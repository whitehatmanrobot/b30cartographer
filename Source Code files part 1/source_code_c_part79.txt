 )
					{
						t_TokenText [ 0 ] = t_Current ;
						t_TokenText [ 1 ] = 0 ;
					}
					else
					{
						return OutOfMemory ;
					}
				}

                t_Read = TRUE ;
			}

            if ( t_Action & StateAction_Consume )
			{
               t_Read = TRUE ;
			}

            if ( t_Action & StateAction_Pushback )
			{
                t_Read = TRUE ;

                a_NextPosition = a_NextPosition - 1 ;
            }

            if ( t_Action & StateAction_Linefeed )
			{
                CurrentLine = CurrentLine + 1 ;
			}

			a_NextPosition = a_NextPosition + 1 ;

            if ( t_Action & StateAction_Return )
			{
                a_Token = t_ReturnToken ;
				a_TokenText = t_TokenText ;

				return t_Status ;
			}

            t_State = t_GotoState ;
        }
		else
		{
            t_State = t_State + 1 ;
		}
	}

	delete [] t_TokenText ;

    return ImpossibleState ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: GetDecoupledImpersonationRestriction ( 

	LPCWSTR a_Hosting , 
	BOOL &a_ImpersonationRestriction 
)
{
	HRESULT t_Result = S_OK ;

	if ( wbem_wcsicmp ( a_Hosting , s_Strings_Wmi_Decoupled ) != 0 )
	{
		if ( wbem_wcsnicmp ( a_Hosting , s_Strings_Wmi_DecoupledColon , ( sizeof ( s_Strings_Wmi_DecoupledColon ) / sizeof ( WCHAR ) - 1 ) ) == 0 )
		{
			const wchar_t *t_Scan = & a_Hosting [ ( sizeof ( s_Strings_Wmi_DecoupledColon ) / sizeof ( WCHAR ) - 1 ) ] ;

			ULONG t_Position = 0 ; 
			ULONG t_Token = 0 ;
			ULONG t_NextPosition = 0 ; 
			wchar_t *t_FoldText = NULL ;

			LexicalStatus t_Status = LexicalAnalyser_NextToken ( 

				g_StateTable ,
				sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
				t_Scan ,
				t_Position , 
				t_Token , 
				t_NextPosition , 
				t_FoldText
			) ;

			if ( ( t_Status == Success ) && ( t_Token == TOKEN_IDENTITY ) && (t_FoldText!=0) && ( wbem_wcsicmp ( t_FoldText , L"FoldIdentity" ) == 0 ) )
			{
				wchar_t *t_IgnoreText = NULL ;

				t_Position = t_NextPosition ;

				t_Status = LexicalAnalyser_NextToken ( 

					g_StateTable ,
					sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
					t_Scan ,
					t_Position , 
					t_Token , 
					t_NextPosition , 
					t_IgnoreText
				) ;

				delete [] t_IgnoreText ;

				if ( ( t_Status == Success ) && ( t_Token == TOKEN_LEFTPARENTHESIS ) )
				{
					wchar_t *t_ValueText = NULL ;

					t_Position = t_NextPosition ;

					t_Status = LexicalAnalyser_NextToken ( 

						g_StateTable ,
						sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
						t_Scan ,
						t_Position , 
						t_Token , 
						t_NextPosition , 
						t_ValueText
					) ;

					if ( ( t_Status == Success ) && ( t_Token == TOKEN_IDENTITY ) && ( wbem_wcsicmp ( t_ValueText , L"TRUE" ) == 0 ) )
					{
						a_ImpersonationRestriction = TRUE ;
					}
					else if ( ( t_Status == Success ) && ( t_Token == TOKEN_IDENTITY ) && ( wbem_wcsicmp ( t_ValueText , L"FALSE" ) == 0 ) )
					{
						a_ImpersonationRestriction = FALSE ;
					}
					else
					{
						t_Status = Syntax_Error ;
					}

					delete [] t_ValueText ;
				}
				else
				{
					t_Status = Syntax_Error ;
				}

				if ( t_Status == Success ) 
				{
					wchar_t *t_IgnoreText = NULL ;

					t_Position = t_NextPosition ;

					t_Status = LexicalAnalyser_NextToken ( 

						g_StateTable ,
						sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
						t_Scan ,
						t_Position , 
						t_Token , 
						t_NextPosition , 
						t_IgnoreText
					) ;

					if ( ( t_Status == Success ) && ( t_Token == TOKEN_RIGHTPARENTHESIS ) )
					{
					}
					else
					{
						t_Status = Syntax_Error ;
					}

					delete [] t_IgnoreText ;
				}

				if ( t_Status == Success ) 
				{
					wchar_t *t_IgnoreText = NULL ;

					t_Position = t_NextPosition ;

					t_Status = LexicalAnalyser_NextToken ( 

						g_StateTable ,
						sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
						t_Scan ,
						t_Position , 
						t_Token , 
						t_NextPosition , 
						t_IgnoreText
					) ;

					if ( ( t_Status == Success ) && ( t_Token == TOKEN_EOF ) )
					{
					}
					else
					{
						t_Status = Syntax_Error ;
					}

					delete [] t_IgnoreText ;
				}
			}
			else
			{
				t_Status = Syntax_Error ;
			}

			delete [] t_FoldText ;

			if ( t_Status != Success ) 
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: GetHosting ( 

	LPCWSTR a_Hosting , 
	Enum_Hosting & a_HostingValue ,
	LPWSTR &a_HostingGroup ,
	BOOL & a_ImpersonationRestriction
)
{
	HRESULT t_Result = S_OK ;

	if ( wbem_wcsicmp ( a_Hosting , s_Strings_Wmi_WmiCore ) == 0 )
	{
		a_HostingValue = e_Hosting_WmiCore ;
	}
	else if ( wbem_wcsicmp ( a_Hosting , s_Strings_Wmi_WmiCoreOrSelfHost ) == 0 )
	{
		a_HostingValue = e_Hosting_WmiCoreOrSelfHost ;
	}
	else if ( wbem_wcsicmp ( a_Hosting , s_Strings_Wmi_SelfHost ) == 0 )
	{
		a_HostingValue = e_Hosting_SelfHost ;
	}
	else if ( wbem_wcsnicmp ( a_Hosting , s_Strings_Wmi_Decoupled , ( sizeof ( s_Strings_Wmi_Decoupled ) / sizeof ( WCHAR ) -1 ) ) == 0 )
	{
		a_HostingValue = e_Hosting_Decoupled ;

		t_Result = GetDecoupledImpersonationRestriction ( 

			a_Hosting , 
			a_ImpersonationRestriction 
		) ;
	}
	else if ( wbem_wcsicmp ( a_Hosting , s_Strings_Wmi_NonCom ) == 0 )
	{
		a_HostingValue = e_Hosting_NonCom ;
	}
	else if ( wbem_wcsnicmp ( a_Hosting , s_Strings_Wmi_SharedLocalSystemHostOrSelfHost , ( sizeof ( s_Strings_Wmi_SharedLocalSystemHostOrSelfHost ) / sizeof ( WCHAR ) - 1 ) ) == 0 )
	{
		t_Result = GetHostingGroup ( 

			a_Hosting , 
			( sizeof ( s_Strings_Wmi_SharedLocalSystemHostOrSelfHost ) / sizeof ( WCHAR ) - 1 ) ,
			e_Hosting_SharedLocalSystemHostOrSelfHost ,
			a_HostingValue ,
			a_HostingGroup
		) ;
	}
	else if ( wbem_wcsnicmp ( a_Hosting , s_Strings_Wmi_SharedLocalSystemHost , ( sizeof ( s_Strings_Wmi_SharedLocalSystemHost ) / sizeof ( WCHAR ) - 1 ) ) == 0 )
	{
		t_Result = GetHostingGroup ( 

			a_Hosting , 
			( sizeof ( s_Strings_Wmi_SharedLocalSystemHost ) / sizeof ( WCHAR ) - 1 ) ,
			e_Hosting_SharedLocalSystemHost ,
			a_HostingValue ,
			a_HostingGroup
		) ;
	}
	else if ( wbem_wcsnicmp ( a_Hosting , s_Strings_Wmi_SharedNetworkServiceHost , ( sizeof ( s_Strings_Wmi_SharedNetworkServiceHost ) / sizeof ( WCHAR ) - 1 ) ) == 0 )
	{
		t_Result = GetHostingGroup ( 

			a_Hosting , 
			( sizeof ( s_Strings_Wmi_SharedNetworkServiceHost ) / sizeof ( WCHAR ) - 1 ) ,
			e_Hosting_SharedNetworkServiceHost ,
			a_HostingValue ,
			a_HostingGroup
		) ;
	}
	else if ( wbem_wcsnicmp ( a_Hosting , s_Strings_Wmi_SharedLocalServiceHost , ( sizeof ( s_Strings_Wmi_SharedLocalServiceHost ) / sizeof ( WCHAR ) - 1 ) ) == 0 )
	{
		t_Result = GetHostingGroup ( 

			a_Hosting , 
			( sizeof ( s_Strings_Wmi_SharedLocalServiceHost ) / sizeof ( WCHAR ) - 1 ) ,
			e_Hosting_SharedLocalServiceHost ,
			a_HostingValue ,
			a_HostingGroup
		) ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object ,
	LPCWSTR a_ProviderName 
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Mask & e_Version )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Version , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_Version = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_Version = 1 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Name )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Name , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_ProviderName ) 
					{
						SysFreeString ( m_ProviderName ) ;
					}

					m_ProviderName = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_ProviderName == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}
			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Enabled )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Enabled , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_Enabled = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_Enabled = TRUE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Clsid  )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Clsid , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					t_Result = CLSIDFromString ( t_Variant.bstrVal , & m_CLSID ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = m_ClsidServer.Load ( (LPCWSTR) t_Variant.bstrVal , a_ProviderName ) ;
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_CLSID = CLSID_NULL ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ClientClsid  )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_ClientClsid , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					t_Result = CLSIDFromString ( t_Variant.bstrVal , & m_ClientCLSID ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_ClientCLSID = CLSID_NULL ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_DefaultMachineName )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_DefaultMachineName , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_DefaultMachineName )
					{
						SysFreeString ( m_DefaultMachineName ) ;
					}

					m_DefaultMachineName = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_DefaultMachineName == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_DefaultMachineName )
					{
						SysFreeString ( m_DefaultMachineName ) ;
						m_DefaultMachineName = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_UnloadTimeout )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_UnloadTimeout , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_UnloadTimeout )
					{
						SysFreeString ( m_UnloadTimeout ) ;
					}

					m_UnloadTimeout = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_UnloadTimeout )
					{
						CWbemDateTime t_Interval ;
						t_Result = t_Interval.PutValue ( m_UnloadTimeout ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT_BOOL t_Bool = VARIANT_FALSE ;
							t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
							if ( t_Bool == VARIANT_TRUE )
							{
								LONG t_MicroSeconds = 0 ;
								LONG t_Seconds = 0 ;
								LONG t_Minutes = 0 ;
								LONG t_Hours = 0 ;
								LONG t_Days = 0 ;

								t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
								t_Interval.GetSeconds ( & t_Seconds ) ;
								t_Interval.GetMinutes ( & t_Minutes ) ;
								t_Interval.GetHours ( & t_Hours ) ;
								t_Interval.GetDay ( & t_Days ) ;

								m_UnloadTimeoutMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
															  ( t_Hours * 60 * 60 * 1000 ) +
															  ( t_Minutes * 60 * 1000 ) +
															  ( t_Seconds * 1000 ) +
															  ( t_MicroSeconds / 1000 ) ;
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_UnloadTimeout )
					{
						SysFreeString ( m_UnloadTimeout ) ;
						m_UnloadTimeout = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ImpersonationLevel )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_ImpersonationLevel , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_I4 )
				{
					switch ( t_Variant.lVal )
					{
						case 0:
						{
							m_ImpersonationLevel = e_Impersonate_None ;		
						}
						break ;

						case 1:
						{
							m_ImpersonationLevel = e_Impersonate ;
						}
						break ;

						default:
						{
							if ( m_Version > 1 )
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
							else
							{
								m_ImpersonationLevel = e_Impersonate_None ;	
							}
						}
						break ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_ImpersonationLevel = e_Impersonate_None ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsSendStatus )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SupportsSendStatus , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsSendStatus = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsSendStatus = TRUE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsShutdown )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SupportsShutdown , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsShutdown = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsShutdown = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsQuotas )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SupportsQuotas , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsQuotas = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsQuotas = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_OperationTimeoutInterval )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_OperationTimeoutInterval , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_OperationTimeout )
					{
						SysFreeString ( m_OperationTimeout ) ;
					}

					m_OperationTimeout = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_OperationTimeout )
					{
						CWbemDateTime t_Interval ;
						t_Result = t_Interval.PutValue ( m_OperationTimeout ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT_BOOL t_Bool = VARIANT_FALSE ;
							t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
							if ( t_Bool == VARIANT_TRUE )
							{
								LONG t_MicroSeconds = 0 ;
								LONG t_Seconds = 0 ;
								LONG t_Minutes = 0 ;
								LONG t_Hours = 0 ;
								LONG t_Days = 0 ;

								t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
								t_Interval.GetSeconds ( & t_Seconds ) ;
								t_Interval.GetMinutes ( & t_Minutes ) ;
								t_Interval.GetHours ( & t_Hours ) ;
								t_Interval.GetDay ( & t_Days ) ;

								m_OperationTimeoutMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
															  ( t_Hours * 60 * 60 * 1000 ) +
															  ( t_Minutes * 60 * 1000 ) +
															  ( t_Seconds * 1000 ) +
															  ( t_MicroSeconds / 1000 ) ;
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_OperationTimeout )
					{
						SysFreeString ( m_OperationTimeout ) ;
						m_UnloadTimeout = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_InitializationTimeoutInterval )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_InitializationTimeoutInterval , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_InitializationTimeout )
					{
						SysFreeString ( m_InitializationTimeout ) ;
					}

					m_InitializationTimeout = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_InitializationTimeout )
					{
						CWbemDateTime t_Interval ;
						t_Result = t_Interval.PutValue ( m_InitializationTimeout ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT_BOOL t_Bool = VARIANT_FALSE ;
							t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
							if ( t_Bool == VARIANT_TRUE )
							{
								LONG t_MicroSeconds = 0 ;
								LONG t_Seconds = 0 ;
								LONG t_Minutes = 0 ;
								LONG t_Hours = 0 ;
								LONG t_Days = 0 ;

								t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
								t_Interval.GetSeconds ( & t_Seconds ) ;
								t_Interval.GetMinutes ( & t_Minutes ) ;
								t_Interval.GetHours ( & t_Hours ) ;
								t_Interval.GetDay ( & t_Days ) ;

								m_InitializationTimeoutMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
															  ( t_Hours * 60 * 60 * 1000 ) +
															  ( t_Minutes * 60 * 1000 ) +
															  ( t_Seconds * 1000 ) +
															  ( t_MicroSeconds / 1000 ) ;
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_InitializationTimeout )
					{
						SysFreeString ( m_InitializationTimeout ) ;
						m_UnloadTimeout = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsThrottling )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SupportsThrottling , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsThrottling = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsThrottling = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ConcurrentIndependantRequests )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_ConcurrentIndependantRequests , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_I4 )
				{
					m_ConcurrentIndependantRequests = t_Variant.lVal ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_ConcurrentIndependantRequests = 0 ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_InitializationReentrancy )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_InitializationReentrancy , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_I4 )
				{
					switch ( t_Variant.lVal )
					{
						case 0:
						{
							m_InitializationReentrancy = e_InitializationReentrancy_Clsid ;		
						}
						break ;

						case 1:
						{
							m_InitializationReentrancy = e_InitializationReentrancy_Namespace ;
						}
						break ;

						case 2:
						{
							m_InitializationReentrancy = e_InitializationReentrancy_None ;
						}
						break ;

						default:
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
						break ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_InitializationReentrancy = e_InitializationReentrancy_Namespace;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_InitializeAsAdminFirst )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_InitializeAsAdminFirst , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_InitializeAsAdminFirst = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_InitializeAsAdminFirst = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_PerUserInitialization )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_PerUserInitialization , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_PerUserInitialization = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_PerUserInitialization = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_PerLocaleInitialization )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_PerLocaleInitialization , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_PerLocaleInitialization = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_PerLocaleInitialization = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Pure )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Pure , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_Pure = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_Pure = TRUE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Hosting )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Hosting , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					t_Result = GetHosting ( t_Variant.bstrVal , m_Hosting , m_HostingGroup , m_DecoupledImpersonationRestriction ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
#ifdef UNIQUE_HOST
						if ( m_HostingGroup )
						{
							SysFreeString ( m_HostingGroup ) ;
						}

						m_HostingGroup = SysAllocString ( GetProviderName () ) ;
						if ( m_HostingGroup == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
#else
#endif
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_Hosting = e_Hosting_SharedLocalSystemHostOrSelfHost ;

#ifdef UNIQUE_HOST
					m_HostingGroup = SysAllocString ( GetProviderName () ) ;
#else
					m_HostingGroup = SysAllocString ( s_Strings_Wmi_DefaultSharedLocalSystemHostOrSelfHost ) ;
#endif
					if ( m_HostingGroup == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		switch ( GetHosting () )
		{
			case e_Hosting_NonCom:
			case e_Hosting_Decoupled:
			{
			}
			break ;

			default:
			{
				if ( GetClsidServer ().GetProviderClsid () == NULL )
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			break ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SecurityDescriptor )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SecurityDescriptor , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					BOOL t_Status = SDDL::ConvertStringSecurityDescriptorToSecurityDescriptor (

						t_Variant.bstrVal ,
						SDDL_REVISION_1 ,
						( PSECURITY_DESCRIPTOR * ) & m_SecurityDescriptor,
						NULL 
					) ;

					if ( t_Status )
					{
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SecurityDescriptor = NULL ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_ObjectPath = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_ObjectPath , 
		L"__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\""
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( m_Identity )
		{
			m_Identity->Release () ;
		}

		t_Result = m_Repository->GetObject ( 

			t_ObjectPath ,
			0 ,
			m_Context , 
			& m_Identity , 
			NULL 
		) ;
	
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = QueryProperties ( 

				a_Mask ,
				m_Identity ,
				a_ProviderName 
			) ;
		}

		SysFreeString ( t_ObjectPath ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( m_Identity )
				{
					m_Identity->Release () ;
				}

				t_Result = m_Repository->GetObject ( 

					t_ObjectPath ,
					0 ,
					m_Context , 
					& m_Identity , 
					NULL 
				) ;
			
				if ( SUCCEEDED ( t_Result ) )
				{
					VARIANT t_Variant ;
					VariantInit ( & t_Variant ) ;
				
					LONG t_VarType = 0 ;
					LONG t_Flavour = 0 ;

					t_Result = m_Identity->Get ( L"Name" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_Variant.vt == VT_BSTR )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								m_Identity ,
								t_Variant.bstrVal
							) ;
						}

						VariantClear ( & t_Variant ) ;
					}
				}

			}

			SysFreeString ( t_ObjectPath ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
				}
			}
		}

		VariantClear ( & t_Variant ) ;

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_InstanceProviderRegistrationV1 :: CServerObject_InstanceProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SupportsPut ( FALSE ) ,
	m_SupportsGet ( FALSE ) ,
	m_SupportsDelete ( FALSE ) ,
	m_SupportsEnumeration ( FALSE ) ,
	m_SupportsBatching ( FALSE ) ,
	m_SupportsTransactions ( FALSE ) ,
	m_Supported ( FALSE ) ,
	m_QuerySupportLevels ( e_QuerySupportLevels_Unknown ) ,
	m_InteractionType ( e_InteractionType_Unknown ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_InstanceProviderRegistrationV1::~CServerObject_InstanceProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_InstanceProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_InstanceProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	if ( a_Mask & e_SupportsPut )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsPut , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsPut = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsPut = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED(t_Result) && (a_Mask & e_SupportsGet) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsGet , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsGet = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsGet = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED(t_Result) && (a_Mask & e_SupportsDelete) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsDelete , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsDelete = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsDelete = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED(t_Result) && (a_Mask & e_SupportsEnumeration) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsEnumeration , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsEnumeration = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsEnumeration = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED(t_Result) && (a_Mask & e_SupportsBatching) )
	{   
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsBatching , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsBatching = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsBatching = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED(t_Result) && (a_Mask & e_SupportsTransactions) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsTransactions , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsTransactions = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsTransactions = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if (SUCCEEDED(t_Result) && ( a_Mask & e_QuerySupportLevels ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_QuerySupportLevels , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == ( VT_BSTR | VT_ARRAY ) )
			{
				if ( SafeArrayGetDim ( t_Variant.parray ) == 1 )
				{
					LONG t_Dimension = 1 ; 

					LONG t_Lower ;
					SafeArrayGetLBound ( t_Variant.parray , t_Dimension , & t_Lower ) ;

					LONG t_Upper ;
					SafeArrayGetUBound ( t_Variant.parray , t_Dimension , & t_Upper ) ;

					LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

					if ( t_Count ) 
					{
						for ( LONG t_ElementIndex = t_Lower ; t_ElementIndex <= t_Upper ; t_ElementIndex ++ )
						{
							BSTR t_Element ;
							if ( SUCCEEDED ( SafeArrayGetElement ( t_Variant.parray , &t_ElementIndex , & t_Element ) ) )
							{
								if ( wbem_wcsicmp ( s_Strings_QuerySupportLevels_UnarySelect , t_Element ) == 0 )
								{
									m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_UnarySelect ;
								}
								else if ( wbem_wcsicmp ( s_Strings_QuerySupportLevels_References , t_Element ) == 0 )
								{
									m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_References ;
								}
								else if ( wbem_wcsicmp ( s_Strings_QuerySupportLevels_Associators , t_Element ) == 0 )
								{
									m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_Associators ;
								}
								else if ( wbem_wcsicmp ( s_Strings_QuerySupportLevels_V1ProviderDefined , t_Element ) == 0 )
								{
									m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_V1ProviderDefined ;
								}
								else
								{
									t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
								}

								SysFreeString ( t_Element ) ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_QuerySupportLevels = e_QuerySupportLevels_None ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if (SUCCEEDED(t_Result) && ( a_Mask & e_InteractionType) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_InteractionType , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				switch ( t_Variant.lVal )
				{
					case 0:
					{
						m_InteractionType = e_InteractionType_Pull ;
					}
					break ;

					case 1:
					{
						m_InteractionType = e_InteractionType_Push ;
					}
					break ;

					case 2:
					{
						m_InteractionType = e_InteractionType_PushVerify ;
					}
					break ;

					default:
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
					break ;
				}
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_InteractionType = e_InteractionType_Pull ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( wbem_wcsicmp ( s_Strings_InstanceProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery ( 

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY;
		}

			
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ClassProviderRegistrationV1 :: CServerObject_ClassProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SupportsPut ( FALSE ) ,
	m_SupportsGet ( FALSE ) ,
	m_SupportsDelete ( FALSE ) ,
	m_SupportsEnumeration ( FALSE ) ,
	m_SupportsBatching ( FALSE ) ,
	m_SupportsTransactions ( FALSE ) ,
	m_Supported ( FALSE ) ,
	m_ReSynchroniseOnNamespaceOpen ( FALSE ) ,
	m_PerUserSchema ( FALSE ) ,
	m_HasReferencedSet( FALSE ),
	m_CacheRefreshInterval ( NULL ) ,
	m_CacheRefreshIntervalMilliSeconds ( 0 ) ,
	m_QuerySupportLevels ( e_QuerySupportLevels_Unknown ) ,
	m_InteractionType ( e_InteractionType_Unknown ) ,
	m_ResultSetQueryTreeCount ( 0 ) ,
	m_UnSupportedQueryTreeCount ( 0 ) ,
	m_ReferencedSetQueryTreeCount ( 0 ) ,
	m_ResultSetQueryTree ( NULL ) ,
	m_UnSupportedQueryTree ( NULL ) ,
	m_ReferencedSetQueryTree ( NULL ) ,
	m_ProviderName ( NULL ) ,
	m_Version ( 1 ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ClassProviderRegistrationV1::~CServerObject_ClassProviderRegistrationV1 ()
{
	if ( m_ResultSetQueryTree )
	{
		for ( ULONG t_Index = 0 ; t_Index < m_ResultSetQueryTreeCount ; t_Index ++ )
		{
			if ( m_ResultSetQueryTree [ t_Index ] )
			{
				delete m_ResultSetQueryTree [ t_Index ] ;
			}
		}

		delete [] m_ResultSetQueryTree ;
	}

	if ( m_UnSupportedQueryTree )
	{
		for ( ULONG t_Index = 0 ; t_Index < m_UnSupportedQueryTreeCount ; t_Index ++ )
		{
			if ( m_UnSupportedQueryTree [ t_Index ] )
			{
				delete m_UnSupportedQueryTree [ t_Index ] ;
			}
		}

		delete [] m_UnSupportedQueryTree ;
	}

	if ( m_ReferencedSetQueryTree )
	{
		for ( ULONG t_Index = 0 ; t_Index < m_ReferencedSetQueryTreeCount ; t_Index ++ )
		{
			if ( m_ReferencedSetQueryTree [ t_Index ] )
			{
				delete m_ReferencedSetQueryTree [ t_Index ] ;
			}
		}

		delete [] m_ReferencedSetQueryTree ;
	}

	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}

	if ( m_ProviderName ) 
	{
		delete [] m_ProviderName ;
	}

	if ( m_CacheRefreshInterval )
	{
		SysFreeString ( m_CacheRefreshInterval ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ClassProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ClassProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: ParseQuery ( 

	ULONG &a_Count ,
	WmiTreeNode **&a_Root , 
	SAFEARRAY *a_Array
)

{
	HRESULT t_Result = S_OK ;

	if ( SafeArrayGetDim ( a_Array ) == 1 )
	{
		LONG t_Dimension = 1 ; 

		LONG t_Lower ;
		SafeArrayGetLBound ( a_Array , t_Dimension , & t_Lower ) ;

		LONG t_Upper ;
		SafeArrayGetUBound ( a_Array , t_Dimension , & t_Upper ) ;

		LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

		a_Root = NULL ;
		a_Count = t_Count ;

		if ( t_Count )
		{
			a_Root = new WmiTreeNode * [ t_Count ] ;
			if ( a_Root ) 
			{
				ZeroMemory ( a_Root , sizeof ( WmiTreeNode * ) * t_Count ) ;

				for ( LONG t_ElementIndex = t_Lower ; SUCCEEDED ( t_Result ) && ( t_ElementIndex <= t_Upper ) ; t_ElementIndex ++ )
				{
					BSTR t_Element ;
					if ( SUCCEEDED ( t_Result = SafeArrayGetElement ( a_Array , &t_ElementIndex , & t_Element ) ) )
					{
						QueryPreprocessor t_PreProcessor ;

						IWbemQuery *t_QueryAnalyser = NULL ;
						t_Result = CoCreateInstance (

							CLSID_WbemQuery ,
							NULL ,
							CLSCTX_INPROC_SERVER ,
							IID_IWbemQuery ,
							( void ** ) & t_QueryAnalyser
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							switch ( t_PreProcessor.Query ( t_Element , t_QueryAnalyser ) )
							{
								case QueryPreprocessor :: State_True:
								{
									WmiTreeNode *t_Root = NULL ;

									switch ( t_PreProcessor.PreProcess ( m_Context , t_QueryAnalyser , t_Root ) )
									{
										case QueryPreprocessor :: State_True:
										{
											a_Root [ t_ElementIndex - t_Lower ] = t_Root ;
										}
										break ;

										case QueryPreprocessor :: State_Error:
										{
											t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
										}
										break;

										default:
										{
											t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
										}
										break ;
									}
								}
								break ;

								case QueryPreprocessor :: State_Error:
								{
									t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
								}
								break;

								default:
								{
									t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
								}
								break ;

							}

							t_QueryAnalyser->Release () ;
						}

						SysFreeString ( t_Element ) ;
					}
				}

				if ( FAILED ( t_Result ) ) 
				{
					for ( LONG t_ElementIndex = t_Lower ; t_ElementIndex <= t_Upper ; t_ElementIndex ++ )
					{
						delete a_Root [ t_ElementIndex  - t_Lower] ;
					}

					delete [] a_Root ;
					a_Root = NULL ;
					a_Count = 0 ;

					if ( m_Version == 1 )
					{
						t_Result = S_OK ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	if ( a_Mask & e_Version )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_Version , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_Version = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_Version = 1 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsPut )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsPut , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsPut = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsPut = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsGet )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsGet , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsGet = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsGet = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsDelete )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsDelete , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsDelete = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsDelete = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsEnumeration )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsEnumeration , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsEnumeration = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsEnumeration = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsBatching )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsBatching , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsBatching = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsBatching = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsTransactions )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsTransactions , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsTransactions = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsTransactions = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_PerUserSchema )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_PerUserSchema , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_PerUserSchema = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_PerUserSchema = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ReSynchroniseOnNamespaceOpen )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_ReSynchroniseOnNamespaceOpen , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_ReSynchroniseOnNamespaceOpen = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_ReSynchroniseOnNamespaceOpen = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_QuerySupportLevels  )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_QuerySupportLevels , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == ( VT_BSTR | VT_ARRAY ) )
				{
					if ( SafeArrayGetDim ( t_Variant.parray ) == 1 )
					{
						LONG t_Dimension = 1 ; 

						LONG t_Lower ;
						SafeArrayGetLBound ( t_Variant.parray , t_Dimension , & t_Lower ) ;

						LONG t_Upper ;
						SafeArrayGetUBound ( t_Variant.parray , t_Dimension , & t_Upper ) ;

						LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

						if ( t_Count )
						{
							for ( LONG t_ElementIndex = t_Lower ; t_ElementIndex <= t_Upper ; t_ElementIndex ++ )
							{
								BSTR t_Element ;
								if ( SUCCEEDED ( SafeArrayGetElement ( t_Variant.parray , &t_ElementIndex , & t_Element ) ) )
								{
									if ( wbem_wcsicmp ( s_Strings_QuerySupportLevels_UnarySelect , t_Element ) == 0 )
									{
										m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_UnarySelect ;
									}
									else if ( wbem_wcsicmp ( s_Strings_QuerySupportLevels_References , t_Element ) == 0 )
									{
										m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_References ;
									}
									else if ( wbem_wcsicmp ( s_Strings_QuerySupportLevels_Associators , t_Element ) == 0 )
									{
										m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_Associators ;
									}
									else if ( wbem_wcsicmp ( s_Strings_QuerySupportLevels_V1ProviderDefined , t_Element ) == 0 )
									{
										m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_V1ProviderDefined ;
									}
									else
									{
										t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
									}

									SysFreeString ( t_Element ) ;
								}
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_QuerySupportLevels = e_QuerySupportLevels_None ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_InteractionType )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_InteractionType , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_I4 )
				{
					switch ( t_Variant.lVal )
					{
						case 0:
						{
							m_InteractionType = e_InteractionType_Pull ;
						}
						break ;

						case 1:
						{
							m_InteractionType = e_InteractionType_Push ;
						}
						break ;

						case 2:
						{
							m_InteractionType = e_InteractionType_PushVerify ;
						}
						break ;

						default:
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
						break ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_InteractionType = e_InteractionType_Pull ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ResultSetQueries )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_ResultSetQueries , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == ( VT_ARRAY | VT_BSTR ) )
				{
					t_Result = ParseQuery ( m_ResultSetQueryTreeCount , m_ResultSetQueryTree , t_Variant.parray ) ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
				}
				else
				{
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_UnSupportedQueries )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_UnSupportedQueries , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == ( VT_ARRAY | VT_BSTR ) )
				{
					t_Result = ParseQuery ( m_UnSupportedQueryTreeCount , m_UnSupportedQueryTree , t_Variant.parray ) ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
				}
				else
				{
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ReferencedSetQueries )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_ReferencedSetQueries , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == ( VT_ARRAY | VT_BSTR ) )
				{
					t_Result = ParseQuery ( m_ReferencedSetQueryTreeCount , m_ReferencedSetQueryTree , t_Variant.parray ) ;

					// Backwards compatibility.
					// W2K code, Query is not really parsed, as long as there is a
					// value, m_HasReferencedSet is TRUE.
					LONG t_Lower ;
					SafeArrayGetLBound ( t_Variant.parray , 1 , & t_Lower ) ;

					LONG t_Upper ;
					SafeArrayGetUBound ( t_Variant.parray , 1 , & t_Upper ) ;

					LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

					m_HasReferencedSet = ( ( t_Upper - t_Lower ) + 1 ) > 0;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
				}
				else
				{
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_CacheRefreshInterval )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_CacheRefreshInterval , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_CacheRefreshInterval )
					{
						SysFreeString ( m_CacheRefreshInterval ) ;
					}

					m_CacheRefreshInterval = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_CacheRefreshInterval )
					{
						CWbemDateTime t_Interval ;
						t_Result = t_Interval.PutValue ( m_CacheRefreshInterval ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT_BOOL t_Bool = VARIANT_FALSE ;
							t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
							if ( t_Bool == VARIANT_TRUE )
							{
								LONG t_MicroSeconds = 0 ;
								LONG t_Seconds = 0 ;
								LONG t_Minutes = 0 ;
								LONG t_Hours = 0 ;
								LONG t_Days = 0 ;

								t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
								t_Interval.GetSeconds ( & t_Seconds ) ;
								t_Interval.GetMinutes ( & t_Minutes ) ;
								t_Interval.GetHours ( & t_Hours ) ;
								t_Interval.GetDay ( & t_Days ) ;

								m_CacheRefreshIntervalMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
															  ( t_Hours * 60 * 60 * 1000 ) +
															  ( t_Minutes * 60 * 1000 ) +
															  ( t_Seconds * 1000 ) +
															  ( t_MicroSeconds / 1000 ) ;
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_CacheRefreshInterval )
					{
						SysFreeString ( m_CacheRefreshInterval ) ;
						m_CacheRefreshInterval = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			else if (t_TempResult != WBEM_E_NOT_FOUND)
			{
				t_Result = t_TempResult;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( ( m_InteractionType == e_InteractionType_Pull ) && ( ( m_SupportsEnumeration == FALSE ) || ( m_SupportsGet == FALSE ) ) )
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( wbem_wcsicmp ( s_Strings_ClassProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			m_ProviderName = new wchar_t [ wcslen ( a_ProviderName ) + 1 ] ;
			if ( m_ProviderName ) 
			{
				StringCchCopy ( m_ProviderName , wcslen ( a_ProviderName ) + 1,  a_ProviderName ) ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemPathKeyList *t_Keys = NULL ;

						t_Result = a_Provider->GetKeyList (

							& t_Keys 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							ULONG t_ProviderNameLength = 0 ;
							ULONG t_Type = 0 ;

							t_Result = t_Keys->GetKey (

								0 ,
								0 ,
								NULL ,
								NULL ,
								& t_ProviderNameLength ,
								m_ProviderName ,
								& t_Type
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								m_ProviderName = new wchar_t [ ( t_ProviderNameLength / sizeof ( wchar_t ) ) + 1 ] ;
								if ( m_ProviderName ) 
								{
									t_Result = t_Keys->GetKey (

										0 ,
										0 ,
										NULL ,
										NULL ,
										& t_ProviderNameLength ,
										m_ProviderName ,
										& t_Type
									) ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY;
								}
							}

							t_Keys->Release () ;
						}
					}
					
					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath * a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	if ( FAILED ( t_Result ) )
	{
		m_Result = t_Result ;
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_MethodProviderRegistrationV1 :: CServerObject_MethodProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SupportsMethods ( FALSE ) ,
	m_Supported ( FALSE ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_MethodProviderRegistrationV1::~CServerObject_MethodProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_MethodProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_MethodProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_SupportsMethods = TRUE ;

	m_Supported = TRUE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( wbem_wcsicmp ( s_Strings_MethodProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DynamicPropertyProviderRegistrationV1 :: CServerObject_DynamicPropertyProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SupportsPut ( FALSE ) ,
	m_SupportsGet ( FALSE ) ,
	m_Supported ( FALSE ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DynamicPropertyProviderRegistrationV1::~CServerObject_DynamicPropertyProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DynamicPropertyProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DynamicPropertyProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	if ( a_Mask & e_SupportsPut )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsPut , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsPut = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsPut = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED(t_Result) && (a_Mask & e_SupportsGet) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsGet , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsGet = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsGet = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else if (t_TempResult != WBEM_E_NOT_FOUND)
		{
			t_Result = t_TempResult;
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( wbem_wcsicmp ( s_Strings_PropertyProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_EventProviderRegistrationV1 :: CServerObject_EventProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Supported ( FALSE ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_EventProviderRegistrationV1::~CServerObject_EventProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_EventProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_EventProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( wbem_wcsicmp ( s_Strings_EventProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_EventConsumerProviderRegistrationV1 :: CServerObject_EventConsumerProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Supported ( FALSE ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_EventConsumerProviderRegistrationV1::~CServerObject_EventConsumerProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_EventConsumerProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_EventConsumerProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( wbem_wcsicmp ( s_Strings_EventConsumerProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRegistrationV1 :: CServerObject_ProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Result ( S_OK ) ,
	m_ReferenceCount ( 0 )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRegistrationV1::~CServerObject_ProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	t_Result = m_ComRegistration.SetContext ( 

		a_Context ,
		a_Namespace ,
		a_Repository
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( wbem_wcsicmp ( s_Strings_InstanceProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_InstanceProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( wbem_wcsicmp ( s_Strings_ClassProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_ClassProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( wbem_wcsicmp ( s_Strings_MethodProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_MethodProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( wbem_wcsicmp ( s_Strings_PropertyProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_PropertyProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( wbem_wcsicmp ( s_Strings_EventProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_EventProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( wbem_wcsicmp ( s_Strings_EventConsumerProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_EventConsumerProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = m_ComRegistration.QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepository ( 
	
						a_Mask ,
						a_Scope , 
						t_Variant.bstrVal
					) ;
				}

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = m_ComRegistration.QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepository ( 

			a_Mask ,
			a_Scope , 
			a_Provider
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = m_ComRegistration.QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepository ( 

			a_Mask ,
			a_Scope , 
			a_Provider
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CServerObject_ProviderRegistrationV1 :: ObjectProvider ()
{
	BOOL t_Supported =	GetClassProviderRegistration ().Supported () ||
						GetInstanceProviderRegistration ().Supported () ||
						GetMethodProviderRegistration ().Supported () || 
						GetPropertyProviderRegistration ().Supported () ;

	return t_Supported ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CServerObject_ProviderRegistrationV1 :: EventProvider ()
{
	BOOL t_Supported =	GetEventConsumerProviderRegistration ().Supported () ||
						GetEventProviderRegistration ().Supported () ;

	return t_Supported ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\sources.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=precomp.h

!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETPATH=obj
TARGETNAME=Wmidcad
TARGETTYPE=DYNLINK

TARGETLIBS= \
	$(WBEMINT_LIB) \
	$(WMIIDL_LIB) \
	$(WBEMCOMN_STATIC_LIB) \
	$(STDLIBRARY_LIB) \
	$(NCOBJAPI_LIB) \
	$(SDK_LIB_PATH)\ntdll.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\uuid.lib


INCLUDES=$(INCLUDES); \
	..\include;\
	$(WBEMSVC_INC);\
	$(WBEMCOMN_INC); \
	$(CONTAINER_INC); \
	$(CONTAINER_SRC); \
	$(NC_COMMON); \
	$(WMIREPOSITIDL_INC); \
	$(STDLIBRARY_INC); \
	$(UTILLIB_INC); \

SOURCES=\
	..\ver.rc \
	..\Globals.cpp \
	..\Maindll.cpp \
	..\aggregator.cpp \
	..\provwsvs.cpp \
	..\ProvInSk.cpp \
	..\ProvObSk.cpp \
	..\ProvCache.cpp \
	..\registar.cpp \
	..\callsec.cpp \
	..\proxy.cpp \
	..\ProvRegistrar.cpp \
	..\ProvEvents.cpp \
	..\ProvEvt.cpp \
	..\provinterceptor.cpp \
	..\provdwsv.cpp \
	..\DateTime.cpp \
	..\ProvObjectSink.cpp \
	..\CGlobals.cpp \
	..\ProvRegDeCoupled.cpp \
	..\ssdlhelper.cpp \
	..\os.cpp \
	..\ProvRegInfo.cpp \
	..\ProvDnf.cpp \
	..\ProvTree.cpp \



C_DEFINES=$(C_DEFINES) /D_WIN32_DCOM
USE_NATIVE_EH=ASYNC
USE_RTTI=1
USE_MSVCRT=1
USE_VCCOM=1
USE_STL=1

DLLENTRY=_DllMainCRTStartup
DLLDEF=$(O)\adapter.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\proxy.cpp ===
#include "precomp.h"
#include <objbase.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <wmiutils.h>
#include "Globals.h"
#include "ProvRegDeCoupled.h"
#include <wmiutils.h>
#include "CGlobals.h"
#include "provcache.h"
#include "aggregator.h"
#include "ProvWsvS.h"
#include "ProvWsv.h"
#include "ProvInSk.h"
#include "ProvobSk.h"

#include <genlex.h>
#include <flexarry.h>
#include <wqllex.h>

struct SWQLColRef;
#include <wqlscan.h>
#include <autoptr.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DCProxy :: DCProxy ( ) : m_ReferenceCount ( 0 ) , 
	event_only_(false),
	m_Sink(NULL),
	NULL_IWbemServices( WBEM_E_NOT_AVAILABLE )
{
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals::s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DCProxy :: ~DCProxy ()
{
  if (m_aggregator_)
       	m_aggregator_->deActivate();

  InterlockedDecrement (&DecoupledProviderSubSystem_Globals::s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) DCProxy :: AddRef ( void )
{
	return InterlockedIncrement (&m_ReferenceCount) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) DCProxy :: Release ( void )
{
	LONG t_Reference = InterlockedDecrement (&m_ReferenceCount);
	if (  0 == t_Reference )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Reference ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP 
DCProxy :: QueryInterface ( REFIID iid , LPVOID FAR *iplpv ) 
{
  if (iplpv == 0)
    return E_POINTER;
  
  if (iid == IID_IUnknown)
    {
    *iplpv = static_cast<NULL_IWbemServices*>(this) ;
    }
  else if (iid == IID_IWbemServices)
    {
    *iplpv = static_cast<IWbemServices *>(this) ;
    }
  else if (iid == IID_IWbemPropertyProvider)
    {
    *iplpv = static_cast<IWbemPropertyProvider *>(this);
    }
  else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = static_cast<IWbemProviderInit *>(this) ;		
	}	
  else if ( iid == IID_IWbemEventProvider )
	{
		*iplpv = static_cast<IWbemEventProvider *>(this) ;	
	}	
  else if ( iid == IID_IWbemEventProviderSecurity )
	{
		*iplpv = static_cast<IWbemEventProviderSecurity *>(this) ;	
	}	
  else if ( iid == IID_IWbemProviderIdentity )
	{
		*iplpv = static_cast<IWbemProviderIdentity *>(this) ;	
	}
  else if ( iid == IID_IWbemEventProviderQuerySink)
	{
		*iplpv = static_cast<IWbemEventProviderQuerySink *>(this) ;	
	}
  else
	  { 
	  *iplpv = 0;
	  return E_NOINTERFACE;
	  }

	DCProxy::AddRef () ;
	return S_OK;
}





/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
      

HRESULT DCProxy :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_CoreService,         // For anybody
	IWbemContext *a_Context,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	// The connection to the agregator is deffered

	if( !a_Sink)
		return WBEM_E_INVALID_PARAMETER;
	
	if(!a_CoreService )
		return a_Sink->SetStatus ( WBEM_E_INVALID_PARAMETER , 0 ) ;
	
	m_CoreService = a_CoreService;
	m_Context = a_Context;
	m_Flags = a_Flags;

	try{
		m_User = a_User;
		m_Locale = a_Locale;
		m_Namespace = a_Namespace;
		// Register the Registrar
		if (DC_registrar::instance())
			DC_registrar::instance()->Save();

		}
	catch( _com_error& err)
	{
		return a_Sink->SetStatus ( WBEM_E_OUT_OF_MEMORY , 0 ) ;
	}

	// Instance provider - we don't know the provider name
	// The real initialization is deffered
	
	if(!event_only_)
		return a_Sink->SetStatus ( S_OK , 0 ) ;

	// Event provider - safely to initialize
	HRESULT hr  = _initialize();

	return a_Sink->SetStatus ( hr , 0 ) ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/



HRESULT 
DCProxy::GetObjectAsync (const BSTR a_ObjectPath, 
			 long a_Flags, 
			 IWbemContext *a_Context,
			 IWbemObjectSink *a_Sink) 
{

  HRESULT t_Result = initialize_from_instance (a_ObjectPath);
  if (FAILED (t_Result))
    return WBEM_E_FAILED;

  return m_aggregator_->GetObjectAsync( a_ObjectPath, a_Flags, a_Context, a_Sink );
}



HRESULT DCProxy :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags ,
    IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = initialize( a_Instance );
	if ( FAILED (t_Result ) )
		return t_Result;
	
	return m_aggregator_->PutInstanceAsync( a_Instance, a_Flags, a_Context, a_Sink );
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT 
DCProxy :: DeleteInstanceAsync (
  const BSTR a_ObjectPath,
  long a_Flags,
  IWbemContext *a_Context,
  IWbemObjectSink *a_Sink
)
{
  HRESULT t_Result = initialize_from_instance (a_ObjectPath);
  if (FAILED (t_Result))
    return WBEM_E_FAILED;

  return m_aggregator_->DeleteInstanceAsync(a_ObjectPath, a_Flags, a_Context, a_Sink );
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DCProxy::CreateInstanceEnumAsync (const BSTR a_Class ,
				  long a_Flags ,
				  IWbemContext *a_Context ,
				  IWbemObjectSink *a_Sink) 
{
  HRESULT t_Result = initialize (a_Class);
  if (FAILED (t_Result))
    return t_Result;
  
  return m_aggregator_->CreateInstanceEnumAsync (a_Class,
						 a_Flags,
						 a_Context,
						 a_Sink);
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DCProxy::ExecMethodAsync (const BSTR a_ObjectPath,
			    const BSTR a_MethodName,
			    long a_Flags,
			    IWbemContext *a_Context,
			    IWbemClassObject *a_InParams,
			    IWbemObjectSink *a_Sink) 
{
  HRESULT t_Result = initialize (a_ObjectPath);
  
  if (FAILED (t_Result))
    return t_Result;

  return m_aggregator_->ExecMethodAsync (a_ObjectPath,
					 a_MethodName,
					 a_Flags  , 
					 a_Context,
					 a_InParams,
					 a_Sink);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DCProxy::ProvideEvents (IWbemObjectSink *a_Sink ,
			long a_Flags)
{
  if (m_aggregator_)
    return m_aggregator_->ProvideEvents (a_Sink, a_Flags);
  else
    return WBEM_E_FAILED;
}


bool 
DCProxy::initialized ()
{
  return m_aggregator_;
};


HRESULT 
DCProxy::_initialize ()
{
  DC_DBkey key( m_User, m_Locale, m_Namespace, m_ProviderName);

	auto_ref<DCProxyAggr> tmp = DC_registrar::instance()->GetAggregator( key );

	if( tmp )
	{
		if ( tmp->initialized() )
		{
			m_aggregator_ = tmp;
			m_aggregator_->activate();
			return S_OK;
		}


		CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
		if (t_ProviderInitSink)
		{
		  t_ProviderInitSink->AddRef();
		
    		HRESULT hr = tmp ->Initialize( 
    				(wchar_t *)m_User,
    				m_Flags,
    				(wchar_t *)m_Namespace,
    				(wchar_t *)m_Locale,
    				(wchar_t *)m_ProviderName,
    				m_CoreService.GetInterfacePtr(), 
    				m_Context.GetInterfacePtr(),
    				t_ProviderInitSink 
    			);

		    t_ProviderInitSink->Release();
    		if( SUCCEEDED ( hr) )
    		{
    			m_aggregator_ = tmp;
    			m_aggregator_->activate();
    		};
		return hr;
		}
		else
		  return WBEM_E_OUT_OF_MEMORY ;
	}
	else
		return WBEM_E_OUT_OF_MEMORY ;

};

HRESULT 
DCProxy ::initialize (IWbemClassObject * pObj)
{
  if (initialized()) return S_OK;

  _variant_t v;
  HRESULT hr = pObj->Get(L"__CLASS", 0, &v, 0, 0);

  // check the HRESULT to see if the action succeeded
  if (SUCCEEDED (hr))
  {
    return initialize ( _bstr_t (v)); 
  }

  return WBEM_E_FAILED;
};

HRESULT 
DCProxy::initialize (const BSTR _name)
{
    if (initialized ())
    return S_OK;

    LockGuard<CriticalSection> t_guard( DC_registrar::instance()->GetLock());
    if (t_guard.locked()==false)
    return WBEM_E_OUT_OF_MEMORY;

    // Double checked looking variant
    if (initialized ())
    return S_OK;

    IWbemClassObject * t_ObjectPath = NULL ;
    IWbemClassObject *Identity ;

    HRESULT t_Result = m_CoreService->GetObject (_name ,
                                            0 ,
                                            m_Context , 
                                            & Identity , 
                                            NULL) ;
    if (FAILED (t_Result))
    return t_Result;

    IWbemQualifierSet *t_QualifierObject = NULL ;

    t_Result = Identity->GetQualifierSet (&t_QualifierObject);

    if (SUCCEEDED (t_Result))
    {
        _variant_t prov_name;
        t_Result  = t_QualifierObject->Get (L"provider", 0, & prov_name, NULL);
        if (SUCCEEDED (t_Result))
        {
            m_ProviderName = (_bstr_t)prov_name;
        };
        t_QualifierObject->Release();
    }
    return _initialize();
}


HRESULT 
DCProxy::initialize_from_instance (const BSTR _path)
{
    if (initialized ())
    return S_OK;

    wchar_t * pszClassName = NULL;

    IWbemPathPtr pPath;
    HRESULT t_Result = pPath.CreateInstance (CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER);

    if (SUCCEEDED (t_Result))
    {
        t_Result = pPath->SetText (WBEMPATH_CREATE_ACCEPT_ALL , _path) ;
        if (SUCCEEDED (t_Result))
        {
            ULONG uBuf = 0;
            t_Result = pPath->GetClassName(&uBuf, 0);
            if (SUCCEEDED (t_Result))
            {
                pszClassName = new wchar_t[uBuf+1];
                if (pszClassName == 0) 
                return WBEM_E_OUT_OF_MEMORY;

                wmilib::auto_buffer<wchar_t> deleteArray(pszClassName);

                t_Result = pPath->GetClassName(&uBuf, pszClassName);
                if (FAILED(t_Result))
                {
                    return WBEM_E_FAILED;
                }
                t_Result = initialize (pszClassName);
            }
        }
    }
    return t_Result;  // The return code is used internally
}


HRESULT DCProxy ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	if( m_aggregator_ )
		return m_aggregator_ ->AccessCheck ( a_QueryLanguage, a_Query, a_SidLength, a_Sid);
	else
		return WBEM_E_FAILED;
}


HRESULT 
DCProxy::SetRegistrationObject(
  long lFlags,
  IWbemClassObject* pProvReg
  )
{
	HRESULT t_Result = WBEM_E_FAILED;

	_variant_t v;
	t_Result = pProvReg->Get(L"NAME", 0, &v, 0, 0);

	// check the HRESULT to see if the action succeeded
	if ( SUCCEEDED( t_Result) )
	{
		m_ProviderName = (_bstr_t)v;
		event_only_ = true;
		return WBEM_S_NO_ERROR;
	}
	else
	{
		return WBEM_E_FAILED;
	}
};

HRESULT 
DCProxy::NewQuery(
		unsigned long dwId,
		WBEM_WSTR wszQueryLanguage,
		WBEM_WSTR wszQuery
)
{
	if( !initialized() )
		return WBEM_E_FAILED;

	return m_aggregator_->NewQuery( dwId, wszQueryLanguage, wszQuery );
}

HRESULT 
DCProxy::CancelQuery( unsigned long dwId )
{
	if( !initialized() )
		return WBEM_E_FAILED;
	return m_aggregator_->CancelQuery( dwId );
};


HRESULT 
DCProxy::ExecQueryAsync(
  const BSTR strQueryLanguage,                
  const BSTR strQuery,                        
  long lFlags,                       
  IWbemContext *pCtx,              
  IWbemObjectSink *pResponseHandler  
)
{

    // Try to parse it
    // ===============

    CTextLexSource src(strQuery);
    CWQLScanner Parser(&src);
    int nRes = Parser.Parse();
    if(nRes != CWQLScanner::SUCCESS)
    {
        return WBEM_E_INVALID_QUERY;
    }

    // Successfully parsed. Go to the first tables involved
    // ======================================================

    CWStringArray awsTables;
    Parser.GetReferencedTables(awsTables);

    if (awsTables.Size()>0)
    {
        HRESULT t_Result = initialize( awsTables[0] );
        if (SUCCEEDED(t_Result))
        {
            return m_aggregator_->ExecQueryAsync( 
                                                strQueryLanguage, 
                                                strQuery, 
                                                lFlags, 
                                                pCtx, 
                                                pResponseHandler );
        }
        else
            return t_Result;
    
    }
    else
    {
        return WBEM_E_FAILED;
    }
};

STDMETHODIMP 
DCProxy::GetProperty( long lFlags, const BSTR strLocale, const BSTR strClassMapping, 
		      const BSTR strInstMapping, const BSTR strPropMapping, VARIANT *pvValue )
  {

  return WBEM_S_FALSE;
  };


STDMETHODIMP 
DCProxy::PutProperty( long lFlags, const BSTR strLocale, const BSTR strClassMapping, 
		      const BSTR strInstMapping, const BSTR strPropMapping,  const VARIANT *pvValue )
  {

  return WBEM_S_FALSE;
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\registar.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/


#include "precomp.h"
#include <objbase.h>
#include <wbemint.h>
#include <wbemcli.h>
#include "Globals.h"
#include "ProvRegDeCoupled.h"
#include <wmiutils.h>
#include "CGlobals.h"
#include "provcache.h"
#include "aggregator.h"
#include "ProvWsvS.h"
#include <assertbreak.h>
#include <dothrow.h>
#include <os.h>
class DCProxyAggr;


DC_reg::DC_reg( const DC_reg& rhs ): 
		service_(rhs.service_), context_(rhs.context_),
		flags_( rhs.flags_), 
		CServerObject_DecoupledClientRegistration_Element() 
	{ 
		*(CServerObject_DecoupledClientRegistration_Element *)(this) = rhs; 
	};

HRESULT 
DC_reg::Load(	
		long a_Flags,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		IUnknown *a_Unknown ,
		GUID a_Identity )
	{

		wchar_t identity[] = L"{00000000-0000-0000-0000-000000000000}";

		StringFromGUID2 ( a_Identity, identity, sizeof(identity)/sizeof(identity[0]) ) ;

		HRESULT t_Result;
		
		if ( 
			FAILED ( t_Result = SetScope( const_cast<LPWSTR>(a_Scope) ) ) ||
			FAILED ( t_Result = SetProvider( const_cast<LPWSTR>(a_Registration) ) ) ||
			FAILED ( t_Result = SetUser ( const_cast<LPWSTR>(a_User) ) ) ||
			FAILED ( t_Result = SetLocale( const_cast<LPWSTR>(a_Locale) ) ) ||
			FAILED ( t_Result = SetClsid( const_cast<LPWSTR>(identity) ) )
			)
			return t_Result;

		flags_ = a_Flags;
		service_ = a_Unknown;
		context_ = a_Context;

		return t_Result;
	};


const DC_reg& 
DC_reg::operator=(const DC_reg& rhs)
	{
		CServerObject_DecoupledClientRegistration_Element(*this) = rhs;
		service_ = rhs.service_;
		context_ = rhs.context_;
		return *this;
	};


GUID 
DC_reg::identity()
	{
		GUID t_Identity ;
		CLSIDFromString ( GetClsid () , & t_Identity ) ;
		return t_Identity;
	};




IUnknownPtr 
DC_reg::service() 
{ 
	if( service_ )
		return service_;

	BSTR t_CreationTime = GetCreationTime () ;
	DWORD t_ProcessIdentifier = GetProcessIdentifier () ;
	BYTE *t_MarshaledProxy = GetMarshaledProxy () ;
	DWORD t_MarshaledProxyLength = GetMarshaledProxyLength () ;

	HRESULT t_Result;

	if ( t_CreationTime && t_MarshaledProxy )
		{
		IUnknown *t_Unknown = NULL ;
		t_Result = DecoupledProviderSubSystem_Globals :: UnMarshalRegistration ( & t_Unknown , t_MarshaledProxy , t_MarshaledProxyLength ) ;
				
			if ( SUCCEEDED ( t_Result ) ) service_.Attach( t_Unknown );
		}
	return service_;
};



//   Register a requested provider 
//   on waiting list for the decoupled partner
void 
DC_DBReg::Register( const DC_DBkey& key, auto_ref<DCProxyAggr>& ptr)
{
  LockGuard<CriticalSection> t_guard(m_Mutex);
  aggregators_.regist(ptr, key);		

};

// UnRegister a Pseudo Provider
void DC_DBReg::UnRegister( auto_ref<DCProxyAggr>& ptr)
{
  LockGuard<CriticalSection> t_guard(m_Mutex);
  aggregators_.unregist(ptr);
};



// a a Decoupled provider
HRESULT DC_DBReg::Register( DC_reg& reg )
{

  LockGuard<CriticalSection> t_guard(m_Mutex);
  if (t_guard.locked() == false)
    return WBEM_E_OUT_OF_MEMORY;

  // Search for the provider on the namespace
	for(requested_providers::iterator it=aggregators_.begin(); it!=aggregators_.end(); ++it)
		if(it->key_.equal( reg ) )
			break;

	
	if ( it != aggregators_.end() )
		return it->client_->Register(reg);

	return S_OK;
};


// Unregister a Decoupled provider
HRESULT DC_DBReg::UnRegister( const DC_DBkey& key, const GUID identity )
{
  LockGuard<CriticalSection> t_guard(m_Mutex);
  if (t_guard.locked() == false)
    return WBEM_E_OUT_OF_MEMORY;

	for(requested_providers::iterator it=aggregators_.begin(); it!=aggregators_.end(); ++it)
		if(	it->key_ == key )
		{
			it->client_->UnRegister(identity);
			return S_OK;
		}
	return S_OK;
};


auto_ref<DCProxyAggr> 
DC_DBReg::find(const DC_DBkey& reg) const
{
  LockGuard<CriticalSection> t_guard(m_Mutex);
  for(requested_providers::iterator it=aggregators_.begin(); it!=aggregators_.end(); ++it)
		if(	it->key_ == reg )
		{
			return it->client_;
		};
  return auto_ref<DCProxyAggr>(NULL); 
};


auto_ref<DCProxyAggr> 
DC_DBReg::GetAggregator(const DC_DBkey& key) const
{ 
	auto_ref<DCProxyAggr> tmp = find( key );
	if( tmp )
		return tmp;

	return auto_ref<DCProxyAggr>( new DCProxyAggr() ); 
};







DC_registrar * DC_registrar::instance_ = NULL;

CriticalSection DC_registrar::m_Mutex(NOTHROW_LOCK);

DC_registrar::DC_registrar ():m_ReferenceCount(1)
{
  InterlockedIncrement(&DecoupledProviderSubSystem_Globals::s_RegistrarUsers);
  CServerObject_DecoupledClientRegistration_Element::VerifyClientKey();
}


DC_registrar::~DC_registrar ()
{
	instance_ = NULL;
}


 
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DC_registrar::QueryInterface (REFIID iid ,
			      LPVOID FAR *iplpv) 
{
  if (iplpv == NULL)
    return E_POINTER;
  
  if (iid == IID_IUnknown)
    *iplpv = static_cast<IUnknown *>(this);
  else if (iid == IID__IWmiProviderSubsystemRegistrar)
    *iplpv = static_cast<_IWmiProviderSubsystemRegistrar *>(this);		
  else 
  {
  *iplpv = NULL;
  return E_NOINTERFACE;
  }

  AddRef ();
  return S_OK;
}


ULONG 
DC_registrar::AddRef ()
{
    LONG counter = InterlockedIncrement(&m_ReferenceCount);
    InterlockedIncrement(&DecoupledProviderSubSystem_Globals::s_RegistrarUsers);
	return counter;
}


ULONG 
DC_registrar::Release ()
{
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals::s_RegistrarUsers);
	LONG t_Reference = InterlockedDecrement(&m_ReferenceCount);
	if (0 == t_Reference)
	{
		delete this ;
	}
	return t_Reference ;
}


HRESULT 
DC_registrar :: Register (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	DWORD a_ProcessIdentifier ,
	IUnknown *a_Unknown ,
	GUID a_Identity
)
{
	try
	{
		DC_reg t_Element;

		t_Element.Load( a_Flags, a_Context, a_User, a_Locale, a_Scope, a_Registration, a_Unknown, a_Identity );
		return mapping_database_.Register(t_Element);
	}
	catch(...){

		return WBEM_E_PROVIDER_FAILURE ;
	};
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DC_registrar::UnRegister (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	GUID a_Identity
)
{
	try
	{
		DC_DBkey key( a_User, a_Locale, a_Scope, a_Registration);
		return mapping_database_.UnRegister(key, a_Identity);
	}
	catch(...)
	{
		return WBEM_E_PROVIDER_FAILURE ;
	};

}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT DC_registrar :: SaveToRegistry (

	IUnknown *a_Unknown ,
	BYTE *a_MarshaledProxy ,
	DWORD a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	CServerObject_DecoupledServerRegistration t_Element ( *DecoupledProviderSubSystem_Globals :: s_Allocator ) ;

	BSTR t_CreationTime = NULL ;

	FILETIME t_CreationFileTime ;
	FILETIME t_ExitFileTime ;
	FILETIME t_KernelFileTime ;
	FILETIME t_UserFileTime ;

	BOOL t_Status = OS::GetProcessTimes (

		  GetCurrentProcess (),
		  & t_CreationFileTime,
		  & t_ExitFileTime,
		  & t_KernelFileTime,
		  & t_UserFileTime
	);

	if ( t_Status ) 
	{
		CWbemDateTime t_Time ;
		t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;
		t_Result = t_Time.GetValue ( & t_CreationTime ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Element.SetProcessIdentifier ( GetCurrentProcessId () ) ;

			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_Element.SetCreationTime ( ( BSTR ) t_CreationTime ) ;
			}

			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_Element.SetMarshaledProxy ( a_MarshaledProxy , a_MarshaledProxyLength ) ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Element.Save () ;
			}

			SysFreeString ( t_CreationTime ) ;
		}
		else
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
	}
	else
	{
		t_Result = WBEM_E_UNEXPECTED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DC_registrar :: Save ()
{
	HRESULT t_Result = S_OK ;

	try
	{
		BYTE *t_MarshaledProxy = NULL ;
		DWORD t_MarshaledProxyLength = 0 ;

			t_Result = DecoupledProviderSubSystem_Globals :: MarshalRegistration ( 
				this ,
				t_MarshaledProxy ,
				t_MarshaledProxyLength
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = SaveToRegistry ( 

					this ,
					t_MarshaledProxy ,
					t_MarshaledProxyLength
				) ;

				delete [] t_MarshaledProxy ;
			}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DC_registrar :: Delete ()
{
	HRESULT t_Result = S_OK ;
	try
	{
		CServerObject_DecoupledServerRegistration t_Element ( *DecoupledProviderSubSystem_Globals :: s_Allocator ) ;
		t_Result = t_Element.Delete () ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}
	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\ssdlhelper.cpp ===
#include "precomp.h"
#include <sddl.h>
#include "ssdlhelper.h"

SDDL sddl_wrapper;

SDDL::function_type 
SDDL::GetFunction(void)
{
    function_type return_function = DummyConvertStringSecurityDescriptorToSecurityDescriptor;
    if (lock_.acquire())
    {
        return_function = current_function_;
        if (current_function_==0)
        {
            HMODULE advapi = LoadLibrary(L"advapi32.dll");
            if (advapi)
            {
                current_function_ = (function_type)GetProcAddress(advapi,"ConvertStringSecurityDescriptorToSecurityDescriptorW");
                FreeLibrary(advapi);
            }

            if (current_function_==0)
            {
                current_function_ = DummyConvertStringSecurityDescriptorToSecurityDescriptor;
            }

            return_function = current_function_;
        }
        lock_.release();
    };
    return return_function;
};

BOOL SDDL::ConvertStringSecurityDescriptorToSecurityDescriptor(
  LPCTSTR StringSecurityDescriptor,          // security descriptor string
  DWORD StringSDRevision,                    // revision level
  PSECURITY_DESCRIPTOR *SecurityDescriptor,  // SD
  PULONG SecurityDescriptorSize              // SD size
)
{
  return (sddl_wrapper.GetFunction())(StringSecurityDescriptor, 
                                      StringSDRevision, 
                                      SecurityDescriptor, 
                                      SecurityDescriptorSize);
};


BOOL SDDL::DummyConvertStringSecurityDescriptorToSecurityDescriptor(
  LPCTSTR StringSecurityDescriptor,          // security descriptor string
  DWORD StringSDRevision,                    // revision level
  PSECURITY_DESCRIPTOR *SecurityDescriptor,  // SD
  PULONG SecurityDescriptorSize              // SD size
)
{
if (SecurityDescriptor==0)
  return ERROR_INVALID_PARAMETER;
if (SecurityDescriptorSize)
  *SecurityDescriptorSize = 0;
*SecurityDescriptor = 0;
return TRUE;
};


bool SDDL::hasSDDLSupport() 
{ 
    return sddl_wrapper.GetFunction() != DummyConvertStringSecurityDescriptorToSecurityDescriptor; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\aggregator.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _ClassProvider_IWbemServices_H
#define _ClassProvider_IWbemServices_H

#include "ProvRegDeCoupled.h"
#include <comdef.h>
#include <list>
#include "provcache.h"
#include <list>
#include <pssutils.h>
#include <AssertBreak.h>
#include <comdef.h>
#include <null_wmi.h>
#include <locksT.h>
using namespace provsubsys;

_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IWbemPath, __uuidof(IWbemPath));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemContext, __uuidof(IWbemContext));
_COM_SMARTPTR_TYPEDEF(_IWmiProviderSubsystemRegistrar,__uuidof(_IWmiProviderSubsystemRegistrar));
_COM_SMARTPTR_TYPEDEF(IWbemQuery,__uuidof(IWbemQuery));


class DC_reg : public CServerObject_DecoupledClientRegistration_Element
{
	IWbemContextPtr context_;
	IUnknownPtr		service_;
	long	flags_;

public:
	DC_reg(): CServerObject_DecoupledClientRegistration_Element(), flags_(0) { };

	DC_reg( const DC_reg& _R );
	DC_reg( CServerObject_DecoupledClientRegistration_Element& _R)
	{
		*(CServerObject_DecoupledClientRegistration_Element*)(this) = _R;	
	};

	HRESULT Load(	
		long a_Flags,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		IUnknown *a_Unknown ,
		GUID a_Identity ) ;


	const DC_reg& operator=(const DC_reg& _R);

	~DC_reg() {  	};

	GUID identity();

	IWbemContextPtr context() { return context_; };

	IUnknownPtr service();
	
	HRESULT SetUser ( const BSTR a_User )
	{ 
		HRESULT res = CServerObject_DecoupledClientRegistration_Element::SetUser( const_cast<BSTR>(a_User) );
		if ( a_User == NULL )
			return S_OK;
		return res;
	}

	HRESULT SetLocale ( const BSTR a_User )
	{ 
		HRESULT res = CServerObject_DecoupledClientRegistration_Element::SetLocale ( const_cast<BSTR>(a_User) );
		if ( a_User == NULL )
			return S_OK;
		return res;
	}

	HRESULT SetScope  ( const BSTR a_User )
	{ 
		HRESULT res = CServerObject_DecoupledClientRegistration_Element::SetScope ( const_cast<BSTR>(a_User) );
		if ( a_User == NULL )
			return S_OK;
		return res;
	}

	long flags() { return flags_; };
};



// Forward declaration
class DCProxyAggr;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *	
 *	
 *****************************************************************************/


struct DC_DBkey
{
	_bstr_t	scope_;
	_bstr_t	locale_;
	_bstr_t user_;
	_bstr_t name_;

	DC_DBkey( 
		const _bstr_t& user,
		const _bstr_t& locale, 
		const _bstr_t& scope,
		const _bstr_t& name 
		): scope_( scope ), locale_( locale ), user_( user ), name_( name )
	{  	};

	DC_DBkey(const DC_DBkey& rhs):scope_(rhs.scope_), locale_(rhs.locale_), user_(rhs.user_), name_(rhs.name_)
	{  };

	bool operator==(const DC_DBkey& rhs) const
	{
		return ( 
			equal_no_case( scope_ , rhs.scope_) && 
			equal_no_case( user_ , rhs.user_) && 
			equal_no_case( locale_ , rhs.locale_) &&
			equal_no_case( name_ , rhs.name_)
			);
	};
	bool operator!=(const DC_DBkey& rhs) const 
	{
		return !(*this==rhs);
	};

	bool equal_no_case( const _bstr_t& lhs, const _bstr_t& rhs) const
	{
		if( lhs.length() != rhs.length() )
			return false;

		if( lhs.length() == 0 )
			return true;

		return wbem_wcsnicmp( lhs, rhs, lhs.length() ) == 0;
	};

	bool equal_no_case( const _bstr_t& lhs, const BSTR rhs) const
	{
		const wchar_t null[] = L"";
		if( lhs.length() != ::SysStringLen(rhs) )
			return false;

		if( lhs.length() == 0 )
			return true;

		return wbem_wcsnicmp( lhs, rhs, lhs.length() ) == 0;
	};

	bool equal(CServerObject_DecoupledClientRegistration_Element& el) const {

		bool result = equal_no_case( scope_, el.GetScope());
		result = result && equal_no_case( locale_, el.GetLocale() );
		result = result && equal_no_case( user_, el.GetUser() );
		result = result && equal_no_case( name_, el.GetProvider() );
		return result;		
	};

protected:
	DC_DBkey& operator=(const DC_DBkey&);
};



struct requested_entry
{
	DC_DBkey	key_;
	auto_ref<DCProxyAggr>	client_; 
	requested_entry(
		const DC_DBkey& key, 
		auto_ref<DCProxyAggr>& ptr
		): client_(ptr), key_(key)
	{ };
};




class requested_providers: public std::list<requested_entry>{

public:
	void regist(auto_ref<DCProxyAggr>& ptr, const DC_DBkey& key)
	{
		push_back(requested_entry(key,ptr));
	}

	void unregist(auto_ref<DCProxyAggr>& ptr)
	{
		for(iterator it=begin(); it!=end(); ++it)
		{
			if(	(*it).client_ ==  ptr )
				erase(it);
			else
				continue;
			break;
		};
	}
};



class DC_DBReg{
  mutable CriticalSection m_Mutex;
public:

	DC_DBReg():m_Mutex(THROW_LOCK) { };

	// Register a Pseudo Provider waiting for the decoupled partner
	void Register( const DC_DBkey&, auto_ref<DCProxyAggr>& );

	// UnRegister a Pseudo Provider
	void UnRegister( auto_ref<DCProxyAggr>& );

	// Register a Decoupled provider
	HRESULT Register( DC_reg& reg_ );

	// Unregister a Decoupled provider
	HRESULT UnRegister( const DC_DBkey&, const GUID a_Identity );

	auto_ref<DCProxyAggr> find(const DC_DBkey&) const;
	auto_ref<DCProxyAggr> GetAggregator(const DC_DBkey&) const;

private:
	requested_providers	aggregators_;
};



class DC_registrar : public _IWmiProviderSubsystemRegistrar 
					 
{
  static CriticalSection m_Mutex ;
  DC_DBReg mapping_database_;
private:



	LONG m_ReferenceCount ;         
	IWbemServicesPtr m_SubSystem ;

	DCProxyAggr&	m_cont();

	HRESULT CacheProvider (
		auto_ref<DCProxyAggr>& ,
		IWbemContext *a_Context ,
		CServerObject_DecoupledClientRegistration_Element &a_Element ,
		IUnknown *a_Unknown 
	) ;
public:

	CriticalSection& GetLock() { return m_Mutex; };
	void RegisterAggregator(const DC_DBkey& key, auto_ref<DCProxyAggr>& aggr){ return mapping_database_.Register(key,aggr);}
	void UnRegisterAggregator(auto_ref<DCProxyAggr>& aggr){ return mapping_database_.UnRegister(aggr);}
	auto_ref<DCProxyAggr> GetAggregator(const DC_DBkey& key) const { return mapping_database_.GetAggregator(key);}

	HRESULT Load (
		auto_ref<DCProxyAggr>& ,
		CServerObject_DecoupledClientRegistration_Element &a_Element
	) ;

	HRESULT MarshalRegistration (

		IUnknown *a_Unknown ,
		BYTE *&a_MarshaledProxy ,
		DWORD &a_MarshaledProxyLength
	) ;

	HRESULT SaveToRegistry (

		IUnknown *a_Unknown ,
		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength
	) ;

public:

	DC_registrar () ;
	~DC_registrar () ;


	HRESULT Save () ;
	HRESULT Delete () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	STDMETHODIMP Register (
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Registration ,
		LPCWSTR a_Scope ,
		DWORD a_ProcessIdentifier ,
		IUnknown *a_Unknown ,
		GUID a_Identity
	) ;

	STDMETHODIMP UnRegister (
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		GUID a_Identity
	) ;

	
	static DC_registrar * instance()
	{
			if (!instance_)
			{
			LockGuard<CriticalSection> lock(m_Mutex);
				if (!instance_)
					instance_ = new DC_registrar();
			}
			return instance_;
	}

	static DC_registrar * instance_;
};




class CInterceptor_IWbemDecoupledProvider;

class DCProxyAggr : public ServiceCacheElement ,
		    public CWbemGlobal_IWmiObjectSinkController
{
private:

	IWbemObjectSinkPtr m_Sink ;
	IWbemPathPtr m_NamespacePath ;


	LONG m_ReferenceCount ;         //Object reference count
	LONG m_UnRegistered ;         //Object reference count

	WmiAllocator &m_Allocator ;

	CriticalSection m_CriticalSection ;

	IWbemServicesPtr m_CoreService ;
	IWbemContextPtr m_context;

	IWbemClassObjectPtr m_Empty ;
	CWbemGlobal_IWbemSyncProviderController *m_Controller ;

	_bstr_t m_Namespace ;
	_bstr_t m_Locale ;
	_bstr_t m_User ;
	_bstr_t m_ProviderName ;
	LONG m_Flags;
	bool initialized_;

public:

	DCProxyAggr () ;
    	~DCProxyAggr () ;
	void activate();
	void deActivate();


public:

	//Non-delegating object IUnknown

    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    
    
    
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (
	
		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		LPWSTR a_Name,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	// IWmi_UnInitialize members

	bool initialized() { return initialized_; };
	HRESULT LoadAll ( void );
	HRESULT Register ( DC_reg&, bool validate = true ) ;

	HRESULT UnRegister ( GUID a_Identity ) ;
	HRESULT UnRegister(const CInterceptor_IWbemDecoupledProvider &);
	HRESULT InitializeProvider ( 

		IUnknown *a_Unknown ,
		IWbemServices *a_Stub ,
		wchar_t *a_NamespacePath ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	HRESULT CreateSyncProvider ( 

		IUnknown *a_ServerSideProvider ,
		IWbemServices *a_Stub ,
		wchar_t *a_NamespacePath ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		GUID a_Identity ,
		CInterceptor_IWbemDecoupledProvider *&a_Interceptor 
	) ;

	HRESULT STDMETHODCALLTYPE ProvideEvents (
		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	HRESULT STDMETHODCALLTYPE AccessCheck (
		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	);

	HRESULT STDMETHODCALLTYPE 
	NewQuery(
		unsigned long dwId,
		WBEM_WSTR wszQueryLanguage,
		WBEM_WSTR wszQuery
	);
	HRESULT STDMETHODCALLTYPE 
	CancelQuery(
		unsigned long dwId
	);

} ;

class DCProxy : public NULL_IWbemServices , 
		public IWbemProviderInit , 
		public IWbemEventProvider,
		public IWbemPropertyProvider,
		public IWbemEventProviderSecurity ,
		public IWbemProviderIdentity,
		public IWbemEventProviderQuerySink
{
private:
	enum { EVENT_PROVIDER, INSTANCE_PROVIDER } PROVIDER_MODE;
	
	auto_ref<DCProxyAggr> m_aggregator_;	

	
	IWbemObjectSink *m_Sink ;
	IWbemPath *m_NamespacePath ;


	LONG m_ReferenceCount ;         //Object reference count

	IWbemServicesPtr m_CoreService ;
	IWbemContextPtr m_Context;

	IWbemClassObjectPtr m_Empty ;
	CWbemGlobal_IWbemSyncProviderController *m_Controller ;

	_bstr_t m_Namespace ;
	_bstr_t m_Locale ;
	_bstr_t m_User ;
	_bstr_t m_ProviderName;

	long m_Flags;
	bool event_only_;

public:
  DCProxy ( ) ;
  ~DCProxy () ;

public:

	HRESULT Initialize(void ){ return S_OK;}
	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    
    
    
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;


	HRESULT STDMETHODCALLTYPE ProvideEvents (
		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	HRESULT STDMETHODCALLTYPE SetRegistrationObject(
		long lFlags,
		IWbemClassObject* pProvReg
	);

	HRESULT STDMETHODCALLTYPE AccessCheck (
		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	);
	
	HRESULT STDMETHODCALLTYPE 
	NewQuery(
		unsigned long dwId,
		WBEM_WSTR wszQueryLanguage,
		WBEM_WSTR wszQuery
	);
	HRESULT STDMETHODCALLTYPE 
	CancelQuery(
		unsigned long dwId
	);

	STDMETHODIMP
	ExecQueryAsync(
		const BSTR strQueryLanguage,                
		const BSTR strQuery,                        
		long lFlags,                       
		IWbemContext *pCtx,              
		IWbemObjectSink *pResponseHandler  
	);


	STDMETHODIMP GetProperty( long lFlags, const BSTR strLocale, const BSTR strClassMapping, 
				  const BSTR strInstMapping, const BSTR strPropMapping,  VARIANT *pvValue );
	STDMETHODIMP PutProperty( long lFlags, const BSTR strLocale, const BSTR strClassMapping, 
				  const BSTR strInstMapping, const BSTR strPropMapping,  const VARIANT *pvValue );


	bool initialized();
	HRESULT initialize_from_instance (const BSTR _path);
	HRESULT initialize( const BSTR);
	HRESULT initialize( IWbemClassObject * pObj);
	HRESULT _initialize( );	//real initialization
} ;



#endif // _ClassProvider_IWbemServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\callsec.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CALLSEC.H

Abstract:


History:

    raymcc      29-Jul-98        First draft.

--*/


#ifndef _CALLSEC_H_
#define _CALLSEC_H_

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CLifeControl
{
public:
    BOOL ObjectCreated(IUnknown* pv) { return TRUE;};
    void ObjectDestroyed(IUnknown* pv){};
    void AddRef(IUnknown* pv) {};
    void Release(IUnknown* pv){};;
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CLifeControl ;

class CWbemThreadSecurityHandle : public _IWmiThreadSecHandle
{
private:

    LONG m_ReferenceCount ;

    HANDLE m_ThreadToken ;
    DWORD m_ImpersonationLevel ;
	DWORD m_AuthenticationService ;
	DWORD m_AuthorizationService ;
	DWORD m_AuthenticationLevel ;
	LPWSTR m_ServerPrincipalName ;
	LPWSTR m_Identity ;

	WMI_THREAD_SECURITY_ORIGIN m_Origin ;

	CLifeControl *m_Control ;

public:

    CWbemThreadSecurityHandle ( CLifeControl *a_Control ) ;
	CWbemThreadSecurityHandle ( const CWbemThreadSecurityHandle &a_Copy ) ;
   ~CWbemThreadSecurityHandle () ;

    CWbemThreadSecurityHandle &operator= ( const CWbemThreadSecurityHandle &a_Copy ) ;

	HRESULT CloneRpcContext (

		IServerSecurity *a_Security
	) ;

	HRESULT CloneThreadContext () ;

	HRESULT CloneProcessContext () ;

/*
 * IUnknown.
 */

    ULONG STDMETHODCALLTYPE AddRef () ;
    ULONG STDMETHODCALLTYPE Release () ;
    HRESULT STDMETHODCALLTYPE QueryInterface ( REFIID a_Riid , void **a_Void ) ;

/*
 *
 */

	HRESULT STDMETHODCALLTYPE GetHandleType ( ULONG *a_Type ) { return WMI_HANDLE_THREAD_SECURITY; }

	HRESULT STDMETHODCALLTYPE GetTokenOrigin ( WMI_THREAD_SECURITY_ORIGIN *a_Origin ) { return m_Origin ; }

/*
 *	_IWmiThreadSecHandle
 */

    HRESULT STDMETHODCALLTYPE GetImpersonation (

		DWORD *a_Level
	) ;

	HRESULT STDMETHODCALLTYPE GetAuthentication (
	
		DWORD *a_Level
	) ;

    HRESULT STDMETHODCALLTYPE GetUser (

        ULONG *a_Size ,
        LPWSTR a_Buffer
	) ;

    HRESULT STDMETHODCALLTYPE GetUserSid (

		ULONG *a_Size ,
		PSID a_Sid
	) ;

    HRESULT STDMETHODCALLTYPE GetToken ( HANDLE *a_ThreadToken ) ;

    HRESULT STDMETHODCALLTYPE GetAuthenticationLuid ( LPVOID a_Luid ) ;

/*
 * Implementation publics
 */

    HANDLE GetThreadToken () { return m_ThreadToken ; }
    DWORD GetImpersonationLevel () { return m_ImpersonationLevel ; }
	DWORD GetAuthenticationService () { return m_AuthenticationService ; }
	DWORD GetAuthorizationService () { return m_AuthorizationService ; }
	DWORD GetAuthenticationLevel () { return m_AuthenticationLevel ; }
	LPWSTR GetServerPrincipalName () { return m_ServerPrincipalName ; }
	LPWSTR GetIdentity () { return m_Identity ; }

	void SetOrigin ( WMI_THREAD_SECURITY_ORIGIN a_Origin ) { m_Origin = a_Origin ; }

	static CWbemThreadSecurityHandle *New () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CLifeControl ;

class CWbemCallSecurity : public IServerSecurity  , public _IWmiCallSec
{
private:

    LONG m_ReferenceCount ;
	DWORD m_ImpersonationLevel ;
	CWbemThreadSecurityHandle *m_ThreadSecurityHandle ;
	HANDLE m_ThreadToken ;
	CLifeControl *m_Control ;

public:

	CWbemCallSecurity ( CLifeControl *a_Control ) ;
   ~CWbemCallSecurity () ;

    CWbemCallSecurity &operator= ( const CWbemCallSecurity &a_Copy ) ;

public:

	CWbemThreadSecurityHandle *GetThreadSecurityHandle () { return m_ThreadSecurityHandle ; }

/*
 * IUnknown.
 */

    ULONG STDMETHODCALLTYPE AddRef () ;
    ULONG STDMETHODCALLTYPE Release () ;
    HRESULT STDMETHODCALLTYPE QueryInterface ( REFIID a_Riid , void **a_Void ) ;

/*
 * IServerSecurity.
 */

    HRESULT STDMETHODCALLTYPE QueryBlanket (

		DWORD *a_AuthenticationService ,
		DWORD *a_AuthorizationService ,
		OLECHAR **a_ServerPrincipleName ,
		DWORD *a_AuthorizationLevel ,
		DWORD *a_ImpersonationLevel ,
		void **a_Privileges ,
		DWORD *a_Capabilities
	) ;

	HRESULT STDMETHODCALLTYPE ImpersonateClient () ;

	HRESULT STDMETHODCALLTYPE RevertToSelf () ;

	BOOL STDMETHODCALLTYPE IsImpersonating () ;

/*
 *	_IWmiCallSec
 */

    HRESULT STDMETHODCALLTYPE GetImpersonation (

        DWORD *a_Level
	) ;

	HRESULT STDMETHODCALLTYPE GetAuthentication (
	
		DWORD *a_Level
	) ;

    HRESULT STDMETHODCALLTYPE GetUser (

        ULONG *a_Size ,
        LPWSTR a_Buffer
	) ;

    HRESULT STDMETHODCALLTYPE GetUserSid (

		ULONG *a_Size ,
		PSID a_Sid
	) ;

    HRESULT STDMETHODCALLTYPE GetAuthenticationLuid ( LPVOID a_Luid ) ;

    HRESULT STDMETHODCALLTYPE GetThreadSecurity ( WMI_THREAD_SECURITY_ORIGIN a_Origin , _IWmiThreadSecHandle **a_ThreadSecurity ) ;

    HRESULT STDMETHODCALLTYPE SetThreadSecurity ( _IWmiThreadSecHandle *a_ThreadSecurity ) ;

	static CWbemCallSecurity *New () ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\cglobals.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _CommonGlobals_H
#define _CommonGlobals_H

#include <pssException.h>
#include <HelperFuncs.h>
#include <Allocator.h>
#include <BasicTree.h>
#include <Queue.h>
#include <Cache.h>
#include <locks.h>
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define SYNCPROV_BATCH_TRANSMIT_SIZE 0x40000

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef WmiContainerController <void *>										CWbemGlobal_VoidPointerController ;
typedef CWbemGlobal_VoidPointerController :: Container						CWbemGlobal_VoidPointerController_Container ;
typedef CWbemGlobal_VoidPointerController :: Container_Iterator				CWbemGlobal_VoidPointerController_Container_Iterator ;
typedef CWbemGlobal_VoidPointerController :: WmiContainerElement			VoidPointerContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define CWbemGlobal_IWmiObjectSinkController						CWbemGlobal_VoidPointerController
#define CWbemGlobal_IWmiObjectSinkController_Container				CWbemGlobal_VoidPointerController_Container
#define CWbemGlobal_IWmiObjectSinkController_Container_Iterator		CWbemGlobal_VoidPointerController_Container_Iterator
#define ObjectSinkContainerElement									VoidPointerContainerElement

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define MASK_PROVIDER_BINDING_BIND 1

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern void DumpThreadTokenSecurityDescriptor () ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define HRESULT_ERROR_MASK (0x0000FFFF)
#define HRESULT_ERROR_FUNC(X) (X&HRESULT_ERROR_MASK)
#define HRESULT_FACILITY_MASK (0x0FFF0000)
#define HRESULT_FACILITY_FUNC(X) ((X&HRESULT_FACILITY_MASK)>>16)
#define HRESULT_SEVERITY_MASK (0xC0000000)
#define HRESULT_SEVERITY_FUNC(X) ((X&HRESULT_SEVERITY_MASK)>>30)

#define HRESULT_ERROR_SERVER_UNAVAILABLE	1722L
#define HRESULT_ERROR_CALL_FAILED_DNE		1727L

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define MAX_PROXIES 512

class ProxyContainer
{
private:

	WmiAllocator &m_Allocator ;
#if 1
	WmiStack <IUnknown *,8> **m_ContainerArray ;
#else
	WmiQueue <IUnknown *,8> **m_ContainerArray ;
#endif
	CriticalSection m_CriticalSection ;
	ULONG m_TopSize ;
	ULONG m_CurrentSize ;
	ULONG m_ProxyCount ;
	BOOL m_Initialized ;

public:

	ProxyContainer ( 

		WmiAllocator &a_Allocator ,
		ULONG a_ProxyCount ,
		ULONG a_TopSize 

	) : m_Allocator ( a_Allocator ) ,
		m_ContainerArray ( NULL ) ,
		m_TopSize ( a_TopSize ) ,
		m_CurrentSize ( 0 ) ,
		m_ProxyCount ( a_ProxyCount ) ,
		m_Initialized ( FALSE ) ,
		m_CriticalSection(NOTHROW_LOCK)
	{
	}

	~ProxyContainer ()
	{
		UnInitialize () ;
	}

	WmiStatusCode Initialize () 
	{
		WmiStatusCode t_StatusCode = e_StatusCode_Success ;

#if 1
		m_ContainerArray = new WmiStack <IUnknown *,8> * [ m_ProxyCount ] ;
#else
		m_ContainerArray = new WmiQueue <IUnknown *,8> * [ m_ProxyCount ] ;
#endif
		if ( m_ContainerArray )
		{
			t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;
			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				m_Initialized = TRUE ;

 				for ( ULONG t_Index = 0 ; t_Index < m_ProxyCount ; t_Index ++ )
				{
					m_ContainerArray [ t_Index ] = NULL ;
				}

				for ( t_Index = 0 ; t_Index < m_ProxyCount ; t_Index ++ )
				{
#if 1
					WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ t_Index ] = new WmiStack <IUnknown *,8> ( m_Allocator ) ;
#else
					WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ t_Index ] = new WmiQueue <IUnknown *,8> ( m_Allocator ) ;
#endif

					if ( t_Container )
					{
						t_StatusCode = t_Container->Initialize () ;
						if ( t_StatusCode != e_StatusCode_Success )
						{
							break ;
						}
					}
					else
					{
						t_StatusCode = e_StatusCode_OutOfMemory ;

						break ;
					}
				}
			}
		}
		else
		{
			t_StatusCode = e_StatusCode_OutOfMemory ;
		}

		return t_StatusCode ;
	}

	WmiStatusCode UnInitialize ()
	{
		WmiStatusCode t_StatusCode = e_StatusCode_Success ;

		if ( m_ContainerArray )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_ProxyCount ; t_Index ++ )
			{
#if 1
				WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ t_Index ] ;
#else
				WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ t_Index ] ;
#endif
				if ( t_Container )
				{
					IUnknown *t_Top = NULL ;
					WmiStatusCode t_StatusCode ;
					while ( ( t_StatusCode = t_Container->Top ( t_Top ) ) == e_StatusCode_Success )
					{
						t_Top->Release () ;
#if 1
						t_StatusCode = t_Container->Pop () ;
#else
						t_StatusCode = t_Container->DeQueue () ;
#endif
					}

					t_StatusCode = t_Container->UnInitialize () ;

					delete t_Container ;
				}
			}

			delete [] m_ContainerArray ;

			m_ContainerArray = NULL ;
		}

		if ( m_Initialized )
		{
			WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;
			m_Initialized = FALSE ;
		}

		return t_StatusCode ;
	}

	WmiStatusCode Return ( 

		IUnknown *a_Element ,
		ULONG a_Index
	)
	{
#if 1
		WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->Push ( a_Element ) ;
#else
		WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->EnQueue ( a_Element ) ;
#endif
	}

	WmiStatusCode Top ( 

		IUnknown *&a_Element ,
		ULONG a_Index
	)
	{
#if 1
		WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->Top ( a_Element ) ;
#else
		WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->Top ( a_Element ) ;
#endif
	}

	WmiStatusCode Reserve ( ULONG a_Index )
	{
#if 1
		WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->Pop () ;
#else
		WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->DeQueue () ;
#endif
	}
	
	ULONG GetTopSize () { return m_TopSize ; } ;
	ULONG GetCurrentSize () { return m_CurrentSize ; } ;
	BOOL GetInitialized () { return m_Initialized ; }

	void SetCurrentSize ( ULONG a_CurrentSize ) { m_CurrentSize = a_CurrentSize ; }

	CriticalSection &GetCriticalSection () { return m_CriticalSection ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderRegistrationV1;
class ProviderSubSystem_Common_Globals
{
public:

	static LPCWSTR s_Wql ;
	static LPCWSTR s_Provider ;

	static WORD s_System_ACESize ;
	static WORD s_LocalService_ACESize ;
	static WORD s_NetworkService_ACESize ;
	static WORD s_LocalAdmins_ACESize ;

	static ACCESS_ALLOWED_ACE *s_Provider_System_ACE ;
	static ACCESS_ALLOWED_ACE *s_Provider_LocalService_ACE ;
	static ACCESS_ALLOWED_ACE *s_Provider_NetworkService_ACE ;
	static ACCESS_ALLOWED_ACE *s_Provider_LocalAdmins_ACE ;

	static ACCESS_ALLOWED_ACE *s_Token_All_Access_System_ACE ;
	static ACCESS_ALLOWED_ACE *s_Token_All_Access_LocalService_ACE ;
	static ACCESS_ALLOWED_ACE *s_Token_All_Access_NetworkService_ACE ;
	static ACCESS_ALLOWED_ACE *s_Token_All_Access_LocalAdmins_ACE ;

	static SECURITY_DESCRIPTOR *s_MethodSecurityDescriptor ;

	static ULONG s_TransmitBufferSize ;
	static ULONG s_DefaultStackSize ;

public:

	static HRESULT CreateInstance ( 

		const CLSID &a_ReferenceClsid ,
		LPUNKNOWN a_OuterUnknown ,
		const DWORD &a_ClassContext ,
		const UUID &a_ReferenceInterfaceId ,
		void **a_ObjectInterface
	) ;

	static HRESULT CreateRemoteInstance ( 

		LPCWSTR a_Server ,
		const CLSID &a_ReferenceClsid ,
		LPUNKNOWN a_OuterUnknown ,
		const DWORD &a_ClassContext ,
		const UUID &a_ReferenceInterfaceId ,
		void **a_ObjectInterface
	) ;

	static HRESULT GetNamespaceServerPath (

		IWbemPath *a_Namespace ,
		wchar_t *&a_ServerNamespacePath
	) ;

	static HRESULT GetNamespacePath (

		IWbemPath *a_Namespace ,
		wchar_t *&a_NamespacePath
	) ;

	static HRESULT GetPathText (

		IWbemPath *a_Path ,
		wchar_t *&a_ObjectPath
	) ;

	static HRESULT BeginCallbackImpersonation (

		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating
	) ;

	static HRESULT BeginImpersonation (

		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating ,
		DWORD *a_AuthenticationLevel = NULL
	) ;

	static HRESULT EndImpersonation (

		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_Impersonating 
	) ;

	static HRESULT GetProxy (

		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy 
	) ;

	static HRESULT GetProxy (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy 
	) ;

	static HRESULT SetCloaking ( 

		IUnknown *a_Unknown
	) ;

	static HRESULT SetCloaking ( 

		IUnknown *a_Unknown ,
		DWORD a_AuthenticationLevel ,
		DWORD a_ImpersonationLevel
	) ;

	static BOOL IsProxy ( IUnknown *a_Unknown ) ;

	static DWORD GetCurrentImpersonationLevel () ;

	static HRESULT EnableAllPrivileges () ;

	static HRESULT EnableAllPrivileges ( HANDLE a_Token ) ;

	static HRESULT SetAnonymous ( IUnknown *a_Proxy ) ;

	static HRESULT SetCallState (

		IUnknown *a_Interface ,
		BOOL &a_Revert
	) ;

	static HRESULT RevertCallState ( 

		BOOL a_Revert
	) ;

	static HRESULT SetProxyState (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert
	) ;

	static HRESULT RevertProxyState ( 

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		IUnknown *a_Proxy , 
		BOOL a_Revert
	) ;

	static HRESULT SetProxyState_SvcHost (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		ACCESS_ALLOWED_ACE *a_Ace ,
		WORD a_AceSize
	) ;

	static HRESULT RevertProxyState_SvcHost ( 

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;

	static HRESULT SetProxyState_PrvHost (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken
	) ;

	static HRESULT RevertProxyState_PrvHost ( 

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;

	static HRESULT SetProxyState_SvcHost (

		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		ACCESS_ALLOWED_ACE *a_Ace ,
		WORD a_AceSize,
		SECURITY_IMPERSONATION_LEVEL impersonationLevel
	) ;

	static HRESULT RevertProxyState_SvcHost ( 

		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;

	static HRESULT SetProxyState_PrvHost (

		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken
	) ;

	static HRESULT RevertProxyState_PrvHost ( 

		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;

	static HRESULT SetProxyState (

		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert
	) ;

	static HRESULT RevertProxyState ( 

		IUnknown *a_Proxy , 
		BOOL a_Revert
	) ;

	static HRESULT Load_DWORD ( HKEY a_Key , LPCWSTR a_Name , DWORD &a_Value ) ;
	static HRESULT Load_String ( HKEY a_Key , LPCWSTR a_Name , BSTR &a_Value ) ;
	static HRESULT Load_ByteArray ( HKEY a_Key , LPCWSTR a_Name , BYTE *&a_Value , DWORD &a_ValueLength ) ;

	static HRESULT Save_DWORD ( HKEY a_Key , LPCWSTR a_Name , DWORD a_Value ) ;
	static HRESULT Save_String ( HKEY a_Key , LPCWSTR a_Name , BSTR a_Value ) ;
	static HRESULT Save_ByteArray ( HKEY a_Key , LPCWSTR a_Name , BYTE *a_Value , DWORD a_ValueLength ) ;

	static HRESULT UnMarshalRegistration (

		IUnknown **a_Unknown ,
		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength
	) ;

	static HRESULT MarshalRegistration (

		IUnknown *a_Unknown ,
		BYTE *&a_MarshaledProxy ,
		DWORD &a_MarshaledProxyLength
	) ;

	static HRESULT ReleaseRegistration (

		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength
	) ;

	static HRESULT IsDependantCall ( IWbemContext *a_Parent , IWbemContext *a_ChildContext , BOOL &a_DependantCall ) ;

	static HRESULT Set_Uint64 (

		_IWmiObject *a_Instance ,
		wchar_t *a_Name ,
		const UINT64 &a_Uint64
	) ;

	static HRESULT Set_Uint32 ( 

		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		const DWORD &a_Uint32
	) ;

	static HRESULT Set_Uint16 ( 

		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		const WORD &a_Uint16
	) ;

	static HRESULT Set_Bool ( 

		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		const BOOL &a_Bool
	) ;

	static HRESULT Set_String ( 

		IWbemClassObject *a_Instance , 
		wchar_t *a_Name ,
		wchar_t *a_String
	) ;

	static HRESULT Set_DateTime ( 

		IWbemClassObject *a_Instance , 
		wchar_t *a_Name ,
		FILETIME a_Time
	) ;

	static HRESULT Set_Byte_Array ( 

		IWbemClassObject *a_Instance , 
		wchar_t *a_Name ,
		BYTE *a_Bytes ,
		WORD a_BytesCount 
	) ;

	static HRESULT Get_Uint64 (

		_IWmiObject *a_Instance ,
		wchar_t *a_Name ,
		UINT64 &a_Uint64 ,
		BOOL &a_Null
	) ;

	static HRESULT Get_Uint32 ( 

		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		DWORD &a_Uint32 ,
		BOOL &a_Null
	) ;

	static HRESULT Get_Uint16 ( 

		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		WORD &a_Uint16 ,
		BOOL &a_Null 
	) ;

	static HRESULT Get_Bool ( 

		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		BOOL &a_Bool ,
		BOOL &a_Null
	) ;

	static HRESULT Get_String ( 

		IWbemClassObject *a_Instance , 
		wchar_t *a_Name ,
		wchar_t *&a_String ,
		BOOL &a_Null
	) ;

	static HRESULT Get_DateTime ( 

		IWbemClassObject *a_Instance , 
		wchar_t *a_Name ,
		FILETIME &a_Time ,
		BOOL &a_Null
	) ;

	static HRESULT Check_SecurityDescriptor_CallIdentity ( 

		SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
		DWORD a_Access , 
		GENERIC_MAPPING *a_Mapping
	) ;

	static HRESULT AdjustSecurityDescriptorWithSid ( 

		SID *a_OwnerSid , 
		SID *a_GroupSid , 
		DWORD a_Access ,
		SECURITY_DESCRIPTOR *&a_SecurityDescriptor , 
		SECURITY_DESCRIPTOR *&a_AlteredSecurityDescriptor
	) ;

	static HRESULT CreateSystemAces () ;

	static HRESULT DeleteSystemAces () ;

	static HRESULT ConstructIdentifyToken_SvcHost (

		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		ACCESS_ALLOWED_ACE *a_Ace ,
		WORD a_AceSize,
		SECURITY_IMPERSONATION_LEVEL impersonationLevel
	) ;

	static HRESULT ConstructIdentifyToken_PrvHost (

		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		ACCESS_ALLOWED_ACE *a_Ace ,
		WORD a_AceSize
	) ;

	static HRESULT CheckAccess (
	
		SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
		DWORD a_Access , 
		GENERIC_MAPPING *a_Mapping
	) ;

	static HRESULT GetUserSid (

		HANDLE a_Token ,
		ULONG *a_Size ,
		PSID &a_Sid
	) ;

	static HRESULT GetGroupSid (

		HANDLE a_Token ,
		ULONG *a_Size ,
		PSID &a_Sid
	) ;

	static HRESULT GetAceWithProcessTokenUser ( 
					
		DWORD a_ProcessIdentifier ,
		WORD &a_AceSize ,
		ACCESS_ALLOWED_ACE *&a_Ace 
	) ;

	static HRESULT SinkAccessInitialize (

		SECURITY_DESCRIPTOR *a_RegistrationSecurityDescriptor ,
		SECURITY_DESCRIPTOR *&a_SinkSecurityDescriptor
	) ;

	static HRESULT CreateMethodSecurityDescriptor () ;

	static HRESULT DeleteMethodSecurityDescriptor () ;

	static SECURITY_DESCRIPTOR *GetMethodSecurityDescriptor () 
	{
		return s_MethodSecurityDescriptor ;
	}

	static DWORD InitializeTransmitSize () ;
	static DWORD GetTransmitSize () { return s_TransmitBufferSize ; }

	static DWORD InitializeDefaultStackSize () ;
	static DWORD GetDefaultStackSize () { return s_DefaultStackSize ; }

	static HRESULT ValidateClientSecurity (CServerObject_ProviderRegistrationV1& ) ;

} ;

#endif // _CommonGlobals_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\datetime.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  datetime.h
//
//  alanbos  20-Jan-00   Created.
//
//  Datetime helper implementation.
//
//***************************************************************************

#ifndef _DATETIME_H_
#define _DATETIME_H_

#define WBEMDT_DMTF_LEN		25
#define WBEMDT_DMTF_SPOS	14
#define WBEMDT_DMTF_UPOS	21

#define	WBEMDT_MIN_YEAR		0
#define	WBEMDT_MAX_YEAR		9999
#define WBEMDT_MIN_MONTH	1
#define WBEMDT_MAX_MONTH	12
#define WBEMDT_MIN_DAY		1
#define WBEMDT_MAX_DAY		31
#define WBEMDT_MIN_DAYINT	0
#define WBEMDT_MAX_DAYINT	999999
#define	WBEMDT_MIN_HOURS	0
#define	WBEMDT_MAX_HOURS	23
#define	WBEMDT_MIN_MINUTES	0
#define	WBEMDT_MAX_MINUTES	59
#define	WBEMDT_MIN_SECONDS	0
#define	WBEMDT_MAX_SECONDS	59
#define	WBEMDT_MIN_MICROSEC	0
#define	WBEMDT_MAX_MICROSEC	999999
#define	WBEMDT_MIN_UTC		-720
#define	WBEMDT_MAX_UTC		720

#define INVALID_TIME 0xffffffffffffffff

//***************************************************************************
//
//  CLASS NAME:
//
//  CWbemDateTime
//
//  DESCRIPTION:
//
//  Implements the ISWbemDateTime interface.  
//
//***************************************************************************

class CWbemDateTime 
{
private:
	// Private helper class for all the messy business
	class WBEMTime 
	{
		private:
			class WBEMTimeSpan 
			{
				private:

					ULONGLONG m_Time;
					friend class WBEMTime;

				public:

					WBEMTimeSpan ( 
						int iMinutes 
					) 
					{
						m_Time = iMinutes * 60;
						m_Time *= 10000000;
				}
			};

		public:

			WBEMTime ()													{ m_uTime = INVALID_TIME ; }
			WBEMTime ( const SYSTEMTIME &st )							{ *this = st ; }
			WBEMTime ( const FILETIME &ft )	;

			const WBEMTime &operator= ( const SYSTEMTIME &st ) ;
			const WBEMTime &operator= ( const FILETIME &ft ) ;

			WBEMTime    operator+ ( const WBEMTimeSpan &ts ) const;
			WBEMTime    operator- ( const WBEMTimeSpan &sub ) const;

			BOOL GetSYSTEMTIME ( SYSTEMTIME *pst ) const;
			BOOL GetFILETIME ( FILETIME *pst ) const;

			BOOL GetDMTF ( SYSTEMTIME &st, long &offset ) const;
			BOOL GetDMTF ( SYSTEMTIME &st ) const;

			void Clear ( void )											{ m_uTime = INVALID_TIME ; }

			bool IsOk () const											{ return m_uTime != INVALID_TIME ? true : false; }
			
			static LONG WINAPI GetLocalOffsetForDate(const SYSTEMTIME *pst);

		private:
			ULONGLONG m_uTime;
	};

	VARIANT_BOOL		m_bYearSpecified;
	VARIANT_BOOL		m_bMonthSpecified;
	VARIANT_BOOL		m_bDaySpecified;
	VARIANT_BOOL		m_bHoursSpecified;
	VARIANT_BOOL		m_bMinutesSpecified;
	VARIANT_BOOL		m_bSecondsSpecified;
	VARIANT_BOOL		m_bMicrosecondsSpecified;
	VARIANT_BOOL		m_bUTCSpecified;
	VARIANT_BOOL		m_bIsInterval;
	
	long				m_iYear;
	long				m_iMonth;
	long				m_iDay;
	long				m_iHours;
	long				m_iMinutes;
	long				m_iSeconds;
	long				m_iMicroseconds;
	long				m_iUTC;

	bool				CheckField (
								LPWSTR			pValue,
								ULONG			len,
								VARIANT_BOOL	&bIsSpecified,
								long			&iValue,
								long			maxValue,
								long			minValue
						);

	bool				CheckUTC (
								LPWSTR			pValue,
								VARIANT_BOOL	&bIsSpecified,
								long			&iValue,
								bool			bParseSign = true
						);

protected:
public:
    
    CWbemDateTime(void);
    virtual ~CWbemDateTime(void);

	// ISWbemDateTime methods

    HRESULT GetValue ( BSTR *value ) ;
    
    HRESULT PutValue ( BSTR value ) ;

    HRESULT GetYear ( long *value ) 
	{
		*value = m_iYear;

		return S_OK;
	}
    
    HRESULT PutYear ( long value ) 
	{
		HRESULT hr = WBEM_S_NO_ERROR;

		if ((value > WBEMDT_MAX_YEAR) || (value < WBEMDT_MIN_YEAR))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iYear = value;

		return hr;
	}		

    HRESULT GetMonth ( long *value ) 
	{
		*value = m_iMonth;

		return S_OK;
	}
    
    HRESULT PutMonth ( long value ) 
	{
		HRESULT hr = WBEM_S_NO_ERROR;

		if ((value > WBEMDT_MAX_MONTH) || (value < WBEMDT_MIN_MONTH))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iMonth = value;

		return hr;
	}		

	HRESULT GetDay ( long *value ) 
	{
		*value = m_iDay;

		return S_OK;
	}
    
    HRESULT PutDay ( long value ) 
	{
		HRESULT hr = S_OK ;

		if (((VARIANT_TRUE == m_bIsInterval) && ((value > WBEMDT_MAX_DAYINT) || (value < WBEMDT_MIN_DAYINT))) ||
			((VARIANT_FALSE == m_bIsInterval) &&((value > WBEMDT_MAX_DAY) || (value < WBEMDT_MIN_DAY))))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iDay = value;

		return hr;
	}		

	HRESULT GetHours ( long *value ) 
	{
		*value = m_iHours;

		return S_OK;
	}
    
    HRESULT PutHours ( long value ) 
	{
		HRESULT hr = S_OK;

		if ((value > WBEMDT_MAX_HOURS) || (value < WBEMDT_MIN_HOURS))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iHours = value;

		return hr;
	}		

		
	HRESULT GetMinutes ( long *value ) 
	{
		*value = m_iMinutes;

		return S_OK;
	}
    
    HRESULT PutMinutes ( long value ) 
	{
		HRESULT hr = S_OK;

		if ((value > WBEMDT_MAX_MINUTES) || (value < WBEMDT_MIN_MINUTES))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iMinutes = value;

		return hr;
	}		

	HRESULT GetSeconds ( long *value ) 
	{
		*value = m_iSeconds;

		return S_OK;
	}
        
    HRESULT PutSeconds ( long value ) 
	{
		HRESULT hr = S_OK;

		if ((value > WBEMDT_MAX_SECONDS) || (value < WBEMDT_MIN_SECONDS))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iSeconds = value;

		return hr;
	}		


	HRESULT GetMicroseconds ( long *value ) 
	{
		*value = m_iMicroseconds;

		return S_OK;
	}
    
    HRESULT PutMicroseconds ( long value ) 
	{
		HRESULT hr = S_OK;

		if ((value > WBEMDT_MAX_MICROSEC) || (value < WBEMDT_MIN_MICROSEC))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iMicroseconds = value;

		return hr;
	}		

	HRESULT GetUTC ( long *value ) 
	{
		*value = m_iUTC;

		return S_OK;
	}
    
    HRESULT PutUTC( long value ) 
	{
		HRESULT hr = S_OK;

		if ((value > WBEMDT_MAX_UTC) || (value < WBEMDT_MIN_UTC))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iUTC = value;

		return hr;
	}		

	HRESULT GetYearSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bYearSpecified; 

		return S_OK;
	}
    
    HRESULT PutYearSpecified ( VARIANT_BOOL value ) 
	{ 
		HRESULT hr = S_OK;

		if ((VARIANT_TRUE == m_bIsInterval) && (VARIANT_TRUE == value))
			hr = WBEM_E_FAILED ;
		else
			m_bYearSpecified = value;

		return hr;
	}
    
    HRESULT GetMonthSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bMonthSpecified; 

		return S_OK;
	}
    
    HRESULT PutMonthSpecified ( VARIANT_BOOL value ) 
	{ 
		HRESULT hr = S_OK;

		if ((VARIANT_TRUE == m_bIsInterval) && (VARIANT_TRUE == value))
			hr = WBEM_E_FAILED;
		else
			m_bMonthSpecified = value;
		
		return hr;
	}

	HRESULT GetDaySpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bDaySpecified; 

		return S_OK;
	}
    
    HRESULT PutDaySpecified ( VARIANT_BOOL value ) 
	{ 
		m_bDaySpecified = value;

		return S_OK;
	}

	HRESULT GetHoursSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bHoursSpecified; 

		return S_OK;
	}
    
    HRESULT PutHoursSpecified ( VARIANT_BOOL value ) 
	{ 
		m_bHoursSpecified = value;

		return S_OK;
	}
		
	HRESULT GetMinutesSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bMinutesSpecified; 

		return S_OK;
	}
        
    HRESULT PutMinutesSpecified ( VARIANT_BOOL value ) 
	{ 
		m_bMinutesSpecified = value;

		return S_OK;
	}

	HRESULT GetSecondsSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bSecondsSpecified; 

		return S_OK;
	}
    
    HRESULT PutSecondsSpecified ( VARIANT_BOOL value ) 
	{ 
		m_bSecondsSpecified = value;

		return S_OK;
	}

	HRESULT GetMicrosecondsSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bMicrosecondsSpecified; 

		return S_OK;
	}
    
    HRESULT PutMicrosecondsSpecified ( VARIANT_BOOL value ) 
	{ 
		m_bMicrosecondsSpecified = value;

		return S_OK;
	}

	HRESULT GetUTCSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bUTCSpecified; 

		return S_OK;
	}
    
    HRESULT PutUTCSpecified ( VARIANT_BOOL value ) 
	{ 
		HRESULT hr = S_OK;

		if ((VARIANT_TRUE == m_bIsInterval) && (VARIANT_TRUE == value))
			hr = WBEM_E_FAILED;
		else
			m_bUTCSpecified = value;
	
		return hr;
	}

	HRESULT GetIsInterval ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bIsInterval; 

		return S_OK;
	}
    
    HRESULT PutIsInterval( VARIANT_BOOL value ) 
	{ 
		if ((VARIANT_TRUE == m_bIsInterval) && (VARIANT_FALSE == value))
		{
			if (0 == m_iDay)
				m_iDay = 1;
			else if (WBEMDT_MAX_DAY < m_iDay)
				m_iDay = WBEMDT_MAX_DAY;
		}
		else if ((VARIANT_TRUE == value) && (VARIANT_FALSE == m_bIsInterval))
		{
			m_bDaySpecified = VARIANT_TRUE; 
			m_bHoursSpecified = VARIANT_TRUE;
			m_bMinutesSpecified = VARIANT_TRUE;
			m_bSecondsSpecified = VARIANT_TRUE;
			m_bMicrosecondsSpecified = VARIANT_TRUE;
		}

		m_bIsInterval = value;

		return S_OK;
	}

	HRESULT GetVarDate (
 
        VARIANT_BOOL bIsLocal,
		DATE *dVarDate
	) ;
    
    HRESULT SetVarDate ( 

        DATE dVarDate,
		VARIANT_BOOL bIsLocal
	) ;

	HRESULT GetSystemTimeDate (

		SYSTEMTIME &fSystemTime
	) ;

	HRESULT GetFileTimeDate (

		FILETIME &fFileTime
	) ;

	HRESULT SetFileTimeDate ( 

		FILETIME fFileTime,
		VARIANT_BOOL bIsLocal
	) ;

	BOOL Preceeds ( CWbemDateTime &a_Time ) ;
};

#endif // _DATETIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\classfac.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ClassFac.h

Abstract:


History:

--*/

#ifndef _ServerClassFactory_H
#define _ServerClassFactory_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


class ClassFactoryBase : public IClassFactory
  {
  long m_ReferenceCount ;
  public:
    ClassFactoryBase () ;
    virtual ~ClassFactoryBase () ;

    	//IUnknown members

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members
    STDMETHODIMP LockServer ( BOOL ) ;
  };

template <class Object,class ObjectInterface>
class CServerClassFactory : public ClassFactoryBase
{
	//IClassFactory members
    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
};

#include <classfac.cpp>

#endif // _ServerClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\globals.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _Globals_H
#define _Globals_H

#include <pssException.h>
#include <Allocator.h>
#include <BasicTree.h>
#include "cglobals.h"
#include "os.h"
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


class DecoupledProviderSubSystem_Globals
{
public:

	static WmiAllocator *s_Allocator ;

	static LONG s_LocksInProgress ;
	static LONG s_ObjectsInProgress ;
	static LONG s_RegistrarUsers;

    static LONG s_CServerClassFactory_ObjectsInProgress ;
	static LONG s_CServerObject_ProviderRegistrar_ObjectsInProgress  ;
	static LONG s_CServerObject_ProviderEvents_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemSyncProvider_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemServices_Stub_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemProviderInitSink_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemWaitingObjectSink_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemObjectSink_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemSyncObjectSink_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemFilteringObjectSink_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemSyncFilteringObjectSink_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemObjectSinkEx_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemSyncObjectSinkEx_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemCombiningObjectSink_ObjectsInProgress;
	static LONG s_CDecoupledAggregator_IWbemProvider_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemDecoupledUnboundObjectSink_ObjectsInProgress;
	static LONG s_CDecoupled_Batching_IWbemSyncObjectSink_ObjectsInProgress;
	static LONG s_CDecoupled_IWbemSyncObjectSink_ObjectsInProgress;
	static LONG s_CInterceptor_DecoupledClient_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemDecoupledProvider_ObjectsInProgress;
	static LONG s_CDecoupled_IWbemUnboundObjectSink_ObjectsInProgress;

	static HRESULT Global_Startup () ;
	static HRESULT Global_Shutdown () ;


	static HRESULT CreateSystemAces(void);
	static HRESULT DeleteSystemAces(void);

	static HRESULT CreateInstance ( 

		const CLSID &a_ReferenceClsid ,
		LPUNKNOWN a_OuterUnknown ,
		const DWORD &a_ClassContext ,
		const UUID &a_ReferenceInterfaceId ,
		void **a_ObjectInterface
	) 
	{
		return ProviderSubSystem_Common_Globals::CreateInstance( a_ReferenceClsid, a_OuterUnknown, a_ClassContext, a_ReferenceInterfaceId, a_ObjectInterface);
	};
	static HRESULT IsDependantCall ( IWbemContext *a_Parent , IWbemContext *a_ChildContext , BOOL &a_DependantCall )
	{
		return ProviderSubSystem_Common_Globals::IsDependantCall ( a_Parent , a_ChildContext , a_DependantCall );
	} ;

	static HRESULT SetProxyState_SvcHost (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		ACCESS_ALLOWED_ACE *a_Ace ,
		WORD a_AceSize,
		SECURITY_IMPERSONATION_LEVEL t_ImpersonationLevel
	) ;

	static HRESULT RevertProxyState_SvcHost ( 

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;


	static HRESULT RevertProxyState_SvcHost ( 

		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;


	static HRESULT SetProxyState (
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert
	) 
	{
		if (OS::secureOS_)
			return ProviderSubSystem_Common_Globals::SetProxyState(a_InterfaceId, a_Interface, a_Proxy, a_Revert);
		else
			return WBEM_E_NOT_FOUND;
	}

	static HRESULT SinkAccessInitialize (SECURITY_DESCRIPTOR *a_RegistrationSecurityDescriptor ,
					SECURITY_DESCRIPTOR *&a_SinkSecurityDescriptor)
	{
		if (OS::secureOS_) return ProviderSubSystem_Common_Globals::SinkAccessInitialize(a_RegistrationSecurityDescriptor, a_SinkSecurityDescriptor);
		else
		{
		  a_SinkSecurityDescriptor = 0;
		  return S_OK;	
		}
	}


	static HRESULT RevertProxyState ( 
		IUnknown *a_Proxy , 
		BOOL a_Revert
	) 
	{
		if (OS::secureOS_)
			return ProviderSubSystem_Common_Globals::RevertProxyState(a_Proxy, a_Revert);
		else
			return S_OK;
	}

	static HRESULT Check_SecurityDescriptor_CallIdentity ( 
		SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
		DWORD a_Access , 
		GENERIC_MAPPING *a_Mapping
	) 
	{
		if (OS::secureOS_)
			return ProviderSubSystem_Common_Globals::Check_SecurityDescriptor_CallIdentity(a_SecurityDescriptor, a_Access, a_Mapping);
		else
			return S_OK;
	}

	static HRESULT UnMarshalRegistration (

		IUnknown **a_Unknown ,
		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength
	) 
	{
		return ProviderSubSystem_Common_Globals::UnMarshalRegistration(a_Unknown, a_MarshaledProxy, a_MarshaledProxyLength);
	};

	static HRESULT MarshalRegistration (

		IUnknown *a_Unknown ,
		BYTE *&a_MarshaledProxy ,
		DWORD &a_MarshaledProxyLength
	) 
	{
		return ProviderSubSystem_Common_Globals::MarshalRegistration(a_Unknown, a_MarshaledProxy, a_MarshaledProxyLength);
	}

	static HRESULT SetCloaking ( IUnknown * proxy , DWORD authenticationLevel , DWORD impersonationLevel ) ;

	static HRESULT RevertProxyState ( 

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		IUnknown *a_Proxy , 
		BOOL a_Revert
	) 
	{
		if (OS::secureOS_)
			return ProviderSubSystem_Common_Globals::RevertProxyState(a_Container, a_ProxyIndex, a_Proxy, a_Revert);
		else
            return S_OK;
	};

	static HRESULT BeginImpersonation (

		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating,
		DWORD *a_AuthenticationLevel = NULL
	) ;

	static HRESULT EndImpersonation (
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_Impersonating
	)
	{
		if (OS::secureOS_)
			return ProviderSubSystem_Common_Globals::EndImpersonation(a_OldContext, a_OldSecurity, a_Impersonating);
		else
            return S_OK;
	};

	static HRESULT SetProxyState (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert
	) 
	{
		if (OS::secureOS_)
			return ProviderSubSystem_Common_Globals::SetProxyState(a_Container, a_ProxyIndex, a_InterfaceId, a_Interface, a_Proxy, a_Revert);
		else
			return WBEM_E_NOT_FOUND;
	}

	static HRESULT GetAceWithProcessTokenUser ( 
					
		DWORD a_ProcessIdentifier ,
		WORD &a_AceSize ,
		ACCESS_ALLOWED_ACE *&a_Ace 
	) ;

	static HRESULT GetUserSid (

		HANDLE a_Token ,
		ULONG *a_Size ,
		PSID &a_Sid
	) ;

	static DWORD GetCurrentImpersonationLevel ()
	{
		if (OS::secureOS_)
			return ProviderSubSystem_Common_Globals:: GetCurrentImpersonationLevel();
		else
			return RPC_C_IMP_LEVEL_ANONYMOUS;
	}


	static HRESULT BeginCallbackImpersonation (

		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating
	);
	
	static HRESULT CheckAccess ( 
		SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
		DWORD a_Access , 
		GENERIC_MAPPING *a_Mapping)
	{
		if (OS::secureOS_)
			return ProviderSubSystem_Common_Globals::CheckAccess(a_SecurityDescriptor, a_Access, a_Mapping);
		else
            return S_OK;

	}

	static HRESULT BeginThreadImpersonation (

		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating
	) ;

	static HRESULT EndThreadImpersonation (

		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_Impersonating 
	) ;

	static HRESULT Begin_IdentifyCall_PrvHost (

		WmiInternalContext a_InternalContext ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity
	) ;

	static HRESULT End_IdentifyCall_PrvHost (

		WmiInternalContext a_InternalContext ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating 
	) ;

	static HRESULT Begin_IdentifyCall_SvcHost (

		WmiInternalContext a_InternalContext ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity
	) ;

	static HRESULT End_IdentifyCall_SvcHost (

		WmiInternalContext a_InternalContext ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating
	) ;



} ;

#endif // _Globals_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\guids.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Guids.h

Abstract:


History:

--*/


// {54D8502C-527D-43f7-A506-A9DA075E229C}
DEFINE_GUID(CLSID_WmiDCProxyProvider, 
0x54d8502c, 0x527d, 0x43f7, 0xa5, 0x6, 0xa9, 0xda, 0x7, 0x5e, 0x22, 0x9c);

// {8D955AC7-AF43-407a-A838-C26080B6671B}
DEFINE_GUID(IID_CacheElement, 
0x8d955ac7, 0xaf43, 0x407a, 0xa8, 0x38, 0xc2, 0x60, 0x80, 0xb6, 0x67, 0x1b);

// {F7BF10E6-A310-4530-8B63-B3354C485E2D}
DEFINE_GUID(IID_CWbemGlobal_IWmiObjectSinkController, 
0xf7bf10e6, 0xa310, 0x4530, 0x8b, 0x63, 0xb3, 0x35, 0x4c, 0x48, 0x5e, 0x2d);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\null_wmi.h ===
class NULL_IWbemServices: public IWbemServices{
public:
	NULL_IWbemServices ( HRESULT hr ) : ret_ ( hr) { };


    /* IUnk not implemented */

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE 
	OpenNamespace ( const BSTR, long, IWbemContext *, IWbemServices **, IWbemCallResult ** )
	{ return ret_; };
    
    HRESULT STDMETHODCALLTYPE 
	CancelAsyncCall ( IWbemObjectSink *a_Sink )
	{ return ret_; };

    
    HRESULT STDMETHODCALLTYPE 
	QueryObjectSink ( long, IWbemObjectSink ** )
	{ return ret_; };

    
    HRESULT STDMETHODCALLTYPE 
	GetObject ( const BSTR , long , IWbemContext *, IWbemClassObject **, IWbemCallResult **)
	{ return ret_; };
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE PutClass (IWbemClassObject *, long , IWbemContext *, IWbemCallResult **)
	{ return ret_; };

    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) 	{ return ret_; };
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE 
	ExecNotificationQueryAsync ( const BSTR, const BSTR, long, IWbemContext *, IWbemObjectSink *)
	{ return ret_; };
    
    HRESULT STDMETHODCALLTYPE 
	ExecMethod ( const BSTR, const BSTR, long, IWbemContext *, IWbemClassObject *, IWbemClassObject **, IWbemCallResult **)
	{ return ret_; };
    
    HRESULT STDMETHODCALLTYPE 
	ExecMethodAsync ( const BSTR, const BSTR, long, IWbemContext *, IWbemClassObject *, IWbemObjectSink *)
	{ return ret_; };

private:
	HRESULT	ret_;
	NULL_IWbemServices(const NULL_IWbemServices&);
	const NULL_IWbemServices& operator=(const NULL_IWbemServices&);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\os.h ===
#ifndef __OS_H__
#define __OS_H__

namespace OS
{
	enum { NT4 = 4 };
	bool unicodeOS();
	extern const bool unicodeOS_;
	extern const bool secureOS_;
	extern const int osVer_;
	
	LONG RegOpenKeyExW (HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
	LONG RegCreateKeyExW (HKEY hKey, LPCTSTR lpSubKey,DWORD Reserved, LPTSTR lpClass,DWORD dwOptions,REGSAM samDesired,LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
	LONG RegEnumKeyExW (HKEY hKey,DWORD dwIndex,LPTSTR lpName,LPDWORD lpcName,LPDWORD lpReserved,LPTSTR lpClass,LPDWORD lpcClass,PFILETIME lpftLastWriteTime);
	LONG RegDeleteKeyW (HKEY hKey, LPCTSTR lpSubKey);
	LONG RegQueryValueExW(
  HKEY hKey,            // handle to key
  LPCTSTR lpValueName,  // value name
  LPDWORD lpReserved,   // reserved
  LPDWORD lpType,       // type buffer
  LPBYTE lpData,        // data buffer
  LPDWORD lpcbData      // size of data buffer
);

LONG RegSetValueExW(
  HKEY hKey,           // handle to key
  LPCTSTR lpValueName, // value name
  DWORD Reserved,      // reserved
  DWORD dwType,        // value type
  CONST BYTE *lpData,  // value data
  DWORD cbData         // size of value data
);

	HRESULT CoImpersonateClient();

	BOOL GetProcessTimes(
  HANDLE hProcess,           // handle to process
  LPFILETIME lpCreationTime, // process creation time
  LPFILETIME lpExitTime,     // process exit time
  LPFILETIME lpKernelTime,   // process kernel-mode time
  LPFILETIME lpUserTime      // process user-mode time
);
  
  HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName );
  HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bInitialOwner, LPCWSTR lpName );
  wchar_t ToUpper(wchar_t c);
  wchar_t ToLower(wchar_t c);
  bool wbem_iswdigit(wchar_t c);
  bool wbem_iswalnum (wchar_t c);



};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provcache.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Cache.H

Abstract:


History:

--*/

#ifndef _Server_Cache_H
#define _Server_Cache_H

#include <Allocator.h>
#include <Algorithms.h>
#include <TPQueue.h>
#include <BasicTree.h>
#include <Cache.h>

#include "ProvRegInfo.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern LONG CompareElement ( const GUID &a_Arg1 , const GUID &a_Arg2 ) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class ProviderCacheKey 
{
public:

	BSTR m_User ;
	BSTR m_Locale ;
	Enum_Hosting m_HostingSpecification ;
	BSTR m_Provider ;
	bool m_Raw ;
	GUID *m_TransactionIdentifier ;	

public:

	ProviderCacheKey () :

		m_User ( NULL ) ,
		m_Locale ( NULL ) ,
		m_Raw ( false ) ,
		m_Provider ( NULL ) ,
		m_TransactionIdentifier ( NULL ) ,
		m_HostingSpecification ( e_Hosting_Undefined )
	{
	}

	ProviderCacheKey ( 

		const ProviderCacheKey &a_Key

	) : m_User ( NULL ) ,
		m_Locale ( NULL ) ,
		m_TransactionIdentifier ( NULL ) ,
		m_Raw ( a_Key.m_Raw ) ,
		m_HostingSpecification ( a_Key.m_HostingSpecification ) ,
		m_Provider ( NULL )
	{
		if ( a_Key.m_User )
		{
			m_User = SysAllocString ( a_Key.m_User ) ;
		}

		if ( a_Key.m_Locale )
		{
			m_Locale = SysAllocString ( a_Key.m_Locale ) ;
		}

		if ( a_Key.m_Provider ) 
		{
			m_Provider = SysAllocString ( a_Key.m_Provider ) ;
		}

		if ( a_Key.m_TransactionIdentifier )
		{
			m_TransactionIdentifier = new GUID ;
			*m_TransactionIdentifier = *a_Key.m_TransactionIdentifier ;
		}
	}	
	
	ProviderCacheKey ( 

		const wchar_t *a_Provider ,
		const Enum_Hosting &a_HostingSpecification ,
		const bool a_Raw ,
		GUID *a_TransactionIdentifier ,
		const wchar_t *a_User ,
		const wchar_t *a_Locale
	) :
		m_Raw ( a_Raw ) ,
		m_Provider ( NULL ) ,
		m_HostingSpecification ( a_HostingSpecification ),
		m_TransactionIdentifier ( NULL ) ,
		m_User ( NULL ) ,
		m_Locale ( NULL )
	{
		if ( a_User )
		{
			m_User = SysAllocString ( a_User ) ;
		}

		if ( a_Locale )
		{
			m_Locale = SysAllocString ( a_Locale ) ;
		}

		if ( a_Provider ) 
		{
			m_Provider = SysAllocString ( a_Provider ) ;
		}

		if ( a_TransactionIdentifier )
		{
			m_TransactionIdentifier = new GUID ;
			*m_TransactionIdentifier = *a_TransactionIdentifier ;
		}
	}

	~ProviderCacheKey ()
	{
		if ( m_User )
		{
			SysFreeString ( m_User ) ;
		}

		if ( m_Locale )
		{
			SysFreeString ( m_Locale ) ;
		}

		if ( m_Provider ) 
		{
			SysFreeString ( m_Provider ) ;
		}

		if ( m_TransactionIdentifier )
		{
			delete m_TransactionIdentifier ;
		}
	}

	ProviderCacheKey &operator= ( const ProviderCacheKey &a_Key ) 
	{
		m_Raw = a_Key.m_Raw ;
		m_HostingSpecification = a_Key.m_HostingSpecification ;

		if ( m_User )
		{
			SysFreeString ( m_User ) ;
		}

		if ( m_Locale )
		{
			SysFreeString ( m_Locale ) ;
		}

		if ( m_Provider ) 
		{
			SysFreeString ( m_Provider ) ;
		}

		if ( m_TransactionIdentifier )
		{
			delete m_TransactionIdentifier ;
		}
	
		if ( a_Key.m_User )
		{
			m_User = SysAllocString ( a_Key.m_User ) ;
		}

		if ( a_Key.m_Locale )
		{
			m_Locale = SysAllocString ( a_Key.m_Locale ) ;
		}

		if ( a_Key.m_Provider ) 
		{
			m_Provider = SysAllocString ( a_Key.m_Provider ) ;
		}

		if ( a_Key.m_TransactionIdentifier )
		{
			m_TransactionIdentifier = new GUID ;
			*m_TransactionIdentifier = *a_Key.m_TransactionIdentifier ;
		}

		return *this ;
	}

	LONG CompareUser ( const BSTR a_User ) const
	{
		if ( m_User && a_User )
		{
			return _wcsicmp ( m_User , a_User ) ;
		}	
		else
		{
			return m_User == a_User ? 0 : ( m_User < a_User ) ? -1 : 1 ;
		}
	}

	LONG CompareLocale ( const BSTR a_Locale ) const
	{
		if ( m_Locale && a_Locale )
		{
			return _wcsicmp ( m_Locale , a_Locale ) ;
		}	
		else
		{
			return m_Locale == a_Locale ? 0 : ( m_Locale < a_Locale ) ? -1 : 1 ;
		}
	}

	LONG CompareProvider ( const BSTR a_Provider ) const
	{
		if ( m_Provider && a_Provider )
		{
			return _wcsicmp ( m_Provider , a_Provider ) ;
		}	
		else
		{
			return m_Provider == a_Provider ? 0 : ( m_Provider < a_Provider ) ? -1 : 1 ;
		}
	}

	LONG CompareTransaction ( const GUID *a_TransactionIdentifier ) const 
	{
		if ( m_TransactionIdentifier && a_TransactionIdentifier )
		{
			return CompareElement ( *m_TransactionIdentifier , *a_TransactionIdentifier ) ;
		}	
		else
		{
			return m_TransactionIdentifier == a_TransactionIdentifier ? 0 : ( m_TransactionIdentifier < a_TransactionIdentifier ) ? -1 : 1 ;
		}
	}

	LONG Compare ( const ProviderCacheKey &a_Key ) const
	{
		LONG t_CompareUser = CompareUser ( a_Key.m_User ) ;
		if ( t_CompareUser == 0 )
		{
			LONG t_CompareLocale = CompareLocale ( a_Key.m_Locale ) ;
			if ( t_CompareLocale == 0 )
			{
				if ( m_Raw == a_Key.m_Raw ) 
				{
					LONG t_CompareProvider = CompareProvider ( a_Key.m_Provider ) ;
					if ( t_CompareProvider == 0 )
					{
						if ( CompareTransaction ( a_Key.m_TransactionIdentifier ) == 0 )
						{
							return m_HostingSpecification - a_Key.m_HostingSpecification ;
						}
						else
						{
							return CompareElement ( m_TransactionIdentifier , a_Key.m_TransactionIdentifier ) ;
						}
					}
					else
					{
						return t_CompareProvider ;
					}
				}
				else
				{
					return m_Raw - a_Key.m_Raw ;
				}
			}	
			else
			{
				return t_CompareLocale ;
			}
		}	
		else
		{
			return t_CompareUser ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern LONG CompareElement ( const ProviderCacheKey &a_Arg1 , const ProviderCacheKey &a_Arg2 ) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_BindingFactory ;


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemProvider ;

typedef WmiCacheController <ProviderCacheKey>					CWbemGlobal_IWmiProviderController ;
typedef CWbemGlobal_IWmiProviderController :: Cache				CWbemGlobal_IWmiProviderController_Cache ;
typedef CWbemGlobal_IWmiProviderController :: Cache_Iterator		CWbemGlobal_IWmiProviderController_Cache_Iterator ;
typedef CWbemGlobal_IWmiProviderController :: WmiCacheElement	ServiceCacheElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemObjectSink ;

typedef WmiContainerController <void *>										CWbemGlobal_IWmiObjectSinkController ;
typedef CWbemGlobal_IWmiObjectSinkController :: Container					CWbemGlobal_IWmiObjectSinkController_Container ;
typedef CWbemGlobal_IWmiObjectSinkController :: Container_Iterator			CWbemGlobal_IWmiObjectSinkController_Container_Iterator ;
typedef CWbemGlobal_IWmiObjectSinkController :: WmiContainerElement			ObjectSinkContainerElement ;


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderSubSystem ;

typedef WmiContainerController <void *>										CWbemGlobal_IWmiProvSubSysController ;
typedef CWbemGlobal_IWmiProvSubSysController :: Container					CWbemGlobal_IWmiProvSubSysController_Container ;
typedef CWbemGlobal_IWmiProvSubSysController :: Container_Iterator			CWbemGlobal_IWmiProvSubSysController_Container_Iterator ;
typedef CWbemGlobal_IWmiProvSubSysController :: WmiContainerElement			ProvSubSysContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncProvider ;

typedef WmiContainerController <GUID>										CWbemGlobal_IWbemSyncProviderController ;
typedef CWbemGlobal_IWbemSyncProviderController :: Container				CWbemGlobal_IWbemSyncProvider_Container ;
typedef CWbemGlobal_IWbemSyncProviderController :: Container_Iterator		CWbemGlobal_IWbemSyncProvider_Container_Iterator ;
typedef CWbemGlobal_IWbemSyncProviderController :: WmiContainerElement		SyncProviderContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef WmiContainerController <DWORD>										CWbemGlobal_HostedProviderController ;
typedef CWbemGlobal_HostedProviderController :: Container					CWbemGlobal_HostedProviderController_Container ;
typedef CWbemGlobal_HostedProviderController :: Container_Iterator			CWbemGlobal_HostedProviderController_Container_Iterator ;
typedef CWbemGlobal_HostedProviderController :: WmiContainerElement			HostedProviderContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


#endif _Server_Cache_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provdnf.h ===
// (C) 1999-2001 Microsoft Corporation 

#ifndef __DNF_TREE_H
#define __DNF_TREE_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#include <stdio.h>
#include <wmiutils.h>

#include "ProvTree.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum WmiTriState
{
	State_False		= 0 ,
	State_True		= 1 ,
	State_Error		= 0xFFFFFFFF
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define TypeId_WmiOrNode						1
#define TypeId_WmiAndNode						2
#define TypeId_WmiNotNode						3
#define TypeId_WmiOperatorNode					4
#define TypeId_WmiOperatorEqualNode				5
#define TypeId_WmiOperatorNotEqualNode			6
#define TypeId_WmiOperatorEqualOrGreaterNode	7
#define TypeId_WmiOperatorEqualOrLessNode		8
#define TypeId_WmiOperatorGreaterNode			9
#define TypeId_WmiOperatorLessNode				10
#define TypeId_WmiOperatorLikeNode				11
#define TypeId_WmiOperatorNotLikeNode			12
#define TypeId_WmiOperatorIsANode				13
#define TypeId_WmiOperatorNotIsANode			14
#define TypeId_WmiValueNode						15
#define TypeId_WmiSignedIntegerNode				16	
#define TypeId_WmiUnsignedIntegerNode			17
#define TypeId_WmiStringNode					18
#define TypeId_WmiNullNode						19
#define TypeId_WmiRangeNode						20
#define TypeId_WmiUnsignedIntegerRangeNode		21
#define TypeId_WmiSignedIntegerRangeNode		22
#define TypeId_WmiStringRangeNode				23
#define TypeId_WmiNullRangeNode					24

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOrNode : public WmiTreeNode
{
private:
protected:
public:

	WmiOrNode ( 

		WmiTreeNode *a_Left = NULL , 
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( TypeId_WmiOrNode , NULL , a_Left , a_Right , a_Parent ) {}

	~WmiOrNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiAndNode : public WmiTreeNode
{
private:
protected:
public:

	WmiAndNode ( 

		WmiTreeNode *a_Left = NULL , 
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( TypeId_WmiAndNode , NULL , a_Left , a_Right , a_Parent ) {}

	~WmiAndNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiNotNode : public WmiTreeNode
{
private:
protected:
public:

	WmiNotNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( TypeId_WmiNotNode , NULL , a_Node , NULL , a_Parent ) {}

	~WmiNotNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiRangeNode ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorNode : public WmiTreeNode
{
private:
protected:
public:

	WmiOperatorNode ( 

		TypeId_TreeNode a_Type , 
		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( a_Type , NULL , a_Node , NULL , a_Parent ) {}

	~WmiOperatorNode () {} ;

	virtual WmiTriState GetRange (WmiRangeNode *&) = 0 ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorEqualNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorEqualNode , a_Node , a_Parent ) {}

	~WmiOperatorEqualNode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *&) ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorNotEqualNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotEqualNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorNotEqualNode , a_Node , a_Parent ) {}

	~WmiOperatorNotEqualNode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *& a_Range ) { a_Range = 0; return ::State_True; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorEqualOrGreaterNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualOrGreaterNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorEqualOrGreaterNode , a_Node , a_Parent ) {}

	~WmiOperatorEqualOrGreaterNode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *&) ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorEqualOrLessNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualOrLessNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorEqualOrLessNode , a_Node , a_Parent ) {}

	~WmiOperatorEqualOrLessNode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *&) ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorGreaterNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorGreaterNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorGreaterNode , a_Node , a_Parent ) {}

	~WmiOperatorGreaterNode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *&) ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorLessNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorLessNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorLessNode , a_Node , a_Parent ) {}

	~WmiOperatorLessNode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *&) ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorLikeNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorLikeNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorLikeNode , a_Node , a_Parent ) {}

	~WmiOperatorLikeNode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *&) ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
 
class WmiOperatorNotLikeNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotLikeNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorNotLikeNode , a_Node , a_Parent ) {}

	~WmiOperatorNotLikeNode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *&) ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorIsANode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorIsANode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorIsANode , a_Node , a_Parent ) {}

	~WmiOperatorIsANode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *&) ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorNotIsANode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotIsANode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorNotIsANode , a_Node , a_Parent ) {}

	~WmiOperatorNotIsANode () ;

	WmiTreeNode *Copy () ;

	WmiTriState GetRange (WmiRangeNode *&) ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiValueNode : public WmiTreeNode
{
public:

	enum WmiValueFunction
	{
		Function_None = 0 ,
		Function_Upper = 1 ,
		Function_Lower = 2
	} ;

private:
protected:

	BSTR m_PropertyName ;
	ULONG m_Index ;
	WmiValueFunction m_PropertyFunction ;
	WmiValueFunction m_ConstantFunction ;

public:

	WmiValueNode ( 

		TypeId_TreeNode a_Type ,
		BSTR a_PropertyName ,
		WmiValueFunction a_PropertyFunction ,
		WmiValueFunction a_ConstantFunction ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( a_Type , NULL , NULL , NULL , a_Parent ) ,
		m_PropertyFunction ( a_PropertyFunction ) ,
		m_ConstantFunction ( a_ConstantFunction ) ,
		m_Index ( a_Index )
	{
		if ( a_PropertyName )
		{
			m_PropertyName = SysAllocString ( a_PropertyName ) ;
			SetValid(m_PropertyName != NULL);
		}
		else
		{
			m_PropertyName = NULL ;
		}
	}

	~WmiValueNode ()
	{
		SysFreeString ( m_PropertyName ) ;
	}

	BSTR GetPropertyName ()
	{
		return m_PropertyName ;
	}

	ULONG GetIndex () { return m_Index ; }

	WmiValueNode :: WmiValueFunction GetPropertyFunction ()
	{
		return m_PropertyFunction ;
	}

	WmiValueNode :: WmiValueFunction GetConstantFunction ()
	{
		return m_ConstantFunction ;
	}

	LONG ComparePropertyName ( WmiValueNode &a_ValueNode ) 
	{
		if ( m_Index < a_ValueNode.m_Index )
		{
			return -1 ;
		}
		else if ( m_Index > a_ValueNode.m_Index )
		{
			return 1 ;
		}
		else
		{
			return _wcsicmp ( m_PropertyName , a_ValueNode.m_PropertyName ) ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiSignedIntegerNode : public WmiValueNode
{
private:
protected:

	LONG m_Integer ;

public:

	WmiSignedIntegerNode ( 

		BSTR a_PropertyName ,
		LONG a_Integer ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiSignedIntegerNode ,
			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 
		) , m_Integer ( a_Integer ) 
	{
	}

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( LONG &a_Integer )
	{
		if ( m_Integer == 0x80000000 )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer - 1 ;
			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( LONG &a_Integer )
	{
		if ( m_Integer == 0x7FFFFFFF )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer + 1 ;
			return TRUE ;
		}
	}

	LONG GetValue ()
	{
		return m_Integer ;
	}

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiUnsignedIntegerNode : public WmiValueNode
{
private:
protected:

	ULONG m_Integer ;

public:

	WmiUnsignedIntegerNode ( 

		BSTR a_PropertyName ,
		ULONG a_Integer ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiUnsignedIntegerNode ,
			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 

		) , m_Integer ( a_Integer ) 
	{
	}

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( ULONG &a_Integer )
	{
		if ( m_Integer == 0 )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer - 1 ;
			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( ULONG &a_Integer )
	{
		if ( m_Integer == 0xFFFFFFFF )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer + 1 ;
			return TRUE ;
		}
	}

	ULONG GetValue ()
	{
		return m_Integer ;
	}

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiStringNode : public WmiValueNode
{
private:
protected:

	BSTR m_String ;

public:

	WmiStringNode ( 

		BSTR a_PropertyName ,
		BSTR a_String ,
		WmiValueNode :: WmiValueFunction a_PropertyFunction ,
		WmiValueNode :: WmiValueFunction a_ConstantFunction ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiStringNode ,
			a_PropertyName , 
			a_PropertyFunction , 
			Function_None ,
			a_Index ,
			a_Parent 
		) 
	{
		if ( a_String ) 
		{
			ULONG t_StringLength = wcslen ( a_String ) ;
			m_String = SysAllocString ( a_String) ;	
			if (!m_String) 
				{
					SetValid(false);
					return;
				}

			if ( a_ConstantFunction == Function_Upper || a_ConstantFunction == Function_Upper)
			{
				for ( ULONG t_Index = 0 ; t_Index < t_StringLength ; t_Index ++ )
				{
					m_String [ t_Index ] = wbem_towlower ( a_String [ t_Index ] ) ;
				}
			}
		}
		else
		{
			m_String = NULL ;
		}
	}

	~WmiStringNode ()
	{
		if ( m_String )
		{
			SysFreeString ( m_String ) ;
		}
	} ;

	WmiTreeNode *Copy () ;


	BSTR GetValue ()
	{
		return m_String ;
	}

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiNullNode : public WmiValueNode
{
private:
protected:
public:

	WmiNullNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiNullNode ,
			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 
		) 
	{
	}

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiRangeNode : public WmiTreeNode
{
private:
protected:

	BSTR m_PropertyName ;
	ULONG m_Index ;

	BOOL m_InfiniteLowerBound ;
	BOOL m_InfiniteUpperBound ;

	BOOL m_LowerBoundClosed;
	BOOL m_UpperBoundClosed;

public:

	LONG ComparePropertyName ( WmiRangeNode &a_RangeNode ) 
	{
		if ( m_Index < a_RangeNode.m_Index )
		{
			return -1 ;
		}
		else if ( m_Index > a_RangeNode.m_Index )
		{
			return 1 ;
		}
		else
		{
			return _wcsicmp ( m_PropertyName , a_RangeNode.m_PropertyName ) ;
		}
	}

public:

	WmiRangeNode ( 

		TypeId_TreeNode a_Type ,
		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 
		
	) : WmiTreeNode ( a_Type , NULL , NULL , a_NextNode , a_Parent ),
		m_InfiniteLowerBound ( a_InfiniteLowerBound ) , 
		m_InfiniteUpperBound ( a_InfiniteUpperBound ) ,
		m_LowerBoundClosed ( a_LowerBoundClosed ) ,
		m_UpperBoundClosed ( a_UpperBoundClosed ) ,
		m_Index ( a_Index )
	{
		if ( a_PropertyName )
		{
			m_PropertyName = SysAllocString ( a_PropertyName ) ;
			SetValid(m_PropertyName != NULL);
		}
		else
		{
			m_PropertyName = NULL ;
		}
	} ;

	~WmiRangeNode () 
	{
		if ( m_PropertyName )
		{
			SysFreeString ( m_PropertyName ) ;
		}
	} ;

	BSTR GetPropertyName ()
	{
		return m_PropertyName ;
	}

	ULONG GetIndex () { return m_Index ; }

	BOOL InfiniteLowerBound () { return m_InfiniteLowerBound ; }
	BOOL InfiniteUpperBound () { return m_InfiniteUpperBound ; }

	BOOL ClosedLowerBound () { return m_LowerBoundClosed ; }
	BOOL ClosedUpperBound () { return m_UpperBoundClosed ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiUnsignedIntegerRangeNode : public WmiRangeNode
{
private:
protected:

	ULONG m_LowerBound ;
	ULONG m_UpperBound ;

public:

	WmiTreeNode *Copy () ;
	
	WmiTriState GetIntersectingRange (

		WmiUnsignedIntegerRangeNode &a_Range ,
		WmiUnsignedIntegerRangeNode *&a_Intersection
	) ;

	WmiTriState GetOverlappingRange (

		WmiUnsignedIntegerRangeNode &a_Range ,
		WmiUnsignedIntegerRangeNode *&a_Intersection
	) ;

public:

	WmiUnsignedIntegerRangeNode (

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		ULONG a_LowerBound ,
		ULONG a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiUnsignedIntegerRangeNode ,
			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) , 
		m_LowerBound ( a_LowerBound ) , 
		m_UpperBound ( a_UpperBound ) 
	{
	}

	ULONG LowerBound () { return m_LowerBound ; }
	ULONG UpperBound () { return m_UpperBound ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiSignedIntegerRangeNode : public WmiRangeNode
{
private:
protected:

	LONG m_LowerBound ;
	LONG m_UpperBound ;

public:

	WmiTreeNode *Copy () ;

	WmiTriState GetIntersectingRange (

		WmiSignedIntegerRangeNode &a_Range ,
		WmiSignedIntegerRangeNode *&a_Intersection
	) ;

	WmiTriState GetOverlappingRange (

		WmiSignedIntegerRangeNode &a_Range ,
		WmiSignedIntegerRangeNode *&a_Intersection
	) ;


public:

	WmiSignedIntegerRangeNode (

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		LONG a_LowerBound ,
		LONG a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiSignedIntegerRangeNode ,
			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) , 
		m_LowerBound ( a_LowerBound ) , 
		m_UpperBound ( a_UpperBound ) 
	{
	}

	LONG LowerBound () { return m_LowerBound ; }
	LONG UpperBound () { return m_UpperBound ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
 
class WmiStringRangeNode : public WmiRangeNode
{
private:
protected:

	BSTR m_LowerBound ;
	BSTR m_UpperBound ;

public:

	WmiTreeNode *Copy () ;

	WmiTriState GetIntersectingRange (

		WmiStringRangeNode &a_Range ,
		WmiStringRangeNode *&a_Intersection
	) ;

	WmiTriState GetOverlappingRange (

		WmiStringRangeNode &a_Range ,
		WmiStringRangeNode *&a_Intersection
	) ;


public:

	WmiStringRangeNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		BSTR a_LowerBound ,
		BSTR a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiStringRangeNode ,
			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) 
	{
		if ( a_LowerBound )
		{
			m_LowerBound = SysAllocString ( a_LowerBound ) ;
			SetValid(m_LowerBound != NULL);
		}
		else
		{
			m_LowerBound = NULL ;
		}

		if ( a_UpperBound )
		{
			m_UpperBound = SysAllocString ( a_UpperBound ) ;
			SetValid(m_UpperBound != NULL);			
		}
		else
		{
			m_UpperBound = NULL ;
		}
	}

	~WmiStringRangeNode ()
	{
		if ( m_LowerBound )
		{
			SysFreeString ( m_LowerBound ) ;
		}

		if ( m_UpperBound )
		{
			SysFreeString ( m_UpperBound ) ;
		}
	} ;

	BSTR LowerBound () { return m_LowerBound ; }
	BSTR UpperBound () { return m_UpperBound ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiNullRangeNode : public WmiRangeNode
{
private:
protected:
public:

	WmiNullRangeNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiNullRangeNode ,
			a_PropertyName , 
			a_Index , 
			TRUE ,
			TRUE ,
			FALSE ,
			FALSE ,
			a_NextNode ,
			a_Parent 
		) 
	{
	}

	~WmiNullRangeNode ()
	{
	} ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Conjunctions
{
private:
protected:

/* 
 *	Range values for the set of properties in a disjunction.
 *	Array index is ordered in property order.
 */

	ULONG m_RangeContainerCount ;
	WmiRangeNode **m_RangeContainer ;
	
public:

	Conjunctions (

		ULONG a_RangeContainerCount 

	) :	m_RangeContainerCount ( a_RangeContainerCount ) ,
		m_RangeContainer ( NULL )
	{
	}

	~Conjunctions () 
	{
		if ( m_RangeContainer )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_RangeContainerCount ; t_Index ++ )
			{
				delete m_RangeContainer [ t_Index ] ;
			}

			delete [] m_RangeContainer ;
		}
	} ;	

	WmiTriState Initialize ()
	{
		WmiTriState t_Status = State_True ;

		m_RangeContainer = new WmiRangeNode * [ m_RangeContainerCount ] ;
		if ( m_RangeContainer )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_RangeContainerCount ; t_Index ++ )
			{
				m_RangeContainer [ t_Index ] = NULL ;
			}
		}
		else
		{
			t_Status = State_Error ; 
		}

		return t_Status ;
	}

	ULONG GetRangeCount () 
	{
		return m_RangeContainerCount ;
	}

	WmiRangeNode *GetRange ( ULONG a_Index ) 
	{
		if ( m_RangeContainerCount > a_Index ) 
		{
			return m_RangeContainer [ a_Index ] ;
		}
		else
		{
			return NULL ;
		}
	}

	void SetRange ( ULONG a_Index , WmiRangeNode *a_Range ) 
	{
		if ( m_RangeContainerCount > a_Index ) 
		{
			if ( m_RangeContainer [ a_Index ] )
			{
				delete m_RangeContainer [ a_Index ] ;
			}

			m_RangeContainer [ a_Index ] = a_Range ;
		}		
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Disjunctions 
{
private:
protected:

/* 
 *	Range values for the set of properties in a disjunction.
 *	Array index is ordered in property order.
 */

	ULONG m_ConjunctionCount ;
	ULONG m_DisjunctionCount ;
	Conjunctions **m_Disjunction ;
	
public:

	Disjunctions (

		ULONG a_DisjunctionCount ,
		ULONG a_ConjunctionCount 

	) :	m_DisjunctionCount ( a_DisjunctionCount ) ,
		m_ConjunctionCount ( a_ConjunctionCount ) ,
		m_Disjunction ( NULL )
	{
	}

	WmiTriState Initialize ()
	{
		WmiTriState t_Status = State_True ;

		m_Disjunction = new Conjunctions * [ m_DisjunctionCount ] ;
		if ( m_Disjunction )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
			{
				m_Disjunction [ t_Index ] = NULL ;
			}

			for ( t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
			{
				Conjunctions *t_Disjunction = new Conjunctions ( m_ConjunctionCount ) ;
				if ( t_Disjunction )
				{
					t_Status = t_Disjunction->Initialize () ;
					if ( t_Status != State_True )
					{
						break ;
					}
				}
				else
				{
					t_Status = State_Error ;
					break ;
				}

				m_Disjunction [ t_Index ] = t_Disjunction ;
			}
		}
		else
		{
			t_Status = State_Error ;
		}

		return t_Status ;
	}

	~Disjunctions () 
	{
		if ( m_Disjunction )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
			{
				Conjunctions *t_Disjunction = m_Disjunction [ t_Index ] ;
				delete t_Disjunction ;
			}
			
			delete [] m_Disjunction ;
		}
	} ;	

	ULONG GetDisjunctionCount () 
	{
		return m_DisjunctionCount ;
	}

	ULONG GetConjunctionCount () 
	{
		return m_ConjunctionCount ;
	}

	Conjunctions *GetDisjunction ( ULONG a_Index ) 
	{
		if ( m_DisjunctionCount > a_Index ) 
		{
			return m_Disjunction [ a_Index ] ;
		}
		else
		{
			return NULL ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class PartitionSet
{
private:
protected:

/*
 *	Null for top level
 */
	ULONG m_KeyIndex ;
	WmiRangeNode *m_Range ;

/*
 *	Number of non overlapping partitions, zero when all keys have been partitioned
 */

	ULONG m_NumberOfNonOverlappingPartitions ;
	PartitionSet **m_NonOverlappingPartitions ;

public:

	PartitionSet ()	:	m_Range ( NULL ) ,
						m_KeyIndex ( 0 ) ,
						m_NumberOfNonOverlappingPartitions ( 0 ) ,
						m_NonOverlappingPartitions ( NULL )
	{
	}

	virtual ~PartitionSet () 
	{
		delete m_Range ;

		if ( m_NonOverlappingPartitions )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_NumberOfNonOverlappingPartitions ; t_Index ++ )
			{
				delete m_NonOverlappingPartitions [ t_Index ] ;
			}

			delete [] m_NonOverlappingPartitions ;
		}
	}

public:

	WmiTriState Initialize ( ULONG a_Count ) 
	{
		WmiTriState t_Status = State_True ;

		m_NumberOfNonOverlappingPartitions = a_Count ;
		m_NonOverlappingPartitions = new PartitionSet * [ a_Count ] ;
		if ( m_NonOverlappingPartitions )
		{
			for ( ULONG t_Index = 0 ; t_Index < a_Count ; t_Index ++ )
			{
				m_NonOverlappingPartitions [ t_Index ] = NULL ;
			}
		}
		else
		{
			t_Status = State_Error ;
		}

		return t_Status ;
	}
	
	void SetPartition ( ULONG a_Index , PartitionSet *a_Partition )
	{
		if ( a_Index < m_NumberOfNonOverlappingPartitions ) 
		{
			m_NonOverlappingPartitions [ a_Index ] = a_Partition ;
		}
	}

public:

	ULONG GetKeyIndex () { return m_KeyIndex ; }
	void SetKeyIndex ( ULONG a_KeyIndex ) { m_KeyIndex = a_KeyIndex ; }

	BOOL Root () { return m_Range == NULL ; }
	BOOL Leaf () { return m_NonOverlappingPartitions == NULL ; }

	void SetRange ( WmiRangeNode *a_Range ) { m_Range = a_Range ; }
	WmiRangeNode *GetRange () { return m_Range ; }

	ULONG GetPartitionCount () { return m_NumberOfNonOverlappingPartitions ; }

	PartitionSet *GetPartition ( ULONG a_Index )
	{
		if ( a_Index < m_NumberOfNonOverlappingPartitions ) 
		{
			return m_NonOverlappingPartitions [ a_Index ] ;
		}
		else
		{
			return NULL ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class QueryPreprocessor 
{
public:

	enum QuadState {

		State_True ,
		State_False ,
		State_ReEvaluate ,
		State_Undefined ,
		State_Error 
	} ;

private:
protected:

	BOOL RecursiveEvaluate ( 

		void *a_Context ,
		SWbemRpnQueryToken ** a_Expression , 
		WmiTreeNode *a_Parent , 
		WmiTreeNode **a_Node ,
		int &a_Index 
	) ;

	void TransformAndOrExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_AndChild , 
		WmiTreeNode *a_OrChild 
	) ;

	void TransformNotNotExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotAndExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualOrGreaterExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualOrLessExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorGreaterExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorLessExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorLikeExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotLikeExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorIsAExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotIsAExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOrExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformAndTrueEvaluation ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformOrFalseEvaluation ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformOperatorToRange ( 

		WmiTreeNode *&a_Node
	) ;

	void TransformIntersectingRange (

		WmiTreeNode *&a_Node ,
		WmiTreeNode *a_Compare ,
		WmiTreeNode *a_Intersection
	) ;

	void TransformNonIntersectingRange (

		WmiTreeNode *&a_Node ,
		WmiTreeNode *a_Compare
	) ;

	WmiTriState EvaluateNotEqualExpression ( WmiTreeNode *&a_Node ) ;

	WmiTriState EvaluateNotExpression ( WmiTreeNode *&a_Node ) ;

	WmiTriState EvaluateAndExpression ( WmiTreeNode *&a_Node ) ;

	WmiTriState EvaluateOrExpression ( WmiTreeNode *&a_Node ) ;

	QuadState RecursiveDisjunctiveNormalForm ( WmiTreeNode *&a_Node ) ;

	QuadState RecursiveRemoveInvariants ( void *a_Context , WmiTreeNode *&a_Root ) ;

	WmiTriState RecursiveInsertNode ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Node ) ;
	WmiTriState InsertNode ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Node ) ;

	WmiTriState RecursiveSortConditionals ( WmiTreeNode *&a_Root , WmiTreeNode *&a_NewRoot ) ;
	WmiTriState SortConditionals ( WmiTreeNode *&a_Root ) ;
	WmiTriState RecursiveSort ( WmiTreeNode *&a_Root ) ;

	WmiTriState RecursiveConvertToRanges ( WmiTreeNode *&a_Root ) ;
	
	QuadState RecursiveRemoveNonOverlappingRanges ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Compare ) ;

	void CountDisjunctions ( WmiTreeNode *a_Root , ULONG &a_Count ) ;

	WmiTriState CreateDisjunctions ( 

		void *a_Context ,
		WmiTreeNode *a_Node , 
		Disjunctions *a_Disjunctions , 
		ULONG a_PropertiesToPartitionCount ,
		BSTR *a_PropertiesToPartition ,
		ULONG &a_DisjunctionIndex 
	) ;

	WmiTriState RecursivePartitionSet ( 

		Disjunctions *a_Disjunctions , 
		PartitionSet *&a_Partition , 
		ULONG a_DisjunctionSetToTestCount ,
		ULONG *a_DisjunctionSetToTest ,
		ULONG a_KeyIndex 
	) ;

protected:

/*
 *	Given a property name and it's value convert to it's correct type.
 *	e.g. if the CIMType of a_PropertyName is uint32 then create an WmiUnsignedIntegerNode
 *	return NULL if error.
 */

	virtual WmiTreeNode *AllocTypeNode ( 

		void *a_Context ,
		BSTR a_PropertyName , 
		VARIANT &a_Variant , 
		WmiValueNode :: WmiValueFunction a_PropertyFunction ,
		WmiValueNode :: WmiValueFunction a_ConstantFunction ,
		WmiTreeNode *a_Parent 

	) ;

	virtual QuadState InvariantEvaluate ( 

		void *a_Context ,
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 

	) { return State_Undefined ; }

	virtual WmiRangeNode *AllocInfiniteRangeNode (

		void *a_Context ,
		BSTR a_PropertyName 

	) { return NULL ; }

protected:

	BOOL Evaluate (

		void *a_Context ,
		SWbemRpnQueryToken **a_Expression , 
		int a_Count ,
		WmiTreeNode **a_Root
	) ;

	QuadState DisjunctiveNormalForm ( WmiTreeNode *&a_Root ) ;

	void RecursiveQuickSort (

		WmiRangeNode **a_Array , 
		ULONG *a_UnsortedOrder ,
		ULONG a_Lower , 
		ULONG a_Upper
	) ;

	void QuickSort (

		WmiRangeNode **a_Array , 
		ULONG *a_UnsortedOrder ,
		ULONG a_Size
	) ;

	void SortRanges (

		ULONG a_DisjunctionCount ,
		ULONG *a_OriginToSorted ,
		WmiRangeNode **a_RangeTable 
	) ;

	WmiTriState RemoveOverlaps (

		ULONG *a_DisjunctionSetToTest ,
		ULONG a_DisjunctionCount ,
		ULONG *a_OverlappingIndex ,
		ULONG *a_OriginToSorted ,
		WmiRangeNode **a_RangeTable 
	) ;

	QuadState RemoveInvariants ( void *a_Context , WmiTreeNode *&a_Root ) ;

	WmiTriState Sort ( WmiTreeNode *&a_Root ) ;

	WmiTriState ConvertToRanges ( WmiTreeNode *&a_Root ) ;

	QuadState RemoveNonOverlappingRanges ( WmiTreeNode *&a_Root ) ;

	WmiTriState CreateDisjunctionContainer (

		void *a_Context , 
		WmiTreeNode *a_Root , 
		ULONG a_Count , 
		BSTR *a_Container , 
		Disjunctions *&a_Disjunctions
	) ;

	WmiTriState CreatePartitionSet ( 

		Disjunctions *a_Disjunctions , 
		PartitionSet *&a_Partition
	) ;

	void PrintTree ( WmiTreeNode *a_Root ) ;

public:

	QueryPreprocessor () ;
	virtual ~QueryPreprocessor () ;

	QuadState PreProcess (

		void *a_Context , 
		IWbemQuery *a_QueryAnalysis , 
		WmiTreeNode *&a_Root
	) ;


	QuadState Query ( 

		BSTR a_Query ,
		IWbemQuery *a_QueryAnalysis
	) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provevents.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Server_ProviderEvent_H
#define _Server_ProviderEvent_H

#include "Globals.h"
#include "provcache.h"
#include "ProvRegistrar.h"
#include "ProvEvt.h"
#include <lockst.h>
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupledChild_IWbemObjectSink ;
class CDecoupledRoot_IWbemObjectSink ;

typedef WmiContainerController <CDecoupledChild_IWbemObjectSink *>			CWbemGlobal_DecoupledIWmiObjectSinkController ;
typedef CWbemGlobal_DecoupledIWmiObjectSinkController :: Container					CWbemGlobal_DecoupledIWmiObjectSinkController_Container ;
typedef CWbemGlobal_DecoupledIWmiObjectSinkController :: Container_Iterator			CWbemGlobal_DecoupledIWmiObjectSinkController_Container_Iterator ;
typedef CWbemGlobal_DecoupledIWmiObjectSinkController :: WmiContainerElement			DecoupledObjectSinkContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupled_IWbemObjectSink :		public IWbemEventSink , 
										public IWbemShutdown
{
private:
protected:

	long m_SecurityDescriptorLength ;
	BYTE *m_SecurityDescriptor ;

	CriticalSection m_CriticalSection ;

	IWbemObjectSink *m_InterceptedSink ;
	IWbemEventSink *m_EventSink ;

	LONG m_GateClosed ;
	LONG m_InProgress ;
	LONG m_StatusCalled ;

public:

	CDecoupled_IWbemObjectSink () ;

	~CDecoupled_IWbemObjectSink () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

    HRESULT STDMETHODCALLTYPE IndicateWithSD (

		long a_ObjectsCount ,
		IUnknown **a_Objects ,
		long a_SecurityDescriptorLength ,
		BYTE *a_SecurityDescriptor
	) ;

    HRESULT STDMETHODCALLTYPE SetSinkSecurity (

		long a_SecurityDescriptorLength ,
		BYTE *a_SecurityDescriptor
	) ;

    HRESULT STDMETHODCALLTYPE IsActive () ;

    HRESULT STDMETHODCALLTYPE SetBatchingParameters (

		LONG a_Flags,
		DWORD a_MaxBufferSize,
		DWORD a_MaxSendLatency
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupledRoot_IWbemObjectSink :		public CDecoupled_IWbemObjectSink ,
											public CWbemGlobal_DecoupledIWmiObjectSinkController
{
private:

	LONG m_ReferenceCount ;

	WmiAllocator &m_Allocator ;

public:

	CDecoupledRoot_IWbemObjectSink (
	
		WmiAllocator &a_Allocator 

	) : CWbemGlobal_DecoupledIWmiObjectSinkController ( a_Allocator ) , 
		m_Allocator ( a_Allocator ) ,
		m_ReferenceCount ( 0 )
	{ ; }

	~CDecoupledRoot_IWbemObjectSink ()
	{
		CWbemGlobal_DecoupledIWmiObjectSinkController :: UnInitialize () ;
	}

    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT SinkInitialize () ;

	HRESULT SetSink ( IWbemObjectSink *a_Sink ) ;

    HRESULT STDMETHODCALLTYPE GetRestrictedSink (

		long a_QueryCount ,
        const LPCWSTR *a_Queries ,
        IUnknown *a_Callback ,
        IWbemEventSink **a_Sink
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupledChild_IWbemObjectSink :		public CDecoupled_IWbemObjectSink ,
											public DecoupledObjectSinkContainerElement
{
private:

	CDecoupledRoot_IWbemObjectSink *m_RootSink ;
	long m_QueryCount ;
    LPWSTR *m_Queries ;
    IUnknown *m_Callback ;

public:

	CDecoupledChild_IWbemObjectSink (
	
		CDecoupledRoot_IWbemObjectSink *a_RootSink
	) ;

	~CDecoupledChild_IWbemObjectSink () ;

    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT SinkInitialize (

		long a_QueryCount ,
		const LPCWSTR *a_Queries ,
		IUnknown *a_Callback
	) ;

    HRESULT STDMETHODCALLTYPE GetRestrictedSink (

		long a_QueryCount ,
        const LPCWSTR *a_Queries ,
        IUnknown *a_Callback ,
        IWbemEventSink **a_Sink
	) ;

	HRESULT SetSink ( IWbemObjectSink *a_Sink ) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderEvents :	public CServerObject_ProviderRegistrar_Base ,
										public IWbemDecoupledBasicEventProvider
{
private:

	WmiAllocator &m_Allocator ;

	CriticalSection m_SinkCriticalSection ;

    long m_ReferenceCount ;
	long m_InternalReferenceCount ;

	CDecoupledRoot_IWbemObjectSink *m_ObjectSink ;
	CEventProvider *m_Provider ;
	IWbemServices *m_Service ;

protected:

public: /* Internal */

	HRESULT SetSink ( IWbemObjectSink *a_Sink ) 
	{
		WmiHelper :: EnterCriticalSection ( & m_SinkCriticalSection ) ;

		if ( m_ObjectSink )
		{
			CDecoupledRoot_IWbemObjectSink *t_Sink = m_ObjectSink ;

			t_Sink->AddRef () ;
		
			WmiHelper :: LeaveCriticalSection ( & m_SinkCriticalSection ) ;

			HRESULT t_Result = t_Sink->SetSink ( a_Sink ) ;

			t_Sink->Release () ;

			return t_Result ;
		}
		else
		{
			WmiHelper :: LeaveCriticalSection ( & m_SinkCriticalSection ) ;

			return WBEM_E_NOT_AVAILABLE ;
		}
	}

    STDMETHODIMP_( ULONG ) InternalAddRef () ;
    STDMETHODIMP_( ULONG ) InternalRelease () ;

public:	/* External */

	CServerObject_ProviderEvents ( WmiAllocator &a_Allocator = *DecoupledProviderSubSystem_Globals::s_Allocator) ;
	~CServerObject_ProviderEvents () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE Register (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		IUnknown *a_Unknown 
	) ;

	HRESULT STDMETHODCALLTYPE UnRegister () ;

	HRESULT STDMETHODCALLTYPE GetSink (

		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink **a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE GetService (

		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemServices **a_Service
	) ;
};

#endif // _Server_ProviderEvent_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provinsk.h ===
#ifndef _Server_Interceptor_IWbemProviderInitSink_H
#define _Server_Interceptor_IWbemProviderInitSink_H

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvObSk.H

Abstract:


History:

--*/


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderInitSink : public IWbemProviderInitSink 
{
private:

	LONG m_ReferenceCount ;

	BOOL m_StatusCalled ;

	HANDLE m_Event ;

	HRESULT m_Result ;

	SECURITY_DESCRIPTOR *m_SecurityDescriptor ;

protected:

public:

	CServerObject_ProviderInitSink ( SECURITY_DESCRIPTOR *a_SecurityDescriptor = 
NULL ) ;
	virtual ~CServerObject_ProviderInitSink () ;

	HRESULT SinkInitialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor = NULL ) ;

	STDMETHODIMP QueryInterface (

		REFIID iid , 
		LPVOID FAR *iplpv 
	) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_(ULONG) Release () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

        LONG a_Status,
        LONG a_Flags 
	) ;

	void Wait ( DWORD a_Timeout = 300000 ) 
	{
		if ( WaitForSingleObject ( m_Event , a_Timeout ) == WAIT_TIMEOUT )
		{
			m_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	void Reset () 
	{
		ResetEvent ( m_Event ) ;
		m_Result = S_OK ;
	}

	HRESULT GetResult () { return m_Result ; }
} ;


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemProviderInitSink : public IWbemProviderInitSink
{
private:

	LONG m_ReferenceCount ;

	LONG m_GateClosed ;
	LONG m_InProgress ;

	BOOL m_StatusCalled ;

	IWbemProviderInitSink *m_InterceptedSink ;

protected:
public:

	CInterceptor_IWbemProviderInitSink (

		IWbemProviderInitSink *a_InterceptedSink
	) ;

	~CInterceptor_IWbemProviderInitSink () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

        LONG a_Status,
        LONG a_Flags 
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown () ;
} ;

#endif _Server_Interceptor_IWbemProviderInitSink_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provevt.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvWsv.H

Abstract:


History:

--*/

#ifndef _Server_EventProvider_H
#define _Server_EventProvider_H

#include "Globals.h"
#include "CGlobals.h"

class CServerObject_ProviderEvents ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CEventProvider :					public IWbemEventProvider ,
										public IWbemEventProviderQuerySink ,
										public IWbemEventProviderSecurity ,
										public IWbemProviderIdentity ,
										public IWbemEventConsumerProviderEx ,
										public IWbemProviderInit , 
										public IWbemShutdown 
{
private:

	LONG m_ReferenceCount ;

	CriticalSection m_CriticalSection ;

	IUnknown *m_Unknown ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;
	IWbemProviderIdentity *m_Provider_IWbemProviderIdentity ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemEventConsumerProviderEx *m_Provider_IWbemEventConsumerProviderEx ;

	IWbemServices *m_CoreService ;
	IUnknown *m_Provider ;
	CServerObject_ProviderEvents *m_EventRegistrar ;

public:

	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Namespace ;

private:

public:

	CEventProvider ( 

		WmiAllocator &a_Allocator ,
		CServerObject_ProviderEvents *a_EventRegistrar ,
		IUnknown *a_Unknown
	) ;

    ~CEventProvider () ;

	HRESULT Initialize () ;

	HRESULT UnRegister () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderIdentity */

	HRESULT STDMETHODCALLTYPE SetRegistrationObject (

		long a_Flags ,
		IWbemClassObject *a_ProviderRegistration
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User,
		LONG a_Flags,
		LPWSTR a_Namespace,
		LPWSTR a_Locale,
		IWbemServices *a_CoreService,         // For anybody
		IWbemContext *a_Context,
		IWbemProviderInitSink *a_Sink     // For init signals
	) ;

	// IWbemShutdown members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

#endif // _Server_EventProvider_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provinterceptor.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvWsv.H

Abstract:


History:

--*/

#ifndef _Decopled_Interceptor_IWbemServices_H
#define _Decopled_Interceptor_IWbemServices_H

#include <Allocator.h>
#include <Algorithms.h>
#include <TPQueue.h>
#include <BasicTree.h>
#include <Cache.h>

#include <CGlobals.h>
#include <ProvRegInfo.h>
#include <ProvObjectSink.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef WmiContainerController <void *>										CWbemGlobal_VoidPointerController ;
typedef CWbemGlobal_VoidPointerController :: Container						CWbemGlobal_VoidPointerController_Container ;
typedef CWbemGlobal_VoidPointerController :: Container_Iterator				CWbemGlobal_VoidPointerController_Container_Iterator ;
typedef CWbemGlobal_VoidPointerController :: WmiContainerElement			VoidPointerContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemObjectSink ;

#define CWbemGlobal_IWmiObjectSinkController						CWbemGlobal_VoidPointerController
#define CWbemGlobal_IWmiObjectSinkController_Container				CWbemGlobal_VoidPointerController_Container
#define CWbemGlobal_IWmiObjectSinkController_Container_Iterator		CWbemGlobal_VoidPointerController_Container_Iterator
#define ObjectSinkContainerElement									VoidPointerContainerElement

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ProxyIndex_IWbemServices					0
#define ProxyIndex_IWbemPropertyProvider			1
#define ProxyIndex_IWbemEventProvider				2
#define ProxyIndex_IWbemEventProviderQuerySink		3
#define ProxyIndex_IWbemEventProviderSecurity		4
#define ProxyIndex_IWbemProviderIdentity			5
#define ProxyIndex_IWbemEventConsumerProvider		6
#define ProxyIndex_IWbemEventConsumerProviderEx		7
#define ProxyIndex_IWbemUnboundObjectSink			8

#define ProxyIndex_Internal_IWbemServices					9
#define ProxyIndex_Internal_IWbemPropertyProvider			10
#define ProxyIndex_Internal_IWbemEventProvider				11
#define ProxyIndex_Internal_IWbemEventProviderQuerySink		12
#define ProxyIndex_Internal_IWbemEventProviderSecurity		13
#define ProxyIndex_Internal_IWbemEventConsumerProvider		14
#define ProxyIndex_Internal_IWbemEventConsumerProviderEx	15
#define ProxyIndex_Internal_IWbemUnboundObjectSink			16

#define ProxyIndex_IWbemShutdown					17

#define ProxyIndex_Provider_Size					18

#define ProxyIndex_UnBoundSync_IWbemUnboundObjectSink			0
#define ProxyIndex_UnBoundSync_Size								1

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupled_IWbemSyncObjectSink :	public CCommon_IWbemSyncObjectSink
{
private:
protected:
public:

	CDecoupled_IWbemSyncObjectSink (

		WmiAllocator &a_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CDecoupled_IWbemSyncObjectSink () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupled_Batching_IWbemSyncObjectSink :	public CCommon_Batching_IWbemSyncObjectSink
{
private:
protected:
public:

	CDecoupled_Batching_IWbemSyncObjectSink (

		WmiAllocator &a_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CDecoupled_Batching_IWbemSyncObjectSink () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemDecoupledUnboundObjectSink : public IWbemUnboundObjectSink ,
												public Internal_IWbemUnboundObjectSink ,

												public IWbemShutdown , 
												public VoidPointerContainerElement
{
private:

	WmiAllocator &m_Allocator ;
	CServerObject_ProviderRegistrationV1 *m_Registration ;

	IUnknown *m_Unknown ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;

	ProxyContainer m_ProxyContainer ;

protected:
public:

	CInterceptor_IWbemDecoupledUnboundObjectSink (

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideProvider , 
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	~CInterceptor_IWbemDecoupledUnboundObjectSink () ;

	HRESULT Initialize () ;

public:

	STDMETHODIMP QueryInterface ( 

		REFIID iid , 
		LPVOID FAR *iplpv 
	) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE Internal_IndicateToConsumer (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	/* _IWmiProviderSite */

	HRESULT STDMETHODCALLTYPE GetSite ( DWORD *a_ProcessIdentifier ) ;

	HRESULT STDMETHODCALLTYPE SetContainer ( IUnknown *a_Container ) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_DecoupledClient :	public IWbemServices , 
										public IWbemPropertyProvider ,
										public IWbemEventProvider ,
										public IWbemEventProviderQuerySink ,
										public IWbemEventProviderSecurity ,
										public IWbemProviderIdentity ,
										public IWbemEventConsumerProviderEx ,
										public IWbemUnboundObjectSink ,

										public IWbemProviderInit ,
										public Internal_IWbemProviderInit ,

										public Internal_IWbemServices , 
										public Internal_IWbemPropertyProvider ,
										public Internal_IWbemEventProvider ,
										public Internal_IWbemEventProviderQuerySink ,
										public Internal_IWbemEventProviderSecurity ,
										public Internal_IWbemEventConsumerProviderEx ,
										public Internal_IWbemUnboundObjectSink ,

										public _IWmiProviderSite ,
										public IWbemShutdown , 
										public CWbemGlobal_IWmiObjectSinkController 
{
private:

	LONG m_ReferenceCount ;

	IUnknown *m_Unknown ;
	IWbemServices *m_Provider_IWbemServices ;
	IWbemPropertyProvider *m_Provider_IWbemPropertyProvider ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;
	IWbemProviderIdentity *m_Provider_IWbemProviderIdentity ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemEventConsumerProviderEx *m_Provider_IWbemEventConsumerProviderEx ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;

	IWbemServices *m_CoreStub ;

	WmiAllocator &m_Allocator ;

	ProxyContainer m_ProxyContainer ;

	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Namespace ;
	BSTR m_TransactionIdentifier ;

public:

	CServerObject_ProviderRegistrationV1 *m_Registration ;

	UINT64 m_ProviderOperation_GetObjectAsync ;
	UINT64 m_ProviderOperation_PutClassAsync ;
	UINT64 m_ProviderOperation_DeleteClassAsync ;
	UINT64 m_ProviderOperation_CreateClassEnumAsync ;
	UINT64 m_ProviderOperation_PutInstanceAsync ;
	UINT64 m_ProviderOperation_DeleteInstanceAsync ;
	UINT64 m_ProviderOperation_CreateInstanceEnumAsync ;
	UINT64 m_ProviderOperation_ExecQueryAsync ;
	UINT64 m_ProviderOperation_ExecNotificationQueryAsync ;
	UINT64 m_ProviderOperation_ExecMethodAsync ;

	UINT64 m_ProviderOperation_Begin ;
	UINT64 m_ProviderOperation_Rollback ;
	UINT64 m_ProviderOperation_Commit ;
	UINT64 m_ProviderOperation_QueryState ;

	UINT64 m_ProviderOperation_QueryInstances ;
	UINT64 m_ProviderOperation_CreateRefresher ;
	UINT64 m_ProviderOperation_CreateRefreshableObject ;
	UINT64 m_ProviderOperation_StopRefreshing ;
	UINT64 m_ProviderOperation_CreateRefreshableEnum ;
	UINT64 m_ProviderOperation_GetObjects ;

	UINT64 m_ProviderOperation_GetProperty ;
	UINT64 m_ProviderOperation_PutProperty ;

	UINT64 m_ProviderOperation_ProvideEvents ;
	UINT64 m_ProviderOperation_NewQuery ;
	UINT64 m_ProviderOperation_CancelQuery ;
	UINT64 m_ProviderOperation_AccessCheck ;
	UINT64 m_ProviderOperation_SetRegistrationObject ;
	UINT64 m_ProviderOperation_FindConsumer ;
	UINT64 m_ProviderOperation_ValidateSubscription ;

	void Increment_ProviderOperation_GetObjectAsync () { m_ProviderOperation_GetObjectAsync ++ ; }
 	void Increment_ProviderOperation_PutClassAsync () { m_ProviderOperation_PutClassAsync ++ ; }
	void Increment_ProviderOperation_DeleteClassAsync () { m_ProviderOperation_DeleteClassAsync ++ ; }
	void Increment_ProviderOperation_CreateClassEnumAsync () { m_ProviderOperation_CreateClassEnumAsync ++ ; }
	void Increment_ProviderOperation_PutInstanceAsync () { m_ProviderOperation_PutInstanceAsync ++ ; }
	void Increment_ProviderOperation_DeleteInstanceAsync () { m_ProviderOperation_DeleteInstanceAsync ++ ; }
	void Increment_ProviderOperation_CreateInstanceEnumAsync () { m_ProviderOperation_CreateInstanceEnumAsync ++ ; }
	void Increment_ProviderOperation_ExecQueryAsync () { m_ProviderOperation_ExecQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecNotificationQueryAsync () { m_ProviderOperation_ExecNotificationQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecMethodAsync () { m_ProviderOperation_ExecMethodAsync ++ ; }

	void Increment_ProviderOperation_Begin () { m_ProviderOperation_Begin ++ ; }
	void Increment_ProviderOperation_Rollback () { m_ProviderOperation_Rollback ++ ; }
	void Increment_ProviderOperation_Commit () { m_ProviderOperation_Commit ++ ; }
	void Increment_ProviderOperation_QueryState () { m_ProviderOperation_QueryState ++ ; }

	void Increment_ProviderOperation_QueryInstances () { m_ProviderOperation_QueryInstances ++ ; }
	void Increment_ProviderOperation_CreateRefresher () { m_ProviderOperation_CreateRefresher ++ ; }
	void Increment_ProviderOperation_CreateRefreshableObject () { m_ProviderOperation_CreateRefreshableObject ++ ; }
	void Increment_ProviderOperation_StopRefreshing () { m_ProviderOperation_StopRefreshing ++ ; }
	void Increment_ProviderOperation_CreateRefreshableEnum () { m_ProviderOperation_CreateRefreshableEnum ++ ; }
	void Increment_ProviderOperation_GetObjects () { m_ProviderOperation_GetObjects ++ ; }

	void Increment_ProviderOperation_GetProperty () { m_ProviderOperation_GetProperty ++ ; }
	void Increment_ProviderOperation_PutProperty () { m_ProviderOperation_PutProperty ++ ; }

	void Increment_ProviderOperation_ProvideEvents () { m_ProviderOperation_ProvideEvents ++ ; }
	void Increment_ProviderOperation_NewQuery () { m_ProviderOperation_NewQuery ++ ; }
	void Increment_ProviderOperation_CancelQuery () { m_ProviderOperation_CancelQuery ++ ; }
	void Increment_ProviderOperation_AccessCheck () { m_ProviderOperation_AccessCheck ++ ; }
	void Increment_ProviderOperation_SetRegistrationObject () { m_ProviderOperation_SetRegistrationObject ++ ; }
	void Increment_ProviderOperation_FindConsumer () { m_ProviderOperation_FindConsumer ++ ; }
	void Increment_ProviderOperation_ValidateSubscription () { m_ProviderOperation_ValidateSubscription ++ ; }

	UINT64 Get_ProviderOperation_GetObjectAsync () { return m_ProviderOperation_GetObjectAsync ; }
	UINT64 Get_ProviderOperation_PutClassAsync () { return m_ProviderOperation_PutClassAsync ; }
	UINT64 Get_ProviderOperation_DeleteClassAsync () { return m_ProviderOperation_DeleteClassAsync ; }
	UINT64 Get_ProviderOperation_CreateClassEnumAsync () { return m_ProviderOperation_CreateClassEnumAsync ; }
	UINT64 Get_ProviderOperation_PutInstanceAsync () { return m_ProviderOperation_PutInstanceAsync ; }
	UINT64 Get_ProviderOperation_DeleteInstanceAsync () { return m_ProviderOperation_DeleteInstanceAsync ; }
	UINT64 Get_ProviderOperation_CreateInstanceEnumAsync () { return m_ProviderOperation_CreateInstanceEnumAsync ; }
	UINT64 Get_ProviderOperation_ExecQueryAsync () { return m_ProviderOperation_ExecQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecNotificationQueryAsync () { return m_ProviderOperation_ExecNotificationQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecMethodAsync () { return m_ProviderOperation_ExecMethodAsync ; }

	UINT64 Get_ProviderOperation_Begin () { return m_ProviderOperation_Begin ; }
	UINT64 Get_ProviderOperation_Rollback () { return m_ProviderOperation_Rollback ; }
	UINT64 Get_ProviderOperation_Commit () { return m_ProviderOperation_Commit ; }
	UINT64 Get_ProviderOperation_QueryState () { return m_ProviderOperation_QueryState ; }

	UINT64 Get_ProviderOperation_QueryInstances () { return m_ProviderOperation_QueryInstances ; }
	UINT64 Get_ProviderOperation_CreateRefresher () { return m_ProviderOperation_CreateRefresher ; }
	UINT64 Get_ProviderOperation_CreateRefreshableObject () { return m_ProviderOperation_CreateRefreshableObject ; }
	UINT64 Get_ProviderOperation_StopRefreshing () { return m_ProviderOperation_StopRefreshing ; }
	UINT64 Get_ProviderOperation_CreateRefreshableEnum () { return m_ProviderOperation_CreateRefreshableEnum ; }
	UINT64 Get_ProviderOperation_GetObjects () { return m_ProviderOperation_GetObjects ; }

	UINT64 Get_ProviderOperation_GetProperty () { return m_ProviderOperation_GetProperty ; }
	UINT64 Get_ProviderOperation_PutProperty () { return m_ProviderOperation_PutProperty ; }

	UINT64 Get_ProviderOperation_ProvideEvents () { return m_ProviderOperation_ProvideEvents ; }
	UINT64 Get_ProviderOperation_NewQuery () { return m_ProviderOperation_NewQuery ; }
	UINT64 Get_ProviderOperation_CancelQuery () { return m_ProviderOperation_CancelQuery ; }
	UINT64 Get_ProviderOperation_AccessCheck () { return m_ProviderOperation_AccessCheck ; }
	UINT64 Get_ProviderOperation_SetRegistrationObject () { return m_ProviderOperation_SetRegistrationObject ; }
	UINT64 Get_ProviderOperation_FindConsumer () { return m_ProviderOperation_FindConsumer ; }
	UINT64 Get_ProviderOperation_ValidateSubscription () { return m_ProviderOperation_ValidateSubscription ; }

private:

	HRESULT SetStatus ( 

		LPWSTR a_Operation ,
		LPWSTR a_Parameters ,
		LPWSTR a_Description ,
		HRESULT a_Result ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT Begin_IWbemServices (

		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IWbemServices *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_IWbemServices (

		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IWbemServices *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT AdjustGetContext (

		IWbemContext *a_Context
	) ;

	HRESULT Helper_GetObjectAsync (

		BOOL a_IsProxy ,
 		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_PutClassAsync (

		BOOL a_IsProxy ,
		IWbemClassObject *a_Object , 
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_DeleteClassAsync (

		BOOL a_IsProxy ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_CreateClassEnumAsync (

		BOOL a_IsProxy ,
		const BSTR a_SuperClass ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_PutInstanceAsync (

		BOOL a_IsProxy ,
		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_DeleteInstanceAsync (

		BOOL a_IsProxy ,
		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

    HRESULT Helper_CreateInstanceEnumAsync (

		BOOL a_IsProxy ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service
	) ;

	HRESULT Helper_ExecQueryAsync (

		BOOL a_IsProxy ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query, 
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_ExecMethodAsync (

		BOOL a_IsProxy ,
		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

public:

	CInterceptor_DecoupledClient ( 

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideUnknown , 
		IWbemServices *a_CoreStub ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

    ~CInterceptor_DecoupledClient () ;

	HRESULT ProviderInitialize () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE GetProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE PutProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderIdentity */

	HRESULT STDMETHODCALLTYPE SetRegistrationObject (

		long a_Flags ,
		IWbemClassObject *a_ProviderRegistration
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	/* IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

/* Internal_IWbemServices */
 
     HRESULT STDMETHODCALLTYPE Internal_OpenNamespace ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CancelAsyncCall ( 

		WmiInternalContext a_InternalContext ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_QueryObjectSink ( 

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_GetObject ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_GetObjectAsync (
        
		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE Internal_PutClass ( 

		WmiInternalContext a_InternalContext ,
        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutClassAsync ( 

		WmiInternalContext a_InternalContext ,
        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteClass ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteClassAsync ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateClassEnum ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateClassEnumAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutInstance (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutInstanceAsync (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteInstance ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteInstanceAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateInstanceEnum (

		WmiInternalContext a_InternalContext ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateInstanceEnumAsync (

		WmiInternalContext a_InternalContext ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecQuery ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecQueryAsync (

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecNotificationQuery (

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecNotificationQueryAsync ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecMethod (

		WmiInternalContext a_InternalContext ,
        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecMethodAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* Internal_IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE Internal_GetProperty (

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE Internal_PutProperty (

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* Internal_IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE Internal_ProvideEvents (

		WmiInternalContext a_InternalContext ,
		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* Internal_IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE Internal_NewQuery (

		WmiInternalContext a_InternalContext ,
		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE Internal_CancelQuery (

		WmiInternalContext a_InternalContext ,
		unsigned long a_Id
	) ;

	/* Internal_IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE Internal_AccessCheck (

		WmiInternalContext a_InternalContext ,
		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* Internal_IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE Internal_FindConsumer (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* Internal_IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE Internal_ValidateSubscription (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer
	) ;

	/* Internal_IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE Internal_IndicateToConsumer (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;


	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_CoreService ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Internal_Initialize (

		WmiInternalContext a_InternalContext ,
		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_CoreService ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	/* _IWmiProviderSite */

	HRESULT STDMETHODCALLTYPE GetSite ( DWORD *a_ProcessIdentifier ) ;

	HRESULT STDMETHODCALLTYPE SetContainer ( IUnknown *a_Container ) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

#endif // _Decopled_Interceptor_IWbemServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provobjectsink.h ===
#ifndef _Common_IWbemObjectSink_H
#define _Common_IWbemObjectSink_H

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvObSk.H

Abstract:


History:

--*/

#include "Queue.h"
#include "CGlobals.h"

#define SYNCPROV_USEBATCH

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ProxyIndex_IWbemObjectSink					0
#define ProxyIndex_Internal_IWbemObjectSink			1
#define ProxyIndex_ObjectSink_Size					2

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CCommon_IWbemSyncObjectSink :			public IWbemObjectSink , 
											public IWbemShutdown ,
											public ObjectSinkContainerElement
{
private:

	LONG m_InProgress ;
	LONG m_StatusCalled ;

	ULONG m_Dependant ;
	IWbemObjectSink *m_InterceptedSink ;

#ifdef INTERNAL_IDENTIFY
	Internal_IWbemObjectSink *m_Internal_InterceptedSink ;

	ProxyContainer m_ProxyContainer ;
#endif
	IUnknown *m_Unknown ;

protected:

	LONG m_GateClosed ;

protected:

#ifdef INTERNAL_IDENTIFY

	HRESULT Begin_IWbemObjectSink (

		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_IWbemObjectSink (

		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;
#endif

    HRESULT STDMETHODCALLTYPE Helper_Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE Helper_SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

public:

	CCommon_IWbemSyncObjectSink (

		WmiAllocator &a_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CCommon_IWbemSyncObjectSink() ;

	void CallBackInternalRelease () ;

	virtual HRESULT SinkInitialize () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CCommon_Batching_IWbemSyncObjectSink :	public CCommon_IWbemSyncObjectSink
{
private:

	DWORD m_Size ;
	WmiQueue <IWbemClassObject *,8> m_Queue ;
	CriticalSection m_CriticalSection ;

protected:
public:

	CCommon_Batching_IWbemSyncObjectSink (

		WmiAllocator &a_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CCommon_Batching_IWbemSyncObjectSink () ;

	HRESULT SinkInitialize () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

#endif _Common_IWbemObjectSink_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provobsk.h ===
#ifndef _Server_Interceptor_IWbemObjectSink_H
#define _Server_Interceptor_IWbemObjectSink_H

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvObSk.H

Abstract:


History:

--*/

#include "ProvCache.h"
#include "Queue.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemObjectSink :	public IWbemObjectSink , 
										public IWbemShutdown ,
#ifdef INTERNAL_IDENTIFY
										public Internal_IWbemObjectSink , 
#endif
										public ObjectSinkContainerElement
{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;
	LONG m_StatusCalled ;

	IWbemObjectSink *m_InterceptedSink ;
	IUnknown *m_Unknown ;
	SECURITY_DESCRIPTOR *m_SecurityDescriptor ;


protected:
public:

	CInterceptor_IWbemObjectSink (

		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller 
	) ;

	~CInterceptor_IWbemObjectSink () ;
	HRESULT Initialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor ) ;

	void CallBackRelease () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_DecoupledIWbemObjectSink :	public IWbemObjectSink , 
												public IWbemShutdown ,
												public ObjectSinkContainerElement
{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;
	LONG m_StatusCalled ;

	IWbemObjectSink *m_InterceptedSink ;
	IUnknown *m_Unknown ;

protected:
public:

	CInterceptor_DecoupledIWbemObjectSink (

		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller 
	) ;

	~CInterceptor_DecoupledIWbemObjectSink () ;

	void CallBackRelease () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemFilteringObjectSink :	public CInterceptor_IWbemObjectSink
{
private:
	LONG m_Filtering ;

	BSTR m_QueryLanguage ;
	BSTR m_Query ;

	IWbemQuery *m_QueryFilter ;

protected:
public:

	CInterceptor_IWbemFilteringObjectSink (

		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query
	) ;

	~CInterceptor_IWbemFilteringObjectSink () ;

	//Non-delegating object IUnknown

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_DecoupledIWbemCombiningObjectSink :	public IWbemObjectSink , 
														public IWbemShutdown ,
														public ObjectSinkContainerElement ,
														public CWbemGlobal_IWmiObjectSinkController 
{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;
	LONG m_StatusCalled ;

	LONG m_SinkCount ;
	HANDLE m_Event ;

	IWbemObjectSink *m_InterceptedSink ;

#if 0
	class InternalInterface : public IWbemObjectSink , public IWbemShutdown
	{
	private:

		CInterceptor_DecoupledIWbemCombiningObjectSink *m_This ;

	public:

		InternalInterface ( CInterceptor_DecoupledIWbemCombiningObjectSink *a_This ) : m_This ( a_This ) 
		{
		}

		STDMETHODIMP QueryInterface ( 

			REFIID iid , 
			LPVOID FAR *iplpv 
		)
		{
			*iplpv = NULL ;

			if ( iid == IID_IUnknown )
			{
				*iplpv = ( LPVOID ) this ;
			}
			else if ( iid == IID_IWbemObjectSink )
			{
				*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
			}	
			else if ( iid == IID_IWbemShutdown )
			{
				*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
			}	

			if ( *iplpv )
			{
				( ( LPUNKNOWN ) *iplpv )->AddRef () ;

				return ResultFromScode ( S_OK ) ;
			}
			else
			{
				return ResultFromScode ( E_NOINTERFACE ) ;
			}
		}

		STDMETHODIMP_( ULONG ) AddRef ()
		{
			return m_This->NonCyclicAddRef () ; 
		}

		STDMETHODIMP_( ULONG ) Release ()
		{
			return m_This->NonCyclicRelease () ;
		}

		HRESULT STDMETHODCALLTYPE Indicate (

			long a_ObjectCount ,
			IWbemClassObject **a_ObjectArray
		)
		{
			return m_This->Indicate (

				a_ObjectCount ,
				a_ObjectArray
			) ;
		}

		HRESULT STDMETHODCALLTYPE SetStatus (

			long a_Flags ,
			HRESULT a_Result ,
			BSTR a_StringParamater ,
			IWbemClassObject *a_ObjectParameter
		)
		{
			return m_This->SetStatus (

				a_Flags ,
				a_Result ,
				a_StringParamater ,
				a_ObjectParameter
			) ;
		}

		HRESULT STDMETHODCALLTYPE Shutdown (

			LONG a_Flags ,
			ULONG a_MaxMilliSeconds ,
			IWbemContext *a_Context
		)
		{
			return m_This->Shutdown (

				a_Flags ,
				a_MaxMilliSeconds ,
				a_Context
			) ;
		}
	} ;

	InternalInterface m_Internal ;
#endif

	void CallBackRelease () ;

protected:
public:

	CInterceptor_DecoupledIWbemCombiningObjectSink (

		WmiAllocator &m_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller
	) ;

	~CInterceptor_DecoupledIWbemCombiningObjectSink () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

	HRESULT Wait ( ULONG a_Timeout ) ;

	HRESULT EnQueue ( CInterceptor_DecoupledIWbemObjectSink *a_Sink ) ;

	void Suspend () ;

	void Resume () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemWaitingObjectSink :		public IWbemObjectSink , 
												public IWbemShutdown ,
												public ObjectSinkContainerElement ,
												public CWbemGlobal_IWmiObjectSinkController 
{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;
	LONG m_StatusCalled ;

	WmiQueue <IWbemClassObject *,8> m_Queue ;
	CriticalSection m_CriticalSection ;

	HANDLE m_Event ;

	HRESULT m_Result ;

protected:
public:

	CInterceptor_IWbemWaitingObjectSink (

		WmiAllocator &m_Allocator ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller
	) ;

	~CInterceptor_IWbemWaitingObjectSink () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

	HRESULT Wait ( ULONG a_Timeout = INFINITE ) ;

	WmiQueue <IWbemClassObject *,8> & GetQueue () { return m_Queue ; }
	CriticalSection &GetQueueCriticalSection () { return m_CriticalSection ; }

	HRESULT GetResult () { return m_Result ; }
} ;

#endif _Server_Interceptor_IWbemObjectSink_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provregdecoupled.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvRegInfo.h

Abstract:


History:

--*/

#ifndef _Server_ProviderRegistrationDecoupled_H
#define _Server_ProviderRegistrationDecoupled_H

#include "Queue.h"
#include "DateTime.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_DecoupledClientRegistration_Element
{
private:

	LONG m_ReferenceCount ;

private:

protected:

	HRESULT m_Result ;

	DWORD m_ProcessIdentifier ;
	BSTR m_Provider ;
	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Scope ;
	BSTR m_CreationTime ;
	BSTR m_Clsid ;
	BYTE *m_MarshaledProxy ;
	DWORD m_MarshaledProxyLength ;

protected:

	static LPCWSTR s_Strings_Reg_Null ;
	static LPCWSTR s_Strings_Reg_Home ;
	static LPCWSTR s_Strings_Reg_HomeClient ;

	static LPCWSTR s_Strings_Reg_CreationTime ;
	static LPCWSTR s_Strings_Reg_User ;
	static LPCWSTR s_Strings_Reg_Locale ;
	static LPCWSTR s_Strings_Reg_Scope ;
	static LPCWSTR s_Strings_Reg_Provider;
	static LPCWSTR s_Strings_Reg_MarshaledProxy ;
	static LPCWSTR s_Strings_Reg_ProcessIdentifier ;

	void Clear () ;

	HRESULT Validate () ;

public:	/* Internal */

    CServerObject_DecoupledClientRegistration_Element () ;
    ~CServerObject_DecoupledClientRegistration_Element () ;

	CServerObject_DecoupledClientRegistration_Element &operator= ( const CServerObject_DecoupledClientRegistration_Element &a_Key ) ;

	ULONG AddRef () ;
	ULONG Release () ;
	static HRESULT VerifyClientKey(void);
	HRESULT Load ( BSTR a_Clsid ) ;
	HRESULT Save ( BSTR a_Clsid ) ;
	HRESULT Delete ( BSTR a_Clsid ) ;

	HRESULT GetResult () { return m_Result ; }

	DWORD GetProcessIdentifier () { return m_ProcessIdentifier ; }
	BSTR GetProvider () { return m_Provider ; }
	BSTR GetLocale () { return m_Locale ; }
	BSTR GetUser () { return m_User ; }
	BSTR GetScope () { return m_Scope ; }
	BSTR GetCreationTime () { return m_CreationTime ; }
	BSTR GetClsid () { return m_Clsid ; }
	BYTE *GetMarshaledProxy () { return m_MarshaledProxy ; }
	DWORD GetMarshaledProxyLength () { return m_MarshaledProxyLength ; }

	HRESULT SetProcessIdentifier ( DWORD a_ProcessIdentifier ) ;
	HRESULT SetProvider ( BSTR a_Provider ) ;
	HRESULT SetLocale ( BSTR a_Locale ) ;
	HRESULT SetUser ( BSTR a_User ) ;
	HRESULT SetScope ( BSTR a_Scope ) ;
	HRESULT SetCreationTime ( BSTR a_CreationTime ) ;
	HRESULT SetClsid ( const BSTR a_Clsid ) ;
	HRESULT SetMarshaledProxy ( BYTE *a_MarshaledProxy , DWORD a_MarshaledProxyLength ) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_DecoupledClientRegistration
{
private:

	LONG m_ReferenceCount ;

private:

	WmiQueue < CServerObject_DecoupledClientRegistration_Element , 8 > m_Queue ;

protected:

	HRESULT m_Result ;

protected:

	static LPCWSTR s_Strings_Reg_Null ;
	static LPCWSTR s_Strings_Reg_Home ;
	static LPCWSTR s_Strings_Reg_HomeClient ;

public:	/* Internal */

    CServerObject_DecoupledClientRegistration ( WmiAllocator &a_Allocator ) ;
    ~CServerObject_DecoupledClientRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT Load () ;

	HRESULT Load (

		BSTR a_Provider ,
		BSTR a_User ,
		BSTR a_Locale ,
		BSTR a_Scope
	) ;
	static  LPCWSTR getClientKey(void) { return s_Strings_Reg_HomeClient;}

	WmiQueue < CServerObject_DecoupledClientRegistration_Element , 8 > &GetQueue () { return m_Queue ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_DecoupledServerRegistration
{
private:

	LONG m_ReferenceCount ;

private:

protected:

	HRESULT m_Result ;

	DWORD m_ProcessIdentifier ;
	BSTR m_CreationTime ;
	BYTE *m_MarshaledProxy ;
	DWORD m_MarshaledProxyLength ;

protected:

	static LPCWSTR s_Strings_Reg_Null ;
	static LPCWSTR s_Strings_Reg_Home ;
	static LPCWSTR s_Strings_Reg_HomeServer ;

	static LPCWSTR s_Strings_Reg_CreationTime ;
	static LPCWSTR s_Strings_Reg_ProcessIdentifier ;
	static LPCWSTR s_Strings_Reg_MarshaledProxy ;

	void Clear () ;

	HRESULT Validate () ;

public:	/* Internal */

    CServerObject_DecoupledServerRegistration ( WmiAllocator &a_Allocator ) ;
    ~CServerObject_DecoupledServerRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT Load () ;
	HRESULT Save () ;
	HRESULT Delete () ;

	HRESULT GetResult () { return m_Result ; }

	DWORD GetProcessIdentifier () { return m_ProcessIdentifier ; }
	BSTR GetCreationTime () { return m_CreationTime ; }
	BYTE *GetMarshaledProxy () { return m_MarshaledProxy ; }
	DWORD GetMarshaledProxyLength () { return m_MarshaledProxyLength ; }

	HRESULT SetProcessIdentifier ( DWORD a_ProcessIdentifier ) ;
	HRESULT SetCreationTime ( BSTR a_CreationTime ) ;
	HRESULT SetMarshaledProxy ( BYTE *a_MarshaledProxy , DWORD a_MarshaledProxyLength ) ;

};


#endif // _Server_ProviderRegistrationDecoupled_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provreginfo.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvRegInfo.h

Abstract:


History:

--*/

#ifndef _Server_ProviderRegistrationInfo_H
#define _Server_ProviderRegistrationInfo_H

#include "ProvDnf.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT VerifySecureLocalSystemProviders ( wchar_t *a_Clsid ) ;
HRESULT VerifySecureSvcHostProviders ( wchar_t *a_Clsid ) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern GENERIC_MAPPING g_ProviderBindingMapping ; 

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define DEFAULT_PROVIDER_TIMEOUT 120000
#define DEFAULT_PROVIDER_LOAD_TIMEOUT 120000

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_ThreadingModel
{
	e_Apartment = 0 ,
	e_Both ,
	e_Free ,
	e_Neutral ,
	e_ThreadingModel_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_Synchronization
{
	e_Ignored = 0 ,
	e_None ,
	e_Supported ,
	e_Required ,
	e_RequiresNew ,
	e_Synchronization_Unknown 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_Boolean
{
	e_False = 0 ,
	e_True ,
	e_Boolean_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_ImpersonationLevel
{
	e_Impersonate_None = 0 ,
	e_Impersonate ,
	e_ImpersonationLevel_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_InitializationReentrancy
{
	e_InitializationReentrancy_Clsid = 0 ,
	e_InitializationReentrancy_Namespace ,
	e_InitializationReentrancy_None ,
	e_InitializationReentrancy_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_InteractionType
{
	e_InteractionType_Pull = 0 ,
	e_InteractionType_Push ,
	e_InteractionType_PushVerify ,
	e_InteractionType_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define e_QuerySupportLevels_UnarySelect ( 1 )
#define e_QuerySupportLevels_References ( e_QuerySupportLevels_UnarySelect << 1 )
#define e_QuerySupportLevels_Associators ( e_QuerySupportLevels_References << 1 )
#define e_QuerySupportLevels_V1ProviderDefined ( e_QuerySupportLevels_Associators << 1 )
#define e_QuerySupportLevels_None ( e_QuerySupportLevels_V1ProviderDefined << 1 )
#define e_QuerySupportLevels_Unknown ( 0 )


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef ULONGLONG Enum_PropertyMask ;

#define	e_ThreadingModel 0x1 
#define	e_Synchronization 0x2
#define	e_Clsid 0x4
#define	e_ClientClsid 0x8
#define	e_DefaultMachineName 0x10
#define	e_UnloadTimeout 0x20
#define	e_ImpersonationLevel 0x40
#define	e_InitializationReentrancy 0x80
#define	e_InitializeAsAdminFirst 0x100
#define	e_PerUserInitialization 0x200
#define	e_PerLocaleInitialization 0x400
#define	e_Pure 0x800
#define	e_Hosting 0x1000
#define	e_HostingGroup 0x2000
#define	e_SupportsPut 0x4000
#define	e_SupportsGet 0x8000
#define	e_SupportsDelete 0x10000
#define	e_SupportsEnumeration 0x20000
#define	e_QuerySupportLevels 0x40000
#define	e_InteractionType 0x80000
#define	e_ResultSetQueries 0x100000
#define	e_UnSupportedQueries 0x200000
#define	e_ReferencedSetQueries 0x400000
#define	e_ClearAfter 0x800000
#define	e_SupportsThrottling 0x1000000
#define	e_ConcurrentIndependantRequests 0x2000000
#define	e_SupportsSendStatus 0x4000000
#define	e_OperationTimeoutInterval 0x8000000
#define	e_InitializationTimeoutInterval 0x10000000
#define	e_SupportsQuotas 0x20000000
#define	e_Enabled 0x40000000
#define	e_SupportsShutdown 0x80000000
#define	e_SupportsBatching 0x100000000
#define	e_SupportsTransactions 0x200000000
#define	e_CacheRefreshInterval 0x400000000
#define	e_PerUserSchema 0x800000000
#define	e_ReSynchroniseOnNamespaceOpen 0x1000000000
#define	e_MemoryPerHost 0x2000000000
#define	e_MemoryAllHosts 0x4000000000
#define	e_ThreadsPerHost 0x8000000000
#define	e_HandlesPerHost 0x10000000000
#define	e_ProcessLimitAllHosts 0x20000000000
#define	e_Version 0x40000000000
#define	e_SecurityDescriptor 0x80000000000
#define	e_Name 0x100000000000

#define	e_All 0xFFFFFFFFFFFFFFFF

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_GlobalRegistration 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	LPWSTR m_Object_UnloadTimeout ;
	ULONG m_Object_UnloadTimeoutMilliSeconds ;

	LPWSTR m_Event_UnloadTimeout ;
	ULONG m_Event_UnloadTimeoutMilliSeconds ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

protected:

	static LPCWSTR s_Strings_Wmi_ClearAfter ;
	static LPCWSTR s_Strings_Wmi___ObjectProviderCacheControl ;
	static LPCWSTR s_Strings_Wmi___EventProviderCacheControl ;
	static LPCWSTR s_Strings_Wmi_Class ;
	static LPCWSTR s_Strings_Wmi_s_Strings_Query_Object ;
	static LPCWSTR s_Strings_Wmi_s_Strings_Path_Object ;
	static LPCWSTR s_Strings_Wmi_s_Strings_Query_Event ;
	static LPCWSTR s_Strings_Wmi_s_Strings_Path_Event ;

protected:
public:	/* Internal */

    CServerObject_GlobalRegistration () ;
    ~CServerObject_GlobalRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object ,
		LPWSTR &a_UnloadTimeout ,
		ULONG &a_UnloadTimeoutMilliSeconds 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask
	) ;

	wchar_t *GetUnloadTimeout () { return m_Object_UnloadTimeout ; }
	ULONG GetUnloadTimeoutMilliSeconds () { return m_Object_UnloadTimeoutMilliSeconds ; }

	wchar_t *GetObjectUnloadTimeout () { return m_Object_UnloadTimeout ; }
	ULONG GetObjectUnloadTimeoutMilliSeconds () { return m_Object_UnloadTimeoutMilliSeconds ; }

	wchar_t *GetEventUnloadTimeout () { return m_Event_UnloadTimeout ; }
	ULONG GetEventUnloadTimeoutMilliSeconds () { return m_Event_UnloadTimeoutMilliSeconds ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_HostQuotaRegistration 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	SIZE_T m_MemoryPerHost ;
	SIZE_T m_MemoryAllHosts ;
	ULONG m_ThreadsPerHost ;
	ULONG m_HandlesPerHost ;
	ULONG m_ProcessLimitAllHosts ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

protected:

	static LPCWSTR s_Strings_Wmi_HostQuotas_Query ;
	static LPCWSTR s_Strings_Wmi_HostQuotas_Path ;
	static LPCWSTR s_Strings_Wmi_MemoryPerHost ;
	static LPCWSTR s_Strings_Wmi_MemoryAllHosts ;
	static LPCWSTR s_Strings_Wmi_ThreadsPerHost ;
	static LPCWSTR s_Strings_Wmi_HandlesPerHost ;
	static LPCWSTR s_Strings_Wmi_ProcessLimitAllHosts ;

protected:
public:	/* Internal */

    CServerObject_HostQuotaRegistration () ;
    ~CServerObject_HostQuotaRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask
	) ;

	SIZE_T GetMemoryPerHost () { return m_MemoryPerHost ; }
	SIZE_T GetMemoryAllHosts () { return m_MemoryAllHosts ; }
	ULONG GetThreadsPerHost () { return m_ThreadsPerHost; }
	ULONG GetHandlesPerHost () { return m_HandlesPerHost; }
	ULONG GetProcessLimitAllHosts () { return m_ProcessLimitAllHosts ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ComRegistration 
{
private:

	LONG m_ReferenceCount ;

private:

	HRESULT Load_ThreadingModel ( HKEY a_Clsid ) ;
	HRESULT Load_Synchronization ( HKEY a_ClsidKey ) ;

	HRESULT Load_InProcServer32 ( LPCWSTR a_ClsidStringKey ) ;
	HRESULT Load_LocalServer32 ( LPCWSTR a_ClsidStringKey ) ;

	HRESULT Load_AppId ( HKEY a_Clsid_Key ) ;
	HRESULT Load_ServerTypes ( LPCWSTR a_ClsidString ) ;

protected:

	HRESULT m_Result ;

	Enum_ThreadingModel m_ThreadingModel ;
	Enum_Synchronization m_Synchronization ;

	Enum_Boolean m_InProcServer32 ;
	Enum_Boolean m_LocalServer32 ;
	Enum_Boolean m_Service ;
	Enum_Boolean m_Loaded ;
	BSTR m_Clsid ;
	BSTR m_AppId ;
	BSTR m_ProviderName ;
	wchar_t m_InProcServer32_Path [ MAX_PATH ] ;
	wchar_t m_LocalServer32_Path [ MAX_PATH ] ;
	wchar_t m_Server_Name [ MAX_PATH ] ;

protected:

	static LPCWSTR s_Strings_Reg_Null ;

	static LPCWSTR s_Strings_Reg_ThreadingModel ;
	static LPCWSTR s_Strings_Reg_InProcServer32 ;
	static LPCWSTR s_Strings_Reg_LocalServer32 ;
	static LPCWSTR s_Strings_Reg_Synchronization ;
	static LPCWSTR s_Strings_Reg_AppId ;

	static LPCWSTR s_Strings_Reg_Apartment_Apartment ;
	static LPCWSTR s_Strings_Reg_Apartment_Both ;
	static LPCWSTR s_Strings_Reg_Apartment_Free ;
	static LPCWSTR s_Strings_Reg_Apartment_Neutral ;

	static LPCWSTR s_Strings_Reg_Apartment_Required ;
	static LPCWSTR s_Strings_Reg_Synchronization_Ignored ; 
	static LPCWSTR s_Strings_Reg_Synchronization_None ;
	static LPCWSTR s_Strings_Reg_Synchronization_Supported ;
	static LPCWSTR s_Strings_Reg_Synchronization_Required ;
	static LPCWSTR s_Strings_Reg_Synchronization_RequiresNew ;

	static LPCWSTR s_Strings_Reg_ClsidKeyStr ;

public:	/* Internal */

    CServerObject_ComRegistration () ;
    ~CServerObject_ComRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT Load ( LPCWSTR a_Clsid , LPCWSTR a_ProviderName ) ;

	Enum_ThreadingModel GetThreadingModel () { return m_ThreadingModel ; }
	Enum_Synchronization GetSynchronization () { return m_Synchronization ; }

	Enum_Boolean InProcServer32 () { return m_InProcServer32 ; }
	Enum_Boolean LocalServer32 () { return m_LocalServer32 ; }
	Enum_Boolean Loaded () { return m_Loaded ; }

	wchar_t *GetInProcServer32_Path () { return m_InProcServer32_Path ; }
	wchar_t *GetLocalServer32_Path () { return m_LocalServer32_Path ; }
	wchar_t *GetServer_Name () { return m_Server_Name ; }
	wchar_t *GetProviderName () { return m_ProviderName ; }
	wchar_t *GetProviderClsid () { return m_Clsid ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ComProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	CServerObject_ComRegistration m_ClsidServer ;

	ULONG m_Version ;
	Enum_ImpersonationLevel m_ImpersonationLevel ;
	Enum_InitializationReentrancy m_InitializationReentrancy ;
	BOOL m_InitializeAsAdminFirst ;
	BOOL m_PerUserInitialization ;
	BOOL m_PerLocaleInitialization ;
	BOOL m_SupportsQuotas ;
	BOOL m_Enabled ;
	BOOL m_SupportsShutdown ;
	BOOL m_Pure ;
	Enum_Hosting m_Hosting ;
	LPWSTR m_HostingGroup ;
	LPWSTR m_DefaultMachineName ;
	BOOL m_DecoupledImpersonationRestriction ;

	LPWSTR m_InitializationTimeout ;
	ULONG m_InitializationTimeoutMilliSeconds ;

	LPWSTR m_UnloadTimeout ;
	ULONG m_UnloadTimeoutMilliSeconds ;

	BOOL m_SupportsSendStatus ;
	LPWSTR m_OperationTimeout ;
	ULONG m_OperationTimeoutMilliSeconds ;

	BOOL m_SupportsThrottling ;
	ULONG m_ConcurrentIndependantRequests ;

	BSTR m_ProviderName ;

	GUID m_CLSID ;
	GUID m_ClientCLSID ;

	IWbemClassObject *m_Identity ;
	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;
	SECURITY_DESCRIPTOR *m_SecurityDescriptor ;

public:

	static LPCWSTR s_Strings_Wmi_Clsid ;
	static LPCWSTR s_Strings_Wmi_ClientClsid ;
	static LPCWSTR s_Strings_Wmi_Name ;
	static LPCWSTR s_Strings_Wmi_Version ;
	static LPCWSTR s_Strings_Wmi_DefaultMachineName ;
	static LPCWSTR s_Strings_Wmi_UnloadTimeout ;
	static LPCWSTR s_Strings_Wmi_ImpersonationLevel ;
	static LPCWSTR s_Strings_Wmi_InitializationReentrancy ;
	static LPCWSTR s_Strings_Wmi_InitializeAsAdminFirst ;
	static LPCWSTR s_Strings_Wmi_PerUserInitialization ;
	static LPCWSTR s_Strings_Wmi_PerLocaleInitialization ;
	static LPCWSTR s_Strings_Wmi_Pure ;
	static LPCWSTR s_Strings_Wmi_Hosting ;
	static LPCWSTR s_Strings_Wmi_HostingGroup ;
	static LPCWSTR s_Strings_Wmi_SupportsThrottling ;
	static LPCWSTR s_Strings_Wmi_SupportsQuotas ;
	static LPCWSTR s_Strings_Wmi_SupportsShutdown ;
	static LPCWSTR s_Strings_Wmi_Enabled ;
	static LPCWSTR s_Strings_Wmi_ConcurrentIndependantRequests ;
	static LPCWSTR s_Strings_Wmi_SupportsSendStatus ;
	static LPCWSTR s_Strings_Wmi_OperationTimeoutInterval ;
	static LPCWSTR s_Strings_Wmi_InitializationTimeoutInterval ;
	static LPCWSTR s_Strings_Wmi_SecurityDescriptor ;

	static WCHAR s_Strings_Wmi_WmiCore [] ;
	static WCHAR s_Strings_Wmi_SelfHost [] ;
	static WCHAR s_Strings_Wmi_WmiCoreOrSelfHost [] ;
	static WCHAR s_Strings_Wmi_Decoupled [] ;
	static WCHAR s_Strings_Wmi_DecoupledColon [] ;
	static WCHAR s_Strings_Wmi_SharedLocalSystemHost [] ;
	static WCHAR s_Strings_Wmi_SharedLocalSystemHostOrSelfHost [] ;
	static WCHAR s_Strings_Wmi_SharedLocalServiceHost [] ;
	static WCHAR s_Strings_Wmi_SharedNetworkServiceHost [] ;
	static WCHAR s_Strings_Wmi_SharedUserHost [] ;
	static WCHAR s_Strings_Wmi_NonCom [] ;

	static WCHAR s_Strings_Wmi_DefaultSharedLocalSystemHost [] ;
	static WCHAR s_Strings_Wmi_DefaultSharedLocalSystemHostOrSelfHost [] ;
	static WCHAR s_Strings_Wmi_DefaultSharedLocalServiceHost [] ;
	static WCHAR s_Strings_Wmi_DefaultSharedNetworkServiceHost [] ;
	static WCHAR s_Strings_Wmi_DefaultSharedUserHost [] ;

	static LPCWSTR s_Strings_Wmi_DefaultHostingRegistryKey ;

protected:
public:	/* Internal */

    CServerObject_ComProviderRegistrationV1 () ;
    ~CServerObject_ComProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object ,
		LPCWSTR a_ProviderName
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	const CLSID &GetClsid () { return m_CLSID ; }
	const CLSID &GetClientClsid () { return m_ClientCLSID ; }
	wchar_t *GetProviderName () { return m_ProviderName ; }

	ULONG GetVersion () { return m_Version ; }
	Enum_ImpersonationLevel GetImpersonationLevel () { return m_ImpersonationLevel ; }
	Enum_InitializationReentrancy GetInitializationReentrancy () { return m_InitializationReentrancy ; }
	Enum_Hosting GetHosting () { return m_Hosting ; }
	LPCWSTR GetHostingGroup () { return m_HostingGroup ; }

	BOOL InitializeAsAdminFirst () { return m_InitializeAsAdminFirst ; }
	BOOL PerUserInitialization () { return m_PerUserInitialization ; }
	BOOL PerLocaleInitialization () { return m_PerLocaleInitialization ; }
	BOOL Pure () { return m_Pure ; }
	BOOL Enabled () { return m_Enabled ; }
	BOOL SupportsQuotas () { return m_SupportsQuotas ; }

	wchar_t *GetDefaultMachineName () { return m_DefaultMachineName ; }
	wchar_t *GetUnloadTimeout () { return m_UnloadTimeout ; }
	wchar_t *GetInitializationTimeout () { return m_InitializationTimeout ; }
	wchar_t *GetOperationTimeout () { return m_OperationTimeout ; }

	void SetUnloadTimeoutMilliSeconds ( ULONG a_UnloadTimeoutMilliSeconds ) { m_UnloadTimeoutMilliSeconds = a_UnloadTimeoutMilliSeconds ; }

	ULONG GetUnloadTimeoutMilliSeconds () { return m_UnloadTimeoutMilliSeconds ; }
	ULONG GetInitializationTimeoutMilliSeconds () { return m_InitializationTimeoutMilliSeconds ; }
	ULONG GetOperationTimeoutMilliSeconds () { return m_OperationTimeoutMilliSeconds ; }

	ULONG GetConcurrentIndependantRequests () { return m_ConcurrentIndependantRequests ; }
	BOOL GetSupportsThrottling () { return m_SupportsThrottling ; }
	BOOL GetSupportsSendStatus () { return m_SupportsSendStatus ; }
	BOOL GetSupportsShutdown () { return m_SupportsShutdown ; }

	Enum_ThreadingModel GetThreadingModel () { return m_ClsidServer.GetThreadingModel () ; }	

	BOOL GetDecoupledImpersonationRestriction () { return m_DecoupledImpersonationRestriction ; }

	CServerObject_ComRegistration &GetClsidServer () { return m_ClsidServer ; }

	SECURITY_DESCRIPTOR *GetSecurityDescriptor () { return m_SecurityDescriptor ; }

	HRESULT GetResult () { return m_Result ; }

	IWbemClassObject *GetIdentity () { return m_Identity ; }

	static HRESULT GetHosting (
	
		LPCWSTR a_Hosting , 
		Enum_Hosting & a_HostingValue , 
		LPWSTR &a_HostingGroup ,
		BOOL & a_ImpersonationRestriction 
	) ;

	static HRESULT GetHostingGroup ( 

		LPCWSTR a_Hosting , 
		size_t a_Prefix ,
		Enum_Hosting a_ExpectedHostingValue ,
		Enum_Hosting & a_HostingValue ,
		BSTR & a_HostingGroup
	) ;

	static HRESULT GetDefaultHostingGroup ( 

		Enum_Hosting a_HostingValue ,
		BSTR & a_HostingGroup 
	) ;

	static HRESULT GetDecoupledImpersonationRestriction ( 

		LPCWSTR a_Hosting , 
		BOOL & a_ImpersonationRestriction 
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_InstanceProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;
	BOOL m_SupportsPut ;
 	BOOL m_SupportsGet ;
	BOOL m_SupportsDelete ;
	BOOL m_SupportsEnumeration ;
	BOOL m_SupportsBatching ;
	BOOL m_SupportsTransactions ;

	Enum_InteractionType m_InteractionType ;
	ULONG m_QuerySupportLevels ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_InstanceProviderRegistration ;

	static LPCWSTR s_Strings_SupportsPut ;
	static LPCWSTR s_Strings_SupportsGet ;
	static LPCWSTR s_Strings_SupportsDelete ;
	static LPCWSTR s_Strings_SupportsEnumeration ;
	static LPCWSTR s_Strings_QuerySupportLevels ;
	static LPCWSTR s_Strings_InteractionType ;

	static LPCWSTR s_Strings_SupportsBatching ;
	static LPCWSTR s_Strings_SupportsTransactions ;

	static LPCWSTR s_Strings_QuerySupportLevels_UnarySelect ;
	static LPCWSTR s_Strings_QuerySupportLevels_References ;
	static LPCWSTR s_Strings_QuerySupportLevels_Associators ;
	static LPCWSTR s_Strings_QuerySupportLevels_V1ProviderDefined ;

	static LPCWSTR s_Strings_InteractionType_Pull ;
	static LPCWSTR s_Strings_InteractionType_Push ;
	static LPCWSTR s_Strings_InteractionType_PushVerify ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_InstanceProviderRegistrationV1 () ;
    ~CServerObject_InstanceProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL SupportsPut () { return m_SupportsPut ; }
	BOOL SupportsGet () { return m_SupportsGet ; }
	BOOL SupportsDelete () { return m_SupportsDelete ; }
	BOOL SupportsEnumeration () { return m_SupportsEnumeration ; }
	BOOL SupportsTransactions () { return m_SupportsTransactions ; }
	BOOL SupportsBatching () { return m_SupportsBatching ; }

	ULONG QuerySupportLevels () { return m_QuerySupportLevels ; }
	Enum_InteractionType InteractionType () { return m_InteractionType ; }

	BOOL Supported () { return m_Supported ; }
	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ClassProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;
	BOOL m_SupportsPut ;
 	BOOL m_SupportsGet ;
	BOOL m_SupportsDelete ;
	BOOL m_SupportsEnumeration ;
	BOOL m_SupportsBatching ;
	BOOL m_SupportsTransactions ;
	BOOL m_PerUserSchema ;
	BOOL m_ReSynchroniseOnNamespaceOpen ;
	BOOL m_HasReferencedSet;
	Enum_InteractionType m_InteractionType ;
	ULONG m_QuerySupportLevels ;
	ULONG m_Version ;
	LPWSTR m_CacheRefreshInterval ;
	ULONG m_CacheRefreshIntervalMilliSeconds ;

	LPWSTR m_ProviderName ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

	ULONG m_ResultSetQueryTreeCount ;
	WmiTreeNode **m_ResultSetQueryTree ;

	ULONG m_UnSupportedQueryTreeCount ;
	WmiTreeNode **m_UnSupportedQueryTree ;

	ULONG m_ReferencedSetQueryTreeCount ;
	WmiTreeNode **m_ReferencedSetQueryTree ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_ClassProviderRegistration ;

	static LPCWSTR s_Strings_Version ;

	static LPCWSTR s_Strings_SupportsPut ;
	static LPCWSTR s_Strings_SupportsGet ;
	static LPCWSTR s_Strings_SupportsDelete ;
	static LPCWSTR s_Strings_SupportsEnumeration ;
	static LPCWSTR s_Strings_QuerySupportLevels ;
	static LPCWSTR s_Strings_InteractionType ;
	static LPCWSTR s_Strings_SupportsBatching ;
	static LPCWSTR s_Strings_SupportsTransactions ;
	static LPCWSTR s_Strings_CacheRefreshInterval ;
	static LPCWSTR s_Strings_PerUserSchema ;
	static LPCWSTR s_Strings_ReSynchroniseOnNamespaceOpen ;

	static LPCWSTR s_Strings_QuerySupportLevels_UnarySelect ;
	static LPCWSTR s_Strings_QuerySupportLevels_References ;
	static LPCWSTR s_Strings_QuerySupportLevels_Associators ;
	static LPCWSTR s_Strings_QuerySupportLevels_V1ProviderDefined ;

	static LPCWSTR s_Strings_InteractionType_Pull ;
	static LPCWSTR s_Strings_InteractionType_Push ;
	static LPCWSTR s_Strings_InteractionType_PushVerify ;

	static LPCWSTR s_Strings_ResultSetQueries ;
	static LPCWSTR s_Strings_UnSupportedQueries ;
	static LPCWSTR s_Strings_ReferencedSetQueries ;

private:

	HRESULT ParseQuery (

		ULONG &a_Count ,
		WmiTreeNode **&a_Root ,
		SAFEARRAY *a_Array
	) ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_ClassProviderRegistrationV1 () ;
    ~CServerObject_ClassProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL SupportsPut () { return m_SupportsPut ; }
	BOOL SupportsGet () { return m_SupportsGet ; }
	BOOL SupportsDelete () { return m_SupportsDelete ; }
	BOOL SupportsEnumeration () { return m_SupportsEnumeration ; }
	BOOL SupportsTransactions () { return m_SupportsTransactions ; }
	BOOL SupportsBatching () { return m_SupportsBatching ; }
	BOOL GetPerUserSchema () { return m_PerUserSchema ; }
	BOOL GetReSynchroniseOnNamespaceOpen () { return m_ReSynchroniseOnNamespaceOpen ; }
	BOOL HasReferencedSet () { return m_HasReferencedSet ; }
	ULONG QuerySupportLevels () { return m_QuerySupportLevels ; }
	Enum_InteractionType InteractionType () { return m_InteractionType ; }

	ULONG GetResultSetQueryCount () { return m_ResultSetQueryTreeCount ; }
	WmiTreeNode **GetResultSetQuery () { return m_ResultSetQueryTree ; }

	ULONG GetUnSupportedQueryCount () { return m_UnSupportedQueryTreeCount ; }
	WmiTreeNode **GetUnSupportedQuery () { return m_UnSupportedQueryTree ; }

	ULONG GetReferencedSetQueryCount () { return m_ReferencedSetQueryTreeCount ; }
	WmiTreeNode **GetReferencedSetQuery () { return m_ReferencedSetQueryTree ; }

	wchar_t *GetCacheRefreshInterval () { return m_CacheRefreshInterval ; }
	ULONG GetCacheRefreshIntervalMilliSeconds () { return m_CacheRefreshIntervalMilliSeconds ; }

	wchar_t *GetProviderName () { return m_ProviderName ; }

	BOOL Supported () { return m_Supported ; }
	HRESULT GetResult () { return m_Result ; }

	BOOL GetVersion () { return m_Version ; } 
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_MethodProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;
	BOOL m_SupportsMethods ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_MethodProviderRegistration ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_MethodProviderRegistrationV1 () ;
    ~CServerObject_MethodProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL SupportsMethods () { return m_SupportsMethods ; }

	BOOL Supported () { return m_Supported ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_EventProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_EventProviderRegistration ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_EventProviderRegistrationV1 () ;
    ~CServerObject_EventProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL Supported () { return m_Supported ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_EventConsumerProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_EventConsumerProviderRegistration ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_EventConsumerProviderRegistrationV1 () ;
    ~CServerObject_EventConsumerProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL Supported () { return m_Supported ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_DynamicPropertyProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;
	BOOL m_SupportsPut ;
 	BOOL m_SupportsGet ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;


private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_PropertyProviderRegistration ;

	static LPCWSTR s_Strings_SupportsPut ;
	static LPCWSTR s_Strings_SupportsGet ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_DynamicPropertyProviderRegistrationV1 () ;
    ~CServerObject_DynamicPropertyProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL SupportsPut () { return m_SupportsPut ; }
	BOOL SupportsGet () { return m_SupportsGet ; }

	BOOL Supported () { return m_Supported ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_ClassProviderRegistration ;
	static LPCWSTR s_Strings_InstanceProviderRegistration ;
	static LPCWSTR s_Strings_MethodProviderRegistration ;
	static LPCWSTR s_Strings_PropertyProviderRegistration ;
	static LPCWSTR s_Strings_EventProviderRegistration ;
	static LPCWSTR s_Strings_EventConsumerProviderRegistration ;

protected:

	HRESULT m_Result ;

	CServerObject_ComProviderRegistrationV1 m_ComRegistration ;

	CServerObject_ClassProviderRegistrationV1 m_ClassProviderRegistration ;
	CServerObject_InstanceProviderRegistrationV1 m_InstanceProviderRegistration ;
	CServerObject_MethodProviderRegistrationV1 m_MethodProviderRegistration ;
	CServerObject_DynamicPropertyProviderRegistrationV1 m_PropertyProviderRegistration ;
	CServerObject_EventProviderRegistrationV1 m_EventProviderRegistration ;
	CServerObject_EventConsumerProviderRegistrationV1 m_EventConsumerProviderRegistration ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_ProviderRegistrationV1 () ;
    ~CServerObject_ProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	const CLSID &GetClsid () { return m_ComRegistration.GetClsid () ; }

	BOOL PerUserInitialization () { return m_ComRegistration.PerUserInitialization () ; }
	BOOL PerLocaleInitialization () { return m_ComRegistration.PerLocaleInitialization () ; }
	Enum_InitializationReentrancy GetInitializationReentrancy () { return m_ComRegistration.GetInitializationReentrancy () ; }
	Enum_ThreadingModel GetThreadingModel () { return m_ComRegistration.GetThreadingModel () ; }	
	Enum_Hosting GetHosting () { return m_ComRegistration.GetHosting () ; }
	LPCWSTR GetHostingGroup () { return m_ComRegistration.GetHostingGroup () ; }

	ULONG GetUnloadTimeoutMilliSeconds () { return m_ComRegistration.GetUnloadTimeoutMilliSeconds () ; }
	wchar_t *GetProviderName () { return m_ComRegistration.GetProviderName () ; }
	CServerObject_ComProviderRegistrationV1 &GetComRegistration () { return m_ComRegistration ; }

	IWbemClassObject *GetIdentity () { return m_ComRegistration.GetIdentity () ; }

	CServerObject_ClassProviderRegistrationV1 &GetClassProviderRegistration () { return m_ClassProviderRegistration ; }
	CServerObject_InstanceProviderRegistrationV1 &GetInstanceProviderRegistration () { return m_InstanceProviderRegistration ; }
	CServerObject_MethodProviderRegistrationV1 &GetMethodProviderRegistration () { return m_MethodProviderRegistration ; }
	CServerObject_DynamicPropertyProviderRegistrationV1 &GetPropertyProviderRegistration () { return m_PropertyProviderRegistration ; }
	CServerObject_EventProviderRegistrationV1 &GetEventProviderRegistration () { return m_EventProviderRegistration ; }
	CServerObject_EventConsumerProviderRegistrationV1 &GetEventConsumerProviderRegistration () { return m_EventConsumerProviderRegistration ; }

	void SetUnloadTimeoutMilliSeconds ( ULONG a_UnloadTimeoutMilliSeconds ) { m_ComRegistration.SetUnloadTimeoutMilliSeconds ( a_UnloadTimeoutMilliSeconds ) ; }

	ULONG GetInitializationTimeoutMilliSeconds () { return m_ComRegistration.GetInitializationTimeoutMilliSeconds () ; }

	HRESULT GetResult () { return m_Result ; }

	BOOL ObjectProvider () ;
	BOOL EventProvider () ;
};

#endif // _Server_ProviderRegistrationInfo_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provtree.h ===
// (C) 1999-2001 Microsoft Corporation 
#ifndef WMI_TREE
#define WMI_TREE

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef DWORD TypeId_TreeNode ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiTreeNode 
{
	bool m_valid;

protected:

	TypeId_TreeNode m_Type ;

	void *m_Data ;
	WmiTreeNode *m_Left ;
	WmiTreeNode *m_Right ;
	WmiTreeNode *m_Parent ;
	
public:

	WmiTreeNode ( 

		WmiTreeNode *a_Node 
	) 
	{
		m_Type = a_Node->m_Type ;
		m_Data = a_Node->m_Data ;
		m_Left = a_Node->m_Left ;
		m_Right = a_Node->m_Right ;
		m_Parent = a_Node->m_Parent ;
		m_valid = a_Node->m_valid;
	}

	WmiTreeNode ( 

		TypeId_TreeNode a_Type = 0 ,
		void *a_Data = NULL ,
		WmiTreeNode *a_Left = NULL ,
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 
	) : m_valid(true)
	{
		m_Type = a_Type ;
		m_Parent = a_Parent ;
		m_Data = a_Data ;
		m_Left = a_Left ;
		m_Right = a_Right ;

		if ( m_Left )
			m_Left->SetParent ( this ) ;

		if ( m_Right )
			m_Right->SetParent ( this ) ;
	}

	virtual ~WmiTreeNode () {}

	bool IsValid() { return m_valid;}
	
	void SetValid(bool valid) { m_valid = valid;}

	TypeId_TreeNode GetType ()
	{
		return m_Type ;
	}

	void *GetData () 
	{
		return m_Data ; 
	}

	WmiTreeNode *GetLeft () 
	{ 
		return m_Left ; 
	}

	WmiTreeNode *GetRight () 
	{
		return m_Right ; 
	}

	WmiTreeNode *GetParent () 
	{
		return m_Parent ; 
	}

	void GetData ( void **a_Data ) 
	{
		*a_Data = & m_Data ; 
	}

	void GetLeft ( WmiTreeNode **&a_Left ) 
	{ 
		a_Left = &m_Left ; 
	}

	void GetRight ( WmiTreeNode **&a_Right ) 
	{
		a_Right = &m_Right ; 
	}

	void GetParent ( WmiTreeNode **&a_Parent ) 
	{
		a_Parent = &m_Parent ; 
	}

	void SetType ( TypeId_TreeNode a_Type )
	{
		m_Type = a_Type ;
	}

	void *SetData ( void *a_Data )
	{
		void *t_Data = m_Data ;
		m_Data = a_Data ;
		return t_Data ;
	}

	WmiTreeNode *SetLeft ( WmiTreeNode *a_Left )
	{
		WmiTreeNode *t_Left = m_Left ;
		m_Left = a_Left ;
		return t_Left ;
	}

	WmiTreeNode *SetRight ( WmiTreeNode *a_Right ) 
	{
		WmiTreeNode *t_Right = m_Right ;
		m_Right = a_Right ;
		return t_Right ;
	}

	WmiTreeNode *SetParent ( WmiTreeNode *a_Parent ) 
	{
		WmiTreeNode *t_Parent = m_Parent ;
		m_Parent = a_Parent ;
		return t_Parent ;
	}

	virtual WmiTreeNode *Copy () ;	// Copy node, not allocating copies of data and allocating copies of sub tree

	virtual WmiTreeNode *CopyNode () ; // Copy node, not allocating copies of data and subtree

	virtual void Print () {} ;
} ;

class WmiTreeNodeIterator 
{
protected:

	WmiTreeNode *m_Iterator ;

public:

	WmiTreeNodeIterator ( WmiTreeNodeIterator *a_WmiTreeNodeIterator )
	{
		m_Iterator = a_WmiTreeNodeIterator->m_Iterator ; 
	}

	WmiTreeNodeIterator ( WmiTreeNode *a_Root ) 
	{
		m_Iterator = a_Root ; 
	}

	virtual ~WmiTreeNodeIterator () {}

	WmiTreeNode *GetIterator () 
	{
		return m_Iterator ; 
	}

	WmiTreeNode *SetIterator ( WmiTreeNode *a_Iterator ) 
	{ 
		WmiTreeNode *t_Iterator = m_Iterator ;
		m_Iterator = a_Iterator ;
		return t_Iterator ;
	}

	virtual WmiTreeNodeIterator *Copy ()	
	{
		WmiTreeNodeIterator *t_Iterator = new WmiTreeNodeIterator ( m_Iterator ) ;
		return t_Iterator ;
	}

	void InOrder () ;
	void PreOrder () ;
	void PostOrder () ;
} ;

#endif // WMI_TREE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provregistrar.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Server_ProviderRegistrar_H
#define _Server_ProviderRegistrar_H

#include "Globals.h"

class CInterceptor_DecoupledClient ;

class CServerObject_ProviderRegistrar_Base : public IWbemDecoupledRegistrar
{
protected:

	WmiAllocator &m_Allocator ;

	CriticalSection m_CriticalSection ;

	GUID m_Identity ;

	BSTR m_Clsid ;
	BSTR m_User ;
	BSTR m_Locale ;
	BSTR m_Scope ;
	BSTR m_Registration ;

	BOOL m_Registered ;

	BYTE *m_MarshaledProxy ;
	DWORD m_MarshaledProxyLength ;

	CInterceptor_DecoupledClient *m_Provider ;

	HRESULT CreateInterceptor (

		IWbemContext *a_Context ,
		IUnknown *a_Unknown ,
		BYTE *&a_MarshaledProxy ,
		DWORD& a_MarshaledProxyLength ,
		IUnknown *&a_MarshaledUnknown
	) ;
	HRESULT DirectUnRegister (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Registration ,
		LPCWSTR a_Scope ,
		GUID &a_Identity
	) ;

	HRESULT DirectRegister (

		GUID &a_Identity ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Registration ,
		LPCWSTR a_Scope ,
		IUnknown *a_Unknown ,
		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength
	) ;

	HRESULT SaveToRegistry (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Registration ,
		LPCWSTR a_Scope ,
		IUnknown *a_Unknown ,
		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength 
	) ;

protected:

public: /* Internal */

public:	/* External */

	CServerObject_ProviderRegistrar_Base ( WmiAllocator &a_Allocator ) ;
	~CServerObject_ProviderRegistrar_Base () ;

	HRESULT STDMETHODCALLTYPE Register (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		IUnknown *a_Unknown
	) ;

	HRESULT STDMETHODCALLTYPE UnRegister () ;

	HRESULT Initialize () ;
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderRegistrar :	public CServerObject_ProviderRegistrar_Base
{
private:

    long m_ReferenceCount ;

protected:

public: /* Internal */

public:	/* External */

	CServerObject_ProviderRegistrar ( WmiAllocator &a_Allocator = *DecoupledProviderSubSystem_Globals::s_Allocator) ;
	~CServerObject_ProviderRegistrar () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;
};

#endif // _Server_ProviderRegistrar_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provwsv.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvWsv.H

Abstract:


History:

--*/

#ifndef _Server_Interceptor_IWbemServices_H
#define _Server_Interceptor_IWbemServices_H

#include <CGlobals.h>
#include "ProvCache.h"
#include "ProvRegInfo.h"

#define ProxyIndex_IWbemServices					0
#define ProxyIndex_IWbemPropertyProvider			1
#define ProxyIndex_IWbemHiPerfProvider				2
#define ProxyIndex_IWbemEventProvider				3
#define ProxyIndex_IWbemEventProviderQuerySink		4
#define ProxyIndex_IWbemEventProviderSecurity		5
#define ProxyIndex_IWbemProviderIdentity			6
#define ProxyIndex_IWbemEventConsumerProvider		7
#define ProxyIndex_IWbemEventConsumerProviderEx		8
#define ProxyIndex_IWbemUnboundObjectSink			9
#define ProxyIndex_IWbemProviderInit				10

#define ProxyIndex_Internal_IWbemServices					11
#define ProxyIndex_Internal_IWbemPropertyProvider			12
#define ProxyIndex_Internal_IWbemEventProvider				13
#define ProxyIndex_Internal_IWbemEventProviderQuerySink		14
#define ProxyIndex_Internal_IWbemEventProviderSecurity		15
#define ProxyIndex_Internal_IWbemEventConsumerProvider		16
#define ProxyIndex_Internal_IWbemEventConsumerProviderEx	17
#define ProxyIndex_Internal_IWbemUnboundObjectSink			18
#define ProxyIndex_Internal_IWbemProviderIdentity			19
#define ProxyIndex_Internal_IWbemProviderInit				20

#define ProxyIndex_IWbemShutdown					21
#define ProxyIndex__IWmiProviderConfiguration		22

#define ProxyIndex_Internal_IWmiProviderConfiguration		23

#define ProxyIndex_Provider_Size					23

#define ProxyIndex_UnBound_IWbemUnboundObjectSink				0
#define ProxyIndex_UnBound_Internal_IWbemUnboundObjectSink		1
#define ProxyIndex_UnBound_Size									2

#define ProxyIndex_UnBoundSync_IWbemUnboundObjectSink			0
#define ProxyIndex_UnBoundSync_Size								1


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncProvider :	public IWbemServices,
					public IWbemPropertyProvider ,
					public IWbemEventProvider ,
					public IWbemEventProviderQuerySink ,
					public IWbemEventProviderSecurity ,
					public IWbemProviderIdentity ,
					public IWbemHiPerfProvider ,
					public SyncProviderContainerElement ,
					public CWbemGlobal_IWmiObjectSinkController 
{
private:

	LONG m_ReferenceCount ;

	IUnknown *m_Unknown ;
	IWbemServices *m_Provider_IWbemServices ;
	IWbemPropertyProvider *m_Provider_IWbemPropertyProvider ;
	IWbemHiPerfProvider *m_Provider_IWbemHiPerfProvider ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;
	IWbemProviderIdentity *m_Provider_IWbemProviderIdentity ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemServices *m_CoreStub ;


	ProxyContainer m_ProxyContainer ;

	LONG m_Initialized ;
	HRESULT m_InitializeResult ;
	HANDLE m_InitializedEvent ;
	IWbemContext *m_InitializationContext ;

public:

	HRESULT SetInitialized ( HRESULT a_InitializeResult ) ;

public:

	CServerObject_ProviderRegistrationV1 *m_Registration ;
	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Namespace ;
	BSTR m_TransactionIdentifier ;

	UINT64 m_ProviderOperation_GetObjectAsync ;
	UINT64 m_ProviderOperation_PutClassAsync ;
	UINT64 m_ProviderOperation_DeleteClassAsync ;
	UINT64 m_ProviderOperation_CreateClassEnumAsync ;
	UINT64 m_ProviderOperation_PutInstanceAsync ;
	UINT64 m_ProviderOperation_DeleteInstanceAsync ;
	UINT64 m_ProviderOperation_CreateInstanceEnumAsync ;
	UINT64 m_ProviderOperation_ExecQueryAsync ;
	UINT64 m_ProviderOperation_ExecNotificationQueryAsync ;
	UINT64 m_ProviderOperation_ExecMethodAsync ;

	UINT64 m_ProviderOperation_Begin ;
	UINT64 m_ProviderOperation_Rollback ;
	UINT64 m_ProviderOperation_Commit ;
	UINT64 m_ProviderOperation_QueryState ;

	UINT64 m_ProviderOperation_QueryInstances ;
	UINT64 m_ProviderOperation_CreateRefresher ;
	UINT64 m_ProviderOperation_CreateRefreshableObject ;
	UINT64 m_ProviderOperation_StopRefreshing ;
	UINT64 m_ProviderOperation_CreateRefreshableEnum ;
	UINT64 m_ProviderOperation_GetObjects ;

	UINT64 m_ProviderOperation_GetProperty ;
	UINT64 m_ProviderOperation_PutProperty ;

	UINT64 m_ProviderOperation_ProvideEvents ;
	UINT64 m_ProviderOperation_NewQuery ;
	UINT64 m_ProviderOperation_CancelQuery ;
	UINT64 m_ProviderOperation_AccessCheck ;
	UINT64 m_ProviderOperation_SetRegistrationObject ;
	UINT64 m_ProviderOperation_FindConsumer ;
	UINT64 m_ProviderOperation_ValidateSubscription ;

	UINT64 m_ProviderOperation_OpenAsync ;
	UINT64 m_ProviderOperation_AddAsync ;
	UINT64 m_ProviderOperation_RemoveAsync ;
	UINT64 m_ProviderOperation_RefreshObjectAsync ;
	UINT64 m_ProviderOperation_RenameObjectAsync ;
	UINT64 m_ProviderOperation_DeleteObjectAsync ;
	UINT64 m_ProviderOperation_PutObjectAsync ;

	void Increment_ProviderOperation_GetObjectAsync () { m_ProviderOperation_GetObjectAsync ++ ; }
 	void Increment_ProviderOperation_PutClassAsync () { m_ProviderOperation_PutClassAsync ++ ; }
	void Increment_ProviderOperation_DeleteClassAsync () { m_ProviderOperation_DeleteClassAsync ++ ; }
	void Increment_ProviderOperation_CreateClassEnumAsync () { m_ProviderOperation_CreateClassEnumAsync ++ ; }
	void Increment_ProviderOperation_PutInstanceAsync () { m_ProviderOperation_PutInstanceAsync ++ ; }
	void Increment_ProviderOperation_DeleteInstanceAsync () { m_ProviderOperation_DeleteInstanceAsync ++ ; }
	void Increment_ProviderOperation_CreateInstanceEnumAsync () { m_ProviderOperation_CreateInstanceEnumAsync ++ ; }
	void Increment_ProviderOperation_ExecQueryAsync () { m_ProviderOperation_ExecQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecNotificationQueryAsync () { m_ProviderOperation_ExecNotificationQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecMethodAsync () { m_ProviderOperation_ExecMethodAsync ++ ; }

	void Increment_ProviderOperation_Begin () { m_ProviderOperation_Begin ++ ; }
	void Increment_ProviderOperation_Rollback () { m_ProviderOperation_Rollback ++ ; }
	void Increment_ProviderOperation_Commit () { m_ProviderOperation_Commit ++ ; }
	void Increment_ProviderOperation_QueryState () { m_ProviderOperation_QueryState ++ ; }

	void Increment_ProviderOperation_QueryInstances () { m_ProviderOperation_QueryInstances ++ ; }
	void Increment_ProviderOperation_CreateRefresher () { m_ProviderOperation_CreateRefresher ++ ; }
	void Increment_ProviderOperation_CreateRefreshableObject () { m_ProviderOperation_CreateRefreshableObject ++ ; }
	void Increment_ProviderOperation_StopRefreshing () { m_ProviderOperation_StopRefreshing ++ ; }
	void Increment_ProviderOperation_CreateRefreshableEnum () { m_ProviderOperation_CreateRefreshableEnum ++ ; }
	void Increment_ProviderOperation_GetObjects () { m_ProviderOperation_GetObjects ++ ; }

	void Increment_ProviderOperation_GetProperty () { m_ProviderOperation_GetProperty ++ ; }
	void Increment_ProviderOperation_PutProperty () { m_ProviderOperation_PutProperty ++ ; }

	void Increment_ProviderOperation_ProvideEvents () { m_ProviderOperation_ProvideEvents ++ ; }
	void Increment_ProviderOperation_NewQuery () { m_ProviderOperation_NewQuery ++ ; }
	void Increment_ProviderOperation_CancelQuery () { m_ProviderOperation_CancelQuery ++ ; }
	void Increment_ProviderOperation_AccessCheck () { m_ProviderOperation_AccessCheck ++ ; }
	void Increment_ProviderOperation_SetRegistrationObject () { m_ProviderOperation_SetRegistrationObject ++ ; }
	void Increment_ProviderOperation_FindConsumer () { m_ProviderOperation_FindConsumer ++ ; }
	void Increment_ProviderOperation_ValidateSubscription () { m_ProviderOperation_ValidateSubscription ++ ; }

	void Increment_ProviderOperation_OpenAsync () { m_ProviderOperation_OpenAsync ++ ; }
	void Increment_ProviderOperation_AddAsync () { m_ProviderOperation_AddAsync ++ ; }
	void Increment_ProviderOperation_RemoveAsync () { m_ProviderOperation_RemoveAsync ++ ; }
	void Increment_ProviderOperation_RefreshObjectAsync () { m_ProviderOperation_RefreshObjectAsync ++ ; }
	void Increment_ProviderOperation_RenameObjectAsync () { m_ProviderOperation_RenameObjectAsync ++ ; }
	void Increment_ProviderOperation_DeleteObjectAsync () { m_ProviderOperation_DeleteObjectAsync ++ ; }
	void Increment_ProviderOperation_PutObjectAsync () { m_ProviderOperation_PutObjectAsync ++ ; }

	UINT64 Get_ProviderOperation_GetObjectAsync () { return m_ProviderOperation_GetObjectAsync ; }
	UINT64 Get_ProviderOperation_PutClassAsync () { return m_ProviderOperation_PutClassAsync ; }
	UINT64 Get_ProviderOperation_DeleteClassAsync () { return m_ProviderOperation_DeleteClassAsync ; }
	UINT64 Get_ProviderOperation_CreateClassEnumAsync () { return m_ProviderOperation_CreateClassEnumAsync ; }
	UINT64 Get_ProviderOperation_PutInstanceAsync () { return m_ProviderOperation_PutInstanceAsync ; }
	UINT64 Get_ProviderOperation_DeleteInstanceAsync () { return m_ProviderOperation_DeleteInstanceAsync ; }
	UINT64 Get_ProviderOperation_CreateInstanceEnumAsync () { return m_ProviderOperation_CreateInstanceEnumAsync ; }
	UINT64 Get_ProviderOperation_ExecQueryAsync () { return m_ProviderOperation_ExecQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecNotificationQueryAsync () { return m_ProviderOperation_ExecNotificationQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecMethodAsync () { return m_ProviderOperation_ExecMethodAsync ; }

	UINT64 Get_ProviderOperation_Begin () { return m_ProviderOperation_Begin ; }
	UINT64 Get_ProviderOperation_Rollback () { return m_ProviderOperation_Rollback ; }
	UINT64 Get_ProviderOperation_Commit () { return m_ProviderOperation_Commit ; }
	UINT64 Get_ProviderOperation_QueryState () { return m_ProviderOperation_QueryState ; }

	UINT64 Get_ProviderOperation_QueryInstances () { return m_ProviderOperation_QueryInstances ; }
	UINT64 Get_ProviderOperation_CreateRefresher () { return m_ProviderOperation_CreateRefresher ; }
	UINT64 Get_ProviderOperation_CreateRefreshableObject () { return m_ProviderOperation_CreateRefreshableObject ; }
	UINT64 Get_ProviderOperation_StopRefreshing () { return m_ProviderOperation_StopRefreshing ; }
	UINT64 Get_ProviderOperation_CreateRefreshableEnum () { return m_ProviderOperation_CreateRefreshableEnum ; }
	UINT64 Get_ProviderOperation_GetObjects () { return m_ProviderOperation_GetObjects ; }

	UINT64 Get_ProviderOperation_GetProperty () { return m_ProviderOperation_GetProperty ; }
	UINT64 Get_ProviderOperation_PutProperty () { return m_ProviderOperation_PutProperty ; }

	UINT64 Get_ProviderOperation_ProvideEvents () { return m_ProviderOperation_ProvideEvents ; }
	UINT64 Get_ProviderOperation_NewQuery () { return m_ProviderOperation_NewQuery ; }
	UINT64 Get_ProviderOperation_CancelQuery () { return m_ProviderOperation_CancelQuery ; }
	UINT64 Get_ProviderOperation_AccessCheck () { return m_ProviderOperation_AccessCheck ; }
	UINT64 Get_ProviderOperation_SetRegistrationObject () { return m_ProviderOperation_SetRegistrationObject ; }
	UINT64 Get_ProviderOperation_FindConsumer () { return m_ProviderOperation_FindConsumer ; }
	UINT64 Get_ProviderOperation_ValidateSubscription () { return m_ProviderOperation_ValidateSubscription ; }

	UINT64 Get_ProviderOperation_OpenAsync () { return m_ProviderOperation_OpenAsync ; }
	UINT64 Get_ProviderOperation_AddAsync () { return m_ProviderOperation_AddAsync ; }
	UINT64 Get_ProviderOperation_RemoveAsync () { return m_ProviderOperation_RemoveAsync ; }
	UINT64 Get_ProviderOperation_RefreshObjectAsync () { return m_ProviderOperation_RefreshObjectAsync ; }
	UINT64 Get_ProviderOperation_RenameObjectAsync () { return m_ProviderOperation_RenameObjectAsync ; }
	UINT64 Get_ProviderOperation_DeleteObjectAsync () { return m_ProviderOperation_RenameObjectAsync ; }
	UINT64 Get_ProviderOperation_PutObjectAsync () { return m_ProviderOperation_PutObjectAsync ; }

private:

	HRESULT AdjustGetContext (

		IWbemContext *a_Context
	) ;

	HRESULT Helper_HiPerfGetObjectAsync (

		IWbemHiPerfProvider *a_HighPerformanceProvider ,
 		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT Helper_GetObjectAsync (

		BOOL a_IsProxy ,
 		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_PutClassAsync (

		BOOL a_IsProxy ,
		IWbemClassObject *a_Object , 
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_DeleteClassAsync (

		BOOL a_IsProxy ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_CreateClassEnumAsync (

		BOOL a_IsProxy ,
		const BSTR a_SuperClass ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_PutInstanceAsync (

		BOOL a_IsProxy ,
		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_DeleteInstanceAsync (

		BOOL a_IsProxy ,
		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

    HRESULT Helper_CreateInstanceEnumAsync (

		BOOL a_IsProxy ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service
	) ;

	HRESULT Helper_QueryInstancesAsync (

		IWbemHiPerfProvider *a_PerformanceProvider ,
 		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;

	HRESULT Helper_ExecQueryAsync (

		BOOL a_IsProxy ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query, 
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_ExecMethodAsync (

		BOOL a_IsProxy ,
		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

public:

	CInterceptor_IWbemSyncProvider ( 

		WmiAllocator &a_Allocator ,
		IUnknown *a_ClientSideUnknown , 
		IUnknown *a_ServerSideUnknown , 
		IWbemServices *a_CoreStub ,
		CWbemGlobal_IWbemSyncProviderController *a_Controller ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		GUID &a_Guid 
	) ;

    ~CInterceptor_IWbemSyncProvider () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;


	/* IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE GetProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE PutProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderIdentity */

	HRESULT STDMETHODCALLTYPE SetRegistrationObject (

		long a_Flags ,
		IWbemClassObject *a_ProviderRegistration
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);


	/* IWbemHiPerfProvider */

	HRESULT STDMETHODCALLTYPE QueryInstances (

		IWbemServices *a_Namespace ,
		WCHAR *a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE CreateRefresher (

		IWbemServices *a_Namespace ,
		long a_Flags ,
		IWbemRefresher **a_Refresher
	) ; 

	HRESULT STDMETHODCALLTYPE CreateRefreshableObject (

		IWbemServices *a_Namespace ,
		IWbemObjectAccess *a_Template ,
		IWbemRefresher *a_Refresher ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectAccess **a_Refreshable ,
		long *a_Id
	) ;

	HRESULT STDMETHODCALLTYPE StopRefreshing (

		IWbemRefresher *a_Refresher ,
		long a_Id ,
		long a_Flags
	) ;

	HRESULT STDMETHODCALLTYPE CreateRefreshableEnum (

		IWbemServices *a_Namespace ,
		LPCWSTR a_Class ,
		IWbemRefresher *a_Refresher ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemHiPerfEnum *a_HiPerfEnum ,
		long *a_Id
	) ;

	HRESULT STDMETHODCALLTYPE GetObjects (

		IWbemServices *a_Namespace ,
		long a_ObjectCount ,
		IWbemObjectAccess **a_Objects ,
		long a_Flags ,
		IWbemContext *a_Context
	) ;

	HRESULT STDMETHODCALLTYPE Initialize (LPWSTR a_User ,
					     LONG a_Flags ,
					     LPWSTR a_Namespace ,
					     LPWSTR a_Locale ,
					     IWbemServices *a_Service ,
					     IWbemContext *a_Context ,
					     IWbemProviderInitSink *a_Sink) ;

	HRESULT STDMETHODCALLTYPE WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout ) ;

	HRESULT STDMETHODCALLTYPE GetInitializeResult () 
	{
		return m_InitializeResult ;
	}

	HRESULT STDMETHODCALLTYPE IsPerUserInitialization ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsPerLocaleInitialization ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupled_IWbemUnboundObjectSink :		public IWbemUnboundObjectSink ,
												public IWbemShutdown , 
												public VoidPointerContainerElement
{
private:

	WmiAllocator &m_Allocator ;
	CServerObject_ProviderRegistrationV1 *m_Registration ;

	_IWmiProviderAbnormalShutdown *m_Controller ;

	IUnknown *m_Unknown ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;
	Internal_IWbemUnboundObjectSink *m_Provider_Internal_IWbemUnboundObjectSink ;

	ProxyContainer m_ProxyContainer ;

	DWORD m_ProcessIdentifier ;

	HRESULT m_InitializeResult ;

protected:

	HRESULT Begin_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

public:

	CDecoupled_IWbemUnboundObjectSink (

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideProvider , 
		CWbemGlobal_IWmiObjectSinkController *a_Controller , 
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	~CDecoupled_IWbemUnboundObjectSink () ;

	HRESULT Initialize () ;

public:

	STDMETHODIMP QueryInterface ( 

		REFIID iid , 
		LPVOID FAR *iplpv 
	) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemDecoupledProvider :	public IWbemServices , 
											public IWbemPropertyProvider ,
											public IWbemEventProvider ,
											public IWbemEventProviderQuerySink ,
											public IWbemEventProviderSecurity ,
											public IWbemProviderInit ,
											public IWbemProviderIdentity ,
											public IWbemEventConsumerProviderEx ,
											public IWbemUnboundObjectSink ,

											public IWbemShutdown , 
											public _IWmiProviderInitialize ,
											public _IWmiProviderAbnormalShutdown ,
											public SyncProviderContainerElement ,
											public CWbemGlobal_IWmiObjectSinkController 
{
private:

	IUnknown *m_Unknown ;
	IWbemServices *m_Provider_IWbemServices ;
	IWbemPropertyProvider *m_Provider_IWbemPropertyProvider ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemEventConsumerProviderEx *m_Provider_IWbemEventConsumerProviderEx ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;
	IWbemProviderInit *m_Provider_IWbemProviderInit ;
	IWbemProviderIdentity *m_Provider_IWbemProviderIdentity ;

	Internal_IWbemServices *m_Provider_Internal_IWbemServices ;
	Internal_IWbemPropertyProvider *m_Provider_Internal_IWbemPropertyProvider ;
	Internal_IWbemEventProvider *m_Provider_Internal_IWbemEventProvider ;
	Internal_IWbemEventProviderQuerySink *m_Provider_Internal_IWbemEventProviderQuerySink ;
	Internal_IWbemEventProviderSecurity *m_Provider_Internal_IWbemEventProviderSecurity ;
	Internal_IWbemEventConsumerProvider *m_Provider_Internal_IWbemEventConsumerProvider ;
	Internal_IWbemEventConsumerProviderEx *m_Provider_Internal_IWbemEventConsumerProviderEx ;
	Internal_IWbemUnboundObjectSink *m_Provider_Internal_IWbemUnboundObjectSink ;
	Internal_IWmiProviderConfiguration *m_Provider_Internal_IWmiProviderConfiguration ;
	Internal_IWbemProviderInit *m_Provider_Internal_IWbemProviderInit ;
	Internal_IWbemProviderIdentity *m_Provider_Internal_IWbemProviderIdentity ;

	IWbemServices *m_CoreStub ;

	IWbemClassObject *m_ExtendedStatusObject ;

	WmiAllocator &m_Allocator ;

	ProxyContainer m_ProxyContainer ;

	LONG m_Initialized ;
	HRESULT m_InitializeResult ;
	HANDLE m_InitializedEvent ;
	IWbemContext *m_InitializationContext ;

	DWORD m_ProcessIdentifier ;

	HRESULT Begin_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

public:

	HRESULT SetInitialized ( HRESULT a_InitializeResult ) ;

public:

	CServerObject_ProviderRegistrationV1 *m_Registration ;
	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Namespace ;
	BSTR m_TransactionIdentifier ;

	UINT64 m_ProviderOperation_GetObjectAsync ;
	UINT64 m_ProviderOperation_PutClassAsync ;
	UINT64 m_ProviderOperation_DeleteClassAsync ;
	UINT64 m_ProviderOperation_CreateClassEnumAsync ;
	UINT64 m_ProviderOperation_PutInstanceAsync ;
	UINT64 m_ProviderOperation_DeleteInstanceAsync ;
	UINT64 m_ProviderOperation_CreateInstanceEnumAsync ;
	UINT64 m_ProviderOperation_ExecQueryAsync ;
	UINT64 m_ProviderOperation_ExecNotificationQueryAsync ;
	UINT64 m_ProviderOperation_ExecMethodAsync ;

	UINT64 m_ProviderOperation_Begin ;
	UINT64 m_ProviderOperation_Rollback ;
	UINT64 m_ProviderOperation_Commit ;
	UINT64 m_ProviderOperation_QueryState ;

	UINT64 m_ProviderOperation_QueryInstances ;
	UINT64 m_ProviderOperation_CreateRefresher ;
	UINT64 m_ProviderOperation_CreateRefreshableObject ;
	UINT64 m_ProviderOperation_StopRefreshing ;
	UINT64 m_ProviderOperation_CreateRefreshableEnum ;
	UINT64 m_ProviderOperation_GetObjects ;

	UINT64 m_ProviderOperation_GetProperty ;
	UINT64 m_ProviderOperation_PutProperty ;

	UINT64 m_ProviderOperation_ProvideEvents ;
	UINT64 m_ProviderOperation_NewQuery ;
	UINT64 m_ProviderOperation_CancelQuery ;
	UINT64 m_ProviderOperation_AccessCheck ;
	UINT64 m_ProviderOperation_SetRegistrationObject ;
	UINT64 m_ProviderOperation_FindConsumer ;
	UINT64 m_ProviderOperation_ValidateSubscription ;

	void Increment_ProviderOperation_GetObjectAsync () { m_ProviderOperation_GetObjectAsync ++ ; }
 	void Increment_ProviderOperation_PutClassAsync () { m_ProviderOperation_PutClassAsync ++ ; }
	void Increment_ProviderOperation_DeleteClassAsync () { m_ProviderOperation_DeleteClassAsync ++ ; }
	void Increment_ProviderOperation_CreateClassEnumAsync () { m_ProviderOperation_CreateClassEnumAsync ++ ; }
	void Increment_ProviderOperation_PutInstanceAsync () { m_ProviderOperation_PutInstanceAsync ++ ; }
	void Increment_ProviderOperation_DeleteInstanceAsync () { m_ProviderOperation_DeleteInstanceAsync ++ ; }
	void Increment_ProviderOperation_CreateInstanceEnumAsync () { m_ProviderOperation_CreateInstanceEnumAsync ++ ; }
	void Increment_ProviderOperation_ExecQueryAsync () { m_ProviderOperation_ExecQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecNotificationQueryAsync () { m_ProviderOperation_ExecNotificationQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecMethodAsync () { m_ProviderOperation_ExecMethodAsync ++ ; }

	void Increment_ProviderOperation_Begin () { m_ProviderOperation_Begin ++ ; }
	void Increment_ProviderOperation_Rollback () { m_ProviderOperation_Rollback ++ ; }
	void Increment_ProviderOperation_Commit () { m_ProviderOperation_Commit ++ ; }
	void Increment_ProviderOperation_QueryState () { m_ProviderOperation_QueryState ++ ; }

	void Increment_ProviderOperation_QueryInstances () { m_ProviderOperation_QueryInstances ++ ; }
	void Increment_ProviderOperation_CreateRefresher () { m_ProviderOperation_CreateRefresher ++ ; }
	void Increment_ProviderOperation_CreateRefreshableObject () { m_ProviderOperation_CreateRefreshableObject ++ ; }
	void Increment_ProviderOperation_StopRefreshing () { m_ProviderOperation_StopRefreshing ++ ; }
	void Increment_ProviderOperation_CreateRefreshableEnum () { m_ProviderOperation_CreateRefreshableEnum ++ ; }
	void Increment_ProviderOperation_GetObjects () { m_ProviderOperation_GetObjects ++ ; }

	void Increment_ProviderOperation_GetProperty () { m_ProviderOperation_GetProperty ++ ; }
	void Increment_ProviderOperation_PutProperty () { m_ProviderOperation_PutProperty ++ ; }

	void Increment_ProviderOperation_ProvideEvents () { m_ProviderOperation_ProvideEvents ++ ; }
	void Increment_ProviderOperation_NewQuery () { m_ProviderOperation_NewQuery ++ ; }
	void Increment_ProviderOperation_CancelQuery () { m_ProviderOperation_CancelQuery ++ ; }
	void Increment_ProviderOperation_AccessCheck () { m_ProviderOperation_AccessCheck ++ ; }
	void Increment_ProviderOperation_SetRegistrationObject () { m_ProviderOperation_SetRegistrationObject ++ ; }
	void Increment_ProviderOperation_FindConsumer () { m_ProviderOperation_FindConsumer ++ ; }
	void Increment_ProviderOperation_ValidateSubscription () { m_ProviderOperation_ValidateSubscription ++ ; }

	UINT64 Get_ProviderOperation_GetObjectAsync () { return m_ProviderOperation_GetObjectAsync ; }
	UINT64 Get_ProviderOperation_PutClassAsync () { return m_ProviderOperation_PutClassAsync ; }
	UINT64 Get_ProviderOperation_DeleteClassAsync () { return m_ProviderOperation_DeleteClassAsync ; }
	UINT64 Get_ProviderOperation_CreateClassEnumAsync () { return m_ProviderOperation_CreateClassEnumAsync ; }
	UINT64 Get_ProviderOperation_PutInstanceAsync () { return m_ProviderOperation_PutInstanceAsync ; }
	UINT64 Get_ProviderOperation_DeleteInstanceAsync () { return m_ProviderOperation_DeleteInstanceAsync ; }
	UINT64 Get_ProviderOperation_CreateInstanceEnumAsync () { return m_ProviderOperation_CreateInstanceEnumAsync ; }
	UINT64 Get_ProviderOperation_ExecQueryAsync () { return m_ProviderOperation_ExecQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecNotificationQueryAsync () { return m_ProviderOperation_ExecNotificationQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecMethodAsync () { return m_ProviderOperation_ExecMethodAsync ; }

	UINT64 Get_ProviderOperation_Begin () { return m_ProviderOperation_Begin ; }
	UINT64 Get_ProviderOperation_Rollback () { return m_ProviderOperation_Rollback ; }
	UINT64 Get_ProviderOperation_Commit () { return m_ProviderOperation_Commit ; }
	UINT64 Get_ProviderOperation_QueryState () { return m_ProviderOperation_QueryState ; }

	UINT64 Get_ProviderOperation_QueryInstances () { return m_ProviderOperation_QueryInstances ; }
	UINT64 Get_ProviderOperation_CreateRefresher () { return m_ProviderOperation_CreateRefresher ; }
	UINT64 Get_ProviderOperation_CreateRefreshableObject () { return m_ProviderOperation_CreateRefreshableObject ; }
	UINT64 Get_ProviderOperation_StopRefreshing () { return m_ProviderOperation_StopRefreshing ; }
	UINT64 Get_ProviderOperation_CreateRefreshableEnum () { return m_ProviderOperation_CreateRefreshableEnum ; }
	UINT64 Get_ProviderOperation_GetObjects () { return m_ProviderOperation_GetObjects ; }

	UINT64 Get_ProviderOperation_GetProperty () { return m_ProviderOperation_GetProperty ; }
	UINT64 Get_ProviderOperation_PutProperty () { return m_ProviderOperation_PutProperty ; }

	UINT64 Get_ProviderOperation_ProvideEvents () { return m_ProviderOperation_ProvideEvents ; }
	UINT64 Get_ProviderOperation_NewQuery () { return m_ProviderOperation_NewQuery ; }
	UINT64 Get_ProviderOperation_CancelQuery () { return m_ProviderOperation_CancelQuery ; }
	UINT64 Get_ProviderOperation_AccessCheck () { return m_ProviderOperation_AccessCheck ; }
	UINT64 Get_ProviderOperation_SetRegistrationObject () { return m_ProviderOperation_SetRegistrationObject ; }
	UINT64 Get_ProviderOperation_FindConsumer () { return m_ProviderOperation_FindConsumer ; }
	UINT64 Get_ProviderOperation_ValidateSubscription () { return m_ProviderOperation_ValidateSubscription ; }

public:

	CInterceptor_IWbemDecoupledProvider ( 

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideUnknown , 
		IWbemServices *a_CoreStub ,
		CWbemGlobal_IWbemSyncProviderController *a_Controller ,
		IWbemContext *a_InitializationContext ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		GUID &a_Guid 
	) ;

    ~CInterceptor_IWbemDecoupledProvider () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE GetProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE PutProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderIdentity */

	HRESULT STDMETHODCALLTYPE SetRegistrationObject (

		long a_Flags ,
		IWbemClassObject *a_ProviderRegistration
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	/* IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_CoreService ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;
    
	HRESULT STDMETHODCALLTYPE Initialize (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Namespace ,
		IWbemServices *a_Repository ,
		IWbemServices *a_Service ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout ) ;

	HRESULT STDMETHODCALLTYPE GetInitializeResult () 
	{
		return m_InitializeResult ;
	}

	HRESULT STDMETHODCALLTYPE GetHosting ( ULONG *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE GetHostingGroup ( BSTR *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsInternal ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsPerUserInitialization ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsPerLocaleInitialization ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE AbnormalShutdown () ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;
#endif // _Server_Interceptor_IWbemServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provwsvs.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _Server_Interceptor_IWbemServices_Stub_H
#define _Server_Interceptor_IWbemServices_Stub_H

#define ProxyIndex_Stub_IWbemServices					0
#define ProxyIndex_Stub_IWbemServicesEx					1
#define ProxyIndex_Stub_IWbemRefreshingServices			2

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemServices_Stub : public IWbemServices,
					public IWbemRefreshingServices ,
					public IWbemShutdown
{
private:

	LONG m_ReferenceCount ;         //Object reference count

	LONG m_GateClosed ;
	LONG m_InProgress ;

	CriticalSection m_CriticalSection ;

	WmiAllocator &m_Allocator ;

	IWbemServices *m_CoreService ;
	IWbemRefreshingServices *m_RefreshingService ;

	ProxyContainer m_ProxyContainer ;

public:

	CInterceptor_IWbemServices_Stub ( WmiAllocator &a_Allocator , IWbemServices *a_Service ) ;
    ~CInterceptor_IWbemServices_Stub () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE AddObjectToRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Path,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddObjectToRefresherByTemplate (

		WBEM_REFRESHER_ID *a_RefresherId ,
		IWbemClassObject *a_Template ,
		long a_Flags ,
		IWbemContext *a_Context ,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddEnumToRefresher(

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE RemoveObjectFromRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Id ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT STDMETHODCALLTYPE GetRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		IWbemRemoteRefresher **a_RemoteRefresher ,
		GUID *a_Guid ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE ReconnectRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId,
		long a_Flags,
		long a_NumberOfObjects,
		DWORD a_ClientRefresherVersion ,
		WBEM_RECONNECT_INFO *a_ReconnectInformation ,
		WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;


#endif // _Server_Interceptor_IWbemServices_Stub_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\pssutils.h ===
namespace provsubsys{

template<class T>
class RefCountingTraits{
	public:
	void add_ref(T * ptr){ ptr->AddRef();};
	void release(T * ptr){ ptr->Release();};
};


template<class T, class ref_traits = RefCountingTraits<T> >
class auto_ref: private ref_traits {
	T* pointee_;

	public:
		auto_ref():pointee_(NULL) 
		{ };

		explicit auto_ref(T * _P):pointee_(_P) 
		{ 
			add_ref();
		};

		explicit auto_ref(const int):pointee_(NULL)
		{ } ;

		auto_ref(const auto_ref& _S):pointee_(_S.pointee_)
		{
			add_ref();
		};

		~auto_ref()
		{ 
			release();
		};

		bool operator==(const auto_ref& _R)
		{
			return pointee_ ==  _R.pointee_;
		};

		const auto_ref& operator=( const auto_ref& _R)
		{
			if(pointee_ ==  _R.pointee_)
				return *this;
			release();
			pointee_ =  _R.pointee_;
			add_ref();
			return *this;
		};
	

		T& operator*( ) const 
		{	
			return *pointee_;

		};

		T* operator->( ) const 
		{
			return pointee_;
		};

		operator bool( ) const throw( )
		{ 
			return pointee_ != NULL; 
		};

		void Dettach()
		{
			release();
			pointee_ = NULL;
		};

protected:
	void add_ref()
	{ 
		if( pointee_ != NULL )
			ref_traits::add_ref(pointee_);
	};

	void release()
	{ 
		if( pointee_ != NULL )
			ref_traits::release(pointee_);
	};
};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\ssdlhelper.h ===
#include "PreComp.h"
#include <locks.h>

struct SDDL
{
  typedef BOOL (*function_type)( LPCTSTR, DWORD, PSECURITY_DESCRIPTOR *, PULONG);
  function_type current_function_; 
  CriticalSection lock_;

  SDDL():lock_(false), current_function_(0){};
  
  static BOOL ConvertStringSecurityDescriptorToSecurityDescriptor( LPCTSTR, DWORD, PSECURITY_DESCRIPTOR *, PULONG);
  static BOOL DummyConvertStringSecurityDescriptorToSecurityDescriptor( LPCTSTR, DWORD, PSECURITY_DESCRIPTOR *, PULONG);
  function_type GetFunction(void);
  static bool hasSDDLSupport();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\strutils.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    STRUTILS.H

Abstract:

	String utilities

History:

--*/

#ifndef __WBEM_STRING_UTILS__H_
#define __WBEM_STRING_UTILS__H_

#pragma optimize("gt", on)

#include "os.h"
#ifdef _DBG
#define _DBG_BREAK DebugBreak();
#else
#define _DBG_BREAK
#endif

inline wchar_t ToLower(wchar_t c)
{
	return OS::ToLower(c);
}

inline wchar_t ToUpper(wchar_t c)
{
    return OS::ToUpper(c);
 
}

inline wchar_t wbem_towlower(wchar_t c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'A' && c <= 'Z')
            return c + ('a' - 'A');
        else
            return c;
    }
    else return ToLower(c);
}

inline wchar_t wbem_towupper(wchar_t c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'a' && c <= 'z')
            return c + ('A' - 'a');
        else
            return c;
    }
    else return ToUpper(c);
}

inline int wbem_wcsicmp( const wchar_t* wsz1, const wchar_t* wsz2)
{
    while(*wsz1 || *wsz2)
    {
        int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

inline int wbem_unaligned_wcsicmp( UNALIGNED const wchar_t* wsz1, UNALIGNED const wchar_t* wsz2)
{
    while(*wsz1 || *wsz2)
    {
        int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

// just like wcsicmp, but first 0 of unicode chracters have been omitted
inline int wbem_ncsicmp(const char* wsz1, const char* wsz2)
{
    while(*wsz1 || *wsz2)
    {
        int diff = wbem_towlower((unsigned char)*wsz1) - 
                    wbem_towlower((unsigned char)*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

inline int wbem_wcsnicmp( const wchar_t* wsz1, const wchar_t* wsz2, size_t n )
{
    while(n-- && (*wsz1 || *wsz2))
    {
        int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

inline int wbem_unaligned_wcsnicmp( UNALIGNED const wchar_t* wsz1, UNALIGNED const wchar_t* wsz2, size_t n )
{
    while(n-- && (*wsz1 || *wsz2))
    {
        int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

inline int wbem_stricmp(const char* sz1, const char* sz2)
{
    while(*sz1 || *sz2)
    {
        int diff = wbem_towlower(*sz1) - wbem_towlower(*sz2);
        if(diff) return diff;
        sz1++; sz2++;
    }

    return 0;
}

inline int wbem_strnicmp(const char* sz1, const char* sz2, size_t n)
{
    while(n-- && (*sz1 || *sz2))
    {
        int diff = wbem_towlower(*sz1) - wbem_towlower(*sz2);
        if(diff) return diff;
        sz1++; sz2++;
    }

    return 0;
}

inline bool wbem_iswdigit(wchar_t c)
{
    return OS::wbem_iswdigit(c);
};

inline bool wbem_iswalnum (wchar_t c)
{
    return OS::wbem_iswalnum(c);
};


//
// returns the real length or Max + 1 if it exceeds
// useful for not probing the entire string to see that it's too big
//
/////////////////////////////////////////
inline size_t wcslen_max(WCHAR * p, size_t Max)
{
	WCHAR * pBegin = p;
	WCHAR * pTail = p + Max + 1;
	while (*p && (p < pTail)) p++;
        return p-pBegin;
};

#pragma optimize("", on)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\classfac.cpp ===
#ifndef __CLASSFACTORY_CPP
#define __CLASSFACTORY_CPP

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ClassFac.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "classfac.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
CServerClassFactory <Object,ObjectInterface> :: CServerClassFactory <Object,ObjectInterface> () : m_ReferenceCount ( 0 )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
CServerClassFactory <Object,ObjectInterface> :: ~CServerClassFactory <Object,ObjectInterface> ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CServerClassFactory <Object,ObjectInterface> :: QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	else if ( a_Riid == IID_IClassFactory )
	{
		*a_Void = ( LPVOID ) ( IClassFactory * ) this ;		
	}	

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP_( ULONG ) CServerClassFactory <Object,ObjectInterface> :: AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP_(ULONG) CServerClassFactory <Object,ObjectInterface> :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CServerClassFactory <Object,ObjectInterface> :: CreateInstance (

	LPUNKNOWN a_UnknownOuter ,
	REFIID a_Riid ,
	LPVOID *a_Object
)
{
	HRESULT t_Result = S_OK ;

	if ( a_UnknownOuter )
	{
		t_Result = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		ObjectInterface *t_Unknown = ( ObjectInterface * ) new Object ( *DecoupledProviderSubSystem_Globals :: s_Allocator );
		if ( t_Unknown == NULL )
		{
			t_Result = E_OUTOFMEMORY ;
		}
		else
		{
			t_Result = t_Unknown->Initialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Unknown->QueryInterface ( a_Riid , a_Object ) ;
				if ( FAILED ( t_Result ) )
				{
					delete t_Unknown ;
				}
			}
			else
			{
				delete t_Unknown ;
			}
		}			
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CServerClassFactory <Object,ObjectInterface> :: LockServer ( BOOL fLock )
{
/* 
 * Place code in critical section
 */

	if ( fLock )
	{
		InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_LocksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_LocksInProgress ) ;
	}

	return S_OK	;
}

#endif __CLASSFACTORY_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\globals.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <windows.h>
#include <objbase.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemcli.h>
#include <wbemint.h>
#include <cominit.h>

#include <wbemcli.h>
#include <wbemint.h>
#include <winntsec.h>
#include <wbemcomn.h>
#include <callsec.h>
#include <cominit.h>

#include <Guids.h>

#include <BasicTree.h>
#include <Thread.h>
#include <Logging.h>

#include "CGlobals.h"
#include "Globals.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiAllocator *DecoupledProviderSubSystem_Globals :: s_Allocator = NULL ;

LONG DecoupledProviderSubSystem_Globals :: s_LocksInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress = 0 ;

LONG DecoupledProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderRegistrar_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderEvents_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_DecoupledClient_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CDecoupled_IWbemSyncObjectSink_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CDecoupled_Batching_IWbemSyncObjectSink_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledUnboundObjectSink_ObjectsInProgress = 0 ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: AdjustSecurityDescriptorWithSystemSid ( 

	SECURITY_DESCRIPTOR *&a_SecurityDescriptor , 
	SECURITY_DESCRIPTOR *&a_AlteredSecurityDescriptor
)
{
	HRESULT t_Result = S_OK ;

	SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;

	PACL t_Dacl = NULL ;
	PACL t_Sacl = NULL ;
	PSID t_Owner = NULL ;
	PSID t_PrimaryGroup = NULL ;
	SECURITY_DESCRIPTOR *t_AlteredSecurityDescriptor = NULL ;

	DWORD t_AlteredSecurityDescriptorSize = sizeof ( SECURITY_DESCRIPTOR ) ;
	DWORD t_DaclSize = 0 ;
	DWORD t_SaclSize = 0 ;
	DWORD t_OwnerSize = 0 ;
	DWORD t_PrimaryGroupSize = 0 ;

	BOOL t_Status = MakeAbsoluteSD (

		a_SecurityDescriptor ,
		t_AlteredSecurityDescriptor ,
		& t_AlteredSecurityDescriptorSize ,
		t_Dacl,
		& t_DaclSize,
		t_Sacl,
		& t_SaclSize,
		t_Owner,
		& t_OwnerSize,
		t_PrimaryGroup,
		& t_PrimaryGroupSize
	) ;

	if ( ( t_Status == FALSE ) && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
	{
		t_Dacl = ( PACL ) new BYTE [ t_DaclSize ] ;
		t_Sacl = ( PACL ) new BYTE [ t_SaclSize ] ;
		t_Owner = ( PSID ) new BYTE [ t_OwnerSize ] ;
		t_PrimaryGroup = ( PSID ) new BYTE [ t_PrimaryGroupSize ] ;

		t_AlteredSecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_AlteredSecurityDescriptorSize ] ;

		if ( t_AlteredSecurityDescriptor && t_Dacl && t_Sacl && t_Owner && t_PrimaryGroup )
		{
			BOOL t_Status = InitializeSecurityDescriptor ( t_AlteredSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
			if ( t_Status )
			{
				t_Status = MakeAbsoluteSD (

					a_SecurityDescriptor ,
					t_AlteredSecurityDescriptor ,
					& t_AlteredSecurityDescriptorSize ,
					t_Dacl,
					& t_DaclSize,
					t_Sacl,
					& t_SaclSize,
					t_Owner,
					& t_OwnerSize,
					t_PrimaryGroup,
					& t_PrimaryGroupSize
				) ;

				if ( t_Status )
				{
					t_SecurityDescriptor = t_AlteredSecurityDescriptor ;
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	PACL t_ExtraDacl = NULL ;

	if ( SUCCEEDED ( t_Result ) )
	{
		ACL_SIZE_INFORMATION t_Size ;

		if ( t_Dacl )
		{
			BOOL t_Status = GetAclInformation (

				t_Dacl ,
				& t_Size ,
				sizeof ( t_Size ) ,
				AclSizeInformation
			);

			if ( t_Status )
			{
				DWORD t_ExtraSize = t_Size.AclBytesInUse + t_Size.AclBytesFree + ProviderSubSystem_Common_Globals :: s_System_ACESize ;

				t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
				if ( t_ExtraDacl )
				{
					CopyMemory ( t_ExtraDacl , t_Dacl , t_Size.AclBytesInUse + t_Size.AclBytesFree ) ;
					t_ExtraDacl->AclSize = t_ExtraSize ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			DWORD t_AceIndex = 0 ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( ProviderSubSystem_Common_Globals :: s_System_ACESize && :: AddAce ( t_ExtraDacl , ACL_REVISION , t_AceIndex , ProviderSubSystem_Common_Globals :: s_Token_All_Access_System_ACE , ProviderSubSystem_Common_Globals :: s_System_ACESize ) )
				{
					t_AceIndex ++ ;
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}

			t_Status = SetSecurityDescriptorDacl (

				  t_SecurityDescriptor ,
				  TRUE ,
				  t_ExtraDacl ,
				  FALSE 
			) ;

			if ( ! t_Status )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			DWORD t_FinalLength = 0 ;

			t_Status = MakeSelfRelativeSD (

				t_SecurityDescriptor ,
				a_AlteredSecurityDescriptor ,
				& t_FinalLength 
			) ;

			if ( t_Status == FALSE && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
			{
				a_AlteredSecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_FinalLength ] ;
				if ( a_AlteredSecurityDescriptor )
				{
					t_Status = MakeSelfRelativeSD (

						t_SecurityDescriptor ,
						a_AlteredSecurityDescriptor ,
						& t_FinalLength 
					) ;

					if ( t_Status == FALSE )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;									
				}
			}
		}

		delete [] t_ExtraDacl ;
	}

	delete [] ( BYTE * ) t_Dacl ;
	delete [] ( BYTE * ) t_Sacl ;
	delete [] ( BYTE * ) t_Owner ;
	delete [] ( BYTE * ) t_PrimaryGroup ;
	delete [] ( BYTE * ) t_AlteredSecurityDescriptor ;

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: OpenTokenToSystem ()
{
	HANDLE t_ProcessToken ;
	
	BOOL t_Status = OpenProcessToken (

		GetCurrentProcess () ,
		TOKEN_QUERY | WRITE_DAC | READ_CONTROL ,
		& t_ProcessToken
	) ;

	if ( t_Status )
	{
		HRESULT t_Result = S_OK ;

		SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;

		DWORD t_LengthRequested = 0 ;
		DWORD t_LengthReturned = 0 ;

		t_Status = GetKernelObjectSecurity (

			t_ProcessToken ,
			DACL_SECURITY_INFORMATION ,
			& t_SecurityDescriptor ,
			t_LengthRequested ,
			& t_LengthReturned
		) ;

		if ( ( t_Status == FALSE ) && ( GetLastError () == ERROR_INSUFFICIENT_BUFFER ) )
		{
			t_SecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_LengthReturned ] ;
			if ( t_SecurityDescriptor )
			{
				t_LengthRequested = t_LengthReturned ;

				t_Status = GetKernelObjectSecurity (

					t_ProcessToken ,
					DACL_SECURITY_INFORMATION ,
					t_SecurityDescriptor ,
					t_LengthRequested ,
					& t_LengthReturned
				) ;

				if ( t_LengthRequested != t_LengthReturned )
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			SECURITY_DESCRIPTOR *t_AdjustedSecurityDescriptor = NULL ;

			t_Result = AdjustSecurityDescriptorWithSystemSid ( 

				t_SecurityDescriptor , 
				t_AdjustedSecurityDescriptor
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_Status = SetKernelObjectSecurity (

					t_ProcessToken ,
					DACL_SECURITY_INFORMATION ,
					t_AdjustedSecurityDescriptor
				) ;

				if ( ! t_Status )
				{
					DWORD t_LastError = GetLastError () ;
					t_Result = WBEM_E_ACCESS_DENIED ;
				}

				delete [] t_AdjustedSecurityDescriptor ;
			}
		}

		CloseHandle ( t_ProcessToken ) ;
		delete [] t_SecurityDescriptor ;

		return t_Result ;
	}
	else
	{
		return WBEM_E_ACCESS_DENIED ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: Global_Startup ()
{
	HRESULT t_Result = S_OK ;

	if ( ! s_Allocator )
	{
/*
 *	Use the global process heap for this particular boot operation
 */

		WmiAllocator t_Allocator ;
		WmiStatusCode t_StatusCode = t_Allocator.New (

			( void ** ) & s_Allocator ,
			sizeof ( WmiAllocator ) 
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			:: new ( ( void * ) s_Allocator ) WmiAllocator ;

			t_StatusCode = s_Allocator->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_Initialize ( *s_Allocator ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ProviderSubSystem_Common_Globals :: CreateSystemAces () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: Global_Shutdown ()
{
	HRESULT t_Result = ProviderSubSystem_Common_Globals :: DeleteSystemAces () ;

	WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_UnInitialize ( *s_Allocator ) ;

	if ( s_Allocator )
	{
/*
 *	Use the global process heap for this particular boot operation
 */

		WmiAllocator t_Allocator ;
		WmiStatusCode t_StatusCode = t_Allocator.Delete (

			( void * ) s_Allocator
		) ;

		if ( t_StatusCode != e_StatusCode_Success )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void * __cdecl operator new ( size_t a_Size )
{
    void *t_Ptr ;
	WmiStatusCode t_StatusCode = DecoupledProviderSubSystem_Globals :: s_Allocator->New (

		( void ** ) & t_Ptr ,
		a_Size
	) ;

	if ( t_StatusCode != e_StatusCode_Success )
    {
        throw Wmi_Heap_Exception (

			Wmi_Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR
		) ;
    }

    return t_Ptr ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void __cdecl operator delete ( void *a_Ptr )
{
    if ( a_Ptr )
    {
		WmiStatusCode t_StatusCode = DecoupledProviderSubSystem_Globals :: s_Allocator->Delete (

			( void * ) a_Ptr
		) ;
    }
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: BeginThreadImpersonation (

	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	HRESULT t_Result = S_OK ;

	IServerSecurity *t_ServerSecurity = NULL ;

	t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & a_OldContext ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			a_Impersonating = t_ServerSecurity->IsImpersonating () ;
		}
		else
		{
			a_Impersonating = FALSE ;
		}
	}

	CWbemCallSecurity *t_CallSecurity = CWbemCallSecurity :: New () ;
	if ( t_CallSecurity )
	{
		t_CallSecurity->AddRef () ;

		_IWmiThreadSecHandle *t_ThreadSecurity = NULL ;
		t_Result = t_CallSecurity->GetThreadSecurity ( ( WMI_THREAD_SECURITY_ORIGIN ) ( WMI_ORIGIN_THREAD ) , & t_ThreadSecurity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_CallSecurity->SetThreadSecurity ( t_ThreadSecurity ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_CallSecurity->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_Impersonating )
					{
						HRESULT t_TempResult = t_ServerSecurity->RevertToSelf () ;
#if DBG
	if ( FAILED ( t_TempResult ) )
	{
		DebugBreak () ;
	}
#endif

					}
				}				
			}

			t_ThreadSecurity->Release () ;
		}

		t_CallSecurity->Release () ;
	}

	if ( t_ServerSecurity )
	{
		t_ServerSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: EndThreadImpersonation (

	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_Impersonating

)
{
	HRESULT t_Result = S_OK ;

	IUnknown *t_NewContext = NULL ;

	t_Result = CoSwitchCallContext ( a_OldContext , & t_NewContext ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_OldContext )
		{
			if ( a_Impersonating )
			{
				IServerSecurity *t_ServerSecurity = NULL ;
				t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_ServerSecurity->ImpersonateClient () ;

					t_ServerSecurity->Release () ;
				}
			}
		}

		if ( a_OldSecurity )
		{
			a_OldSecurity->Release() ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

/* 
 * CoGetCallContext AddReffed this thing so now we have to release it.
 */

	if ( a_OldContext )
	{ 
        a_OldContext->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

	WmiInternalContext a_InternalContext ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity
)
{
	HRESULT t_Result = WBEM_E_INVALID_PARAMETER ;

	if ( a_InternalContext.m_IdentifyHandle )
	{
		HANDLE t_IdentifyToken = ( HANDLE ) a_InternalContext.m_IdentifyHandle ;
		BOOL t_Status = SetThreadToken ( NULL , t_IdentifyToken ) ;
		if ( t_Status )
		{
			t_Result = BeginThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

			HRESULT t_TempResult = RevertToSelf () ;
#if DBG
	if ( FAILED ( t_TempResult ) )
	{
		DebugBreak () ;
	}
#endif

		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		CloseHandle ( t_IdentifyToken ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost (

	WmiInternalContext a_InternalContext ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	HRESULT t_Result = EndThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
#if DBG
	if ( FAILED ( t_Result ) )
	{
		DebugBreak () ;
	}
#endif

	t_Result = RevertToSelf () ;
#if DBG
	if ( FAILED ( t_Result ) )
	{
		DebugBreak () ;
	}
#endif

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

	WmiInternalContext a_InternalContext ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity
)
{
	HRESULT t_Result = WBEM_E_INVALID_PARAMETER ;

	if ( a_InternalContext.m_IdentifyHandle )
	{
		HANDLE t_IdentifyToken = NULL ;

		t_Result = CoImpersonateClient () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			HANDLE t_CallerIdentifyToken = ( HANDLE ) a_InternalContext.m_IdentifyHandle ;
			DWORD t_ProcessIdentifier = a_InternalContext.m_ProcessIdentifier ;

			HANDLE t_ProcessHandle = OpenProcess (

				PROCESS_DUP_HANDLE ,
				FALSE ,
				t_ProcessIdentifier 
			) ;

			if ( t_ProcessHandle )
			{
				BOOL t_Status = DuplicateHandle (

					t_ProcessHandle ,
					t_CallerIdentifyToken ,
					GetCurrentProcess () ,
					& t_IdentifyToken ,
					MAXIMUM_ALLOWED | TOKEN_DUPLICATE | TOKEN_IMPERSONATE ,
					TRUE ,
					0
				) ;

				if ( t_Status )
				{
				}
				else
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}
								
				CloseHandle ( t_ProcessHandle ) ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}

			HRESULT t_TempResult = CoRevertToSelf () ;
#if DBG
	if ( FAILED ( t_TempResult ) )
	{
		DebugBreak () ;
	}
#endif

		}

		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Status = SetThreadToken ( NULL , t_IdentifyToken ) ;
			if ( t_Status )
			{
				t_Result = BeginThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

				HRESULT t_TempResult = CoRevertToSelf () ;
#if DBG
	if ( FAILED ( t_TempResult ) )
	{
		DebugBreak () ;
	}
#endif

				t_TempResult = RevertToSelf () ;
#if DBG
	if ( FAILED ( t_TempResult ) )
	{
		DebugBreak () ;
	}
#endif

			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}

			CloseHandle ( t_IdentifyToken ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: End_IdentifyCall_SvcHost (

	WmiInternalContext a_InternalContext ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	HRESULT t_Result = EndThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
#if DBG
	if ( FAILED ( t_Result ) )
	{
		DebugBreak () ;
	}
#endif

	t_Result = RevertToSelf () ;
#if DBG
	if ( FAILED ( t_Result ) )
	{
		DebugBreak () ;
	}
#endif

	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\maindll.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	MainDll.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <comdef.h>
#include <stdio.h>

#include "Globals.h"
#include "ClassFac.h"
#include "Guids.h"
#include "ProvRegistrar.h"
#include "ProvEvents.h"
#include <lockst.h>
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HINSTANCE g_ModuleInstance=NULL;

CriticalSection s_CriticalSection(NOTHROW_LOCK) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL APIENTRY DllMain (

	HINSTANCE a_ModuleInstance, 
	ULONG a_Reason , 
	LPVOID a_Reserved
)
{
	g_ModuleInstance = a_ModuleInstance ;

	BOOL t_Status = TRUE ;

    if ( DLL_PROCESS_DETACH == a_Reason )
	{
		HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Global_Shutdown () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Status = TRUE ;
		}
		else
		{
			t_Status = FALSE ;
		}

		WmiHelper :: DeleteCriticalSection ( & s_CriticalSection ) ;

		t_Status = TRUE ;
    }
    else if ( DLL_PROCESS_ATTACH == a_Reason )
	{
		WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & s_CriticalSection ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Global_Startup () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Status = TRUE ;
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}

		DisableThreadLibraryCalls ( a_ModuleInstance ) ;
    }
    else if ( DLL_THREAD_DETACH == a_Reason )
	{
		t_Status = TRUE ;
    }
    else if ( DLL_THREAD_ATTACH == a_Reason )
	{
		t_Status = TRUE ;
    }

    return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllGetClassObject (

	REFCLSID a_Clsid , 
	REFIID a_Riid , 
	void **a_Void 
)
{
	HRESULT t_Result = S_OK ; 

	if ( a_Clsid == CLSID_WbemDecoupledRegistrar ) 
	{
		CServerClassFactory <CServerObject_ProviderRegistrar,CServerObject_ProviderRegistrar> *t_Unknown = new CServerClassFactory <CServerObject_ProviderRegistrar,CServerObject_ProviderRegistrar> ;
		if ( t_Unknown == NULL )
		{
			t_Result = E_OUTOFMEMORY ;
		}
		else
		{
			t_Result = t_Unknown->QueryInterface ( a_Riid , a_Void ) ;
			if ( FAILED ( t_Result ) )
			{
				delete t_Unknown ;				
			}
			else
			{
			}			
		}
	}
	else if ( a_Clsid == CLSID_WbemDecoupledBasicEventProvider ) 
	{
		CServerClassFactory <CServerObject_ProviderEvents,CServerObject_ProviderEvents> *t_Unknown = new CServerClassFactory <CServerObject_ProviderEvents,CServerObject_ProviderEvents> ;
		if ( t_Unknown == NULL )
		{
			t_Result = E_OUTOFMEMORY ;
		}
		else
		{
			t_Result = t_Unknown->QueryInterface ( a_Riid , a_Void ) ;
			if ( FAILED ( t_Result ) )
			{
				delete t_Unknown ;				
			}
			else
			{
			}			
		}
	}
	else
	{
		t_Result = CLASS_E_CLASSNOTAVAILABLE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllCanUnloadNow ()
{

/* 
 * Place code in critical section
 */

	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & s_CriticalSection , FALSE ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		BOOL t_Unload = ( 
						DecoupledProviderSubSystem_Globals :: s_LocksInProgress || DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress 
					) ;
		t_Unload = ! t_Unload ;

		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

		return t_Unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
	}
	else
	{
		return FALSE ;
	}
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

//Strings used during self registeration


#define REG_FORMAT_STR			L"%s\\%s"
#define NOT_INSERT_STR			L"NotInsertable"
#define INPROC32_STR			L"InprocServer32"
#define LOCALSERVER32_STR		L"LocalServer32"
#define THREADING_MODULE_STR	L"ThreadingModel"
#define APARTMENT_STR			L"Both"
#define APPID_VALUE_STR			L"APPID"
#define APPID_STR				L"APPID\\"
#define CLSID_STR				L"CLSID\\"

#define WMI_PROVIDER_DECOUPLED_REGISTRAR				__TEXT("Microsoft WMI Provider Subsystem Decoupled Registrar")
#define WMI_PROVIDER_DECOUPLED_BASIC_EVENT_PROVIDER		__TEXT("Microsoft WMI Provider Subsystem Decoupled Basic Event Provider")

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL SetKeyAndValue ( wchar_t *pszKey , wchar_t *pszSubkey , wchar_t *pszValueName , wchar_t *pszValue )
{
    HKEY hKey;
    wchar_t szKey[256];

	HRESULT t_Result = StringCchCopyW ( szKey , sizeof ( szKey ) / sizeof ( wchar_t ) , pszKey ) ;
	if ( FAILED ( t_Result ) )
	{
		return FALSE ;
	}

    if ( NULL != pszSubkey )
    {
		t_Result = StringCchCatW ( szKey , sizeof ( szKey ) / sizeof ( wchar_t ) , L"\\" ) ;
		if ( FAILED ( t_Result ) )
		{
			return FALSE ;
		}

        t_Result = StringCchCatW ( szKey , sizeof ( szKey ) / sizeof ( wchar_t ) , pszSubkey ) ;
		if ( FAILED ( t_Result ) )
		{
			return FALSE ;
		}
    }

    if ( ERROR_SUCCESS != RegCreateKeyEx ( 

			HKEY_CLASSES_ROOT , 
			szKey , 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE ,
			KEY_ALL_ACCESS, 
			NULL, 
			&hKey, 
			NULL
		)
	)
	{
        return FALSE ;
	}

    if ( NULL != pszValue )
    {
        if ( ERROR_SUCCESS != RegSetValueEx (

				hKey, 
				pszValueName, 
				0, 
				REG_SZ, 
				(BYTE *) pszValue , 
				(lstrlen(pszValue)+1)*sizeof(wchar_t)
			)
		)
		{
			return FALSE;
		}
    }

    RegCloseKey ( hKey ) ;

    return TRUE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI RegisterServer ( GUID a_ProviderClassId , wchar_t *a_ProviderName )
{
	wchar_t szModule[512];
	GetModuleFileName(g_ModuleInstance,(wchar_t*)szModule, sizeof(szModule)/sizeof(wchar_t));

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	int iRet = StringFromGUID2(a_ProviderClassId,szProviderClassID, 128);

	StringCchCopyW(szProviderCLSIDClassID,sizeof(szProviderCLSIDClassID)/sizeof(wchar_t),CLSID_STR);
	StringCchCatW(szProviderCLSIDClassID,sizeof(szProviderCLSIDClassID)/sizeof(wchar_t),szProviderClassID);

		//Create entries under CLSID
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, a_ProviderName ))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INSERT_STR, NULL, NULL))
			return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

	return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI UnregisterServer( GUID a_ProviderClassId )
{
	wchar_t szTemp[128];

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	int iRet = StringFromGUID2(a_ProviderClassId ,szProviderClassID, 128);

	StringCchCopyW (szProviderCLSIDClassID,sizeof(szProviderCLSIDClassID)/sizeof(wchar_t),CLSID_STR);
	StringCchCatW (szProviderCLSIDClassID,sizeof(szProviderCLSIDClassID)/sizeof(wchar_t),szProviderClassID);

	//Delete entries under CLSID

	StringCchPrintfW(szTemp, sizeof(szTemp)/sizeof(wchar_t),REG_FORMAT_STR, szProviderCLSIDClassID, NOT_INSERT_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	StringCchPrintfW(szTemp, sizeof(szTemp)/sizeof(wchar_t),REG_FORMAT_STR,szProviderCLSIDClassID, INPROC32_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDClassID);

    return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllRegisterServer ()
{
	HRESULT t_Result ;

	t_Result = RegisterServer ( CLSID_WbemDecoupledRegistrar			,	WMI_PROVIDER_DECOUPLED_REGISTRAR ) ;
	t_Result = RegisterServer ( CLSID_WbemDecoupledBasicEventProvider	,	WMI_PROVIDER_DECOUPLED_BASIC_EVENT_PROVIDER ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllUnregisterServer ()
{
	HRESULT t_Result ;

	t_Result = UnregisterServer ( CLSID_WbemDecoupledRegistrar ) ;
	t_Result = UnregisterServer ( CLSID_WbemDecoupledBasicEventProvider ) ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Precomp.h

Abstract:


History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
#include <ntpsapi.h>
#include <ntexapi.h>

#define _WINNT_	// have what is needed from above

#include <ole2.h>
#include <windows.h>
#define COREPOL_HEADERFILE_IS_INCLUDED
#ifndef POLARITY
#if 1
#define POLARITY __declspec( dllimport )
#else
#define POLARITY 
#endif
#endif

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#define COREPROX_POLARITY __declspec( dllimport )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\include\provevt.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvWsv.H

Abstract:


History:

--*/

#ifndef _Server_EventProvider_H
#define _Server_EventProvider_H

#include "Globals.h"
#include "CGlobals.h"

class CServerObject_ProviderEvents ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CEventProvider :					public IWbemEventProvider ,
										public IWbemEventProviderQuerySink ,
										public IWbemEventProviderSecurity ,
										public IWbemProviderIdentity ,
										public IWbemEventConsumerProviderEx ,
										public IWbemProviderInit , 
										public IWbemShutdown 
{
private:

	LONG m_ReferenceCount ;

	CriticalSection m_CriticalSection ;

	IUnknown *m_Unknown ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;
	IWbemProviderIdentity *m_Provider_IWbemProviderIdentity ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemEventConsumerProviderEx *m_Provider_IWbemEventConsumerProviderEx ;

	IWbemServices *m_CoreService ;
	IUnknown *m_Provider ;
	CServerObject_ProviderEvents *m_EventRegistrar ;

public:

	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Namespace ;

private:

public:

	CEventProvider ( 

		WmiAllocator &a_Allocator ,
		CServerObject_ProviderEvents *a_EventRegistrar ,
		IUnknown *a_Unknown
	) ;

    ~CEventProvider () ;

	HRESULT Initialize () ;

	HRESULT UnRegister () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderIdentity */

	HRESULT STDMETHODCALLTYPE SetRegistrationObject (

		long a_Flags ,
		IWbemClassObject *a_ProviderRegistration
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User,
		LONG a_Flags,
		LPWSTR a_Namespace,
		LPWSTR a_Locale,
		IWbemServices *a_CoreService,         // For anybody
		IWbemContext *a_Context,
		IWbemProviderInitSink *a_Sink     // For init signals
	) ;

	// IWbemShutdown members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

#endif // _Server_EventProvider_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\provevt.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"

#include <wbemint.h>
#include <stdio.h>
#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvEvents.h"
#include "ProvEvt.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CEventProvider :: CEventProvider (

	WmiAllocator &a_Allocator ,
	CServerObject_ProviderEvents *a_EventRegistrar ,
	IUnknown *a_Unknown

) :	m_EventRegistrar ( a_EventRegistrar ) ,
	m_Unknown ( a_Unknown ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_IWbemProviderIdentity ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_IWbemEventConsumerProviderEx ( NULL ) ,
	m_CoreService ( NULL ) ,
	m_Locale ( NULL ) ,
	m_User ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_ReferenceCount ( 0 ) ,
	m_CriticalSection(NOTHROW_LOCK)
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

	if ( m_EventRegistrar )
	{
		m_EventRegistrar->InternalAddRef () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;

		HRESULT t_Result = m_Unknown->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemProviderIdentity , ( void ** ) & m_Provider_IWbemProviderIdentity ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_IWbemEventConsumerProviderEx ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CEventProvider :: ~CEventProvider ()
{
	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}

	if ( m_EventRegistrar )
	{
		m_EventRegistrar->InternalRelease () ;
	}

	if ( m_Provider_IWbemEventProvider )
	{
		m_Provider_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		m_Provider_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		m_Provider_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_IWbemProviderIdentity )
	{
		m_Provider_IWbemProviderIdentity->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		m_Provider_IWbemEventConsumerProviderEx->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProvider )
	{
		m_Provider_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_CoreService )
	{
		m_CoreService->Release () ;
	}

	WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider :: Initialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;
	if ( t_StatusCode != e_StatusCode_Success )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CEventProvider :: AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CEventProvider :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CEventProvider :: QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	else if ( a_Riid == IID_IWbemEventProvider )
	{
		if ( m_Unknown )
		{
			if ( m_Provider_IWbemEventProvider )
			{
				*a_Void = ( LPVOID ) ( IWbemEventProvider * ) this ;
			}
		}
		else
		{
			*a_Void = ( LPVOID ) ( IWbemEventProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemProviderIdentity )
	{
		if ( m_Provider_IWbemProviderIdentity )
		{
			*a_Void = ( LPVOID ) ( IWbemProviderIdentity * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*a_Void = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*a_Void = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemProviderInit )
	{
		*a_Void = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}
	else if ( a_Riid == IID_IWbemShutdown )
	{
		*a_Void = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		HRESULT t_TempResult = m_EventRegistrar->SetSink ( a_Sink ) ;

		if ( SUCCEEDED ( t_TempResult ) ) 
		{
			if ( m_Provider_IWbemEventProvider )
			{

				BOOL t_Impersonating = FALSE ;
				IUnknown *t_OldContext = NULL ;
				IServerSecurity *t_OldSecurity = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					BOOL t_Revert = FALSE ;
					IUnknown *t_Proxy = NULL ;

					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemEventProvider , m_Provider_IWbemEventProvider , t_Proxy , t_Revert ) ;
					if ( t_Result == WBEM_E_NOT_FOUND )
					{
						try
						{
							t_Result = m_Provider_IWbemEventProvider->ProvideEvents (

								a_Sink ,
								a_Flags 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}
					}
					else 
					{
						if ( SUCCEEDED ( t_Result ) )
						{
							IWbemEventProvider *t_Provider = ( IWbemEventProvider * ) t_Proxy ;

							// Set cloaking on the proxy
							// =========================

							DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

							t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

								t_Provider ,
								RPC_C_AUTHN_LEVEL_DEFAULT , 
								t_ImpersonationLevel
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = CoImpersonateClient () ;
								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_Provider->ProvideEvents (

										a_Sink ,
										a_Flags 
									) ;
								}
								else
								{
									t_Result = WBEM_E_ACCESS_DENIED ;
								}
							}

							ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
						}
					}

					ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
				}
			}
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try 
					{
						t_Result = m_Provider_IWbemEventProviderQuerySink->NewQuery (

							a_Id ,
							a_QueryLanguage ,
							a_Query
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_DEFAULT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->NewQuery (

									a_Id ,
									a_QueryLanguage ,
									a_Query
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			return t_Result ;
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::CancelQuery (

	unsigned long a_Id
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemEventProviderQuerySink->CancelQuery (

							a_Id
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventProviderQuerySink *t_Provider = NULL ;
						t_Result = t_Proxy->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & t_Provider ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							// Set cloaking on the proxy
							// =========================

							DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

							t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

								t_Provider ,
								RPC_C_AUTHN_LEVEL_DEFAULT , 
								t_ImpersonationLevel
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = CoImpersonateClient () ;
								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_Provider->CancelQuery (

										a_Id
									) ;
								}
								else
								{
									t_Result = WBEM_E_ACCESS_DENIED ;
								}
							}

							t_Provider->Release () ;
						}

						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemEventProviderSecurity , m_Provider_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemEventProviderSecurity->AccessCheck (

							a_QueryLanguage ,
							a_Query ,
							a_SidLength ,
							a_Sid
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventProviderSecurity *t_Provider = ( IWbemEventProviderSecurity * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_DEFAULT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->AccessCheck (

									a_QueryLanguage ,
									a_Query ,
									a_SidLength ,
									a_Sid
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::SetRegistrationObject (

	long a_Flags ,
	IWbemClassObject *a_ProviderRegistration
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemProviderIdentity )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemProviderIdentity , m_Provider_IWbemProviderIdentity , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemProviderIdentity->SetRegistrationObject (

							a_Flags ,
							a_ProviderRegistration
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemProviderIdentity *t_Provider = ( IWbemProviderIdentity * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_DEFAULT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->SetRegistrationObject (

									a_Flags ,
									a_ProviderRegistration
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemEventConsumerProvider , m_Provider_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemEventConsumerProvider->FindConsumer (

							a_LogicalConsumer ,
							a_Consumer
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventConsumerProvider *t_Provider = ( IWbemEventConsumerProvider * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_DEFAULT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->FindConsumer (

									a_LogicalConsumer ,
									a_Consumer
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemEventConsumerProviderEx , m_Provider_IWbemEventConsumerProviderEx , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemEventConsumerProviderEx->ValidateSubscription (

							a_LogicalConsumer
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventConsumerProviderEx *t_Provider = ( IWbemEventConsumerProviderEx * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_DEFAULT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->ValidateSubscription (

									a_LogicalConsumer
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider :: UnRegister ()
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_CoreService,         // For anybody
	IWbemContext *a_Context,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	if ( a_CoreService ) 
	{
		m_CoreService = a_CoreService ;
		m_CoreService->AddRef () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	
	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	IWbemShutdown *t_Shutdown = NULL ;

	if ( m_Unknown )
	{
		t_Result = m_Unknown->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemShutdown , t_Shutdown , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_Shutdown->Shutdown (

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemShutdown *t_Provider = ( IWbemShutdown * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_DEFAULT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Provider->Shutdown (

								a_Flags ,
								a_MaxMilliSeconds ,
								a_Context
							) ;
						}

						ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_Shutdown->Release () ;
		}
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\provinterceptor.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"

#include <wbemint.h>
#include <stdio.h>
#include "CGlobals.h"
#include "Globals.h"
#include "ProvInterceptor.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemDecoupledUnboundObjectSink :: CInterceptor_IWbemDecoupledUnboundObjectSink (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) :	VoidPointerContainerElement (

		a_Controller ,
		this 
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Registration ( & a_Registration ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_UnBoundSync_Size , MAX_PROXIES )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledUnboundObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	if ( a_ServerSideProvider ) 
	{
		m_Unknown = a_ServerSideProvider ;
		m_Unknown->AddRef () ;

		HRESULT t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemDecoupledUnboundObjectSink :: ~CInterceptor_IWbemDecoupledUnboundObjectSink ()
{
	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledUnboundObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: Initialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemDecoupledUnboundObjectSink :: AddRef ()
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemDecoupledUnboundObjectSink :: Release ()
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemDecoupledUnboundObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID__IWmiProviderSite )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderSite * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: Internal_IndicateToConsumer (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = IndicateToConsumer (


			a_LogicalConsumer ,
			a_ObjectCount ,
			a_Objects
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_UnBoundSync_IWbemUnboundObjectSink , IID_IWbemUnboundObjectSink , m_Provider_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Provider_IWbemUnboundObjectSink->IndicateToConsumer (


					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemUnboundObjectSink *t_Provider = ( IWbemUnboundObjectSink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Provider->IndicateToConsumer (

							a_LogicalConsumer ,
							a_ObjectCount ,
							a_Objects
						) ;
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_UnBoundSync_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: GetSite ( DWORD *a_ProcessIdentifier )
{
	HRESULT t_Result = S_OK ;

	if ( a_ProcessIdentifier ) 
	{
		*a_ProcessIdentifier = GetCurrentProcessId () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: SetContainer ( IUnknown *a_Container )
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CDecoupled_IWbemSyncObjectSink :: CDecoupled_IWbemSyncObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	: CCommon_IWbemSyncObjectSink ( 

		a_Allocator ,
		a_InterceptedSink ,
		a_Unknown ,
		a_Controller ,
		a_Dependant 
	) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CDecoupled_IWbemSyncObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_IWbemSyncObjectSink :: ~CDecoupled_IWbemSyncObjectSink ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CDecoupled_IWbemSyncObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CDecoupled_Batching_IWbemSyncObjectSink :: CDecoupled_Batching_IWbemSyncObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	: CCommon_Batching_IWbemSyncObjectSink ( 

		a_Allocator ,
		a_InterceptedSink ,
		a_Unknown ,
		a_Controller ,
		a_Dependant 
	) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CDecoupled_Batching_IWbemSyncObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_Batching_IWbemSyncObjectSink :: ~CDecoupled_Batching_IWbemSyncObjectSink ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CDecoupled_Batching_IWbemSyncObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_DecoupledClient :: CInterceptor_DecoupledClient (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	IWbemServices *a_CoreStub ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) :	m_ReferenceCount ( 0 ) ,
	m_Allocator ( a_Allocator ) ,
	CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemServices ( NULL ) ,
	m_Provider_IWbemPropertyProvider ( NULL ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_CoreStub ( a_CoreStub ) ,
	m_Registration ( & a_Registration ) ,
	m_Locale ( NULL ) ,
	m_User ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_Provider_Size , MAX_PROXIES )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_DecoupledClient_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	if ( a_ServerSideProvider ) 
	{
		m_Unknown = a_ServerSideProvider ;
		m_Unknown->AddRef () ;

		HRESULT t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemServices , ( void ** ) & m_Provider_IWbemServices ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemPropertyProvider , ( void ** ) & m_Provider_IWbemPropertyProvider ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_IWbemEventConsumerProviderEx ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_DecoupledClient :: ~CInterceptor_DecoupledClient ()
{
	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemServices )
	{
		m_Provider_IWbemServices->Release () ; 
	}

	if ( m_Provider_IWbemPropertyProvider )
	{
		m_Provider_IWbemPropertyProvider->Release () ; 
	}

	if ( m_Provider_IWbemEventProvider )
	{
		m_Provider_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		m_Provider_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		m_Provider_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		m_Provider_IWbemEventConsumerProviderEx->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProvider )
	{
		m_Provider_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->Release () ;
	}

	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_DecoupledClient_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_DecoupledClient :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_DecoupledClient :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_DecoupledClient :: QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	if ( a_Riid == IID_IWbemProviderInit )
	{
		*a_Void = ( LPVOID ) ( IWbemProviderInit * ) this ;
	}
	if ( a_Riid == IID_Internal_IWbemProviderInit )
	{
		*a_Void = ( LPVOID ) ( Internal_IWbemProviderInit * ) this ;
	}
	else if ( a_Riid == IID_IWbemServices )
	{
		if ( m_Provider_IWbemServices )
		{
			*a_Void = ( LPVOID ) ( IWbemServices * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemPropertyProvider )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			*a_Void = ( LPVOID ) ( IWbemPropertyProvider * ) this ;
		}
	}	
	else if ( a_Riid == IID_IWbemEventProvider )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*a_Void = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*a_Void = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*a_Void = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( a_Riid == IID__IWmiProviderInitialize )
	{
		*a_Void = ( LPVOID ) ( _IWmiProviderInitialize * ) this ;		
	}
	else if ( a_Riid == IID__IWmiProviderSite )
	{
		*a_Void = ( LPVOID ) ( _IWmiProviderSite * ) this ;		
	}
	else if ( a_Riid == IID_IWbemShutdown )
	{
		*a_Void = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}
	else if ( a_Riid == IID__IWmiProviderConfiguration )
	{
		*a_Void = ( LPVOID ) ( _IWmiProviderConfiguration * ) this ;		
	}	
	else if ( a_Riid == IID_Internal_IWbemServices )
	{
		if ( m_Provider_IWbemServices )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemServices * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemPropertyProvider )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemPropertyProvider * ) this ;
		}
	}	
	else if ( a_Riid == IID_Internal_IWbemEventProvider )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemUnboundObjectSink * ) this ;
		}
	}

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_OpenNamespace ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = OpenNamespace (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_NamespaceService ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CancelAsyncCall ( 
	
	WmiInternalContext a_InternalContext ,		
	IWbemObjectSink *a_Sink
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CancelAsyncCall (
		
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_QueryObjectSink ( 

	WmiInternalContext a_InternalContext ,
	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryObjectSink (

			a_Flags ,	
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_GetObject ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetObject (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_Object ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_GetObjectAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetObjectAsync (

			a_ObjectPath ,
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutClass ( 

	WmiInternalContext a_InternalContext ,		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutClass (

			a_Object ,
			a_Flags , 
			a_Context ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutClassAsync ( 
		
	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_Object , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutClassAsync (

			a_Object , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_DeleteClass ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteClass (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_DeleteClassAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteClassAsync (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CreateClassEnum ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_SuperClass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateClassEnum (

			a_SuperClass ,
			a_Flags, 
			a_Context ,
			a_Enum
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CreateClassEnumAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_SuperClass , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateClassEnumAsync (

			a_SuperClass ,
			a_Flags, 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutInstance (

	WmiInternalContext a_InternalContext ,
    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutInstance (

			a_Instance ,
			a_Flags ,
			a_Context ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutInstanceAsync ( 

	WmiInternalContext a_InternalContext ,		
	IWbemClassObject *a_Instance , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutInstanceAsync (

			a_Instance , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_DeleteInstance ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteInstance (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_DeleteInstanceAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteInstanceAsync (

			a_ObjectPath ,
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CreateInstanceEnum ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateInstanceEnum (

			a_Class ,
			a_Flags , 
			a_Context , 
			a_Enum
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CreateInstanceEnumAsync (

	WmiInternalContext a_InternalContext ,
 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateInstanceEnumAsync (

			a_Class ,
			a_Flags ,
			a_Context ,
			a_Sink 
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecQuery ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecQuery (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Enum
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecQueryAsync ( 

	WmiInternalContext a_InternalContext ,		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecQueryAsync (

			a_QueryLanguage ,
			a_Query, 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecNotificationQuery ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecNotificationQuery (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Enum
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_DecoupledClient :: Internal_ExecNotificationQueryAsync ( 

	WmiInternalContext a_InternalContext ,            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecNotificationQueryAsync (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Sink 
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecMethod (

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecMethod (

			a_ObjectPath ,
			a_MethodName ,
			a_Flags ,
			a_Context ,
			a_InParams ,
			a_OutParams ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecMethodAsync ( 

	WmiInternalContext a_InternalContext ,		
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecMethodAsync (

			a_ObjectPath ,
			a_MethodName ,
			a_Flags ,
			a_Context ,
			a_InParams ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_GetProperty (

	WmiInternalContext a_InternalContext ,
    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetProperty ( 

			a_Flags ,
			a_Locale ,
			a_ClassMapping ,
			a_InstanceMapping ,
			a_PropertyMapping ,
			a_Value
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutProperty (

	WmiInternalContext a_InternalContext ,
    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutProperty ( 

			a_Flags ,
			a_Locale ,
			a_ClassMapping ,
			a_InstanceMapping ,
			a_PropertyMapping ,
			a_Value
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ProvideEvents (

	WmiInternalContext a_InternalContext ,
	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ProvideEvents (

			a_Sink ,
			a_Flags 
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_NewQuery (

	WmiInternalContext a_InternalContext ,
	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = NewQuery (

			a_Id ,
			a_QueryLanguage ,
			a_Query
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CancelQuery (

	WmiInternalContext a_InternalContext ,
	unsigned long a_Id
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CancelQuery (

			a_Id
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_AccessCheck (

	WmiInternalContext a_InternalContext ,
	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = AccessCheck (

			a_QueryLanguage ,
			a_Query ,
			a_SidLength ,
			a_Sid
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_FindConsumer (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = FindConsumer (

			a_LogicalConsumer ,
			a_Consumer
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ValidateSubscription (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ValidateSubscription (

			a_LogicalConsumer
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_IndicateToConsumer (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = IndicateToConsumer (


			a_LogicalConsumer ,
			a_ObjectCount ,
			a_Objects
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: AdjustGetContext (

    IWbemContext *a_Context
)
{
    // See if per-property get are being used.
    // ========================================

    HRESULT t_Result = S_OK ;

    if ( a_Context )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		t_Result = a_Context->GetValue ( L"__GET_EXTENSIONS" , 0, & t_Variant ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			// If here, they are being used.  Next we have to check and see
			// if the reentrancy flag is set or not.
			// =============================================================

			VariantClear ( & t_Variant ) ;

			t_Result = a_Context->GetValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 , & t_Variant ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				
				VariantClear ( & t_Variant ) ;

				a_Context->DeleteValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 ) ;
			}
			else
			{
				// If here, we have to clear out the get extensions.
				// =================================================

				a_Context->DeleteValue ( L"__GET_EXTENSIONS" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_KEYS_ONLY" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_PROPERTIES" , 0 ) ;
			}
		}
	}

    return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: SetStatus ( 

	LPWSTR a_Operation ,
	LPWSTR a_Parameters ,
	LPWSTR a_Description ,
	HRESULT a_Result ,
	IWbemObjectSink *a_Sink
)
{
	return a_Sink->SetStatus ( 0 , a_Result , NULL , NULL ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Begin_IWbemServices (

	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IWbemServices *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalServiceHost:
		case e_Hosting_SharedNetworkServiceHost:
		{
			a_Interface = m_Provider_IWbemServices ;
			a_IsProxy = FALSE ;
		}
		break ;

		default:
		{
			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , a_Proxy , a_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					a_Interface = m_Provider_IWbemServices ;
					a_IsProxy = FALSE ;
					t_Result = S_OK ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						a_IsProxy = TRUE ;

						a_Interface = ( IWbemServices * ) a_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							a_Interface ,
							RPC_C_AUTHN_LEVEL_DEFAULT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						if ( FAILED ( t_Result ) )
						{
							HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

								m_ProxyContainer , 
								ProxyIndex_IWbemServices , 
								a_Proxy , 
								a_Revert
							) ;
						}
					}
				}

				if ( FAILED ( t_Result ) )
				{
					ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
				}
			}
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: End_IWbemServices (

	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IWbemServices *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

			m_ProxyContainer , 
			ProxyIndex_IWbemServices , 
			a_Proxy , 
			a_Revert
		) ;
	}

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalServiceHost:
		case e_Hosting_SharedNetworkServiceHost:
		{
		}
		break ;

		default:
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
		break ;
	}
	
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Find ( 

			a_Sink ,
			t_Iterator
		) ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			ObjectSinkContainerElement *t_Element = t_Iterator.GetElement () ;

			UnLock () ;

			IWbemObjectSink *t_ObjectSink = NULL ;
			t_Result = t_Element->QueryInterface ( IID_IWbemObjectSink , ( void ** ) & t_ObjectSink ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_Impersonating ;
				IUnknown *t_OldContext ;
				IServerSecurity *t_OldSecurity ;
				BOOL t_IsProxy ;
				IWbemServices *t_Interface ;
				BOOL t_Revert ;
				IUnknown *t_Proxy ;

				t_Result = Begin_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Interface->CancelAsyncCall (

						t_ObjectSink
					) ;

					End_IWbemServices (

						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;
				}

				t_ObjectSink->Release () ;
			}

			IWbemShutdown *t_Shutdown = NULL ;
			HRESULT t_TempResult = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				t_TempResult = t_Shutdown->Shutdown ( 

					0 , 
					0 , 
					NULL 
				) ;

				t_Shutdown->Release () ;
			}

			t_Element->Release () ;
		}
		else
		{
			UnLock () ;

			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_GetObjectAsync (

	BOOL a_IsProxy ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_GetObjectAsync () ;

						try	
						{
							t_Result = a_Service->GetObjectAsync (

 								a_ObjectPath ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						Increment_ProviderOperation_GetObjectAsync () ;

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							try
							{
								t_Result = a_Service->GetObjectAsync (

 									a_ObjectPath ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"GetObjectAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsGet () || m_Registration->GetClassProviderRegistration ().SupportsGet () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_GetObjectAsync ( 

					t_IsProxy ,
					a_ObjectPath ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_PutClassAsync (

	BOOL a_IsProxy ,
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_PutClassAsync () ;

						try
						{
							t_Result = a_Service->PutClassAsync (

 								a_Object ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_PutClassAsync () ;

							try
							{
								t_Result = a_Service->PutClassAsync (

 									a_Object ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"PutClassAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsPut () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_PutClassAsync ( 

					t_IsProxy ,
					a_Object ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_DeleteClassAsync (

	BOOL a_IsProxy ,
	const BSTR a_Class , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_DeleteClassAsync () ;

						try
						{
							t_Result = a_Service->DeleteClassAsync (

 								a_Class ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_DeleteClassAsync () ;

							try
							{
								t_Result = a_Service->DeleteClassAsync (

 									a_Class ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"DeleteClassAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: DeleteClassAsync ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsDelete () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_DeleteClassAsync ( 

					t_IsProxy ,
					a_Class ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_CreateClassEnumAsync (

	BOOL a_IsProxy ,
	const BSTR a_SuperClass , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CDecoupled_Batching_IWbemSyncObjectSink *t_Sink = new CDecoupled_Batching_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_CreateClassEnumAsync () ;

						try
						{
							t_Result = a_Service->CreateClassEnumAsync (

 								a_SuperClass ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_CreateClassEnumAsync () ;

							try
							{
								t_Result = a_Service->CreateClassEnumAsync (

 									a_SuperClass ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"CreateClassEnumAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CreateClassEnumAsync ( 
		
	const BSTR a_SuperClass , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsEnumeration () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_CreateClassEnumAsync ( 

					t_IsProxy ,
					a_SuperClass ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutInstance (

    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_PutInstanceAsync (

	BOOL a_IsProxy ,
	IWbemClassObject *a_Instance ,
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) ) 
					{
						Increment_ProviderOperation_PutInstanceAsync () ;

						try
						{
							t_Result = a_Service->PutInstanceAsync (

 								a_Instance ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_PutInstanceAsync () ;

							try
							{
								t_Result = a_Service->PutInstanceAsync (

 									a_Instance ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"PutInstanceAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsPut () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_PutInstanceAsync ( 

					t_IsProxy ,
					a_Instance ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: DeleteInstance ( 

	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_DeleteInstanceAsync (

	BOOL a_IsProxy ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_DeleteInstanceAsync () ;

						try
						{
							t_Result = a_Service->DeleteInstanceAsync (

 								a_ObjectPath ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_DeleteInstanceAsync () ;

							try
							{
								t_Result = a_Service->DeleteInstanceAsync (

 									a_ObjectPath ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"DeleteInstanceAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: DeleteInstanceAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsDelete () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_DeleteInstanceAsync ( 

					t_IsProxy ,
					a_ObjectPath ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CreateInstanceEnum ( 

	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_CreateInstanceEnumAsync (

	BOOL a_IsProxy ,
 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CDecoupled_Batching_IWbemSyncObjectSink *t_Sink = new CDecoupled_Batching_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_CreateInstanceEnumAsync () ;

						try
						{
							t_Result = a_Service->CreateInstanceEnumAsync (

 								a_Class ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							Increment_ProviderOperation_CreateInstanceEnumAsync () ;

							try
							{
								t_Result = a_Service->CreateInstanceEnumAsync (

 									a_Class ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				HRESULT t_TempResult = SetStatus ( L"CreateInstanceEnumAsync" , NULL , NULL , t_Result , t_Sink ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_CreateInstanceEnumAsync ( 

					t_IsProxy ,
					a_Class ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecQuery ( 

	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_ExecQueryAsync (

	BOOL a_IsProxy ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Context )
		{
			t_Result = a_Context->Clone ( & t_ContextCopy ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = S_OK ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		if ( ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_UnarySelect ) ||  ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_V1ProviderDefined ) ) 
		{
			CDecoupled_Batching_IWbemSyncObjectSink *t_Sink = new CDecoupled_Batching_IWbemSyncObjectSink (

				m_Allocator ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				FALSE
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_ExecQueryAsync () ;

							try
							{
								t_Result = a_Service->ExecQueryAsync (

									a_QueryLanguage ,
									a_Query, 
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							if ( a_IsProxy )
							{
								t_Result = CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{
								Increment_ProviderOperation_ExecQueryAsync () ;

								try
								{
									t_Result = a_Service->ExecQueryAsync (

										a_QueryLanguage ,
										a_Query, 
										a_Flags ,
										t_ContextCopy ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( FAILED ( t_Result ) )
					{
						HRESULT t_TempResult = SetStatus ( L"ExecQueryAsync" , NULL , NULL , t_Result , t_Sink ) ;
					}
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else if ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () )
		{
			IWbemQuery *t_QueryFilter = NULL ;
			t_Result = ProviderSubSystem_Common_Globals :: CreateInstance	(

				CLSID_WbemQuery ,
				NULL ,
				CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
				IID_IWbemQuery ,
				( void ** ) & t_QueryFilter
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_QueryFilter->Parse ( 

					a_QueryLanguage ,
					a_Query , 
					0 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					SWbemRpnEncodedQuery *t_Expression = NULL ;

					t_Result = t_QueryFilter->GetAnalysis (

						WMIQ_ANALYSIS_RPN_SEQUENCE ,
						0 ,
						( void ** ) & t_Expression
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_Expression->m_uFromTargetType == WMIQ_RPN_FROM_UNARY )
						{
							BSTR t_Class = SysAllocString ( t_Expression->m_ppszFromList [ 0 ] ) ;
							if ( t_Class )
							{
								CDecoupled_Batching_IWbemSyncObjectSink *t_Sink = new CDecoupled_Batching_IWbemSyncObjectSink (

									m_Allocator ,
									a_Sink , 
									( IWbemServices * ) this , 
									( CWbemGlobal_IWmiObjectSinkController * ) this ,
									FALSE
								) ;

								if ( t_Sink )
								{
									t_Sink->AddRef () ;

									t_Result = t_Sink->SinkInitialize () ;
									if ( SUCCEEDED ( t_Result ) )
									{
										a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , 0 , NULL , NULL ) ;

										CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

										Lock () ;

										WmiStatusCode t_StatusCode = Insert ( 

											*t_Sink ,
											t_Iterator
										) ;

										if ( t_StatusCode == e_StatusCode_Success ) 
										{
											UnLock () ;

											if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
											{
												a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
											}

											if ( a_IsProxy )
											{
												t_Result = CoImpersonateClient () ;
											}
											else
											{
												t_Result = S_OK ;
											}

											if ( SUCCEEDED ( t_Result ) )
											{
												a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , 0 , NULL , NULL ) ;

												Increment_ProviderOperation_CreateInstanceEnumAsync () ;

												try
												{
													t_Result = a_Service->CreateInstanceEnumAsync (

 														t_Class ,
														a_Flags ,
														t_ContextCopy ,
														t_Sink 
													) ;
												}
												catch ( ... )
												{
													t_Result = WBEM_E_PROVIDER_FAILURE ;
												}
				
												CoRevertToSelf () ;
											}
											else
											{
												t_Result = WBEM_E_ACCESS_DENIED ;
											}

											if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
											{
												a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

												if ( a_IsProxy )
												{
													t_Result = CoImpersonateClient () ;
												}
												else
												{
													t_Result = S_OK ;
												}

												if ( SUCCEEDED ( t_Result ) ) 
												{
													Increment_ProviderOperation_CreateInstanceEnumAsync () ;

													try
													{
														t_Result = a_Service->CreateInstanceEnumAsync (

 															t_Class ,
															a_Flags ,
															t_ContextCopy ,
															t_Sink 
														) ;
													}
													catch ( ... )
													{
														t_Result = WBEM_E_PROVIDER_FAILURE ;
													}
					
													CoRevertToSelf () ;
												}
												else
												{
													t_Result = WBEM_E_ACCESS_DENIED ;
												}
											}
										}
										else
										{
											t_Result = WBEM_E_OUT_OF_MEMORY ;
										}
									}

									if ( FAILED ( t_Result ) )
									{
										HRESULT t_TempResult = SetStatus ( L"CreateInstanceEnumAsync" , NULL , NULL , t_Result , t_Sink ) ;
									}

                                    t_Sink->Release () ;
								}
								else
								{
									SysFreeString ( t_Class ) ;

									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = WBEM_E_NOT_SUPPORTED ;
						}

						t_QueryFilter->FreeMemory ( t_Expression ) ;
					}
					else
					{
						t_Result = WBEM_E_UNEXPECTED ;
					}
				}
				else
				{
					t_Result = WBEM_E_NOT_SUPPORTED ;
				}

				t_QueryFilter->Release () ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_SUPPORTED ;
		}
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_UnarySelect ) || ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_V1ProviderDefined ) || ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () ) )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_ExecQueryAsync ( 

					t_IsProxy ,
					a_QueryLanguage ,
					a_Query, 
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_DecoupledClient :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecMethod (

	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_ExecMethodAsync (

	BOOL a_IsProxy ,
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) ) 
					{
						Increment_ProviderOperation_ExecMethodAsync () ;

						try
						{
							t_Result = a_Service->ExecMethodAsync (

 								a_ObjectPath ,
								a_MethodName ,
								a_Flags ,
								t_ContextCopy ,
								a_InParams ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_ExecMethodAsync () ;

							try
							{
								t_Result = a_Service->ExecMethodAsync (

 									a_ObjectPath ,
									a_MethodName ,
									a_Flags ,
									t_ContextCopy ,
									a_InParams ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"ExecMethodAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecMethodAsync ( 
		
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetMethodProviderRegistration ().SupportsMethods () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_ExecMethodAsync ( 

					t_IsProxy ,
					a_ObjectPath ,
					a_MethodName ,
					a_Flags ,
					a_Context ,
					a_InParams ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: GetProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		if ( m_Registration->GetPropertyProviderRegistration ().SupportsGet () )
		{
			Increment_ProviderOperation_GetProperty () ;

			HRESULT t_Result = S_OK ;

			try
			{
				t_Result = m_Provider_IWbemPropertyProvider->GetProperty ( 

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;

				CoRevertToSelf () ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;

				CoRevertToSelf () ;
			}

			return t_Result ;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		if ( m_Registration->GetPropertyProviderRegistration ().SupportsPut () )
		{
			Increment_ProviderOperation_PutProperty () ;

			HRESULT t_Result = S_OK ;

			try
			{
				t_Result = m_Provider_IWbemPropertyProvider->PutProperty ( 

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;

				CoRevertToSelf () ;

				return t_Result ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;

				CoRevertToSelf () ;
			}

			return t_Result ;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	if ( m_Provider_IWbemEventProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProvider , IID_IWbemEventProvider , m_Provider_IWbemEventProvider , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_ProvideEvents () ;

				try
				{
					t_Result = m_Provider_IWbemEventProvider->ProvideEvents (

						a_Sink ,
						a_Flags 
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProvider *t_Provider = ( IWbemEventProvider * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_ProvideEvents () ;

							try
							{
								t_Result = t_Provider->ProvideEvents (

									a_Sink ,
									a_Flags 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProvider , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_NewQuery () ;

				try
				{
					t_Result = m_Provider_IWbemEventProviderQuerySink->NewQuery (

						a_Id ,
						a_QueryLanguage ,
						a_Query
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_NewQuery () ;

							try
							{
								t_Result = t_Provider->NewQuery (

									a_Id ,
									a_QueryLanguage ,
									a_Query
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::CancelQuery (

	unsigned long a_Id
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_CancelQuery () ;

				try
				{
					t_Result = m_Provider_IWbemEventProviderQuerySink->CancelQuery (

						a_Id
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_CancelQuery () ;

							try
							{
								t_Result = t_Provider->CancelQuery (

									a_Id
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	if ( m_Provider_IWbemEventProviderSecurity )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderSecurity , IID_IWbemEventProviderSecurity , m_Provider_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_AccessCheck () ;

				try
				{
					t_Result = m_Provider_IWbemEventProviderSecurity->AccessCheck (

						a_QueryLanguage ,
						a_Query ,
						a_SidLength ,
						a_Sid
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProviderSecurity *t_Provider = ( IWbemEventProviderSecurity * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_AccessCheck () ;

							try
							{
								t_Result = t_Provider->AccessCheck (

									a_QueryLanguage ,
									a_Query ,
									a_SidLength ,
									a_Sid
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::SetRegistrationObject (

	long a_Flags ,
	IWbemClassObject *a_ProviderRegistration
)
{
	if ( m_Provider_IWbemProviderIdentity )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemProviderIdentity , IID_IWbemProviderIdentity , m_Provider_IWbemProviderIdentity , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_SetRegistrationObject () ;

				try
				{
					t_Result = m_Provider_IWbemProviderIdentity->SetRegistrationObject (

						a_Flags ,
						a_ProviderRegistration
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemProviderIdentity *t_Provider = ( IWbemProviderIdentity * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_SetRegistrationObject () ;

							try
							{
								t_Result = t_Provider->SetRegistrationObject (

									a_Flags ,
									a_ProviderRegistration
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemProviderIdentity , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	if ( m_Provider_IWbemEventConsumerProvider )
	{
		IWbemUnboundObjectSink *t_Consumer = NULL ;

		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProvider , IID_IWbemEventConsumerProvider , m_Provider_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_FindConsumer () ;

				try
				{
					t_Result = m_Provider_IWbemEventConsumerProvider->FindConsumer (

						a_LogicalConsumer ,
						& t_Consumer
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventConsumerProvider *t_Provider = ( IWbemEventConsumerProvider * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_FindConsumer () ;

							try
							{
								t_Result = t_Provider->FindConsumer (

									a_LogicalConsumer ,
									& t_Consumer
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( a_Consumer )
			{
				CInterceptor_IWbemDecoupledUnboundObjectSink *t_UnboundObjectSink = new CInterceptor_IWbemDecoupledUnboundObjectSink (

						m_Allocator ,
						t_Consumer , 
						this ,
						*m_Registration
				) ;

				if ( t_UnboundObjectSink )
				{
					t_UnboundObjectSink->AddRef () ;

					t_Result = t_UnboundObjectSink->Initialize () ;
					if ( SUCCEEDED ( t_Result ) )
					{
						CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

						Lock () ;

						WmiStatusCode t_StatusCode = Insert ( 

							*t_UnboundObjectSink ,
							t_Iterator
						) ;

						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							UnLock () ;

							*a_Consumer = t_UnboundObjectSink ;

							t_UnboundObjectSink->AddRef () ;
						}
						else
						{
							UnLock () ;

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_UnboundObjectSink->Release () ;
				}
			}
		}

		if ( t_Consumer )
		{
			t_Consumer->Release () ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProviderEx , IID_IWbemEventConsumerProviderEx , m_Provider_IWbemEventConsumerProviderEx , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_ValidateSubscription () ;

				try
				{
					t_Result = m_Provider_IWbemEventConsumerProviderEx->ValidateSubscription (

						a_LogicalConsumer
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventConsumerProviderEx *t_Provider = ( IWbemEventConsumerProviderEx * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_ValidateSubscription () ;

							try
							{
								t_Result = t_Provider->ValidateSubscription (

									a_LogicalConsumer
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProviderEx , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemUnboundObjectSink , IID_IWbemUnboundObjectSink , m_Provider_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Provider_IWbemUnboundObjectSink->IndicateToConsumer (


					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemUnboundObjectSink *t_Provider = ( IWbemUnboundObjectSink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Provider->IndicateToConsumer (

							a_LogicalConsumer ,
							a_ObjectCount ,
							a_Objects
						) ;
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Initialize (

	LPWSTR a_User ,
	LONG a_Flags ,
	LPWSTR a_Namespace ,
	LPWSTR a_Locale ,
	IWbemServices *a_CoreService ,
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	if ( m_Unknown )
	{
		IWbemProviderInit *t_Provider = NULL ;

		t_Result = m_Unknown->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & t_Provider ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			try 
			{
				t_Result = t_Provider->Initialize (

					a_User,
					a_Flags,
					a_Namespace,
					a_Locale,
					a_CoreService,
					a_Context,
					a_Sink
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}

			t_Provider->Release () ;
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_Initialize (

	WmiInternalContext a_InternalContext ,
	LPWSTR a_User ,
	LONG a_Flags ,
	LPWSTR a_Namespace ,
	LPWSTR a_Locale ,
	IWbemServices *a_CoreService ,
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Initialize (

			a_User ,
			a_Flags ,
			a_Namespace ,
			a_Locale ,
			a_CoreService ,
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ProviderInitialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: GetSite ( DWORD *a_ProcessIdentifier )
{
	HRESULT t_Result = S_OK ;

	if ( a_ProcessIdentifier ) 
	{
		*a_ProcessIdentifier = GetCurrentProcessId () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: SetContainer ( IUnknown *a_Container )
{	
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	IWbemShutdown *t_Shutdown = NULL ;

	if ( m_Unknown )
	{
		t_Result = m_Unknown->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , IID_IWbemShutdown , t_Shutdown , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_Shutdown->Shutdown (

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}

					CoRevertToSelf () ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemShutdown *t_Provider = ( IWbemShutdown * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_DEFAULT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								try
								{
									t_Result = t_Provider->Shutdown (

										a_Flags ,
										a_MaxMilliSeconds ,
										a_Context
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
						}

						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_Shutdown->Release () ;
		}
	}

	Lock () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Container->Size () ] ;
	if ( t_ShutdownElements )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

		ULONG t_Count = 0 ;
		while ( ! t_Iterator.Null () )
		{
			t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

			t_Iterator.Increment () ;

			t_Count ++ ;
		}

		UnLock () ;

		for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
		{
			if ( t_ShutdownElements [ t_Index ] ) 
			{
				t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

					a_Flags ,
					a_MaxMilliSeconds ,
					a_Context
				) ;

				t_ShutdownElements [ t_Index ]->Release () ;
			}
		}

		delete [] t_ShutdownElements ;
	}
	else
	{	
		UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\provevents.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include <PreComp.h>
#include <wbemint.h>

#include "Globals.h"
#include "Guids.h"

#include "ProvRegistrar.h"
#include "ProvEvents.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_IWbemObjectSink :: CDecoupled_IWbemObjectSink ()

	:	m_InterceptedSink ( NULL ) ,
		m_EventSink ( NULL ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_StatusCalled ( FALSE ) ,
		m_SecurityDescriptorLength ( 0 ) ,
		m_SecurityDescriptor ( NULL ),
		m_CriticalSection(NOTHROW_LOCK)
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

	WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_IWbemObjectSink::~CDecoupled_IWbemObjectSink ()
{
	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 0 , 0 ) )
	{
		WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

		IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
		if ( t_ObjectSink )
		{
			t_ObjectSink->AddRef () ;
		}

		WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

		if ( t_ObjectSink )
		{
			t_ObjectSink->SetStatus ( 

				0 ,
				WBEM_E_UNEXPECTED ,
				NULL ,
				NULL
			) ;

			t_ObjectSink->Release () ;
		}


	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_EventSink )
	{
		m_EventSink->Release () ;
	}

	if ( m_SecurityDescriptor )
	{
		delete [] m_SecurityDescriptor ;
	}

	WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CDecoupled_IWbemObjectSink::QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	else if ( a_Riid == IID_IWbemObjectSink )
	{
		*a_Void = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}
	else if ( a_Riid == IID_IWbemEventSink )
	{
		*a_Void = ( LPVOID ) ( IWbemEventSink * ) this ;		
	}	
	else if ( a_Riid == IID_IWbemShutdown )
	{
		*a_Void = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
				if ( t_ObjectSink )
				{
					t_ObjectSink->AddRef () ;
				}

				WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				if ( t_ObjectSink )
				{
					t_Result = t_ObjectSink->Indicate ( 

						a_ObjectCount ,
						a_ObjectArray
					) ;

					t_ObjectSink->Release () ;
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				switch ( a_Flags )
				{
					case WBEM_STATUS_PROGRESS:
					{
						WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

						IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
						if ( t_ObjectSink )
						{
							t_ObjectSink->AddRef () ;
						}

						WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

						if ( t_ObjectSink )
						{
							t_Result = t_ObjectSink->SetStatus ( 

								a_Flags ,
								a_Result ,
								a_StringParam ,
								a_ObjectParam
							) ;

							t_ObjectSink->Release () ;
						}
					}
					break ;

					case WBEM_STATUS_COMPLETE:
					{
						if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
						{
							WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

							IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
							if ( t_ObjectSink )
							{
								t_ObjectSink->AddRef () ;
							}

							WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

							if ( t_ObjectSink )
							{
								t_Result = t_ObjectSink->SetStatus ( 

									a_Flags ,
									a_Result ,
									a_StringParam ,
									a_ObjectParam
								) ;

								t_ObjectSink->Release () ;
							}
						}
					}
					break ;

					default:
					{
						t_Result = WBEM_E_INVALID_PARAMETER ;
					}
					break ;
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: SetSinkSecurity (

	long a_SecurityDescriptorLength ,
	BYTE *a_SecurityDescriptor
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				IWbemEventSink *t_ObjectSink = m_EventSink ;
				if ( t_ObjectSink )
				{
					t_ObjectSink->AddRef () ;
				}

				WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				if ( t_ObjectSink )
				{
					t_Result = t_ObjectSink->SetSinkSecurity ( 

							a_SecurityDescriptorLength ,
							a_SecurityDescriptor
					) ;

					t_ObjectSink->Release () ;
				}
				else
				{
					if ( a_SecurityDescriptor )
					{
						if ( a_SecurityDescriptorLength )
						{
							WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

							m_SecurityDescriptorLength = a_SecurityDescriptorLength ;
							m_SecurityDescriptor = new BYTE [ a_SecurityDescriptorLength ] ;
							if  ( m_SecurityDescriptor )
							{
								try
								{
									CopyMemory ( m_SecurityDescriptor , a_SecurityDescriptor , a_SecurityDescriptorLength ) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_CRITICAL_ERROR ;
								}
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;
						}
						else
						{
							t_Result = WBEM_E_INVALID_PARAMETER ;
						}
					}
					else
					{
						WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

						if ( m_SecurityDescriptor )
						{
							delete m_SecurityDescriptor ;
							m_SecurityDescriptor = NULL ;
						}

						m_SecurityDescriptorLength = 0 ;

						WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;
					}
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: IsActive ()
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				IWbemEventSink *t_ObjectSink = m_EventSink ;
				if ( t_ObjectSink )
				{
					t_ObjectSink->AddRef () ;
				}

				WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				if ( t_ObjectSink )
				{
					t_Result = t_ObjectSink->IsActive () ;

					t_ObjectSink->Release () ;
				}
				else
				{
					t_Result = WBEM_S_FALSE ;
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: SetBatchingParameters (

	LONG a_Flags,
	DWORD a_MaxBufferSize,
	DWORD a_MaxSendLatency
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				IWbemEventSink *t_ObjectSink = m_EventSink ;
				if ( t_ObjectSink )
				{
					t_ObjectSink->AddRef () ;
				}

				WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				if ( t_ObjectSink )
				{
					t_Result = t_ObjectSink->SetBatchingParameters ( 

						a_Flags ,
						a_MaxBufferSize ,
						a_MaxSendLatency
					) ;

					t_ObjectSink->Release () ;
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
		{
			WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

			IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
			if ( t_ObjectSink )
			{
				t_ObjectSink->AddRef () ;
			}

			WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

			if ( t_ObjectSink )
			{
				t_Result = t_ObjectSink->SetStatus ( 

					0 ,
					WBEM_E_SHUTTING_DOWN ,
					NULL ,
					NULL
				) ;

				t_ObjectSink->Release () ;
			}
		}

		m_GateClosed ++ ;

		try
		{
			bool t_Acquired = false ;
			while ( ! t_Acquired )
			{
				if ( m_InProgress == 0 )
				{
					t_Acquired = true ;

					break ;
				}

				if ( SwitchToThread () == FALSE ) 
				{
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledRoot_IWbemObjectSink :: SinkInitialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_Decoupled_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledRoot_IWbemObjectSink :: SetSink ( IWbemObjectSink *a_Sink ) 
{
	Lock () ;

	CWbemGlobal_Decoupled_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	CWbemGlobal_Decoupled_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

	while ( ! t_Iterator.Null () )
	{
		HRESULT t_Result = t_Iterator.GetKey ()->SetSink ( a_Sink ) ;

		t_Iterator.Increment () ;
	}

	UnLock () ;

	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	m_InterceptedSink = a_Sink ;
	m_InterceptedSink->AddRef () ;

	t_Result = a_Sink->QueryInterface ( IID_IWbemEventSink , ( void ** ) & m_EventSink ) ;

	WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledChild_IWbemObjectSink :: SetSink ( IWbemObjectSink *a_Sink ) 
{
	HRESULT t_Result = S_OK ;

	IWbemObjectSink *t_InterceptedObjectSink = NULL ;
	IWbemEventSink *t_RestrictedEventSinkObjectSink = NULL ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemEventSink *t_EventSink = NULL ;
		t_Result = a_Sink->QueryInterface ( IID_IWbemEventSink , ( void ** ) & t_EventSink ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_EventSink->GetRestrictedSink (

				m_QueryCount ,
				m_Queries ,
				m_Callback ,
				& t_RestrictedEventSinkObjectSink
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
						t_Result = t_RestrictedEventSinkObjectSink->QueryInterface ( IID_IWbemObjectSink , ( void ** ) & t_InterceptedObjectSink ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( m_SecurityDescriptor )
							{
								t_Result = t_RestrictedEventSinkObjectSink->SetSinkSecurity (

									m_SecurityDescriptorLength ,
									m_SecurityDescriptor
								) ;
							}
						}
			}

			t_EventSink->Release () ;
		}
	}

	WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

	IWbemObjectSink *t_TempInterceptedObjectSink = m_InterceptedSink ;
	IWbemEventSink *t_TempRestrictedEventSinkObjectSink = m_EventSink ;

	m_InterceptedSink = t_InterceptedObjectSink ;
	m_EventSink = t_RestrictedEventSinkObjectSink  ;

	WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

	if ( t_TempInterceptedObjectSink )
	{
		t_TempInterceptedObjectSink->Release () ;
	}

	if ( t_TempRestrictedEventSinkObjectSink )
	{
		t_TempRestrictedEventSinkObjectSink->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CDecoupledChild_IWbemObjectSink :: CDecoupledChild_IWbemObjectSink (

	CDecoupledRoot_IWbemObjectSink *a_RootSink
	
) : Decoupled_ObjectSinkContainerElement ( 

		a_RootSink ,
		this
	) ,
 	m_RootSink ( a_RootSink )
{
	m_RootSink->AddRef () ;
}

#pragma warning( default : 4355 )


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupledChild_IWbemObjectSink :: ~CDecoupledChild_IWbemObjectSink ()
{
	m_RootSink->Release () ;

	if ( m_Queries )
	{
		for ( long t_Index = 0 ; t_Index < m_QueryCount ; t_Index ++ )
		{
			SysFreeString ( m_Queries [ t_Index ] ) ;
		}

		delete [] m_Queries ;
		m_Queries = NULL ;
	}

	if ( m_Callback )
	{
		m_Callback->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CDecoupledChild_IWbemObjectSink :: AddRef () 
{
	return Decoupled_ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CDecoupledChild_IWbemObjectSink :: Release ()
{
	return Decoupled_ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledChild_IWbemObjectSink :: SinkInitialize (

	long a_QueryCount ,
	const LPCWSTR *a_Queries ,
	IUnknown *a_Callback
) 
{
	HRESULT t_Result = S_OK ;

	if ( m_Callback )
	{
		m_Callback->Release () ;
	}

	m_Callback = a_Callback ;
	if ( m_Callback )
	{
		m_Callback->AddRef () ;
	}

	if ( m_Queries )
	{
		for ( long t_Index = 0 ; t_Index < m_QueryCount ; t_Index ++ )
		{
			SysFreeString ( m_Queries [ t_Index ] ) ;
		}

		delete [] m_Queries ;
		m_Queries = NULL ;
	}

	m_QueryCount = a_QueryCount ;
	if ( a_Queries )
	{
		m_Queries = new wchar_t * [ m_QueryCount ] ;
		if ( m_Queries )
		{
			for ( long t_Index = 0 ; t_Index < m_QueryCount ; t_Index ++ )
			{
				m_Queries [ t_Index ] = NULL ;
			}

			for ( t_Index = 0 ; t_Index < m_QueryCount ; t_Index ++ )
			{
				try
				{
					m_Queries [ t_Index ] = SysAllocString ( a_Queries [ t_Index ] ) ;
					if ( m_Queries [ t_Index ] )
					{
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
						break ;
					}
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CDecoupledChild_IWbemObjectSink :: GetRestrictedSink (

	long a_QueryCount ,
    const LPCWSTR *a_Queries ,
    IUnknown *a_Callback ,
    IWbemEventSink **a_Sink
)
{
	return m_RootSink->GetRestrictedSink (

		a_QueryCount ,
		a_Queries ,
		a_Callback ,
		a_Sink
	) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CDecoupledRoot_IWbemObjectSink :: AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CDecoupledRoot_IWbemObjectSink :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;

		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledRoot_IWbemObjectSink :: GetRestrictedSink (

	long a_QueryCount ,
    const LPCWSTR *a_Queries ,
    IUnknown *a_Callback ,
    IWbemEventSink **a_Sink
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		if ( a_Sink )
		{
			*a_Sink = NULL ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			InterlockedIncrement ( & m_InProgress ) ;

			try
			{
				if ( m_GateClosed == 1 )
				{
					t_Result = WBEM_E_SHUTTING_DOWN ;
				}
				else
				{
					WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

					IWbemEventSink *t_ObjectSink = m_EventSink ;
					if ( t_ObjectSink )
					{
						t_ObjectSink->AddRef () ;
					}

					WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

					if ( t_ObjectSink )
					{
						t_Result = t_ObjectSink->GetRestrictedSink ( 

								a_QueryCount ,
								a_Queries ,
								a_Callback ,
								a_Sink
						) ;

						t_ObjectSink->Release () ;
					}
					else
					{
						CDecoupledChild_IWbemObjectSink *t_RestrictedSink = new CDecoupledChild_IWbemObjectSink ( this ) ;
						if ( t_RestrictedSink )
						{
							t_RestrictedSink->AddRef () ;

							t_Result = t_RestrictedSink->SinkInitialize (

								a_QueryCount ,
								a_Queries ,
								a_Callback
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								Lock () ;

								CWbemGlobal_Decoupled_IWmiObjectSinkController_Container_Iterator t_Iterator ;

								WmiStatusCode t_StatusCode = Insert (
								
									*t_RestrictedSink ,
									t_Iterator
								) ;

								if ( t_StatusCode == e_StatusCode_Success )
								{
									*a_Sink = t_RestrictedSink ;
								}
								else
								{
									t_RestrictedSink->Release () ;

									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								UnLock () ;
							}
							else
							{
								t_RestrictedSink->Release () ;
							}
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
				}
			}
			catch ( ... )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			InterlockedDecrement ( & m_InProgress ) ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderEvents :: CServerObject_ProviderEvents (

	WmiAllocator &a_Allocator 

) : CServerObject_ProviderRegistrar_Base ( a_Allocator ) ,
	m_Allocator ( a_Allocator ) ,
	m_ReferenceCount ( 0 ) ,
	m_InternalReferenceCount ( 0 ) ,
	m_ObjectSink ( NULL ) ,
	m_Service ( NULL ) ,
	m_Provider ( NULL ),
	m_SinkCriticalSection (NOTHROW_LOCK)
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderEvents_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

	WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_SinkCriticalSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderEvents::~CServerObject_ProviderEvents ()
{
	WmiHelper :: DeleteCriticalSection ( & m_SinkCriticalSection ) ;

	if ( m_Provider ) 
	{
		m_Provider->Release () ;
	}

	if ( m_Service ) 
	{
		m_Service->Release () ;
	}

	if ( m_ObjectSink )
	{
		m_ObjectSink->Release () ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderEvents_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_ProviderEvents::QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	else if ( a_Riid == IID_IWbemDecoupledRegistrar )
	{
		*a_Void = ( LPVOID ) ( IWbemDecoupledRegistrar * ) ( CServerObject_ProviderRegistrar_Base * ) this ;		
	}	
	else if ( a_Riid == IID_IWbemDecoupledBasicEventProvider )
	{
		*a_Void = ( LPVOID ) ( IWbemDecoupledBasicEventProvider * ) this ;		
	}	

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_ProviderEvents :: AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 1 )
	{
		InternalAddRef () ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_ProviderEvents :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		if ( m_Provider )
		{
			m_Provider->Release () ;
			m_Provider = NULL ;
		}

		InternalRelease () ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_ProviderEvents :: InternalAddRef ()
{
	return InterlockedIncrement ( & m_InternalReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_ProviderEvents :: InternalRelease ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_InternalReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderEvents :: Register (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	IUnknown *a_Unknown 
) 
{
	HRESULT t_Result = S_OK ;

	if ( a_Scope == NULL || a_Registration == NULL )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	if (FAILED(t_Result = AcquireLock()))
	{
		return t_Result;
	};

	try 
	{
		if ( m_Registered == FALSE )
		{
			IWbemLocator *t_Locator = NULL ;

			t_Result = CoCreateInstance (

				CLSID_WbemLocator ,
				NULL ,
				CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
				IID_IUnknown ,
				( void ** )  & t_Locator
			);

			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemServices *t_Service = NULL ;

				BSTR t_Namespace = SysAllocString ( a_Scope ) ;
				if ( t_Namespace )
				{
					t_Result = t_Locator->ConnectServer (

						t_Namespace ,
						NULL ,
						NULL,
						NULL ,
						0 ,
						NULL,
						NULL,
						&t_Service
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						m_Service = t_Service ;
					}

					SysFreeString ( t_Namespace ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				t_Locator->Release () ;
			}

			if ( SUCCEEDED ( t_Result ) ) 
			{
				WmiHelper :: EnterCriticalSection ( & m_SinkCriticalSection ) ;

				m_ObjectSink = new CDecoupledRoot_IWbemObjectSink ( m_Allocator ) ;
				if ( m_ObjectSink )
				{
					m_ObjectSink->AddRef () ;
					t_Result = m_ObjectSink->SinkInitialize () ;
					if ( SUCCEEDED ( t_Result ) ) 
					{
					}
					else
					{
						m_ObjectSink->Release ();
						m_ObjectSink = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				WmiHelper :: LeaveCriticalSection ( & m_SinkCriticalSection ) ;
			}

			if ( SUCCEEDED ( t_Result ) ) 
			{
				m_Provider = new CEventProvider (

					m_Allocator ,
					this ,
					a_Unknown 
				) ;

				if ( m_Provider )
				{
					m_Provider->AddRef () ;

					t_Result = m_Provider->Initialize () ;
					if ( SUCCEEDED ( t_Result ) )
					{
						IUnknown *t_Unknown = NULL ;
						t_Result = m_Provider->QueryInterface ( IID_IUnknown , ( void ** ) & t_Unknown ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CServerObject_ProviderRegistrar_Base :: Register ( 

								a_Flags ,
								a_Context ,
								a_User ,
								a_Locale ,
								a_Scope ,
								a_Registration ,
								t_Unknown
							) ;

							t_Unknown->Release () ;
						}
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				WmiHelper :: EnterCriticalSection ( & m_SinkCriticalSection ) ;

				if ( m_ObjectSink )
				{
					m_ObjectSink->Release () ;
					m_ObjectSink = NULL ;
				}

				WmiHelper :: LeaveCriticalSection ( & m_SinkCriticalSection ) ;

				if ( m_Provider )
				{
					m_Provider->Release () ;
					m_Provider = NULL ;
				}

				if ( m_Service ) 
				{
					m_Service->Release () ;
					m_Service = NULL ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_FAILED ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	ReleaseLock();

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderEvents :: UnRegister ()
{
	HRESULT t_Result = S_OK ;

	if (FAILED(t_Result = AcquireLock()))
	{
		return t_Result;
	};


	try 
	{
		if ( m_Registered )
		{
			t_Result = CServerObject_ProviderRegistrar_Base :: UnRegister () ; 

			if ( m_Provider ) 
			{
				m_Provider->UnRegister () ;
				m_Provider->Release () ;
				m_Provider = NULL ;
			}

			if ( m_Service )
			{
				m_Service->Release () ;
				m_Service = NULL ;
			}

			if ( m_ObjectSink )
			{
				m_ObjectSink->Release () ;
				m_ObjectSink = NULL ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_REGISTERED ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	ReleaseLock();

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderEvents :: GetSink (

	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink **a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	if (FAILED(t_Result = AcquireLock()))
	{
		return t_Result;
	};

	try 
	{
		if ( m_Registered )
		{
			if ( a_Sink )
			{	
				*a_Sink = m_ObjectSink ;
				m_ObjectSink->AddRef () ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_REGISTERED ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	ReleaseLock();

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderEvents :: GetService (

	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_Service
) 
{
	HRESULT t_Result = S_OK ;

	if (FAILED(t_Result = AcquireLock()))
	{
		return t_Result;
	};


	try
	{
		if ( m_Registered )
		{
			if ( a_Service )
			{	
				*a_Service = m_Service ;
				m_Service->AddRef () ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_REGISTERED ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	ReleaseLock();

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\provregistrar.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include <PreComp.h>
#include <wbemint.h>

#include <CGlobals.h>
#include <DateTime.h>
#include <ProvRegInfo.h>
#include <ProvRegDecoupled.h>

#include "Globals.h"
#include "Guids.h"

#include "ProvInterceptor.h"
#include "ProvRegistrar.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRegistrar_Base :: CServerObject_ProviderRegistrar_Base (

	WmiAllocator &a_Allocator 

) : 
	m_Allocator ( a_Allocator ) ,
	m_Clsid ( NULL ) ,
	m_Provider ( NULL ) ,
	m_User ( NULL ) ,
	m_Locale ( NULL ) ,
	m_Scope ( NULL ) ,
	m_Registration ( NULL ) ,
	m_Registered ( FALSE ) ,
	m_MarshaledProxy ( NULL ) ,
	m_MarshaledProxyLength ( 0 ) ,
	m_registrationEvent(NULL)
{
	ZeroMemory ( & m_Identity , sizeof ( m_Identity ) ) ;
}


HRESULT CServerObject_ProviderRegistrar_Base :: AcquireLock(void)
{

	DWORD index = 0;
	HRESULT result = CoWaitForMultipleHandles(COWAIT_WAITALL , DEFAULT_PROVIDER_TIMEOUT, 1, &m_registrationEvent, &index); 
	return result;
}
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRegistrar_Base::~CServerObject_ProviderRegistrar_Base ()
{
	if ( m_Provider )
	{
		m_Provider->Release () ;
	}

	if ( m_Clsid )
	{
		SysFreeString ( m_Clsid ) ;
	}

	if ( m_User )
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_Scope ) 
	{
		SysFreeString ( m_Scope ) ;
	}

	if ( m_Registration )
	{
		SysFreeString ( m_Registration ) ;
	}

	if ( m_MarshaledProxy )
	{
		ProviderSubSystem_Common_Globals :: ReleaseRegistration (

			m_MarshaledProxy ,
			m_MarshaledProxyLength
		) ;

		delete [] m_MarshaledProxy ;
		m_MarshaledProxy = NULL ;
		m_MarshaledProxyLength = 0 ;
	}

	CloseHandle(m_registrationEvent);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrar_Base :: Initialize ()
{
	m_registrationEvent = CreateMutex(0, FALSE, 0);
	if ( NULL != m_registrationEvent) 
	{
		return S_OK ;
	}
	else
	{
		return WBEM_E_OUT_OF_MEMORY ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrar_Base :: SaveToRegistry (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Registration ,
	LPCWSTR a_Scope ,
	IUnknown *a_Unknown ,
	BYTE *a_MarshaledProxy ,
	DWORD a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	CServerObject_DecoupledClientRegistration_Element t_Element ;

	BSTR t_CreationTime = NULL ;

	FILETIME t_CreationFileTime ;
	FILETIME t_ExitFileTime ;
	FILETIME t_KernelFileTime ;
	FILETIME t_UserFileTime ;

	BOOL t_Status = GetProcessTimes (

		  GetCurrentProcess (),
		  & t_CreationFileTime,
		  & t_ExitFileTime,
		  & t_KernelFileTime,
		  & t_UserFileTime
	);

	if ( t_Status ) 
	{
		CWbemDateTime t_Time ;
		t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;

		t_Result = t_Time.GetValue ( & t_CreationTime ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Element.SetProcessIdentifier ( GetCurrentProcessId () ) ;

			if ( SUCCEEDED ( t_Result ) ) 
			{
				if ( a_Locale ) 
				{
					t_Result = t_Element.SetLocale ( ( BSTR ) a_Locale ) ;
				}
			}

			if ( SUCCEEDED ( t_Result ) ) 
			{
				if ( a_User ) 
				{
					t_Result = t_Element.SetUser ( ( BSTR ) a_User ) ;
				}
			}

			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_Element.SetProvider ( ( BSTR ) a_Registration ) ;
			}

			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_Element.SetScope ( ( BSTR ) a_Scope ) ;
			}

			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_Element.SetCreationTime ( ( BSTR ) t_CreationTime ) ;
			}

			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_Element.SetMarshaledProxy ( a_MarshaledProxy , a_MarshaledProxyLength ) ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Element.Save ( m_Clsid ) ;
			}

			SysFreeString ( t_CreationTime ) ;
		}
		else
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
	}
	else
	{
		t_Result = WBEM_E_UNEXPECTED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrar_Base :: DirectRegister (

	GUID &a_Identity ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Registration ,
	LPCWSTR a_Scope ,
	IUnknown *a_Unknown ,
	BYTE *a_MarshaledProxy ,
	DWORD a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	CServerObject_DecoupledServerRegistration t_Element ( m_Allocator ) ;

	BSTR t_CreationTime = NULL ;

	FILETIME t_CreationFileTime ;
	FILETIME t_ExitFileTime ;
	FILETIME t_KernelFileTime ;
	FILETIME t_UserFileTime ;

	BOOL t_Status = GetProcessTimes (

		  GetCurrentProcess (),
		  & t_CreationFileTime,
		  & t_ExitFileTime,
		  & t_KernelFileTime,
		  & t_UserFileTime
	);

	if ( t_Status ) 
	{
		CWbemDateTime t_Time ;
		t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;

		t_Result = t_Time.GetValue ( & t_CreationTime ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Element.Load () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BSTR t_ServerCreationTime = t_Element.GetCreationTime () ;
				DWORD t_ProcessIdentifier = t_Element.GetProcessIdentifier () ;
				BYTE *t_MarshaledProxy = t_Element.GetMarshaledProxy () ;
				DWORD t_MarshaledProxyLength = t_Element.GetMarshaledProxyLength () ;

				IUnknown *t_Unknown = NULL ;
				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: UnMarshalRegistration ( & t_Unknown , t_MarshaledProxy , t_MarshaledProxyLength ) ;
				if ( SUCCEEDED ( t_TempResult ) )
				{
					_IWmiProviderSubsystemRegistrar *t_Registrar = NULL ;
						
					t_Result = t_Unknown->QueryInterface ( IID__IWmiProviderSubsystemRegistrar , ( void ** ) & t_Registrar ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						BOOL t_Impersonating = FALSE ;
						IUnknown *t_OldContext = NULL ;
						IServerSecurity *t_OldSecurity = NULL ;

						t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							BOOL t_Revert = FALSE ;
							IUnknown *t_Proxy = NULL ;

							t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID__IWmiProviderSubsystemRegistrar , t_Registrar , t_Proxy , t_Revert ) ;
							if ( t_Result == WBEM_E_NOT_FOUND )
							{
								try
								{
									t_Result = t_Registrar->Register ( 

										0 ,
										a_Context ,
										a_User ,
										a_Locale ,
										a_Scope ,
										a_Registration ,
										GetCurrentProcessId () ,
										a_Unknown ,
										a_Identity 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}
							}
							else
							{
								if ( SUCCEEDED ( t_Result ) )
								{
									_IWmiProviderSubsystemRegistrar *t_RegistrarProxy = ( _IWmiProviderSubsystemRegistrar * ) t_Proxy ;

									// Set cloaking on the proxy
									// =========================

									DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

									t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

										t_RegistrarProxy ,
										RPC_C_AUTHN_LEVEL_DEFAULT , 
										t_ImpersonationLevel
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
									    t_Result = CoImpersonateClient () ;
										if ( SUCCEEDED ( t_Result ) )
										{
											try
											{
												t_Result = t_RegistrarProxy->Register ( 

													0 ,
													a_Context ,
													a_User ,
													a_Locale ,
													a_Scope ,
													a_Registration ,
													GetCurrentProcessId () ,
													a_Unknown ,
													a_Identity 
												) ;
											}
											catch ( ... )
											{
												t_Result = WBEM_E_PROVIDER_FAILURE ;
											}

											CoRevertToSelf () ;
										}
										else
										{
											t_Result = WBEM_E_ACCESS_DENIED ;
										}
									}	

									ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
								}
							}

							ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
						}

						t_Registrar->Release () ;
					}

					t_Unknown->Release () ;
				}
			}
			else
			{
				t_Result = S_OK ;
			}

			SysFreeString ( t_CreationTime ) ;
		}
		else
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
	}
	else
	{
		t_Result = WBEM_E_UNEXPECTED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrar_Base :: DirectUnRegister (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Registration ,
	LPCWSTR a_Scope ,
	GUID &a_Identity  
)
{
	HRESULT t_Result = S_OK ;

	CServerObject_DecoupledServerRegistration t_Element ( m_Allocator ) ;

	FILETIME t_CreationFileTime ;
	FILETIME t_ExitFileTime ;
	FILETIME t_KernelFileTime ;
	FILETIME t_UserFileTime ;

	BOOL t_Status = GetProcessTimes (

		  GetCurrentProcess (),
		  & t_CreationFileTime,
		  & t_ExitFileTime,
		  & t_KernelFileTime,
		  & t_UserFileTime
	);

	if ( t_Status ) 
	{
		t_Result = t_Element.Load () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			BSTR const t_CreationTime = t_Element.GetCreationTime () ;
			DWORD t_ProcessIdentifier = t_Element.GetProcessIdentifier () ;
			BYTE *t_MarshaledProxy = t_Element.GetMarshaledProxy () ;
			DWORD t_MarshaledProxyLength = t_Element.GetMarshaledProxyLength () ;

			IUnknown *t_Unknown = NULL ;
			t_Result = ProviderSubSystem_Common_Globals :: UnMarshalRegistration ( & t_Unknown , t_MarshaledProxy , t_MarshaledProxyLength ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				_IWmiProviderSubsystemRegistrar *t_Registrar = NULL ;
					
				t_Result = t_Unknown->QueryInterface ( IID__IWmiProviderSubsystemRegistrar , ( void ** ) & t_Registrar ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					BOOL t_Impersonating = FALSE ;
					IUnknown *t_OldContext = NULL ;
					IServerSecurity *t_OldSecurity = NULL ;

					t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						BOOL t_Revert = FALSE ;
						IUnknown *t_Proxy = NULL ;

						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID__IWmiProviderSubsystemRegistrar , t_Registrar , t_Proxy , t_Revert ) ;
						if ( t_Result == WBEM_E_NOT_FOUND )
						{
							try
							{
								t_Result = t_Registrar->UnRegister ( 

									0 ,
									a_Context ,
									a_User ,
									a_Locale ,
									a_Scope ,
									a_Registration ,
									a_Identity 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}
						}
						else
						{
							if ( SUCCEEDED ( t_Result ) )
							{
								_IWmiProviderSubsystemRegistrar *t_RegistrarProxy = ( _IWmiProviderSubsystemRegistrar * ) t_Proxy ;

								// Set cloaking on the proxy
								// =========================

								DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

								t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

									t_RegistrarProxy ,
									RPC_C_AUTHN_LEVEL_DEFAULT , 
									t_ImpersonationLevel
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = CoImpersonateClient () ;
									if ( SUCCEEDED ( t_Result ) )
									{
										try
										{
											t_Result = t_RegistrarProxy->UnRegister ( 

												0 ,
												a_Context ,
												a_User ,
												a_Locale ,
												a_Scope ,
												a_Registration ,
												a_Identity 
											) ;
										}
										catch ( ... )
										{
											t_Result = WBEM_E_PROVIDER_FAILURE ;
										}

										CoRevertToSelf () ;
									}
									else
									{
										t_Result = WBEM_E_ACCESS_DENIED ;
									}
								}	

								HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
							}
						}

						ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
					}

					t_Registrar->Release () ;
				}

				t_Unknown->Release () ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: ReleaseRegistration (

				m_MarshaledProxy ,
				m_MarshaledProxyLength
			) ;

			delete [] m_MarshaledProxy ;
			m_MarshaledProxy = NULL ;
			m_MarshaledProxyLength = 0 ;
		}
	}
	else
	{
		t_Result = WBEM_E_UNEXPECTED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrar_Base :: CreateInterceptor (

	IWbemContext *a_Context ,
	IUnknown *a_Unknown ,
	BYTE *&a_MarshaledProxy ,
	DWORD &a_MarshaledProxyLength ,
	IUnknown *&a_MarshaledUnknown
)
{
	IWbemLocator *t_Locator = NULL ;
	IWbemServices *t_Service = NULL ;
	CServerObject_ProviderRegistrationV1 *t_Registration = NULL ;

	HRESULT t_Result = CoCreateInstance (

		CLSID_WbemLocator ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IUnknown ,
		( void ** )  & t_Locator
	);

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_Locator->ConnectServer (

			m_Scope ,
			NULL ,
			NULL,
			NULL ,
			0 ,
			NULL,
			NULL,
			& t_Service
		) ;

		t_Locator->Release () ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Registration = new CServerObject_ProviderRegistrationV1 ;
		if ( t_Registration )
		{
			t_Registration->AddRef () ;

			IWbemPath *t_NamespacePath = NULL ;

			t_Result = CoCreateInstance (

				CLSID_WbemDefPath ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IWbemPath ,
				( void ** )  & t_NamespacePath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_NamespacePath->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , m_Scope ) ;
			}

			if ( SUCCEEDED( t_Result ) ) 
			{
				t_Result = t_Registration->SetContext ( 

					a_Context ,
					t_NamespacePath , 
					t_Service
				) ;
				
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Registration->Load ( 

						e_All ,
						NULL , 
						m_Registration
					) ;

					if ( t_Result == WBEM_E_NOT_FOUND )
					{
						t_Result = WBEM_E_PROVIDER_NOT_FOUND ;
					}
				}
			}

			if ( t_NamespacePath )
			{
				t_NamespacePath->Release () ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		CInterceptor_DecoupledClient *t_Provider = new CInterceptor_DecoupledClient ( 

			m_Allocator ,
			a_Unknown , 
			t_Service ,
			*t_Registration
		) ;
		
		if ( t_Provider )
		{
			t_Provider->AddRef () ;

			t_Result = t_Provider->ProviderInitialize () ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_Provider->QueryInterface ( IID_IUnknown , ( void ** ) & a_MarshaledUnknown ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: MarshalRegistration ( 

						a_MarshaledUnknown ,
						a_MarshaledProxy ,
						a_MarshaledProxyLength
					) ;

					if ( FAILED ( t_Result ) )
					{
						a_MarshaledUnknown->Release () ;
						a_MarshaledUnknown = NULL ;
					}
				}
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				m_Provider = t_Provider ;
			}
			else
			{
				t_Provider->Release () ;
			}
		}
	}

	if ( t_Registration )
	{
		t_Registration->Release () ;
	}

	if ( t_Service )
	{
		t_Service->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrar_Base :: Register (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	IUnknown *a_Unknown
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Scope == NULL || a_Registration == NULL || a_Unknown == NULL )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	if (FAILED(t_Result = AcquireLock()))
	{
		return t_Result;
	};
	
	try
	{
		if ( m_Registered == FALSE )
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = CoCreateGuid ( & m_Identity ) ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				BSTR t_Clsid = NULL ;

				t_Result = StringFromCLSID (

				  m_Identity ,
				  & t_Clsid
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( m_Clsid ) 
					{
						SysFreeString ( m_Clsid ) ;
						m_Clsid = NULL ;
					}

					if ( m_User )
					{
						SysFreeString ( m_User ) ;
						m_User = NULL ;
					}

					if ( m_Locale ) 
					{
						SysFreeString ( m_Locale ) ;
						m_Locale = NULL ;
					}

					if ( m_Scope ) 
					{
						SysFreeString ( m_Scope ) ;
						m_Scope = NULL ;
					}

					if ( m_Registration )
					{
						SysFreeString ( m_Registration ) ;
						m_Registration = NULL ;
					}

					m_Clsid = SysAllocString ( t_Clsid ) ;
					if ( m_Clsid == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( a_User )
					{
						m_User = SysAllocString ( a_User ) ;
						if ( m_User == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( m_Locale )
					{
						m_Locale = SysAllocString ( a_Locale ) ;
						if ( m_Locale == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					m_Scope = SysAllocString ( a_Scope ) ;
					if ( m_Scope == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					m_Registration = SysAllocString ( a_Registration ) ;
					if ( m_Registration == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						IUnknown *t_MarshaledUnknown = NULL ;

						t_Result = CreateInterceptor (

							a_Context ,
							a_Unknown ,
							m_MarshaledProxy ,
							m_MarshaledProxyLength ,
							t_MarshaledUnknown
						) ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							t_Result = DirectRegister (

								m_Identity ,
								a_Flags ,
								a_Context ,
								a_User ,
								a_Locale ,
								a_Registration ,
								a_Scope ,
								t_MarshaledUnknown ,
								m_MarshaledProxy ,
								m_MarshaledProxyLength
							) ;
						}

						if ( t_MarshaledUnknown )
						{
							t_MarshaledUnknown->Release () ;
						}
					}

					CoTaskMemFree ( t_Clsid ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_UNEXPECTED ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_ALREADY_REGISTERED ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_Registered = TRUE ;
	}

	ReleaseLock();

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrar_Base :: UnRegister ()
{
	HRESULT t_Result = S_OK ;

	if (FAILED(t_Result = AcquireLock()))
	{
		return t_Result;
	};

	try
	{
		if ( m_Registered ) 
		{
			CServerObject_DecoupledClientRegistration_Element t_Element ;
			t_Result = t_Element.Load ( m_Clsid ) ;

			t_Result = DirectUnRegister ( 

				0 ,
				NULL ,
				m_User ,
				m_Locale ,
				m_Registration ,
				m_Scope ,
				m_Identity
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( m_Provider )
				{
					m_Provider->Release () ;
					m_Provider = NULL ;
				}

				m_Registered = FALSE ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_REGISTERED ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	ReleaseLock();

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRegistrar :: CServerObject_ProviderRegistrar (

	WmiAllocator &a_Allocator 

) : CServerObject_ProviderRegistrar_Base ( a_Allocator ) ,
	m_ReferenceCount ( 0 ) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderRegistrar_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRegistrar::~CServerObject_ProviderRegistrar ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderRegistrar_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_ProviderRegistrar::QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	else if ( a_Riid == IID_IWbemDecoupledRegistrar )
	{
		*a_Void = ( LPVOID ) ( IWbemDecoupledRegistrar * ) this ;		
	}	

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_ProviderRegistrar :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_ProviderRegistrar :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\include\globals.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _Globals_H
#define _Globals_H

#include <pssException.h>
#include <Allocator.h>
#include <BasicTree.h>
#include <Cache.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DecoupledProviderSubSystem_Globals
{
public:

	static WmiAllocator *s_Allocator ;

	static LONG s_LocksInProgress ;
	static LONG s_ObjectsInProgress ;

    static LONG s_CServerClassFactory_ObjectsInProgress ;
	static LONG s_CServerObject_ProviderRegistrar_ObjectsInProgress  ;
	static LONG s_CServerObject_ProviderEvents_ObjectsInProgress ;
	static LONG s_CInterceptor_DecoupledClient_ObjectsInProgress ;
	static LONG s_CDecoupled_IWbemSyncObjectSink_ObjectsInProgress ;
	static LONG s_CDecoupled_Batching_IWbemSyncObjectSink_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemDecoupledUnboundObjectSink_ObjectsInProgress ;

	static HRESULT Global_Startup () ;
	static HRESULT Global_Shutdown () ;

	static HRESULT BeginThreadImpersonation (

		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating
	) ;

	static HRESULT EndThreadImpersonation (

		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_Impersonating 
	) ;

	static HRESULT Begin_IdentifyCall_PrvHost (

		WmiInternalContext a_InternalContext ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity
	) ;

	static HRESULT End_IdentifyCall_PrvHost (

		WmiInternalContext a_InternalContext ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating 
	) ;

	static HRESULT Begin_IdentifyCall_SvcHost (

		WmiInternalContext a_InternalContext ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity
	) ;

	static HRESULT End_IdentifyCall_SvcHost (

		WmiInternalContext a_InternalContext ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating
	) ;

	static HRESULT AdjustSecurityDescriptorWithSystemSid ( 

		SECURITY_DESCRIPTOR *&a_SecurityDescriptor , 
		SECURITY_DESCRIPTOR *&a_AlteredSecurityDescriptor
	) ;

	static HRESULT OpenTokenToSystem () ;
} ;

#endif // _Globals_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\include\classfac.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ClassFac.h

Abstract:


History:

--*/

#ifndef _ServerClassFactory_H
#define _ServerClassFactory_H

#include "ProvRegistrar.h"
#include "ProvEvents.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
class CServerClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

    CServerClassFactory () ;
    ~CServerClassFactory () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

#include <classfac.cpp>

#endif // _ServerClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\include\provevents.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Server_ProviderEvent_H
#define _Server_ProviderEvent_H

#include "Globals.h"
#include "ProvRegistrar.h"
#include "ProvEvt.h"
#include <lockst.h>
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupledChild_IWbemObjectSink ;
class CDecoupledRoot_IWbemObjectSink ;

typedef WmiContainerController <CDecoupledChild_IWbemObjectSink *>					CWbemGlobal_Decoupled_IWmiObjectSinkController ;
typedef CWbemGlobal_Decoupled_IWmiObjectSinkController :: Container					CWbemGlobal_Decoupled_IWmiObjectSinkController_Container ;
typedef CWbemGlobal_Decoupled_IWmiObjectSinkController :: Container_Iterator		CWbemGlobal_Decoupled_IWmiObjectSinkController_Container_Iterator ;
typedef CWbemGlobal_Decoupled_IWmiObjectSinkController :: WmiContainerElement		Decoupled_ObjectSinkContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupled_IWbemObjectSink :		public IWbemEventSink , 
										public IWbemShutdown
{
private:
protected:

	long m_SecurityDescriptorLength ;
	BYTE *m_SecurityDescriptor ;

	CriticalSection m_CriticalSection ;

	IWbemObjectSink *m_InterceptedSink ;
	IWbemEventSink *m_EventSink ;

	LONG m_GateClosed ;
	LONG m_InProgress ;
	LONG m_StatusCalled ;

public:

	CDecoupled_IWbemObjectSink () ;

	~CDecoupled_IWbemObjectSink () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

    HRESULT STDMETHODCALLTYPE IndicateWithSD (

		long a_ObjectsCount ,
		IUnknown **a_Objects ,
		long a_SecurityDescriptorLength ,
		BYTE *a_SecurityDescriptor
	) ;

    HRESULT STDMETHODCALLTYPE SetSinkSecurity (

		long a_SecurityDescriptorLength ,
		BYTE *a_SecurityDescriptor
	) ;

    HRESULT STDMETHODCALLTYPE IsActive () ;

    HRESULT STDMETHODCALLTYPE SetBatchingParameters (

		LONG a_Flags,
		DWORD a_MaxBufferSize,
		DWORD a_MaxSendLatency
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupledRoot_IWbemObjectSink :		public CDecoupled_IWbemObjectSink ,
											public CWbemGlobal_Decoupled_IWmiObjectSinkController
{
private:

	LONG m_ReferenceCount ;

	WmiAllocator &m_Allocator ;

public:

	CDecoupledRoot_IWbemObjectSink (
	
		WmiAllocator &a_Allocator 

	) : CWbemGlobal_Decoupled_IWmiObjectSinkController ( a_Allocator ) , 
		m_Allocator ( a_Allocator ) ,
		m_ReferenceCount ( 0 )
	{ ; }

	~CDecoupledRoot_IWbemObjectSink ()
	{
		CWbemGlobal_Decoupled_IWmiObjectSinkController :: UnInitialize () ;
	}

    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT SinkInitialize () ;

	HRESULT SetSink ( IWbemObjectSink *a_Sink ) ;

    HRESULT STDMETHODCALLTYPE GetRestrictedSink (

		long a_QueryCount ,
        const LPCWSTR *a_Queries ,
        IUnknown *a_Callback ,
        IWbemEventSink **a_Sink
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupledChild_IWbemObjectSink :		public CDecoupled_IWbemObjectSink ,
											public Decoupled_ObjectSinkContainerElement
{
private:

	CDecoupledRoot_IWbemObjectSink *m_RootSink ;
	long m_QueryCount ;
    LPWSTR *m_Queries ;
    IUnknown *m_Callback ;

public:

	CDecoupledChild_IWbemObjectSink (
	
		CDecoupledRoot_IWbemObjectSink *a_RootSink
	) ;

	~CDecoupledChild_IWbemObjectSink () ;

    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT SinkInitialize (

		long a_QueryCount ,
		const LPCWSTR *a_Queries ,
		IUnknown *a_Callback
	) ;

    HRESULT STDMETHODCALLTYPE GetRestrictedSink (

		long a_QueryCount ,
        const LPCWSTR *a_Queries ,
        IUnknown *a_Callback ,
        IWbemEventSink **a_Sink
	) ;

	HRESULT SetSink ( IWbemObjectSink *a_Sink ) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderEvents :	public CServerObject_ProviderRegistrar_Base ,
										public IWbemDecoupledBasicEventProvider
{
private:

	WmiAllocator &m_Allocator ;

	CriticalSection m_SinkCriticalSection ;

    long m_ReferenceCount ;
	long m_InternalReferenceCount ;

	CDecoupledRoot_IWbemObjectSink *m_ObjectSink ;
	CEventProvider *m_Provider ;
	IWbemServices *m_Service ;

protected:

public: /* Internal */

	HRESULT SetSink ( IWbemObjectSink *a_Sink ) 
	{
		WmiHelper :: EnterCriticalSection ( & m_SinkCriticalSection ) ;

		if ( m_ObjectSink )
		{
			CDecoupledRoot_IWbemObjectSink *t_Sink = m_ObjectSink ;

			t_Sink->AddRef () ;
		
			WmiHelper :: LeaveCriticalSection ( & m_SinkCriticalSection ) ;

			HRESULT t_Result = t_Sink->SetSink ( a_Sink ) ;

			t_Sink->Release () ;

			return t_Result ;
		}
		else
		{
			WmiHelper :: LeaveCriticalSection ( & m_SinkCriticalSection ) ;

			return WBEM_E_NOT_AVAILABLE ;
		}
	}

    STDMETHODIMP_( ULONG ) InternalAddRef () ;
    STDMETHODIMP_( ULONG ) InternalRelease () ;

public:	/* External */

	CServerObject_ProviderEvents ( WmiAllocator &a_Allocator ) ;
	~CServerObject_ProviderEvents () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE Register (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		IUnknown *a_Unknown 
	) ;

	HRESULT STDMETHODCALLTYPE UnRegister () ;

	HRESULT STDMETHODCALLTYPE GetSink (

		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink **a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE GetService (

		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemServices **a_Service
	) ;
};

#endif // _Server_ProviderEvent_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\include\provregistrar.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Server_ProviderRegistrar_H
#define _Server_ProviderRegistrar_H

#include "Globals.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_DecoupledClient ;

class CServerObject_ProviderRegistrar_Base : public IWbemDecoupledRegistrar
{
protected:

	WmiAllocator &m_Allocator ;

	HANDLE m_registrationEvent;

	GUID m_Identity ;

	BSTR m_Clsid ;
	BSTR m_User ;
	BSTR m_Locale ;
	BSTR m_Scope ;
	BSTR m_Registration ;

	BOOL m_Registered ;

	BYTE *m_MarshaledProxy ;
	DWORD m_MarshaledProxyLength ;

	CInterceptor_DecoupledClient *m_Provider ;

	HRESULT CreateInterceptor (

		IWbemContext *a_Context ,
		IUnknown *a_Unknown ,
		BYTE *&a_MarshaledProxy ,
		DWORD &a_MarshaledProxyLength ,
		IUnknown *&a_MarshaledUnknown
	) ;

	HRESULT DirectUnRegister (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Registration ,
		LPCWSTR a_Scope ,
		GUID &a_Identity
	) ;

	HRESULT DirectRegister (

		GUID &a_Identity ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Registration ,
		LPCWSTR a_Scope ,
		IUnknown *a_Unknown ,
		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength
	) ;

	HRESULT SaveToRegistry (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Registration ,
		LPCWSTR a_Scope ,
		IUnknown *a_Unknown ,
		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength 
	) ;

protected:

public: /* Internal */

public:	/* External */

	CServerObject_ProviderRegistrar_Base ( WmiAllocator &a_Allocator ) ;
	~CServerObject_ProviderRegistrar_Base () ;

	HRESULT STDMETHODCALLTYPE Register (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		IUnknown *a_Unknown
	) ;

	HRESULT STDMETHODCALLTYPE UnRegister () ;

	HRESULT Initialize () ;
	HRESULT AcquireLock(void);
	void ReleaseLock(void);
};


inline
void CServerObject_ProviderRegistrar_Base::ReleaseLock(void)
{
	ReleaseMutex( m_registrationEvent );
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderRegistrar :	public CServerObject_ProviderRegistrar_Base
{
private:

    long m_ReferenceCount ;

protected:

public: /* Internal */

public:	/* External */

	CServerObject_ProviderRegistrar ( WmiAllocator &a_Allocator ) ;
	~CServerObject_ProviderRegistrar () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;
};

#endif // _Server_ProviderRegistrar_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\include\provinterceptor.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvWsv.H

Abstract:


History:

--*/

#ifndef _Decopled_Interceptor_IWbemServices_H
#define _Decopled_Interceptor_IWbemServices_H

#include <Allocator.h>
#include <Algorithms.h>
#include <TPQueue.h>
#include <BasicTree.h>
#include <Cache.h>

#include <CGlobals.h>
#include <ProvRegInfo.h>
#include <ProvObjectSink.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef WmiContainerController <void *>										CWbemGlobal_VoidPointerController ;
typedef CWbemGlobal_VoidPointerController :: Container						CWbemGlobal_VoidPointerController_Container ;
typedef CWbemGlobal_VoidPointerController :: Container_Iterator				CWbemGlobal_VoidPointerController_Container_Iterator ;
typedef CWbemGlobal_VoidPointerController :: WmiContainerElement			VoidPointerContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemObjectSink ;

#define CWbemGlobal_IWmiObjectSinkController						CWbemGlobal_VoidPointerController
#define CWbemGlobal_IWmiObjectSinkController_Container				CWbemGlobal_VoidPointerController_Container
#define CWbemGlobal_IWmiObjectSinkController_Container_Iterator		CWbemGlobal_VoidPointerController_Container_Iterator
#define ObjectSinkContainerElement									VoidPointerContainerElement

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ProxyIndex_IWbemServices					0
#define ProxyIndex_IWbemPropertyProvider			1
#define ProxyIndex_IWbemEventProvider				2
#define ProxyIndex_IWbemEventProviderQuerySink		3
#define ProxyIndex_IWbemEventProviderSecurity		4
#define ProxyIndex_IWbemProviderIdentity			5
#define ProxyIndex_IWbemEventConsumerProvider		6
#define ProxyIndex_IWbemEventConsumerProviderEx		7
#define ProxyIndex_IWbemUnboundObjectSink			8

#define ProxyIndex_Internal_IWbemServices					9
#define ProxyIndex_Internal_IWbemPropertyProvider			10
#define ProxyIndex_Internal_IWbemEventProvider				11
#define ProxyIndex_Internal_IWbemEventProviderQuerySink		12
#define ProxyIndex_Internal_IWbemEventProviderSecurity		13
#define ProxyIndex_Internal_IWbemEventConsumerProvider		14
#define ProxyIndex_Internal_IWbemEventConsumerProviderEx	15
#define ProxyIndex_Internal_IWbemUnboundObjectSink			16

#define ProxyIndex_IWbemShutdown					17

#define ProxyIndex_Provider_Size					18

#define ProxyIndex_UnBoundSync_IWbemUnboundObjectSink			0
#define ProxyIndex_UnBoundSync_Size								1

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupled_IWbemSyncObjectSink :	public CCommon_IWbemSyncObjectSink
{
private:
protected:
public:

	CDecoupled_IWbemSyncObjectSink (

		WmiAllocator &a_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CDecoupled_IWbemSyncObjectSink () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupled_Batching_IWbemSyncObjectSink :	public CCommon_Batching_IWbemSyncObjectSink
{
private:
protected:
public:

	CDecoupled_Batching_IWbemSyncObjectSink (

		WmiAllocator &a_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CDecoupled_Batching_IWbemSyncObjectSink () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemDecoupledUnboundObjectSink : public IWbemUnboundObjectSink ,
												public Internal_IWbemUnboundObjectSink ,

												public IWbemShutdown , 
												public VoidPointerContainerElement
{
private:

	WmiAllocator &m_Allocator ;
	CServerObject_ProviderRegistrationV1 *m_Registration ;

	IUnknown *m_Unknown ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;

	ProxyContainer m_ProxyContainer ;

protected:
public:

	CInterceptor_IWbemDecoupledUnboundObjectSink (

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideProvider , 
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	~CInterceptor_IWbemDecoupledUnboundObjectSink () ;

	HRESULT Initialize () ;

public:

	STDMETHODIMP QueryInterface ( 

		REFIID iid , 
		LPVOID FAR *iplpv 
	) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE Internal_IndicateToConsumer (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	/* _IWmiProviderSite */

	HRESULT STDMETHODCALLTYPE GetSite ( DWORD *a_ProcessIdentifier ) ;

	HRESULT STDMETHODCALLTYPE SetContainer ( IUnknown *a_Container ) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_DecoupledClient :	public IWbemServices , 
										public IWbemPropertyProvider ,
										public IWbemEventProvider ,
										public IWbemEventProviderQuerySink ,
										public IWbemEventProviderSecurity ,
										public IWbemProviderIdentity ,
										public IWbemEventConsumerProviderEx ,
										public IWbemUnboundObjectSink ,

										public IWbemProviderInit ,
										public Internal_IWbemProviderInit ,

										public Internal_IWbemServices , 
										public Internal_IWbemPropertyProvider ,
										public Internal_IWbemEventProvider ,
										public Internal_IWbemEventProviderQuerySink ,
										public Internal_IWbemEventProviderSecurity ,
										public Internal_IWbemEventConsumerProviderEx ,
										public Internal_IWbemUnboundObjectSink ,

										public _IWmiProviderSite ,
										public IWbemShutdown , 
										public CWbemGlobal_IWmiObjectSinkController 
{
private:

	LONG m_ReferenceCount ;

	IUnknown *m_Unknown ;
	IWbemServices *m_Provider_IWbemServices ;
	IWbemPropertyProvider *m_Provider_IWbemPropertyProvider ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;
	IWbemProviderIdentity *m_Provider_IWbemProviderIdentity ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemEventConsumerProviderEx *m_Provider_IWbemEventConsumerProviderEx ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;

	IWbemServices *m_CoreStub ;

	WmiAllocator &m_Allocator ;

	ProxyContainer m_ProxyContainer ;

	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Namespace ;
	BSTR m_TransactionIdentifier ;

public:

	CServerObject_ProviderRegistrationV1 *m_Registration ;

	UINT64 m_ProviderOperation_GetObjectAsync ;
	UINT64 m_ProviderOperation_PutClassAsync ;
	UINT64 m_ProviderOperation_DeleteClassAsync ;
	UINT64 m_ProviderOperation_CreateClassEnumAsync ;
	UINT64 m_ProviderOperation_PutInstanceAsync ;
	UINT64 m_ProviderOperation_DeleteInstanceAsync ;
	UINT64 m_ProviderOperation_CreateInstanceEnumAsync ;
	UINT64 m_ProviderOperation_ExecQueryAsync ;
	UINT64 m_ProviderOperation_ExecNotificationQueryAsync ;
	UINT64 m_ProviderOperation_ExecMethodAsync ;

	UINT64 m_ProviderOperation_Begin ;
	UINT64 m_ProviderOperation_Rollback ;
	UINT64 m_ProviderOperation_Commit ;
	UINT64 m_ProviderOperation_QueryState ;

	UINT64 m_ProviderOperation_QueryInstances ;
	UINT64 m_ProviderOperation_CreateRefresher ;
	UINT64 m_ProviderOperation_CreateRefreshableObject ;
	UINT64 m_ProviderOperation_StopRefreshing ;
	UINT64 m_ProviderOperation_CreateRefreshableEnum ;
	UINT64 m_ProviderOperation_GetObjects ;

	UINT64 m_ProviderOperation_GetProperty ;
	UINT64 m_ProviderOperation_PutProperty ;

	UINT64 m_ProviderOperation_ProvideEvents ;
	UINT64 m_ProviderOperation_NewQuery ;
	UINT64 m_ProviderOperation_CancelQuery ;
	UINT64 m_ProviderOperation_AccessCheck ;
	UINT64 m_ProviderOperation_SetRegistrationObject ;
	UINT64 m_ProviderOperation_FindConsumer ;
	UINT64 m_ProviderOperation_ValidateSubscription ;

	void Increment_ProviderOperation_GetObjectAsync () { m_ProviderOperation_GetObjectAsync ++ ; }
 	void Increment_ProviderOperation_PutClassAsync () { m_ProviderOperation_PutClassAsync ++ ; }
	void Increment_ProviderOperation_DeleteClassAsync () { m_ProviderOperation_DeleteClassAsync ++ ; }
	void Increment_ProviderOperation_CreateClassEnumAsync () { m_ProviderOperation_CreateClassEnumAsync ++ ; }
	void Increment_ProviderOperation_PutInstanceAsync () { m_ProviderOperation_PutInstanceAsync ++ ; }
	void Increment_ProviderOperation_DeleteInstanceAsync () { m_ProviderOperation_DeleteInstanceAsync ++ ; }
	void Increment_ProviderOperation_CreateInstanceEnumAsync () { m_ProviderOperation_CreateInstanceEnumAsync ++ ; }
	void Increment_ProviderOperation_ExecQueryAsync () { m_ProviderOperation_ExecQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecNotificationQueryAsync () { m_ProviderOperation_ExecNotificationQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecMethodAsync () { m_ProviderOperation_ExecMethodAsync ++ ; }

	void Increment_ProviderOperation_Begin () { m_ProviderOperation_Begin ++ ; }
	void Increment_ProviderOperation_Rollback () { m_ProviderOperation_Rollback ++ ; }
	void Increment_ProviderOperation_Commit () { m_ProviderOperation_Commit ++ ; }
	void Increment_ProviderOperation_QueryState () { m_ProviderOperation_QueryState ++ ; }

	void Increment_ProviderOperation_QueryInstances () { m_ProviderOperation_QueryInstances ++ ; }
	void Increment_ProviderOperation_CreateRefresher () { m_ProviderOperation_CreateRefresher ++ ; }
	void Increment_ProviderOperation_CreateRefreshableObject () { m_ProviderOperation_CreateRefreshableObject ++ ; }
	void Increment_ProviderOperation_StopRefreshing () { m_ProviderOperation_StopRefreshing ++ ; }
	void Increment_ProviderOperation_CreateRefreshableEnum () { m_ProviderOperation_CreateRefreshableEnum ++ ; }
	void Increment_ProviderOperation_GetObjects () { m_ProviderOperation_GetObjects ++ ; }

	void Increment_ProviderOperation_GetProperty () { m_ProviderOperation_GetProperty ++ ; }
	void Increment_ProviderOperation_PutProperty () { m_ProviderOperation_PutProperty ++ ; }

	void Increment_ProviderOperation_ProvideEvents () { m_ProviderOperation_ProvideEvents ++ ; }
	void Increment_ProviderOperation_NewQuery () { m_ProviderOperation_NewQuery ++ ; }
	void Increment_ProviderOperation_CancelQuery () { m_ProviderOperation_CancelQuery ++ ; }
	void Increment_ProviderOperation_AccessCheck () { m_ProviderOperation_AccessCheck ++ ; }
	void Increment_ProviderOperation_SetRegistrationObject () { m_ProviderOperation_SetRegistrationObject ++ ; }
	void Increment_ProviderOperation_FindConsumer () { m_ProviderOperation_FindConsumer ++ ; }
	void Increment_ProviderOperation_ValidateSubscription () { m_ProviderOperation_ValidateSubscription ++ ; }

	UINT64 Get_ProviderOperation_GetObjectAsync () { return m_ProviderOperation_GetObjectAsync ; }
	UINT64 Get_ProviderOperation_PutClassAsync () { return m_ProviderOperation_PutClassAsync ; }
	UINT64 Get_ProviderOperation_DeleteClassAsync () { return m_ProviderOperation_DeleteClassAsync ; }
	UINT64 Get_ProviderOperation_CreateClassEnumAsync () { return m_ProviderOperation_CreateClassEnumAsync ; }
	UINT64 Get_ProviderOperation_PutInstanceAsync () { return m_ProviderOperation_PutInstanceAsync ; }
	UINT64 Get_ProviderOperation_DeleteInstanceAsync () { return m_ProviderOperation_DeleteInstanceAsync ; }
	UINT64 Get_ProviderOperation_CreateInstanceEnumAsync () { return m_ProviderOperation_CreateInstanceEnumAsync ; }
	UINT64 Get_ProviderOperation_ExecQueryAsync () { return m_ProviderOperation_ExecQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecNotificationQueryAsync () { return m_ProviderOperation_ExecNotificationQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecMethodAsync () { return m_ProviderOperation_ExecMethodAsync ; }

	UINT64 Get_ProviderOperation_Begin () { return m_ProviderOperation_Begin ; }
	UINT64 Get_ProviderOperation_Rollback () { return m_ProviderOperation_Rollback ; }
	UINT64 Get_ProviderOperation_Commit () { return m_ProviderOperation_Commit ; }
	UINT64 Get_ProviderOperation_QueryState () { return m_ProviderOperation_QueryState ; }

	UINT64 Get_ProviderOperation_QueryInstances () { return m_ProviderOperation_QueryInstances ; }
	UINT64 Get_ProviderOperation_CreateRefresher () { return m_ProviderOperation_CreateRefresher ; }
	UINT64 Get_ProviderOperation_CreateRefreshableObject () { return m_ProviderOperation_CreateRefreshableObject ; }
	UINT64 Get_ProviderOperation_StopRefreshing () { return m_ProviderOperation_StopRefreshing ; }
	UINT64 Get_ProviderOperation_CreateRefreshableEnum () { return m_ProviderOperation_CreateRefreshableEnum ; }
	UINT64 Get_ProviderOperation_GetObjects () { return m_ProviderOperation_GetObjects ; }

	UINT64 Get_ProviderOperation_GetProperty () { return m_ProviderOperation_GetProperty ; }
	UINT64 Get_ProviderOperation_PutProperty () { return m_ProviderOperation_PutProperty ; }

	UINT64 Get_ProviderOperation_ProvideEvents () { return m_ProviderOperation_ProvideEvents ; }
	UINT64 Get_ProviderOperation_NewQuery () { return m_ProviderOperation_NewQuery ; }
	UINT64 Get_ProviderOperation_CancelQuery () { return m_ProviderOperation_CancelQuery ; }
	UINT64 Get_ProviderOperation_AccessCheck () { return m_ProviderOperation_AccessCheck ; }
	UINT64 Get_ProviderOperation_SetRegistrationObject () { return m_ProviderOperation_SetRegistrationObject ; }
	UINT64 Get_ProviderOperation_FindConsumer () { return m_ProviderOperation_FindConsumer ; }
	UINT64 Get_ProviderOperation_ValidateSubscription () { return m_ProviderOperation_ValidateSubscription ; }

private:

	HRESULT SetStatus ( 

		LPWSTR a_Operation ,
		LPWSTR a_Parameters ,
		LPWSTR a_Description ,
		HRESULT a_Result ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT Begin_IWbemServices (

		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IWbemServices *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_IWbemServices (

		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IWbemServices *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT AdjustGetContext (

		IWbemContext *a_Context
	) ;

	HRESULT Helper_GetObjectAsync (

		BOOL a_IsProxy ,
 		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_PutClassAsync (

		BOOL a_IsProxy ,
		IWbemClassObject *a_Object , 
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_DeleteClassAsync (

		BOOL a_IsProxy ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_CreateClassEnumAsync (

		BOOL a_IsProxy ,
		const BSTR a_SuperClass ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_PutInstanceAsync (

		BOOL a_IsProxy ,
		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_DeleteInstanceAsync (

		BOOL a_IsProxy ,
		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

    HRESULT Helper_CreateInstanceEnumAsync (

		BOOL a_IsProxy ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service
	) ;

	HRESULT Helper_ExecQueryAsync (

		BOOL a_IsProxy ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query, 
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_ExecMethodAsync (

		BOOL a_IsProxy ,
		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

public:

	CInterceptor_DecoupledClient ( 

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideUnknown , 
		IWbemServices *a_CoreStub ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

    ~CInterceptor_DecoupledClient () ;

	HRESULT ProviderInitialize () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE GetProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE PutProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderIdentity */

	HRESULT STDMETHODCALLTYPE SetRegistrationObject (

		long a_Flags ,
		IWbemClassObject *a_ProviderRegistration
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	/* IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

/* Internal_IWbemServices */
 
     HRESULT STDMETHODCALLTYPE Internal_OpenNamespace ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CancelAsyncCall ( 

		WmiInternalContext a_InternalContext ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_QueryObjectSink ( 

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_GetObject ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_GetObjectAsync (
        
		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE Internal_PutClass ( 

		WmiInternalContext a_InternalContext ,
        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutClassAsync ( 

		WmiInternalContext a_InternalContext ,
        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteClass ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteClassAsync ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateClassEnum ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateClassEnumAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutInstance (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutInstanceAsync (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteInstance ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteInstanceAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateInstanceEnum (

		WmiInternalContext a_InternalContext ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateInstanceEnumAsync (

		WmiInternalContext a_InternalContext ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecQuery ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecQueryAsync (

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecNotificationQuery (

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecNotificationQueryAsync ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecMethod (

		WmiInternalContext a_InternalContext ,
        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecMethodAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* Internal_IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE Internal_GetProperty (

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE Internal_PutProperty (

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* Internal_IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE Internal_ProvideEvents (

		WmiInternalContext a_InternalContext ,
		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* Internal_IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE Internal_NewQuery (

		WmiInternalContext a_InternalContext ,
		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE Internal_CancelQuery (

		WmiInternalContext a_InternalContext ,
		unsigned long a_Id
	) ;

	/* Internal_IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE Internal_AccessCheck (

		WmiInternalContext a_InternalContext ,
		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* Internal_IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE Internal_FindConsumer (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* Internal_IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE Internal_ValidateSubscription (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer
	) ;

	/* Internal_IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE Internal_IndicateToConsumer (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;


	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_CoreService ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Internal_Initialize (

		WmiInternalContext a_InternalContext ,
		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_CoreService ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	/* _IWmiProviderSite */

	HRESULT STDMETHODCALLTYPE GetSite ( DWORD *a_ProcessIdentifier ) ;

	HRESULT STDMETHODCALLTYPE SetContainer ( IUnknown *a_Container ) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

#endif // _Decopled_Interceptor_IWbemServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\classfac.cpp ===
#ifndef __CLASSFACTORY_CPP
#define __CLASSFACTORY_CPP

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ClassFac.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvResv.h"
#include "ProvFact.h"
#include "ProvSubS.h"
#include "classfac.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
CServerClassFactory <Object,ObjectInterface> :: CServerClassFactory <Object,ObjectInterface> () : m_ReferenceCount ( 0 )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
CServerClassFactory <Object,ObjectInterface> :: ~CServerClassFactory <Object,ObjectInterface> ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress ) ;
	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CServerClassFactory <Object,ObjectInterface> :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) ( IClassFactory * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP_( ULONG ) CServerClassFactory <Object,ObjectInterface> :: AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP_(ULONG) CServerClassFactory <Object,ObjectInterface> :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CServerClassFactory <Object,ObjectInterface> :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		IUnknown *lpunk = ( ObjectInterface * ) new Object ( *ProviderSubSystem_Globals :: s_Allocator );
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
			else
			{
			}
		}			
	}

	return status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CServerClassFactory <Object,ObjectInterface> :: LockServer ( BOOL fLock )
{
/* 
 * Place code in critical section
 */

	if ( fLock )
	{
		InterlockedIncrement ( & ProviderSubSystem_Globals :: s_LocksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & ProviderSubSystem_Globals :: s_LocksInProgress ) ;
	}

	return S_OK	;
}

#endif __CLASSFACTORY_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\globals.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <windows.h>
#include <objbase.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemcli.h>
#include <wbemint.h>
#include <winntsec.h>
#include <callsec.h>
#include <cominit.h>

#include <NCObjApi.h>
#include "winmgmtr.h"

#include <Guids.h>

#include <BasicTree.h>
#include <Thread.h>
#include <Logging.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvSubS.h"

#ifdef WMIASLOCAL
#include "Main.h"
#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG ProviderSubSystem_Globals :: s_Initialized = 0 ;

WmiAllocator *ProviderSubSystem_Globals :: s_Allocator = NULL ;

CriticalSection ProviderSubSystem_Globals :: s_DecoupledRegistrySection(NOTHROW_LOCK) ;

HANDLE ProviderSubSystem_Globals :: s_FileMapping = NULL ;
CServerObject_ProviderSubsystem_Counters *ProviderSubSystem_Globals :: s_SharedCounters = NULL ;

StrobeThread *ProviderSubSystem_Globals :: s_StrobeThread = NULL ;

HANDLE ProviderSubSystem_Globals :: s_CoFreeUnusedLibrariesEvent = NULL ;

HANDLE ProviderSubSystem_Globals :: s_HostJobObject = NULL ;
LPCWSTR ProviderSubSystem_Globals :: s_HostJobObjectName = L"Global\\WmiProviderSubSystemHostJob" ;

LPCWSTR ProviderSubSystem_Globals :: s_ProviderSubsystemEventSourceName = L"WinMgmt" ;
HANDLE ProviderSubSystem_Globals :: s_NtEventLogSource = NULL ;

HostController *ProviderSubSystem_Globals :: s_HostController = NULL ;
RefresherManagerController *ProviderSubSystem_Globals :: s_RefresherManagerController = NULL ;
CWbemGlobal_HostedProviderController *ProviderSubSystem_Globals :: s_HostedProviderController = NULL ;
CWbemGlobal_IWmiProvSubSysController *ProviderSubSystem_Globals :: s_ProvSubSysController = NULL ;
CWbemGlobal_IWbemSyncProviderController *ProviderSubSystem_Globals :: s_SyncProviderController = NULL ;
CDecoupled_ProviderSubsystemRegistrar *ProviderSubSystem_Globals :: s_DecoupledRegistrar = NULL ;

CriticalSection ProviderSubSystem_Globals :: s_GuidTagSection(NOTHROW_LOCK) ;
CWbemGlobal_ComServerTagContainer *ProviderSubSystem_Globals ::  s_GuidTag = NULL ;

LONG ProviderSubSystem_Globals :: s_LocksInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_ObjectsInProgress = 0 ;

ULONG ProviderSubSystem_Globals :: s_InternalCacheTimeout = DEFAULT_PROVIDER_TIMEOUT ;
ULONG ProviderSubSystem_Globals :: s_ObjectCacheTimeout = DEFAULT_PROVIDER_TIMEOUT ;
ULONG ProviderSubSystem_Globals :: s_EventCacheTimeout = DEFAULT_PROVIDER_TIMEOUT ;
ULONG ProviderSubSystem_Globals :: s_StrobeTimeout = DEFAULT_PROVIDER_TIMEOUT >> 1 ;

ULONG ProviderSubSystem_Globals :: s_Quota_ProcessLimitCount = 0x20 ;
SIZE_T ProviderSubSystem_Globals :: s_Quota_ProcessMemoryLimitCount = 0x10000000 ;
SIZE_T ProviderSubSystem_Globals :: s_Quota_JobMemoryLimitCount = 0x10000000 ;
SIZE_T ProviderSubSystem_Globals :: s_Quota_PrivatePageCount = 0x10000000 ;
ULONG ProviderSubSystem_Globals :: s_Quota_HandleCount = 0x1000 ;
ULONG ProviderSubSystem_Globals :: s_Quota_NumberOfThreads = 0x1000 ;


LONG ProviderSubSystem_Globals :: s_CAggregator_IWbemProvider_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemProviderInitSink_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Proxy_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Stub_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IEnumWbemClassObject_Stub_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IEnumWbemClassObject_Proxy_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Interceptor_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_RestrictingInterceptor_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSinkEx_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemFilteringObjectSink_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemProvider_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncProvider_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncObjectSink_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncObjectSinkEx_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncFilteringObjectSink_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemCombiningObjectSink_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemWaitingObjectSink_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemUnboundObjectSink_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncUnboundObjectSink_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledProvider_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CDecoupled_IWbemUnboundObjectSink_ObjectsInProgress = 0 ;

LONG ProviderSubSystem_Globals :: s_CServerObject_Host_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerObject_HostInterceptor_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerObject_BindingFactory_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerObject_DynamicPropertyProviderResolver_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerObject_IWbemServices_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerObject_ProviderSubsystem_Counters_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerObject_ProviderSubSystem_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerObject_RawFactory_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_StaTask_Create_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerObject_StaThread_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_StrobeThread_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CDecoupledAggregator_IWbemProvider_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CDecoupled_ProviderSubsystemRegistrar_ObjectsInProgress = 0 ;

LONG ProviderSubSystem_Globals :: s_CServerObject_ProviderRefresherManager_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerProvRefreshManagerClassFactory_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerObject_InterceptorProviderRefresherManager_ObjectsInProgress = 0 ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LPCWSTR ProviderSubSystem_Globals :: s_FileMappingName = L"Global\\Wmi Provider Sub System Counters" ;

LPCWSTR ProviderSubSystem_Globals :: s_QueryPrefix = L"Select * from __Win32Provider Where Name = \"" ;
ULONG ProviderSubSystem_Globals :: s_QueryPrefixLen = wcslen ( ProviderSubSystem_Globals :: s_QueryPrefix ) ;

LPCWSTR ProviderSubSystem_Globals :: s_QueryPostfix = L"\"" ;
ULONG ProviderSubSystem_Globals :: s_QueryPostfixLen = wcslen ( ProviderSubSystem_Globals :: s_QueryPostfix ) ;

ULONG ProviderSubSystem_Globals :: s_QueryConstantsLen = ProviderSubSystem_Globals :: s_QueryPrefixLen + ProviderSubSystem_Globals :: s_QueryPostfixLen  ;

LPCWSTR ProviderSubSystem_Globals :: s_Provider = L"Provider" ;
ULONG ProviderSubSystem_Globals :: s_ProviderLen = wcslen ( ProviderSubSystem_Globals :: s_Provider ) ;

LPCWSTR ProviderSubSystem_Globals :: s_Class = L"__Class" ;
ULONG ProviderSubSystem_Globals :: s_ClassLen = wcslen ( ProviderSubSystem_Globals :: s_Class ) ;

LPCWSTR ProviderSubSystem_Globals :: s_Wql = L"Wql" ;

LPCWSTR ProviderSubSystem_Globals :: s_DynProps = L"DynProps" ;
LPCWSTR ProviderSubSystem_Globals :: s_Dynamic = L"Dynamic" ;
LPCWSTR ProviderSubSystem_Globals :: s_ClassContext = L"ClassContext" ;
LPCWSTR ProviderSubSystem_Globals :: s_InstanceContext = L"InstanceContext" ;
LPCWSTR ProviderSubSystem_Globals :: s_PropertyContext = L"PropertyContext" ;

HANDLE ProviderSubSystem_Globals :: s_EventSource = NULL ;
LPWSTR ProviderSubSystem_Globals :: s_EventPropertySources [] = {

	L"Msft_WmiProvider_ComServerLoadOperationEvent" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Clsid!s! ServerName!s! InProcServer!b! LocalServer!b! InProcServerPath!s! LocalServerPath!s!" ,

	L"Msft_WmiProvider_ComServerOperationFailureEvent" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Clsid!s! ServerName!s! InProcServer!b! LocalServer!b! InProcServerPath!s! LocalServerPath!s! ResultCode!u!" ,

    L"Msft_WmiProvider_LoadOperationEvent",
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Clsid!s! ServerName!s! InProcServer!b! LocalServer!b! InProcServerPath!s! LocalServerPath!s! ThreadingModel!u! Synchronisation!u!" ,

    L"Msft_WmiProvider_LoadOperationFailureEvent",
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Clsid!s! ServerName!s! InProcServer!b! LocalServer!b! InProcServerPath!s! LocalServerPath!s! ThreadingModel!u! Synchronisation!u! ResultCode!u!" ,

    L"Msft_WmiProvider_InitializationOperationFailureEvent" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! ResultCode!u!" ,

    L"Msft_WmiProvider_InitializationOperationEvent" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s!" ,

    L"Msft_WmiProvider_UnLoadOperationEvent" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s!" ,

	L"Msft_WmiProvider_GetObjectAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ObjectPath!s!" ,

	L"Msft_WmiProvider_PutClassAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ClassObject!O!" ,
 
	L"Msft_WmiProvider_DeleteClassAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ClassName!s!" ,

	L"Msft_WmiProvider_CreateClassEnumAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! SuperclassName!s!" ,

	L"Msft_WmiProvider_PutInstanceAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! InstanceObject!O!" ,

	L"Msft_WmiProvider_DeleteInstanceAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ObjectPath!s!" ,

	L"Msft_WmiProvider_CreateInstanceEnumAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ClassName!s!" ,

	L"Msft_WmiProvider_ExecQueryAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! QueryLanguage!s! Query!s!" ,

	L"Msft_WmiProvider_ExecNotificationQueryAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! QueryLanguage!s! Query!s!" ,

	L"Msft_WmiProvider_ExecMethodAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ObjectPath!s! MethodName!s! InputParameters!O!" ,

	L"Msft_WmiProvider_ProvideEvents_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u!" ,

	L"Msft_WmiProvider_AccessCheck_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! QueryLanguage!s! Query!s! Sid!c[]!" ,

	L"Msft_WmiProvider_CancelQuery_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! QueryId!u!" ,

	L"Msft_WmiProvider_NewQuery_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! QueryId!u! QueryLanguage!s! Query!s!" ,

	L"Msft_WmiProvider_GetObjectAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ObjectPath!s! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_PutClassAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ClassObject!O! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_DeleteClassAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ClassName!s! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_CreateClassEnumAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! SuperclassName!s! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_PutInstanceAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! InstanceObject!O! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_DeleteInstanceAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ObjectPath!s! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_CreateInstanceEnumAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ClassName!s! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_ExecQueryAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! QueryLanguage!s! Query!s! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_ExecNotificationQueryAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! QueryLanguage!s! Query!s! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_ExecMethodAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ObjectPath!s! MethodName!s! InputParameters!O! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_ProvideEvents_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! Result!u!" ,

	L"Msft_WmiProvider_AccessCheck_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! QueryLanguage!s! Query!s! Sid!c[]! Result!u!" ,

	L"Msft_WmiProvider_CancelQuery_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! QueryId!u! Result!u!" ,

	L"Msft_WmiProvider_NewQuery_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! QueryId!u! QueryLanguage!s! Query!s! Result!u!" 
} ;

ULONG ProviderSubSystem_Globals :: s_EventClassHandlesSize = sizeof ( s_EventPropertySources ) / ( sizeof ( wchar_t * ) * 2 )  ;
HANDLE ProviderSubSystem_Globals :: s_EventClassHandles [ sizeof ( s_EventPropertySources ) / ( sizeof ( wchar_t * ) * 2 ) ] ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: Initialize_Events ()
{
	HRESULT t_Result = S_OK ;

    ProviderSubSystem_Globals ::s_EventSource = WmiEventSourceConnect (

		L"root\\cimv2" ,
        L"ProviderSubSystem" ,
        TRUE ,
        32000 ,
        100 ,
        NULL ,
        NULL
	) ;

    if ( ProviderSubSystem_Globals :: s_EventSource )
    {
        for ( ULONG t_Index = 0 ; t_Index < ProviderSubSystem_Globals :: s_EventClassHandlesSize ; t_Index ++ )
        {
            ProviderSubSystem_Globals :: s_EventClassHandles [ t_Index ] =  WmiCreateObjectWithFormat (

				ProviderSubSystem_Globals :: s_EventSource ,
                s_EventPropertySources [ t_Index * 2 ] ,
                WMI_CREATEOBJ_LOCKABLE ,
                s_EventPropertySources [ t_Index * 2 + 1 ]
			) ;

            if ( ProviderSubSystem_Globals :: s_EventClassHandles [ t_Index ] == NULL )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;

                break;
			}
        }
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: UnInitialize_Events ()
{
	HRESULT t_Result = S_OK ;

    if ( ProviderSubSystem_Globals ::s_EventSource )
    {
        for ( ULONG t_Index = 0 ; t_Index < ProviderSubSystem_Globals :: s_EventClassHandlesSize ; t_Index ++ )
        {
	HANDLE eventHandle = ProviderSubSystem_Globals :: s_EventClassHandles [ t_Index ];
        ProviderSubSystem_Globals :: s_EventClassHandles [ t_Index ] = NULL;    
	WmiDestroyObject ( eventHandle) ;
        }

        WmiEventSourceDisconnect ( ProviderSubSystem_Globals :: s_EventSource );
        ProviderSubSystem_Globals :: s_EventSource = NULL;
        
    }

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetSecurityDescriptor ( SECURITY_DESCRIPTOR &a_SecurityDescriptor , DWORD a_Access ) 
{
	HRESULT t_Result = S_OK ;

	BOOL t_BoolResult = InitializeSecurityDescriptor ( & a_SecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
	if ( t_BoolResult )
	{
		SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

		PSID t_System_Sid = NULL ;
		ACCESS_ALLOWED_ACE *t_System_ACE = NULL ;
		USHORT t_System_ACESize = 0 ;

		t_BoolResult = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			1 ,
			SECURITY_LOCAL_SYSTEM_RID,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_System_Sid
		);

		if ( t_BoolResult )
		{
			DWORD t_SidLength = ::GetLengthSid ( t_System_Sid );
			t_System_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
			t_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_System_ACESize ] ;
			if ( t_System_ACE )
			{
				CopySid ( t_SidLength, (PSID) & t_System_ACE->SidStart, t_System_Sid ) ;
				t_System_ACE->Mask = FILE_MAP_ALL_ACCESS;
				t_System_ACE->Header.AceType = 0 ;
				t_System_ACE->Header.AceFlags = 3 ;
				t_System_ACE->Header.AceSize = t_System_ACESize ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			DWORD t_LastError = ::GetLastError();

			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		PSID t_LocalService_Sid = NULL ;
		ACCESS_ALLOWED_ACE *t_LocalService_ACE = NULL ;
		USHORT t_LocalService_ACESize = 0 ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_BoolResult = AllocateAndInitializeSid (

				& t_NtAuthoritySid ,
				1 ,
				SECURITY_LOCAL_SERVICE_RID ,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				& t_LocalService_Sid
			);

			if ( t_BoolResult )
			{
				DWORD t_SidLength = ::GetLengthSid ( t_LocalService_Sid );
				t_LocalService_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
				t_LocalService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_LocalService_ACESize ] ;
				if ( t_LocalService_ACE )
				{
					CopySid ( t_SidLength, (PSID) & t_LocalService_ACE->SidStart, t_LocalService_Sid ) ;
					t_LocalService_ACE->Mask = FILE_MAP_ALL_ACCESS ;
					t_LocalService_ACE->Header.AceType = 0 ;
					t_LocalService_ACE->Header.AceFlags = 3 ;
					t_LocalService_ACE->Header.AceSize = t_LocalService_ACESize ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				DWORD t_LastError = ::GetLastError();

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		PSID t_NetworkService_Sid = NULL ;
		ACCESS_ALLOWED_ACE *t_NetworkService_ACE = NULL ;
		USHORT t_NetworkService_ACESize = 0 ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_BoolResult = AllocateAndInitializeSid (

				& t_NtAuthoritySid ,
				1 ,
				SECURITY_NETWORK_SERVICE_RID ,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				& t_NetworkService_Sid
			);

			if ( t_BoolResult )
			{
				DWORD t_SidLength = ::GetLengthSid ( t_NetworkService_Sid );
				t_NetworkService_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
				t_NetworkService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_NetworkService_ACESize ] ;
				if ( t_NetworkService_ACE )
				{
					CopySid ( t_SidLength, (PSID) & t_NetworkService_ACE->SidStart, t_NetworkService_Sid ) ;
					t_NetworkService_ACE->Mask = FILE_MAP_ALL_ACCESS ;
					t_NetworkService_ACE->Header.AceType = 0 ;
					t_NetworkService_ACE->Header.AceFlags = 3 ;
					t_NetworkService_ACE->Header.AceSize = t_NetworkService_ACESize ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				DWORD t_LastError = ::GetLastError();

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		PSID t_Everyone_Sid = NULL ;
		ACCESS_ALLOWED_ACE *t_Everyone_ACE = NULL ;
		USHORT t_Everyone_ACESize = 0 ;

		if ( SUCCEEDED ( t_Result ) )
		{
			SID_IDENTIFIER_AUTHORITY t_WorldAuthoritySid = SECURITY_WORLD_SID_AUTHORITY ;
		
			t_BoolResult = AllocateAndInitializeSid (

				& t_WorldAuthoritySid ,
				1 ,
				SECURITY_WORLD_RID ,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				& t_Everyone_Sid
			);

			if ( t_BoolResult )
			{
				DWORD t_SidLength = ::GetLengthSid ( t_Everyone_Sid );
				t_Everyone_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
				t_Everyone_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Everyone_ACESize ] ;
				if ( t_Everyone_ACE )
				{
					CopySid ( t_SidLength, (PSID) & t_Everyone_ACE->SidStart, t_Everyone_Sid ) ;
					t_Everyone_ACE->Mask = a_Access ;
					t_Everyone_ACE->Header.AceType = 0 ;
					t_Everyone_ACE->Header.AceFlags = 3 ;
					t_Everyone_ACE->Header.AceSize = t_Everyone_ACESize ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				DWORD t_LastError = ::GetLastError();

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			// Now we need to set permissions on the registry: Everyone read; Admins full.
			// We have the sid for admins from the above code.  Now get the sid for "Everyone"

			DWORD t_TotalAclSize = sizeof(ACL) + t_System_ACESize + t_NetworkService_ACESize + t_LocalService_ACESize + t_Everyone_ACESize ;
			PACL t_Dacl = (PACL) new BYTE [ t_TotalAclSize ] ;
			if ( t_Dacl )
			{
				if ( :: InitializeAcl ( t_Dacl, t_TotalAclSize, ACL_REVISION ) )
				{
					DWORD t_AceIndex = 0 ;

					if ( t_System_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_System_ACE , t_System_ACESize ) )
					{
						t_AceIndex ++ ;
					}

					if ( t_NetworkService_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_NetworkService_ACE , t_NetworkService_ACESize ) )
					{
						t_AceIndex ++ ;
					}

					if ( t_LocalService_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_LocalService_ACE , t_LocalService_ACESize ) )
					{
						t_AceIndex ++ ;
					}

					if ( a_Access )
					{
						if ( t_Everyone_ACESize && :: AddAce ( t_Dacl , ACL_REVISION, t_AceIndex , t_Everyone_ACE , t_Everyone_ACESize ) )
						{
							t_AceIndex ++ ;
						}
					}					

					t_BoolResult = SetSecurityDescriptorDacl (

					& a_SecurityDescriptor ,
					TRUE ,
					t_Dacl ,
					FALSE
					) ;

					if ( t_BoolResult == FALSE )
					{
						delete [] ( ( BYTE * ) t_Dacl ) ;

						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		if ( t_System_ACE )
		{
			delete [] ( ( BYTE * ) t_System_ACE ) ;
		}

		if ( t_NetworkService_ACE )
		{
			delete [] ( ( BYTE * ) t_NetworkService_ACE ) ;
		}

		if ( t_LocalService_ACE )
		{
			delete [] ( ( BYTE * ) t_LocalService_ACE ) ;
		}

		if ( t_Everyone_ACE )
		{
			delete [] ( ( BYTE * ) t_Everyone_ACE ) ;
		}

		if ( t_System_Sid )
		{
			FreeSid ( t_System_Sid ) ;
		}

		if ( t_NetworkService_Sid )
		{
			FreeSid ( t_NetworkService_Sid ) ;
		}

		if ( t_LocalService_Sid )
		{
			FreeSid ( t_LocalService_Sid ) ;
		}

		if ( t_Everyone_Sid )
		{
			FreeSid ( t_Everyone_Sid ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: Initialize_SharedCounters ()
{
	HRESULT t_Result = S_OK ;

	HANDLE t_Handle = OpenFileMapping (

		FILE_MAP_READ | FILE_MAP_WRITE ,
		FALSE ,
		s_FileMappingName
	) ;

	if ( t_Handle == NULL )
	{
		if ( GetLastError () == ERROR_FILE_NOT_FOUND )
		{
			SECURITY_DESCRIPTOR t_SecurityDescriptor ;

			t_Result = GetSecurityDescriptor ( 

				t_SecurityDescriptor ,
				0
				// FILE_MAP_ALL_ACCESS
			) ;

			if ( SUCCEEDED ( t_Result ) ) 
			{
				SECURITY_ATTRIBUTES t_SecurityAttributes ;

				t_SecurityAttributes.nLength = sizeof ( SECURITY_ATTRIBUTES ) ; 
				t_SecurityAttributes.lpSecurityDescriptor = & t_SecurityDescriptor ; 
				t_SecurityAttributes.bInheritHandle = FALSE ; 

				t_Handle = CreateFileMapping (

					INVALID_HANDLE_VALUE ,
					& t_SecurityAttributes , 
					PAGE_READWRITE | SEC_COMMIT ,
					0 ,
					sizeof ( CServerObject_ProviderSubsystem_Counters ) , 
					s_FileMappingName
				) ;

				if ( t_Handle == NULL )
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}

				delete [] t_SecurityDescriptor.Dacl ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	void *t_Location = NULL ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Location = MapViewOfFile (
			
			t_Handle ,
			FILE_MAP_READ | FILE_MAP_WRITE ,
			0 ,
			0 ,
			sizeof ( CServerObject_ProviderSubsystem_Counters )
		) ;

		if ( t_Location )
		{
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		s_FileMapping = t_Handle ;
		s_SharedCounters = ( CServerObject_ProviderSubsystem_Counters * ) t_Location ;
	}
	else
	{
		if ( t_Handle )
		{
			CloseHandle ( t_Handle ) ;
		}

		SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

		PSID t_System_Sid = NULL ;

		BOOL t_BoolResult = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			1 ,
			SECURITY_LOCAL_SYSTEM_RID,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_System_Sid
		);

		if ( t_BoolResult )
		{
			LPCWSTR t_Array [ 1 ] ;

			t_Array [ 0 ] = s_FileMappingName ;

			BOOL t_Status = :: ReportEvent (

			  ProviderSubSystem_Globals :: GetNtEventSource () ,
			  EVENTLOG_WARNING_TYPE ,
			  0 ,
			  WBEM_MC_PROVIDER_SUBSYSTEM_LOCALSYSTEM_NAMED_SECTION ,
			  t_System_Sid ,
			  1 ,
			  0 ,
			  ( LPCWSTR * ) t_Array ,
			  NULL
			) ;

			if ( t_Status == 0 )
			{
				DWORD t_LastError = GetLastError () ;
			}

			LocalFree ( t_System_Sid ) ; 
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: UnInitialize_SharedCounters ()
{
	HRESULT t_Result = S_OK ;

	if ( s_SharedCounters )
	{
		BOOL t_Status = UnmapViewOfFile ( ( void * ) s_SharedCounters ) ;
                s_SharedCounters = NULL ;
	}

	if ( s_FileMapping )
	{
		CloseHandle ( s_FileMapping ) ;
		s_FileMapping = NULL ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: CreateJobObject ()
{
	HRESULT t_Result = S_OK ;

	s_HostJobObject = :: CreateJobObject (

		NULL ,
		s_HostJobObjectName	
	) ;

	if ( s_HostJobObject == NULL )
	{
		switch ( GetLastError () )
		{
			case ERROR_ALREADY_EXISTS:
			{
				s_HostJobObject = OpenJobObject (

					JOB_OBJECT_ALL_ACCESS ,
					FALSE ,
					s_HostJobObjectName
				) ;

				if ( ! s_HostJobObject )
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}
			}
			break ;

			default:
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
			break;
		}
	}
	else
	{
		JOBOBJECTINFOCLASS t_JobObjectInfoClass = JobObjectExtendedLimitInformation ;
		JOBOBJECT_EXTENDED_LIMIT_INFORMATION t_JobObjectInfo ;
		DWORD t_JobObjectInfoLength = sizeof ( JOBOBJECT_EXTENDED_LIMIT_INFORMATION ) ;
		ZeroMemory ( & t_JobObjectInfo , sizeof ( JOBOBJECT_EXTENDED_LIMIT_INFORMATION ) ) ;

		ULONG t_LimitRequirements = s_Quota_ProcessLimitCount > 0 ? JOB_OBJECT_LIMIT_ACTIVE_PROCESS : 0 ;
		t_LimitRequirements = ( s_Quota_ProcessMemoryLimitCount > 0 ? t_LimitRequirements | JOB_OBJECT_LIMIT_JOB_MEMORY : t_LimitRequirements );
		t_LimitRequirements = s_Quota_JobMemoryLimitCount > 0 ? t_LimitRequirements | JOB_OBJECT_LIMIT_PROCESS_MEMORY : t_LimitRequirements ;

		t_JobObjectInfo.BasicLimitInformation.LimitFlags = t_LimitRequirements | JOB_OBJECT_LIMIT_BREAKAWAY_OK;
		t_JobObjectInfo.BasicLimitInformation.ActiveProcessLimit = s_Quota_ProcessLimitCount ;
		t_JobObjectInfo.ProcessMemoryLimit = s_Quota_ProcessMemoryLimitCount ;
		t_JobObjectInfo.JobMemoryLimit = s_Quota_JobMemoryLimitCount ;
		t_JobObjectInfo.PeakProcessMemoryUsed = s_Quota_ProcessMemoryLimitCount ;
		t_JobObjectInfo.PeakJobMemoryUsed = s_Quota_JobMemoryLimitCount ;

		OSVERSIONINFOEX t_OsInformationEx ;
		ZeroMemory ( & t_OsInformationEx , sizeof ( t_OsInformationEx ) ) ;
		t_OsInformationEx.dwOSVersionInfoSize = sizeof ( t_OsInformationEx ) ;

		if ( GetVersionEx ( ( OSVERSIONINFO * ) & t_OsInformationEx ) )
		{
			if ( ( t_OsInformationEx.dwPlatformId == VER_PLATFORM_WIN32_NT ) && ( ( t_OsInformationEx.dwMajorVersion > 5 ) || ( ( t_OsInformationEx.dwMajorVersion == 5 ) && ( t_OsInformationEx.dwMinorVersion >= 1 ) ) ) )
			{
				t_JobObjectInfo.BasicLimitInformation.LimitFlags = t_JobObjectInfo.BasicLimitInformation.LimitFlags | JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE | JOB_OBJECT_LIMIT_BREAKAWAY_OK;
			}
		}
		else
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Status = SetInformationJobObject (

			  s_HostJobObject ,
			  t_JobObjectInfoClass ,
			  & t_JobObjectInfo ,
			  t_JobObjectInfoLength
			) ;

			if ( t_Status == FALSE ) 
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: DeleteJobObject ()
{
	HRESULT t_Result = S_OK ;

	if ( s_HostJobObject )
	{
		BOOL t_Status = TerminateJobObject ( s_HostJobObject ,  0 ) ;
		CloseHandle ( s_HostJobObject ) ;
                s_HostJobObject = NULL ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: AssignProcessToJobObject ( HANDLE a_Handle )
{
	HRESULT t_Result = S_OK ;

	if ( s_HostJobObject )
	{
		BOOL t_Status =:: AssignProcessToJobObject (

		  s_HostJobObject ,
		  a_Handle 
		) ;

		if ( t_Status == FALSE ) 
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: Global_Startup ()
{
	HRESULT t_Result = S_OK ;

	if ( ! s_Allocator )
	{
/*
 *	Use the global process heap for this particular boot operation
 */
	
		WmiAllocator t_Allocator ;
		WmiStatusCode t_StatusCode = t_Allocator.New (

			( void ** ) & s_Allocator ,
			sizeof ( WmiAllocator ) 
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
#ifdef DBG
			:: new ( ( void * ) s_Allocator ) WmiAllocator ( WmiAllocator :: e_DefaultAllocation , 0 , 0 ) ;
#else
			:: new ( ( void * ) s_Allocator ) WmiAllocator ;
#endif

			t_StatusCode = s_Allocator->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & s_DecoupledRegistrySection ) ;
		if ( t_StatusCode != e_StatusCode_Success )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
 
	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & s_GuidTagSection ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			s_GuidTag = new CWbemGlobal_ComServerTagContainer ( *s_Allocator ) ;
			if ( s_GuidTag )
			{
				t_StatusCode = s_GuidTag->Initialize () ;
				if ( t_StatusCode != e_StatusCode_Success )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		s_NtEventLogSource = RegisterEventSource ( NULL , s_ProviderSubsystemEventSourceName ) ;
		if ( s_NtEventLogSource == NULL )
		{
			return WBEM_E_CRITICAL_ERROR ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		s_ProvSubSysController = :: new CWbemGlobal_IWmiProvSubSysController ( *s_Allocator ) ;
		if ( s_ProvSubSysController )
		{
			s_ProvSubSysController->AddRef () ;

			WmiStatusCode t_StatusCode = s_ProvSubSysController->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				delete s_ProvSubSysController ;
				s_ProvSubSysController = NULL ;
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		s_SyncProviderController = :: new CWbemGlobal_IWbemSyncProviderController ( *s_Allocator ) ;
		if ( s_SyncProviderController )
		{
			s_SyncProviderController->AddRef () ;

			WmiStatusCode t_StatusCode = s_SyncProviderController->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				delete s_SyncProviderController ;
				s_SyncProviderController = NULL ;
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		s_HostedProviderController = :: new CWbemGlobal_HostedProviderController ( *s_Allocator ) ;
		if ( s_HostedProviderController )
		{
			s_HostedProviderController->AddRef () ;

			WmiStatusCode t_StatusCode = s_HostedProviderController->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				delete s_HostedProviderController ;
				s_HostedProviderController = NULL ;
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		s_HostController = :: new HostController ( *s_Allocator ) ;
		if ( s_HostController )
		{
			s_HostController->AddRef () ;

			WmiStatusCode t_StatusCode = s_HostController->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				delete s_HostController ;
				s_HostController = NULL ;
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		s_RefresherManagerController = :: new RefresherManagerController ( *s_Allocator ) ;
		if ( s_RefresherManagerController )
		{
			s_RefresherManagerController->AddRef () ;

			WmiStatusCode t_StatusCode = s_RefresherManagerController->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				delete s_RefresherManagerController ;
				s_RefresherManagerController = NULL ;
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_Initialize ( *s_Allocator ) ;
	}

	ProviderSubSystem_Common_Globals :: InitializeTransmitSize () ;

	ProviderSubSystem_Common_Globals :: InitializeDefaultStackSize () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: Global_Shutdown ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = WmiHelper :: DeleteCriticalSection ( & s_DecoupledRegistrySection ) ;

	t_StatusCode = WmiHelper :: DeleteCriticalSection ( & s_GuidTagSection ) ;

	if ( s_GuidTag ) 
	{
		t_StatusCode = s_GuidTag->UnInitialize () ;
		delete s_GuidTag ;
		s_GuidTag = NULL ;
	}

	if ( s_ProvSubSysController )
	{
		WmiStatusCode t_StatusCode = s_ProvSubSysController->UnInitialize () ;
		s_ProvSubSysController->Release () ;
		s_ProvSubSysController = NULL ;
	}

	if ( s_SyncProviderController )
	{
		WmiStatusCode t_StatusCode = s_SyncProviderController->Shutdown () ;
		t_StatusCode = s_SyncProviderController->UnInitialize () ;
		s_SyncProviderController->Release () ;
		s_SyncProviderController = NULL ;
	}

	if ( s_HostedProviderController )
	{
		WmiStatusCode t_StatusCode = s_HostController->Shutdown () ;
		t_StatusCode = s_HostController->UnInitialize () ;
		s_HostController->Release () ;
		s_HostController = NULL ;
	}

	if ( s_HostController )
	{
		WmiStatusCode t_StatusCode = s_HostController->Shutdown () ;
		t_StatusCode = s_HostController->UnInitialize () ;
		s_HostController->Release () ;
		s_HostController = NULL ;
	}

	if ( s_RefresherManagerController )
	{
		WmiStatusCode t_StatusCode = s_RefresherManagerController->Shutdown () ;
		t_StatusCode = s_RefresherManagerController->UnInitialize () ;
		s_RefresherManagerController->Release () ;
		s_RefresherManagerController= NULL ;
	}

	t_StatusCode = WmiThread <ULONG> :: Static_UnInitialize ( *s_Allocator ) ;

	if ( s_NtEventLogSource )
	{
		DeregisterEventSource ( s_NtEventLogSource ) ;
	}

	if ( s_Allocator )
	{
/*
 *	Use the global process heap for this particular boot operation
 */

		WmiAllocator t_Allocator ;
		WmiStatusCode t_StatusCode = t_Allocator.Delete (

			( void * ) s_Allocator
		) ;

		if ( t_StatusCode != e_StatusCode_Success )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemGlobal_ComServerTagContainer *ProviderSubSystem_Globals :: GetGuidTag ()
{
	return s_GuidTag ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemGlobal_IWmiProvSubSysController *ProviderSubSystem_Globals :: GetProvSubSysController ()
{
	return s_ProvSubSysController ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemGlobal_IWbemSyncProviderController *ProviderSubSystem_Globals :: GetSyncProviderController ()
{
	return s_SyncProviderController ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HostController *ProviderSubSystem_Globals :: GetHostController ()
{
	return s_HostController ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

RefresherManagerController *ProviderSubSystem_Globals :: GetRefresherManagerController ()
{
	return s_RefresherManagerController ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemGlobal_HostedProviderController *ProviderSubSystem_Globals :: GetHostedProviderController ()
{
	return s_HostedProviderController ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CriticalSection *ProviderSubSystem_Globals :: GetGuidTagCriticalSection ()
{
	return & s_GuidTagSection ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CriticalSection *ProviderSubSystem_Globals :: GetDecoupledRegistrySection ()
{
	return & s_DecoupledRegistrySection ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void * __cdecl operator new ( size_t a_Size )
{
    void *t_Ptr ;
	WmiStatusCode t_StatusCode = ProviderSubSystem_Globals :: s_Allocator->New (

		( void ** ) & t_Ptr ,
		a_Size
	) ;

	if ( t_StatusCode != e_StatusCode_Success )
    {
#if 1
		t_Ptr = NULL ;
#else
        throw Wmi_Heap_Exception (

			Wmi_Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR
		) ;
#endif
    }

    return t_Ptr ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void __cdecl operator delete ( void *a_Ptr )
{
    if ( a_Ptr )
    {
		WmiStatusCode t_StatusCode = ProviderSubSystem_Globals :: s_Allocator->Delete (

			( void * ) a_Ptr
		) ;
    }
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: ForwardReload (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Namespace ,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProvSubSysController *t_SubSystemController = ProviderSubSystem_Globals :: GetProvSubSysController () ;
	if ( t_SubSystemController )
	{
		t_SubSystemController->Lock () ;

		CWbemGlobal_IWmiProvSubSysController_Container *t_Container = NULL ;
		t_SubSystemController->GetContainer ( t_Container ) ;

		if ( t_Container->Size () )
		{
			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator = t_Container->Begin ();

			CServerObject_ProviderSubSystem **t_ControllerElements = new CServerObject_ProviderSubSystem * [ t_Container->Size () ] ;
			if ( t_ControllerElements )
			{
				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_CWbemProviderSubSystem , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				t_SubSystemController->UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ControllerElements [ t_Index ] )
					{
						t_Result = t_ControllerElements [ t_Index ]->ForwardReload ( 

							0 , 
							NULL ,
							a_Namespace ,
							a_Provider
						) ;

						t_ControllerElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ControllerElements ;
			}
			else
			{
				t_SubSystemController->UnLock () ;
			}
		}
		else
		{
			t_SubSystemController->UnLock () ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL ProviderSubSystem_Globals :: CheckGuidTag ( const GUID &a_Guid )
{
	BOOL t_Present = FALSE ;

	CWbemGlobal_ComServerTagContainer_Iterator t_Iterator ;

	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & s_GuidTagSection ) ;
	
	t_StatusCode = s_GuidTag->Find ( a_Guid , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		t_Present = TRUE ;
	}

	t_StatusCode = WmiHelper :: LeaveCriticalSection ( & s_GuidTagSection ) ;

	return t_Present ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void ProviderSubSystem_Globals :: InsertGuidTag ( const GUID &a_Guid )
{
	CWbemGlobal_ComServerTagContainer_Iterator t_Iterator ;

	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & s_GuidTagSection ) ;
	
	t_StatusCode = s_GuidTag->Insert ( a_Guid , a_Guid , t_Iterator ) ;
	
	t_StatusCode = WmiHelper :: LeaveCriticalSection ( & s_GuidTagSection ) ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void ProviderSubSystem_Globals :: DeleteGuidTag ( const GUID &a_Guid )
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & s_GuidTagSection ) ;
	
	t_StatusCode = s_GuidTag->Delete ( a_Guid ) ;
	
	t_StatusCode = WmiHelper :: LeaveCriticalSection ( & s_GuidTagSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void ProviderSubSystem_Globals :: ClearGuidTag ()
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & s_GuidTagSection ) ;

	CWbemGlobal_ComServerTagContainer_Iterator GuidTagIt = s_GuidTag->Begin();
	while (!GuidTagIt.Null())
	{
		s_GuidTag->Delete (GuidTagIt.GetKey()); 
		GuidTagIt = s_GuidTag->Begin();
	}
	t_StatusCode = WmiHelper :: LeaveCriticalSection ( & s_GuidTagSection ) ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: BeginThreadImpersonation (

	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	HRESULT t_Result = S_OK ;

	IServerSecurity *t_ServerSecurity = NULL ;

	t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & a_OldContext ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			a_Impersonating = t_ServerSecurity->IsImpersonating () ;
		}
		else
		{
			a_Impersonating = FALSE ;
		}
	}

	CWbemCallSecurity *t_CallSecurity = CWbemCallSecurity :: New () ;
	if ( t_CallSecurity )
	{
		t_CallSecurity->AddRef () ;

		_IWmiThreadSecHandle *t_ThreadSecurity = NULL ;
		t_Result = t_CallSecurity->GetThreadSecurity ( ( WMI_THREAD_SECURITY_ORIGIN ) ( WMI_ORIGIN_THREAD ) , & t_ThreadSecurity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_CallSecurity->SetThreadSecurity ( t_ThreadSecurity ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_CallSecurity->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_Impersonating )
					{
						t_ServerSecurity->RevertToSelf () ;
					}
				}				
			}

			t_ThreadSecurity->Release () ;
		}

		t_CallSecurity->Release () ;
	}

	if ( t_ServerSecurity )
	{
		t_ServerSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: EndThreadImpersonation (

	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_Impersonating

)
{
	HRESULT t_Result = S_OK ;

	IUnknown *t_NewContext = NULL ;

	t_Result = CoSwitchCallContext ( a_OldContext , & t_NewContext ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_OldContext )
		{
			if ( a_Impersonating )
			{
				IServerSecurity *t_ServerSecurity = NULL ;
				t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_ServerSecurity->ImpersonateClient () ;

					t_ServerSecurity->Release () ;
				}
			}
		}

		if ( a_OldSecurity )
		{
			a_OldSecurity->Release() ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

/* 
 * CoGetCallContext AddReffed this thing so now we have to release it.
 */

	if ( a_OldContext )
	{ 
        a_OldContext->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

	WmiInternalContext a_InternalContext ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity
)
{
	HRESULT t_Result = WBEM_E_INVALID_PARAMETER ;

	if ( a_InternalContext.m_IdentifyHandle )
	{
		HANDLE t_IdentifyToken = ( HANDLE ) a_InternalContext.m_IdentifyHandle ;
		BOOL t_Status = SetThreadToken ( NULL , t_IdentifyToken ) ;
		if ( t_Status )
		{
			t_Result = BeginThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

			RevertToSelf () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		CloseHandle ( t_IdentifyToken ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost (

	WmiInternalContext a_InternalContext ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	EndThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	RevertToSelf () ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

	WmiInternalContext a_InternalContext ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity
)
{
	HRESULT t_Result = WBEM_E_INVALID_PARAMETER ;

	if ( a_InternalContext.m_IdentifyHandle )
	{
		HANDLE t_IdentifyToken = NULL ;

		t_Result = CoImpersonateClient () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			HANDLE t_CallerIdentifyToken = ( HANDLE ) a_InternalContext.m_IdentifyHandle ;
			DWORD t_ProcessIdentifier = a_InternalContext.m_ProcessIdentifier ;

			HANDLE t_ProcessHandle = OpenProcess (

				PROCESS_DUP_HANDLE ,
				FALSE ,
				t_ProcessIdentifier 
			) ;

			if ( t_ProcessHandle )
			{
				BOOL t_Status = DuplicateHandle (

					t_ProcessHandle ,
					t_CallerIdentifyToken ,
					GetCurrentProcess () ,
					& t_IdentifyToken ,
					MAXIMUM_ALLOWED | TOKEN_DUPLICATE | TOKEN_IMPERSONATE ,
					TRUE ,
					0
				) ;

				if ( t_Status )
				{
				}
				else
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}
								
				CloseHandle ( t_ProcessHandle ) ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}

			CoRevertToSelf () ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Status = SetThreadToken ( NULL , t_IdentifyToken ) ;
			if ( t_Status )
			{
				t_Result = BeginThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

				CoRevertToSelf () ;

				RevertToSelf () ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}

			CloseHandle ( t_IdentifyToken ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost (

	WmiInternalContext a_InternalContext ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	EndThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	RevertToSelf () ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG ProviderSubSystem_Globals :: Increment_Global_Object_Count ()
{
	return InterlockedIncrement ( & ProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG ProviderSubSystem_Globals :: Decrement_Global_Object_Count ()
{
	LONG t_Count = InterlockedDecrement ( & ProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

#ifdef WMIASLOCAL
#ifdef DBG
	if ( t_Count == 1 )
	{
		SetObjectDestruction () ;
	}
#else
	if ( ProviderSubSystem_Globals :: s_CServerObject_Host_ObjectsInProgress == 0 )
	{
		SetObjectDestruction () ;
	}
#endif
#endif

	return t_Count ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\maindll.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	MainDll.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include<olectl.h>
#include <stdio.h>

#include <HelperFuncs.h>
#include <Logging.h>

#include <CGlobals.h>
#include "Globals.h"
#include "ClassFac.h"
#include "ProvResv.h"
#include "ProvFact.h"
#include "ProvSubS.h"
#include "ProvAggr.h"
#include "ProvLoad.h"
#include "ProvSelf.h"
#include "ProvHost.h"
#include "StrobeThread.h"
#include "ProvCache.h"
#include "Guids.h"
#include <strsafe.h>
#include <autoptr.h>
#include <scopeguard.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HINSTANCE g_hInst=NULL;

CriticalSection s_CriticalSection(NOTHROW_LOCK) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DllStartup ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = WmiDebugLog :: Initialize ( *ProviderSubSystem_Globals :: s_Allocator ) ;

	t_Result = ProviderSubSystem_Globals :: Initialize_SharedCounters () ;
	if ( FAILED ( t_Result ) )
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ProviderSubSystem_Globals :: Initialize_Events () ;
		if ( SUCCEEDED ( t_Result ) )
		{
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ProviderSubSystem_Common_Globals :: CreateSystemAces () ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ProviderSubSystem_Common_Globals :: CreateMethodSecurityDescriptor () ;
	}
		
	if ( SUCCEEDED ( t_Result ) )
	{
		ProviderSubSystem_Globals :: s_StrobeThread = new StrobeThread ( *ProviderSubSystem_Globals :: s_Allocator, ProviderSubSystem_Globals :: s_StrobeTimeout ) ;
	
		if ( ProviderSubSystem_Globals :: s_StrobeThread)
		{
			if (!Dispatcher::scheduleTimer(*ProviderSubSystem_Globals :: s_StrobeThread, ProviderSubSystem_Globals :: s_StrobeTimeout, 0 , WT_EXECUTELONGFUNCTION))
			{
				ProviderSubSystem_Globals :: s_StrobeThread->Release();
				ProviderSubSystem_Globals :: s_StrobeThread=0;
				t_Result = WBEM_E_OUT_OF_MEMORY;
			}
			else
				ProviderSubSystem_Globals :: s_StrobeThread->Release();
		}
		else
		{
		    t_Result = WBEM_E_OUT_OF_MEMORY;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ProviderSubSystem_Globals :: s_CoFreeUnusedLibrariesEvent = OpenEvent (

			EVENT_ALL_ACCESS,
			FALSE,
			L"WINMGMT_PROVIDER_CANSHUTDOWN"
		) ;

		if ( ProviderSubSystem_Globals :: s_CoFreeUnusedLibrariesEvent == NULL )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiCoreServices *t_CoreService = NULL ;

		t_Result = CoCreateInstance (

			CLSID_IWmiCoreServices ,
			NULL ,
			CLSCTX_INPROC_SERVER ,
			IID__IWmiCoreServices ,
			( void ** )  & t_CoreService
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemServices *t_Service = NULL ;

			LONG t_Flags = WMICORE_FLAG_REPOSITORY | WMICORE_CLIENT_TYPE_PROVIDER ;

			t_Result = t_CoreService->GetServices (

				L"root" ,
				NULL,
				NULL,
				t_Flags ,
				IID_IWbemServices ,
				( void ** ) & t_Service
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				CServerObject_GlobalRegistration t_Registration ;
				t_Result = t_Registration.SetContext (

					NULL ,
					NULL ,
					t_Service
				) ;
				
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Registration.Load (

						e_All
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						ProviderSubSystem_Globals :: s_StrobeTimeout = t_Registration.GetUnloadTimeoutMilliSeconds () >> 1 ;
						ProviderSubSystem_Globals :: s_InternalCacheTimeout = t_Registration.GetUnloadTimeoutMilliSeconds () ;
						ProviderSubSystem_Globals :: s_ObjectCacheTimeout = t_Registration.GetObjectUnloadTimeoutMilliSeconds () ;
						ProviderSubSystem_Globals :: s_EventCacheTimeout = t_Registration.GetEventUnloadTimeoutMilliSeconds () ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					CServerObject_HostQuotaRegistration t_Registration ;
					t_Result = t_Registration.SetContext (

						NULL ,
						NULL ,
						t_Service
					) ;
					
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Registration.Load (

							e_All
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							ProviderSubSystem_Globals ::s_Quota_ProcessLimitCount = t_Registration.GetProcessLimitAllHosts () ;
							ProviderSubSystem_Globals ::s_Quota_ProcessMemoryLimitCount = t_Registration.GetMemoryPerHost () ;
							ProviderSubSystem_Globals ::s_Quota_JobMemoryLimitCount = t_Registration.GetMemoryAllHosts () ;
							ProviderSubSystem_Globals ::s_Quota_HandleCount = t_Registration.GetHandlesPerHost () ;
							ProviderSubSystem_Globals ::s_Quota_NumberOfThreads = t_Registration.GetThreadsPerHost () ;
							ProviderSubSystem_Globals ::s_Quota_PrivatePageCount = t_Registration.GetMemoryPerHost () ;
						}
					}
				}

				t_Service->Release () ;
			}

			t_CoreService->Release () ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ProviderSubSystem_Globals :: CreateJobObject () ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ProviderSubSystem_Globals :: s_Initialized = 1 ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DllShutdown ()
{
	HRESULT t_Result = S_OK ;

    if (ProviderSubSystem_Globals :: s_StrobeThread)
    {
	    Dispatcher::cancelTimer(*ProviderSubSystem_Globals :: s_StrobeThread);
    	    Dispatcher::close();
    	    ProviderSubSystem_Globals :: s_StrobeThread = 0;
    }
	
	t_Result = ProviderSubSystem_Globals :: UnInitialize_Events () ;

	t_Result = ProviderSubSystem_Globals :: UnInitialize_SharedCounters () ;

	if ( ProviderSubSystem_Globals :: s_CoFreeUnusedLibrariesEvent )
	{
		CloseHandle ( ProviderSubSystem_Globals :: s_CoFreeUnusedLibrariesEvent ) ;
		ProviderSubSystem_Globals :: s_CoFreeUnusedLibrariesEvent = NULL ;
	}

	t_Result = ProviderSubSystem_Common_Globals :: DeleteMethodSecurityDescriptor () ;

	t_Result = ProviderSubSystem_Common_Globals :: DeleteSystemAces () ;

	WmiStatusCode t_StatusCode = WmiDebugLog :: UnInitialize ( *ProviderSubSystem_Globals :: s_Allocator  ) ;

	t_Result = ProviderSubSystem_Globals :: DeleteJobObject () ;

	ProviderSubSystem_Globals :: s_Initialized = 0 ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
)
{
	g_hInst=hInstance;

	BOOL t_Status = TRUE ;

    if ( DLL_PROCESS_DETACH == ulReason )
	{
		HRESULT t_Result = ProviderSubSystem_Globals :: Global_Shutdown () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Status = TRUE ;
		}
		else
		{
			t_Status = FALSE ;
		}

		WmiHelper :: DeleteCriticalSection ( & s_CriticalSection ) ;

		t_Status = TRUE ;
    }
    else if ( DLL_PROCESS_ATTACH == ulReason )
	{
		DisableThreadLibraryCalls ( hInstance ) ;

		WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & s_CriticalSection ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			HRESULT t_Result = ProviderSubSystem_Globals :: Global_Startup () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Status = TRUE ;
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}
    }
    else if ( DLL_THREAD_DETACH == ulReason )
	{
		t_Status = TRUE ;
    }
    else if ( DLL_THREAD_ATTACH == ulReason )
	{
		t_Status = TRUE ;
    }

    return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllGetClassObject (

	REFCLSID rclsid , 
	REFIID riid, 
	void **ppv 
)
{
	HRESULT t_Result = S_OK ; 

	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & s_CriticalSection , FALSE ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		if ( ProviderSubSystem_Globals :: s_Initialized == 0 )
		{
			DllStartup () ;
		}

		if ( rclsid == CLSID_WmiProvSS ) 
		{
			CServerProvSubSysClassFactory *lpunk = new CServerProvSubSysClassFactory ;
			if ( lpunk == NULL )
			{
				t_Result = E_OUTOFMEMORY ;
			}
			else
			{
				t_Result = lpunk->QueryInterface ( riid , ppv ) ;
				if ( FAILED ( t_Result ) )
				{
					delete lpunk ;				
				}
				else
				{
				}			
			}
		}
		else if ( rclsid == CLSID_WmiProviderBindingFactory ) 
		{
			CServerClassFactory <CServerObject_BindingFactory,_IWmiProviderFactory> *lpunk = new CServerClassFactory <CServerObject_BindingFactory,_IWmiProviderFactory> ;
			if ( lpunk == NULL )
			{
				t_Result = E_OUTOFMEMORY ;
			}
			else
			{
				t_Result = lpunk->QueryInterface ( riid , ppv ) ;
				if ( FAILED ( t_Result ) )
				{
					delete lpunk ;				
				}
				else
				{
				}			
			}
		}
		else if ( rclsid == CLSID_WmiProviderInProcFactory ) 
		{
			CServerClassFactory <CServerObject_RawFactory,_IWmiProviderFactory> *lpunk = new CServerClassFactory <CServerObject_RawFactory,_IWmiProviderFactory> ;
			if ( lpunk == NULL )
			{
				t_Result = E_OUTOFMEMORY ;
			}
			else
			{
				t_Result = lpunk->QueryInterface ( riid , ppv ) ;
				if ( FAILED ( t_Result ) )
				{
					delete lpunk ;				
				}
				else
				{
				}			
			}
		}
		else if ( rclsid == CLSID_ProvSubSys_Provider ) 
		{
			CServerClassFactory <CServerObject_IWbemServices,IWbemServices> *lpunk = new CServerClassFactory <CServerObject_IWbemServices,IWbemServices> ;
			if ( lpunk == NULL )
			{
				t_Result = E_OUTOFMEMORY ;
			}
			else
			{
				t_Result = lpunk->QueryInterface ( riid , ppv ) ;
				if ( FAILED ( t_Result ) )
				{
					delete lpunk ;				
				}
				else
				{
				}			
			}
		}
		else
		{
			t_Result = CLASS_E_CLASSNOTAVAILABLE ;
		}

		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;
	}
	else
	{
		t_Result = E_OUTOFMEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllCanUnloadNow ()
{

/* 
 * Place code in critical section
 */
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & s_CriticalSection , FALSE ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{	
		BOOL unload = ( 
						ProviderSubSystem_Globals :: s_LocksInProgress || ProviderSubSystem_Globals :: s_ObjectsInProgress 
					) ;
		unload = ! unload ;

		if ( unload )
		{
			DllShutdown () ;
		}

		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

		return unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT SetApplicationSecurity ( HKEY a_Key , LPCWSTR a_Name , DWORD a_Access ) 
{
	HRESULT t_Result = S_OK ;

	SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

	PSID t_Administrator_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_Administrator_ACE = NULL ;
	WORD t_Administrator_ACESize = 0 ;

	BOOL t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		2 ,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_Administrator_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_Administrator_Sid );
		t_Administrator_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Administrator_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Administrator_ACESize ] ;
		if ( t_Administrator_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_Administrator_ACE->SidStart, t_Administrator_Sid ) ;
			t_Administrator_ACE->Mask = a_Access;
			t_Administrator_ACE->Header.AceType = 0 ;
			t_Administrator_ACE->Header.AceFlags = 3 ;
			t_Administrator_ACE->Header.AceSize = t_Administrator_ACESize ;
		}
		else
		{
			t_Result = E_OUTOFMEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = E_OUTOFMEMORY ;
	}

	PSID t_Interactive_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_Interactive_ACE = NULL ;
	WORD t_Interactive_ACESize = 0 ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_INTERACTIVE_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_Interactive_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_Interactive_Sid );
		t_Interactive_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Interactive_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Interactive_ACESize ] ;
		if ( t_Interactive_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_Interactive_ACE->SidStart, t_Interactive_Sid ) ;
			t_Interactive_ACE->Mask = a_Access;
			t_Interactive_ACE->Header.AceType = 0 ;
			t_Interactive_ACE->Header.AceFlags = 3 ;
			t_Interactive_ACE->Header.AceSize = t_Interactive_ACESize ;
		}
		else
		{
			t_Result = E_OUTOFMEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = E_OUTOFMEMORY ;
	}

	PSID t_System_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_System_ACE = NULL ;
	WORD t_System_ACESize = 0 ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_LOCAL_SYSTEM_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_System_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_System_Sid );
		t_System_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_System_ACESize ] ;
		if ( t_System_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_System_ACE->SidStart, t_System_Sid ) ;
			t_System_ACE->Mask = a_Access;
			t_System_ACE->Header.AceType = 0 ;
			t_System_ACE->Header.AceFlags = 3 ;
			t_System_ACE->Header.AceSize = t_System_ACESize ;
		}
		else
		{
			t_Result = E_OUTOFMEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = E_OUTOFMEMORY ;
	}

	PSID t_LocalService_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_LocalService_ACE = NULL ;
	WORD t_LocalService_ACESize = 0 ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_LOCAL_SERVICE_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_LocalService_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_LocalService_Sid );
		t_LocalService_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_LocalService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_LocalService_ACESize ] ;
		if ( t_LocalService_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_LocalService_ACE->SidStart, t_LocalService_Sid ) ;
			t_LocalService_ACE->Mask = a_Access;
			t_LocalService_ACE->Header.AceType = 0 ;
			t_LocalService_ACE->Header.AceFlags = 3 ;
			t_LocalService_ACE->Header.AceSize = t_LocalService_ACESize ;
		}
		else
		{
			t_Result = E_OUTOFMEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = E_OUTOFMEMORY ;
	}

	PSID t_NetworkService_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_NetworkService_ACE = NULL ;
	WORD t_NetworkService_ACESize = 0 ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_NETWORK_SERVICE_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_NetworkService_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_NetworkService_Sid );
		t_NetworkService_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_NetworkService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_NetworkService_ACESize ] ;
		if ( t_NetworkService_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_NetworkService_ACE->SidStart, t_NetworkService_Sid ) ;
			t_NetworkService_ACE->Mask = a_Access;
			t_NetworkService_ACE->Header.AceType = 0 ;
			t_NetworkService_ACE->Header.AceFlags = 3 ;
			t_NetworkService_ACE->Header.AceSize = t_NetworkService_ACESize ;
		}
		else
		{
			t_Result = E_OUTOFMEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = E_OUTOFMEMORY ;
	}

	// Now we need to set permissions on the registry: Everyone read; Admins full.
	// We have the sid for admins from the above code.  Now get the sid for "Everyone"

	DWORD t_TotalAclSize = sizeof(ACL) + t_Administrator_ACESize + t_Interactive_ACESize + t_LocalService_ACESize + 
										 t_NetworkService_ACESize + t_System_ACESize ;
	PACL t_Dacl = (PACL) new BYTE [ t_TotalAclSize ] ;
	if ( t_Dacl )
	{
		if ( :: InitializeAcl ( t_Dacl, t_TotalAclSize, ACL_REVISION ) )
		{
			DWORD t_AceIndex = 0 ;

			if ( t_Interactive_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_Interactive_ACE , t_Interactive_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			if ( t_System_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_System_ACE , t_System_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			if ( t_LocalService_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_LocalService_ACE , t_LocalService_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			if ( t_NetworkService_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_NetworkService_ACE , t_NetworkService_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			
			if ( t_Administrator_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_Administrator_ACE , t_Administrator_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			SECURITY_INFORMATION t_SecurityInfo = 0L;

			t_SecurityInfo |= DACL_SECURITY_INFORMATION;
			t_SecurityInfo |= PROTECTED_DACL_SECURITY_INFORMATION;

			SECURITY_DESCRIPTOR t_SecurityDescriptor ;
			t_BoolResult = InitializeSecurityDescriptor ( & t_SecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
			if ( t_BoolResult )
			{
				t_BoolResult = SetSecurityDescriptorDacl (

				  & t_SecurityDescriptor ,
				  TRUE ,
				  t_Dacl ,
				  FALSE
				) ;

				if ( t_BoolResult )
				{
					t_BoolResult = SetSecurityDescriptorOwner (

						& t_SecurityDescriptor ,
						t_System_Sid,
						FALSE 				
					) ;
				}

				if ( t_BoolResult )
				{
					t_BoolResult = SetSecurityDescriptorGroup (

						& t_SecurityDescriptor ,
						t_Administrator_Sid,
						FALSE 				
					) ;
				}

				if ( t_BoolResult )
				{
					DWORD t_Length = GetSecurityDescriptorLength ( & t_SecurityDescriptor ) ;

					SECURITY_DESCRIPTOR *t_RelativeSecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_Length ];
;					if ( t_RelativeSecurityDescriptor )
					{
						t_BoolResult = MakeSelfRelativeSD (

							& t_SecurityDescriptor ,
							t_RelativeSecurityDescriptor ,
							& t_Length 
						);

						if ( t_BoolResult )
						{
							DWORD t_ValueType = REG_BINARY ;
							DWORD t_DataSize = t_Length ;

							LONG t_RegResult = RegSetValueEx (

							  a_Key ,
							  a_Name ,
							  0 ,
							  t_ValueType ,
							  LPBYTE ( t_RelativeSecurityDescriptor ) ,
							  t_DataSize 
							) ;

							if ( t_RegResult != ERROR_SUCCESS ) 
							{
								t_Result = E_FAIL ;
							}
						}

						delete [] t_RelativeSecurityDescriptor ;
					}
					else
					{
						t_Result = E_OUTOFMEMORY ;
					}
				}
				else
				{
					t_Result = E_FAIL ;	
				}
			}
			else
			{
				t_Result = E_FAIL ;	
			}
		}

		delete [] ( ( BYTE * ) t_Dacl ) ;
	}
	else
	{
		t_Result = E_OUTOFMEMORY ;
	}

	if ( t_Administrator_ACE )
	{
		delete [] ( ( BYTE * ) t_Administrator_ACE ) ;
	}

	if ( t_Interactive_ACE )
	{
		delete [] ( ( BYTE * ) t_Interactive_ACE ) ;
	}

	if ( t_System_ACE )
	{
		delete [] ( ( BYTE * ) t_System_ACE ) ;
	}

	if ( t_LocalService_ACE )
	{
		delete [] ( ( BYTE * ) t_LocalService_ACE ) ;
	}

	if ( t_NetworkService_ACE )
	{
		delete [] ( ( BYTE * ) t_NetworkService_ACE ) ;
	}

	if ( t_Interactive_Sid )
	{
		FreeSid ( t_Interactive_Sid ) ;
	}

	if ( t_System_Sid )
	{
		FreeSid ( t_System_Sid ) ;
	}

	if ( t_LocalService_Sid )
	{
		FreeSid ( t_LocalService_Sid ) ;
	}

	if ( t_NetworkService_Sid )
	{
		FreeSid ( t_NetworkService_Sid ) ;
	}

	if ( t_Administrator_Sid )
	{
		FreeSid ( t_Administrator_Sid ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

//Strings used during self registeration


#define REG_FORMAT_STR			L"%s\\%s"
#define NOT_INSERT_STR			L"NotInsertable"
#define INPROC32_STR			L"InprocServer32"
#define LOCALSERVER32_STR		L"LocalServer32"
#define THREADING_MODULE_STR	L"ThreadingModel"
#define APARTMENT_STR			L"Both"
#define APPID_VALUE_STR			L"AppId"
#define APPID_STR				L"APPID\\"
#define CLSID_STR				L"CLSID\\"

#define WMI_PROVIDER_SUBSYSTEM				__TEXT("Microsoft WMI Provider Subsystem")
#define WMI_PROVIDER_HOST					__TEXT("Microsoft WMI Provider Subsystem Host")
#define WMI_PROVIDER_BINDINGFACTORY			__TEXT("Microsoft WMI Provider Subsystem Binding Factory")
#define WMI_PROVIDER_INPROCFACTORY			__TEXT("Microsoft WMI Provider Subsystem InProc Factory")
#define WMI_PROVIDER_HOSTINPROCFACTORY		__TEXT("Microsoft WMI Provider Subsystem Host InProc Factory")
#define WMI_PROVIDER						__TEXT("Microsoft WMI Provider Subsystem Self Instrumentation")
#define WMI_REFRESHER_MANAGER				__TEXT("Microsoft WMI Provider Subsystem Refresher Manager")

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL SetKeyAndValue ( wchar_t *pszKey , wchar_t *pszSubkey , wchar_t *pszValueName , wchar_t *pszValue )
{
    HKEY hKey;
    wchar_t szKey[256];
    StringCchCopyW ( szKey , 256,  pszKey ) ;

    if (NULL!=pszSubkey)
    	{
	 StringCchCatW ( szKey , 256, L"\\" ) ;
        StringCchCatW ( szKey , 256, pszSubkey ) ;
    	}

    if ( ERROR_SUCCESS != RegCreateKeyEx ( 

			HKEY_CLASSES_ROOT , 
			szKey , 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE ,
			KEY_ALL_ACCESS, 
			NULL, 
			&hKey, 
			NULL
		)
	)
	{
        return FALSE ;
	}

    if ( NULL != pszValue )
    {
        if ( ERROR_SUCCESS != RegSetValueEx (

				hKey, 
				pszValueName, 
				0, 
				REG_SZ, 
				(BYTE *) pszValue , 
				(lstrlen(pszValue)+1)*sizeof(wchar_t)
			)
		)
		{
			return FALSE;
		}
    }

    RegCloseKey ( hKey ) ;

    return TRUE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class OnScopeClose_DeleteString 
{
private:

	wchar_t *m_Executable ;

protected:
public:

	OnScopeClose_DeleteString ( wchar_t *a_Executable ) : m_Executable ( a_Executable )
	{
	}

	~OnScopeClose_DeleteString ()
	{
		delete [] m_Executable ;
	}
} ;

STDAPI RegisterServer ( 

	BOOL a_Local , 
	BOOL a_InProc , 
	GUID a_ProviderClassId , 
	wchar_t *a_ProviderName ,
	wchar_t *a_ExecutableArguments
)
{
	wchar_t t_Executable [MAX_PATH + 1];
	t_Executable [ 0 ] = 0 ;
	t_Executable [ MAX_PATH ] = 0 ;
	DWORD t_Length = GetModuleFileName (

		g_hInst , 
		( wchar_t * ) t_Executable , 
		sizeof ( t_Executable ) / sizeof ( wchar_t ) - 1
	) ;

	if ( t_Length )
	{

		DWORD t_ExecutableAndArgsLength = wcslen ( t_Executable ) + 1 ;
	
		if (a_ExecutableArguments)
		{
			t_ExecutableAndArgsLength += sizeof ( L" " )/sizeof(wchar_t) + wcslen ( a_ExecutableArguments ) ;
		}

		wchar_t *t_ExecutableAndArgs = new wchar_t [ t_ExecutableAndArgsLength ] ;
		if ( t_ExecutableAndArgs )
		{
			OnScopeClose_DeleteString t_GarbageCollect ( t_ExecutableAndArgs ) ;

			StringCchCopyW ( t_ExecutableAndArgs ,t_ExecutableAndArgsLength,  t_Executable ) ;
			if ( a_ExecutableArguments )
			{
				StringCchCatW ( t_ExecutableAndArgs , t_ExecutableAndArgsLength, L" " ) ;
				StringCchCatW ( t_ExecutableAndArgs , t_ExecutableAndArgsLength, a_ExecutableArguments ) ;
			}
		
			wchar_t szProviderClassID[128];
			wchar_t szProviderCLSIDClassID[128];

			int iRet = StringFromGUID2(a_ProviderClassId,szProviderClassID, 128);

			if ( a_Local )
			{
				wchar_t szProviderCLSIDAppID[128];
				StringCchCopyW(szProviderCLSIDAppID,128, APPID_STR);
				StringCchCatW(szProviderCLSIDAppID,128, szProviderClassID);

				if (FALSE ==SetKeyAndValue(szProviderCLSIDAppID, NULL, NULL, a_ProviderName ))
					return SELFREG_E_CLASS;

				HKEY t_Key ;
				DWORD t_Disposition = 0 ;

				LONG t_RegResult = RegOpenKeyEx (

					HKEY_CLASSES_ROOT ,
					szProviderCLSIDAppID ,
					NULL ,
					KEY_READ | KEY_WRITE ,
					& t_Key
				) ;

				if ( t_RegResult == ERROR_SUCCESS )
				{
					ON_BLOCK_EXIT(RegCloseKey, t_Key);
					HRESULT t_Result = SetApplicationSecurity ( t_Key , L"LaunchPermission" , COM_RIGHTS_EXECUTE ) ;

					if ( FAILED ( t_Result ) )
					{
						return SELFREG_E_CLASS;
					}
				}
				else
				{
					return SELFREG_E_CLASS;
				}
			}

			StringCchCopyW(szProviderCLSIDClassID,128, CLSID_STR);
			StringCchCatW(szProviderCLSIDClassID,128, szProviderClassID);

			if ( a_Local )
			{
				if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL , APPID_VALUE_STR, szProviderClassID ))
					return SELFREG_E_CLASS;
			}

				//Create entries under CLSID
			if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, a_ProviderName ))
				return SELFREG_E_CLASS;

			if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INSERT_STR, NULL, NULL))
					return SELFREG_E_CLASS;

			if ( a_Local )
			{
				if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, LOCALSERVER32_STR, NULL,t_ExecutableAndArgs))
					return SELFREG_E_CLASS;

				if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, LOCALSERVER32_STR,THREADING_MODULE_STR, APARTMENT_STR))
					return SELFREG_E_CLASS;
			}

			if ( a_InProc )
			{
				if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,t_ExecutableAndArgs))
					return SELFREG_E_CLASS;

				if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
					return SELFREG_E_CLASS;
			}
		
			return S_OK;
		}
		else
		{
			return E_FAIL ;
		}
	}
	else
	{
		return E_FAIL ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI UnregisterServer( BOOL a_Local , BOOL a_InProc , GUID a_ProviderClassId )
{
	wchar_t szTemp[128];

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	int iRet = StringFromGUID2(a_ProviderClassId ,szProviderClassID, 128);

	StringCchCopyW(szProviderCLSIDClassID,128, CLSID_STR);
	StringCchCatW(szProviderCLSIDClassID,128, szProviderClassID);

	//Delete entries under CLSID

	StringCchPrintfW(szTemp, 128, REG_FORMAT_STR, szProviderCLSIDClassID, NOT_INSERT_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	if ( a_Local )
	{
		wchar_t szProviderCLSIDAppID[128];
		StringCchCopyW(szProviderCLSIDAppID,128, APPID_STR);
		StringCchCatW(szProviderCLSIDAppID,128, szProviderClassID);

		//Delete entries under APPID

		DWORD t_Status = RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDAppID);

		StringCchPrintfW(szTemp, 128, REG_FORMAT_STR,szProviderCLSIDClassID, LOCALSERVER32_STR);
		t_Status = RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);
	}

	if ( a_InProc )
	{
		StringCchPrintfW(szTemp, 128, REG_FORMAT_STR,szProviderCLSIDClassID, INPROC32_STR);
		RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);
	}

	RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDClassID);

    return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllRegisterServer ()
{
	HRESULT t_Result ;

#ifdef WMIASLOCAL
	t_Result = RegisterServer ( TRUE , FALSE , CLSID_WmiProviderHost				,	WMI_PROVIDER_HOST , NULL ) ;
#else
	t_Result = RegisterServer ( FALSE , TRUE , CLSID_WmiProvSS						,	WMI_PROVIDER_SUBSYSTEM , NULL ) ;
	t_Result = RegisterServer ( FALSE , TRUE , CLSID_WmiProviderBindingFactory		,	WMI_PROVIDER_BINDINGFACTORY , NULL ) ;
	t_Result = RegisterServer ( FALSE , TRUE , CLSID_WmiProviderInProcFactory		,	WMI_PROVIDER_INPROCFACTORY , NULL ) ;
	t_Result = RegisterServer ( FALSE , TRUE , CLSID_ProvSubSys_Provider			,	WMI_PROVIDER , NULL ) ;
#endif

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllUnregisterServer ()
{
	HRESULT t_Result ;

#ifdef WMIASLOCAL
	t_Result = UnregisterServer ( TRUE , FALSE , CLSID_WmiProviderHost ) ;
#else
	t_Result = UnregisterServer ( FALSE , TRUE , CLSID_WmiProvSS ) ;
	t_Result = UnregisterServer ( FALSE , TRUE , CLSID_WmiProviderBindingFactory ) ;
	t_Result = UnregisterServer ( FALSE , TRUE , CLSID_WmiProviderInProcFactory ) ;
	t_Result = UnregisterServer ( FALSE , TRUE , CLSID_ProvSubSys_Provider ) ;
#endif

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\main.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Main.cpp

Abstract:


History:

--*/

#include <precomp.h>

#include <objbase.h>
#include <stdio.h>
#include <wbemint.h>
#include <Thread.h>
#include <HelperFuncs.h>
#include <Logging.h>

#include "Globals.h"
#include "CGlobals.h"
#include "classfac.h"
#include "ProvLoad.h"
#include "ProvAggr.h"
#include "ProvHost.h"
#include "guids.h"
#include "Main.h"

#include <locale.h>

#include <helper.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define PROVIDER_HOST_DLL_TIMEOUT (10*1000) // 10 seconds

#define VALIDATE_HEAP {};
#ifdef DEV_BUILD
#ifdef  _X86_

////////////////////////////////////////////////////////
class ValidateHeap : public EventHandler
{
	BOOL (* rtlValidateProcessHeaps)(void);
public:

	ValidateHeap () ;
	int handleTimeout (void) ;
	void validateHeap();
} heapValidator;

#undef VALIDATE_HEAP
#define VALIDATE_HEAP {heapValidator.validateHeap(); };

ValidateHeap::ValidateHeap()
{
	FARPROC OldRoutine = GetProcAddress(GetModuleHandleW(L"NTDLL"),"RtlValidateProcessHeaps");
	rtlValidateProcessHeaps = reinterpret_cast<BOOL (*)(void)>(OldRoutine) ;
}

int 
ValidateHeap::handleTimeout (void)
{
	validateHeap();
	return 0;
}

void
ValidateHeap::validateHeap (void)
{
	//NtCurrentPeb()->BeingDebugged = 1;
	if (rtlValidateProcessHeaps)
	{
	    if ((*rtlValidateProcessHeaps)()==FALSE)
		    DebugBreak();
	}
	//NtCurrentPeb()->BeingDebugged = 0;
}
////////////////////////////////////////////////////////

#include <malloc.h>

struct HEAP_ENTRY {
	WORD Size;
	WORD PrevSize;
	BYTE SegmentIndex;
	BYTE Flags;
    BYTE UnusedBytes;
	BYTE SmallTagIndex;
};

#define HEAP_SLOW_FLAGS  0x7d030f60

// only the "header"

typedef struct _HEAP {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
} HEAP;


BOOL  g_FaultHeapEnabled = FALSE;
BOOL  g_FaultFileEnabled = FALSE;
ULONG g_Seed;
ULONG g_Factor  = 100000;
ULONG g_Percent = 0x20;
//ULONG g_RowOfFailures = 5;
//LONG  g_NumFailInARow = 0;
//LONG  g_NumFailedAllocation = 0;
BOOL g_bDisableBreak = FALSE;
BOOL g_ExitProcessCalled = FALSE;
LONG g_Index = -1;

class CS_ : public CRITICAL_SECTION
{
public:
	CS_(){InitializeCriticalSection(this);};
	~CS_(){DeleteCriticalSection(this);};
} g_CS;

#define MAX_OPERATIONS (1024*8)

typedef struct _FinalOperations 
{
    enum OpType
    {
        Delete = 'eerF',
        Alloc  = 'ollA',
        ReAlloc = 'lAeR',
        Destroy = 'tseD',
        Create = 'aerC'        
    };
    OpType m_OpType;
    ULONG_PTR m_Addr;
    PVOID m_Stack[6];   
} FinalOperations;

/*
FinalOperations g_FinalOp[MAX_OPERATIONS];

VOID SetFinalOp(FinalOperations::OpType Type,
	          ULONG_PTR Addr)
{
    if (!g_ExitProcessCalled)
    	return;

    if (g_bDisableBreak)
    	return;
    
    ULONG * pDW = (ULONG *)_alloca(sizeof(ULONG));
    LONG NewIndex = InterlockedIncrement(&g_Index);
    NewIndex %= MAX_OPERATIONS;
    //if (g_Index >= MAX_OPERATIONS)
    //{    	
    //	InterlockedIncrement(&g_IndexRot);
    //}
    g_FinalOp[NewIndex].m_OpType = Type;
    g_FinalOp[NewIndex].m_Addr = Addr;
    RtlCaptureStackBackTrace(2,
        		          6,
                		  (PVOID *)g_FinalOp[NewIndex].m_Stack,
                          pDW);    
}
*/
#define SIZE_JUMP_ADR    5
#define SIZE_SAVED_INSTR 12

void
_declspec(naked) Prolog__ReadFile(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
	}
}


BOOL _I_ReadFile(
  HANDLE hFile,               // handle to file
  LPVOID lpBuffer,            // data buffer
  DWORD nNumberOfBytesToRead, // number of bytes to read
  LPDWORD lpNumberOfBytesRead, // number of bytes read  
  LPOVERLAPPED lpOverlapped   // offset
){
	DWORD * pDw = (DWORD *)_alloca(sizeof(DWORD));
    BOOL bRet;

	LONG Ret = RtlRandomEx(&g_Seed);
	if (g_FaultFileEnabled && (Ret%g_Factor < g_Percent))
	{
	    if (lpNumberOfBytesRead)
	        *lpNumberOfBytesRead = 0;
		return FALSE;
	}    
    
    _asm{
		push lpOverlapped;
        push lpNumberOfBytesRead;
		push nNumberOfBytesToRead;
		push lpBuffer;
		push hFile;
		call Prolog__ReadFile;
		mov  bRet,eax
	}

    return bRet;
}


void
_declspec(naked) Prolog__WriteFile(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
	}
}

BOOL _I_WriteFile(
  HANDLE hFile,                    // handle to file
  LPCVOID lpBuffer,                // data buffer
  DWORD nNumberOfBytesToWrite,     // number of bytes to write
  LPDWORD lpNumberOfBytesWritten,  // number of bytes written
  LPOVERLAPPED lpOverlapped        // overlapped buffer
){

	DWORD * pDw = (DWORD *)_alloca(sizeof(DWORD));
    BOOL bRet;

	LONG Ret = RtlRandomEx(&g_Seed);
	if (g_FaultFileEnabled && (Ret%g_Factor < g_Percent))
	{
	    if (lpNumberOfBytesWritten)
	        *lpNumberOfBytesWritten = 0;
		return FALSE;
	}    
    
    _asm{
		push lpOverlapped;
        push lpNumberOfBytesWritten;
		push nNumberOfBytesToWrite;
		push lpBuffer;
		push hFile;
		call Prolog__WriteFile;
		mov  bRet,eax
	}

    return bRet;
}


void
_declspec(naked) Prolog__CreateEvent(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
	}
}

HANDLE _I_CreateEvent(
  LPSECURITY_ATTRIBUTES lpEventAttributes, // SD
  BOOL bManualReset,                       // reset type
  BOOL bInitialState,                      // initial state
  LPCWSTR lpName                           // object name
)
{
	DWORD * pDw = (DWORD *)_alloca(sizeof(DWORD));
	HANDLE hHandle;

	LONG Ret = RtlRandomEx(&g_Seed);
	if (g_FaultFileEnabled && (Ret%g_Factor < g_Percent))
	{
		return NULL;
	}

    _asm{
		push lpName;
        push bInitialState;
		push bManualReset;
		push lpEventAttributes
		call Prolog__CreateEvent;
		mov  hHandle,eax
	}
    
	return hHandle;
}


void
_declspec(naked) Prolog__RtlFreeHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
	}
}

#define SPACE_STACK_ALLOC (4*sizeof(ULONG_PTR))

DWORD _I_RtlFreeHeap(VOID * pHeap,DWORD Flags,VOID * pBlock)
{	
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
	Flags |= (((HEAP *)pHeap)->Flags) | (((HEAP *)pHeap)->ForceFlags);	
	DWORD dwRet;

	if (pBlock && !(HEAP_SLOW_FLAGS & Flags))
	{
		HEAP_ENTRY * pEntry = (HEAP_ENTRY *)pBlock-1;

              DWORD RealSize = pEntry->Size * sizeof(HEAP_ENTRY);
		DWORD Size = RealSize - pEntry->UnusedBytes;
		
		ULONG_PTR * pL = (ULONG_PTR *)pBlock;

		if (0 == (pEntry->Flags & 0x01) ||0xf0f0f0f0 == pL[1] )
		{
			if (!g_bDisableBreak)
				DebugBreak();
		}
		
		//memset(pBlock,0xF0,RealSize-SPACE_STACK_ALLOC-sizeof(HEAP_ENTRY));		
		DWORD CanMemset = RealSize-sizeof(HEAP_ENTRY);
		memset(pBlock,0xF0,(CanMemset > SPACE_STACK_ALLOC)?CanMemset-SPACE_STACK_ALLOC:CanMemset);
		
				
		if (pEntry->Size >=4)
		{		    
		    RtlCaptureStackBackTrace (1,
        		                      4,
                		              (PVOID *)(pEntry+2),
                        		      pLong);		
		}

	}

	_asm {
		push pBlock              ;
		push Flags               ;
		push pHeap               ;
		call Prolog__RtlFreeHeap ;
		mov  dwRet,eax           ;
	}

    //SetFinalOp(FinalOperations::Delete,(ULONG_PTR)pBlock);

	return dwRet;
}

void
_declspec(naked) Prolog__RtlAllocateHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // to make this distinct
	}
}

VOID * _I_RtlAllocateHeap(VOID * pHeap,DWORD Flags,DWORD Size)
{
	//Size+=0x1000;	
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
	Flags |= (((HEAP *)pHeap)->Flags) | (((HEAP *)pHeap)->ForceFlags);	
	VOID * pRet;
	DWORD NewSize = (Size < (3*sizeof(HEAP_ENTRY)))?(3*sizeof(HEAP_ENTRY)+SPACE_STACK_ALLOC):(Size+SPACE_STACK_ALLOC);	


//       if (g_FaultHeapEnabled && g_NumFailInARow)
//       {
//       	InterlockedDecrement(&g_NumFailInARow);
//       	goto here;
//       }
       
	LONG Ret = RtlRandomEx(&g_Seed);
	if (g_FaultHeapEnabled && (Ret%g_Factor < g_Percent))
	{
//		g_NumFailInARow = g_RowOfFailures;
//here:		
//		InterlockedIncrement(&g_NumFailedAllocation);
		return NULL;
	}

	_asm {
		push NewSize                 ;
		push Flags                   ;
		push pHeap                   ;
		call Prolog__RtlAllocateHeap ;
		mov  pRet,eax                ;
	}

    //SetFinalOp(FinalOperations::Alloc,(ULONG_PTR)pRet);	
	
	if (pRet && !(HEAP_SLOW_FLAGS & Flags) )
	{

	   if (NewSize <= 0xffff)
       	    NewSize = sizeof(HEAP_ENTRY)*((HEAP_ENTRY *)pRet-1)->Size;
		
	    if (!(HEAP_ZERO_MEMORY & Flags))
	    {	
		    memset(pRet,0xc0,NewSize-sizeof(HEAP_ENTRY));
	    }

	    RtlCaptureStackBackTrace(1,
	    	                                     4,
                         		               (PVOID *)((BYTE *)pRet+(NewSize-SPACE_STACK_ALLOC-sizeof(HEAP_ENTRY))),
                        		               pLong);
	    
	}
	

	return pRet;
	
}

void
_declspec(naked) Prolog__RtlReAllocateHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
		nop ; // dist			
	}
}


VOID *
_I_RtlReAllocateHeap(
  HANDLE pHeap,   // handle to heap block
  DWORD Flags,  // heap reallocation options
  LPVOID lpMem,   // pointer to memory to reallocate
  SIZE_T Size  // number of bytes to reallocate
){
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
	Flags |= (((HEAP *)pHeap)->Flags) | (((HEAP *)pHeap)->ForceFlags);	
	VOID * pRet;

	DWORD NewSize = (Size < (3*sizeof(HEAP_ENTRY)))?(3*sizeof(HEAP_ENTRY)+SPACE_STACK_ALLOC):(Size+SPACE_STACK_ALLOC);
	
	_asm {
		push NewSize                 ;
		push lpMem                   ;
		push Flags                 ;
		push pHeap                   ;
		call Prolog__RtlReAllocateHeap ;
		mov  pRet,eax                ;
	}

    //SetFinalOp(FinalOperations::ReAlloc,(ULONG_PTR)pRet);	

	if (pRet && !(HEAP_SLOW_FLAGS & Flags) )
	{

	   if (NewSize <= 0xffff)
       	    NewSize = sizeof(HEAP_ENTRY)*((HEAP_ENTRY *)pRet-1)->Size;
		
	    RtlCaptureStackBackTrace(1,
	    	                                     4,
                         		               (PVOID *)((BYTE *)pRet+(NewSize-SPACE_STACK_ALLOC-sizeof(HEAP_ENTRY))),
                        		               pLong);
	    
	}


       return pRet;
}

void
_declspec(naked) Prolog__RtlValidateHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
		nop ; // dist			
		nop ; // dist			
	}
}

BOOL
_I_RtlValidateHeap(
  HANDLE pHeap,   // handle to heap block
  DWORD dwFlags,  // heap reallocation options
  LPVOID lpMem   // pointer to memory to validate
){
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
	BOOL bRet;

       g_bDisableBreak = TRUE;
	
	_asm {
		push lpMem                   ;
		push dwFlags                 ;
		push pHeap                   ;
		call Prolog__RtlValidateHeap ;
		mov  bRet,eax                ;
	}

       g_bDisableBreak = FALSE;

       return bRet;
}

void
_declspec(naked) Prolog__RtlCreateHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
		nop ; // dist			
		nop ; // dist			
		nop ; // dist		
	}
}

PVOID
_I_RtlCreateHeap (
    IN ULONG Flags,
    IN PVOID HeapBase,
    IN SIZE_T ReserveSize,
    IN SIZE_T CommitSize,
    IN PVOID Lock_,
    IN VOID * Parameters
    )
{
    EnterCriticalSection(&g_CS);
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
	PVOID pHeap;
	
	_asm {
		push Parameters        ;
		push Lock_              ;
		push CommitSize        ;
		push  ReserveSize      ;
		push HeapBase          ;		
		push Flags             ;
		call Prolog__RtlCreateHeap ;
		mov  pHeap,eax         ;
	}
	if (pHeap)
	{
	    HEAP * pRealHeap = (HEAP *)pHeap;
	    if (pRealHeap->Flags & (HEAP_TAIL_CHECKING_ENABLED | HEAP_FREE_CHECKING_ENABLED))
	    {
    	    pRealHeap->Flags &= ~(HEAP_TAIL_CHECKING_ENABLED | HEAP_FREE_CHECKING_ENABLED);
    	}
	    if (pRealHeap->ForceFlags & (HEAP_TAIL_CHECKING_ENABLED | HEAP_FREE_CHECKING_ENABLED))
	    {
    	    pRealHeap->ForceFlags &= ~(HEAP_TAIL_CHECKING_ENABLED | HEAP_FREE_CHECKING_ENABLED);
    	}	    
	}

    //SetFinalOp(FinalOperations::ReAlloc,(ULONG_PTR)pHeap);
    LeaveCriticalSection(&g_CS);
	return pHeap;
}


void
_declspec(naked) Prolog__RtlDestroyHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
		nop ; // dist			
		nop ; // dist			
		nop ; // dist		
		nop ; // dist		
	}
}

PVOID
_I_RtlDestroyHeap (
    IN PVOID HeapHandle
    )
{
    EnterCriticalSection(&g_CS);
    
    ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));    
    PVOID pRet;

    //SetFinalOp(FinalOperations::Destroy,(ULONG_PTR)HeapHandle);
    
    VALIDATE_HEAP;
    	
    _asm {
    	push HeapHandle;
    	call Prolog__RtlDestroyHeap;
    	mov pRet, eax;
    }

    LeaveCriticalSection(&g_CS);
    return pRet;
}

#define MAX_REMEMBER (1024) 

struct CSCCTrace
{
    enum OpType {
    	Enter = 'rtnE',
    	Leave = 'vaeL'
    };
    OpType Type;
    DWORD Tid;
    ULONG_PTR Trace[6];
} g_CSCCTrace[MAX_REMEMBER];

LONG g_CSCCIndex = -1;

RTL_CRITICAL_SECTION * g_HeapLock;

void
_declspec(naked) Prolog__RtlEnterCriticalSection(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
		nop ; // dist			
		nop ; // dist			
		nop ; // dist			
		nop ; // dist
		nop ; // dist		
	}
}

NTSTATUS
_I_RtlEnterCriticalSection(PRTL_CRITICAL_SECTION CriticalSection)
{
    ULONG * pLong = (ULONG * )_alloca(sizeof(ULONG ));

    if (g_HeapLock == CriticalSection)
    {
	    long nIndex = InterlockedIncrement(&g_CSCCIndex);
	    nIndex %= MAX_REMEMBER;
	    CSCCTrace * pTrace = &g_CSCCTrace[nIndex];
	    pTrace->Type = CSCCTrace::Enter;
	    pTrace->Tid =GetCurrentThreadId();
	    RtlCaptureStackBackTrace (2,6,(PVOID *)pTrace->Trace,pLong);    
    }
    
    NTSTATUS Status;
    _asm {	
    	push CriticalSection;
    	call Prolog__RtlEnterCriticalSection;
    	mov Status,eax;
    };
    return Status;    
}

void
_declspec(naked) Prolog__RtlLeaveCriticalSection(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
		nop ; // dist			
		nop ; // dist			
		nop ; // dist			
		nop ; // dist
		nop ; // dist
		nop ; // dist		
	}
}


NTSTATUS
_I_RtlLeaveCriticalSection(PRTL_CRITICAL_SECTION CriticalSection)
{
    ULONG * pLong = (ULONG * )_alloca(sizeof(ULONG ));
    if (g_HeapLock == CriticalSection)
    {
	    long nIndex = InterlockedIncrement(&g_CSCCIndex);
	    nIndex %= MAX_REMEMBER;
	    CSCCTrace * pTrace = &g_CSCCTrace[nIndex];
	    pTrace->Type = CSCCTrace::Leave;
	    pTrace->Tid =GetCurrentThreadId();
	    RtlCaptureStackBackTrace (2,6,(PVOID *)pTrace->Trace,pLong);
    }
    
    NTSTATUS Status;
    _asm {	
    	push CriticalSection;
    	call Prolog__RtlLeaveCriticalSection;
    	mov Status,eax;
    };
    return Status;    
}

void intercept2(WCHAR * Module,
			   LPSTR Function,
			   VOID * NewRoutine,
			   VOID * pPrologStorage,
			   DWORD Size)    
{
	FARPROC OldRoutine = GetProcAddress(GetModuleHandleW(Module),Function);

	if (OldRoutine)
	{
		MEMORY_BASIC_INFORMATION MemBI;
		DWORD dwOldProtect;
		BOOL bRet, bRet2;
		DWORD dwRet;

		dwRet = VirtualQuery(OldRoutine,&MemBI,sizeof(MemBI));

		bRet = VirtualProtect(MemBI.BaseAddress,
							  MemBI.RegionSize,
							  PAGE_EXECUTE_WRITECOPY,
							  &dwOldProtect);

		dwRet = VirtualQuery(pPrologStorage,&MemBI,sizeof(MemBI));

		bRet2 = VirtualProtect(MemBI.BaseAddress,
							  MemBI.RegionSize,
							  PAGE_EXECUTE_WRITECOPY,
							  &dwOldProtect);

		if (bRet && bRet2)
		{
			VOID * pToJump = (VOID *)NewRoutine;
			BYTE Arr[SIZE_JUMP_ADR] = { 0xe9 };
			
			LONG * pOffset = (LONG *)&Arr[1];
			* pOffset = (LONG)NewRoutine - (LONG)OldRoutine - SIZE_JUMP_ADR ;        
			// save the old code
			
			memcpy(pPrologStorage,OldRoutine,Size); 		
			// put the new code
			memset(OldRoutine,0x90,Size);
			memcpy(OldRoutine,Arr,SIZE_JUMP_ADR);
			// adjust the prolog to continue
			* pOffset = (LONG)OldRoutine + Size - (LONG)pPrologStorage - SIZE_SAVED_INSTR - SIZE_JUMP_ADR; // magic for nops
			memcpy((BYTE *)pPrologStorage+SIZE_SAVED_INSTR,Arr,SIZE_JUMP_ADR);
		}
	}
	else
	{
		OutputDebugStringA("GetProcAddress FAIL\n");
	}
}

void unintercept(WCHAR * Module,
                 LPSTR Function,
			     VOID * pPrologStorage,
			     DWORD Size)
{
    FARPROC OldRoutine = GetProcAddress(GetModuleHandleW(Module),Function);

	if (OldRoutine)
	{
	    memcpy((void *)OldRoutine,pPrologStorage,Size);
	}
}

#endif /*_X86_*/

class CSetVectoredHandler
{
private:
//	static ULONG_PTR Base;
//	static ULONG_PTR Limit;
	PVOID     pVectorHandler;
	enum ExceptionTypes
	{
	    StatusAccessViolation,
	    CXXException,
	    StatusNoMemory,
	    OtherExceptions,
	    LastException
	};
	static LONG ExceptionCounters[LastException];
	static DWORD s_ThreadId;
/*	
	static CONTEXT s_Context;
	static EXCEPTION_RECORD s_ExceptionRecord;
#ifdef _X86_	
	static BYTE s_Stack[4*1024];
#endif
*/

/*	
	BOOL GetDllLimits(WCHAR * pDllName)
	{
	    UNICODE_STRING DllName;
	    RtlInitUnicodeString(&DllName,pDllName);
	    PEB_LDR_DATA * pLdr = NtCurrentPeb()->Ldr;
	    LIST_ENTRY * pHeadEntry = &pLdr->InLoadOrderModuleList;
	    LIST_ENTRY * pEntry = pLdr->InLoadOrderModuleList.Flink;
	    BOOL bFound = FALSE;
	    while (pHeadEntry != pEntry)
	    {
	        LDR_DATA_TABLE_ENTRY * pData = CONTAINING_RECORD(pEntry,
	        	                                               LDR_DATA_TABLE_ENTRY,
	        	                                               InLoadOrderLinks);
	        if (0 == wbem_wcsicmp(DllName.Buffer,pData->BaseDllName.Buffer))
	        {
	            //OutputDebugStringA("found\n");
	            Base = (ULONG_PTR)pData->DllBase;
	            Limit = Base + (ULONG_PTR)pData->SizeOfImage;
	            bFound = TRUE;
	            break;
	        }
	        pEntry = pEntry->Flink;
	    }
	    return bFound;
	}
*/	
public:
	CSetVectoredHandler()
	{
    	pVectorHandler = NULL;
    	//if (GetDllLimits(L"fastprox.dll"))
    	//{
    	    pVectorHandler = AddVectoredExceptionHandler(TRUE,CSetVectoredHandler::VectoredHandler);
    	//}
	};
	~CSetVectoredHandler()
	{
	    if (pVectorHandler)
	        RemoveVectoredExceptionHandler(pVectorHandler);
	};
	static LONG WINAPI VectoredHandler(PEXCEPTION_POINTERS ExceptionInfo)
	{	    
    	PEXCEPTION_RECORD pExr = ExceptionInfo->ExceptionRecord;
    	PCONTEXT pCxr = ExceptionInfo->ContextRecord; 
    	BYTE * pESP;
    	HANDLE hThread;
    	PRTL_CRITICAL_SECTION   LoaderLockPointer;
    	BOOL bHoldingLoaderLock;
    	ULONG c;
    	switch (pExr->ExceptionCode)
    	{
    	case STATUS_ACCESS_VIOLATION:
/*    		
    		s_Context = *pCxr;
    		s_ExceptionRecord = *pExr;
#ifdef _X86_
            pESP = (BYTE *)pCxr->Esp;
            pESP = (BYTE *)((ULONG_PTR)pESP&0xFFFFF000);
            memcpy(s_Stack,pESP,4*1024);
#endif
*/
    	case STATUS_PRIVILEGED_INSTRUCTION:
        case STATUS_INVALID_HANDLE:
       	case STATUS_STACK_OVERFLOW:
       	case STATUS_POSSIBLE_DEADLOCK:
    		InterlockedIncrement(&ExceptionCounters[(LONG)StatusAccessViolation]);
			DebugBreak();			
	   		break;
    	case 0xe06d7363:
    		InterlockedIncrement(&ExceptionCounters[(LONG)CXXException]);
    		break;       		
    	case STATUS_NO_MEMORY:
    		InterlockedIncrement(&ExceptionCounters[(LONG)StatusNoMemory]);
    		break; 		
    	default:
    		InterlockedIncrement(&ExceptionCounters[(LONG)OtherExceptions]);
    		break;
    	}
	    return EXCEPTION_CONTINUE_SEARCH;
	}
} ; //g_C;

LONG CSetVectoredHandler::ExceptionCounters[CSetVectoredHandler::LastException];
DWORD CSetVectoredHandler::s_ThreadId;
/*
CONTEXT CSetVectoredHandler::s_Context;
EXCEPTION_RECORD CSetVectoredHandler::s_ExceptionRecord;
#ifdef _X86_	
BYTE CSetVectoredHandler::s_Stack[4*1024];
#endif
*/
#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define CORE_PROVIDER_UNLOAD_TIMEOUT ( 30 * 1000 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HWND g_Wnd = NULL ;
DWORD g_DebugLevel = 0 ;
DWORD g_HostRegister = 0 ;
IUnknown *g_HostClassFactory = NULL ;
static const wchar_t *g_TemplateCode = L"Wmi Provider Host" ;
Task_ObjectDestruction *g_Task = NULL ;
Task_FreeLibraries * g_TaskFreeLib = NULL;
FactoryLifeTimeThread * g_Thread = NULL;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
void initiateShutdown(void);

LRESULT CALLBACK WindowsMainProc ( HWND a_hWnd , UINT a_message , WPARAM a_wParam , LPARAM a_lParam )
{
	LRESULT t_rc = 0 ;

	switch ( a_message )
	{
		case WM_DESTROY:
		{
			PostMessage ( a_hWnd , WM_QUIT , 0 , 0 ) ;
		}
		break ;

		default:
		{		
			t_rc = DefWindowProc ( a_hWnd , a_message , a_wParam , a_lParam ) ;
		}
		break ;
	}

	return ( t_rc ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HWND WindowsInit ( HINSTANCE a_HInstance )
{
	WNDCLASS  t_wc ;
 
	t_wc.style            = CS_HREDRAW | CS_VREDRAW ;
	t_wc.lpfnWndProc      = WindowsMainProc ;
	t_wc.cbClsExtra       = 0 ;
	t_wc.cbWndExtra       = 0 ;
	t_wc.hInstance        = a_HInstance ;
	t_wc.hIcon            = LoadIcon(NULL, IDI_HAND) ;
	t_wc.hCursor          = LoadCursor(NULL, IDC_ARROW) ;
	t_wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1) ;
	t_wc.lpszMenuName     = NULL ;
	t_wc.lpszClassName    = g_TemplateCode ;
 
	ATOM t_winClass = RegisterClass ( &t_wc ) ;

	HWND t_HWnd = CreateWindow (

		g_TemplateCode ,              // see RegisterClass() call
		g_TemplateCode ,                      // text for window title bar
		WS_OVERLAPPEDWINDOW | WS_MINIMIZE ,               // window style
		CW_USEDEFAULT ,                     // default horizontal position
		CW_USEDEFAULT ,                     // default vertical position
		CW_USEDEFAULT ,                     // default width
		CW_USEDEFAULT ,                     // default height
		NULL ,                              // overlapped windows have no parent
		NULL ,                              // use the window class menu
		a_HInstance ,
		NULL                                // pointer not needed
	) ;

	//ShowWindow ( t_HWnd , SW_SHOW ) ;
	ShowWindow ( t_HWnd, SW_HIDE ) ;

	UpdateWindow ( t_HWnd ) ;

	HMENU t_Menu = GetSystemMenu ( t_HWnd , FALSE ) ; 
	if ( t_Menu )
	{
		DeleteMenu ( t_Menu , SC_RESTORE , MF_BYCOMMAND ) ;
	}

	return t_HWnd ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WindowsStop ( HINSTANCE a_Instance , HWND a_HWnd )
{
	DestroyWindow ( a_HWnd ) ;
	UnregisterClass ( g_TemplateCode , a_Instance ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HWND WindowsStart ( HINSTANCE a_Handle )
{
	HWND t_HWnd = NULL ;
	if ( ! ( t_HWnd = WindowsInit ( a_Handle ) ) )
	{
    }

	return t_HWnd ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WindowsDispatch ()
{
	BOOL t_GetMessage ;
	MSG t_lpMsg ;

	while (	( t_GetMessage = GetMessage ( & t_lpMsg , NULL , 0 , 0 ) ) == TRUE )
	{
		TranslateMessage ( & t_lpMsg ) ;
		DispatchMessage ( & t_lpMsg ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT RevokeFactories ()
{
	if ( g_HostRegister )
	{
		CoRevokeClassObject ( g_HostRegister );
		g_HostRegister = 0 ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT UninitComServer ()
{
	RevokeFactories () ;
	CoUninitialize () ;
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT InitComServer ( DWORD a_AuthenticationLevel , DWORD a_ImpersonationLevel )
{
	HRESULT t_Result = S_OK ;

    t_Result = CoInitializeEx (

		0, 
		COINIT_MULTITHREADED
	);

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = CoInitializeSecurity (

			NULL, 
			-1, 
			NULL, 
			NULL,
			a_AuthenticationLevel,
			a_ImpersonationLevel, 
			NULL, 
			EOAC_DYNAMIC_CLOAKING , 
			0
		);

		if ( FAILED ( t_Result ) ) 
		{
			CoUninitialize () ;
			return t_Result ;
		}
	}

	return t_Result  ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT InitFactories ()
{
	HRESULT t_Result = S_OK ;

	DWORD t_ClassContext = CLSCTX_LOCAL_SERVER ;
	DWORD t_Flags = REGCLS_SINGLEUSE ;

	g_HostClassFactory = new CServerClassFactory <CServerObject_Host,_IWmiProviderHost> ;

	t_Result = CoRegisterClassObject (

		CLSID_WmiProviderHost, 
		g_HostClassFactory,
		t_ClassContext, 
		t_Flags, 
		& g_HostRegister
	);

	if ( FAILED ( t_Result ) )
	{
		if ( g_HostRegister )
		{
			CoRevokeClassObject ( g_HostRegister );
			g_HostRegister = 0 ;
			g_HostClassFactory->Release () ;
			g_HostClassFactory = NULL ;
		}
	}	

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Enqueue_ObjectDestruction ( WmiThread < ULONG > *a_Thread )
{
	HRESULT t_Result = S_OK ;
	g_Task = new Task_ObjectDestruction ( *ProviderSubSystem_Globals :: s_Allocator ) ;
	if ( g_Task )
	{
		g_Task->AddRef () ;

		if ( g_Task->Initialize () == e_StatusCode_Success ) 
		{
			if ( a_Thread->EnQueueAlertable ( 0 , *g_Task ) == e_StatusCode_Success )
			{
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( FAILED ( t_Result ) )
	{
		g_Task = NULL ;
	}
	
	if (SUCCEEDED(t_Result))
	{
	    g_TaskFreeLib = new Task_FreeLibraries(*ProviderSubSystem_Globals::s_Allocator);
	    if (g_TaskFreeLib)
	    {
			g_TaskFreeLib->AddRef () ;

			if ( g_TaskFreeLib->Initialize () == e_StatusCode_Success ) 
			{
				if (e_StatusCode_Success != a_Thread->EnQueueAlertable(0,*g_TaskFreeLib))
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}	    
    	}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Dequeue_ObjectDestruction ( WmiThread < ULONG > *a_Thread )
{
	HRESULT t_Result = S_OK ;

/*
    // Don't clean up since we need a guarantee that no syncronisation needs to take place
	if ( g_Task )
	{
		g_Task->Release () ;
	}
 */

    IUnknown * pUnk;
    if (pUnk = (IUnknown *)InterlockedCompareExchangePointer((PVOID *)&g_TaskFreeLib,0,(PVOID)g_TaskFreeLib))
    {
        pUnk->Release();
    }

	return t_Result ;
}
	
void exitIfManaged()
{
	// Clean managed heap
    	HINSTANCE hmod = GetModuleHandle(L"mscoree.dll");
    	if (hmod != NULL)
    	{
		typedef void (WINAPI * PFN_EEShutDownCOM)();
        	PFN_EEShutDownCOM uninitEE = (PFN_EEShutDownCOM)GetProcAddress(hmod, "CoEEShutDownCOM");
        	if (uninitEE)
        	{
            		uninitEE();
        	}
    	}

	// If we're part of a managed app (aka. a managed component is present in our
	// process) we cannot excute any global shutdown code. In this case we are just calling
	// framework shutdown.

	// To determine if we're a managed app, we check if mscoree.dll is loaded.
	// Then, if CorExitProcess is available, we call it.

	typedef void (WINAPI * PFN_EXIT_PROCESS)(UINT uExitCode);
	PFN_EXIT_PROCESS pfn;

	if (hmod != NULL) 
	{
		pfn = (PFN_EXIT_PROCESS)GetProcAddress(hmod, "CorExitProcess");
		if (pfn != NULL) 
		{
		
			if (ProviderSubSystem_Globals :: s_ObjectsInProgress == 0) 	return;

			// We still have oustanding objects
			// Revoke Factories and UnInit com
			UninitComServer();
			pfn(0);
		}
	}
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Process ()
{
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
	DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_CONNECT;

	HRESULT t_Result = InitComServer ( t_AuthenticationLevel , t_ImpersonationLevel ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = WmiDebugLog :: Initialize ( *ProviderSubSystem_Globals :: s_Allocator  ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_Result = ProviderSubSystem_Globals :: Initialize_SharedCounters () ;
			if ( FAILED ( t_Result ) )
			{
				t_Result = S_OK ;
			}

			t_Result = ProviderSubSystem_Globals :: Initialize_Events () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = ProviderSubSystem_Common_Globals :: CreateSystemAces () ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemLocator *t_Locator = NULL ;

				HRESULT t_Result = CoCreateInstance (
  
					CLSID_WbemLocator ,
					NULL ,
					CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
					IID_IUnknown ,
					( void ** )  & t_Locator
				);

				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = NULL ;

					BSTR t_Namespace = SysAllocString ( L"Root" ) ;
					if ( t_Namespace ) 
					{
						t_Result = t_Locator->ConnectServer (

							t_Namespace ,
							NULL ,
							NULL,
							NULL ,
							0 ,
							NULL,
							NULL,
							& t_Service
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							CServerObject_GlobalRegistration t_Registration ;
							t_Result = t_Registration.SetContext (

								NULL ,
								NULL ,
								t_Service
							) ;
							
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Registration.Load (

									e_All
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									ProviderSubSystem_Globals :: s_StrobeTimeout = t_Registration.GetUnloadTimeoutMilliSeconds () >> 1 ;
									ProviderSubSystem_Globals :: s_InternalCacheTimeout = t_Registration.GetUnloadTimeoutMilliSeconds () ;
									ProviderSubSystem_Globals :: s_ObjectCacheTimeout = t_Registration.GetObjectUnloadTimeoutMilliSeconds () ;
									ProviderSubSystem_Globals :: s_EventCacheTimeout = t_Registration.GetEventUnloadTimeoutMilliSeconds () ;
								}
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								CServerObject_HostQuotaRegistration t_Registration ;
								t_Result = t_Registration.SetContext (

									NULL ,
									NULL ,
									t_Service
								) ;
								
								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_Registration.Load (

										e_All
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										ProviderSubSystem_Globals ::s_Quota_ProcessLimitCount = t_Registration.GetProcessLimitAllHosts () ;
										ProviderSubSystem_Globals ::s_Quota_ProcessMemoryLimitCount = t_Registration.GetMemoryPerHost () ;
										ProviderSubSystem_Globals ::s_Quota_JobMemoryLimitCount = t_Registration.GetMemoryAllHosts () ;
										ProviderSubSystem_Globals ::s_Quota_HandleCount = t_Registration.GetHandlesPerHost () ;
										ProviderSubSystem_Globals ::s_Quota_NumberOfThreads = t_Registration.GetThreadsPerHost () ;
										ProviderSubSystem_Globals ::s_Quota_PrivatePageCount = t_Registration.GetMemoryPerHost () ;
									}
								}
							}

							t_Service->Release () ;
						}

						SysFreeString ( t_Namespace ) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					t_Locator->Release () ;
				}
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				g_Thread = new FactoryLifeTimeThread ( *ProviderSubSystem_Globals :: s_Allocator , DEFAULT_PROVIDER_TIMEOUT ) ;
				if ( g_Thread )
				{
					g_Thread->AddRef () ;

					t_StatusCode = g_Thread->Initialize () ;
					if ( t_StatusCode == e_StatusCode_Success )
					{
						t_Result = Enqueue_ObjectDestruction ( g_Thread ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = InitFactories () ;

#ifdef DEV_BUILD
#ifdef _X86_
//    g_FaultHeapEnabled = TRUE;
//	g_FaultFileEnabled = TRUE;
#endif
#endif
					
							if ( SUCCEEDED ( t_Result ) )
							{
								Wmi_SetStructuredExceptionHandler t_StructuredException ;

								try 
								{
									WindowsDispatch () ;
								}
								catch ( Wmi_Structured_Exception t_StructuredException )
								{
								}
							}

							Dequeue_ObjectDestruction ( g_Thread ) ;
						}

						HANDLE t_ThreadHandle = NULL ;

						BOOL t_Status = DuplicateHandle ( 

							GetCurrentProcess () ,
							g_Thread->GetHandle () ,
							GetCurrentProcess () ,
							& t_ThreadHandle, 
							0 , 
							FALSE , 
							DUPLICATE_SAME_ACCESS
						) ;

						g_Thread->Release () ;

						WaitForSingleObject ( t_ThreadHandle , INFINITE ) ;

						CloseHandle ( t_ThreadHandle ) ;
						
						g_Thread = NULL;
						Dequeue_ObjectDestruction (NULL);
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				
				exitIfManaged();

				t_Result = ProviderSubSystem_Common_Globals :: DeleteSystemAces () ;

				t_Result = ProviderSubSystem_Globals :: UnInitialize_Events () ;
			}

			t_Result = ProviderSubSystem_Globals :: UnInitialize_SharedCounters () ;

			WmiStatusCode t_StatusCode = WmiDebugLog :: UnInitialize ( *ProviderSubSystem_Globals :: s_Allocator  ) ;
		}
			
		UninitComServer () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL ParseCommandLine () 
{
	BOOL t_Exit = FALSE ;

	LPTSTR t_CommandLine = GetCommandLineW () ;
	if ( t_CommandLine )
	{
		wchar_t *t_Arg = NULL ;
		wchar_t *t_ApplicationArg = NULL ;
		t_ApplicationArg = wcstok ( t_CommandLine , L" \t") ;
		t_Arg = wcstok ( NULL , L" \t" ) ;
		if ( t_Arg ) 
		{
			if ( lstrcmpi ( t_Arg , L"/RegServer" ) == 0 )
			{
				t_Exit = TRUE ;
				DllRegisterServer () ;
			}
			else if ( lstrcmpi ( t_Arg , L"/UnRegServer" ) == 0 )
			{
				t_Exit = TRUE ;
				DllUnregisterServer () ;
			}
		}
	}

	return t_Exit ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#include <arena.h>

LONG
WINAPI
SvchostUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    return RtlUnhandledExceptionFilter(ExceptionInfo);
}

int WINAPI WinMain (
  
    HINSTANCE hInstance,		// handle to current instance
    HINSTANCE hPrevInstance,	// handle to previous instance
    LPSTR lpCmdLine,			// pointer to command line
    int nShowCmd 				// show state of window
)
{
#ifdef DEV_BUILD
	//SetUnhandledExceptionFilter(&SvchostUnhandledExceptionFilter);

	//SetErrorMode(SEM_FAILCRITICALERRORS);

#ifdef _X86_
	//NtCurrentPeb()->BeingDebugged = 1;
	intercept2(L"ntdll.dll","RtlFreeHeap",_I_RtlFreeHeap,Prolog__RtlFreeHeap,5);
	intercept2(L"ntdll.dll","RtlAllocateHeap",_I_RtlAllocateHeap,Prolog__RtlAllocateHeap,5);
	intercept2(L"ntdll.dll","RtlReAllocateHeap",_I_RtlReAllocateHeap,Prolog__RtlReAllocateHeap,5);	
	intercept2(L"ntdll.dll","RtlValidateHeap",_I_RtlValidateHeap,Prolog__RtlValidateHeap,7);
	intercept2(L"ntdll.dll","RtlCreateHeap",_I_RtlCreateHeap,Prolog__RtlCreateHeap,5);
	intercept2(L"ntdll.dll","RtlDestroyHeap",_I_RtlDestroyHeap,Prolog__RtlDestroyHeap,6);

	//intercept2(L"ntdll.dll","RtlEnterCriticalSection",_I_RtlEnterCriticalSection,Prolog__RtlEnterCriticalSection,7);
	//intercept2(L"ntdll.dll","RtlLeaveCriticalSection",_I_RtlLeaveCriticalSection,Prolog__RtlLeaveCriticalSection,6);
	
	intercept2(L"kernel32.dll","CreateEventW",_I_CreateEvent,Prolog__CreateEvent,6);
	intercept2(L"kernel32.dll","WriteFile",_I_WriteFile,Prolog__WriteFile,7);
	intercept2(L"kernel32.dll","ReadFile",_I_ReadFile,Prolog__ReadFile,7);

	HANDLE hHeap = CWin32DefaultArena::GetArenaHeap();
	g_HeapLock = *((RTL_CRITICAL_SECTION **)((BYTE *)hHeap+0x578));

    // this is for CritSec timeout
    //LARGE_INTEGER * pLi = (LARGE_INTEGER *)0x77fC47E8;
    //pLi->QuadPart = 0xffffffffdc3cba00; // 2 min
    //pLi->QuadPart = 0xfffffffff4143e00; // 2 sec
	
#endif /*_X86_*/
#endif
        setlocale(LC_CTYPE,"English");

	HRESULT t_Result = ProviderSubSystem_Globals :: Global_Startup () ;
	if ( SUCCEEDED ( t_Result ) )
	{
		BOOL t_Exit = ParseCommandLine () ;
		if ( ! t_Exit ) 
		{
			RPC_STATUS t_Status = RpcMgmtSetServerStackSize ( ProviderSubSystem_Common_Globals :: GetDefaultStackSize () );

			g_Wnd = WindowsStart ( hInstance ) ;

			t_Result = Process () ;

			WindowsStop ( hInstance , g_Wnd ) ;
		}

		t_Result = ProviderSubSystem_Globals :: Global_Shutdown () ;
	}

#ifdef DEV_BUILD
#ifdef _X86_

	//VALIDATE_HEAP;
	unintercept(L"ntdll.dll","RtlFreeHeap",Prolog__RtlFreeHeap,5);	
	unintercept(L"ntdll.dll","RtlAllocateHeap",Prolog__RtlAllocateHeap,5);
	unintercept(L"ntdll.dll","RtlReAllocateHeap",Prolog__RtlReAllocateHeap,5);	
	unintercept(L"ntdll.dll","RtlValidateHeap",Prolog__RtlValidateHeap,7);
	unintercept(L"ntdll.dll","RtlCreateHeap",Prolog__RtlCreateHeap,5);
	unintercept(L"ntdll.dll","RtlDestroyHeap",Prolog__RtlDestroyHeap,6);

	//unintercept(L"ntdll.dll","RtlEnterCriticalSection",Prolog__RtlEnterCriticalSection,7);
	//unintercept(L"ntdll.dll","RtlLeaveCriticalSection",Prolog__RtlLeaveCriticalSection,6);
		
	unintercept(L"kernel32.dll","CreateEventW",Prolog__CreateEvent,6);
	unintercept(L"kernel32.dll","WriteFile",Prolog__WriteFile,7);
	unintercept(L"kernel32.dll","ReadFile",Prolog__ReadFile,7);
	
#endif /*_X86_*/
#endif


	return 0 ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode FactoryLifeTimeThread :: Initialize_Callback ()
{
	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode FactoryLifeTimeThread :: UnInitialize_Callback () 
{
	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

FactoryLifeTimeThread :: FactoryLifeTimeThread (

	WmiAllocator &a_Allocator ,
	const ULONG &a_Timeout 

) : WmiThread < ULONG > ( a_Allocator , NULL , a_Timeout ) ,
	m_Allocator ( a_Allocator )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

FactoryLifeTimeThread::~FactoryLifeTimeThread ()
{
}



/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL FactoryLifeTimeThread :: QuotaCheck ()
{
	DWORD t_ProcessInformationSize = sizeof ( SYSTEM_PROCESS_INFORMATION ) ;
	SYSTEM_PROCESS_INFORMATION *t_ProcessInformation = ( SYSTEM_PROCESS_INFORMATION * ) new BYTE [t_ProcessInformationSize] ;
	if ( t_ProcessInformation )
	{
		BOOL t_Retry = TRUE ;
		while ( t_Retry )
		{
			NTSTATUS t_Status = NtQuerySystemInformation (

				SystemProcessInformation,
				t_ProcessInformation,
				t_ProcessInformationSize,
				NULL
			) ;

			if ( t_Status == STATUS_INFO_LENGTH_MISMATCH )
			{
				delete [] t_ProcessInformation;

				t_ProcessInformation = NULL ;
				t_ProcessInformationSize += 32768 ;
				t_ProcessInformation = ( SYSTEM_PROCESS_INFORMATION * ) new BYTE [t_ProcessInformationSize] ;
				if ( ! t_ProcessInformation )
				{
					return FALSE ;
				}
			}
			else
			{
				t_Retry = FALSE ;

				if ( ! NT_SUCCESS ( t_Status ) )
				{
					delete [] t_ProcessInformation;
					t_ProcessInformation = NULL ;

					return FALSE ;
				}
			}
		}
	}
	else
	{
		return FALSE ;
	}

	BOOL t_Status = TRUE ;

	SYSTEM_PROCESS_INFORMATION *t_Block = t_ProcessInformation ;

	while ( t_Block )
	{
		if ( ( HandleToUlong ( t_Block->UniqueProcessId ) ) == GetCurrentProcessId () )
		{
			if ( t_Block->HandleCount > ProviderSubSystem_Globals::s_Quota_HandleCount )
			{
			    DBG_PRINTFA((pBuff,"HandleCount %x %x\n",t_Block->HandleCount,ProviderSubSystem_Globals::s_Quota_HandleCount));
				t_Status = FALSE ;
			}

			if ( t_Block->NumberOfThreads > ProviderSubSystem_Globals::s_Quota_NumberOfThreads )
			{
			    DBG_PRINTFA((pBuff,"NumberOfThreads %x %x\n",t_Block->NumberOfThreads,ProviderSubSystem_Globals::s_Quota_NumberOfThreads));
				t_Status = FALSE ;
			}

			if ( t_Block->PrivatePageCount > ProviderSubSystem_Globals :: s_Quota_PrivatePageCount )
			{
			    DBG_PRINTFA((pBuff,"PrivatePageCount %x %x\n", t_Block->PrivatePageCount,ProviderSubSystem_Globals::s_Quota_PrivatePageCount));			
				t_Status = FALSE ;
			}
		}

		DWORD t_NextOffSet = t_Block->NextEntryOffset ;
		if ( t_NextOffSet )
		{
			t_Block = ( SYSTEM_PROCESS_INFORMATION * ) ( ( ( BYTE * ) t_Block ) + t_NextOffSet ) ;
		}
		else
		{
			t_Block = NULL ;
		}
	}

	delete [] t_ProcessInformation;

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode FactoryLifeTimeThread :: TimedOut ()
{
	try
	{
	
		if ( QuotaCheck () == TRUE ) 
		{
			initiateShutdown();
		}
		else
		{
			CWbemGlobal_IWbemSyncProviderController *t_SyncProviderController = ProviderSubSystem_Globals :: GetSyncProviderController () ;

			CWbemGlobal_IWbemSyncProvider_Container *t_Container = NULL ;
			WmiStatusCode t_StatusCode = t_SyncProviderController->GetContainer ( t_Container ) ;

			t_SyncProviderController->Lock () ;

			_IWmiProviderQuota **t_QuotaElements = new _IWmiProviderQuota * [ t_Container->Size () ] ;
			if ( t_QuotaElements )
			{
				CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator = t_Container->Begin () ;

				ULONG t_Count = 0 ;

				while ( ! t_Iterator.Null () )
				{
					SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;

					t_QuotaElements [ t_Count ] = NULL ;

					HRESULT t_Result = t_Element->QueryInterface ( IID__IWmiProviderQuota , ( void ** ) & t_QuotaElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				t_SyncProviderController->UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_QuotaElements [ t_Index ] )
					{
						HRESULT t_Result = t_QuotaElements [ t_Index ]->Violation ( 0 , NULL , NULL ) ;

						t_QuotaElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_QuotaElements ;
			}
			else
			{
				t_SyncProviderController->UnLock () ;
			}

			RevokeFactories () ;

/*
 *	Just exit since we can't safely wait for clients to disconnect correctly before cleaning up dependant resources.
 */
#ifdef _X86_
#ifdef DEV_BUILD
 //           g_ExitProcessCalled = TRUE;

            EnterCriticalSection(&g_CS);
            VALIDATE_HEAP;
            LeaveCriticalSection(&g_CS);
#endif
#endif            
			TerminateProcess ( GetCurrentProcess () , WBEM_E_QUOTA_VIOLATION ) ;
		}

		CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
	}
	catch ( ... )
	{
	}

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void SetObjectDestruction ()
{
	if ( g_Task )
	{
		SetEvent ( g_Task->GetEvent () ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode Task_ObjectDestruction :: Process ( WmiThread <ULONG> &a_Thread )
{
	initiateShutdown();
	return e_StatusCode_EnQueue ;
}

void initiateShutdown(void)
{
	if ( ProviderSubSystem_Globals :: s_CServerObject_Host_ObjectsInProgress == 0 )
	{
		RevokeFactories () ;
	}    
	if (ProviderSubSystem_Globals :: s_CServerObject_StaThread_ObjectsInProgress == 0 && 
	    ProviderSubSystem_Globals :: s_CServerObject_Host_ObjectsInProgress == 0 )

	{
		CoFreeUnusedLibrariesEx(0,0);
		CoFreeUnusedLibrariesEx(0,0);

		PostMessage ( g_Wnd , WM_QUIT , 0 , 0 ) ;
	}
};


void SetProviderDestruction()
{
	if (g_TaskFreeLib) SetEvent (g_TaskFreeLib->GetEvent ());
}


WmiStatusCode Task_FreeLibraries::Process(WmiThread<ULONG> & a_Thread)
{
	CoFreeUnusedLibrariesEx(PROVIDER_HOST_DLL_TIMEOUT,0);
	return e_StatusCode_EnQueue ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Precomp.h

Abstract:


History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
#include <ntpsapi.h>
#include <ntexapi.h>

#define _WINNT_	// have what is needed from above

#include <ole2.h>
#include <windows.h>

#include <corepol.h>

#ifdef USE_POLARITY
    #ifdef BUILDING_DLL
        #define COREPROX_POLARITY __declspec( dllexport )
    #else 
        #define COREPROX_POLARITY __declspec( dllimport )
    #endif
#else
    #define COREPROX_POLARITY
#endif
#define STRSAFE_NO_DEPRECATE

#include <strsafe.h>
#include <strutils.h>
#include <wbemutil.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provaggr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"
#include <typeinfo.h>
#include <wbemint.h>
#include <Like.h>
#include "Globals.h"
#include "CGlobals.h"
#include "ProvAggr.h"
#include "ProvFact.h"
#include "ProvObSk.h"
#include "ProvInSk.h"
#include "ProvRegInfo.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CAggregator_IWbemProvider :: CAggregator_IWbemProvider (

	WmiAllocator &a_Allocator ,
	CWbemGlobal_IWmiProviderController *a_Controller , 
	_IWmiProviderFactory *a_Factory ,
	IWbemServices *a_CoreRepositoryStub ,
	IWbemServices *a_CoreFullStub ,
	const ProviderCacheKey &a_Key ,
	const ULONG &a_Period ,
	IWbemContext *a_InitializationContext

) :	CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	ServiceCacheElement ( 

		a_Controller ,
		a_Key ,
		a_Period 
	) ,
	m_ReferenceCount ( 0 ) , 
	m_Allocator ( a_Allocator ) ,
	m_CoreRepositoryStub ( a_CoreRepositoryStub ) ,
	m_CoreFullStub ( a_CoreFullStub ) ,
	m_Factory ( a_Factory ) ,
	m_ClassProvidersCount ( 0 ) ,
	m_ClassProviders ( NULL ) ,
	m_User ( NULL ) ,
	m_Locale ( NULL ) ,
	m_Initialized ( 0 ) ,
	m_InitializeResult ( S_OK ) ,
	m_InitializedEvent ( NULL ) , 
	m_InitializationContext ( a_InitializationContext )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CAggregator_IWbemProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_InitializationContext )
	{
		m_InitializationContext->AddRef () ;
	}

	if ( m_Factory ) 
	{
		m_Factory->AddRef () ;
	}

	if ( m_CoreRepositoryStub )
	{
		m_CoreRepositoryStub->AddRef () ;
	}

	if ( m_CoreFullStub )
	{
		m_CoreFullStub->AddRef () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CAggregator_IWbemProvider :: ~CAggregator_IWbemProvider ()
{
	if ( m_Factory ) 
	{
		m_Factory->Release () ;
	}

	if ( m_CoreRepositoryStub )
	{
		m_CoreRepositoryStub->Release () ;
	}

	if ( m_CoreFullStub )
	{
		m_CoreFullStub->Release () ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_ClassProviders )
	{
		for ( ULONG t_Index = 0 ; t_Index < m_ClassProvidersCount ; t_Index ++ )
		{
			if ( m_ClassProviders [ t_Index ] )
			{
				m_ClassProviders [ t_Index ]->Release () ;
			}
		}

		delete [] m_ClassProviders ;
	}

	if ( m_InitializationContext )
	{
		m_InitializationContext->Release () ;
	}

	if ( m_InitializedEvent )
	{
		CloseHandle ( m_InitializedEvent ) ;
	}

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CAggregator_IWbemProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: Initialize (

	long a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User,
    LPCWSTR a_Locale,
	LPCWSTR a_Namespace ,
	IWbemServices *a_Repository ,
	IWbemServices *a_Service ,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_InitializedEvent = CreateEvent ( NULL , TRUE , FALSE , NULL ) ;
		if ( m_InitializedEvent == NULL )
		{
			t_Result = t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_User )
		{
			m_User = SysAllocString ( a_User ) ;
			if ( ! m_User ) 
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Locale )
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( ! m_Locale ) 
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: IsIndependant ( IWbemContext *a_Context )
{
	BOOL t_DependantCall = FALSE ;
	HRESULT t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_DependantCall == FALSE )
		{
		}
		else
		{
			return S_FALSE ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout )
{
	HRESULT t_Result = WBEM_E_UNEXPECTED ;

	if ( m_Initialized == 0 )
	{
		BOOL t_DependantCall = FALSE ;
		t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_DependantCall == FALSE )
			{
				if ( WaitForSingleObject ( m_InitializedEvent , a_Timeout ) == WAIT_TIMEOUT )
				{
					return WBEM_E_PROVIDER_LOAD_FAILURE ;
				}
			}
			else
			{
				if ( WaitForSingleObject ( m_InitializedEvent , 0 ) == WAIT_TIMEOUT )
				{
					return S_FALSE ;
				}
			}
		}
	}
	else
	{
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: SetInitialized ( HRESULT a_InitializeResult )
{
	m_InitializeResult = a_InitializeResult ;

	InterlockedExchange ( & m_Initialized , 1 ) ;

	if ( m_InitializedEvent )
	{
		SetEvent ( m_InitializedEvent ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CAggregator_IWbemProvider :: AddRef ( void )
{
	return ServiceCacheElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CAggregator_IWbemProvider :: Release ( void )
{
	return ServiceCacheElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CAggregator_IWbemProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}	
	else if ( iid == IID__IWmiProviderInitialize )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderInitialize * ) this ;		
	}
	else if ( iid == IID__IWmiProviderCache )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderCache * ) this ;
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	
	else if ( iid == IID_CAggregator_IWbemProvider )
	{
		*iplpv = ( LPVOID ) ( CAggregator_IWbemProvider * ) this ;		
	}	
	else if ( iid == IID__IWmiProviderAssociatorsHelper )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderAssociatorsHelper * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState CAggregator_IWbemProvider :: Get_RecursiveEvaluate ( 

	wchar_t *a_Class ,
	IWbemContext *a_Context , 
	WmiTreeNode *&a_Node
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_Undefined ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = Get_RecursiveEvaluate ( a_Class , a_Context , t_Left ) ;
				if ( t_Status == QueryPreprocessor :: State_False )
				{
					if ( t_Right )
					{
						t_Status = Get_RecursiveEvaluate ( a_Class , a_Context , t_Right ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = Get_RecursiveEvaluate ( a_Class , a_Context , t_Left ) ;
				if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
				{
					if ( t_Right )
					{
						t_Status = Get_RecursiveEvaluate ( a_Class , a_Context , t_Right ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( wbem_wcsicmp ( L"__Class" , t_String->GetPropertyName () ) == 0 )
					{
						if ( t_String->GetValue () && wbem_wcsicmp ( a_Class , t_String->GetValue () ) == 0 )
						{
							t_Status = QueryPreprocessor :: State_True ;
						}
						else
						{
							t_Status = QueryPreprocessor :: State_False ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotEqualNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( wbem_wcsicmp ( L"__Class" , t_String->GetPropertyName () ) == 0 )
					{
						if ( t_String->GetValue () && wbem_wcsicmp ( a_Class , t_String->GetValue () ) != 0 )
						{
							t_Status = QueryPreprocessor :: State_True ;
						}
						else
						{
							t_Status = QueryPreprocessor :: State_False ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrGreaterNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( wbem_wcsicmp ( L"__Class" , t_String->GetPropertyName () ) == 0 )
					{
						if ( t_String->GetValue () && wbem_wcsicmp ( a_Class , t_String->GetValue () ) >= 0 )
						{
							t_Status = QueryPreprocessor :: State_True ;
						}
						else
						{
							t_Status = QueryPreprocessor :: State_False ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrLessNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( wbem_wcsicmp ( L"__Class" , t_String->GetPropertyName () ) == 0 )
					{
						if ( t_String->GetValue () && wbem_wcsicmp ( a_Class , t_String->GetValue () ) <= 0 )
						{
							t_Status = QueryPreprocessor :: State_True ;
						}
						else
						{
							t_Status = QueryPreprocessor :: State_False ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLessNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( wbem_wcsicmp ( L"__Class" , t_String->GetPropertyName () ) == 0 )
					{
						if ( t_String->GetValue () && wbem_wcsicmp ( a_Class , t_String->GetValue () ) < 0 )
						{
							t_Status = QueryPreprocessor :: State_True ;
						}
						else
						{
							t_Status = QueryPreprocessor :: State_False ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorGreaterNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( wbem_wcsicmp ( L"__Class" , t_String->GetPropertyName () ) == 0 )
					{
						if ( t_String->GetValue () && wbem_wcsicmp ( a_Class , t_String->GetValue () ) > 0 )
						{
							t_Status = QueryPreprocessor :: State_True ;
						}
						else
						{
							t_Status = QueryPreprocessor :: State_False ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLikeNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( wbem_wcsicmp ( L"__Class" , t_String->GetPropertyName () ) == 0 )
					{
						CLike t_Like ( t_String->GetValue () ) ;
						if ( t_Like.Match ( a_Class ) )
						{
							t_Status = QueryPreprocessor :: State_True ;
						}
						else
						{
							t_Status = QueryPreprocessor :: State_False ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotLikeNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( wbem_wcsicmp ( L"__Class" , t_String->GetPropertyName () ) == 0 )
					{
						CLike t_Like ( t_String->GetValue () ) ;
						if ( ! t_Like.Match ( a_Class ) )
						{
							t_Status = QueryPreprocessor :: State_True ;
						}
						else
						{
							t_Status = QueryPreprocessor :: State_False ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorIsANode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotIsANode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState CAggregator_IWbemProvider :: Get_Evaluate (

	wchar_t *a_Class ,
	IWbemContext *a_Context , 
	WmiTreeNode *&a_Root
)
{
	QueryPreprocessor :: QuadState t_Status = Get_RecursiveEvaluate ( a_Class , a_Context , a_Root ) ;
	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState CAggregator_IWbemProvider :: EnumDeep_RecursiveEvaluate ( 

	IWbemClassObject *a_Class ,
	IWbemContext *a_Context , 
	WmiTreeNode *&a_Node
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_Undefined ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = EnumDeep_RecursiveEvaluate ( a_Class , a_Context , t_Left ) ;
				if ( t_Status == QueryPreprocessor :: State_False )
				{
					if ( t_Right )
					{
						t_Status = EnumDeep_RecursiveEvaluate ( a_Class , a_Context , t_Right ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = EnumDeep_RecursiveEvaluate ( a_Class , a_Context , t_Left ) ;
				if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
				{
					if ( t_Right )
					{
						t_Status = EnumDeep_RecursiveEvaluate ( a_Class , a_Context , t_Right ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( wbem_wcsicmp ( L"__SuperClass" , t_String->GetPropertyName () ) == 0 )
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;

						LONG t_VarType = 0 ;
						LONG t_Flavour = 0 ;

						HRESULT t_Result = a_Class->Get ( L"__SuperClass" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_Variant.vt == VT_BSTR )
							{
								if ( t_String->GetValue () && wbem_wcsicmp ( t_Variant.bstrVal , t_String->GetValue () ) == 0 )
								{
									t_Status = QueryPreprocessor :: State_True ;
								}
								else
								{
									t_Status = QueryPreprocessor :: State_False ;
								}
							}

							VariantClear ( & t_Variant ) ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotEqualNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrGreaterNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrLessNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLessNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorGreaterNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLikeNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotLikeNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorIsANode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( wbem_wcsicmp ( L"__this" , t_String->GetPropertyName () ) == 0 )
					{
						IWbemClassObject *t_FilterObject = NULL ;

						HRESULT t_Result = m_CoreFullStub->GetObject ( 

							t_String->GetValue () ,
							0 ,
							a_Context , 
							& t_FilterObject , 
							NULL 
						) ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							LONG t_LeftLength = 0 ;
							LONG t_RightLength = 0 ;
							BOOL t_LeftIsA = FALSE ;

							t_Status = IsA (

								a_Class ,
								t_FilterObject ,
								t_LeftLength ,
								t_RightLength ,
								t_LeftIsA
							) ;

							if ( ( t_Status == QueryPreprocessor :: State_True ) && ( t_LeftIsA == TRUE ) )
							{
								t_Status = QueryPreprocessor :: State_True ;
							}
							else
							{
								t_Status = QueryPreprocessor :: State_False ;
							}

							t_FilterObject->Release () ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotIsANode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( wbem_wcsicmp ( L"__this" , t_String->GetPropertyName () ) == 0 )
					{
						IWbemClassObject *t_FilterObject = NULL ;

						HRESULT t_Result = m_CoreFullStub->GetObject ( 

							t_String->GetValue () ,
							0 ,
							a_Context , 
							& t_FilterObject , 
							NULL 
						) ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							LONG t_LeftLength = 0 ;
							LONG t_RightLength = 0 ;
							BOOL t_LeftIsA = FALSE ;

							t_Status = IsA (

								a_Class ,
								t_FilterObject ,
								t_LeftLength ,
								t_RightLength ,
								t_LeftIsA
							) ;

							if ( ! ( ( t_Status == QueryPreprocessor :: State_True ) && ( t_LeftIsA == TRUE ) ) )
							{
								t_Status = QueryPreprocessor :: State_True ;
							}
							else
							{
								t_Status = QueryPreprocessor :: State_False ;
							}

							t_FilterObject->Release () ;
						}
					}
				}
			}
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState CAggregator_IWbemProvider :: EnumDeep_Evaluate (

	IWbemClassObject *a_Class ,
	IWbemContext *a_Context , 
	WmiTreeNode *&a_Root
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_True ;
 
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	LONG t_VarType = 0 ;
	LONG t_Flavour = 0 ;

	HRESULT t_Result = a_Class->Get ( L"__Class" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Variant.vt == ( VT_NULL ) )
		{
			t_Status = QueryPreprocessor :: State_True ;
		}
		else
		{
			t_Status = EnumDeep_RecursiveEvaluate ( a_Class , a_Context , a_Root ) ;
		}

		VariantClear ( & t_Variant ) ;
	}
	else
	{
		t_Status = QueryPreprocessor :: State_Error ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState CAggregator_IWbemProvider :: EnumShallow_RecursiveEvaluate ( 

	IWbemClassObject *a_Class ,
	IWbemContext *a_Context , 
	WmiTreeNode *&a_Node
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_Undefined ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = EnumShallow_RecursiveEvaluate ( a_Class , a_Context , t_Left ) ;
				if ( t_Status == QueryPreprocessor :: State_False )
				{
					if ( t_Right )
					{
						t_Status = EnumShallow_RecursiveEvaluate ( a_Class , a_Context , t_Right ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = EnumShallow_RecursiveEvaluate ( a_Class , a_Context , t_Left ) ;
				if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
				{
					if ( t_Right )
					{
						t_Status = EnumShallow_RecursiveEvaluate ( a_Class , a_Context , t_Right ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( wbem_wcsicmp ( L"__SuperClass" , t_String->GetPropertyName () ) == 0 )
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;

						LONG t_VarType = 0 ;
						LONG t_Flavour = 0 ;

						HRESULT t_Result = a_Class->Get ( L"__SuperClass" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_Variant.vt == VT_BSTR )
							{
								if ( t_String->GetValue () && wbem_wcsicmp ( t_Variant.bstrVal , t_String->GetValue () ) == 0 )
								{
									t_Status = QueryPreprocessor :: State_True ;
								}
								else
								{
									t_Status = QueryPreprocessor :: State_False ;
								}
							}

							VariantClear ( & t_Variant ) ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotEqualNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrGreaterNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrLessNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLessNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorGreaterNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLikeNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotLikeNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorIsANode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( wbem_wcsicmp ( L"__this" , t_String->GetPropertyName () ) == 0 )
					{
						IWbemClassObject *t_FilterObject = NULL ;

						HRESULT t_Result = m_CoreFullStub->GetObject ( 

							t_String->GetValue () ,
							0 ,
							a_Context , 
							& t_FilterObject , 
							NULL 
						) ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							LONG t_LeftLength = 0 ;
							LONG t_RightLength = 0 ;
							BOOL t_LeftIsA = FALSE ;

							t_Status = IsA (

								a_Class ,
								t_FilterObject  ,
								t_LeftLength ,
								t_RightLength ,
								t_LeftIsA
							) ;

							if ( ( t_Status == QueryPreprocessor :: State_True ) && ( t_LeftIsA == TRUE ) )
							{
								t_Status = QueryPreprocessor :: State_True ;
							}
							else
							{
								t_Status = QueryPreprocessor :: State_False ;
							}

							t_FilterObject->Release () ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotIsANode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( wbem_wcsicmp ( L"__this" , t_String->GetPropertyName () ) == 0 )
					{
						IWbemClassObject *t_FilterObject = NULL ;

						HRESULT t_Result = m_CoreFullStub->GetObject ( 

							t_String->GetValue () ,
							0 ,
							a_Context , 
							& t_FilterObject , 
							NULL 
						) ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							LONG t_LeftLength = 0 ;
							LONG t_RightLength = 0 ;
							BOOL t_LeftIsA = FALSE ;

							t_Status = IsA (

								a_Class  ,
								t_FilterObject,
								t_LeftLength ,
								t_RightLength ,
								t_LeftIsA
							) ;

							if ( ! ( ( t_Status == QueryPreprocessor :: State_True ) && ( t_LeftIsA == TRUE ) ) )
							{
								t_Status = QueryPreprocessor :: State_True ;
							}
							else
							{
								t_Status = QueryPreprocessor :: State_False ;
							}

							t_FilterObject->Release () ;
						}
					}
				}
			}
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState CAggregator_IWbemProvider :: EnumShallow_Evaluate (

	IWbemClassObject *a_Class ,
	IWbemContext *a_Context , 
	WmiTreeNode *&a_Root
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_True ;
 
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	LONG t_VarType = 0 ;
	LONG t_Flavour = 0 ;

	HRESULT t_Result = a_Class->Get ( L"__Class" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Variant.vt == ( VT_NULL ) )
		{
			t_Status = QueryPreprocessor :: State_True ;
		}
		else
		{
			t_Status = EnumShallow_RecursiveEvaluate ( a_Class , a_Context , a_Root ) ;
		}

		VariantClear ( & t_Variant ) ;
	}
	else
	{
		t_Status = QueryPreprocessor :: State_Error ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState CAggregator_IWbemProvider :: IsA (

	IWbemClassObject *a_Left ,
	IWbemClassObject *a_Right ,
	LONG &a_LeftLength ,
	LONG &a_RightLength ,
	BOOL &a_LeftIsA
) 
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_False ;

	SAFEARRAY *t_LeftArray = NULL ;
	SAFEARRAY *t_RightArray = NULL ;
	
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	LONG t_VarType = 0 ;
	LONG t_Flavour = 0 ;

	BSTR t_LeftClass = NULL ;
	BSTR t_RightClass = NULL ;

	HRESULT t_Result = a_Left->Get ( L"__Class" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Variant.vt == ( VT_NULL ) )
		{
			t_Status = QueryPreprocessor :: State_True ;
			a_LeftIsA = FALSE ;
		}
		else
		{
			t_LeftClass = SysAllocString ( t_Variant.bstrVal ) ;
		}

		VariantClear ( & t_Variant ) ;
	}
	else
	{
		t_Status = QueryPreprocessor :: State_Error ;
	}

	if ( t_Status == QueryPreprocessor :: State_False )
	{
		t_Result = a_Right->Get ( L"__Class" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == ( VT_NULL ) )
			{
				t_Status = QueryPreprocessor :: State_True ;
				a_LeftIsA = TRUE ;
			}
			else
			{
				t_RightClass = SysAllocString ( t_Variant.bstrVal ) ;
			}

			VariantClear ( & t_Variant ) ;
		}
		else
		{
			t_Status = QueryPreprocessor :: State_Error ;
		}
	}

	VARIANT t_RightSafeArray ;
	VariantInit ( & t_RightSafeArray ) ;

	VARIANT t_LeftSafeArray ;
	VariantInit ( & t_LeftSafeArray ) ;

	if ( t_Status == QueryPreprocessor :: State_False )
	{
		t_Result = a_Right->Get ( L"__Derivation" , 0 , & t_RightSafeArray , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_RightSafeArray.vt == ( VT_BSTR | VT_ARRAY ) )
			{
				if ( SafeArrayGetDim ( t_RightSafeArray.parray ) == 1 )
				{
					LONG t_Dimension = 1 ; 

					LONG t_Lower ;
					SafeArrayGetLBound ( t_RightSafeArray.parray , t_Dimension , & t_Lower ) ;

					LONG t_Upper ;
					SafeArrayGetUBound ( t_RightSafeArray.parray , t_Dimension , & t_Upper ) ;

					a_RightLength = ( t_Upper - t_Lower ) + 2 ;

					SAFEARRAYBOUND t_ArrayBounds ;
					t_ArrayBounds.cElements = ( t_Upper - t_Lower ) + 2 ; 
					t_ArrayBounds.lLbound = t_Lower ;

					t_RightArray = SafeArrayCreate ( 

						VT_BSTR , 
						t_Dimension ,
						& t_ArrayBounds
					) ;

					if ( t_RightArray )
					{
						for ( LONG t_Index = t_Lower ; t_Index <= t_Upper ; t_Index ++ )
						{
							LONG t_ElementIndex = t_Lower + 1 ;

							BSTR t_Element = NULL ;
							if ( SUCCEEDED ( SafeArrayGetElement ( t_RightSafeArray.parray , & t_Index , & t_Element ) ) )
							{
								if ( SUCCEEDED ( SafeArrayPutElement ( t_RightArray , & t_ElementIndex , t_Element ) ) )
								{
								}
								else
								{
									t_Status = QueryPreprocessor :: State_Error ;

									SysFreeString ( t_Element ) ;

									break ;
								}

								SysFreeString ( t_Element ) ;
							}
							else
							{
							}
						}

						if ( t_Status != QueryPreprocessor :: State_Error )
						{
							LONG t_ElementIndex = t_Lower ;
							if ( SUCCEEDED ( SafeArrayPutElement ( t_RightArray , & t_ElementIndex , t_RightClass ) ) )
							{
							}
							else
							{
								t_Status = QueryPreprocessor :: State_Error ;
							}
						}
					}
					else
					{
						t_Status = QueryPreprocessor :: State_Error ;
					}
				}
				else
				{
					t_Status = QueryPreprocessor :: State_Error ;
				}
			}
			else
			{
				t_Status = QueryPreprocessor :: State_Error ;
			}
		}
		else
		{
			t_Status = QueryPreprocessor :: State_Error ;
		}

		if ( t_Status != QueryPreprocessor :: State_Error )
		{
			t_Result = a_Left->Get ( L"__Derivation" , 0 , & t_LeftSafeArray , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_LeftSafeArray.vt == ( VT_BSTR | VT_ARRAY ) )
				{
					t_LeftArray = t_LeftSafeArray.parray ;
					if ( SafeArrayGetDim ( t_LeftSafeArray.parray ) == 1 )
					{
						LONG t_Dimension = 1 ; 

						LONG t_Lower ;
						SafeArrayGetLBound ( t_LeftSafeArray.parray , t_Dimension , & t_Lower ) ;

						LONG t_Upper ;
						SafeArrayGetUBound ( t_LeftSafeArray.parray , t_Dimension , & t_Upper ) ;

						a_LeftLength = ( t_Upper - t_Lower ) + 2 ;

						SAFEARRAYBOUND t_ArrayBounds ;
						t_ArrayBounds.cElements = ( t_Upper - t_Lower ) + 2 ; 
						t_ArrayBounds.lLbound = t_Lower ;

						t_LeftArray = SafeArrayCreate ( 

							VT_BSTR , 
							t_Dimension ,
							& t_ArrayBounds
						) ;

						if ( t_LeftArray )
						{
							for ( LONG t_Index = t_Lower ; t_Index <= t_Upper ; t_Index ++ )
							{
								LONG t_ElementIndex = t_Lower + 1 ;

								BSTR t_Element = NULL ;
								if ( SUCCEEDED ( SafeArrayGetElement ( t_LeftSafeArray.parray , & t_Index , & t_Element ) ) )
								{
									if ( SUCCEEDED ( SafeArrayPutElement ( t_LeftArray , & t_ElementIndex , t_Element ) ) )
									{
									}
									else
									{
										t_Status = QueryPreprocessor :: State_Error ;

										SysFreeString ( t_Element ) ;

										break ;
									}

									SysFreeString ( t_Element ) ;
								}
								else
								{
									t_Status = QueryPreprocessor :: State_Error ;

									break ;
								}
							}

							if ( t_Status != QueryPreprocessor :: State_Error )
							{
								LONG t_ElementIndex = t_Lower ;
								if ( SUCCEEDED ( SafeArrayPutElement ( t_LeftArray , & t_ElementIndex , t_LeftClass ) ) )
								{
								}
								else
								{
									t_Status = QueryPreprocessor :: State_Error ;
								}
							}
						}
						else
						{
							t_Status = QueryPreprocessor :: State_Error ;
						}
					}
					else
					{
						t_Status = QueryPreprocessor :: State_Error ;
					}
				}
				else
				{
					t_Status = QueryPreprocessor :: State_Error ;
				}
			}
			else
			{
				t_Status = QueryPreprocessor :: State_Error ;
			}
		}

		if ( t_Status != QueryPreprocessor :: State_Error )
		{
			if ( t_LeftArray && t_RightArray )
			{
				ULONG t_MinimumLength = a_LeftLength < a_RightLength ? a_LeftLength : a_RightLength ;
				for ( LONG t_Index = t_MinimumLength ; t_Index > 0 ; t_Index -- )
				{
					BSTR t_LeftElement = NULL ;
					BSTR t_RightElement = NULL ;

					LONG t_Dimension = 1 ; 

					LONG t_Lower ;
					SafeArrayGetLBound ( t_LeftArray , t_Dimension , & t_Lower ) ;
					t_Lower = t_Lower + t_Index - 1 ;
 
					if ( SUCCEEDED ( t_Result = SafeArrayGetElement ( t_LeftArray , & t_Lower , & t_LeftElement ) ) )
					{
						SafeArrayGetUBound ( t_RightArray , t_Dimension , & t_Lower ) ;
						t_Lower = t_Lower + t_Index - 1 ;

						if ( SUCCEEDED ( t_Result = SafeArrayGetElement ( t_RightArray , & t_Lower , & t_RightElement ) ) )
						{
						}
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( wbem_wcsicmp ( t_LeftElement , t_RightElement ) != 0 )
						{
							SysFreeString ( t_LeftElement ) ;
							SysFreeString ( t_RightElement ) ;

							break ;
						}
					}

					SysFreeString ( t_LeftElement ) ;
					SysFreeString ( t_RightElement ) ;
				}

				if ( t_Index == 0 ) 
				{
					t_Status = QueryPreprocessor :: State_True ;

					a_LeftIsA = TRUE ;
				}
				else
				{
					if ( t_Index == t_MinimumLength )
					{
						if ( a_RightLength == t_MinimumLength )
						{
							t_Status = QueryPreprocessor :: State_True ;

							a_LeftIsA = TRUE ;
						}
						else
						{
							if ( a_LeftLength == t_MinimumLength )
							{
								t_Status = QueryPreprocessor :: State_True ;

								a_LeftIsA = FALSE ;
							}
						}
					}
				}
			}
			else	
			{
				t_Status = QueryPreprocessor :: State_Error ;
			}
		}

		SafeArrayDestroy ( t_LeftArray ) ;
		SafeArrayDestroy ( t_RightArray ) ;

		VariantClear ( & t_LeftSafeArray ) ;
		VariantClear ( & t_RightSafeArray ) ;
	}

	SysFreeString ( t_LeftClass ) ;
	SysFreeString ( t_RightClass ) ;

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: Enum_ClassProviders ( IWbemContext *a_Context )
{
	HRESULT t_Result = Enum_ClassProviders ( 

		m_CoreRepositoryStub ,
		a_Context 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; t_Index < m_ClassProvidersCount ; t_Index ++ )
		{
			CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
			if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
			{
				if ( t_Registration->InteractionType () == e_InteractionType_Push )
				{
					IWbemServices *t_Provider = NULL ;

					WmiInternalContext t_InternalContext ;
					ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

					HRESULT t_TempResult = m_Factory->GetProvider ( 

						t_InternalContext ,
						0 ,
						a_Context ,
						NULL ,
						m_User ,
						m_Locale ,
						NULL ,
						m_ClassProviders [ t_Index ]->GetProviderName () ,
						IID_IWbemServices , 
						( void ** ) & t_Provider 

					) ;

					if ( SUCCEEDED ( t_TempResult ) )
					{
						t_Provider->Release () ;
					}
				}
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: Enum_ClassProviders (

	IWbemServices *a_Repository ,
	IWbemContext *a_Context 
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_Query = SysAllocString ( L"Select * from __ClassProviderRegistration" ) ;
	if ( t_Query )
	{
		IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

		BSTR t_Language = SysAllocString ( ProviderSubSystem_Globals :: s_Wql ) ;
		if ( t_Language ) 
		{
			t_Result = a_Repository->ExecQuery ( 
				
				t_Language ,
				t_Query ,
				WBEM_FLAG_BIDIRECTIONAL ,
				a_Context , 
				& t_ClassObjectEnum
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				m_ClassProvidersCount = 0 ;

				IWbemClassObject *t_ClassObject = NULL ;
				ULONG t_ObjectCount = 0 ;

				t_ClassObjectEnum->Reset () ;
				while ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) 
				{
					m_ClassProvidersCount ++ ;
					t_ClassObject->Release () ;
				}

				if ( m_ClassProvidersCount )
				{
					m_ClassProviders = new CServerObject_ProviderRegistrationV1 * [ m_ClassProvidersCount ] ;
					if ( m_ClassProviders )
					{
						ZeroMemory ( m_ClassProviders , sizeof ( CServerObject_ProviderRegistrationV1 * ) * m_ClassProvidersCount ) ;

						ULONG t_Index = 0 ;

						t_ClassObjectEnum->Reset () ;
						while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
						{
							VARIANT t_Variant ;
							VariantInit ( & t_Variant ) ;
						
							LONG t_VarType = 0 ;
							LONG t_Flavour = 0 ;

							t_Result = t_ClassObject->Get ( L"Provider" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_Variant.vt == VT_BSTR )
								{
									IWbemPath *t_Path = NULL ;

									t_Result = CoCreateInstance (

										CLSID_WbemDefPath ,
										NULL ,
										CLSCTX_INPROC_SERVER ,
										IID_IWbemPath ,
										( void ** )  & t_Path
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										t_Result = t_Path->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , t_Variant.bstrVal ) ;
										if ( SUCCEEDED ( t_Result ) )
										{
											m_ClassProviders [ t_Index ] = new CServerObject_ProviderRegistrationV1  ;
											if ( m_ClassProviders [ t_Index ] )
											{
												m_ClassProviders [ t_Index ]->AddRef () ;

												t_Result = m_ClassProviders [ t_Index ]->SetContext ( 

													a_Context ,
													NULL , 
													a_Repository
												) ;
												
												if ( SUCCEEDED ( t_Result ) )
												{
													t_Result = m_ClassProviders [ t_Index ]->Load ( 

														e_All ,
														NULL , 
														t_Path
													) ;
												}
											}
											else
											{
												t_Result = WBEM_E_OUT_OF_MEMORY ;
											}
										}

										t_Path->Release () ;
									}
								}
							}

							VariantClear ( & t_Variant ) ;

							t_ClassObject->Release () ;

							t_Index ++ ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				t_ClassObjectEnum->Release () ;
			}

			SysFreeString ( t_Language ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		SysFreeString ( t_Query ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider::OpenNamespace ( 

	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemServices **a_NamespaceService, 
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

	Lock () ;

	WmiStatusCode t_StatusCode = Find ( 

		a_Sink ,
		t_Iterator
	) ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		ObjectSinkContainerElement *t_Element = t_Iterator.GetElement () ;

		UnLock () ;

		IObjectSink_CancelOperation *t_ObjectSink = NULL ;
		t_Result = t_Element->QueryInterface ( IID_IObjectSink_CancelOperation , ( void ** ) & t_ObjectSink ) ;
		if ( SUCCEEDED ( t_Result ) )
		{ 
			t_Result = t_ObjectSink->Cancel (

				0
			) ;

			t_ObjectSink->Release () ;
		}

		IWbemShutdown *t_Shutdown = NULL ;
		HRESULT t_TempResult = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = t_Shutdown->Shutdown ( 

				0 , 
				0 , 
				NULL 
			) ;

			t_Shutdown->Release () ;
		}

		t_Element->Release () ;
	}
	else
	{
		UnLock () ;

		t_Result = WBEM_E_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: QueryObjectSink ( 

	long a_Flags,		
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: GetObject ( 
		
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject **a_Object,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

		return WBEM_E_NOT_FOUND ;
	}

	if ( m_ClassProvidersCount )
	{
		IWbemPath *t_Path = NULL ;

		t_Result = CoCreateInstance (

			CLSID_WbemDefPath ,
			NULL ,
			CLSCTX_INPROC_SERVER ,
			IID_IWbemPath ,
			( void ** )  & t_Path
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Path->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_ObjectPath ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				ULONG t_ClassNameLength = 0 ;
				LPWSTR t_ClassName = NULL ;

				t_Result = t_Path->GetClassName (

					& t_ClassNameLength ,
					t_ClassName
				);

				if ( SUCCEEDED ( t_Result ) )
				{
					t_ClassName = new wchar_t [ t_ClassNameLength ] ;
					if ( t_ClassName )
					{
						t_Result = t_Path->GetClassName (

							& t_ClassNameLength ,
							t_ClassName
						);

						if ( SUCCEEDED ( t_Result ) )
						{
							BOOL t_ClassProviderFound = FALSE ;

							for ( ULONG t_Index = 0 ; t_Index < m_ClassProvidersCount ; t_Index ++ )
							{
								BOOL t_ProbeProvider = FALSE ;

								CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
								if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
								{
									WmiTreeNode **t_Forest = t_Registration->GetResultSetQuery () ;
									ULONG t_ForestCount = t_Registration->GetResultSetQueryCount () ;
									if ( t_ForestCount )
									{
										for ( ULONG t_FilterIndex = 0 ; t_FilterIndex < t_ForestCount ; t_FilterIndex ++ )
										{
											QueryPreprocessor :: QuadState t_Status = Get_Evaluate (

												t_ClassName ,
												a_Context , 
												t_Forest [ t_FilterIndex ] 
											) ;

											if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
											{
												t_ProbeProvider = TRUE ;
											}
										}
									}
									else
									{
										t_ProbeProvider = TRUE ;
									}
								}

								if ( t_ProbeProvider )
								{
									IWbemServices *t_Provider = NULL ;

									WmiInternalContext t_InternalContext ;
									ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

									t_Result = m_Factory->GetProvider ( 

										t_InternalContext ,
										0 ,
										a_Context ,
										NULL ,
										m_User ,
										m_Locale ,
										NULL ,
										m_ClassProviders [ t_Index ]->GetProviderName () ,
										IID_IWbemServices , 
										( void ** ) & t_Provider 

									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										if ( t_Registration->InteractionType () == e_InteractionType_Pull )
										{
											CInterceptor_IWbemWaitingObjectSink_GetObjectAsync *t_WaitingSink = new CInterceptor_IWbemWaitingObjectSink_GetObjectAsync (

												m_Allocator ,
												t_Provider ,
												a_Sink ,
												( CWbemGlobal_IWmiObjectSinkController * ) this ,
												*m_ClassProviders [ t_Index ]
											) ;

											if ( t_WaitingSink )
											{
												t_WaitingSink->AddRef () ;

												t_Result = t_WaitingSink->Initialize ( 
											
													m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () , 
													a_ObjectPath ,
													a_Flags ,
													a_Context 
												) ;

												if ( SUCCEEDED ( t_Result ) ) 
												{
													CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

													Lock () ;

													WmiStatusCode t_StatusCode = Insert ( 

														*t_WaitingSink ,
														t_Iterator
													) ;

													UnLock () ;

													if ( t_StatusCode == e_StatusCode_Success ) 
													{
														t_Result = t_Provider->GetObjectAsync ( 
																
															a_ObjectPath, 
															a_Flags, 
															a_Context,
															t_WaitingSink
														) ;

														if ( SUCCEEDED ( t_Result ) )
														{
															t_Result = t_WaitingSink->Wait ( INFINITE ) ;
															if ( SUCCEEDED ( t_Result ) )
															{
																if ( SUCCEEDED ( t_WaitingSink->GetResult () ) )
																{
																	t_ClassProviderFound = TRUE ;
																}
																else
																{
																	if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
																	{
																		t_Result = S_OK ;
																	}
																	else
																	{
																	}
																}
															}
															else
															{
															}
														}
														else
														{
															if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
															{
																t_Result = S_OK ;
															}
														}

														WmiQueue <IWbemClassObject *,8> &t_Queue = t_WaitingSink->GetQueue () ;

														CriticalSection &t_CriticalSection = t_WaitingSink->GetQueueCriticalSection () ;

														WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

														WmiStatusCode t_StatusCode = e_StatusCode_Success ;

														IWbemClassObject *t_Object = NULL ;
														while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
														{
															if(SUCCEEDED(t_Result))
																t_Result = a_Sink->Indicate ( 1 , & t_Object ) ;

															t_Object->Release () ;
															t_StatusCode = t_Queue.DeQueue () ;
														}

														WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
													}
													else
													{
														t_Result = WBEM_E_OUT_OF_MEMORY ;
													}
												}

												t_WaitingSink->Release () ;
											}
											else
											{
												t_Result = WBEM_E_OUT_OF_MEMORY ;
											}
										}

										t_Provider->Release () ;
									}
									else
									{
										t_Result = S_OK ;
									}
								}
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_ClassProviderFound == FALSE )
								{
									t_Result = WBEM_E_NOT_FOUND ;
								}
							}
						}

						delete [] t_ClassName ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
			}

			t_Path->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_NOT_FOUND ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: PutClass ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: PutClass_Helper_Advisory ( 

	IWbemClassObject *a_ClassObject, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	for ( ULONG t_Index = 0 ; SUCCEEDED ( t_Result ) && ( t_Index < m_ClassProvidersCount ) ; t_Index ++ )
	{
		CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
		if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
		{
			switch ( t_Registration->GetVersion () )
			{
				case 1:
				{
				}
				break ;

				case 2:
				{
					BOOL t_ProbeProvider = FALSE ;

					WmiTreeNode **t_Forest = t_Registration->GetResultSetQuery () ;
					ULONG t_ForestCount = t_Registration->GetResultSetQueryCount () ;
					if ( t_ForestCount )
					{
						for ( ULONG t_FilterIndex = 0 ; t_FilterIndex < t_ForestCount ; t_FilterIndex ++ )
						{
							QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_True ;

							t_Status = EnumDeep_Evaluate (

								a_ClassObject ,
								a_Context , 
								t_Forest [ t_FilterIndex ] 
							) ;

							if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
							{
								t_ProbeProvider = TRUE ;
							}
						}
					}
					else
					{
						t_ProbeProvider = TRUE ;
					}

					if ( t_ProbeProvider )
					{
						IWbemServices *t_Provider = NULL ;

						WmiInternalContext t_InternalContext ;
						ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

						t_Result = m_Factory->GetProvider ( 

							t_InternalContext ,
							0 ,
							a_Context ,
							NULL ,
							m_User ,
							m_Locale ,
							NULL ,
							m_ClassProviders [ t_Index ]->GetProviderName () ,
							IID_IWbemServices , 
							( void ** ) & t_Provider 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_Registration->InteractionType () == e_InteractionType_Pull )
							{
								CInterceptor_IWbemWaitingObjectSink_PutClassAsync *t_PuttingSink = new CInterceptor_IWbemWaitingObjectSink_PutClassAsync (

									m_Allocator , 
									t_Provider ,
									a_Sink ,
									( CWbemGlobal_IWmiObjectSinkController * ) this ,
									*m_ClassProviders [ t_Index ]
								) ;

								if ( t_PuttingSink )
								{
									t_PuttingSink->AddRef () ;

									t_Result = t_PuttingSink->Initialize ( 
									
										m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
										a_ClassObject , 
										a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
										a_Context
									) ;

									if ( SUCCEEDED ( t_Result ) ) 
									{
										CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

										Lock () ;

										WmiStatusCode t_StatusCode = Insert ( 

											*t_PuttingSink ,
											t_Iterator
										) ;

										UnLock () ;

										if ( t_StatusCode == e_StatusCode_Success ) 
										{
											t_Result = t_Provider->PutClassAsync ( 
													
												a_ClassObject , 
												a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
												a_Context,
												t_PuttingSink
											) ;

											if ( SUCCEEDED ( t_Result ) ) 
											{
												t_Result = t_PuttingSink->Wait ( INFINITE ) ;

												if ( SUCCEEDED ( t_Result ) )
												{
													t_Result = t_PuttingSink->GetResult () ;
													if ( FAILED ( t_Result ) )
													{
														if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
														{
															t_Result = S_OK ;
														}
													}
												}
											}
											else
											{
												if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
												{
													t_Result = S_OK ;
												}
											}
										}
										else
										{
											t_Result = WBEM_E_OUT_OF_MEMORY ;
										}

										WmiQueue <IWbemClassObject *,8> &t_Queue = t_PuttingSink->GetQueue () ;

										CriticalSection &t_CriticalSection = t_PuttingSink->GetQueueCriticalSection () ;

										WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

										IWbemClassObject *t_Object = NULL ;
										while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
										{
											t_Object->Release () ;
											t_StatusCode = t_Queue.DeQueue () ;
										}

										WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
									}

									t_PuttingSink->Release () ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							t_Provider->Release () ;
						}
					}
				}
				break ;

				default:
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
				break ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: PutClass_Helper_Put_CreateOrUpdate ( 

	BSTR a_Class ,
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	BOOL t_FoundProvider = FALSE ;

	for ( ULONG t_Index = 0 ; SUCCEEDED ( t_Result ) && ( t_Index < m_ClassProvidersCount ) ; t_Index ++ )
	{
		BOOL t_ProbeProvider = FALSE ;

		CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
		if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
		{
			WmiTreeNode **t_Forest = t_Registration->GetResultSetQuery () ;
			ULONG t_ForestCount = t_Registration->GetResultSetQueryCount () ;
			if ( t_ForestCount )
			{
				for ( ULONG t_FilterIndex = 0 ; t_FilterIndex < t_ForestCount ; t_FilterIndex ++ )
				{
					QueryPreprocessor :: QuadState t_Status = Get_Evaluate (

						a_Class ,
						a_Context , 
						t_Forest [ t_FilterIndex ] 
					) ;

					if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
					{
						t_ProbeProvider = TRUE ;
					}
				}
			}
			else
			{
				t_ProbeProvider = TRUE ;
			}
		}

		if ( t_ProbeProvider )
		{
			IWbemServices *t_Provider = NULL ;

			WmiInternalContext t_InternalContext ;
			ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

			t_Result = m_Factory->GetProvider ( 

				t_InternalContext ,
				0 ,
				a_Context ,
				NULL ,
				m_User ,
				m_Locale ,
				NULL ,
				m_ClassProviders [ t_Index ]->GetProviderName () ,
				IID_IWbemServices , 
				( void ** ) & t_Provider 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Registration->InteractionType () == e_InteractionType_Pull )
				{
					CInterceptor_IWbemWaitingObjectSink_PutClassAsync *t_WaitingSink = new CInterceptor_IWbemWaitingObjectSink_PutClassAsync (

						m_Allocator ,
						t_Provider ,
						a_Sink ,
						( CWbemGlobal_IWmiObjectSinkController * ) this ,
						*m_ClassProviders [ t_Index ]
					) ;

					if ( t_WaitingSink )
					{
						t_WaitingSink->AddRef () ;

						t_Result = t_WaitingSink->Initialize (
						
							m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
							a_Object , 
							a_Flags, 
							a_Context
						) ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

							Lock () ;

							WmiStatusCode t_StatusCode = Insert ( 

								*t_WaitingSink ,
								t_Iterator
							) ;

							UnLock () ;

							if ( t_StatusCode == e_StatusCode_Success ) 
							{
								t_Result = t_Provider->PutClassAsync ( 
										
									a_Object , 
									a_Flags, 
									a_Context,
									t_WaitingSink
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_WaitingSink->Wait ( INFINITE ) ;
									if ( SUCCEEDED ( t_Result ) )
									{
										if ( SUCCEEDED ( t_WaitingSink->GetResult () ) )
										{
											t_FoundProvider = TRUE ;
										}
										else
										{
											if ( ( a_Flags & ( WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY ) ) == WBEM_FLAG_CREATE_ONLY )
											{
												if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
												{
													t_Result = S_OK ;
												}
												else
												{
												}
											}
											else
											{
												if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
												{
													t_Result = S_OK ;
												}
												else
												{
												}
											}
										}
									}
									else
									{
									}
								}
								else
								{
									if ( ( a_Flags & ( WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY ) ) == WBEM_FLAG_CREATE_ONLY )
									{
										if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
										{
											t_Result = S_OK ;
										}
										else
										{
										}
									}
									else
									{
										if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
										{
											t_Result = S_OK ;
										}
										else
										{
										}
									}
								}

								WmiQueue <IWbemClassObject *,8> &t_Queue = t_WaitingSink->GetQueue () ;

								CriticalSection &t_CriticalSection = t_WaitingSink->GetQueueCriticalSection () ;

								WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

								WmiStatusCode t_StatusCode = e_StatusCode_Success ;

								IWbemClassObject *t_Object = NULL ;
								while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
								{
									t_Object->Release () ;
									t_StatusCode = t_Queue.DeQueue () ;
								}

								WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}

						t_WaitingSink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				t_Provider->Release () ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_FoundProvider == FALSE )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: PutClass_Helper_Put ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	LONG t_VarType = 0 ;
	LONG t_Flavour = 0 ;

	BOOL t_FoundProvider = FALSE ;

	HRESULT t_Result = a_Object->Get ( L"__Class" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		BOOL t_OwningRegistration = FALSE ;

		for ( ULONG t_Index = 0 ; ( SUCCEEDED ( t_Result ) && ( t_Index < m_ClassProvidersCount ) ) && ( t_OwningRegistration == FALSE ) ; t_Index ++ )
		{
			BOOL t_ProbeProvider = FALSE ;

			CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
			if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
			{
				WmiTreeNode **t_Forest = t_Registration->GetResultSetQuery () ;
				ULONG t_ForestCount = t_Registration->GetResultSetQueryCount () ;
				if ( t_ForestCount )
				{
					for ( ULONG t_FilterIndex = 0 ; t_FilterIndex < t_ForestCount ; t_FilterIndex ++ )
					{
						QueryPreprocessor :: QuadState t_Status = Get_Evaluate (

							t_Variant.bstrVal ,
							a_Context , 
							t_Forest [ t_FilterIndex ] 
						) ;

						if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
						{
							if ( t_Registration->InteractionType () == e_InteractionType_Pull )
							{
								t_FoundProvider = TRUE ;
							}

							t_ProbeProvider = TRUE ;
						}
					}
				}
				else
				{
					if ( t_Registration->InteractionType () == e_InteractionType_Pull )
					{
						t_FoundProvider = TRUE ;
					}

					t_ProbeProvider = TRUE ;
				}
			}

			if ( t_ProbeProvider )
			{
				IWbemServices *t_Provider = NULL ;

				WmiInternalContext t_InternalContext ;
				ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

				t_Result = m_Factory->GetProvider ( 

					t_InternalContext ,
					0 ,
					a_Context ,
					NULL ,
					m_User ,
					m_Locale ,
					NULL ,
					m_ClassProviders [ t_Index ]->GetProviderName () ,
					IID_IWbemServices , 
					( void ** ) & t_Provider 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Registration->InteractionType () == e_InteractionType_Pull )
					{
						CInterceptor_IWbemWaitingObjectSink_GetObjectAsync *t_WaitingSink = new CInterceptor_IWbemWaitingObjectSink_GetObjectAsync (

							m_Allocator ,
							t_Provider ,
							a_Sink ,
							( CWbemGlobal_IWmiObjectSinkController * ) this ,
							*m_ClassProviders [ t_Index ]
						) ;

						if ( t_WaitingSink )
						{
							t_WaitingSink->AddRef () ;

							t_Result = t_WaitingSink->Initialize (
							
								m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
								t_Variant.bstrVal , 
								a_Flags, 
								a_Context
							) ;

							if ( SUCCEEDED ( t_Result ) ) 
							{
								CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

								Lock () ;

								WmiStatusCode t_StatusCode = Insert ( 

									*t_WaitingSink ,
									t_Iterator
								) ;

								UnLock () ;

								if ( t_StatusCode == e_StatusCode_Success ) 
								{
									WmiStatusCode t_StatusCode = e_StatusCode_Success ;

									WmiQueue <IWbemClassObject *,8> &t_Queue = t_WaitingSink->GetQueue () ;

									t_Result = t_Provider->GetObjectAsync ( 
											
										t_Variant.bstrVal , 
										a_Flags, 
										a_Context,
										t_WaitingSink
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										t_Result = t_WaitingSink->Wait ( INFINITE ) ;

										if ( SUCCEEDED ( t_Result ) )
										{
											if ( SUCCEEDED ( t_WaitingSink->GetResult () ) )
											{
												t_OwningRegistration = TRUE ;

												CriticalSection &t_CriticalSection = t_WaitingSink->GetQueueCriticalSection () ;

												WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

												IWbemClassObject *t_Object = NULL ;
												while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
												{
													t_Object->Release () ;
													t_StatusCode = t_Queue.DeQueue () ;
												}

												WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
											}
											else
											{
												if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
												{
													t_Result = S_OK ;
												}
											}
										}
									}
									else
									{
										if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
										{
											t_Result = S_OK ;
										}
									}

									CriticalSection &t_CriticalSection = t_WaitingSink->GetQueueCriticalSection () ;

									WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

									IWbemClassObject *t_Object = NULL ;
									while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
									{
										t_Object->Release () ;
										t_StatusCode = t_Queue.DeQueue () ;
									}

									WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							t_WaitingSink->Release () ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_Provider->Release () ;
				}
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_OwningRegistration )
			{
				if ( ( a_Flags & ( WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY ) ) == WBEM_FLAG_CREATE_ONLY )
				{
					t_Result = WBEM_E_ALREADY_EXISTS ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = PutClass_Helper_Put_CreateOrUpdate ( 

						t_Variant.bstrVal ,							
						a_Object, 
						( ( a_Flags & ( WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY ) ) == WBEM_FLAG_CREATE_OR_UPDATE ) ? a_Flags | WBEM_FLAG_UPDATE_ONLY : a_Flags & ( ~WBEM_FLAG_CREATE_ONLY ) , 
						a_Context,
						a_Sink
					) ;
				}
			}
			else
			{
				if ( ( a_Flags & ( WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY ) ) == WBEM_FLAG_UPDATE_ONLY ) 
				{
					t_Result = WBEM_E_NOT_FOUND ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = PutClass_Helper_Put_CreateOrUpdate ( 

						t_Variant.bstrVal ,							
						a_Object, 
						( ( a_Flags & ( WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY ) ) == WBEM_FLAG_CREATE_OR_UPDATE ) ? a_Flags | WBEM_FLAG_CREATE_ONLY  : a_Flags & ( ~WBEM_FLAG_UPDATE_ONLY ) , 
						a_Context,
						a_Sink
					) ;
				}
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_FoundProvider == FALSE ) 
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: PutClassAsync ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	if ( WBEM_FLAG_ADVISORY & a_Flags )
	{
		if ( m_ClassProvidersCount )
		{
			t_Result = PutClass_Helper_Advisory ( 

				a_Object ,
				a_Flags, 
				a_Context,
				a_Sink
			) ;
		}
	}
	else
	{
		if ( m_ClassProvidersCount )
		{
			t_Result = PutClass_Helper_Put ( 

				a_Object ,
				a_Flags, 
				a_Context,
				a_Sink
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: DeleteClass ( 
		
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: DeleteClass_Helper_Advisory ( 

	IWbemClassObject *a_ClassObject ,
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	for ( ULONG t_Index = 0 ; SUCCEEDED ( t_Result ) && ( t_Index < m_ClassProvidersCount ) ; t_Index ++ )
	{
		CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
		if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
		{
			switch ( t_Registration->GetVersion () )
			{
				case 1:
				{
				}
				break ;

				case 2:
				{
					BOOL t_ProbeProvider = FALSE ;

					WmiTreeNode **t_Forest = t_Registration->GetResultSetQuery () ;
					ULONG t_ForestCount = t_Registration->GetResultSetQueryCount () ;
					if ( t_ForestCount )
					{
						for ( ULONG t_FilterIndex = 0 ; t_FilterIndex < t_ForestCount ; t_FilterIndex ++ )
						{
							QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_True ;

							t_Status = EnumDeep_Evaluate (

								a_ClassObject ,
								a_Context , 
								t_Forest [ t_FilterIndex ] 
							) ;

							if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
							{
								t_ProbeProvider = TRUE ;
							}
						}
					}
					else
					{
						t_ProbeProvider = TRUE ;
					}

					if ( t_ProbeProvider )
					{
						IWbemServices *t_Provider = NULL ;

						WmiInternalContext t_InternalContext ;
						ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

						t_Result = m_Factory->GetProvider ( 

							t_InternalContext ,
							0 ,
							a_Context ,
							NULL ,
							m_User ,
							m_Locale ,
							NULL ,
							m_ClassProviders [ t_Index ]->GetProviderName () ,
							IID_IWbemServices , 
							( void ** ) & t_Provider 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_Registration->InteractionType () == e_InteractionType_Pull )
							{
								CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync *t_DeletingSink = new CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync (

									m_Allocator , 
									t_Provider ,
									a_Sink ,
									( CWbemGlobal_IWmiObjectSinkController * ) this ,
									*m_ClassProviders [ t_Index ]
								) ;

								if ( t_DeletingSink )
								{
									t_DeletingSink->AddRef () ;

									t_Result = t_DeletingSink->Initialize ( 
									
										m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
										a_Class ,
										a_Flags ,
										a_Context	
									) ;

									if ( SUCCEEDED ( t_Result ) ) 
									{
										CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

										Lock () ;

										WmiStatusCode t_StatusCode = Insert ( 

											*t_DeletingSink ,
											t_Iterator
										) ;

										UnLock () ;

										if ( t_StatusCode == e_StatusCode_Success ) 
										{
											t_Result = t_Provider->DeleteClassAsync ( 
													
												a_Class, 
												a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
												a_Context,
												t_DeletingSink
											) ;

											if ( SUCCEEDED ( t_Result ) ) 
											{
												t_Result = t_DeletingSink->Wait ( INFINITE ) ;

												if ( SUCCEEDED ( t_Result ) )
												{
													t_Result = t_DeletingSink->GetResult () ;
													if ( FAILED ( t_Result ) )
													{
														if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
														{
															t_Result = S_OK ;
														}

													}
												}
												else
												{
													if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
													{
														t_Result = S_OK ;
													}
												}
											}
										}
										else
										{
											t_Result = WBEM_E_OUT_OF_MEMORY ;
										}

										WmiQueue <IWbemClassObject *,8> &t_Queue = t_DeletingSink->GetQueue () ;

										CriticalSection &t_CriticalSection = t_DeletingSink->GetQueueCriticalSection () ;

										WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

										IWbemClassObject *t_Object = NULL ;
										while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
										{
											t_Object->Release () ;
											t_StatusCode = t_Queue.DeQueue () ;
										}

										WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
									}

									t_DeletingSink->Release () ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							t_Provider->Release () ;
						}
					}
				}
				break ;

				default:
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
				break ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: DeleteClass_Helper_Enum ( 

	IWbemClassObject *a_ClassObject ,
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	for ( ULONG t_Index = 0 ; SUCCEEDED ( t_Result ) && ( t_Index < m_ClassProvidersCount ) ; t_Index ++ )
	{
		CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
		if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
		{
			switch ( t_Registration->GetVersion () )
			{
				case 1:
				{
					BOOL t_EnumProbeProvider = FALSE ;

					WmiTreeNode **t_Forest = t_Registration->GetResultSetQuery () ;
					ULONG t_ForestCount = t_Registration->GetResultSetQueryCount () ;
					if ( t_ForestCount )
					{
						for ( ULONG t_FilterIndex = 0 ; t_FilterIndex < t_ForestCount ; t_FilterIndex ++ )
						{
							QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_True ;

							t_Status = EnumDeep_Evaluate (

								a_ClassObject ,
								a_Context , 
								t_Forest [ t_FilterIndex ] 
							) ;

							if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
							{
								t_EnumProbeProvider = TRUE ;
							}
						}
					}
					else
					{
						t_EnumProbeProvider = TRUE ;
					}

					if ( t_EnumProbeProvider )
					{
						IWbemServices *t_Provider = NULL ;

						WmiInternalContext t_InternalContext ;
						ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

						t_Result = m_Factory->GetProvider ( 

							t_InternalContext ,
							0 ,
							a_Context ,
							NULL ,
							m_User ,
							m_Locale ,
							NULL ,
							m_ClassProviders [ t_Index ]->GetProviderName () ,
							IID_IWbemServices , 
							( void ** ) & t_Provider 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync *t_EnumeratingSink = new CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync (

								m_Allocator , 
								t_Provider ,
								a_Sink ,
								( CWbemGlobal_IWmiObjectSinkController * ) this ,
								*m_ClassProviders [ t_Index ]
							) ;

							if ( t_EnumeratingSink )
							{
								t_EnumeratingSink->AddRef () ;

								t_Result = t_EnumeratingSink->Initialize (
								
									m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
									a_Class, 
									WBEM_FLAG_DEEP, 
									a_Context
								) ;

								if ( SUCCEEDED ( t_Result ) ) 
								{
									CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

									Lock () ;

									WmiStatusCode t_StatusCode = Insert ( 

										*t_EnumeratingSink ,
										t_Iterator
									) ;

									UnLock () ;

									if ( t_StatusCode == e_StatusCode_Success ) 
									{
										t_Result = t_Provider->CreateClassEnumAsync ( 
												
											a_Class, 
											WBEM_FLAG_DEEP, 
											a_Context,
											t_EnumeratingSink
										) ;

										if ( SUCCEEDED ( t_Result ) )
										{
											t_Result = t_EnumeratingSink->Wait ( INFINITE ) ;
											if ( SUCCEEDED ( t_Result ) )
											{
												t_Result = t_EnumeratingSink->GetResult () ;
												if ( SUCCEEDED ( t_Result ) )
												{
													WmiQueue <IWbemClassObject *,8> &t_Queue = t_EnumeratingSink->GetQueue () ;

													CriticalSection &t_CriticalSection = t_EnumeratingSink->GetQueueCriticalSection () ;

													WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

													IWbemClassObject *t_Object = NULL ;

													WmiStatusCode t_StatusCode = e_StatusCode_Success ;

													while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
													{
														VARIANT t_Variant ;
														VariantInit ( & t_Variant ) ;

														LONG t_VarType = 0 ;
														LONG t_Flavour = 0 ;

														t_Result = t_Object->Get ( L"__Class" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
														if ( SUCCEEDED ( t_Result ) )
														{
															CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync *t_DeletingSink = new CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync (

																m_Allocator ,
																t_Provider ,
																a_Sink ,
																( CWbemGlobal_IWmiObjectSinkController * ) this ,
																*m_ClassProviders [ t_Index ]
															) ;

															if ( t_DeletingSink )
															{
																t_DeletingSink->AddRef () ;

																t_Result = t_DeletingSink->Initialize ( 
																
																	m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
																	t_Variant.bstrVal , 
																	a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS ,
																	a_Context
																) ;

																if ( SUCCEEDED ( t_Result ) ) 
																{
																	CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

																	Lock () ;

																	WmiStatusCode t_StatusCode = Insert ( 

																		*t_DeletingSink ,
																		t_Iterator
																	) ;

																	UnLock () ;

																	if ( t_StatusCode == e_StatusCode_Success ) 
																	{
																		t_Result = t_Provider->DeleteClassAsync ( 
																				
																			t_Variant.bstrVal , 
																			a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
																			a_Context,
																			t_DeletingSink
																		) ;

																		if ( SUCCEEDED ( t_Result ) )
																		{
																			t_Result = t_DeletingSink->Wait ( INFINITE ) ;
																			if ( SUCCEEDED ( t_Result ) )
																			{
																				if ( SUCCEEDED ( t_DeletingSink->GetResult () ) )
																				{
																				}
																				else
																				{
																					if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
																					{
																						t_Result = S_OK ;
																					}
																				}
																			}
																		}
																		else
																		{
																			if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
																			{
																				t_Result = S_OK ;
																			}
																		}
																	}
																	else
																	{
																		t_Result = WBEM_E_OUT_OF_MEMORY ;
																	}

																	WmiQueue <IWbemClassObject *,8> &t_Queue = t_DeletingSink->GetQueue () ;

																	CriticalSection &t_CriticalSection = t_DeletingSink->GetQueueCriticalSection () ;

																	WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

																	IWbemClassObject *t_Object = NULL ;
																	while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
																	{
																		t_Object->Release () ;
																		t_StatusCode = t_Queue.DeQueue () ;
																	}

																	WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
																}

																t_DeletingSink->Release () ;
															}
															else
															{
																t_Result = WBEM_E_OUT_OF_MEMORY ;
															}

															VariantClear ( & t_Variant ) ;
														}
														else
														{
															t_Result = WBEM_E_CRITICAL_ERROR ;
														}

														t_Object->Release () ;

														t_StatusCode = t_Queue.DeQueue () ;
													}

													WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;

												}
												else
												{
													if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
													{
														t_Result = S_OK ;
													}
												}
											}
										}
										else
										{
											if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
											{
												t_Result = S_OK ;
											}
										}
									}
									else
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}
								}

								t_EnumeratingSink->Release () ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							t_Provider->Release () ;
						}
					}
				}
				break ;

				case 2:
				{
				}
				break ;

				default:
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
				break ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: DeleteClass_Helper_Get ( 

	IWbemClassObject *a_ClassObject ,
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	BOOL t_ClassDeleted = FALSE ;

	for ( ULONG t_Index = 0 ; SUCCEEDED ( t_Result ) && ( t_Index < m_ClassProvidersCount ) ; t_Index ++ )
	{
		BOOL t_EnumProbeProvider = FALSE ;

		CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
		if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
		{
			WmiTreeNode **t_Forest = t_Registration->GetResultSetQuery () ;
			ULONG t_ForestCount = t_Registration->GetResultSetQueryCount () ;
			if ( t_ForestCount )
			{
				for ( ULONG t_FilterIndex = 0 ; t_FilterIndex < t_ForestCount ; t_FilterIndex ++ )
				{
					QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_True ;

					t_Status = Get_Evaluate (

						a_Class ,
						a_Context , 
						t_Forest [ t_FilterIndex ] 
					) ;

					if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
					{
						t_EnumProbeProvider = TRUE ;
					}
				}
			}
			else
			{
				t_EnumProbeProvider = TRUE ;
			}
		}

		if ( t_EnumProbeProvider )
		{
			IWbemServices *t_Provider = NULL ;

			WmiInternalContext t_InternalContext ;
			ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

			t_Result = m_Factory->GetProvider ( 

				t_InternalContext ,
				0 ,
				a_Context ,
				NULL ,
				m_User ,
				m_Locale ,
				NULL ,
				m_ClassProviders [ t_Index ]->GetProviderName () ,
				IID_IWbemServices , 
				( void ** ) & t_Provider 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Registration->InteractionType () == e_InteractionType_Pull )
				{
					CInterceptor_IWbemWaitingObjectSink_GetObjectAsync *t_GettingSink = new CInterceptor_IWbemWaitingObjectSink_GetObjectAsync (

						m_Allocator , 
						t_Provider ,
						a_Sink ,
						( CWbemGlobal_IWmiObjectSinkController * ) this ,
						*m_ClassProviders [ t_Index ]
					) ;

					if ( t_GettingSink )
					{
						t_GettingSink->AddRef () ;

						t_Result = t_GettingSink->Initialize (

							m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
							a_Class, 
							0 , 
							a_Context
						) ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

							Lock () ;

							WmiStatusCode t_StatusCode = Insert ( 

								*t_GettingSink ,
								t_Iterator
							) ;

							UnLock () ;

							if ( t_StatusCode == e_StatusCode_Success ) 
							{
								t_Result = t_Provider->GetObjectAsync ( 
										
									a_Class, 
									0 , 
									a_Context,
									t_GettingSink
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_GettingSink->Wait ( INFINITE ) ;
									if ( SUCCEEDED ( t_Result ) )
									{
										t_Result = t_GettingSink->GetResult () ;
										if ( SUCCEEDED ( t_Result ) )
										{
											CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync *t_DeletingSink = new CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync (

												m_Allocator ,
												t_Provider ,
												a_Sink ,
												( CWbemGlobal_IWmiObjectSinkController * ) this ,
												*m_ClassProviders [ t_Index ]
											) ;

											if ( t_DeletingSink )
											{
												t_DeletingSink->AddRef () ;

												t_Result = t_DeletingSink->Initialize ( 
												
													m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
													a_Class , 
													a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
													a_Context
												) ;

												if ( SUCCEEDED ( t_Result ) ) 
												{
													CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

													Lock () ;

													WmiStatusCode t_StatusCode = Insert ( 

														*t_DeletingSink ,
														t_Iterator
													) ;

													UnLock () ;

													if ( t_StatusCode == e_StatusCode_Success ) 
													{
														t_Result = t_Provider->DeleteClassAsync ( 
																
															a_Class, 
															a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
															a_Context,
															t_DeletingSink
														) ;

														if ( SUCCEEDED ( t_Result ) )
														{
															t_Result = t_DeletingSink->Wait ( INFINITE ) ;
															if ( SUCCEEDED ( t_Result ) )
															{
																if ( SUCCEEDED ( t_DeletingSink->GetResult () ) )
																{
																	t_ClassDeleted = TRUE ;
																}
															}
															else
															{
																if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
																{
																	t_Result = S_OK ;
																}
															}
														}
														else
														{
															if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
															{
																t_Result = S_OK ;
															}
														}
													}
													else
													{
														t_Result = WBEM_E_OUT_OF_MEMORY ;
													}

													WmiQueue <IWbemClassObject *,8> &t_Queue = t_DeletingSink->GetQueue () ;

													CriticalSection &t_CriticalSection = t_DeletingSink->GetQueueCriticalSection () ;

													WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

													IWbemClassObject *t_Object = NULL ;
													while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
													{
														t_Object->Release () ;
														t_StatusCode = t_Queue.DeQueue () ;
													}

													WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
												}

												t_DeletingSink->Release () ;
											}
											else
											{
												t_Result = WBEM_E_OUT_OF_MEMORY ;
											}
										}
										else
										{
											if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
											{
												t_Result = S_OK ;
											}
										}
									}
								}
								else
								{
									if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
									{
										t_Result = S_OK ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							WmiQueue <IWbemClassObject *,8> &t_Queue = t_GettingSink->GetQueue () ;

							CriticalSection &t_CriticalSection = t_GettingSink->GetQueueCriticalSection () ;

							WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

							IWbemClassObject *t_Object = NULL ;
							while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
							{
								t_Object->Release () ;
								t_StatusCode = t_Queue.DeQueue () ;
							}

							WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
						}
					
						t_GettingSink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				t_Provider->Release () ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_ClassDeleted == FALSE )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: DeleteClassAsync ( 
		
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	IWbemClassObject *t_ClassObject = NULL ;

	t_Result = m_CoreFullStub->GetObject ( 

		a_Class ,
		0 ,
		a_Context , 
		& t_ClassObject , 
		NULL 
	) ;

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			t_Result = DeleteClass_Helper_Advisory ( 

				t_ClassObject ,
				a_Class, 
				a_Flags, 
				a_Context,
				a_Sink
			) ;
		}
		else
		{
			t_Result = DeleteClass_Helper_Enum ( 

				t_ClassObject ,
				a_Class, 
				a_Flags, 
				a_Context,
				a_Sink
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = DeleteClass_Helper_Get ( 

					t_ClassObject ,
					a_Class, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}
		}

		t_ClassObject->Release () ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: CreateClassEnum ( 

	const BSTR a_Superclass, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CAggregator_IWbemProvider :: CreateClassEnumAsync (

	const BSTR a_Superclass , 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	if ( m_ClassProvidersCount )
	{
		IWbemClassObject *t_SuperclassObject = NULL ;

		if ( wcscmp ( L"" , a_Superclass ) != 0 )
		{
			t_Result = m_CoreFullStub->GetObject ( 

				a_Superclass ,
				0 ,
				a_Context , 
				& t_SuperclassObject , 
				NULL 
			) ;
		}

		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_ClassProviderFound = FALSE ;

			for ( ULONG t_Index = 0 ; t_Index < m_ClassProvidersCount ; t_Index ++ )
			{
				BOOL t_ProbeProvider = FALSE ;

				CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
				if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
				{
					if ( t_SuperclassObject )
					{
						WmiTreeNode **t_Forest = t_Registration->GetResultSetQuery () ;
						ULONG t_ForestCount = t_Registration->GetResultSetQueryCount () ;
						if ( t_ForestCount )
						{
							for ( ULONG t_FilterIndex = 0 ; t_FilterIndex < t_ForestCount ; t_FilterIndex ++ )
							{
								QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_True ;

								if ( ( a_Flags & ( WBEM_FLAG_DEEP | WBEM_FLAG_SHALLOW ) ) == WBEM_FLAG_DEEP )
								{
									t_Status = EnumDeep_Evaluate (

										t_SuperclassObject ,
										a_Context , 
										t_Forest [ t_FilterIndex ] 
									) ;
								}
								else
								{
									t_Status = EnumShallow_Evaluate (

										t_SuperclassObject ,
										a_Context , 
										t_Forest [ t_FilterIndex ] 
									) ;
								}

								if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
								{
									t_ProbeProvider = TRUE ;
								}
							}
						}
						else
						{
							t_ProbeProvider = TRUE ;
						}
					}
					else
					{
						t_ProbeProvider = TRUE ;
					}
				}

				if ( t_ProbeProvider )
				{
					IWbemServices *t_Provider = NULL ;

					WmiInternalContext t_InternalContext ;
					ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

					t_Result = m_Factory->GetProvider ( 

						t_InternalContext ,
						0 ,
						a_Context ,
						NULL ,
						m_User ,
						m_Locale ,
						NULL ,
						m_ClassProviders [ t_Index ]->GetProviderName () ,
						IID_IWbemServices , 
						( void ** ) & t_Provider 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_Registration->InteractionType () == e_InteractionType_Pull )
						{
							CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync *t_WaitingSink = new CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync (

								m_Allocator ,
								t_Provider ,
								a_Sink ,
								( CWbemGlobal_IWmiObjectSinkController * ) this ,
								*m_ClassProviders [ t_Index ]
							) ;

							if ( t_WaitingSink )
							{
								t_WaitingSink->AddRef () ;

								t_Result = t_WaitingSink->Initialize (
								
									m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
									a_Superclass , 
									a_Flags, 
									a_Context
								) ;

								if ( SUCCEEDED ( t_Result ) ) 
								{
									CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

									Lock () ;

									WmiStatusCode t_StatusCode = Insert ( 

										*t_WaitingSink ,
										t_Iterator
									) ;

									UnLock () ;

									if ( t_StatusCode == e_StatusCode_Success ) 
									{
										t_ClassProviderFound = TRUE ;

										t_Result = t_Provider->CreateClassEnumAsync ( 
												
											a_Superclass, 
											a_Flags, 
											a_Context,
											t_WaitingSink
										) ;

										if ( SUCCEEDED ( t_Result ) )
										{
											t_Result = t_WaitingSink->Wait ( INFINITE ) ;
											if ( SUCCEEDED ( t_Result ) )
											{
												if ( SUCCEEDED ( t_WaitingSink->GetResult () ) )
												{
													WmiQueue <IWbemClassObject *,8> &t_Queue = t_WaitingSink->GetQueue () ;

													CriticalSection &t_CriticalSection = t_WaitingSink->GetQueueCriticalSection () ;

													WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

													WmiStatusCode t_StatusCode = e_StatusCode_Success ;

													IWbemClassObject *t_Object = NULL ;
													while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
													{
														if(SUCCEEDED(t_Result))
															t_Result = a_Sink->Indicate ( 1 , & t_Object ) ;

														t_Object->Release () ;
														t_StatusCode = t_Queue.DeQueue () ;
													}

													WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
												}
												else
												{
													t_Result = S_OK ;
												}
											}
											else
											{
											}
										}
										else
										{
											t_Result = S_OK ;
										}
									}
									else
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}
								}

								t_WaitingSink->Release () ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}

						t_Provider->Release () ;
					}
					else
					{
						t_Result = S_OK ;
					}
				}
			}

			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
		else if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}

		if ( t_SuperclassObject )
		{
			t_SuperclassObject->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_NOT_FOUND;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: PutInstance (

    IWbemClassObject *a_Instance,
    long a_Flags,
    IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags ,
    IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: DeleteInstance ( 

	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CAggregator_IWbemProvider :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink

) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CAggregator_IWbemProvider :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CAggregator_IWbemProvider :: ExecMethod ( 

	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CAggregator_IWbemProvider :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: Expel (

	long a_Flags ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProviderController *t_Controller = ServiceCacheElement :: GetController () ;
	if ( t_Controller )
	{
		t_Controller->Shutdown ( ServiceCacheElement :: GetKey () ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: ForceReload ()
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: GetReferencesClasses (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	if ( m_ClassProvidersCount )
	{
		BOOL t_ClassProviderFound = FALSE ;

		for ( ULONG t_Index = 0 ; t_Index < m_ClassProvidersCount ; t_Index ++ )
		{
			BOOL t_ProbeProvider = FALSE ;

			CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
			if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
			{
				t_ProbeProvider = t_Registration->HasReferencedSet() ;
			}

			if ( t_ProbeProvider )
			{
				IWbemServices *t_Provider = NULL ;

				WmiInternalContext t_InternalContext ;
				ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

				t_Result = m_Factory->GetProvider ( 

					t_InternalContext ,
					0 ,
					a_Context ,
					NULL ,
					m_User ,
					m_Locale ,
					NULL ,
					m_ClassProviders [ t_Index ]->GetProviderName () ,
					IID_IWbemServices , 
					( void ** ) & t_Provider 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Registration->InteractionType () == e_InteractionType_Pull )
					{
						CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync *t_WaitingSink = new CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync (

							m_Allocator ,
							t_Provider ,
							a_Sink ,
							( CWbemGlobal_IWmiObjectSinkController * ) this ,
							*m_ClassProviders [ t_Index ]
						) ;

						if ( t_WaitingSink )
						{
							t_WaitingSink->AddRef () ;

							t_Result = t_WaitingSink->Initialize (
							
								m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
								L"" , 
								a_Flags, 
								a_Context
							) ;

							if ( SUCCEEDED ( t_Result ) ) 
							{
								CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

								Lock () ;

								WmiStatusCode t_StatusCode = Insert ( 

									*t_WaitingSink ,
									t_Iterator
								) ;

								UnLock () ;

								if ( t_StatusCode == e_StatusCode_Success ) 
								{
									t_ClassProviderFound = TRUE ;

									t_Result = t_Provider->CreateClassEnumAsync ( 
											
										L"", 
										a_Flags, 
										a_Context,
										t_WaitingSink
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										t_Result = t_WaitingSink->Wait ( INFINITE ) ;
										if ( SUCCEEDED ( t_Result ) )
										{
											if ( SUCCEEDED ( t_WaitingSink->GetResult () ) )
											{
												WmiQueue <IWbemClassObject *,8> &t_Queue = t_WaitingSink->GetQueue () ;

												CriticalSection &t_CriticalSection = t_WaitingSink->GetQueueCriticalSection () ;

												WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

												WmiStatusCode t_StatusCode = e_StatusCode_Success ;

												IWbemClassObject *t_Object = NULL ;
												while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
												{
													if(SUCCEEDED(t_Result))
														t_Result = a_Sink->Indicate ( 1 , & t_Object ) ;

													t_Object->Release () ;
													t_StatusCode = t_Queue.DeQueue () ;
												}

												WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
											}
											else
											{
												t_Result = S_OK ;
											}
										}
										else
										{
										}
									}
									else
									{
										t_Result = S_OK ;
									}
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							t_WaitingSink->Release () ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_Provider->Release () ;
				}
				else
				{
					t_Result = S_OK ;
				}
			}
		}

		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}
	else
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provcntrs.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvCntrs.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderSubsystem_Counters :: CServerObject_ProviderSubsystem_Counters () : 

    m_ProviderHost_WmiCore_Loads ( 0 ) ,
    m_ProviderHost_WmiCore_UnLoads ( 0 ) ,
	m_ProviderHost_WmiCoreOrSelfHost_Loads ( 0 ) ,
	m_ProviderHost_WmiCoreOrSelfHost_UnLoads ( 0 ) ,
	m_ProviderHost_SelfHost_Loads ( 0 ) ,
	m_ProviderHost_SelfHost_UnLoads ( 0 ) ,
	m_ProviderHost_ClientHost_Loads ( 0 ) ,
	m_ProviderHost_ClientHost_UnLoads ( 0 ) ,
	m_ProviderHost_Decoupled_Loads ( 0 ) ,
	m_ProviderHost_Decoupled_UnLoads ( 0 ) ,
	m_ProviderHost_SharedLocalSystemHost_Loads ( 0 ) ,
	m_ProviderHost_SharedLocalSystemHost_UnLoads ( 0 ) ,
	m_ProviderHost_SharedNetworkHost_Loads ( 0 ) ,
	m_ProviderHost_SharedNetworkHost_UnLoads ( 0 ) ,
	m_ProviderHost_SharedUserHost_Loads ( 0 ) ,
	m_ProviderHost_SharedUserHost_UnLoads ( 0 ) ,
	m_ProviderOperation_GetObjectAsync ( 0 ) ,
	m_ProviderOperation_PutClassAsync ( 0 ) ,
	m_ProviderOperation_DeleteClassAsync ( 0 ) ,
	m_ProviderOperation_CreateClassEnumAsync ( 0 ) ,
	m_ProviderOperation_PutInstanceAsync ( 0 ) ,
	m_ProviderOperation_DeleteInstanceAsync ( 0 ) ,
	m_ProviderOperation_CreateInstanceEnumAsync ( 0 ) ,
	m_ProviderOperation_ExecQueryAsync ( 0 ) ,
	m_ProviderOperation_ExecNotificationQueryAsync ( 0 ) ,
	m_ProviderOperation_ExecMethodAsync ( 0 ) ,
	m_ProviderOperation_QueryInstances ( 0 ) ,
	m_ProviderOperation_CreateRefresher ( 0 ) ,
	m_ProviderOperation_CreateRefreshableObject ( 0 ) ,
	m_ProviderOperation_StopRefreshing ( 0 ) ,
	m_ProviderOperation_CreateRefreshableEnum ( 0 ) ,
	m_ProviderOperation_GetObjects ( 0 ) ,
	m_ProviderOperation_GetProperty ( 0 ) ,
	m_ProviderOperation_PutProperty ( 0 ) ,
	m_ProviderOperation_ProvideEvents ( 0 ) ,
	m_ProviderOperation_NewQuery ( 0 ) ,
	m_ProviderOperation_CancelQuery ( 0 ) ,
	m_ProviderOperation_AccessCheck ( 0 ) ,
	m_ProviderOperation_SetRegistrationObject ( 0 ) ,
	m_ProviderOperation_FindConsumer ( 0 ) ,
	m_ProviderOperation_ValidateSubscription ( 0 )
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_ProviderSubsystem_Counters_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderSubsystem_Counters::~CServerObject_ProviderSubsystem_Counters ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_ProviderSubsystem_Counters_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provcache.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvSubS.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <wbemint.h>

#include <HelperFuncs.h>

#include "Guids.h"
#include "Globals.h"
#include "CGlobals.h"
#include "ProvSubS.h"
#include "ProvFact.h"
#include "ProvAggr.h"
#include "ProvLoad.h"
#include "ProvWsv.h"
#include "ProvObSk.h"

#include "ProvCache.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG CompareElement ( const HostCacheKey &a_Arg1 , const HostCacheKey &a_Arg2 )
{
	return a_Arg1.Compare ( a_Arg2 ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG CompareElement ( const BindingFactoryCacheKey &a_Arg1 , const BindingFactoryCacheKey &a_Arg2 )
{
	return a_Arg1.Compare ( a_Arg2 ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG CompareElement ( const ProviderCacheKey &a_Arg1 , const ProviderCacheKey &a_Arg2 ) 
{
	return a_Arg1.Compare ( a_Arg2 ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG CompareElement ( const GUID &a_Guid1 , const GUID &a_Guid2 )
{
	return memcmp ( & a_Guid1, & a_Guid2 , sizeof ( GUID ) ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG CompareElement ( const LONG &a_Arg1 , const LONG &a_Arg2 )
{
	return a_Arg1 - a_Arg2 ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HostController :: HostController ( WmiAllocator &a_Allocator ) : CWbemGlobal_IWmiHostController ( a_Allocator ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode HostController :: StrobeBegin ( const ULONG &a_Period )
{
	ULONG t_Timeout = ProviderSubSystem_Globals :: GetStrobeThread ().GetTimeout () ;
	ProviderSubSystem_Globals :: GetStrobeThread ().SetTimeout ( t_Timeout < a_Period ? t_Timeout : a_Period ) ;
	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

RefresherManagerController :: RefresherManagerController ( WmiAllocator &a_Allocator ) : CWbemGlobal_IWbemRefresherMgrController ( a_Allocator ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode RefresherManagerController :: StrobeBegin ( const ULONG &a_Period )
{
	ULONG t_Timeout = ProviderSubSystem_Globals :: GetStrobeThread ().GetTimeout () ;
	ProviderSubSystem_Globals :: GetStrobeThread ().SetTimeout ( t_Timeout < a_Period ? t_Timeout : a_Period ) ;
	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ProviderController :: ProviderController (

	WmiAllocator &a_Allocator ,
	CWbemGlobal_HostedProviderController *a_Controller ,
	DWORD a_ProcessIdentifier

) : m_Container ( a_Allocator ) ,
    m_CriticalSection(NOTHROW_LOCK),
	HostedProviderContainerElement ( 

		a_Controller ,
		a_ProcessIdentifier
	)
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ProviderController :: ~ProviderController () 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) ProviderController :: AddRef () 
{
	return HostedProviderContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) ProviderController :: Release () 
{
	return HostedProviderContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP ProviderController :: QueryInterface ( 

	REFIID iid , 
	LPVOID FAR *iplpv 
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_ProviderController )
	{
		*iplpv = ( LPVOID ) ( ProviderController * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ProviderController :: Initialize () 
{
	WmiStatusCode t_StatusCode = m_Container.Initialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_StatusCode = m_CriticalSection.valid() ? e_StatusCode_Success : e_StatusCode_OutOfMemory;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ProviderController :: UnInitialize () 
{
	WmiStatusCode t_StatusCode = m_Container.UnInitialize () ;
	return t_StatusCode ;
}	

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ProviderController :: Insert ( 

	CInterceptor_IWbemProvider *a_Element ,
	Container_Iterator &a_Iterator 
)
{
	Lock () ;

	Container_Iterator t_Iterator ;
	WmiStatusCode t_StatusCode = m_Container.Insert ( a_Element , a_Element , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		a_Element->NonCyclicAddRef () ;
	}

	UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ProviderController :: Delete ( 

	CInterceptor_IWbemProvider * const &a_Key
)
{
	Lock () ;

	WmiStatusCode t_StatusCode = m_Container.Delete ( a_Key ) ;

	UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ProviderController :: Find ( 

	CInterceptor_IWbemProvider * const &a_Key , 
	Container_Iterator &a_Iterator
)
{
	Lock () ;

	WmiStatusCode t_StatusCode = m_Container.Find ( a_Key , a_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		a_Iterator.GetElement ()->NonCyclicAddRef ( ) ;
	}

	UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ProviderController :: Lock ()
{
	if (!m_CriticalSection.valid())
		return e_StatusCode_OutOfMemory;

	while (!m_CriticalSection.acquire())
		Sleep(1000);

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ProviderController :: UnLock ()
{
	m_CriticalSection.release();
	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ProviderController :: Shutdown ()
{
	Lock () ;

	Container_Iterator t_Iterator = m_Container.Root ();

	while ( ! t_Iterator.Null () )
	{
		m_Container.Delete ( t_Iterator.GetKey () ) ;
		t_Iterator = m_Container.Root () ;
	}

	UnLock () ;

	return e_StatusCode_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provdcaggr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"
#include <typeinfo.h>
#include <wbemint.h>
#include <NCObjApi.h>

#include <Guids.h>
#include <Like.h>
#include "Globals.h"
#include "CGlobals.h"
#include "DateTime.h"
#include "ProvSubS.h"
#include "ProvDcAggr.h"
#include "ProvWsvS.h"
#include "ProvFact.h"
#include "ProvObSk.h"
#include "ProvInSk.h"
#include <scopecheck.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_ProviderSubsystemRegistrar :: CDecoupled_ProviderSubsystemRegistrar (

	WmiAllocator &a_Allocator ,
	CServerObject_ProviderSubSystem *a_SubSystem

) :	m_SubSystem ( a_SubSystem ) ,
	m_ReferenceCount ( 0 ) , 
	m_Allocator ( a_Allocator )
{
	m_SubSystem->AddRef () ;

	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CDecoupledAggregator_IWbemProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_ProviderSubsystemRegistrar :: ~CDecoupled_ProviderSubsystemRegistrar ()
{
	m_SubSystem->Release () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CDecoupledAggregator_IWbemProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CDecoupled_ProviderSubsystemRegistrar::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiProviderSubsystemRegistrar )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderSubsystemRegistrar * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CDecoupled_ProviderSubsystemRegistrar :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CDecoupled_ProviderSubsystemRegistrar :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_ProviderSubsystemRegistrar :: SaveToRegistry (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	DWORD a_ProcessIdentifier ,
	GUID &a_Identity ,
	IUnknown *a_Unknown
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_Handle = OpenProcess (

		PROCESS_QUERY_INFORMATION ,
		FALSE ,
		a_ProcessIdentifier
	) ;

	if ( t_Handle ) 
	{
		wchar_t t_Guid [64] ;

		int t_Status = StringFromGUID2 ( a_Identity , t_Guid , sizeof ( t_Guid ) / sizeof ( wchar_t ) ) ;
		if ( t_Status )
		{
			BYTE *t_MarshaledProxy = NULL ;
			DWORD t_MarshaledProxyLength = 0 ;

			t_Result = ProviderSubSystem_Common_Globals :: MarshalRegistration ( 

				a_Unknown ,
				t_MarshaledProxy ,
				t_MarshaledProxyLength
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				CServerObject_DecoupledClientRegistration_Element t_Element ;

				BSTR t_CreationTime = NULL ;

				FILETIME t_CreationFileTime ;
				FILETIME t_ExitFileTime ;
				FILETIME t_KernelFileTime ;
				FILETIME t_UserFileTime ;

				BOOL t_Status = GetProcessTimes (

					  t_Handle ,
					  & t_CreationFileTime,
					  & t_ExitFileTime,
					  & t_KernelFileTime,
					  & t_UserFileTime
				);

				if ( t_Status ) 
				{
					CWbemDateTime t_Time ;
					t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;

					t_Result = t_Time.GetValue ( & t_CreationTime ) ;
					if ( SUCCEEDED ( t_Result ) ) 
					{
						t_Result = t_Element.SetProcessIdentifier ( a_ProcessIdentifier ) ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							if ( a_Locale ) 
							{
								t_Result = t_Element.SetLocale ( ( BSTR ) a_Locale ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							if ( a_User ) 
							{
								t_Result = t_Element.SetUser ( ( BSTR ) a_User ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							t_Result = t_Element.SetProvider ( ( BSTR ) a_Registration ) ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							t_Result = t_Element.SetScope ( ( BSTR ) a_Scope ) ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							t_Result = t_Element.SetCreationTime ( ( BSTR ) t_CreationTime ) ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							t_Result = t_Element.SetMarshaledProxy ( t_MarshaledProxy , t_MarshaledProxyLength ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( ProviderSubSystem_Globals :: GetDecoupledRegistrySection () ) ;
							
							t_Result = t_Element.Save ( t_Guid ) ;

							t_StatusCode = WmiHelper :: LeaveCriticalSection ( ProviderSubSystem_Globals :: GetDecoupledRegistrySection () ) ;
						}

						SysFreeString ( t_CreationTime ) ;
					}
					else
					{
						t_Result = WBEM_E_UNEXPECTED ;
					}
				}
				else
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}

				delete [] t_MarshaledProxy ;
			}
		}
		else
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		CloseHandle ( t_Handle ) ;
	}
	else
	{
		t_Result = WBEM_E_ACCESS_DENIED ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_ProviderSubsystemRegistrar :: ValidateClientSecurity (

	IWbemContext *a_Context ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	IWbemPath *t_Scope = NULL ;

	t_Result = CoCreateInstance (

		CLSID_WbemDefPath ,
		NULL ,
		CLSCTX_INPROC_SERVER ,
		IID_IWbemPath ,
		( void ** )  & t_Scope 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CoImpersonateClient () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Scope->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Scope ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CServerObject_ProviderRegistrationV1 *t_Registration = new CServerObject_ProviderRegistrationV1 ;
				if ( t_Registration )
				{
					t_Registration->AddRef () ;

					t_Result = t_Registration->SetContext ( 

						a_Context ,
						t_Scope , 
						a_Service
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_InternalCacheTimeout ) ;

						t_Result = t_Registration->Load ( 

							e_All ,
							NULL , 
							a_Registration
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							SECURITY_DESCRIPTOR *t_SecurityDescriptor = t_Registration->GetComRegistration ().GetSecurityDescriptor () ;

							t_Result = ProviderSubSystem_Common_Globals :: Check_SecurityDescriptor_CallIdentity (

								t_SecurityDescriptor , 
								MASK_PROVIDER_BINDING_BIND ,
								& g_ProviderBindingMapping,
								ProviderSubSystem_Common_Globals::GetDefaultDecoupledSD()
							) ;
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND )
							{
								t_Result = WBEM_E_PROVIDER_NOT_FOUND ;
							}	
							else
							{
								t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
							}
						}
					}

					t_Registration->Release () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			CoRevertToSelf () ;
		}

		t_Scope->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_ProviderSubsystemRegistrar :: Register (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	DWORD a_ProcessIdentifier ,
	IUnknown *a_Unknown ,
	GUID a_Identity
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		IWbemContext *t_Context = NULL ;

		if ( a_Context )
		{
			t_Context = a_Context ;
			t_Context->AddRef () ;
		}
		else
		{
			t_Result = CoCreateInstance ( 

				CLSID_WbemContext ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IWbemContext ,
				( void ** )  & t_Context
			) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemServices *t_Service = NULL ;
			t_Result = m_SubSystem->GetWmiService ( 

				( const BSTR ) a_Scope ,
				( const BSTR ) a_User ,
				( const BSTR ) a_Locale ,
				t_Service
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = ValidateClientSecurity (

					a_Context ,
					a_Scope ,
					a_Registration ,
					t_Service 
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = SaveToRegistry (

						a_Flags ,
						a_Context ,
						a_User ,
						a_Locale ,
						a_Scope ,
						a_Registration ,
						a_ProcessIdentifier ,
						a_Identity ,
						a_Unknown
					) ;
				}

				if ( SUCCEEDED ( t_Result ) ) 
				{
					_IWmiProviderFactory *t_Factory = NULL ;
					t_Result = m_SubSystem->Create (

						t_Service ,
						0,
						t_Context ,
						a_Scope  ,
						IID__IWmiProviderFactory  ,
						( void ** ) & t_Factory
					) ;
					
					if ( SUCCEEDED ( t_Result ) ) 
					{
						_IWmiProviderSubsystemRegistrar *t_Registrar = NULL ;

						t_Result = t_Factory->GetDecoupledProvider (

							0 ,
							t_Context ,
							a_User ,
							a_Locale  ,
							a_Scope ,
							a_Registration ,
							IID__IWmiProviderSubsystemRegistrar ,
							( void ** ) & t_Registrar
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Registrar->Register (

								0 ,
								t_Context ,
								a_User ,
								a_Locale  ,
								a_Scope ,
								a_Registration ,
								a_ProcessIdentifier ,
								a_Unknown ,
								a_Identity
							) ;

							t_Registrar->Release () ;
						}

						t_Factory->Release () ;
					}
				}

				t_Service->Release () ;
			}
		}

		if ( t_Context )
		{
			t_Context->Release () ;
		}

	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

HRESULT HasDeleteAccess(wchar_t * guid)
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_HomeClientClsid_String = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 
		3, 
		& t_HomeClientClsid_String , 
		CServerObject_DecoupledClientRegistration::getClientKey() ,
		L"\\" ,
		guid) ;

	if (SUCCEEDED(t_Result))
		{
		t_Result = CoImpersonateClient();
		if ( SUCCEEDED ( t_Result ) )
			{
			HKEY t_HomeClientClsid_Key ;

			if (RegOpenKeyEx (HKEY_LOCAL_MACHINE , t_HomeClientClsid_String ,  0 , 	DELETE , & t_HomeClientClsid_Key )== ERROR_SUCCESS)
				{
				RegCloseKey(t_HomeClientClsid_Key);
				}
			else
				{
				t_Result = E_ACCESSDENIED;
				}
			CoRevertToSelf();
			}
		SysFreeString ( t_HomeClientClsid_String ) ;
		}

	return t_Result;
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT CDecoupled_ProviderSubsystemRegistrar :: UnRegister (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	GUID a_Identity
)
{
	HRESULT t_Result = S_OK ;

	wchar_t t_Guid [64] ;

	int t_Status = StringFromGUID2 ( a_Identity , t_Guid , sizeof ( t_Guid ) / sizeof ( wchar_t ) ) ;
	
	if ( !t_Status )
		{
		return E_UNEXPECTED;
		}

	t_Result = HasDeleteAccess(t_Guid);

	if (FAILED(t_Result)) return t_Result;

	try
	{
		IWbemServices *t_Service = NULL ;
		t_Result = m_SubSystem->GetWmiService ( 

			( const BSTR ) a_Scope ,
			( const BSTR ) a_User ,
			( const BSTR ) a_Locale ,
			t_Service
		) ;

		if (SUCCEEDED ( t_Result ) )
		{
			_IWmiProviderFactory *t_Factory = NULL ;
			t_Result = m_SubSystem->Create (

				t_Service ,
				0,
				a_Context ,
				a_Scope  ,
				IID__IWmiProviderFactory  ,
				( void ** ) & t_Factory
			) ;
			
			if ( SUCCEEDED ( t_Result ) ) 
			{
				_IWmiProviderSubsystemRegistrar *t_Registrar = NULL ;

				t_Result = t_Factory->GetDecoupledProvider (

					0 ,
					a_Context ,
					a_User ,
					a_Locale  ,
					a_Scope ,
					a_Registration ,
					IID__IWmiProviderSubsystemRegistrar ,
					( void ** ) & t_Registrar
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Registrar->UnRegister (

						0 ,
						a_Context ,
						a_User ,
						a_Locale  ,
						a_Scope ,
						a_Registration ,
						a_Identity
					) ;

					t_Registrar->Release () ;
				}

				t_Factory->Release () ;
			}

			t_Service->Release () ;
		}

		wchar_t t_Guid [64] ;

		int t_Status = StringFromGUID2 ( a_Identity , t_Guid , sizeof ( t_Guid ) / sizeof ( wchar_t ) ) ;
		if ( t_Status )
		{
			CServerObject_DecoupledClientRegistration_Element t_Element ;

			WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( ProviderSubSystem_Globals :: GetDecoupledRegistrySection () ) ;

			t_Result = t_Element.Delete ( t_Guid ) ;

			t_StatusCode = WmiHelper :: LeaveCriticalSection ( ProviderSubSystem_Globals :: GetDecoupledRegistrySection () ) ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_ProviderSubsystemRegistrar :: CacheProvider (

	CServerObject_ProviderSubSystem *a_SubSystem ,
	IWbemContext *a_Context ,
	CServerObject_DecoupledClientRegistration_Element &a_Element ,
	IUnknown *a_Unknown 
)
{
	HRESULT t_Result = S_OK ;

	IWbemServices *t_Service = NULL ;
	t_Result = a_SubSystem->GetWmiService ( 

		a_Element.GetScope () ,
		( const BSTR ) a_Element.GetUser () ,
		( const BSTR ) a_Element.GetLocale () ,
		t_Service
	) ;

	if (SUCCEEDED ( t_Result ) )
	{
		_IWmiProviderFactory *t_Factory = NULL ;
		t_Result = a_SubSystem->Create (

			t_Service ,
			0,
			a_Context ,
			a_Element.GetScope () ,
			IID__IWmiProviderFactory  ,
			( void ** ) & t_Factory
		) ;
		
		if ( SUCCEEDED ( t_Result ) ) 
		{
			_IWmiProviderSubsystemRegistrar *t_Registrar = NULL ;

			t_Result = t_Factory->GetDecoupledProvider (

				0 ,
				a_Context ,
				a_Element.GetUser () ,
				a_Element.GetLocale () ,
				a_Element.GetScope () ,
				a_Element.GetProvider () ,
				IID__IWmiProviderSubsystemRegistrar ,
				( void ** ) & t_Registrar
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				GUID t_Identity ;
				t_Result = CLSIDFromString ( a_Element.GetClsid () , & t_Identity ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Registrar->Register (

						0 ,
						a_Context ,
						a_Element.GetUser () ,
						a_Element.GetLocale () ,
						a_Element.GetScope () ,
						a_Element.GetProvider () ,
						a_Element.GetProcessIdentifier () ,
						a_Unknown ,
						t_Identity
					) ;
				}	

				t_Registrar->Release () ;
			}

			t_Factory->Release () ;
		}

		t_Service->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_ProviderSubsystemRegistrar :: Load (

	CServerObject_ProviderSubSystem *a_SubSystem ,
	IWbemContext *a_Context ,
	CServerObject_DecoupledClientRegistration_Element &a_Element
)
{
	HRESULT t_Result = S_OK ;

	BYTE *t_MarshaledProxy = a_Element.GetMarshaledProxy () ;
	DWORD t_MarshaledProxyLength = a_Element.GetMarshaledProxyLength () ;

	if ( t_MarshaledProxy )
	{
		IUnknown *t_Unknown = NULL ;
		t_Result = ProviderSubSystem_Common_Globals :: UnMarshalRegistration ( & t_Unknown , t_MarshaledProxy , t_MarshaledProxyLength ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CacheProvider ( 

				a_SubSystem ,
				a_Context ,
				a_Element ,
				t_Unknown 	
			) ;

			t_Unknown->Release () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_ProviderSubsystemRegistrar :: Load (

	CServerObject_ProviderSubSystem *a_SubSystem ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		CServerObject_DecoupledClientRegistration t_Elements ( m_Allocator ) ;

		WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( ProviderSubSystem_Globals :: GetDecoupledRegistrySection () ) ;

		HRESULT t_TempResult = t_Elements.Load () ;

		t_StatusCode = WmiHelper :: LeaveCriticalSection ( ProviderSubSystem_Globals :: GetDecoupledRegistrySection () ) ;

		if ( SUCCEEDED ( t_TempResult ) )
		{
			WmiQueue < CServerObject_DecoupledClientRegistration_Element , 8 > &t_Queue = t_Elements.GetQueue () ;
			
			CServerObject_DecoupledClientRegistration_Element t_Top ;

			WmiStatusCode t_StatusCode ;
			while ( ( t_StatusCode = t_Queue.Top ( t_Top ) ) == e_StatusCode_Success )
			{
				HRESULT t_TempResult = Load (

					a_SubSystem , 
					a_Context , 
					t_Top
				) ;

				t_StatusCode = t_Queue.DeQueue () ;
			}
		}
		else
		{
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_ProviderSubsystemRegistrar :: SaveToRegistry (

	IUnknown *a_Unknown ,
	BYTE *a_MarshaledProxy ,
	DWORD a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	CServerObject_DecoupledServerRegistration t_Element ( m_Allocator ) ;

	BSTR t_CreationTime = NULL ;

	FILETIME t_CreationFileTime ;
	FILETIME t_ExitFileTime ;
	FILETIME t_KernelFileTime ;
	FILETIME t_UserFileTime ;

	BOOL t_Status = GetProcessTimes (

		  GetCurrentProcess (),
		  & t_CreationFileTime,
		  & t_ExitFileTime,
		  & t_KernelFileTime,
		  & t_UserFileTime
	);

	if ( t_Status ) 
	{
		CWbemDateTime t_Time ;
		t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;
		t_Result = t_Time.GetValue ( & t_CreationTime ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Element.SetProcessIdentifier ( GetCurrentProcessId () ) ;

			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_Element.SetCreationTime ( ( BSTR ) t_CreationTime ) ;
			}

			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_Element.SetMarshaledProxy ( a_MarshaledProxy , a_MarshaledProxyLength ) ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Element.Save () ;
			}

			SysFreeString ( t_CreationTime ) ;
		}
		else
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
	}
	else
	{
		t_Result = WBEM_E_UNEXPECTED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_ProviderSubsystemRegistrar :: Save ()
{
	HRESULT t_Result = S_OK ;

	try
	{
/*
 *	Clear existing stale entries.
 */

		CServerObject_DecoupledClientRegistration t_Elements ( m_Allocator ) ;
		HRESULT t_TempResult = t_Elements.Load () ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			WmiQueue < CServerObject_DecoupledClientRegistration_Element , 8 > &t_Queue = t_Elements.GetQueue () ;
			
			CServerObject_DecoupledClientRegistration_Element t_Top ;

			WmiStatusCode t_StatusCode ;
			while ( ( t_StatusCode = t_Queue.Top ( t_Top ) ) == e_StatusCode_Success )
			{
				t_StatusCode = t_Queue.DeQueue () ;
			}
		}
		else
		{
		}

		BYTE *t_MarshaledProxy = NULL ;
		DWORD t_MarshaledProxyLength = 0 ;

		IUnknown *t_Unknown = NULL ;
		t_Result = this->QueryInterface ( IID_IUnknown, ( void ** ) & t_Unknown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = ProviderSubSystem_Common_Globals :: MarshalRegistration ( 

				t_Unknown ,
				t_MarshaledProxy ,
				t_MarshaledProxyLength
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = SaveToRegistry ( 

					t_Unknown ,
					t_MarshaledProxy ,
					t_MarshaledProxyLength
				) ;

				delete [] t_MarshaledProxy ;
			}

			t_Unknown->Release () ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_ProviderSubsystemRegistrar :: Delete ()
{
	HRESULT t_Result = S_OK ;

	try
	{
		CServerObject_DecoupledServerRegistration t_Element ( m_Allocator ) ;
		t_Result = t_Element.Delete () ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupledAggregator_IWbemProvider :: CDecoupledAggregator_IWbemProvider (

	WmiAllocator &a_Allocator ,
	CWbemGlobal_IWmiProviderController *a_Controller , 
	_IWmiProviderFactory *a_Factory ,
	IWbemServices *a_CoreRepositoryStub ,
	IWbemServices *a_CoreFullStub ,
	const ProviderCacheKey &a_Key ,
	const ULONG &a_Period ,
	IWbemContext *a_InitializationContext ,
	CServerObject_ProviderRegistrationV1 &a_Registration
	
) :	CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	ServiceCacheElement ( 

		a_Controller ,
		a_Key ,
		a_Period 
	) ,
	m_ReferenceCount ( 0 ) , 
	m_Allocator ( a_Allocator ) ,
	m_Registration ( & a_Registration ) ,
	m_ExtendedStatusObject ( NULL ) , 
	m_CoreRepositoryStub ( a_CoreRepositoryStub ) ,
	m_CoreFullStub ( a_CoreFullStub ) ,
	m_Factory ( a_Factory ) ,
	m_User ( NULL ) ,
	m_Locale ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Controller ( NULL ) ,
	m_NamespacePath ( NULL ) ,
	m_Sink ( NULL ) ,
	m_Initialized ( 0 ) ,
	m_InitializeResult ( S_OK ) ,
	m_InitializedEvent ( NULL ) , 
	m_InitializationContext ( a_InitializationContext )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CDecoupledAggregator_IWbemProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	m_Registration->AddRef () ;

	if ( m_Factory ) 
	{
		m_Factory->AddRef () ;
	}

	if ( m_CoreRepositoryStub )
	{
		m_CoreRepositoryStub->AddRef () ;
	}

	if ( m_CoreFullStub )
	{
		m_CoreFullStub->AddRef () ;
	}

	if ( m_InitializationContext )
	{
		m_InitializationContext->AddRef () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupledAggregator_IWbemProvider :: ~CDecoupledAggregator_IWbemProvider ()
{
	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	if ( m_Controller )
	{
		CWbemGlobal_IWbemSyncProvider_Container *t_Container = NULL ;
		WmiStatusCode t_StatusCode = m_Controller->GetContainer ( t_Container ) ;

		m_Controller->Lock () ;

		CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator = t_Container->Begin () ;
		while ( ! t_Iterator.Null () )
		{
			SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;

			t_Container->Delete ( t_Element->GetKey () ) ;

			m_Controller->UnLock () ;

			t_Element->Release () ;

			m_Controller->Lock () ;

			t_Iterator = t_Container->Begin () ;
		}

		m_Controller->UnLock () ;

		m_Controller->UnInitialize () ;

		m_Controller->Release () ;
	}

	if ( m_NamespacePath )
	{
		m_NamespacePath->Release () ;
	}

	if ( m_Factory ) 
	{
		m_Factory->Release () ;
	}

	if ( m_CoreRepositoryStub )
	{
		m_CoreRepositoryStub->Release () ;
	}

	if ( m_CoreFullStub )
	{
		m_CoreFullStub->Release () ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_Namespace )
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Sink )
	{
		m_Sink->AddRef () ;
	}

	if ( m_InitializationContext )
	{
		m_InitializationContext->Release () ;
	}

	if ( m_InitializedEvent )
	{
		CloseHandle ( m_InitializedEvent ) ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	if ( m_ExtendedStatusObject )
	{
		m_ExtendedStatusObject->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CDecoupledAggregator_IWbemProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: Initialize (

	long a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User,
    LPCWSTR a_Locale,
	LPCWSTR a_Namespace ,
	IWbemServices *a_Repository ,
	IWbemServices *a_Service ,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_Controller = new CWbemGlobal_IWbemSyncProviderController ( m_Allocator ) ;
		if ( m_Controller )
		{
			m_Controller->AddRef () ;

			t_StatusCode = m_Controller->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success ) 
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CoCreateInstance (

			CLSID_WbemDefPath ,
			NULL ,
			CLSCTX_INPROC_SERVER ,
			IID_IWbemPath ,
			( void ** )  & m_NamespacePath
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = m_NamespacePath->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Namespace ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_User )
		{
			m_User = SysAllocString ( a_User ) ;
			if ( ! m_User ) 
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( a_Locale )
			{
				m_Locale = SysAllocString ( a_Locale ) ;
				if ( ! m_Locale ) 
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( a_Namespace )
			{
				m_Namespace = SysAllocString ( a_Namespace ) ;
				if ( ! m_Namespace ) 
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_InitializedEvent = CreateEvent ( NULL , TRUE , FALSE , NULL ) ;
		if ( m_InitializedEvent == NULL )
		{
			t_Result = t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_Repository->GetObject ( 

			L"__ExtendedStatus" ,
			0 , 
			a_Context ,
			& m_ExtendedStatusObject ,
			NULL
		) ;
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: SetStatus ( 

	LPWSTR a_Operation ,
	LPWSTR a_Parameters ,
	LPWSTR a_Description ,
	HRESULT a_Result ,
	IWbemObjectSink *a_Sink
)
{
	if ( m_ExtendedStatusObject )
	{
		IWbemClassObject *t_StatusObject ;
		HRESULT t_Result = m_ExtendedStatusObject->SpawnInstance ( 

			0 , 
			& t_StatusObject
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: Set_String ( t_StatusObject , L"Provider" , m_Registration ? m_Registration->GetProviderName () : L"ProviderSubsystem" ) ;

			if ( a_Operation ) 
			{
				ProviderSubSystem_Common_Globals :: Set_String ( t_StatusObject , L"Operation" , a_Operation ) ;
			}

			if ( a_Parameters ) 
			{
				ProviderSubSystem_Common_Globals :: Set_String ( t_StatusObject , L"ParameterInfo" , a_Parameters ) ;
			}

			if ( a_Description ) 
			{
				ProviderSubSystem_Common_Globals :: Set_String ( t_StatusObject , L"Description" , a_Description ) ;
			}

			_IWmiObject *t_FastStatusObject ;
			t_Result = t_StatusObject->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastStatusObject ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				ProviderSubSystem_Common_Globals :: Set_Uint32 ( t_FastStatusObject , L"StatusCode" , a_Result ) ;

				t_FastStatusObject->Release () ;
			}

			if ( SUCCEEDED ( a_Result ) )
			{
				t_Result = a_Sink->SetStatus ( 0 , a_Result , NULL , t_StatusObject ) ;
			}
			else
			{
				t_Result = a_Sink->SetStatus ( 0 , a_Result , L"Provider Subsystem Error Report" , t_StatusObject ) ;
			}

			t_StatusObject->Release () ;
		}
		else
		{
			t_Result = a_Sink->SetStatus ( 0 , a_Result , NULL , NULL ) ;
		}
	}
	else
	{
		HRESULT t_Result = a_Sink->SetStatus ( 0 , a_Result , NULL , NULL ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: IsIndependant ( IWbemContext *a_Context )
{
	BOOL t_DependantCall = FALSE ;
	HRESULT t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_DependantCall == FALSE )
		{
		}
		else
		{
			return S_FALSE ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout )
{
	HRESULT t_Result = WBEM_E_UNEXPECTED ;

	if ( m_Initialized == 0 )
	{
		BOOL t_DependantCall = FALSE ;
		t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_DependantCall == FALSE )
			{
				if ( WaitForSingleObject ( m_InitializedEvent , a_Timeout ) == WAIT_TIMEOUT )
				{
					return WBEM_E_PROVIDER_LOAD_FAILURE ;
				}
			}
			else
			{
				if ( WaitForSingleObject ( m_InitializedEvent , 0 ) == WAIT_TIMEOUT )
				{
					return S_FALSE ;
				}
			}
		}
	}
	else
	{
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: SetInitialized ( HRESULT a_InitializeResult )
{
	m_InitializeResult = a_InitializeResult ;

	InterlockedExchange ( & m_Initialized , 1 ) ;

	if ( m_InitializedEvent )
	{
		SetEvent ( m_InitializedEvent ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CDecoupledAggregator_IWbemProvider :: AddRef ( void )
{
	return ServiceCacheElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CDecoupledAggregator_IWbemProvider :: Release ( void )
{
	return ServiceCacheElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CDecoupledAggregator_IWbemProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}	
	else if ( iid == IID_IWbemEventProvider )
	{
		*iplpv = ( LPVOID ) ( IWbemEventProvider * ) this ;
	}
	else if ( iid == IID_IWbemEventProviderQuerySink )
	{
		*iplpv = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
	}
	else if ( iid == IID_IWbemEventProviderSecurity )
	{
		*iplpv = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
	}
	else if ( iid == IID_IWbemProviderIdentity )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderIdentity * ) this ;
	}
	else if ( iid == IID_IWbemEventConsumerProvider )
	{
		*iplpv = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
	}
	else if ( iid == IID_IWbemEventConsumerProviderEx )
	{
		*iplpv = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
	}
	else if ( iid == IID__IWmiProviderSubsystemRegistrar )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderSubsystemRegistrar * ) this ;		
	}	
	else if ( iid == IID__IWmiProviderInitialize )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderInitialize * ) this ;		
	}	
	else if ( iid == IID_CDecoupledAggregator_IWbemProvider )
	{
		*iplpv = ( LPVOID ) ( CDecoupledAggregator_IWbemProvider * ) this ;
	}	
	else if ( iid == IID__IWmiProviderCache )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderCache * ) this ;
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * )this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class TInterface, const IID *TInterface_Id>
HRESULT GetProviders (

	IWbemContext *a_Context ,
	CWbemGlobal_IWbemSyncProviderController *a_Controller ,
	TInterface **&a_Elements ,
	ULONG &a_ElementCount ,
	ULONG &a_ContainerCount 
) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWbemSyncProvider_Container *t_Container = NULL ;
	WmiStatusCode t_StatusCode = a_Controller->GetContainer ( t_Container ) ;

	a_Controller->Lock () ;

	a_ContainerCount = t_Container->Size () ;

	a_Elements = new TInterface * [ t_Container->Size () ] ;
	if ( a_Elements )
	{
		CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator = t_Container->Begin () ;

		a_ElementCount = 0 ;

		while ( ! t_Iterator.Null () )
		{
			SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;

			a_Elements [ a_ElementCount ] = NULL ;

			_IWmiProviderInitialize *t_Initializer = NULL ;

			t_Result = t_Element->QueryInterface (

				IID__IWmiProviderInitialize	,
				( void ** ) & t_Initializer
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Initializer->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					HRESULT t_Result = t_Element->QueryInterface ( *TInterface_Id , ( void ** ) & a_Elements [ a_ElementCount ] ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						a_ElementCount ++ ;
					}
				}

				t_Initializer->Release () ;
			}

			t_Iterator.Increment () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	a_Controller->UnLock () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class TInterface>
HRESULT ClearProviders (

	TInterface **a_Elements ,
	ULONG a_ElementCount
) 
{
	HRESULT t_Result = S_OK ;

	for ( ULONG t_Index = 0 ; t_Index < a_ElementCount ; t_Index ++ )
	{
		a_Elements [ t_Index ]->Release () ;
	}

	delete [] a_Elements ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider::OpenNamespace ( 

	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemServices **a_NamespaceService, 
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

	Lock () ;

	WmiStatusCode t_StatusCode = Find ( 

		a_Sink ,
		t_Iterator
	) ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		ObjectSinkContainerElement *t_Element = t_Iterator.GetElement () ;

		UnLock () ;

		IObjectSink_CancelOperation *t_ObjectSink = NULL ;
		t_Result = t_Element->QueryInterface ( IID_IObjectSink_CancelOperation , ( void ** ) & t_ObjectSink ) ;
		if ( SUCCEEDED ( t_Result ) )
		{ 
			t_Result = t_ObjectSink->Cancel (

				0
			) ;

			t_ObjectSink->Release () ;
		}

		IWbemShutdown *t_Shutdown = NULL ;
		HRESULT t_TempResult = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = t_Shutdown->Shutdown ( 

				0 , 
				0 , 
				NULL 
			) ;

			t_Shutdown->Release () ;
		}

		t_Element->Release () ;
	}
	else
	{
		UnLock () ;

		t_Result = WBEM_E_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: QueryObjectSink ( 

	long a_Flags,		
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: GetObject ( 
		
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject **a_Object,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

		return WBEM_E_NOT_FOUND ;
	}

	BOOL t_ObjectGot = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices,&IID_IWbemServices> ( a_Context , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			IWbemServices *t_Provider = t_Elements [ t_Index ] ;

			CInterceptor_IWbemWaitingObjectSink *t_GettingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				t_Provider ,
				a_Sink ,
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				*m_Registration
			) ;

			if ( t_GettingSink )
			{
				t_GettingSink->AddRef () ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_GettingSink ,
						t_Iterator
					) ;

					UnLock () ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						t_Result = t_Provider->GetObjectAsync ( 
								
							a_ObjectPath , 
							0 , 
							a_Context,
							t_GettingSink
						) ;

						if ( FAILED ( t_Result ) )
						{
							if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
							{
								AbnormalShutdown ( t_Elements [ t_Index ] ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_GettingSink->Wait ( INFINITE ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_GettingSink->GetResult () ;
								if ( SUCCEEDED ( t_Result ) )
								{
									t_ObjectGot = TRUE ;
								}
								else
								{
									if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
									{
										t_Result = S_OK ;
									}
								}
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					WmiQueue <IWbemClassObject *,8> &t_Queue = t_GettingSink->GetQueue () ;

					IWbemClassObject *t_Object = NULL ;
					while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
					{
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = a_Sink->Indicate ( 1 , & t_Object ) ;
						}

						t_Object->Release () ;
						t_StatusCode = t_Queue.DeQueue () ;
					}
				}

				t_GettingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_ObjectGot == FALSE )
		{
			if ( t_ElementsCount )
			{ 
				t_Result = WBEM_E_NOT_FOUND ;

				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
			else
			{
				SetStatus ( L"GetObjectAsync" , NULL , L"No Decoupled Providers Attached" , WBEM_E_NOT_FOUND , a_Sink ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: PutClass ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: PutClassAsync ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	BOOL t_ClassPut = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices,&IID_IWbemServices> ( a_Context , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			IWbemServices *t_Provider = t_Elements [ t_Index ] ;

			CInterceptor_IWbemWaitingObjectSink *t_ClassPuttingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				t_Provider ,
				a_Sink ,
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				*m_Registration
			) ;

			if ( t_ClassPuttingSink )
			{
				t_ClassPuttingSink->AddRef () ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_ClassPuttingSink ,
						t_Iterator
					) ;

					UnLock () ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						t_Result = t_Provider->PutClassAsync ( 
								
							a_Object , 
							a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
							a_Context,
							t_ClassPuttingSink
						) ;

						if ( FAILED ( t_Result ) )
						{
							if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
							{
								AbnormalShutdown ( t_Elements [ t_Index ] ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_ClassPuttingSink->Wait ( INFINITE ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( SUCCEEDED ( t_ClassPuttingSink->GetResult () ) )
								{
									t_ClassPut = TRUE ;
								}
							}
							else
							{
								if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
								{
									t_Result = S_OK ;
								}
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					WmiQueue <IWbemClassObject *,8> &t_Queue = t_ClassPuttingSink->GetQueue () ;

					IWbemClassObject *t_Object = NULL ;
					while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
					{
						t_Object->Release () ;
						t_StatusCode = t_Queue.DeQueue () ;
					}
				}

				t_ClassPuttingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_ClassPut == FALSE )
		{
			if ( t_ElementsCount )
			{ 
				t_Result = WBEM_E_NOT_FOUND ;

				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
			else
			{
				SetStatus ( L"PutClassAsync" , NULL , L"No Decoupled Providers Attached" , WBEM_E_NOT_FOUND , a_Sink ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: DeleteClass ( 
		
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: DeleteClassAsync ( 
		
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	BOOL t_ClassDeleted = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices,&IID_IWbemServices> ( a_Context , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			IWbemServices *t_Provider = t_Elements [ t_Index ] ;

			CInterceptor_IWbemWaitingObjectSink *t_ClassDeletingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				t_Provider ,
				a_Sink ,
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				*m_Registration
			) ;

			if ( t_ClassDeletingSink )
			{
				t_ClassDeletingSink->AddRef () ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_ClassDeletingSink ,
						t_Iterator
					) ;

					UnLock () ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						t_Result = t_Provider->DeleteClassAsync ( 
								
							a_Class , 
							a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
							a_Context,
							t_ClassDeletingSink
						) ;

						if ( FAILED ( t_Result ) )
						{
							if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
							{
								AbnormalShutdown ( t_Elements [ t_Index ] ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_ClassDeletingSink->Wait ( INFINITE ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( SUCCEEDED ( t_ClassDeletingSink->GetResult () ) )
								{
									t_ClassDeleted = TRUE ;
								}
							}
							else
							{
								if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
								{
									t_Result = S_OK ;
								}
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					WmiQueue <IWbemClassObject *,8> &t_Queue = t_ClassDeletingSink->GetQueue () ;

					IWbemClassObject *t_Object = NULL ;
					while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
					{
						t_Object->Release () ;
						t_StatusCode = t_Queue.DeQueue () ;
					}
				}

				t_ClassDeletingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_ClassDeleted == FALSE )
		{
			if ( t_ElementsCount )
			{ 
				t_Result = WBEM_E_NOT_FOUND ;

				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
			else
			{
				SetStatus ( L"DeleteClassAsync" , NULL , L"No Decoupled Providers Attached" , WBEM_E_NOT_FOUND , a_Sink ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: CreateClassEnum ( 

	const BSTR a_Superclass, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CDecoupledAggregator_IWbemProvider :: CreateClassEnumAsync (

	const BSTR a_Superclass , 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = S_OK ;

	CInterceptor_DecoupledIWbemCombiningObjectSink *t_CombiningSink = new CInterceptor_DecoupledIWbemCombiningObjectSink (

		m_Allocator ,
		a_Sink , 
		( CWbemGlobal_IWmiObjectSinkController * ) this
	) ;

	if ( t_CombiningSink )
	{
		t_CombiningSink->AddRef () ;

		t_CombiningSink->Suspend () ;

		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Insert ( 

			*t_CombiningSink ,
			t_Iterator
		) ;

		UnLock () ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			IWbemServices **t_Elements = NULL ;
			ULONG t_ElementsCount = 0 ;
			ULONG t_ContainerCount = 0 ;

			t_Result = GetProviders <IWbemServices,&IID_IWbemServices> ( a_Context , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_ProviderFound = FALSE ;

				for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
				{
					IWbemServices *t_Provider = t_Elements [ t_Index ] ; 

					CInterceptor_DecoupledIWbemObjectSink *t_Sink = new CInterceptor_DecoupledIWbemObjectSink (

						t_Provider ,
						t_CombiningSink , 
						( IWbemObjectSink * ) t_CombiningSink , 
						( CWbemGlobal_IWmiObjectSinkController * ) t_CombiningSink
					) ;

					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							t_Result = t_CombiningSink->EnQueue ( t_Sink ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->CreateClassEnumAsync ( 
										
									a_Superclass , 
									a_Flags, 
									a_Context,
									t_Sink
								) ;

								if ( FAILED ( t_Result ) )
								{
									if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
									{
										AbnormalShutdown ( t_Elements [ t_Index ] ) ;
									}
								}

								if ( SUCCEEDED ( t_Result ) )
								{
								}
								else
								{
									if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
									{
										t_Result = S_OK ;
									}
								}
							}
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
			}

			if ( SUCCEEDED ( t_Result ) && t_ElementsCount )
			{
				t_CombiningSink->Resume () ;

				t_Result = t_CombiningSink->Wait ( INFINITE ) ;
			}
			else
			{
				SetStatus ( L"CreateClassEnumAsync" , NULL , L"No Decoupled Providers Attached" , WBEM_S_SOURCE_NOT_AVAILABLE , a_Sink ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		t_CombiningSink->Release () ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: PutInstance (

    IWbemClassObject *a_Instance,
    long a_Flags,
    IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags ,
    IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	BOOL t_InstancePut = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices,&IID_IWbemServices> ( a_Context , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			IWbemServices *t_Provider = t_Elements [ t_Index ] ;

			CInterceptor_IWbemWaitingObjectSink *t_InstancePuttingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				t_Provider ,
				a_Sink ,
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				*m_Registration
			) ;

			if ( t_InstancePuttingSink )
			{
				t_InstancePuttingSink->AddRef () ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_InstancePuttingSink ,
						t_Iterator
					) ;

					UnLock () ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						t_Result = t_Provider->PutInstanceAsync ( 
								
							a_Instance , 
							a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
							a_Context,
							t_InstancePuttingSink
						) ;

						if ( FAILED ( t_Result ) )
						{
							if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
							{
								AbnormalShutdown ( t_Elements [ t_Index ] ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_InstancePuttingSink->Wait ( INFINITE ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( SUCCEEDED ( t_InstancePuttingSink->GetResult () ) )
								{
									t_InstancePut = TRUE ;
								}
							}
							else
							{
								if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
								{
									t_Result = S_OK ;
								}
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					WmiQueue <IWbemClassObject *,8> &t_Queue = t_InstancePuttingSink->GetQueue () ;

					IWbemClassObject *t_Object = NULL ;
					while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
					{
						t_Object->Release () ;
						t_StatusCode = t_Queue.DeQueue () ;
					}
				}

				t_InstancePuttingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_InstancePut == FALSE )
		{
			if ( t_ElementsCount )
			{ 
				t_Result = WBEM_E_NOT_FOUND ;

				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
			else
			{
				SetStatus ( L"PutInstanceAsync" , NULL , L"No Decoupled Providers Attached" , WBEM_E_NOT_FOUND , a_Sink ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: DeleteInstance ( 

	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CDecoupledAggregator_IWbemProvider :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	BOOL t_InstanceDeleted = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices,&IID_IWbemServices> ( a_Context , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			IWbemServices *t_Provider = t_Elements [ t_Index ] ;

			CInterceptor_IWbemWaitingObjectSink *t_InstanceDeletingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				t_Provider ,
				a_Sink ,
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				*m_Registration
			) ;

			if ( t_InstanceDeletingSink )
			{
				t_InstanceDeletingSink->AddRef () ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_InstanceDeletingSink ,
						t_Iterator
					) ;

					UnLock () ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						t_Result = t_Provider->DeleteInstanceAsync ( 
								
							a_ObjectPath , 
							a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
							a_Context,
							t_InstanceDeletingSink
						) ;

						if ( FAILED ( t_Result ) )
						{
							if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
							{
								AbnormalShutdown ( t_Elements [ t_Index ] ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_InstanceDeletingSink->Wait ( INFINITE ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( SUCCEEDED ( t_InstanceDeletingSink->GetResult () ) )
								{
									t_InstanceDeleted = TRUE ;
								}
							}
							else
							{
								if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
								{
									t_Result = S_OK ;
								}
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					WmiQueue <IWbemClassObject *,8> &t_Queue = t_InstanceDeletingSink->GetQueue () ;

					IWbemClassObject *t_Object = NULL ;
					while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
					{
						t_Object->Release () ;
						t_StatusCode = t_Queue.DeQueue () ;
					}
				}

				t_InstanceDeletingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_InstanceDeleted == FALSE )
		{
			if ( t_ElementsCount )
			{ 
				t_Result = WBEM_E_NOT_FOUND ;

				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
			else
			{
				SetStatus ( L"DeleteInstanceAsync" , NULL , L"No Decoupled Providers Attached" , WBEM_E_NOT_FOUND , a_Sink ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = S_OK ;

	CInterceptor_DecoupledIWbemCombiningObjectSink *t_CombiningSink = new CInterceptor_DecoupledIWbemCombiningObjectSink (

		m_Allocator ,
		a_Sink , 
		( CWbemGlobal_IWmiObjectSinkController * ) this
	) ;

	if ( t_CombiningSink )
	{
		t_CombiningSink->AddRef () ;

		t_CombiningSink->Suspend () ;

		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Insert ( 

			*t_CombiningSink ,
			t_Iterator
		) ;

		UnLock () ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			IWbemServices **t_Elements = NULL ;
			ULONG t_ElementsCount = 0 ;
			ULONG t_ContainerCount = 0 ;

			t_Result = GetProviders <IWbemServices,&IID_IWbemServices> ( a_Context , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_ProviderFound = FALSE ;

				for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
				{
					IWbemServices *t_Provider = t_Elements [ t_Index ] ; 

					CInterceptor_DecoupledIWbemObjectSink *t_Sink = new CInterceptor_DecoupledIWbemObjectSink (

						t_Provider ,
						t_CombiningSink , 
						( IWbemObjectSink * ) t_CombiningSink , 
						( CWbemGlobal_IWmiObjectSinkController * ) t_CombiningSink
					) ;

					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							t_Result = t_CombiningSink->EnQueue ( t_Sink ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->CreateInstanceEnumAsync ( 
										
									a_Class, 
									a_Flags, 
									a_Context,
									t_Sink
								) ;

								if ( FAILED ( t_Result ) )
								{
									if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
									{
										AbnormalShutdown ( t_Elements [ t_Index ] ) ;
									}
								}

								if ( SUCCEEDED ( t_Result ) )
								{
								}
								else
								{
									if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
									{
										t_Result = S_OK ;
									}
								}
							}
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
			}

			if ( SUCCEEDED ( t_Result ) && t_ElementsCount )
			{
				t_CombiningSink->Resume () ;

				t_Result = t_CombiningSink->Wait ( INFINITE ) ;
			}
			else
			{
				SetStatus ( L"CreateInstanceEnumAsync" , NULL , L"No Decoupled Providers Attached" , WBEM_S_SOURCE_NOT_AVAILABLE , a_Sink ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		t_CombiningSink->Release () ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = S_OK ;

	CInterceptor_DecoupledIWbemCombiningObjectSink *t_CombiningSink = new CInterceptor_DecoupledIWbemCombiningObjectSink (

		m_Allocator ,
		a_Sink , 
		( CWbemGlobal_IWmiObjectSinkController * ) this
	) ;

	if ( t_CombiningSink )
	{
		t_CombiningSink->AddRef () ;

		t_CombiningSink->Suspend () ;

		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Insert ( 

			*t_CombiningSink ,
			t_Iterator
		) ;

		UnLock () ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			IWbemServices **t_Elements = NULL ;
			ULONG t_ElementsCount = 0 ;
			ULONG t_ContainerCount = 0 ;

			t_Result = GetProviders <IWbemServices,&IID_IWbemServices> ( a_Context , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_ProviderFound = FALSE ;

				for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
				{
					IWbemServices *t_Provider = t_Elements [ t_Index ] ; 

					CInterceptor_DecoupledIWbemObjectSink *t_Sink = new CInterceptor_DecoupledIWbemObjectSink (

						t_Provider ,
						t_CombiningSink , 
						( IWbemObjectSink * ) t_CombiningSink , 
						( CWbemGlobal_IWmiObjectSinkController * ) t_CombiningSink
					) ;

					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							t_Result = t_CombiningSink->EnQueue ( t_Sink ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->ExecQueryAsync ( 
										
									a_QueryLanguage, 
									a_Query, 
									a_Flags, 
									a_Context,
									t_Sink
								) ;

								if ( FAILED ( t_Result ) )
								{
									if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
									{
										AbnormalShutdown ( t_Elements [ t_Index ] ) ;
									}
								}

								if ( SUCCEEDED ( t_Result ) )
								{
								}
								else
								{
									if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
									{
										t_Result = S_OK ;
									}
								}
							}
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
			}

			if ( SUCCEEDED ( t_Result ) && t_ElementsCount )
			{
				t_CombiningSink->Resume () ;

				t_Result = t_CombiningSink->Wait ( INFINITE ) ;
			}
			else
			{
				SetStatus ( L"ExecQueryAsync" , NULL , L"No Decoupled Providers Attached" , WBEM_S_SOURCE_NOT_AVAILABLE , a_Sink ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		t_CombiningSink->Release () ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CDecoupledAggregator_IWbemProvider :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CDecoupledAggregator_IWbemProvider :: ExecMethod ( 

	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

		return WBEM_E_NOT_FOUND ;
	}

	BOOL t_MethodCalled = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices,&IID_IWbemServices> ( a_Context , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) &&  !t_MethodCalled ; t_Index ++ )
		{
			IWbemServices *t_Provider = t_Elements [ t_Index ] ;

			CInterceptor_IWbemWaitingObjectSink *t_MethodSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				t_Provider ,
				a_Sink ,
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				*m_Registration
			) ;

			if ( t_MethodSink )
			{
				t_MethodSink->AddRef () ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_MethodSink ,
						t_Iterator
					) ;

					UnLock () ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						t_Result = t_Provider->ExecMethodAsync ( 
								
							a_ObjectPath,
							a_MethodName,
							a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
							a_Context,
							a_InParams,
							t_MethodSink
						) ;

						if ( FAILED ( t_Result ) )
						{
							if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
							{
								AbnormalShutdown ( t_Elements [ t_Index ] ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_MethodSink->Wait ( INFINITE ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( SUCCEEDED ( t_MethodSink->GetResult () ) )
								{
									t_MethodCalled = TRUE ;
								}
							}
							else
							{
								if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
								{
									t_Result = S_OK ;
								}
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					WmiQueue <IWbemClassObject *,8> &t_Queue = t_MethodSink->GetQueue () ;

					IWbemClassObject *t_Object = NULL ;
					while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
					{
                                            if (SUCCEEDED(t_Result))
                                            {
                                                a_Sink->Indicate ( 1 , & t_Object ) ;
                                            }

						t_Object->Release () ;
						t_StatusCode = t_Queue.DeQueue () ;
					}
				}

				t_MethodSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_MethodCalled == FALSE )
		{
			if ( t_ElementsCount )
			{ 
				t_Result = WBEM_E_NOT_FOUND ;

				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
			else
			{
				SetStatus ( L"ExecMethodAsync" , NULL , L"No Decoupled Providers Attached" , WBEM_E_NOT_FOUND , a_Sink ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	return t_Result ;
}

 /******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider ::  ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
#ifdef WMI_PRIVATE_DBG
#ifdef DBG
            CTestNullTokenOnScope Test(__LINE__,__FILE__);
#endif
#endif

	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	if ( InterlockedCompareExchangePointer ( ( void ** ) & m_Sink , a_Sink , NULL ) == NULL )
	{
		m_Sink->AddRef () ;
	}

	IWbemEventProvider **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	t_Result = GetProviders <IWbemEventProvider,&IID_IWbemEventProvider> ( NULL , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->ProvideEvents (

 				a_Sink,
				a_Flags
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
				{
					AbnormalShutdown ( t_Elements [ t_Index ] ) ;
				}
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventProvider> ( t_Elements , t_ElementsCount ) ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
#ifdef WMI_PRIVATE_DBG
#ifdef DBG
            CTestNullTokenOnScope Test(__LINE__,__FILE__);
#endif
#endif

	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	IWbemEventProviderQuerySink **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	t_Result = GetProviders <IWbemEventProviderQuerySink,&IID_IWbemEventProviderQuerySink> ( NULL , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->NewQuery (

 				a_Id,
				a_QueryLanguage ,
				a_Query
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
				{
					AbnormalShutdown ( t_Elements [ t_Index ] ) ;
				}
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventProviderQuerySink> ( t_Elements , t_ElementsCount ) ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider ::CancelQuery (

	unsigned long a_Id
)
{
#ifdef WMI_PRIVATE_DBG
#ifdef DBG
            CTestNullTokenOnScope Test(__LINE__,__FILE__);
#endif
#endif

	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	IWbemEventProviderQuerySink **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	t_Result = GetProviders <IWbemEventProviderQuerySink,&IID_IWbemEventProviderQuerySink> ( NULL , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->CancelQuery (

 				a_Id
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
				{
					AbnormalShutdown ( t_Elements [ t_Index ] ) ;
				}
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventProviderQuerySink> ( t_Elements , t_ElementsCount ) ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
#ifdef WMI_PRIVATE_DBG
#ifdef DBG
            CTestNullTokenOnScope Test(__LINE__,__FILE__);
#endif
#endif

	HRESULT t_AggregatedResult = S_OK ;

	IWbemEventProviderSecurity **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemEventProviderSecurity,&IID_IWbemEventProviderSecurity> ( NULL , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->AccessCheck (

 				a_QueryLanguage,
				a_Query ,
				a_SidLength ,
				a_Sid
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Result != S_OK )
				{
					t_AggregatedResult = t_Result ;
				}
			}
			else
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
				{
					AbnormalShutdown ( t_Elements [ t_Index ] ) ;
				}
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventProviderSecurity> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{		
		if ( t_ContainerCount )
		{
			if ( t_ElementsCount != t_ContainerCount )
			{
				t_AggregatedResult = WBEM_S_SUBJECT_TO_SDS ;
			}
		}

		t_Result = t_AggregatedResult ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider ::SetRegistrationObject (

	long a_Flags ,
	IWbemClassObject *a_ProviderRegistration
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	IWbemProviderIdentity **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	t_Result = GetProviders <IWbemProviderIdentity,&IID_IWbemProviderIdentity> ( NULL , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->SetRegistrationObject (

				a_Flags ,
				a_ProviderRegistration
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
				{
					AbnormalShutdown ( t_Elements [ t_Index ] ) ;
				}
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemProviderIdentity> ( t_Elements , t_ElementsCount ) ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	IWbemEventConsumerProvider **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	t_Result = GetProviders <IWbemEventConsumerProvider,&IID_IWbemEventConsumerProvider> ( NULL , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->FindConsumer (

 				a_LogicalConsumer,
				a_Consumer
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
				{
					AbnormalShutdown ( t_Elements [ t_Index ] ) ;
				}
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventConsumerProvider> ( t_Elements , t_ElementsCount ) ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	IWbemEventConsumerProviderEx **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	t_Result = GetProviders <IWbemEventConsumerProviderEx,&IID_IWbemEventConsumerProviderEx> ( NULL , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->ValidateSubscription (

 				a_LogicalConsumer
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
				{
					AbnormalShutdown ( t_Elements [ t_Index ] ) ;
				}
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventConsumerProviderEx> ( t_Elements , t_ElementsCount ) ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: AbnormalShutdown ( IUnknown *t_Element )
{
	SyncProviderContainerElement *t_ContainerElement = NULL ;
	HRESULT t_Result = t_Element->QueryInterface ( IID_CacheElement , ( void ** ) & t_ContainerElement ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		m_Controller->Lock () ;

		GUID t_Identity = t_ContainerElement->GetKey () ;
		WmiStatusCode t_StatusCode = m_Controller->Delete ( t_Identity ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			m_Controller->UnLock () ;

			t_Element->Release () ;
		}
		else
		{
			m_Controller->UnLock () ;
		}

		t_ContainerElement->Release () ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: InitializeProvider ( 

	IUnknown *a_Unknown ,
	IWbemServices *a_Stub ,
	wchar_t *a_NamespacePath ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	CServerObject_ProviderRegistrationV1 &a_Registration
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Registration.GetEventProviderRegistration ().Supported () )
	{
		IWbemProviderIdentity *t_ProviderIdentity = NULL ;
		t_Result = a_Unknown->QueryInterface ( IID_IWbemProviderIdentity , ( void ** ) & t_ProviderIdentity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_ProviderIdentity->SetRegistrationObject (

				0 ,
				a_Registration.GetIdentity () 
			) ;

			t_ProviderIdentity->Release () ;
		}
	}

	IWbemProviderInit *t_ProviderInit = NULL ;
	t_Result = a_Unknown->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & t_ProviderInit ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink () ; 
		if ( t_ProviderInitSink )
		{
			t_ProviderInitSink->AddRef () ;

			t_Result = t_ProviderInitSink->SinkInitialize ( a_Registration.GetComRegistration().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
				if ( t_Sink )
				{
					t_Sink->AddRef () ;

					t_Result = t_ProviderInit->Initialize (

						a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
						0 ,
						( const BSTR ) a_NamespacePath ,
						a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
						a_Stub ,
						a_Context ,
						t_Sink    
					) ;

					t_Sink->Release () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_ProviderInitSink->Wait () ;
					t_Result = t_ProviderInitSink->GetResult () ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					WmiSetAndCommitObject (

						ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationEvent ] , 
						WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						a_NamespacePath,
						a_Registration.GetProviderName () ,
						a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
						a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
						NULL
					) ;
				}
				else
				{
					WmiSetAndCommitObject (

						ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationFailureEvent ] , 
						WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						a_NamespacePath,
						a_Registration.GetProviderName () ,
						a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
						a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
						NULL ,
						t_Result 
					) ;
				}
			}

			t_ProviderInitSink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		t_ProviderInit->Release () ;
	}
	else
	{
		t_Result = WBEM_E_ACCESS_DENIED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: CreateSyncProvider ( 

	IUnknown *a_ServerSideProvider ,
	IWbemServices *a_Stub ,
	wchar_t *a_NamespacePath ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	GUID a_Identity ,
	CInterceptor_IWbemDecoupledProvider *&a_Interceptor 
)
{
	HRESULT t_Result = S_OK ;

	CInterceptor_IWbemDecoupledProvider *t_Interceptor = new CInterceptor_IWbemDecoupledProvider (

		m_Allocator , 
		a_ServerSideProvider ,
		a_Stub ,
		m_Controller , 
		a_Context ,
		a_Registration ,
		a_Identity
	) ;

	if ( t_Interceptor ) 
	{
/*
 *	One for the cache
 */
		t_Interceptor->AddRef () ;

		_IWmiProviderInitialize *t_InterceptorInit = NULL ;

		t_Result = t_Interceptor->QueryInterface ( IID__IWmiProviderInitialize , ( void ** ) & t_InterceptorInit ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
			if ( t_ProviderInitSink )
			{
				t_ProviderInitSink->AddRef () ;

				t_Result = t_ProviderInitSink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						t_Result = t_InterceptorInit->Initialize (

							0 ,
							a_Context ,
							NULL ,
							a_Registration.GetComRegistration ().PerUserInitialization () ? ( BSTR ) a_User : NULL ,
							a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( BSTR ) a_Locale : NULL  ,
							a_NamespacePath ,
							NULL ,
							NULL ,
							t_Sink    
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_ProviderInitSink->Wait () ;
							t_Result = t_ProviderInitSink->GetResult () ;
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				t_ProviderInitSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			t_InterceptorInit->Release () ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Interceptor->AddRef () ;

			CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator ;

			WmiStatusCode t_StatusCode = m_Controller->Insert ( 

				*t_Interceptor ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			m_Controller->UnLock () ;
		}
		else
		{
			m_Controller->UnLock () ;
		}

		t_Interceptor->SetInitialized ( t_Result ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			a_Interceptor = t_Interceptor ;
		}
		else
		{
			t_Interceptor->Release () ;
		}
	}
	else
	{
		m_Controller->UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: Register (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	DWORD a_ProcessIdentifier ,
	IUnknown *a_Unknown ,
	GUID a_Identity
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		m_Controller->Lock () ;

		CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator ;

		WmiStatusCode t_StatusCode = m_Controller->Find ( a_Identity , t_Iterator ) ;
		if ( t_StatusCode != e_StatusCode_Success )
		{
			CInterceptor_IWbemServices_Interceptor *t_Stub = new CInterceptor_IWbemServices_Interceptor ( m_Allocator , m_CoreFullStub ) ;
			if ( t_Stub )
			{
				t_Stub->AddRef () ;

				CInterceptor_IWbemDecoupledProvider *t_Interceptor = NULL ;

				t_Result = CreateSyncProvider ( 

					a_Unknown ,
					t_Stub ,
					( BSTR ) a_Scope ,
					0 ,
					a_Context ,
					a_User ,
					a_Locale ,
					NULL ,
					*m_Registration ,
					a_Identity ,
					t_Interceptor
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					IUnknown *t_Unknown = NULL ;
					t_Result = t_Interceptor->QueryInterface ( IID_IUnknown , ( void ** ) & t_Unknown ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = InitializeProvider ( 

							t_Unknown ,
							t_Stub ,
							( BSTR ) a_Scope ,
							a_Flags ,
							a_Context ,
							a_User ,
							a_Locale ,
							NULL ,
							*m_Registration
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( InterlockedCompareExchangePointer ( ( void ** ) & m_Sink , NULL , NULL ) )
							{
								IWbemEventProvider *t_Provider = NULL ;

								t_Result = t_Unknown->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & t_Provider ) ;
								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_Provider->ProvideEvents ( m_Sink , 0 ) ;

									t_Provider->Release () ;
								}

								m_Sink->SetStatus ( 

									WBEM_STATUS_REQUIREMENTS, 
									WBEM_REQUIREMENTS_RECHECK_SUBSCRIPTIONS, 
									NULL, 
									NULL
								) ;
							}
						}

						t_Unknown->Release () ;
					}

					t_Interceptor->Release () ;
				}

				t_Stub->Release () ;
			}
			else
			{
				m_Controller->UnLock () ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;

			m_Controller->UnLock () ;

			t_Element->Release () ;

			t_Result = S_OK ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: UnRegister (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	GUID a_Identity
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator ;

		IWbemShutdown *t_Shutdown = NULL ;

		m_Controller->Lock () ;

		WmiStatusCode t_StatusCode = m_Controller->Find ( a_Identity , t_Iterator ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;			

			t_Result = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;

			m_Controller->Delete ( a_Identity ) ;

			m_Controller->UnLock () ;

			if ( SUCCEEDED ( t_Result ) && t_Shutdown )
			{
				t_Result = t_Shutdown->Shutdown ( 
		
					0 , 
					0 , 
					NULL 
				) ;

				t_Shutdown->Release () ;
			}

/*
 *	One for the find.
 */

			t_Element->Release () ;

/*
 *	Removed reference due the cache.
 */

			t_Element->Release () ;
		}
		else
		{
			m_Controller->UnLock () ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: Expel (

	long a_Flags ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProviderController *t_Controller = ServiceCacheElement :: GetController () ;
	if ( t_Controller )
	{
		t_Controller->Shutdown ( ServiceCacheElement :: GetKey () ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider  :: ForceReload ()
{
	HRESULT t_Result = ProviderSubSystem_Globals :: ForwardReload ( 

		_IWMIPROVSSSINK_FLAGS_RELOAD , 
		NULL ,
		m_Namespace ,
		ServiceCacheElement :: GetKey ().m_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	if ( m_Controller )
	{
		CWbemGlobal_IWbemSyncProvider_Container *t_Container = NULL ;
		
		m_Controller->GetContainer ( t_Container ) ;

		Lock () ;

		if ( t_Container->Size () )
		{
			IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Container->Size () ] ;
			if ( t_ShutdownElements )
			{
				CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator = t_Container->Begin ();

				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ShutdownElements [ t_Index ] ) 
					{
						t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;

						t_ShutdownElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ShutdownElements ;
			}
			else
			{
				UnLock () ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			UnLock () ;
		}

		m_Controller->Shutdown () ;
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provdwsv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"

#include <wbemint.h>
#include <stdio.h>
#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvSubs.h"
#include "ProvFact.h"
#include "ProvObSk.h"
#include "ProvInSk.h"
#include "ProvWsv.h"
#include "ProvCache.h"

#include "arrtempl.h"

#include "Guids.h"
#include <cominit.h>
#include <scopecheck.h>


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CDecoupled_IWbemUnboundObjectSink :: CDecoupled_IWbemUnboundObjectSink (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) :	VoidPointerContainerElement (

		a_Controller ,
		this 
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Controller ( NULL ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_Internal_IWbemUnboundObjectSink ( NULL ) ,
	m_Registration ( & a_Registration ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_UnBound_Size , MAX_PROXIES ) ,
	m_ProcessIdentifier ( 0 ) ,
	m_InitializeResult ( S_OK ) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CDecoupled_IWbemUnboundObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
	
	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	m_InitializeResult = a_Controller->QueryInterface ( IID__IWmiProviderAbnormalShutdown , ( void ** ) & m_Controller ) ;
	if ( SUCCEEDED ( m_InitializeResult ) )
	{
		if ( a_ServerSideProvider ) 
		{
			m_Unknown = a_ServerSideProvider ;
			m_Unknown->AddRef () ;

			m_InitializeResult = a_ServerSideProvider->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
			if ( SUCCEEDED ( m_InitializeResult ) )
			{
				m_InitializeResult  = a_ServerSideProvider->QueryInterface ( IID_Internal_IWbemUnboundObjectSink , ( void ** ) & m_Provider_Internal_IWbemUnboundObjectSink ) ;
			}
		}
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_IWbemUnboundObjectSink :: ~CDecoupled_IWbemUnboundObjectSink ()
{
	if ( m_Controller )
	{
		m_Controller->Release () ;
	}

	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Provider_Internal_IWbemUnboundObjectSink )
	{
		m_Provider_Internal_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CDecoupled_IWbemUnboundObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: Initialize ()
{
	if ( SUCCEEDED ( m_InitializeResult ) )
	{
		WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			m_InitializeResult = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( m_InitializeResult ) )
	{
		_IWmiProviderSite *t_Site = NULL ;
		m_InitializeResult = m_Unknown->QueryInterface ( IID__IWmiProviderSite , ( void ** ) & t_Site ) ;
		if ( SUCCEEDED ( m_InitializeResult ) )
		{
			m_InitializeResult = t_Site->GetSite ( & m_ProcessIdentifier ) ;
			t_Site->Release () ;
		}
	}

	return m_InitializeResult ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CDecoupled_IWbemUnboundObjectSink :: AddRef ()
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CDecoupled_IWbemUnboundObjectSink :: Release ()
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CDecoupled_IWbemUnboundObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: Begin_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	DWORD t_AuthenticationLevel = 0 ;

	t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating , & t_AuthenticationLevel ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_ProcessIdentifier )
		{
			t_Result = CoImpersonateClient () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				CoRevertToSelf () ;

				if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
					
						m_ProxyContainer , 
						a_ProxyIndex , 
						a_InterfaceIdentifier , 
						a_ServerInterface , 
						a_Proxy , 
						a_Revert
					) ;
				}
				else
				{
					WORD t_AceSize = 0 ;
					ACCESS_ALLOWED_ACE *t_Ace = NULL ;

					t_Result = ProviderSubSystem_Common_Globals :: GetAceWithProcessTokenUser ( 
					
						a_ProcessIdentifier ,
						t_AceSize ,
						t_Ace 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
						
							m_ProxyContainer , 
							a_InternalProxyIndex , 
							a_InterfaceIdentifier , 
							a_InternalServerInterface , 
							a_Proxy , 
							a_Revert , 
							a_ProcessIdentifier , 
							a_IdentifyToken ,
							t_Ace ,
							t_AceSize
						) ;

						delete [] ( BYTE * ) t_Ace ;
					}
				}
			}
		}
		else
		{
			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
			
				m_ProxyContainer , 
				a_ProxyIndex , 
				a_InterfaceIdentifier , 
				a_ServerInterface , 
				a_Proxy , 
				a_Revert
			) ;
		}

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = a_ServerInterface ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IUnknown * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel ;

				if ( m_Registration->GetComRegistration ().GetDecoupledImpersonationRestriction () )
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				else
				{
					t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;
				}

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_DEFAULT, 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( a_Context )
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;
						t_Variant.lVal = t_AuthenticationLevel ;
						t_Variant.vt = VT_I4 ;

						
						t_Result = a_Context->SetValue ( L"__WBEM_CLIENT_AUTHENTICATION_LEVEL" , 0, & t_Variant ) ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					if ( a_IdentifyToken )
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 

							m_ProxyContainer , 
							a_InternalProxyIndex , 
							a_Proxy , 
							a_Revert ,
							a_ProcessIdentifier , 
							a_IdentifyToken 
						) ;
					}
					else
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

							m_ProxyContainer , 
							a_ProxyIndex , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: End_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 

				m_ProxyContainer , 
				a_InternalProxyIndex , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier ,
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				a_ProxyIndex , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemUnboundObjectSink ;
		REFIID t_InterfaceIdentifier = IID_IWbemUnboundObjectSink ;
		DWORD t_ProxyIndex = ProxyIndex_UnBound_IWbemUnboundObjectSink ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemUnboundObjectSink ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemUnboundObjectSink ;
		DWORD t_InternalProxyIndex = ProxyIndex_UnBound_Internal_IWbemUnboundObjectSink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = m_ProcessIdentifier ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemUnboundObjectSink * ) t_Interface )->Internal_IndicateToConsumer (

					t_InternalContext ,
					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else
			{

				t_Result = ( ( IWbemUnboundObjectSink * ) t_Interface )->IndicateToConsumer (

					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				if ( m_Controller )
				{
					m_Controller->AbnormalShutdown () ;
				}
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemDecoupledProvider :: CInterceptor_IWbemDecoupledProvider (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	IWbemServices *a_CoreStub ,
	CWbemGlobal_IWbemSyncProviderController *a_Controller ,
	IWbemContext *a_InitializationContext ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	GUID &a_Guid 

) :	CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	SyncProviderContainerElement (

		a_Controller ,
		a_Guid
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemServices ( NULL ) ,
	m_Provider_IWbemPropertyProvider ( NULL ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_IWbemProviderInit ( NULL ) ,
	m_Provider_IWbemProviderIdentity ( NULL ) ,
	m_Provider_Internal_IWbemServices ( NULL ) ,
	m_Provider_Internal_IWbemPropertyProvider ( NULL ) ,
	m_Provider_Internal_IWbemEventProvider ( NULL ) ,
	m_Provider_Internal_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_Internal_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_Internal_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_Internal_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_Internal_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_Internal_IWmiProviderConfiguration ( NULL ) ,
	m_Provider_Internal_IWbemProviderInit ( NULL ) ,
	m_Provider_Internal_IWbemProviderIdentity ( NULL ) ,
	m_ExtendedStatusObject ( NULL ) ,
	m_CoreStub ( a_CoreStub ) ,
	m_Registration ( & a_Registration ) ,
	m_Locale ( NULL ) ,
	m_User ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_ProcessIdentifier ( 0 ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_Provider_Size , MAX_PROXIES ) ,
	m_ProviderOperation_GetObjectAsync ( 0 ) ,
	m_ProviderOperation_PutClassAsync ( 0 ) ,
	m_ProviderOperation_DeleteClassAsync ( 0 ) ,
	m_ProviderOperation_CreateClassEnumAsync ( 0 ) ,
	m_ProviderOperation_PutInstanceAsync ( 0 ) ,
	m_ProviderOperation_DeleteInstanceAsync ( 0 ) ,
	m_ProviderOperation_CreateInstanceEnumAsync ( 0 ) ,
	m_ProviderOperation_ExecQueryAsync ( 0 ) ,
	m_ProviderOperation_ExecNotificationQueryAsync ( 0 ) ,
	m_ProviderOperation_ExecMethodAsync ( 0 ) ,
	m_ProviderOperation_QueryInstances ( 0 ) ,
	m_ProviderOperation_CreateRefresher ( 0 ) ,
	m_ProviderOperation_CreateRefreshableObject ( 0 ) ,
	m_ProviderOperation_StopRefreshing ( 0 ) ,
	m_ProviderOperation_CreateRefreshableEnum ( 0 ) ,
	m_ProviderOperation_GetObjects ( 0 ) ,
	m_ProviderOperation_GetProperty ( 0 ) ,
	m_ProviderOperation_PutProperty ( 0 ) ,
	m_ProviderOperation_ProvideEvents ( 0 ) ,
	m_ProviderOperation_NewQuery ( 0 ) ,
	m_ProviderOperation_CancelQuery ( 0 ) ,
	m_ProviderOperation_AccessCheck ( 0 ) ,
	m_ProviderOperation_SetRegistrationObject ( 0 ) ,
	m_ProviderOperation_FindConsumer ( 0 ) ,
	m_ProviderOperation_ValidateSubscription ( 0 ) ,
	m_Initialized ( 0 ) ,
	m_InitializeResult ( S_OK ) ,
	m_InitializedEvent ( NULL ) , 
	m_InitializationContext ( a_InitializationContext ),
	m_expandedSD(0)
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( a_InitializationContext )
	{
		a_InitializationContext->AddRef () ;
	}

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	if ( a_ServerSideProvider ) 
	{
		m_Unknown = a_ServerSideProvider ;
		m_Unknown->AddRef () ;

		HRESULT t_TempResult = m_Unknown->QueryInterface ( IID_IWbemServices , ( void ** ) & m_Provider_IWbemServices ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemServices , ( void ** ) & m_Provider_Internal_IWbemServices ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemPropertyProvider , ( void ** ) & m_Provider_IWbemPropertyProvider ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemPropertyProvider , ( void ** ) & m_Provider_Internal_IWbemPropertyProvider ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventProvider , ( void ** ) & m_Provider_Internal_IWbemEventProvider ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_Internal_IWbemEventProviderQuerySink ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventProviderSecurity , ( void ** ) & m_Provider_Internal_IWbemEventProviderSecurity ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemUnboundObjectSink , ( void ** ) & m_Provider_Internal_IWbemUnboundObjectSink ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventConsumerProvider , ( void ** ) & m_Provider_Internal_IWbemEventConsumerProvider ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_IWbemEventConsumerProviderEx ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_Internal_IWbemEventConsumerProviderEx ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & m_Provider_IWbemProviderInit ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemProviderInit , ( void ** ) & m_Provider_Internal_IWbemProviderInit ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemProviderIdentity , ( void ** ) & m_Provider_IWbemProviderIdentity ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemProviderIdentity , ( void ** ) & m_Provider_Internal_IWbemProviderIdentity ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}
	}

	if ( m_CoreStub )
	{
		m_CoreStub->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemDecoupledProvider :: ~CInterceptor_IWbemDecoupledProvider ()
{
	WmiSetAndCommitObject (

		ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_UnLoadOperationEvent ] , 
		WMI_SENDCOMMIT_SET_NOT_REQUIRED,
		m_Namespace ,
		m_Registration->GetProviderName () ,
		m_User ,
		m_Locale ,
		NULL 
	) ;

	if ( m_ExtendedStatusObject )
	{
		m_ExtendedStatusObject->Release () ;
	}

	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemServices )
	{
		m_Provider_IWbemServices->Release () ; 
	}

	if ( m_Provider_IWbemPropertyProvider )
	{
		m_Provider_IWbemPropertyProvider->Release () ; 
	}

	if ( m_Provider_IWbemEventProvider )
	{
		m_Provider_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		m_Provider_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		m_Provider_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		m_Provider_IWbemEventConsumerProviderEx->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProvider )
	{
		m_Provider_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Provider_IWbemProviderInit )
	{
		m_Provider_IWbemProviderInit->Release () ;
	}

	if ( m_Provider_IWbemProviderIdentity )
	{
		m_Provider_IWbemProviderIdentity->Release () ;
	}

	if ( m_Provider_Internal_IWbemServices )
	{
		m_Provider_Internal_IWbemServices->Release () ;
	}

	if ( m_Provider_Internal_IWbemPropertyProvider )
	{
		m_Provider_Internal_IWbemPropertyProvider->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventProvider )
	{
		m_Provider_Internal_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventProviderQuerySink )
	{
		m_Provider_Internal_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventProviderSecurity )
	{
		m_Provider_Internal_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventConsumerProvider )
	{
		m_Provider_Internal_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventConsumerProviderEx )
	{
		m_Provider_Internal_IWbemEventConsumerProviderEx->Release () ;
	}

	if ( m_Provider_Internal_IWbemUnboundObjectSink )
	{
		m_Provider_Internal_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Provider_Internal_IWmiProviderConfiguration )
	{
		m_Provider_Internal_IWmiProviderConfiguration->Release () ;
	}

	if ( m_Provider_Internal_IWbemProviderInit )
	{
		m_Provider_Internal_IWbemProviderInit->Release () ;
	}

	if ( m_Provider_Internal_IWbemProviderIdentity )
	{
		m_Provider_Internal_IWbemProviderIdentity->Release () ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->Release () ;
	}

	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	if ( m_InitializationContext )
	{
		m_InitializationContext->Release () ;
	}

	if ( m_InitializedEvent )
	{
		CloseHandle ( m_InitializedEvent ) ;
	}

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	if (m_expandedSD) delete[] (BYTE*)m_expandedSD;
		
	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemDecoupledProvider :: AddRef ()
{
	return SyncProviderContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemDecoupledProvider :: Release ()
{
	return SyncProviderContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemDecoupledProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		if ( m_Provider_IWbemServices )
		{
			*iplpv = ( LPVOID ) ( IWbemServices * ) this ;
		}
	}
	else if ( iid == IID_IWbemPropertyProvider )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemPropertyProvider * ) this ;
		}
	}	
	else if ( iid == IID_IWbemEventProvider )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProvider * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_IWbemProviderInit )
	{
		if ( m_Provider_IWbemProviderInit )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
		}
	}
	else if ( iid == IID_IWbemProviderIdentity )
	{
		if ( m_Provider_IWbemProviderIdentity )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderIdentity * ) this ;
		}
	}
	else if ( iid == IID__IWmiProviderAbnormalShutdown )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderAbnormalShutdown * ) this ;
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}
	else if ( iid == IID_CWbemGlobal_IWmiObjectSinkController )
	{
		*iplpv = ( LPVOID ) ( CWbemGlobal_IWmiObjectSinkController * ) this ;		
	}	
	else if ( iid == IID_CacheElement )
	{
		*iplpv = ( LPVOID ) ( SyncProviderContainerElement * ) this ;		
	}
	else if ( iid == IID__IWmiProviderInitialize )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderInitialize * ) this ;
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ConstructToken_SvcHost (

	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	ACCESS_ALLOWED_ACE *a_Ace ,
	WORD a_AceSize,
	SECURITY_IMPERSONATION_LEVEL level
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_ThreadToken = NULL ;

	BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		MAXIMUM_ALLOWED ,
		TRUE ,
		& t_ThreadToken
	) ;
	
	if ( t_Status )
	{
		CoRevertToSelf () ;

		a_Revert = FALSE ;

		SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;

		DWORD t_LengthRequested = 0 ;
		DWORD t_LengthReturned = 0 ;

		t_Status = GetKernelObjectSecurity (

			t_ThreadToken ,
			DACL_SECURITY_INFORMATION ,
			& t_SecurityDescriptor ,
			t_LengthRequested ,
			& t_LengthReturned
		) ;

		if ( ( t_Status == FALSE ) && ( GetLastError () == ERROR_INSUFFICIENT_BUFFER ) )
		{
			t_SecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_LengthReturned ] ;
			if ( t_SecurityDescriptor )
			{
				t_LengthRequested = t_LengthReturned ;

				t_Status = GetKernelObjectSecurity (

					t_ThreadToken ,
					DACL_SECURITY_INFORMATION ,
					t_SecurityDescriptor ,
					t_LengthRequested ,
					& t_LengthReturned
				) ;

				if ( t_LengthRequested != t_LengthReturned )
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		HANDLE t_AdjustedThreadToken = NULL ;

		if ( SUCCEEDED ( t_Result ) )
		{
			PACL t_ExtraDacl = NULL ;

			ACL *t_Dacl = NULL ;
			BOOL t_DaclPresent = FALSE ;
			BOOL t_DaclDefaulted = FALSE ;

			t_Status = GetSecurityDescriptorDacl (

				t_SecurityDescriptor ,
				& t_DaclPresent ,
				& t_Dacl ,
				& t_DaclDefaulted
			) ;

			if ( t_Status )
			{
				ACL_SIZE_INFORMATION t_Size ;

				if ( t_Dacl )
				{
					BOOL t_Status = GetAclInformation (

						t_Dacl ,
						& t_Size ,
						sizeof ( t_Size ) ,
						AclSizeInformation
					);

					if ( t_Status )
					{
						DWORD t_ExtraSize = t_Size.AclBytesInUse + t_Size.AclBytesFree + a_AceSize ;

						t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
						if ( t_ExtraDacl )
						{
							CopyMemory ( t_ExtraDacl , t_Dacl , t_Size.AclBytesInUse + t_Size.AclBytesFree ) ;
							t_ExtraDacl->AclSize = t_ExtraSize ;

							BOOL t_Status = :: AddAce ( t_ExtraDacl , ACL_REVISION, t_Size.AceCount , a_Ace , a_AceSize ) ;
							if ( t_Status )
							{
								SECURITY_DESCRIPTOR t_AdjustedSecurityDescriptor ;

								if ( SUCCEEDED ( t_Result ) )
								{
									BOOL t_Status = InitializeSecurityDescriptor ( & t_AdjustedSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
									if ( t_Status ) 
									{
										t_Status = SetSecurityDescriptorDacl (

											& t_AdjustedSecurityDescriptor ,
											t_DaclPresent ,
											t_ExtraDacl ,
											t_DaclDefaulted
										) ;

										if ( t_Status ) 
										{
											SECURITY_ATTRIBUTES t_SecurityAttributes ;
											t_SecurityAttributes.nLength = GetSecurityDescriptorLength ( & t_AdjustedSecurityDescriptor ) ;
											t_SecurityAttributes.lpSecurityDescriptor = & t_AdjustedSecurityDescriptor ;
											t_SecurityAttributes.bInheritHandle = FALSE ;

											t_Status = DuplicateTokenEx ( 

												t_ThreadToken,
												DUPLICATE_SAME_ACCESS ,
												& t_SecurityAttributes ,
												( SECURITY_IMPERSONATION_LEVEL ) level ,
												TokenImpersonation ,
												& t_AdjustedThreadToken
											) ;

											if ( t_Status == FALSE )
											{
												t_Result = WBEM_E_ACCESS_DENIED ;
											}
										}
										else
										{
											t_Result = WBEM_E_CRITICAL_ERROR ;
										}
									}
									else
									{
										t_Result = WBEM_E_UNEXPECTED ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_CRITICAL_ERROR ;
							}

							delete [] ( BYTE * ) t_ExtraDacl ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			HANDLE t_ProcessHandle = OpenProcess (

				MAXIMUM_ALLOWED ,
				FALSE ,
				a_ProcessIdentifier 
			) ;

			if ( t_ProcessHandle )
			{
				t_Status = DuplicateHandle (

					GetCurrentProcess () ,
					t_AdjustedThreadToken ,
					t_ProcessHandle ,
					& a_IdentifyToken ,
					MAXIMUM_ALLOWED | TOKEN_DUPLICATE | TOKEN_IMPERSONATE ,
					TRUE ,
					0
				) ;

				if ( t_Status )
				{

				}
				else
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}

				CloseHandle ( t_ProcessHandle ) ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}

		if ( t_SecurityDescriptor )
		{
			delete [] ( BYTE * ) t_SecurityDescriptor ; 
		}

		if ( t_AdjustedThreadToken )
		{
			CloseHandle ( t_AdjustedThreadToken ) ;
		}

		CloseHandle ( t_ThreadToken ) ;
	}
	else
	{
		t_Result = WBEM_E_ACCESS_DENIED ;
	}

	return t_Result ;
}

HRESULT SetProxyState_SvcHost ( 

    CInterceptor_IWbemDecoupledProvider * a_pInterceptor,
	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	ACCESS_ALLOWED_ACE *a_Ace ,
	WORD a_AceSize
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = ProviderSubSystem_Common_Globals::GetProxy ( a_Container , a_ProxyIndex , a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			DWORD t_ImpersonationLevel ;

			if ( a_pInterceptor->m_Registration->GetComRegistration ().GetDecoupledImpersonationRestriction () )
			{
				t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
			}
			else
			{
				t_ImpersonationLevel = ProviderSubSystem_Common_Globals::GetCurrentImpersonationLevel () ;
			}
		
			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = ProviderSubSystem_Common_Globals::EnableAllPrivileges () ;
			// Get the token's impersonation level
			// ===================================

				t_Result = ConstructToken_SvcHost (

					a_Revert ,
					a_ProcessIdentifier ,
					a_IdentifyToken ,
					a_Ace ,
					a_AceSize,
					(SECURITY_IMPERSONATION_LEVEL)(t_ImpersonationLevel-1)
				) ;
				
				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = SetInterfaceSecurity (

						a_Proxy ,
						NULL ,
						NULL ,
						NULL ,
						DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
						RPC_C_IMP_LEVEL_IDENTIFY
					) ;
				}
				CoRevertToSelf () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

HRESULT CInterceptor_IWbemDecoupledProvider :: Begin_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	DWORD t_AuthenticationLevel = 0 ;

	t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating , & t_AuthenticationLevel ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		_DBG_ASSERT( a_ProcessIdentifier );

		WORD t_AceSize = 0 ;
		ACCESS_ALLOWED_ACE *t_Ace = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: GetAceWithProcessTokenUser ( 
		
			a_ProcessIdentifier ,
			t_AceSize ,
			t_Ace 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = SetProxyState_SvcHost ( 

			    this,
				m_ProxyContainer , 
				a_InternalProxyIndex , 
				a_InterfaceIdentifier , 
				a_InternalServerInterface , 
				a_Proxy , 
				a_Revert , 
				a_ProcessIdentifier , 
				a_IdentifyToken ,
				t_Ace ,
				t_AceSize
			) ;

			delete [] ( BYTE * ) t_Ace ;
		}


		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = a_ServerInterface ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IUnknown * ) a_Proxy ;

				// Set cloaking on the proxy
				// this is always the _Internal_IWbemSerivcesProxy
				// so this settings really do not matter,
				// unless the DecoupledProvider
				// is able to bypass the IServerSecurity set-up with the hand-crafted token

				DWORD t_ImpersonationLevel ;

				if ( m_Registration->GetComRegistration ().GetDecoupledImpersonationRestriction () )
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				else
				{
					t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;
				}

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_DEFAULT, 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( a_Context )
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;
						t_Variant.lVal = t_AuthenticationLevel ;
						t_Variant.vt = VT_I4 ;

						
						t_Result = a_Context->SetValue ( L"__WBEM_CLIENT_AUTHENTICATION_LEVEL" , 0, & t_Variant ) ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					if ( a_IdentifyToken )
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 

							m_ProxyContainer , 
							a_InternalProxyIndex , 
							a_Proxy , 
							a_Revert ,
							a_ProcessIdentifier , 
							a_IdentifyToken 
						) ;
					}
					else
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

							m_ProxyContainer , 
							a_ProxyIndex , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: End_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;


	if ( a_Proxy )
	{
		_DBG_ASSERT(a_IdentifyToken);
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 

				m_ProxyContainer , 
				a_InternalProxyIndex , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier ,
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				a_ProxyIndex , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Find ( 

			a_Sink ,
			t_Iterator
		) ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			ObjectSinkContainerElement *t_Element = t_Iterator.GetElement () ;

			UnLock () ;

			IWbemObjectSink *t_ObjectSink = NULL ;
			t_Result = t_Element->QueryInterface ( IID_IWbemObjectSink , ( void ** ) & t_ObjectSink ) ;
			if ( SUCCEEDED ( t_Result ) )
			{ 
				IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
				REFIID t_InterfaceIdentifier = IID_IWbemServices ;
				DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
				IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
				REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
				DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
				BOOL t_Impersonating ;
				IUnknown *t_OldContext ;
				IServerSecurity *t_OldSecurity ;
				BOOL t_IsProxy ;
				IUnknown *t_Interface ;
				BOOL t_Revert ;
				IUnknown *t_Proxy ;
				HANDLE t_IdentifyToken = NULL ;

				t_Result = Begin_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_IdentifyToken )
					{
						WmiInternalContext t_InternalContext ;
						t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
						t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

						t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CancelAsyncCall (

							t_InternalContext ,
							t_ObjectSink
						) ;
					}
					else
					{
						t_Result = ( ( IWbemServices * ) t_Interface )->CancelAsyncCall (

							t_ObjectSink
						) ;
					}

					End_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;
				}

				t_ObjectSink->Release () ;
			}

			IWbemShutdown *t_Shutdown = NULL ;
			HRESULT t_TempResult = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				t_TempResult = t_Shutdown->Shutdown ( 

					0 , 
					0 , 
					NULL 
				) ;

				t_Shutdown->Release () ;
			}

			t_Element->Release () ;
		}
		else
		{
			UnLock () ;

			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

		return WBEM_E_NOT_FOUND ;
	}

	BOOL t_DependantCall = FALSE ;

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( this->GetSD() ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							if ( t_ObjectPath )
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_GetObjectAsync (

									t_InternalContext ,
									t_ObjectPath, 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;

								SysFreeString ( t_ObjectPath ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->GetObjectAsync (

								a_ObjectPath, 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( GetSD() ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							WmiInternalContext t_InternalContext ;
							t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
							t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

							t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutClassAsync (

								t_InternalContext ,
								a_Object , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->PutClassAsync (

								a_Object , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: DeleteClassAsync ( 
		
	const BSTR a_Class ,
	long a_Flags,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( GetSD() ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_Class = SysAllocString ( a_Class ) ;
							if ( t_Class ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteClassAsync (

									t_InternalContext ,
									t_Class , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;

								SysFreeString ( t_Class ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->DeleteClassAsync (

								a_Class , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CInterceptor_IWbemDecoupledProvider :: CreateClassEnumAsync (

	const BSTR a_Superclass ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( GetSD() ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_Superclass = SysAllocString ( a_Superclass ) ;
							if ( t_Superclass ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateClassEnumAsync  (

									t_InternalContext ,
									t_Superclass , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;

								SysFreeString ( t_Superclass ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->CreateClassEnumAsync  (

								a_Superclass , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutInstance (

    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance , 
	long a_Flags ,
    IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( GetSD() ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							WmiInternalContext t_InternalContext ;
							t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
							t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

							t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutInstanceAsync (

								t_InternalContext ,
								a_Instance , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->PutInstanceAsync (

								a_Instance , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: DeleteInstance ( 

	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemDecoupledProvider :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink	
)
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( GetSD() ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							if ( t_ObjectPath ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteInstanceAsync  (

									t_InternalContext ,
									t_ObjectPath ,
									a_Flags ,
									a_Context ,
									t_Sink
								) ;

								SysFreeString ( t_ObjectPath ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->DeleteInstanceAsync  (

								a_ObjectPath ,
								a_Flags ,
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: CreateInstanceEnum ( 

	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink

) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( GetSD() ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							WmiInternalContext t_InternalContext ;
							t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
							t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

							BSTR t_Class = SysAllocString ( a_Class ) ;
							if ( t_Class )
							{
								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateInstanceEnumAsync (

									t_InternalContext ,
 									t_Class ,
									a_Flags ,
									a_Context ,
									t_Sink 
								) ;

								SysFreeString ( t_Class ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{

							t_Result = ( ( IWbemServices * ) t_Interface )->CreateInstanceEnumAsync (

 								a_Class ,
								a_Flags ,
								a_Context ,
								t_Sink 
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecQuery ( 

	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemFilteringObjectSink *t_Sink = new CInterceptor_IWbemFilteringObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			a_QueryLanguage ,
			a_Query 
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( GetSD() ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
							BSTR t_Query = SysAllocString ( a_Query ) ;

							if ( t_QueryLanguage && t_Query ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecQueryAsync  (

									t_InternalContext ,
									t_QueryLanguage , 
									t_Query, 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							SysFreeString ( t_QueryLanguage ) ;
							SysFreeString ( t_Query ) ;
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->ExecQueryAsync  (

								a_QueryLanguage , 
								a_Query, 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			
			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemDecoupledProvider :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecMethod (

	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecMethodAsync ( 

    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

		return WBEM_E_NOT_FOUND ;
	}

	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( GetSD() ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy ,
						a_Context
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							BSTR t_MethodName = SysAllocString ( a_MethodName ) ;

							if ( t_ObjectPath && t_MethodName ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecMethodAsync  (

									t_InternalContext ,
									t_ObjectPath ,
									t_MethodName ,
									a_Flags ,
									a_Context ,
									a_InParams ,
									t_Sink
								) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							SysFreeString ( t_ObjectPath ) ;
							SysFreeString ( t_MethodName ) ;
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->ExecMethodAsync  (

								a_ObjectPath ,
								a_MethodName ,
								a_Flags ,
								a_Context ,
								a_InParams ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: GetProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemPropertyProvider ;
		REFIID t_InterfaceIdentifier = IID_IWbemPropertyProvider ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemPropertyProvider ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemPropertyProvider ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemPropertyProvider ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemPropertyProvider ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				BSTR t_ClassMapping = NULL ;
				BSTR t_InstanceMapping = NULL ;
				BSTR t_PropertyMapping = NULL ;

				if ( a_ClassMapping )
				{
					t_ClassMapping = SysAllocString ( a_ClassMapping ) ;
					if ( t_ClassMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( a_InstanceMapping )
				{
					t_InstanceMapping = SysAllocString ( a_InstanceMapping ) ;
					if ( t_InstanceMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					} 
				}

				if ( a_PropertyMapping )
				{
					t_PropertyMapping = SysAllocString ( a_PropertyMapping ) ;
					if ( t_PropertyMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					( ( Internal_IWbemPropertyProvider * ) t_Interface )->Internal_GetProperty ( 

						t_InternalContext ,
						a_Flags ,
						a_Locale ,
						t_ClassMapping ,
						t_InstanceMapping ,
						t_PropertyMapping ,
						a_Value
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_ClassMapping ) ;
				SysFreeString ( t_InstanceMapping ) ;
				SysFreeString ( t_PropertyMapping ) ;
			}
			else
			{
				t_Result = ( ( IWbemPropertyProvider * ) t_Interface )->GetProperty (

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}	
	else
	{
		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemPropertyProvider ;
		REFIID t_InterfaceIdentifier = IID_IWbemPropertyProvider ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemPropertyProvider ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemPropertyProvider ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemPropertyProvider ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemPropertyProvider ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				BSTR t_ClassMapping = NULL ;
				BSTR t_InstanceMapping = NULL ;
				BSTR t_PropertyMapping = NULL ;

				if ( a_ClassMapping )
				{
					t_ClassMapping = SysAllocString ( a_ClassMapping ) ;
					if ( t_ClassMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( a_InstanceMapping )
				{
					t_InstanceMapping = SysAllocString ( a_InstanceMapping ) ;
					if ( t_InstanceMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					} 
				}

				if ( a_PropertyMapping )
				{
					t_PropertyMapping = SysAllocString ( a_PropertyMapping ) ;
					if ( t_PropertyMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					( ( Internal_IWbemPropertyProvider * ) t_Interface )->Internal_PutProperty ( 

						t_InternalContext ,
						a_Flags ,
						a_Locale ,
						t_ClassMapping ,
						t_InstanceMapping ,
						t_PropertyMapping ,
						a_Value
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_ClassMapping ) ;
				SysFreeString ( t_InstanceMapping ) ;
				SysFreeString ( t_PropertyMapping ) ;
			}
			else
			{
				t_Result = ( ( IWbemPropertyProvider * ) t_Interface )->PutProperty (

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
#ifdef WMI_PRIVATE_DBG
#ifdef DBG
            CTestNullTokenOnScope Test(__LINE__,__FILE__);
#endif
#endif

	if ( m_Provider_IWbemEventProvider )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventProvider ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProvider ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProvider ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProvider ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProvider ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProvider ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemEventProvider * ) t_Interface )->Internal_ProvideEvents (

					t_InternalContext ,
					a_Sink ,
					a_Flags 
				) ;
			}
			else
			{
				t_Result = ( ( IWbemEventProvider * ) t_Interface )->ProvideEvents (

					a_Sink ,
					a_Flags 
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
#ifdef WMI_PRIVATE_DBG
#ifdef DBG
            CTestNullTokenOnScope Test(__LINE__,__FILE__);
#endif
#endif

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderQuerySink ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProviderQuerySink ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderQuerySink ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProviderQuerySink ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProviderQuerySink ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProviderQuerySink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
				BSTR t_Query = SysAllocString ( a_Query ) ;

				if ( t_QueryLanguage && t_Query )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					t_Result = ( ( Internal_IWbemEventProviderQuerySink * ) t_Interface )->Internal_NewQuery (

						t_InternalContext ,
						a_Id ,
						t_QueryLanguage ,
						t_Query
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_QueryLanguage ) ;
				SysFreeString ( t_Query ) ;
			}
			else
			{
				t_Result = ( ( IWbemEventProviderQuerySink * ) t_Interface )->NewQuery (

					a_Id ,
					a_QueryLanguage ,
					a_Query
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::CancelQuery (

	unsigned long a_Id
)
{
#ifdef WMI_PRIVATE_DBG
#ifdef DBG
            CTestNullTokenOnScope Test(__LINE__,__FILE__);
#endif
#endif

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderQuerySink ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProviderQuerySink ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderQuerySink ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProviderQuerySink ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProviderQuerySink ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProviderQuerySink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemEventProviderQuerySink * ) t_Interface )->Internal_CancelQuery (

					t_InternalContext ,
					a_Id
				) ;
			}
			else
			{
				t_Result = ( ( IWbemEventProviderQuerySink * ) t_Interface )->CancelQuery (

					a_Id
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
#ifdef WMI_PRIVATE_DBG
#ifdef DBG
            CTestNullTokenOnScope Test(__LINE__,__FILE__);
#endif
#endif

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderSecurity ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProviderSecurity ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderSecurity ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProviderSecurity ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProviderSecurity ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProviderSecurity;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
				BSTR t_Query = SysAllocString ( a_Query ) ;

				if ( t_QueryLanguage && t_Query )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					t_Result = ( ( Internal_IWbemEventProviderSecurity * ) t_Interface )->Internal_AccessCheck (

						t_InternalContext ,
						t_QueryLanguage ,
						t_Query ,
						a_SidLength ,
						a_Sid
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_QueryLanguage ) ;
				SysFreeString ( t_Query ) ;
			}
			else
			{
				t_Result = ( ( IWbemEventProviderSecurity * ) t_Interface )->AccessCheck (

					a_QueryLanguage ,
					a_Query ,
					a_SidLength ,
					a_Sid
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	if ( m_Provider_IWbemEventConsumerProvider )
	{
		IWbemUnboundObjectSink *t_Consumer = NULL ;

		IUnknown *t_ServerInterface = m_Provider_IWbemEventConsumerProvider ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventConsumerProvider ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventConsumerProvider ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventConsumerProvider ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventConsumerProvider ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventConsumerProvider ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemEventConsumerProvider * ) t_Interface )->Internal_FindConsumer (

					t_InternalContext ,
					a_LogicalConsumer ,
					& t_Consumer
				) ;
			}
			else
			{
				t_Result = ( ( IWbemEventConsumerProvider * ) t_Interface )->FindConsumer (

					a_LogicalConsumer ,
					& t_Consumer
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( a_Consumer )
			{
				CDecoupled_IWbemUnboundObjectSink *t_UnboundObjectSink = new CDecoupled_IWbemUnboundObjectSink (

						m_Allocator ,
						t_Consumer , 
						this ,
						*m_Registration
				) ;

				if ( t_UnboundObjectSink )
				{
					t_UnboundObjectSink->AddRef () ;

					t_Result = t_UnboundObjectSink->Initialize () ;
					if ( SUCCEEDED ( t_Result ) ) 
					{
						CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

						Lock () ;

						WmiStatusCode t_StatusCode = Insert ( 

							*t_UnboundObjectSink ,
							t_Iterator
						) ;

						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							UnLock () ;

							*a_Consumer = t_UnboundObjectSink ;

							t_UnboundObjectSink->AddRef () ;
						}
						else
						{
							UnLock () ;

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_UnboundObjectSink->Release () ;
				}
			}
		}
		else
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		if ( t_Consumer )
		{
			t_Consumer->Release () ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventConsumerProviderEx ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventConsumerProviderEx ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventConsumerProviderEx ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventConsumerProviderEx ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventConsumerProviderEx ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventConsumerProviderEx ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemEventConsumerProviderEx * ) t_Interface )->Internal_ValidateSubscription (

					t_InternalContext ,
					a_LogicalConsumer
				) ;
			}
			else
			{

				t_Result = ( ( IWbemEventConsumerProviderEx * ) t_Interface )->ValidateSubscription (

					a_LogicalConsumer
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemUnboundObjectSink ;
		REFIID t_InterfaceIdentifier = IID_IWbemUnboundObjectSink ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemUnboundObjectSink ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemUnboundObjectSink ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemUnboundObjectSink ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemUnboundObjectSink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemUnboundObjectSink * ) t_Interface )->Internal_IndicateToConsumer (

					t_InternalContext ,
					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else
			{

				t_Result = ( ( IWbemUnboundObjectSink * ) t_Interface )->IndicateToConsumer (

					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: SetInitialized ( HRESULT a_InitializeResult )
{
	m_InitializeResult = a_InitializeResult ;

	InterlockedExchange ( & m_Initialized , 1 ) ;

	if ( m_InitializedEvent )
	{
		SetEvent ( m_InitializedEvent ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout )
{
	HRESULT t_Result = WBEM_E_UNEXPECTED ;

	if ( m_Initialized == 0 )
	{
		BOOL t_DependantCall = FALSE ;
		t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_DependantCall == FALSE )
			{
				if ( WaitForSingleObject ( m_InitializedEvent , a_Timeout ) == WAIT_TIMEOUT )
				{
					return WBEM_E_PROVIDER_LOAD_FAILURE ;
				}
			}
			else
			{
				if ( WaitForSingleObject ( m_InitializedEvent , 0 ) == WAIT_TIMEOUT )
				{
					return S_FALSE ;
				}
			}
		}
	}
	else
	{
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: SetRegistrationObject (

	long a_Flags ,
	IWbemClassObject *a_ProviderRegistration
)
{
	if ( m_Provider_IWbemProviderIdentity )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemProviderIdentity ;
		REFIID t_InterfaceIdentifier = IID_IWbemProviderIdentity ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemProviderIdentity ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemProviderIdentity ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemProviderIdentity ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemProviderIdentity ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemProviderIdentity * ) t_Interface )->Internal_SetRegistrationObject (

					t_InternalContext ,
					a_Flags ,
					a_ProviderRegistration
				) ;
			}
			else
			{
				t_Result = ( ( IWbemProviderIdentity * ) t_Interface )->SetRegistrationObject (

					a_Flags ,
					a_ProviderRegistration
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: Initialize (

	LPWSTR a_User ,
	LONG a_Flags ,
	LPWSTR a_Namespace ,
	LPWSTR a_Locale ,
	IWbemServices *a_CoreService ,
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink
)
{
	if ( m_Provider_IWbemProviderInit )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemProviderInit ;
		REFIID t_InterfaceIdentifier = IID_IWbemProviderInit ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemProviderInit ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemProviderInit ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemProviderInit ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemProviderInit ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemProviderInit * ) t_Interface )->Internal_Initialize (

					t_InternalContext ,
					a_User ,
					a_Flags ,
					a_Namespace ,
					a_Locale ,
					a_CoreService ,
					a_Context ,
					a_Sink
				) ;
			}
			else
			{
				t_Result = ( ( IWbemProviderInit * ) t_Interface )->Initialize (

					a_User ,
					a_Flags ,
					a_Namespace ,
					a_Locale ,
					a_CoreService ,
					a_Context ,
					a_Sink
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: AbnormalShutdown ()
{
	HRESULT t_Result = S_OK ;
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	IWbemShutdown *t_Shutdown = NULL ;

	if ( m_Unknown )
	{
		t_Result = m_Unknown->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , IID_IWbemShutdown , t_Shutdown , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_Shutdown->Shutdown (

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}

					CoRevertToSelf () ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemShutdown *t_Provider = ( IWbemShutdown * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_DEFAULT, 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								try
								{
									t_Result = t_Provider->Shutdown (

										a_Flags ,
										a_MaxMilliSeconds ,
										a_Context
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
						}

						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_Shutdown->Release () ;
		}
	}

	if ( m_CoreStub )
	{
		t_Shutdown = NULL ;
		t_Result = m_CoreStub->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Shutdown->Shutdown (

				a_Flags ,
				a_MaxMilliSeconds ,
				a_Context
			) ;

			t_Shutdown->Release () ;
		}
	}

	Lock () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Container->Size () ] ;
	if ( t_ShutdownElements )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

		ULONG t_Count = 0 ;
		while ( ! t_Iterator.Null () )
		{
			t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

			t_Iterator.Increment () ;

			t_Count ++ ;
		}

		UnLock () ;

		for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
		{
			if ( t_ShutdownElements [ t_Index ] ) 
			{
				t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

					a_Flags ,
					a_MaxMilliSeconds ,
					a_Context
				) ;

				t_ShutdownElements [ t_Index ]->Release () ;
			}
		}

		delete [] t_ShutdownElements ;
	}
	else
	{	
		UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: Initialize (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Namespace ,
	IWbemServices *a_Repository ,
	IWbemServices *a_Service ,
	IWbemProviderInitSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_TransactionIdentifier )
		{
			wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;

			if ( a_TransactionIdentifier )
			{
				StringFromGUID2 ( *a_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
			}

			m_TransactionIdentifier = SysAllocString ( t_TransactionIdentifier ) ;
		}
	}

	if ( a_Repository )
	{
		t_Result = a_Repository->GetObject ( 

			L"__ExtendedStatus" ,
			0 , 
			a_Context ,
			& m_ExtendedStatusObject ,
			NULL
		) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_InitializedEvent = CreateEvent ( NULL , TRUE , FALSE , NULL ) ;
		if ( m_InitializedEvent == NULL )
		{
			t_Result = t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiProviderSite *t_Site = NULL ;
		t_Result = m_Unknown->QueryInterface ( IID__IWmiProviderSite , ( void ** ) & t_Site ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Site->GetSite ( & m_ProcessIdentifier ) ;
			t_Site->Release () ;

			// Add the process SD
			t_Result = AddProcessToSD(m_ProcessIdentifier, m_expandedSD, m_Registration->GetComRegistration ().GetSecurityDescriptor ());
		}
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}


HANDLE TokenOfProcess(DWORD a_ProcessIdentifier)
{
	HANDLE t_ProcessToken = NULL;

	HANDLE t_ProcessHandle = OpenProcess (
		MAXIMUM_ALLOWED ,
		FALSE ,
		a_ProcessIdentifier 
	) ;

	if ( t_ProcessHandle )
	{
		BOOL t_Status = OpenProcessToken (
			t_ProcessHandle ,
			TOKEN_QUERY ,
			& t_ProcessToken
		) ;
		CloseHandle(t_ProcessHandle);
	}
	return t_ProcessToken;
};

// If the oject is secured we are using that SD to secure the interceptor
// if not we are aloweing well knowns SID's plus the process owner to pass

HRESULT CInterceptor_IWbemDecoupledProvider :: AddProcessToSD (DWORD pid, SECURITY_DESCRIPTOR*& destSD, SECURITY_DESCRIPTOR* sourceSD )
{
	_DBG_ASSERT(pid !=0);

	HRESULT t_Result = S_OK;
	if (sourceSD) return t_Result;
	
	if(HANDLE t_Token = TokenOfProcess(pid))
	{
			DWORD t_OwnerSize = 0 ; 
			PSID t_OwnerSid = NULL ;
			BOOL t_OwnerDefaulted = FALSE ;

			t_Result = ProviderSubSystem_Common_Globals :: GetUserSid (

				t_Token ,
				& t_OwnerSize , 
				t_OwnerSid 
			) ; 

			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_GroupSize = 0 ; 
				PSID t_GroupSid = NULL ;
				BOOL t_GroupDefaulted = FALSE ;

				t_Result = ProviderSubSystem_Common_Globals :: GetGroupSid (

					t_Token ,
					& t_GroupSize , 
					t_GroupSid 
				) ; 

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: AdjustSecurityDescriptorWithSid ( 
						( SID * ) t_OwnerSid ,
						( SID * ) t_GroupSid ,
						MASK_PROVIDER_BINDING_BIND ,
						sourceSD , 
						destSD
					) ;

					delete [] ( BYTE * ) t_GroupSid ;
				}

				delete [] ( BYTE * ) t_OwnerSid ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			CloseHandle ( t_Token ) ;
	}
	else
	{
		t_Result = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,GetLastError());
	};
	
	return S_OK;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provinsk.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvInSk.h"
#include "guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderInitSink :: CServerObject_ProviderInitSink (

	SECURITY_DESCRIPTOR *a_SecurityDescriptor 

)	:   m_ReferenceCount ( 0 ) , 
		m_Event ( NULL ) , 
		m_StatusCalled ( FALSE ) , 
		m_Result ( S_OK ) ,
		m_SecurityDescriptor ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderInitSink :: ~CServerObject_ProviderInitSink () 
{
	if ( m_Event ) 
	{
		CloseHandle ( m_Event ) ;
	}

	if ( m_SecurityDescriptor )
	{
		delete [] ( BYTE * ) m_SecurityDescriptor ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderInitSink :: SinkInitialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor )
{
	HRESULT t_Result = S_OK ;

	m_Event = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	if ( m_Event )
	{
		if ( a_SecurityDescriptor )
		{
			t_Result = ProviderSubSystem_Common_Globals :: SinkAccessInitialize ( a_SecurityDescriptor , m_SecurityDescriptor ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_ProviderInitSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemProviderInitSink )
	{
		*iplpv = ( LPVOID ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_ProviderInitSink :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_ProviderInitSink :: Release ()
{
	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderInitSink :: SetStatus (

    LONG a_Status,
    LONG a_Flags 
)
{
	HRESULT t_Result = S_OK ;
	if ( m_SecurityDescriptor )
	{
		t_Result = CoImpersonateClient () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Check_SecurityDescriptor_CallIdentity (

				m_SecurityDescriptor , 
				MASK_PROVIDER_BINDING_BIND ,
				& g_ProviderBindingMapping
			) ;

			CoRevertToSelf () ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_Result = a_Status ;
	}
	else
	{
		m_Result = t_Result ;
	}

	SetEvent ( m_Event ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemProviderInitSink :: CInterceptor_IWbemProviderInitSink (

	IWbemProviderInitSink *a_InterceptedSink

)	:	m_ReferenceCount ( 0 ) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_StatusCalled ( FALSE ) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemProviderInitSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemProviderInitSink::~CInterceptor_IWbemProviderInitSink ()
{
	if ( ! m_StatusCalled ) 
	{
		m_InterceptedSink->SetStatus ( WBEM_E_UNEXPECTED , 0 ) ; 
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemProviderInitSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemProviderInitSink::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemProviderInitSink )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInitSink * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemProviderInitSink :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemProviderInitSink :: Release ()
{
	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProviderInitSink :: SetStatus (

	LONG a_Status,
    LONG a_Flags 
)
{
	HRESULT t_Result = S_OK ;

	m_StatusCalled = TRUE ;

	m_InProgress ++ ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedSink->SetStatus ( 

			a_Status,
			a_Flags 
		) ;
	}

	m_InProgress -- ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProviderInitSink :: Shutdown ()
{
	HRESULT t_Result = S_OK ;

	m_GateClosed ++ ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;
			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provfact.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <stdio.h>
#define SECURITY_WIN32
#include <Security.h>
#include <lmcons.h>

#include <HelperFuncs.h>
#include <Logging.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvSubS.h"
#include "ProvAggr.h"
#include "ProvFact.h"
#include "ProvLoad.h"
#include "ProvWsv.h"
#include "ProvWsvS.h"
#include "ProvResv.h"
#include "ProvInSk.h"
#include "ProvRegDeCoupled.h"
#include "ProvRegInfo.h"
#include "ProvCache.h"
#include "ProvHost.h"
#include "ProvObSk.h"
#include "Guids.h"

#include <scopecheck.h>



/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CServerObject_BindingFactory :: CServerObject_BindingFactory (

	WmiAllocator &a_Allocator

) :	CWbemGlobal_IWmiProviderController ( a_Allocator ) ,
	m_Internal ( this ) ,
	m_Allocator ( a_Allocator ) ,
	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_NamespacePath ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SubSystem ( NULL ) ,
	m_SvcWrappersContainer( a_Allocator )
{
	CWbemGlobal_IWmiProviderController :: AddRef () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_BindingFactory_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_BindingFactory :: CServerObject_BindingFactory (

	WmiAllocator &a_Allocator ,
	CWbemGlobal_IWmiFactoryController *a_Controller ,
	const BindingFactoryCacheKey &a_Key ,
	const ULONG &a_Period 

) : BindingFactoryCacheElement (

		a_Controller ,
		a_Key ,
		a_Period
	) ,
	CWbemGlobal_IWmiProviderController ( a_Allocator ) ,
	m_Internal ( this ) ,
	m_Allocator ( a_Allocator ) ,
	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_NamespacePath ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SubSystem ( NULL ) ,
	m_SvcWrappersContainer( a_Allocator )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_BindingFactory_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_BindingFactory::~CServerObject_BindingFactory ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		delete [] m_Namespace ;
	}

	if ( m_NamespacePath ) 
	{
		m_NamespacePath->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}

	if ( m_SubSystem ) 
	{
		m_SubSystem->Release () ;
	}

	CWbemGlobal_IWmiProviderController :: UnInitialize () ;


	ULONG t_Count = m_SvcWrappersContainer.Size();
	for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
	{
		IUnknown * t_SvcWrap ;
		WmiStatusCode t_StatusCode = m_SvcWrappersContainer.Top ( t_SvcWrap) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_SvcWrap->Release () ;
			t_StatusCode = m_SvcWrappersContainer.DeQueue () ;
		}
	}

	m_SvcWrappersContainer.UnInitialize() ;
	
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_BindingFactory_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Initialize (

	_IWmiProvSS *a_SubSys ,
	_IWmiProviderFactory *a_Factory ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Namespace ,
	IWbemServices *a_Repository ,
	IWbemServices *a_Service	
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		if ( a_Namespace ) 
		{
			m_Namespace = DupString(a_Namespace );
			if ( m_Namespace == 0) 
			{	
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = CoCreateInstance (

					CLSID_WbemDefPath ,
					NULL ,
					CLSCTX_INPROC_SERVER ,
					IID_IWbemPath ,
					( void ** )  & m_NamespacePath
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = m_NamespacePath->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Namespace ) ;
				}
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			m_SubSystem = a_SubSys ;
			m_Flags = a_Flags ;
			m_Context = a_Context ;
			
			if ( m_Context ) 
			{
				m_Context->AddRef () ;
			}

			if ( m_SubSystem ) 
			{
				m_SubSystem->AddRef () ;
			}

			WmiStatusCode t_StatusCode = CWbemGlobal_IWmiProviderController :: Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success ) 
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		if (e_StatusCode_Success != m_SvcWrappersContainer.Initialize() )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_BindingFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiProviderFactory )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderFactory * ) this ;		
	}	
	else if ( iid == IID__IWmiProviderFactoryInitialize )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderFactoryInitialize * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	
	else if ( iid == IID__IWmiProviderConfiguration )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderConfiguration * ) this ;		
	}	
	else if ( iid == IID_CWbemGlobal_IWmiProviderController )
	{
		*iplpv = ( LPVOID ) & ( this->m_Internal ) ;
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_BindingFactory :: AddRef ()
{
	return BindingFactoryCacheElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_BindingFactory :: Release ()
{	
	return BindingFactoryCacheElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: CacheProvider (

	_IWmiProviderSubsystemRegistrar *a_Registrar ,
	IWbemContext *a_Context ,
	CServerObject_DecoupledClientRegistration_Element &a_Element ,
	IUnknown *a_Unknown 
)
{
	HRESULT t_Result = S_OK ;

	GUID t_Identity ;
	t_Result = CLSIDFromString ( a_Element.GetClsid () , & t_Identity ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_Registrar->Register (

			0 ,
			a_Context ,
			a_Element.GetUser () ,
			a_Element.GetLocale () ,
			a_Element.GetScope () ,
			a_Element.GetProvider () ,
			a_Element.GetProcessIdentifier () ,
			a_Unknown ,
			t_Identity
		) ;
	}	

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Load (

	_IWmiProviderSubsystemRegistrar *a_Registrar ,
	IWbemContext *a_Context ,
	CServerObject_DecoupledClientRegistration_Element &a_Element
)
{
	HRESULT t_Result = S_OK ;

	BYTE *t_MarshaledProxy = a_Element.GetMarshaledProxy () ;
	DWORD t_MarshaledProxyLength = a_Element.GetMarshaledProxyLength () ;

	if ( t_MarshaledProxy )
	{
		IUnknown *t_Unknown = NULL ;
		t_Result = ProviderSubSystem_Common_Globals :: UnMarshalRegistration ( & t_Unknown , t_MarshaledProxy , t_MarshaledProxyLength ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CacheProvider ( 

				a_Registrar ,
				a_Context ,
				a_Element ,
				t_Unknown 	
			) ;

			t_Unknown->Release () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Load (

	CDecoupledAggregator_IWbemProvider *a_Aggregator ,
	IWbemContext *a_Context ,
	BSTR a_Provider ,
	BSTR a_User ,
	BSTR a_Locale ,
	BSTR a_Scope
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		_IWmiProviderSubsystemRegistrar *t_Registrar = NULL ;
		t_Result = a_Aggregator->QueryInterface ( IID__IWmiProviderSubsystemRegistrar , ( void ** ) & t_Registrar ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( ProviderSubSystem_Globals :: GetDecoupledRegistrySection () ) ;

			CServerObject_DecoupledClientRegistration t_Elements ( m_Allocator ) ;
			HRESULT t_TempResult = t_Elements.Load (

				a_Provider ,
				a_User ,
				a_Locale ,
				a_Scope
			) ;
							
			t_StatusCode = WmiHelper :: LeaveCriticalSection ( ProviderSubSystem_Globals :: GetDecoupledRegistrySection () ) ;

			if ( SUCCEEDED ( t_TempResult ) )
			{
				WmiQueue < CServerObject_DecoupledClientRegistration_Element , 8 > &t_Queue = t_Elements.GetQueue () ;
				
				CServerObject_DecoupledClientRegistration_Element t_Top ;

				WmiStatusCode t_StatusCode ;
				while ( ( t_StatusCode = t_Queue.Top ( t_Top ) ) == e_StatusCode_Success )
				{
					HRESULT t_TempResult = Load (

						t_Registrar ,
						a_Context , 
						t_Top
					) ;

					t_StatusCode = t_Queue.DeQueue () ;
				}
			}
			else
			{
			}

			t_Registrar->Release () ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: GetHosting ( 

	CServerObject_ProviderRegistrationV1 &a_Registration ,
	IWbemContext *a_Context ,
	Enum_Hosting &a_Hosting ,
	LPCWSTR &a_HostingGroup
)
{
	HRESULT t_Result = S_OK ;

	a_Hosting = e_Hosting_Undefined ;
	
	if ( a_Context )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		HRESULT t_TResult = a_Context->GetValue ( L"Hosting" , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( t_TResult ) )
		{
			if ( t_Variant.vt == VT_I4 )	
			{
				a_Hosting = ( Enum_Hosting ) t_Variant.lVal ;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	a_Hosting = ( a_Hosting == e_Hosting_Undefined ) ? a_Registration.GetHosting () : a_Hosting ;
	switch ( a_Hosting )
	{
		case e_Hosting_SharedNetworkServiceHost:
		case e_Hosting_SharedLocalSystemHostOrSelfHost:
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalServiceHost:
		{
			a_HostingGroup = a_Registration.GetHostingGroup () ;
		}
		break ;

		default:
		{
			a_HostingGroup = NULL ;
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Create ( 

	CServerObject_ProviderRegistrationV1 &a_Registration ,
	Enum_Hosting a_Hosting ,
	LPCWSTR a_HostingGroup ,
	LPCWSTR a_User ,
	_IWmiProviderHost **a_Host ,
	_IWmiProviderFactory **a_Factory ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	switch ( a_Hosting )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_WmiCoreOrSelfHost:
		case e_Hosting_SelfHost:
		case e_Hosting_NonCom:
		{
			t_Result = ProviderSubSystem_Common_Globals :: CreateInstance	(

				CLSID_WmiProviderInProcFactory ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID__IWmiProviderFactory ,
				( void ** ) a_Factory 
			) ;
		}
		break ;

		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalSystemHostOrSelfHost:
		{
			try
			{
				HostCacheKey t_Key ( 

					HostCacheKey :: e_HostDesignation_Shared ,
					a_HostingGroup ,
					HostCacheKey :: e_IdentityDesignation_LocalSystem ,
					NULL
				) ;

				t_Result = CServerObject_HostInterceptor :: CreateUsingToken (

					t_Key ,
					a_Host ,
					a_Factory ,
					a_Context
				) ;
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		break ;

		case e_Hosting_Decoupled:
		{
			t_Result = WBEM_E_PROVIDER_NOT_FOUND ;
		}
		break ;

		case e_Hosting_SharedLocalServiceHost:
		{
			try
			{
				HostCacheKey t_Key ( 

					HostCacheKey :: e_HostDesignation_Shared ,
					a_HostingGroup ,
					HostCacheKey :: e_IdentityDesignation_LocalService ,
					NULL
				) ;

				t_Result = CServerObject_HostInterceptor :: CreateUsingAccount (

					t_Key ,
					L"LocalService" ,
					L"NT AUTHORITY" ,
					a_Host ,
					a_Factory ,
					a_Context
				) ;
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		break ;

		case e_Hosting_SharedNetworkServiceHost:
		{
			try
			{
				HostCacheKey t_Key ( 

					HostCacheKey :: e_HostDesignation_Shared ,
					a_HostingGroup ,
					HostCacheKey :: e_IdentityDesignation_NetworkService ,
					NULL
				) ;

				t_Result = CServerObject_HostInterceptor :: CreateUsingAccount (

					t_Key ,
					L"NetworkService" ,
					L"NT AUTHORITY" ,
					a_Host ,
					a_Factory ,
					a_Context
				) ;
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		break ;

		default:
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: InitializeHostedService (

	CInterceptor_IWbemProvider *a_Interceptor ,
	IUnknown *a_Unknown
)
{
	HRESULT t_Result = S_OK ;

	IUnknown *t_InterceptorUnknown = NULL ;
	t_Result = a_Interceptor->QueryInterface ( IID_IUnknown , ( void ** ) & t_InterceptorUnknown ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiProviderSite *t_Site = NULL ;
		t_Result = a_Unknown->QueryInterface ( IID__IWmiProviderSite , ( void ** ) & t_Site ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Site->SetContainer ( a_Interceptor->GetQuota () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				DWORD t_ProcessIdentifier = 0 ;
				t_Result = t_Site->GetSite ( & t_ProcessIdentifier ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_HostedProviderController *t_HostedController = ProviderSubSystem_Globals :: GetHostedProviderController () ;

					AutoLockGuard<CWbemGlobal_HostedProviderController> localLock(*t_HostedController);


					CWbemGlobal_HostedProviderController_Container_Iterator t_Iterator ;

					WmiStatusCode t_StatusCode = t_HostedController->Find ( t_ProcessIdentifier , t_Iterator ) ;
					switch ( t_StatusCode )
					{
						case e_StatusCode_Success:
						{
							ProviderController *t_ProviderController = NULL ;
							t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_ProviderController , ( void ** ) & t_ProviderController ) ;
							if ( SUCCEEDED ( t_Result ) ) 
							{
							
								AutoLockGuard<ProviderController> providerLock(*t_ProviderController);

								ProviderController :: Container_Iterator t_Iterator ;
								t_StatusCode = t_ProviderController->Insert ( a_Interceptor , t_Iterator ) ;
								if ( t_StatusCode != e_StatusCode_Success )
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								providerLock.UnLock () ;

								t_ProviderController->Release () ;
							}
						}
						break ;

						default:
						{
							ProviderController *t_ProviderController = new ProviderController ( 

								m_Allocator , 
								t_HostedController , 
								t_ProcessIdentifier
							) ;

							if ( t_ProviderController )
							{
								t_ProviderController->AddRef () ;

								t_StatusCode = t_ProviderController->Initialize () ;
								if ( t_StatusCode == e_StatusCode_Success ) 
								{
									t_StatusCode = t_HostedController->Insert ( *t_ProviderController , t_Iterator ) ;
									if ( t_StatusCode == e_StatusCode_Success ) 
									{
										t_ProviderController->AddRef () ;

										AutoLockGuard<ProviderController> providerLock(*t_ProviderController);

										ProviderController :: Container_Iterator t_Iterator ;
										t_StatusCode = t_ProviderController->Insert ( a_Interceptor , t_Iterator ) ;
										if ( t_StatusCode == e_StatusCode_Success )
										{
										}
										else
										{
											t_Result = WBEM_E_OUT_OF_MEMORY ;
										}

										if ( FAILED ( t_Result ) )
										{
											t_StatusCode = t_HostedController->Delete ( t_ProcessIdentifier ) ;
										}

										providerLock.UnLock () ;
									}
									else
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								t_ProviderController->Release () ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						break ;
					}
				}
			}

			t_Site->Release () ;
		}

		t_InterceptorUnknown->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: InternalFindAggregatedDecoupledProvider ( 

	IWbemServices *a_RepositoryService ,
	IWbemServices *a_FullService ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	ProviderCacheKey &a_Key ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope,
	LPCWSTR a_Name ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		AutoLockGuard<CServerObject_BindingFactory> localLock(*this) ;

		CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator ;

		WmiStatusCode t_StatusCode = Find ( a_Key , t_Iterator ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			ServiceCacheElement *t_Element = t_Iterator.GetElement () ;

			localLock.UnLock () ;

			CDecoupledAggregator_IWbemProvider *t_Aggregator = NULL ;

			t_Result = t_Element->QueryInterface (

				IID_CDecoupledAggregator_IWbemProvider ,
				( void ** ) & t_Aggregator
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Aggregator->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Result == S_FALSE )
					{
						t_Result = t_Element->QueryInterface (

							a_RIID ,
							a_Interface
						) ;

						t_Aggregator->Release () ;
						t_Element->Release () ;
						return t_Result ;
					}

					if ( SUCCEEDED ( t_Result = t_Aggregator->GetInitializeResult () ) )
					{
						t_Result = t_Element->QueryInterface (

							a_RIID ,
							a_Interface
						) ;

						if ( FAILED ( t_Result ) )
						{
							t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
						}
					}
					else
					{
						t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
					}
				}

				t_Aggregator->Release () ;
			}
			else
			{
				t_Result = WBEM_E_UNEXPECTED ;
			}

			t_Element->Release () ;
		}
		else
		{
			BOOL t_ReEntrancy = ( a_Registration.GetInitializationReentrancy () == e_InitializationReentrancy_Clsid ) ;
			t_ReEntrancy = t_ReEntrancy || ( a_Registration.GetInitializationReentrancy () == e_InitializationReentrancy_Namespace ) ;

			CDecoupledAggregator_IWbemProvider *t_InitializingAggregator = NULL ;

			BOOL t_IndependantCall = TRUE ;

			if ( t_ReEntrancy )
			{
				CWbemGlobal_IWmiProviderController_Cache *t_Cache = NULL ;
				GetCache ( t_Cache ) ;

				CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator = t_Cache->Begin ();

				while ( ! t_Iterator.Null () )
				{
					ServiceCacheElement *t_Element = t_Iterator.GetElement () ;

					BOOL t_Equivalent = ( a_Key.m_Provider ) && ( t_Iterator.GetKey ().m_Provider ) && ( wcscmp ( a_Key.m_Provider , t_Iterator.GetKey ().m_Provider ) == 0 ) ;
					if ( t_Equivalent )
					{
						t_Result = t_Element->QueryInterface (

							IID_CDecoupledAggregator_IWbemProvider ,
							( void ** ) & t_InitializingAggregator
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_InitializingAggregator->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_Result == S_FALSE )
								{
									t_IndependantCall = FALSE ;
								}
							}

							break ;
						}
					}

					t_Iterator.Increment () ;
				}
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				wchar_t *t_NamespacePath = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: GetNamespacePath ( 

					Direct_GetNamespacePath () , 
					t_NamespacePath
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					CInterceptor_IWbemServices_Interceptor *t_RepositoryStub = new CInterceptor_IWbemServices_Interceptor ( m_Allocator , a_RepositoryService ) ;
					if ( t_RepositoryStub )
					{
						t_RepositoryStub->AddRef () ;

						// Do not care about failure case
						if (e_StatusCode_Success == m_SvcWrappersContainer.EnQueue((IWbemServices *)t_RepositoryStub))
							t_RepositoryStub->AddRef();

						CInterceptor_IWbemServices_Interceptor *t_FullStub = new CInterceptor_IWbemServices_Interceptor ( m_Allocator , a_FullService ) ;
						if ( t_FullStub )
						{
							t_FullStub->AddRef () ;

							// Do not care about failure case
            				if (e_StatusCode_Success == m_SvcWrappersContainer.EnQueue((IWbemServices *)t_FullStub))
            					t_FullStub->AddRef();


							CDecoupledAggregator_IWbemProvider *t_Aggregator = NULL ;

							try
							{
								t_Aggregator = new CDecoupledAggregator_IWbemProvider ( 

									m_Allocator , 
									this , 
									this ,
									t_RepositoryStub ,
									t_FullStub ,
									a_Key ,
									ProviderSubSystem_Globals :: s_InternalCacheTimeout ,
									a_Context ,
									a_Registration
								) ;

								if ( t_Aggregator == NULL ) 
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							catch ( Wmi_Heap_Exception &a_Exception )
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_CRITICAL_ERROR ;
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Aggregator->AddRef () ;

								_IWmiProviderInitialize *t_AggregatorInit = NULL ;
								t_Result = t_Aggregator->QueryInterface ( IID__IWmiProviderInitialize , ( void ** ) & t_AggregatorInit ) ;
								if ( SUCCEEDED ( t_Result ) )
								{
									CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
									if ( t_ProviderInitSink )
									{
										t_ProviderInitSink->AddRef () ;

										t_Result = t_ProviderInitSink->SinkInitialize () ;
										if ( SUCCEEDED ( t_Result ) ) 
										{
											CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
											if ( t_Sink )
											{
												t_Sink->AddRef () ;

												t_Result = t_AggregatorInit->Initialize (

													0 ,
													a_Context ,
													NULL ,
													( const BSTR ) a_User ,
													( const BSTR ) a_Locale ,
													( const BSTR ) t_NamespacePath ,
													t_RepositoryStub ,
													t_FullStub ,
													t_Sink
												) ;

												if ( SUCCEEDED ( t_Result ) )
												{
													t_ProviderInitSink->Wait () ;

													t_Result = t_ProviderInitSink->GetResult () ;
													if ( SUCCEEDED ( t_Result ) )
													{
													}
												}

												t_Sink->Release () ; 
											}
											else
											{
												t_Result = WBEM_E_OUT_OF_MEMORY ;
											}
										}

										t_ProviderInitSink->Release () ;
									}
									else
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}


									t_AggregatorInit->Release () ;
								}

								if ( SUCCEEDED ( t_Result ) )
								{
									if ( t_IndependantCall )
									{
										WmiStatusCode t_StatusCode = Insert ( 

											*t_Aggregator ,
											t_Iterator
										) ;

										if ( t_StatusCode == e_StatusCode_Success ) 
										{
											localLock.UnLock () ;

											if ( t_InitializingAggregator )
											{
												t_Result = t_InitializingAggregator->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
												if ( SUCCEEDED ( t_Result ) )
												{
													if ( t_Result == S_FALSE )
													{
													}
													else
													{
														if ( SUCCEEDED ( t_Result = t_InitializingAggregator->GetInitializeResult () ) )
														{
														}
														else
														{
															t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
														}	
													}
												}
											}

											if ( SUCCEEDED ( t_Result ) )
											{
												t_Result = Load (

													t_Aggregator ,
													a_Context ,
													( BSTR ) a_Name ,
													( BSTR ) ( a_Registration.PerUserInitialization () ? a_User : NULL ) ,
													( BSTR ) ( a_Registration.PerLocaleInitialization () ? a_Locale : NULL ) ,
													( BSTR ) t_NamespacePath
												) ;

												if ( SUCCEEDED ( t_Result ) )
												{
													t_Result = t_Aggregator->QueryInterface (

														a_RIID ,
														a_Interface
													) ;
												}

												if ( FAILED ( t_Result ) )
												{
													WmiStatusCode t_StatusCode = CWbemGlobal_IWmiProviderController :: Shutdown ( a_Key ) ; 

													t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
												}
											}

											t_Aggregator->SetInitialized ( t_Result ) ;
										}
										else
										{
											localLock.UnLock () ;
										}
									}
									else
									{
										localLock.UnLock () ;

										t_Result = t_Aggregator->QueryInterface (

											a_RIID ,
											a_Interface
										) ;
									}
								}
								else
								{
									localLock.UnLock () ;
								}

								t_Aggregator->Release () ;
							}
							else
							{
								localLock.UnLock () ;
							}

							t_FullStub->Release () ;
						}
						else
						{
							localLock.UnLock () ;

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

						t_RepositoryStub->Release () ;
					}
					else
					{
						localLock.UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					delete [] t_NamespacePath ;
				}
				else
				{
					localLock.UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				localLock.UnLock () ;
			}

			if ( t_InitializingAggregator )
			{
				t_InitializingAggregator->Release () ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: GetDecoupledProvider (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope,
	LPCWSTR a_Name ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK;
	try 
	{
		IWbemPath *t_Scope = NULL ;

		if ( a_Scope ) 
		{
			t_Result = CoCreateInstance (

				CLSID_WbemDefPath ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IWbemPath ,
				( void ** )  & t_Scope
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Scope->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Scope ) ;
			}
		}

		CServerObject_ProviderSubSystem *t_SubSystem = NULL ;
		IWbemServices *t_RepositoryService = NULL ;
		IWbemServices *t_FullService = NULL ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = Direct_GetSubSystem ()->QueryInterface ( IID_CWbemProviderSubSystem , ( void ** ) & t_SubSystem ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_SubSystem->GetWmiRepositoryService ( 
				
					Direct_GetNamespacePath () , 
					( const BSTR ) a_User,
					( const BSTR ) a_Locale ,
					t_RepositoryService
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = t_SubSystem->GetWmiService ( 
					
						Direct_GetNamespacePath () , 
						( const BSTR ) a_User ,
						( const BSTR ) a_Locale ,
						t_FullService
					) ;
				}
			}
		}

		CServerObject_ProviderRegistrationV1 *t_Registration = new CServerObject_ProviderRegistrationV1 ;
		if ( t_Registration )
		{
			t_Registration->AddRef () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Registration->SetContext ( 

				a_Context ,
				Direct_GetNamespacePath () , 
				t_RepositoryService
			) ;
			
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_InternalCacheTimeout ) ;

				t_Result = t_Registration->Load ( 

					e_All ,
					t_Scope , 
					a_Name
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Registration->GetComRegistration ().Enabled () ) 
					{
						if ( ProviderSubSystem_Globals :: CheckGuidTag ( t_Registration->GetClsid () ) )
						{
							t_Result = WBEM_E_PROVIDER_DISABLED ;
						}
					}
					else
					{
						t_Result = WBEM_E_PROVIDER_DISABLED ;
					}
				}
				else
				{
					if ( t_Result == WBEM_E_NOT_FOUND )
					{
						t_Result = WBEM_E_PROVIDER_NOT_FOUND ;
					}	
					else
					{
						t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
					}
				}
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			try
			{
				ProviderCacheKey t_Key ( 

					a_Name , 
					e_Hosting_Decoupled ,
					NULL ,
					true ,
					NULL ,
					a_User ,
					a_Locale 
				) ;

				t_Result = InternalFindAggregatedDecoupledProvider ( 

					t_RepositoryService ,
					t_FullService ,
					*t_Registration ,
					t_Key ,
					a_Flags ,
					a_Context ,
					a_User ,
					a_Locale ,
					a_Scope,
					a_Name ,
					a_RIID , 
					a_Interface 
				) ;
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( t_Scope )
		{
			t_Scope->Release () ;
		}

		if ( t_RepositoryService )
		{
			t_RepositoryService->Release () ;
		}

		if ( t_FullService )
		{
			t_FullService->Release () ;
		}

		if ( t_SubSystem )
		{
			t_SubSystem->Release () ;
		}

		if ( t_Registration )
		{
			t_Registration->Release () ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: InternalGetProvider ( 

	IWbemServices *a_RepositoryService ,
	IWbemServices *a_FullService ,
	_IWmiProviderHost *a_Host ,
	_IWmiProviderFactory *a_Factory ,
	CInterceptor_IWbemProvider *a_Interceptor ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	ProviderCacheKey &a_Key ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	LPCWSTR a_Name ,
	void **a_Unknown ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		DWORD t_ProcessIdentifier = 0 ;
		if ( a_Host )
		{
			t_Result = a_Host->GetProcessIdentifier ( & t_ProcessIdentifier ) ;
		}

		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				HANDLE t_IdentifyHandle = NULL ;

				switch ( a_Registration.GetHosting () )
				{
					case e_Hosting_SharedLocalSystemHost:
					case e_Hosting_SharedLocalSystemHostOrSelfHost:
					{
						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
						
							IID__IWmiProviderFactory , 
							a_Factory , 
							t_Proxy , 
							t_Revert , 
							t_ProcessIdentifier , 
							t_IdentifyHandle ,
							ProviderSubSystem_Common_Globals :: s_Token_All_Access_System_ACE ,
							ProviderSubSystem_Common_Globals :: s_System_ACESize
						) ;
					}
					break ;

					case e_Hosting_SharedLocalServiceHost:
					{
						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
						
							IID__IWmiProviderFactory , 
							a_Factory , 
							t_Proxy , 
							t_Revert , 
							t_ProcessIdentifier , 
							t_IdentifyHandle ,
							ProviderSubSystem_Common_Globals :: s_Token_All_Access_LocalService_ACE ,
							ProviderSubSystem_Common_Globals :: s_LocalService_ACESize
						) ;
					}
					break ;

					case e_Hosting_SharedNetworkServiceHost:
					{
						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
						
							IID__IWmiProviderFactory , 
							a_Factory , 
							t_Proxy , 
							t_Revert , 
							t_ProcessIdentifier , 
							t_IdentifyHandle ,
							ProviderSubSystem_Common_Globals :: s_Token_All_Access_NetworkService_ACE ,
							ProviderSubSystem_Common_Globals :: s_NetworkService_ACESize
	 					) ;
					}
					break ;

					default:
					{
						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
						
							IID__IWmiProviderFactory , 
							a_Factory , 
							t_Proxy , 
							t_Revert
						) ;
					}
					break ;
				}

				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					WmiInternalContext t_InternalContext ;
					ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

					t_Result = a_Factory->GetProvider ( 

						t_InternalContext ,
						a_Flags ,
						a_Context ,
						a_TransactionIdentifier ,
						a_User ,
						a_Locale ,
						a_Scope ,
						a_Name ,
						IID_IUnknown , 
						a_Unknown
					) ;

					DEBUGTRACE((LOG_PROVSS,"    LOCAL GetProvider(%S) hr = %08x\n",a_Name,t_Result));
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						_IWmiProviderFactory *t_FactoryProxy = ( _IWmiProviderFactory * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_FactoryProxy ,
							RPC_C_AUTHN_LEVEL_DEFAULT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							IUnknown *t_Unknown = NULL ;

							WmiInternalContext t_InternalContext ;
							t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyHandle ;
							t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

							t_Result = t_FactoryProxy->GetProvider ( 

								t_InternalContext ,
								a_Flags ,
								a_Context ,
								a_TransactionIdentifier ,
								a_User ,
								a_Locale ,
								a_Scope ,
								a_Name ,
								IID_IUnknown , 
								a_Unknown
							) ;

    						DEBUGTRACE((LOG_PROVSS,"    PROXY GetProvider(%S) hr = %08x\n",a_Name,t_Result));
						}

						if ( t_IdentifyHandle )
						{
							HRESULT t_Result = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 
							
								t_Proxy , 
								t_Revert ,
								t_ProcessIdentifier , 
								t_IdentifyHandle
							) ;
						}
						else
						{
							HRESULT t_Result = ProviderSubSystem_Common_Globals :: RevertProxyState ( 
							
								t_Proxy , 
								t_Revert
							) ;
						}
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: InternalGetProviderViaProxyRoute ( 

	IWbemServices *a_RepositoryService ,
	IWbemServices *a_FullService ,
	CInterceptor_IWbemProvider *a_Interceptor ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	Enum_Hosting a_Hosting ,
	LPCWSTR a_HostingGroup ,
	ProviderCacheKey &a_Key ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	LPCWSTR a_Name ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
	HRESULT t_Result = S_OK ;

	DEBUGTRACE((LOG_PROVSS,"+ CServerObject_BindingFactory::InternalGetProviderViaProxyRoute\n"));

	try
	{
		_IWmiProviderHost *t_Host = NULL ;
		_IWmiProviderFactory *t_Factory = NULL ;

		t_Result = Create (

			a_Registration ,
			a_Hosting ,
			a_HostingGroup ,
			a_User ,
			& t_Host ,
			& t_Factory ,
			a_Context
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			_IWmiProviderFactoryInitialize *t_Initializer = NULL ;

			t_Result = t_Factory->QueryInterface ( IID__IWmiProviderFactoryInitialize , ( void ** ) & t_Initializer ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
			
				CInterceptor_IWbemServices_Interceptor *t_RepositoryStub = new CInterceptor_IWbemServices_Interceptor (
				
					m_Allocator , 
					a_RepositoryService
				) ;

				if ( t_RepositoryStub )
				{
					t_RepositoryStub->AddRef () ;

					t_Result = t_RepositoryStub->ServiceInitialize () ;
					if ( SUCCEEDED ( t_Result ) )
					{

						CInterceptor_IWbemServices_Interceptor *t_FullStub = new CInterceptor_IWbemServices_Interceptor (
						
							m_Allocator , 
							a_FullService
						) ;


						if ( t_FullStub )
						{
							t_FullStub->AddRef () ;

							t_Result = t_FullStub->ServiceInitialize () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Initializer->Initialize (

									NULL ,
									this ,
									a_Flags ,
									a_Context ,
									Direct_GetNamespace () ,
									t_RepositoryStub ,
									t_FullStub 
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									IUnknown *t_Unknown = NULL ;

									t_Result = InternalGetProvider ( 

										t_RepositoryStub ,
										t_FullStub ,
										t_Host ,
										t_Factory ,
										a_Interceptor ,
										a_Registration ,
										a_Key ,
										a_Flags ,
										a_Context ,
										a_TransactionIdentifier ,
										a_User ,
										a_Locale ,
										a_Scope ,
										a_Name ,
										( void ** ) & t_Unknown ,
										a_RIID , 
										a_Interface 
									) ;

									DEBUGTRACE((LOG_PROVSS,"   InternalGetProvider hr = %08x\n",t_Result ));

									if ( SUCCEEDED ( t_Result ) )
									{
										t_Result = a_Interceptor->SetProvider ( t_Host , t_Unknown ) ;
										if ( SUCCEEDED ( t_Result )	)
										{
											t_Result = InitializeHostedService (

												a_Interceptor ,
												t_Unknown
											) ;

											if ( SUCCEEDED ( t_Result ) )
											{
												t_Result = a_Interceptor->QueryInterface (

													a_RIID ,
													a_Interface
												) ;

												if ( FAILED ( t_Result ) )
												{
													t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
												}
											}
										}

										t_Unknown->Release () ;
									}
								}
							}

							t_FullStub->Release () ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_RepositoryStub->Release () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				t_Initializer->Release () ;
			}

			t_Factory->Release () ;

			if ( t_Host )
			{
				t_Host->Release () ;
			}
			
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	DEBUGTRACE((LOG_PROVSS,"- CServerObject_BindingFactory::InternalGetProviderViaProxyRoute hr = %08x\n",t_Result));

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: InternalFindProvider ( 

	IWbemServices *a_RepositoryService ,
	IWbemServices *a_FullService ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	Enum_Hosting a_Hosting ,
	LPCWSTR a_HostingGroup ,
	ProviderCacheKey &a_Key ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	LPCWSTR a_Name ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator ;

		AutoLockGuard<CServerObject_BindingFactory> localLock(*this) ;

		WmiStatusCode t_StatusCode = Find ( a_Key , t_Iterator ) ;
		
		DEBUGTRACE((LOG_PROVSS,"   Find() StatusCode %08x\n",t_StatusCode));
		
		if ( t_StatusCode == e_StatusCode_Success )
		{
			ServiceCacheElement *t_Element = t_Iterator.GetElement () ;

			localLock.UnLock () ;

			CInterceptor_IWbemProvider *t_Interceptor = NULL ;

			t_Result = t_Element->QueryInterface (

				IID_CInterceptor_IWbemProvider ,
				( void ** ) & t_Interceptor
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interceptor->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Result == S_FALSE )
					{
						t_Result = t_Element->QueryInterface (

							a_RIID ,
							a_Interface
						) ;

						t_Interceptor->Release () ;
						t_Element->Release () ;

						return t_Result ;
					}

					if ( SUCCEEDED ( t_Result = t_Interceptor->GetInitializeResult () ) )
					{
						t_Result = t_Element->QueryInterface (

							a_RIID ,
							a_Interface
						) ;

						if ( FAILED ( t_Result ) )
						{
							t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
						}
					}
					else
					{
						t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
					}
				}

				t_Interceptor->Release () ;
			}
			else
			{
				t_Result = WBEM_E_UNEXPECTED ;
			}

			t_Element->Release () ;
		}
		else
		{
			BOOL t_ReEntrancy = ( a_Registration.GetInitializationReentrancy () == e_InitializationReentrancy_Clsid ) ;
			t_ReEntrancy = t_ReEntrancy || ( a_Registration.GetInitializationReentrancy () == e_InitializationReentrancy_Namespace ) ;

			CInterceptor_IWbemProvider *t_InitializingInterceptor = NULL ;

			BOOL t_IndependantCall = TRUE ;

			if ( t_ReEntrancy )
			{
				CWbemGlobal_IWmiProviderController_Cache *t_Cache = NULL ;
				GetCache ( t_Cache ) ;

				CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator = t_Cache->Begin ();

				while ( ! t_Iterator.Null () )
				{
					ServiceCacheElement *t_Element = t_Iterator.GetElement () ;

					BOOL t_Equivalent = ( a_Key.m_Provider ) && ( t_Iterator.GetKey ().m_Provider ) && ( wcscmp ( a_Key.m_Provider , t_Iterator.GetKey ().m_Provider ) == 0 ) ;
					if ( t_Equivalent )
					{
						t_Result = t_Element->QueryInterface (

							IID_CInterceptor_IWbemProvider ,
							( void ** ) & t_InitializingInterceptor
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_InitializingInterceptor->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_Result == S_FALSE )
								{
									t_IndependantCall = FALSE ;
								}
							}

							break ;
						}
					}

					t_Iterator.Increment () ;
				}
			}

			CInterceptor_IWbemProvider *t_Interceptor = NULL ;

			try
			{
				t_Interceptor = new CInterceptor_IWbemProvider ( 

					m_Allocator , 
					this , 
					a_Key ,
					a_Registration.GetUnloadTimeoutMilliSeconds () ,
					a_Context ,
					a_Registration
				) ;

				if ( t_Interceptor ) 
				{
					t_Interceptor->AddRef () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemProviderInit *t_InterceptorInit = NULL ;

				t_Result = t_Interceptor->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & t_InterceptorInit ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
					if ( t_ProviderInitSink )
					{
						t_ProviderInitSink->AddRef () ;

						t_Result = t_ProviderInitSink->SinkInitialize () ;
						if ( SUCCEEDED ( t_Result ) ) 
						{
							CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
							if ( t_Sink )
							{
								t_Sink->AddRef () ;

								t_Result = t_InterceptorInit->Initialize (

									NULL ,
									0 ,
									m_Namespace ,
									NULL ,
									NULL ,
									NULL ,
									t_Sink    
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_ProviderInitSink->Wait () ;

									t_Result = t_ProviderInitSink->GetResult () ;
								}

								DEBUGTRACE((LOG_PROVSS,"  IWbemProviderInit::Initialize hr = %08x\n",t_Result));

								t_Sink->Release () ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}

						t_ProviderInitSink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					t_InterceptorInit->Release () ;
				}
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IndependantCall )
				{
					WmiStatusCode t_StatusCode = e_StatusCode_Success;
					
					if ( a_Registration.GetUnloadTimeoutMilliSeconds() != 0 ) 
					{
					    t_StatusCode = Insert (*t_Interceptor, t_Iterator);
					}

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						localLock.UnLock () ;

						t_Result = InternalGetProviderViaProxyRoute ( 

							a_RepositoryService ,
							a_FullService ,
							t_Interceptor ,
							a_Registration ,
							a_Hosting ,
							a_HostingGroup ,
							a_Key ,
							a_Flags ,
							a_Context ,
							a_TransactionIdentifier ,
							a_User ,
							a_Locale ,
							a_Scope ,
							a_Name ,
							a_RIID , 
							a_Interface 
						) ;

						if ( FAILED ( t_Result ) )
						{
							WmiStatusCode t_StatusCode = CWbemGlobal_IWmiProviderController :: Shutdown ( a_Key ) ; 
						}

						t_Interceptor->SetInitialized ( t_Result ) ;
					}
					else
					{
						localLock.UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					localLock.UnLock () ;

					t_Result = t_Interceptor->QueryInterface (

						a_RIID ,
						a_Interface
					) ;
				}
			}
			else
			{
				localLock.UnLock () ;
			}

			if ( t_Interceptor )
			{
				t_Interceptor->Release () ;
			}

			if ( t_InitializingInterceptor )
			{
				t_InitializingInterceptor->Release () ;
			}
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: GetProvider ( 

	WmiInternalContext a_InternalContext ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	LPCWSTR a_Name ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif
#ifdef WMI_PRIVATE_DBG
#ifdef DBG
    CTestNullTokenOnScope Test(__LINE__,__FILE__);
#endif
#endif


    DEBUGTRACE((LOG_PROVSS,"+ CServerObject_BindingFactory::GetProvider User %S Locale %S Scope %S Name %S\n",a_User,a_Locale,a_Scope,a_Name));

	HRESULT t_Result = S_OK ;

	try 
	{
		ProviderCacheKey t_Key ( 

			a_Name , 
			e_Hosting_SharedNetworkServiceHost ,
			CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedNetworkServiceHost ,
			true ,
			a_TransactionIdentifier ,
			NULL ,
			NULL
		) ;

		t_Result = FindProvider (

			a_Context ,
			t_Key , 
			FALSE ,
			a_RIID , 
			a_Interface ,
			a_User ,
			a_Locale
		) ;

		DEBUGTRACE((LOG_PROVSS,"  FindProvider hr = %08x\n",t_Result));

		if ( SUCCEEDED ( t_Result ) )
		{
		}
		else
		{
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				CServerObject_ProviderSubSystem *t_SubSystem = NULL ;
				IWbemServices *t_RepositoryService = NULL ;
				IWbemServices *t_FullService = NULL ;

				t_Result = Direct_GetSubSystem ()->QueryInterface ( IID_CWbemProviderSubSystem , ( void ** ) & t_SubSystem ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_SubSystem->GetWmiRepositoryService (
					
						Direct_GetNamespacePath () , 
						( const BSTR ) a_User ,
						( const BSTR ) a_Locale ,
						t_RepositoryService
					) ;

					if ( SUCCEEDED ( t_Result ) ) 
					{
						t_Result = t_SubSystem->GetWmiService (
						
							Direct_GetNamespacePath () ,
							( const BSTR ) a_User ,
							( const BSTR ) a_Locale ,
							t_FullService
						) ;
					}
				}

				IWbemContext *t_Context = NULL ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_Context == NULL )
					{
						t_Result = CoCreateInstance (

							CLSID_WbemContext ,
							NULL ,
							CLSCTX_INPROC_SERVER ,
							IID_IWbemContext ,
							( void ** )  & t_Context
						) ;
					}
				}

				IWbemPath *t_Scope = NULL ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_Scope ) 
					{
						t_Result = CoCreateInstance (

							CLSID_WbemDefPath ,
							NULL ,
							CLSCTX_INPROC_SERVER ,
							IID_IWbemPath ,
							( void ** )  & t_Scope
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Scope->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Scope ) ;
						}
					}
				}

				CServerObject_ProviderRegistrationV1 *t_Registration = new CServerObject_ProviderRegistrationV1 ;
				if ( t_Registration )
				{
					t_Registration->AddRef () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
					
				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = t_Registration->SetContext ( 

						a_Context ? a_Context : t_Context ,
						Direct_GetNamespacePath () , 
						t_RepositoryService
					) ;
					
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Registration->Load ( 

							e_All ,
							t_Scope , 
							a_Name
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_Registration->GetComRegistration ().Enabled () ) 
							{
								if ( ProviderSubSystem_Globals :: CheckGuidTag ( t_Registration->GetClsid () ) )
								{
									t_Result = WBEM_E_PROVIDER_DISABLED ;
								}
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND )
							{
								t_Result = WBEM_E_PROVIDER_NOT_FOUND ;
							}	
							else
							{
								t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
							}
						}

						if (t_Registration->GetUnloadTimeoutMilliSeconds()==DEFAULT_PROVIDER_TIMEOUT)  
						if ( t_Registration->ObjectProvider () )
						{
							if ( t_Registration->EventProvider () )
							{
								t_Registration->SetUnloadTimeoutMilliSeconds (
									ProviderSubSystem_Globals :: s_ObjectCacheTimeout < ProviderSubSystem_Globals :: s_EventCacheTimeout ? 
										ProviderSubSystem_Globals :: s_EventCacheTimeout :	ProviderSubSystem_Globals :: s_ObjectCacheTimeout
								) ;
							}
							else
							{
								t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_ObjectCacheTimeout ) ;
							}
						}
						else
						{
							if ( t_Registration->EventProvider () )
							{
								t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_EventCacheTimeout ) ;
							}
						}
					}
				}

				if ( t_Scope ) 
				{
					t_Scope->Release () ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					LPCWSTR t_HostingGroup = NULL ;
					Enum_Hosting t_Hosting = e_Hosting_Undefined ;
					t_Result = GetHosting ( *t_Registration , a_Context ? a_Context : t_Context , t_Hosting , t_HostingGroup ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						try
						{
							ProviderCacheKey t_Key ( 

								a_Name , 
								t_Hosting ,
								t_HostingGroup ,
								true ,
								a_TransactionIdentifier ,
								t_Registration->PerUserInitialization () ? a_User : NULL ,
								t_Registration->PerLocaleInitialization () ? a_Locale : NULL
							) ;

							switch ( t_Hosting )
							{
								case e_Hosting_Decoupled:
								{
									t_Result = InternalFindAggregatedDecoupledProvider ( 

										t_RepositoryService ,
										t_FullService ,
										*t_Registration ,
										t_Key ,
										a_Flags ,
										a_Context ? a_Context : t_Context ,
										a_User ,
										a_Locale ,
										a_Scope,
										a_Name ,
										a_RIID , 
										a_Interface 
									) ;
								}
								break ;

								default:
								{
									t_Result = InternalFindProvider ( 

										t_RepositoryService ,
										t_FullService ,
										*t_Registration ,
										t_Hosting ,
										t_HostingGroup ,
										t_Key ,
										a_Flags ,
										a_Context ? a_Context : t_Context ,
										a_TransactionIdentifier ,
										a_User ,
										a_Locale ,
										a_Scope ,
										a_Name ,
										a_RIID , 
										a_Interface 
									) ;
								}
								break;
							}
						}
						catch ( Wmi_Heap_Exception &a_Exception )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
						catch ( Wmi_Structured_Exception t_StructuredException )
						{
							t_Result = WBEM_E_FAILED ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
						}
						catch ( ... )
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
				}

				if ( t_RepositoryService )
				{
					t_RepositoryService->Release () ;
				}

				if ( t_FullService )
				{
					t_FullService->Release () ;
				}

				if ( t_SubSystem )
				{
					t_SubSystem->Release () ;
				}

				if ( t_Registration )
				{
					t_Registration->Release () ;
				}

				if ( t_Context )
				{
					t_Context->Release () ;
				}
			}
		}
	}
	catch ( Wmi_Heap_Exception &a_Exception )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_FAILED ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

    DEBUGTRACE((LOG_PROVSS,"- CServerObject_BindingFactory::GetProvider hr = %08x\n",t_Result));
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: GetHostedProvider ( 

	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	LPCWSTR a_Name ,
	ULONG a_Host ,
	LPCWSTR a_HostingGroup ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif
	HRESULT t_Result = S_OK;

	try 
	{
		ProviderCacheKey t_Key ( 

			a_Name , 
			a_Host ,
			a_HostingGroup ,
			true ,
			a_TransactionIdentifier ,
			NULL ,
			NULL
		) ;

		t_Result = FindProvider (

			a_Context ,
			t_Key , 
			TRUE ,
			a_RIID , 
			a_Interface ,
			a_User ,
			a_Locale
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
		}
		else
		{
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				CServerObject_ProviderSubSystem *t_SubSystem = NULL ;
				IWbemServices *t_RepositoryService = NULL ;
				IWbemServices *t_FullService = NULL ;

				t_Result = Direct_GetSubSystem ()->QueryInterface ( IID_CWbemProviderSubSystem , ( void ** ) & t_SubSystem ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_SubSystem->GetWmiRepositoryService (
					
						Direct_GetNamespacePath () , 
						( const BSTR ) a_User ,
						( const BSTR ) a_Locale ,
						t_RepositoryService
					) ;

					if ( SUCCEEDED ( t_Result ) ) 
					{
						t_Result = t_SubSystem->GetWmiService (
						
							Direct_GetNamespacePath () ,
							( const BSTR ) a_User ,
							( const BSTR ) a_Locale ,
							t_FullService
						) ;
					}
				}

				IWbemPath *t_Scope = NULL ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_Scope ) 
					{
						t_Result = CoCreateInstance (

							CLSID_WbemDefPath ,
							NULL ,
							CLSCTX_INPROC_SERVER ,
							IID_IWbemPath ,
							( void ** )  & t_Scope
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Scope->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Scope ) ;
						}
					}
				}

				CServerObject_ProviderRegistrationV1 *t_Registration = new CServerObject_ProviderRegistrationV1 ;
				if ( t_Registration )
				{
					t_Registration->AddRef () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
					
				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = t_Registration->SetContext ( 

						a_Context ,
						Direct_GetNamespacePath () , 
						t_RepositoryService
					) ;
					
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Registration->Load ( 

							e_All ,
							t_Scope , 
							a_Name
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_Registration->GetComRegistration ().Enabled () ) 
							{
								if ( ProviderSubSystem_Globals :: CheckGuidTag ( t_Registration->GetClsid () ) )
								{
									t_Result = WBEM_E_PROVIDER_DISABLED ;
								}
							}

							if (t_Registration->GetUnloadTimeoutMilliSeconds()==DEFAULT_PROVIDER_TIMEOUT)  
							{
							if ( t_Registration->ObjectProvider () )
							{
								if ( t_Registration->EventProvider () )
								{
									t_Registration->SetUnloadTimeoutMilliSeconds (
									
										ProviderSubSystem_Globals :: s_ObjectCacheTimeout < ProviderSubSystem_Globals :: s_EventCacheTimeout ? 
										
											ProviderSubSystem_Globals :: s_EventCacheTimeout :	ProviderSubSystem_Globals :: s_ObjectCacheTimeout
									) ;
								}
								else
								{
									t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_ObjectCacheTimeout ) ;
								}
							}
							else
							{
								if ( t_Registration->EventProvider () )
								{
									t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_EventCacheTimeout ) ;
								}
							}
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND )
							{
								t_Result = WBEM_E_PROVIDER_NOT_FOUND ;
							}	
							else
							{
								t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
							}
						}
					}
				}

				if ( t_Scope ) 
				{
					t_Scope->Release () ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					try
					{
						ProviderCacheKey t_Key ( 

							a_Name , 
							a_Host ,
							a_HostingGroup ,
							true ,
							a_TransactionIdentifier ,
							t_Registration->PerUserInitialization () ? a_User : NULL ,
							t_Registration->PerLocaleInitialization () ? a_Locale : NULL
						) ;

						switch ( a_Host )
						{
							case e_Hosting_Decoupled:
							{
								t_Result = InternalFindAggregatedDecoupledProvider ( 

									t_RepositoryService ,
									t_FullService ,
									*t_Registration ,
									t_Key ,
									a_Flags ,
									a_Context ,
									a_User ,
									a_Locale ,
									a_Scope,
									a_Name ,
									a_RIID , 
									a_Interface 
								) ;
							}
							break ;

							default:
							{
								t_Result = InternalFindProvider ( 

									t_RepositoryService ,
									t_FullService ,
									*t_Registration ,
									( Enum_Hosting ) a_Host ,
									a_HostingGroup ,
									t_Key ,
									a_Flags ,
									a_Context ,
									a_TransactionIdentifier ,
									a_User ,
									a_Locale ,
									a_Scope ,
									a_Name ,
									a_RIID	 , 
									a_Interface 
								) ;
							}
							break;
						}
					}
					catch ( Wmi_Heap_Exception &a_Exception )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
					catch ( Wmi_Structured_Exception t_StructuredException )
					{
						t_Result = WBEM_E_FAILED ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
					}
					catch ( ... )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}

				if ( t_RepositoryService )
				{
					t_RepositoryService->Release () ;
				}

				if ( t_FullService )
				{
					t_FullService->Release () ;
				}

				if ( t_SubSystem )
				{
					t_SubSystem->Release () ;
				}

				if ( t_Registration )
				{
					t_Registration->Release () ;
				}
			}
		}
	}
	catch ( Wmi_Heap_Exception &a_Exception )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_FAILED ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: GetAggregatedClassProvider ( 

	IWbemServices *a_RepositoryService ,
	IWbemServices *a_FullService ,
	ProviderCacheKey &a_Key ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	IWbemClassObject *a_Class ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		AutoLockGuard<CServerObject_BindingFactory> localLock(*this) ;

		CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator ;

		WmiStatusCode t_StatusCode = Find ( a_Key , t_Iterator ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			ServiceCacheElement *t_Element = t_Iterator.GetElement () ;

			localLock.UnLock () ;

			CAggregator_IWbemProvider *t_Aggregator = NULL ;

			t_Result = t_Element->QueryInterface (

				IID_CAggregator_IWbemProvider ,
				( void ** ) & t_Aggregator
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Aggregator->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Result == S_FALSE )
					{
						t_Result = t_Element->QueryInterface (

							a_RIID ,
							a_Interface
						) ;

						t_Aggregator->Release () ;
						t_Element->Release () ;

						return t_Result ;
					}

					if ( SUCCEEDED ( t_Result = t_Aggregator->GetInitializeResult () ) )
					{
						t_Result = t_Element->QueryInterface (

							a_RIID ,
							a_Interface
						) ;

						if ( FAILED ( t_Result ) )
						{
							t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
						}
					}
					else
					{
						t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
					}
				}

				t_Aggregator->Release () ;
			}
			else
			{
				t_Result = WBEM_E_UNEXPECTED ;
			}

			t_Element->Release () ;
		}
		else
		{
			CAggregator_IWbemProvider *t_Aggregator = NULL ;

			CInterceptor_IWbemServices_Interceptor *t_RepositoryStub = new CInterceptor_IWbemServices_Interceptor ( m_Allocator , a_RepositoryService ) ;
			if ( t_RepositoryStub )
			{
				t_RepositoryStub->AddRef () ;

				CInterceptor_IWbemServices_Interceptor *t_FullStub = new CInterceptor_IWbemServices_Interceptor ( m_Allocator , a_FullService ) ;
				if ( t_FullStub )
				{
					t_FullStub->AddRef () ;

					t_Aggregator = new CAggregator_IWbemProvider ( 

						m_Allocator , 
						this , 
						this ,
						t_RepositoryStub ,
						t_FullStub ,
						a_Key ,
						ProviderSubSystem_Globals :: s_InternalCacheTimeout ,
						a_Context 
					) ;

					if ( t_Aggregator ) 
					{
						t_Aggregator->AddRef () ;

						wchar_t *t_NamespacePath = NULL ;

						t_Result = ProviderSubSystem_Common_Globals :: GetNamespacePath ( 

							Direct_GetNamespacePath () , 
							t_NamespacePath
						) ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							_IWmiProviderInitialize *t_AggregatorInit = NULL ;
							t_Result = t_Aggregator->QueryInterface ( IID__IWmiProviderInitialize , ( void ** ) & t_AggregatorInit ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
								if ( t_ProviderInitSink )
								{
									t_ProviderInitSink->AddRef () ;

									t_Result = t_ProviderInitSink->SinkInitialize () ;
									if ( SUCCEEDED ( t_Result ) ) 
									{
										CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
										if ( t_Sink )
										{
											t_Sink->AddRef () ;

											t_Result = t_AggregatorInit->Initialize (

												0 ,
												a_Context ,
												NULL ,
												( const BSTR ) a_User ,
												( const BSTR ) a_Locale ,
												( const BSTR ) t_NamespacePath ,
												t_RepositoryStub ,
												t_FullStub ,
												t_Sink
											) ;

											if ( SUCCEEDED ( t_Result ) )
											{
												t_ProviderInitSink->Wait () ;

												t_Result = t_ProviderInitSink->GetResult () ;
											}

											t_Sink->Release () ;
										}
										else
										{
											t_Result = WBEM_E_OUT_OF_MEMORY ;
										}
									}

									t_ProviderInitSink->Release () ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								t_AggregatorInit->Release () ;
							}

							delete [] t_NamespacePath ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					t_FullStub->Release () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				t_RepositoryStub->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				WmiStatusCode t_StatusCode = Insert ( 

					*t_Aggregator ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					localLock.UnLock () ;

					t_Result = t_Aggregator->Enum_ClassProviders ( a_Context ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Aggregator->QueryInterface (

							a_RIID ,
							a_Interface
						) ;

						if ( FAILED ( t_Result ) )
						{
							t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
						}
					}

					t_Aggregator->SetInitialized ( t_Result ) ;
				}
				else
				{
					localLock.UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				localLock.UnLock () ;
			}

			if ( t_Aggregator )
			{
				t_Aggregator->Release () ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: WaitProvider ( 

	IWbemContext *a_Context ,
	REFIID a_RIID , 
	void **a_Interface ,
	ServiceCacheElement *a_Element ,
	_IWmiProviderInitialize *a_Initializer 
)
{
	HRESULT t_Result = a_Initializer->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Result == S_FALSE )
		{
			t_Result = a_Element->QueryInterface (

				a_RIID ,
				a_Interface
			) ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result = a_Initializer->GetInitializeResult () ) )
			{
				t_Result = a_Element->QueryInterface (

					a_RIID ,
					a_Interface
				) ;

				if ( FAILED ( t_Result ) )
				{
					t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
				}
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: SearchSpecificProvider ( 

	IWbemContext *a_Context ,
	ProviderCacheKey &a_Key ,
	REFIID a_RIID , 
	void **a_Interface ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale
)
{

	AutoLockGuard<CServerObject_BindingFactory> localLock(*this) ;

	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProviderController_Cache *t_Cache = NULL ;
	GetCache ( t_Cache ) ;

	CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator ;

	try
	{
		ProviderCacheKey t_Key ( 

			a_Key.m_Provider , 
			e_Hosting_Undefined ,
			NULL ,
			false ,
			NULL ,
			NULL ,
			NULL
		) ;

		WmiStatusCode t_StatusCode = t_Cache->FindNext ( t_Key , t_Iterator ) ;
		if ( t_StatusCode != e_StatusCode_Success )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}
	catch ( Wmi_Heap_Exception &a_Exception )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		BOOL t_Equal = FALSE ;

		if ( t_Iterator.GetKey ().m_Provider )
		{
			if ( a_Key.m_Provider ) 
			{
				if ( wbem_wcsicmp ( t_Iterator.GetKey ().m_Provider , a_Key.m_Provider ) == 0 ) 
				{
					t_Equal = TRUE ;
				}
			}
		}

		if ( t_Equal )
		{
			ServiceCacheElement *t_Element = t_Iterator.GetElement () ;

			_IWmiProviderInitialize *t_Initializer = NULL ;

			t_Result = t_Element->QueryInterface (

				IID__IWmiProviderInitialize	,
				( void ** ) & t_Initializer
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_PerUser ;
				t_Initializer->IsPerUserInitialization ( & t_PerUser ) ;

				BOOL t_PerLocale ;
				t_Initializer->IsPerLocaleInitialization ( & t_PerLocale ) ;

				DWORD t_Hosting ;
				t_Initializer->GetHosting ( & t_Hosting ) ;

				BSTR t_HostingGroup ;
				t_Initializer->GetHostingGroup ( & t_HostingGroup ) ;

				BOOL t_Internal ;
				t_Initializer->IsInternal ( & t_Internal ) ;

				try
				{
					ProviderCacheKey t_SpecificKey ( 

						a_Key.m_Provider , 
						t_Hosting ,
						t_HostingGroup ,
						t_Internal ? false : true ,
						NULL ,
						t_PerUser ? a_User : NULL ,
						t_PerLocale ? a_Locale : NULL 
					) ;

					SysFreeString ( t_HostingGroup ) ;

					WmiStatusCode t_StatusCode = Find ( t_SpecificKey , t_Iterator ) ;
					if ( t_StatusCode != e_StatusCode_Success )
					{
						t_Result = WBEM_E_NOT_FOUND ;
					}
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					ServiceCacheElement *t_Element = t_Iterator.GetElement () ;

					localLock.UnLock () ;

					_IWmiProviderInitialize *t_SpecificInitializer = NULL ;

					t_Result = t_Element->QueryInterface (

						IID__IWmiProviderInitialize	,
						( void ** ) & t_SpecificInitializer
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = WaitProvider ( 

							a_Context ,
							a_RIID , 
							a_Interface ,
							t_Element ,
							t_SpecificInitializer
						) ;

						t_SpecificInitializer->Release () ;
					}
					else
					{
						t_Result = WBEM_E_UNEXPECTED ;
					}

					t_Element->Release () ;
				}
				else
				{
					localLock.UnLock () ;
				}

				t_Initializer->Release () ;
			}
			else
			{
				localLock.UnLock () ;
			}
		}
		else
		{
			localLock.UnLock () ;

			t_Result = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		localLock.UnLock () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: FindProvider ( 

	IWbemContext *a_Context ,
	ProviderCacheKey &a_Key ,
	BOOL a_SpecificProvider ,
	REFIID a_RIID , 
	void **a_Interface ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale
)
{
	HRESULT t_Result = S_OK;

	AutoLockGuard<CServerObject_BindingFactory> localLock(*this) ;

	CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator ;

	WmiStatusCode t_StatusCode = Find ( a_Key , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		ServiceCacheElement *t_Element = t_Iterator.GetElement () ;

		localLock.UnLock () ;

		_IWmiProviderInitialize *t_Initializer = NULL ;

		t_Result = t_Element->QueryInterface (

			IID__IWmiProviderInitialize	,
			( void ** ) & t_Initializer
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_PerUser ;
			t_Initializer->IsPerUserInitialization ( & t_PerUser ) ;
			BOOL t_PerLocale ;
			t_Initializer->IsPerLocaleInitialization ( & t_PerLocale ) ;

			if ( t_PerUser || t_PerLocale )
			{
				t_Result = WBEM_E_NOT_FOUND ;
			}
			else
			{
				t_Result = WaitProvider ( 

					a_Context ,
					a_RIID , 
					a_Interface ,
					t_Element ,
					t_Initializer 
				) ;
			}

			t_Initializer->Release () ;
		}
		else
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}

		t_Element->Release () ;
	}
	else
	{
		t_Result = WBEM_E_NOT_FOUND ;

		localLock.UnLock () ;
	}	

	if ( t_Result == WBEM_E_NOT_FOUND )
	{
		if ( ! a_SpecificProvider )
		{ 
			t_Result = SearchSpecificProvider (

				a_Context ,
				a_Key ,
				a_RIID , 
				a_Interface ,
				a_User ,
				a_Locale
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: GetClassProvider (

    LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	IWbemClassObject *a_Class ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK;
	try 
	{
		ProviderCacheKey t_Key ( 

			NULL , 
			e_Hosting_WmiCore ,
			NULL ,
			false ,
			NULL ,
			a_User ,
			a_Locale 
		) ;

		t_Result = FindProvider (

			a_Context ,
			t_Key , 
			TRUE ,
			a_RIID , 
			a_Interface ,
			a_User ,
			a_Locale
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
		}
		else
		{
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				CServerObject_ProviderSubSystem *t_SubSystem = NULL ;
				IWbemServices *t_RepositoryService = NULL ;
				IWbemServices *t_FullService = NULL ;

				t_Result = Direct_GetSubSystem ()->QueryInterface ( IID_CWbemProviderSubSystem , ( void ** ) & t_SubSystem ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_SubSystem->GetWmiRepositoryService (
					
						Direct_GetNamespacePath () ,
						( const BSTR ) a_User ,
						( const BSTR ) a_Locale ,
						t_RepositoryService
					) ;
					if ( SUCCEEDED ( t_Result ) ) 
					{
						t_Result = t_SubSystem->GetWmiService (
						
							Direct_GetNamespacePath () , 
							( const BSTR ) a_User ,
							( const BSTR ) a_Locale ,
							t_FullService
						) ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = GetAggregatedClassProvider ( 

						t_RepositoryService ,
						t_FullService ,
						t_Key ,
						a_Flags ,
						a_Context ,
						a_User ,
						a_Locale ,
						a_Scope ,
						a_Class ,
						a_RIID , 
						a_Interface 
					) ;
				}

				if ( t_RepositoryService )
				{
					t_RepositoryService->Release () ;
				}

				if ( t_FullService )
				{
					t_FullService->Release () ;
				}

				if ( t_SubSystem )
				{
					t_SubSystem->Release () ;
				}
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}
	catch ( Wmi_Heap_Exception t_HeapException )
	{	
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: GetDynamicPropertyResolver (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK;	
	try 
	{
		CServerObject_ProviderSubSystem *t_SubSystem = NULL ;
		t_Result = Direct_GetSubSystem ()->QueryInterface ( IID_CWbemProviderSubSystem , ( void ** ) & t_SubSystem ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemServices *t_FullService = NULL ;
			t_Result = t_SubSystem->GetWmiService ( 
			
				Direct_GetNamespacePath () , 
				( const BSTR ) a_User ,
				( const BSTR ) a_Locale ,
				t_FullService
			) ;

			if ( SUCCEEDED ( t_Result ) ) 
			{
#ifdef INTERNAL_IDENTIFY

				CInterceptor_IWbemServices_Stub *t_Stub = new CInterceptor_IWbemServices_Stub (
				
					NULL ,
					m_Allocator , 
					t_FullService
				) ;
#else
				CInterceptor_IWbemServices_Interceptor *t_Stub = new CInterceptor_IWbemServices_Interceptor (
				
					m_Allocator , 
					t_FullService
				) ;

#endif

				if ( t_Stub )
				{
					t_Stub->AddRef () ;

					t_Result = t_Stub->ServiceInitialize () ;
					if ( SUCCEEDED ( t_Result ) )
					{
						CServerObject_DynamicPropertyProviderResolver *t_Resolver = new CServerObject_DynamicPropertyProviderResolver (

							m_Allocator ,
							this ,
							t_Stub
						) ;

						if ( t_Resolver ) 
						{
							t_Resolver->AddRef () ;

							wchar_t *t_NamespacePath = NULL ;

							t_Result = ProviderSubSystem_Common_Globals :: GetNamespacePath ( 

								Direct_GetNamespacePath () , 
								t_NamespacePath
							) ;

							if ( SUCCEEDED ( t_Result ) ) 
							{
								IWbemProviderInit *t_ProviderInit = NULL ;

								t_Result = t_Resolver->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & t_ProviderInit ) ;
								if ( SUCCEEDED ( t_Result ) )
								{
									CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
									if ( t_ProviderInitSink )
									{
										t_ProviderInitSink->AddRef () ;

										t_Result = t_ProviderInitSink->SinkInitialize () ;
										if ( SUCCEEDED ( t_Result ) ) 
										{
											CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
											if ( t_Sink )
											{
												t_Sink->AddRef () ;

												t_Result = t_ProviderInit->Initialize (

													( const BSTR ) a_User ,
													0 ,
													( const BSTR ) t_NamespacePath ,
													( const BSTR ) a_Locale ,
													t_Stub ,
													a_Context ,
													t_Sink    
												) ;

												if ( SUCCEEDED ( t_Result ) )
												{
													t_ProviderInitSink->Wait () ;

													t_Result = t_ProviderInitSink->GetResult () ;
													if ( SUCCEEDED ( t_Result ) )
													{
														t_Result = t_Resolver->QueryInterface ( a_RIID , a_Interface ) ;
													}
												}

												t_Sink->Release () ;
											}
											else
											{
												t_Result = WBEM_E_OUT_OF_MEMORY ;
											}
										}

										t_ProviderInitSink->Release () ;
									}
									else
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}

									t_ProviderInit->Release () ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								delete [] t_NamespacePath ;
							}

							t_Resolver->Release () ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_Stub->Release () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				t_FullService->Release () ;

			}

			t_SubSystem->Release () ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Get (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemObjectSink *a_Sink
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	wchar_t *t_Locale = NULL ; 
	wchar_t *t_User = NULL ; 
	wchar_t *t_Namespace = NULL ; 
	GUID *t_TransactionIdentifier = NULL ; 
	wchar_t *t_Provider = NULL ; 
	wchar_t *t_HostingGroup = NULL ;
	DWORD t_HostingSpecification = 0 ;

	try 
	{
		if ( wbem_wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
		{
			IWbemPath *t_PathObject = NULL ;

			t_Result = CoCreateInstance (

				CLSID_WbemDefPath ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IWbemPath ,
				( void ** )  & t_PathObject
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_PathObject->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_Path ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					IWbemPathKeyList *t_Keys = NULL ;

					t_Result = t_PathObject->GetKeyList (

						& t_Keys 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						ULONG t_KeyCount = 0 ;
						t_Result = t_Keys->GetCount (

							& t_KeyCount 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_KeyCount == 7 )
							{
								for ( ULONG t_Index = 0 ; ( t_Index < t_KeyCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
								{
									wchar_t t_Key [ 32 ] ; 
									ULONG t_KeyLength = 32 ;
									ULONG t_KeyValueLength = 0 ;
									ULONG t_KeyType = 0 ;

									t_Result = t_Keys->GetKey (

										t_Index ,
										0 ,
										& t_KeyLength ,
										t_Key ,
										& t_KeyValueLength ,
										NULL ,
										& t_KeyType
									) ;

									if ( SUCCEEDED ( t_Result ) ) 
									{
										if ( t_KeyType == CIM_STRING )
										{
											wchar_t *t_KeyValue = new wchar_t [ t_KeyValueLength ] ;
											if ( t_KeyValue )
											{
												t_Result = t_Keys->GetKey (

													t_Index ,
													0 ,
													& t_KeyLength ,
													t_Key ,
													& t_KeyValueLength ,
													t_KeyValue ,
													& t_KeyType
												) ;

												if ( SUCCEEDED ( t_Result ) )
												{
													if ( wbem_wcsicmp ( L"Namespace" , t_Key ) == 0 )
													{
														t_Namespace = t_KeyValue ;
													}
													else if ( wbem_wcsicmp ( L"Provider" , t_Key ) == 0 )
													{
														t_Provider = t_KeyValue ;
													}
													else if ( wbem_wcsicmp ( L"HostingGroup" , t_Key ) == 0 )
													{
														if ( wbem_wcsicmp ( t_KeyValue , L"" ) != 0 ) 
														{
															t_HostingGroup = t_KeyValue ;
														}
														else
														{
															delete [] t_KeyValue ;
														}
													}
													else if ( wbem_wcsicmp ( L"Locale" , t_Key ) == 0 )
													{
														if ( wbem_wcsicmp ( t_KeyValue , L"" ) != 0 ) 
														{
															t_Locale = t_KeyValue ;
														}
														else
														{
															delete [] t_KeyValue ;
														}
													}
													else if ( wbem_wcsicmp ( L"User" , t_Key ) == 0 )
													{
														if ( wbem_wcsicmp ( t_KeyValue , L"" ) != 0 ) 
														{
															t_User = t_KeyValue ;
														}
														else
														{
															delete [] t_KeyValue ;
														}
													}
													else if ( wbem_wcsicmp ( L"TransactionIdentifier" , t_Key ) == 0 )
													{
														if ( wbem_wcsicmp ( t_KeyValue , L"" ) != 0 ) 
														{
															t_TransactionIdentifier = new GUID ;
															if ( t_TransactionIdentifier )
															{
																t_Result = CLSIDFromString (

																	t_KeyValue ,
																	t_TransactionIdentifier
																) ;

																if ( FAILED ( t_Result ) )
																{
																	t_Result = WBEM_E_INVALID_OBJECT_PATH ;
																}
															}
														}
														else
														{
															delete [] t_KeyValue ;
														}
													}
													else
													{
														delete [] t_KeyValue ;

														t_Result = WBEM_E_INVALID_OBJECT_PATH ;
													}
												}
												else
												{
													t_Result = WBEM_E_CRITICAL_ERROR ;
												}
											}
											else
											{
												t_Result = WBEM_E_OUT_OF_MEMORY ;
											}	
										}
										else if ( t_KeyType == CIM_SINT32 )
										{
											DWORD t_KeyValue = 0 ;
											t_Result = t_Keys->GetKey (

												t_Index ,
												0 ,
												& t_KeyLength ,
												t_Key ,
												& t_KeyValueLength ,
												& t_KeyValue ,
												& t_KeyType
											) ;

											if ( SUCCEEDED ( t_Result ) )
											{
												if ( wbem_wcsicmp ( L"HostingSpecification" , t_Key ) == 0 )
												{
													t_HostingSpecification = t_KeyValue ;
												}
												else
												{
													t_Result = WBEM_E_INVALID_OBJECT_PATH ;
												}
											}
											else
											{
												t_Result = WBEM_E_CRITICAL_ERROR ;
											}
										}
										else
										{
											t_Result = WBEM_E_INVALID_OBJECT_PATH ;
										}
									}
									else
									{
										t_Result = WBEM_E_CRITICAL_ERROR ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_INVALID_OBJECT_PATH ;
							}
						}
                        t_Keys->Release();
                    }
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				t_PathObject->Release () ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		
			if ( SUCCEEDED ( t_Result ) ) 
			{
				ProviderCacheKey t_Key ( 

					t_Provider , 
					t_HostingSpecification ,
					t_HostingGroup ,
					true ,
					t_TransactionIdentifier ,
					t_User ,
					t_Locale
				) ;

				CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator ;

				AutoLockGuard<CServerObject_BindingFactory> localLock(*this) ;

				WmiStatusCode t_StatusCode = Find ( t_Key , t_Iterator ) ;

				if ( t_StatusCode == e_StatusCode_Success )
				{
					ServiceCacheElement *t_Service = t_Iterator.GetElement () ;

					localLock.UnLock () ;

					_IWmiProviderConfiguration *t_Configuration = NULL ;
					t_Result = t_Service->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_Configuration ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						_IWmiProviderInitialize *t_Initialize = NULL ;
						t_Result = t_Service->QueryInterface ( IID__IWmiProviderInitialize , ( void ** ) & t_Initialize ) ;
						if ( SUCCEEDED ( t_Result ) ) 
						{
							HRESULT t_TempResult = 	t_Initialize->WaitProvider ( 
							
								a_Context , 
								DEFAULT_PROVIDER_LOAD_TIMEOUT
							) ;

							if ( ( t_TempResult == S_OK ) && ( SUCCEEDED ( t_Initialize->GetInitializeResult () ) ) )
							{
								t_Result = t_Configuration->Get ( 

									a_Service ,
									a_Flags, 
									a_Context,
 									a_Class, 
									a_Path,
									a_Sink 
								) ;
							}
							else
							{
								t_Result = WBEM_E_NOT_FOUND ;
							}

							t_Initialize->Release () ;
						}

						t_Configuration->Release () ;
					}
					else
					{
						t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
					}

					t_Service->Release () ;
				}
				else
				{
					localLock.UnLock () ;

					t_Result = WBEM_E_NOT_FOUND ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_CLASS ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}
	catch ( Wmi_Heap_Exception t_HeapException )
	{	
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_Locale )
	{
		delete [] t_Locale ;
	}

	if ( t_User )
	{
		delete [] t_User ;
	}

	if ( t_Namespace ) 
	{
		delete [] t_Namespace ;
	} 

	if ( t_TransactionIdentifier ) 
	{
		delete [] t_TransactionIdentifier ;
	}

	if ( t_Provider )
	{
		delete [] t_Provider ;
	}

	if ( t_HostingGroup )
	{
		delete [] t_HostingGroup ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Set (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_OldObject ,
	IWbemClassObject *a_NewObject  

)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		AutoLockGuard<CServerObject_BindingFactory> localLock(*this) ;
		
		CWbemGlobal_IWmiProviderController_Cache *t_Cache = NULL ;
		GetCache ( t_Cache ) ;

		if ( t_Cache->Size () )
		{
			_IWmiProviderCache **t_Elements = new _IWmiProviderCache * [ t_Cache->Size () ] ;
			if ( t_Elements )
			{
				for ( ULONG t_Index = 0 ; t_Index < t_Cache->Size () ; t_Index ++ )
				{
					t_Elements [ t_Index ] = NULL ;
				}

				CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator = t_Cache->Begin ();

				ULONG t_Count = 0 ;
				while ( SUCCEEDED ( t_Result ) && ( ! t_Iterator.Null () ) )
				{
					try
					{
						ProviderCacheKey t_Key = t_Iterator.GetKey () ;
						ServiceCacheElement *t_Element = t_Iterator.GetElement () ;

						t_Iterator.Increment () ;

						if ( t_Key.m_Provider && ( wbem_wcsicmp ( a_Provider , t_Key.m_Provider ) == 0 ) )
						{
							t_Result = t_Element->QueryInterface ( 

								IID__IWmiProviderCache , 
								( void ** ) & t_Elements [ t_Count ]
							) ;

							WmiStatusCode t_StatusCode = CWbemGlobal_IWmiProviderController :: Shutdown ( t_Key ) ; 
						} 

						t_Count ++ ;
					}
					catch ( Wmi_Heap_Exception &a_Exception )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}

				localLock.UnLock () ;

				for ( t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_Elements [ t_Index ] ) 
					{
						t_Result = t_Elements [ t_Index ]->ForceReload () ;

						t_Elements [ t_Index ]->Release () ;
					}
				}
	
				delete [] t_Elements ;
			}
			else
			{
				localLock.UnLock () ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			localLock.Lock () ;

			CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator = t_Cache->Begin ();
			while ( SUCCEEDED ( t_Result ) && ( ! t_Iterator.Null () ) )
			{
				try
				{
					ProviderCacheKey t_Key = t_Iterator.GetKey () ;

					t_Iterator.Increment () ;

					if ( t_Key.m_Provider == NULL )
					{
						WmiStatusCode t_StatusCode = CWbemGlobal_IWmiProviderController :: Shutdown ( t_Key ) ; 
					} 
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
		}

		localLock.UnLock () ;

		if ( a_OldObject )
		{
			GUID t_Clsid ;

			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;

			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			t_Result = a_OldObject->Get ( L"Clsid" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					t_Result = CLSIDFromString ( t_Variant.bstrVal , & t_Clsid ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						ProviderSubSystem_Globals :: DeleteGuidTag ( t_Clsid ) ;
					}
				}

				VariantClear ( & t_Variant ) ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Deleted (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_Object  
) 
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		AutoLockGuard<CServerObject_BindingFactory> localLock(*this) ;

		CWbemGlobal_IWmiProviderController_Cache *t_Cache = NULL ;
		GetCache ( t_Cache ) ;

		if ( t_Cache->Size () )
		{
			CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator = t_Cache->Begin ();

			while ( SUCCEEDED ( t_Result ) && ( ! t_Iterator.Null () ) )
			{
				try
				{
					ProviderCacheKey t_Key = t_Iterator.GetKey () ;

					t_Iterator.Increment () ;

					if ( t_Key.m_Provider && (wbem_wcsicmp ( a_Provider , t_Key.m_Provider ) == 0 ) )
					{
						WmiStatusCode t_StatusCode = CWbemGlobal_IWmiProviderController :: Shutdown ( t_Key ) ; 
					} 
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
		}

		localLock.UnLock () ;

		GUID t_Clsid ;

		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		t_Result = a_Object->Get ( L"Clsid" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BSTR )
			{
				t_Result = CLSIDFromString ( t_Variant.bstrVal , & t_Clsid ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					ProviderSubSystem_Globals :: DeleteGuidTag ( t_Clsid ) ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Enumerate (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	if ( wbem_wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
	{
		AutoLockGuard<CServerObject_BindingFactory> localLock(*this);

		CWbemGlobal_IWmiProviderController_Cache *t_Cache = NULL ;
		GetCache ( t_Cache ) ;

		if ( t_Cache->Size () )
		{
			CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator = t_Cache->Begin ();

			_IWmiProviderConfiguration **t_ControllerElements = new _IWmiProviderConfiguration * [ t_Cache->Size () ] ;
			if ( t_ControllerElements )
			{
				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				localLock.UnLock () ;

				try
				{
					BindingFactoryCacheKey t_Key = BindingFactoryCacheElement :: GetKey () ;
					VARIANT t_Variant ;
					VariantInit ( & t_Variant ) ;

					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( t_Key.m_Namespace ) ;

					for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
					{
						if ( t_ControllerElements [ t_Index ] )
						{
							_IWmiProviderInitialize *t_Initialize = NULL ;
							t_Result = t_ControllerElements [ t_Index ]->QueryInterface ( IID__IWmiProviderInitialize , ( void ** ) & t_Initialize ) ;
							if ( SUCCEEDED ( t_Result ) ) 
							{
								HRESULT t_TempResult = 	t_Initialize->WaitProvider ( 
								
									a_Context , 
									DEFAULT_PROVIDER_LOAD_TIMEOUT
								) ;

								if ( ( t_TempResult == S_OK ) && ( SUCCEEDED ( t_Initialize->GetInitializeResult () ) ) )
								{
									CWaitingObjectSink *t_Sink = new CWaitingObjectSink ( m_Allocator ) ;
									if ( t_Sink )
									{
										t_Sink->AddRef () ;

										t_Result = t_Sink->SinkInitialize () ;
										if ( SUCCEEDED ( t_Result ) )
										{
											t_Result = t_ControllerElements [ t_Index ]->Enumerate ( 

												a_Service ,
												a_Flags, 
												a_Context,
 												a_Class, 
												t_Sink 
											) ;

											t_Result = t_Sink->Wait ( INFINITE ) ;

											if ( SUCCEEDED ( t_Result ) )
											{
												t_Result = t_Sink->GetResult () ;
												if ( FAILED ( t_Result ) )
												{
												}
											}

											WmiQueue <IWbemClassObject *,8> &t_Queue = t_Sink->GetQueue () ;

											WmiStatusCode t_StatusCode = e_StatusCode_Success ;

											IWbemClassObject *t_Object = NULL ;
											while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
											{
												if ( SUCCEEDED ( t_Result ) )
												{
													t_Object->Put ( L"Namespace" , 0 , & t_Variant , 0 ) ;

													a_Sink->Indicate ( 1, & t_Object ) ;
												}

												t_Object->Release () ;
												t_StatusCode = t_Queue.DeQueue () ;
											}
										}

										t_Sink->Release () ;
									}
									else
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}	
								}

								t_Initialize->Release () ;
							}

							t_ControllerElements [ t_Index ]->Release () ;
						}
					}

					VariantClear ( & t_Variant ) ;
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				delete [] t_ControllerElements ;
			}
			else
			{
				localLock.UnLock () ;
			}
		}
		else
		{
			localLock.UnLock () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Shutdown (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	ULONG a_MilliSeconds
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Call (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,		
	LPCWSTR a_Method ,
	IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		if ( wbem_wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
		{
			wchar_t *t_Locale = NULL ; 
			wchar_t *t_User = NULL ; 
			wchar_t *t_Namespace = NULL ; 
			GUID *t_TransactionIdentifier = NULL ; 
			wchar_t *t_HostingGroup = NULL ; 
			wchar_t *t_Provider = NULL ; 
			DWORD t_HostingSpecification = 0 ;

			IWbemPath *t_PathObject = NULL ;

			t_Result = CoCreateInstance (

				CLSID_WbemDefPath ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IWbemPath ,
				( void ** )  & t_PathObject
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_PathObject->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_Path ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					IWbemPathKeyList *t_Keys = NULL ;

					t_Result = t_PathObject->GetKeyList (

						& t_Keys 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						ULONG t_KeyCount = 0 ;
						t_Result = t_Keys->GetCount (

							& t_KeyCount 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_KeyCount == 7 )
							{
								for ( ULONG t_Index = 0 ; ( t_Index < t_KeyCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
								{
									wchar_t t_Key [ 32 ] ; 
									ULONG t_KeyLength = 32 ;
									ULONG t_KeyValueLength = 0 ;
									ULONG t_KeyType = 0 ;

									t_Result = t_Keys->GetKey (

										t_Index ,
										0 ,
										& t_KeyLength ,
										t_Key ,
										& t_KeyValueLength ,
										NULL ,
										& t_KeyType
									) ;

									if ( SUCCEEDED ( t_Result ) ) 
									{
										if ( t_KeyType == CIM_STRING )
										{
											wchar_t *t_KeyValue = new wchar_t [ t_KeyValueLength ] ;
											if ( t_KeyValue )
											{
												t_Result = t_Keys->GetKey (

													t_Index ,
													0 ,
													& t_KeyLength ,
													t_Key ,
													& t_KeyValueLength ,
													t_KeyValue ,
													& t_KeyType
												) ;

												if ( SUCCEEDED ( t_Result ) )
												{
													if ( wbem_wcsicmp ( L"Namespace" , t_Key ) == 0 )
													{
														t_Namespace = t_KeyValue ;
													}
													else if ( wbem_wcsicmp ( L"Provider" , t_Key ) == 0 )
													{
														t_Provider = t_KeyValue ;
													}
													else if ( wbem_wcsicmp ( L"HostingGroup" , t_Key ) == 0 )
													{
														t_HostingGroup = t_KeyValue ;
													}
													else if ( wbem_wcsicmp ( L"Locale" , t_Key ) == 0 )
													{
														if ( wbem_wcsicmp ( t_KeyValue , L"" ) != 0 ) 
														{
															t_Locale = t_KeyValue ;
														}
														else
														{
															delete [] t_KeyValue ;
														}
													}
													else if ( wbem_wcsicmp ( L"User" , t_Key ) == 0 )
													{
														if ( wbem_wcsicmp ( t_KeyValue , L"" ) != 0 ) 
														{
															t_User = t_KeyValue ;
														}
														else
														{
															delete [] t_KeyValue ;
														}
													}
													else if ( wbem_wcsicmp ( L"TransactionIdentifier" , t_Key ) == 0 )
													{
														if ( wbem_wcsicmp ( t_KeyValue , L"" ) != 0 ) 
														{
															t_TransactionIdentifier = new GUID ;
															if ( t_TransactionIdentifier )
															{
																t_Result = CLSIDFromString (

																	t_KeyValue ,
																	t_TransactionIdentifier
																) ;

																if ( FAILED ( t_Result ) )
																{
																	t_Result = WBEM_E_INVALID_OBJECT_PATH ;
																}
															}
														}
														else
														{
															delete [] t_KeyValue ;
														}
													}
													else
													{
														delete [] t_KeyValue ;

														t_Result = WBEM_E_INVALID_OBJECT_PATH ;
													}
												}
												else
												{
													t_Result = WBEM_E_CRITICAL_ERROR ;
												}
											}
											else
											{
												t_Result = WBEM_E_OUT_OF_MEMORY ;
											}	
										}
										else if ( t_KeyType == CIM_SINT32 )
										{
											DWORD t_KeyValue = 0 ;
											t_Result = t_Keys->GetKey (

												t_Index ,
												0 ,
												& t_KeyLength ,
												t_Key ,
												& t_KeyValueLength ,
												& t_KeyValue ,
												& t_KeyType
											) ;

											if ( SUCCEEDED ( t_Result ) )
											{
												if ( wbem_wcsicmp ( L"HostingSpecification" , t_Key ) == 0 )
												{
													t_HostingSpecification = t_KeyValue ;
												}
												else
												{
													t_Result = WBEM_E_INVALID_OBJECT_PATH ;
												}
											}
											else
											{
												t_Result = WBEM_E_CRITICAL_ERROR ;
											}
										}
										else
										{
											t_Result = WBEM_E_INVALID_OBJECT_PATH ;
										}
									}
									else
									{
										t_Result = WBEM_E_CRITICAL_ERROR ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_INVALID_OBJECT_PATH ;
							}
						}
                        t_Keys->Release();
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				t_PathObject->Release () ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		
			if ( SUCCEEDED ( t_Result ) ) 
			{
				try
				{
					ProviderCacheKey t_Key ( 

						t_Provider , 
						t_HostingSpecification ,
						t_HostingGroup ,
						true ,
						t_TransactionIdentifier ,
						t_User ,
						t_Locale
					) ;

					CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator ;

					AutoLockGuard<CServerObject_BindingFactory> localLock(*this) ;

					WmiStatusCode t_StatusCode = Find ( t_Key , t_Iterator ) ;

					if ( t_StatusCode == e_StatusCode_Success )
					{
						ServiceCacheElement *t_Service = t_Iterator.GetElement () ;

						if ( wbem_wcsicmp ( a_Method , L"UnLoad" ) == 0 )
						{
							localLock.UnLock () ;

							_IWmiProviderLoad *t_Load = NULL ;

							t_Result = t_Service->QueryInterface ( IID__IWmiProviderLoad , ( void ** ) & t_Load ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								WmiStatusCode t_StatusCode = CWbemGlobal_IWmiProviderController :: Shutdown ( t_Key ) ; 

								t_Result = t_Load->Unload ( 

									0 ,
									a_Context
								) ;

								t_Load->Release () ;
							}
							else
							{
								t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
							}
						}
						else if ( ( wbem_wcsicmp ( a_Method , L"Suspend" ) == 0 ) || ( wbem_wcsicmp ( a_Method , L"Resume" ) == 0 ) )
						{
							localLock.UnLock () ;

							_IWmiProviderConfiguration *t_Configuration = NULL ;
							t_Result = t_Service->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_Configuration ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								_IWmiProviderInitialize *t_Initialize = NULL ;
								t_Result = t_Service->QueryInterface ( IID__IWmiProviderInitialize , ( void ** ) & t_Initialize ) ;
								if ( SUCCEEDED ( t_Result ) ) 
								{
									HRESULT t_TempResult = 	t_Initialize->WaitProvider ( 
									
										a_Context , 
										DEFAULT_PROVIDER_LOAD_TIMEOUT
									) ;

									if ( ( t_TempResult == S_OK ) && ( SUCCEEDED ( t_Initialize->GetInitializeResult () ) ) )
									{
										t_Result = t_Configuration->Call ( 

											a_Service ,
											a_Flags, 
											a_Context,
 											a_Class, 
											a_Path,
											a_Method,
											a_InParams,
											a_Sink 
										) ;
									}
									else
									{
										t_Result = WBEM_E_NOT_FOUND ;
									}

									t_Initialize->Release () ;
								}

								t_Configuration->Release () ;
							}
							else
							{
								t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
							}
						}
						else
						{
							localLock.UnLock () ;
						}

						t_Service->Release () ;
					}
					else
					{
						localLock.UnLock () ;

						t_Result = WBEM_E_NOT_FOUND ;
					}
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}

			if ( t_Locale )
			{
				delete [] t_Locale ;
			}

			if ( t_User )
			{
				delete [] t_User ;
			}

			if ( t_Namespace ) 
			{
				delete [] t_Namespace ;
			} 

			if ( t_TransactionIdentifier ) 
			{
				delete [] t_TransactionIdentifier ;
			}

			if ( t_Provider )
			{
				delete [] t_Provider ;
			}

			if ( t_HostingGroup )
			{
				delete [] t_HostingGroup ;
			}
		}
		else
		{
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Query (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
	WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
	VARIANT *a_Value 
)
{
	return WBEM_E_NOT_SUPPORTED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		AutoLockGuard<CServerObject_BindingFactory> localLock(*this) ;
		
		CWbemGlobal_IWmiProviderController_Cache *t_Cache = NULL ;
		GetCache ( t_Cache ) ;

		if ( t_Cache->Size () )
		{
			IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Cache->Size () ] ;
			if ( t_ShutdownElements )
			{
				CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator = t_Cache->Begin ();

				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				localLock.UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ShutdownElements [ t_Index ] ) 
					{
						t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;

						t_ShutdownElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ShutdownElements ;
			}
			else
			{
				localLock.UnLock () ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			localLock.UnLock () ;
		}

		CWbemGlobal_IWmiProviderController :: Shutdown () ;

       	localLock.Lock();
		ULONG t_Count = m_SvcWrappersContainer.Size();

		IUnknown ** t_ppUnks = 0;
		if (t_Count) t_ppUnks = new IUnknown *[t_Count];
		
		if (t_ppUnks)
		{
			for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
			{
				IUnknown * t_SvcWrap ;
				WmiStatusCode t_StatusCode = m_SvcWrappersContainer.Top ( t_SvcWrap ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					t_ppUnks[t_Index] = t_SvcWrap;
					t_StatusCode = m_SvcWrappersContainer.DeQueue () ;
				}
			}
		}
       	localLock.UnLock();
        
        if (t_ppUnks)
        {
            for (ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++)
            {
                CoDisconnectObject(t_ppUnks[t_Index],0);
                t_ppUnks[t_Index]->Release () ;
            }
            delete[] t_ppUnks;
        }


	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CServerObject_BindingFactory :: Strobe ( ULONG &a_NextStrobeDelta )
{
	return CWbemGlobal_IWmiProviderController :: Strobe ( a_NextStrobeDelta ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CServerObject_BindingFactory :: StrobeBegin ( const ULONG &a_Period )
{
	ULONG t_Timeout = ProviderSubSystem_Globals :: GetStrobeThread ().GetTimeout () ;
	ProviderSubSystem_Globals :: GetStrobeThread ().SetTimeout ( t_Timeout < a_Period ? t_Timeout : a_Period ) ;
	return e_StatusCode_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provhost.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvSubS.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <wbemint.h>

#include <HelperFuncs.h>
#include <Logging.h>

#include <CGlobals.h>
#include "Globals.h"
#include "ClassFac.h"
#include "ProvInSk.h"
#include "ProvLoad.h"
#include "ProvHost.h"
#include "ProvCache.h"
#include "ProvRMgr.h"
#include "Guids.h"
#include <tpwrap.cpp>

#ifdef WMIASLOCAL
#include "Main.h"
#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: AbnormalShutdown (

	HostCacheKey &a_Key
) 
{
	WmiStatusCode t_StatusCode = ProviderSubSystem_Globals :: GetHostController ()->Shutdown ( a_Key ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: CreateUsingToken (

	HostCacheKey &a_Key ,
	_IWmiProviderHost **a_Host ,
	_IWbemRefresherMgr **a_RefresherManager ,
	IWbemContext *a_Context 
)
{
	HRESULT t_Result = FindHost (

		a_Context , 
		a_Key ,
		IID__IWmiProviderHost ,
		( void ** ) a_Host
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = (*a_Host)->GetObject (

			CLSID__WbemHostedRefresherMgr ,
			0 ,
			NULL ,
			IID__IWbemRefresherMgr,
			( void ** ) a_RefresherManager 
		) ;

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
			{
				AbnormalShutdown ( a_Key ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: CreateUsingAccount (

	HostCacheKey &a_Key ,
	LPWSTR a_User ,
	LPWSTR a_Domain ,
	_IWmiProviderHost **a_Host ,
	_IWbemRefresherMgr **a_RefresherManager ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

/*
 *	Revert to LocalService 
 */

	CoRevertToSelf () ;

/*
 *	Logon the system defined Account
 */

	HANDLE t_ThreadToken = NULL ;

	BOOL t_Status = LogonUser (

		a_User ,
		a_Domain ,
		NULL ,
		LOGON32_LOGON_SERVICE ,
		LOGON32_PROVIDER_WINNT50,
        & t_ThreadToken 
	) ;

	if ( t_Status )
	{
		t_Status = ImpersonateLoggedOnUser ( t_ThreadToken ) ;
		if ( t_Status )
		{
			ProviderSubSystem_Common_Globals :: EnableAllPrivileges () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;

			DWORD t_LastError = GetLastError () ;
		}
	}
	else
	{
		t_Result = WBEM_E_ACCESS_DENIED ;

		DWORD t_LastError = GetLastError () ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = FindHost (

			a_Context , 
			a_Key ,
			IID__IWmiProviderHost ,
			( void ** ) a_Host
		) ;
	}

	RevertToSelf () ;

	if ( t_ThreadToken )
	{
		CloseHandle ( t_ThreadToken ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = (*a_Host)->GetObject (

			CLSID__WbemHostedRefresherMgr ,
			0 ,
			NULL ,
			IID__IWbemRefresherMgr,
			( void ** ) a_RefresherManager 
		) ;

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
			{
				AbnormalShutdown ( a_Key ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: CreateUsingToken (

	HostCacheKey &a_Key ,
	_IWmiProviderHost **a_Host ,
	_IWmiProviderFactory **a_Factory ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = FindHost (

		a_Context , 
		a_Key ,
		IID__IWmiProviderHost ,
		( void ** ) a_Host
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = (*a_Host)->GetObject (

			CLSID_WmiProviderHostedInProcFactory ,
			0 ,
			NULL ,
			IID__IWmiProviderFactory,
			( void ** ) a_Factory 
		) ;

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
			{
				AbnormalShutdown ( a_Key ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: CreateUsingAccount (

	HostCacheKey &a_Key ,
	LPWSTR a_User ,
	LPWSTR a_Domain ,
	_IWmiProviderHost **a_Host ,
	_IWmiProviderFactory **a_Factory ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

/*
 *	Revert to LocalService 
 */

	CoRevertToSelf () ;

/*
 *	Logon the system defined Account
 */

	HANDLE t_ThreadToken = NULL ;

	BOOL t_Status = LogonUser (

		a_User ,
		a_Domain ,
		NULL ,
		LOGON32_LOGON_SERVICE ,
		LOGON32_PROVIDER_WINNT50,
        & t_ThreadToken 
	) ;

	if ( t_Status )
	{
		t_Status = ImpersonateLoggedOnUser ( t_ThreadToken ) ;
		if ( t_Status )
		{
			ProviderSubSystem_Common_Globals :: EnableAllPrivileges () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;

			DWORD t_LastError = GetLastError () ;
		}
	}
	else
	{
		t_Result = WBEM_E_ACCESS_DENIED ;

		DWORD t_LastError = GetLastError () ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = FindHost (

			a_Context , 
			a_Key ,
			IID__IWmiProviderHost ,
			( void ** ) a_Host
		) ;
	}

	RevertToSelf () ;

	if ( t_ThreadToken )
	{
		CloseHandle ( t_ThreadToken ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = (*a_Host)->GetObject (

			CLSID_WmiProviderHostedInProcFactory ,
			0 ,
			NULL ,
			IID__IWmiProviderFactory,
			( void ** ) a_Factory 
		) ;

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
			{
				AbnormalShutdown ( a_Key ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: FindHost ( 

	IWbemContext *a_Context ,
	HostCacheKey &a_Key ,
	REFIID a_RIID , 
	void **a_Interface
)
{
	HRESULT t_Result = S_OK;

	*a_Interface = NULL ;

	ProviderSubSystem_Globals :: GetHostController ()->Lock () ;

	CWbemGlobal_IWmiHostController_Cache_Iterator t_Iterator ;

	WmiStatusCode t_StatusCode = ProviderSubSystem_Globals :: GetHostController ()->Find ( a_Key , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		HostCacheElement *t_Element = t_Iterator.GetElement () ;

		ProviderSubSystem_Globals :: GetHostController ()->UnLock () ;

		CServerObject_HostInterceptor *t_HostInterceptor = NULL ;

		t_Result = t_Element->QueryInterface (

			IID_CServerObject_HostInterceptor ,
			( void ** ) & t_HostInterceptor
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_HostInterceptor->WaitHost ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_HostInterceptor->GetInitializeResult () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Element->QueryInterface (

						a_RIID ,
						a_Interface
					) ;

					if ( FAILED ( t_Result ) )
					{
						t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
					}
				}
			}

			t_HostInterceptor->Release () ;
		}
		else
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}

		t_Element->Release () ;
	}
	else
	{
		CServerObject_HostInterceptor *t_HostInterceptor = new CServerObject_HostInterceptor ( 

			*ProviderSubSystem_Globals :: s_Allocator , 
			ProviderSubSystem_Globals :: GetHostController () , 
			a_Key ,
			ProviderSubSystem_Globals :: s_InternalCacheTimeout ,
			a_Context
		) ;

		if ( t_HostInterceptor ) 
		{
			t_HostInterceptor->AddRef () ;

			CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
			if ( t_ProviderInitSink )
			{
				t_ProviderInitSink->AddRef () ;

				t_Result = t_ProviderInitSink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = t_HostInterceptor->Initialize (

						NULL ,
						t_ProviderInitSink
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_ProviderInitSink->Wait () ;

						t_Result = t_ProviderInitSink->GetResult () ;
					}
				}

				t_ProviderInitSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			WmiStatusCode t_StatusCode = ProviderSubSystem_Globals :: GetHostController ()->Insert ( 

				*t_HostInterceptor ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				ProviderSubSystem_Globals :: GetHostController ()->UnLock () ;

				IUnknown *t_Host = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: CreateInstance (

					CLSID_WmiProviderHost ,
					NULL ,
					CLSCTX_LOCAL_SERVER | CLSCTX_ENABLE_AAA ,
					IID_IUnknown ,
					( void ** ) & t_Host 
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = t_HostInterceptor->SetHost ( t_Host ) ;
					t_Host->Release () ;
				}
			}
			else
			{
				ProviderSubSystem_Globals :: GetHostController ()->UnLock () ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			ProviderSubSystem_Globals :: GetHostController ()->UnLock () ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			DWORD t_ProcessIdentifier = 0 ;
			t_Result = t_HostInterceptor->GetProcessIdentifier ( & t_ProcessIdentifier ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				RevertToSelf () ;

				HANDLE t_Handle = OpenProcess (

					PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION | SYNCHRONIZE | PROCESS_SET_QUOTA | PROCESS_TERMINATE ,
					FALSE ,
					t_ProcessIdentifier
				) ;

				if ( t_Handle ) 
				{
					Task_ProcessTermination *t_Task = new Task_ProcessTermination ( *ProviderSubSystem_Globals :: s_Allocator , t_Handle , t_ProcessIdentifier ) ;
					if ( t_Task )
					{
							if (Dispatcher::registerHandlerOnce(*t_Task))
							{
								t_Result = ProviderSubSystem_Globals :: AssignProcessToJobObject ( t_Handle ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
							t_Task->Release();
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

				}
				else
				{
					DWORD t_LastError = GetLastError () ;

					t_Result = WBEM_E_ACCESS_DENIED ;
				}
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_HostInterceptor->QueryInterface (

					a_RIID ,
					a_Interface
				) ;
			}
		}

		if ( FAILED ( t_Result ) )
		{
			WmiStatusCode t_StatusCode = ProviderSubSystem_Globals :: GetHostController ()->Shutdown ( a_Key ) ; 
		}


		if ( t_HostInterceptor )
		{
			t_HostInterceptor->SetInitialized ( t_Result ) ;
			t_HostInterceptor->Release () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CServerObject_HostInterceptor :: CServerObject_HostInterceptor (

	WmiAllocator &a_Allocator ,
	CWbemGlobal_IWmiHostController *a_Controller , 
	const HostCacheKey &a_Key ,
	const ULONG &a_Period ,
	IWbemContext *a_InitializationContext

) :	HostCacheElement ( 

		a_Controller ,
		a_Key ,
		a_Period 
	) ,
	m_Allocator ( a_Allocator ) ,
	m_ProxyContainer ( m_Allocator , 2 , MAX_PROXIES ) ,
	m_Unknown ( NULL ) ,
	m_Host_IWmiProviderHost ( NULL ) ,
	m_Host_IWbemShutdown ( NULL ) ,
	m_ProcessIdentifier ( 0 ) ,
	m_UnInitialized ( 0 ) ,
	m_Initialized ( 0 ) ,
	m_InitializeResult ( S_OK ) ,
	m_InitializedEvent ( NULL ) , 
	m_InitializationContext ( a_InitializationContext )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_HostInterceptor_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_InitializationContext )
	{
		m_InitializationContext->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_HostInterceptor :: ~CServerObject_HostInterceptor ()
{
	if ( m_InitializationContext )
	{
		m_InitializationContext->Release () ;
	}

	if ( m_InitializedEvent )
	{
		CloseHandle ( m_InitializedEvent ) ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_HostInterceptor_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_HostInterceptor :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiProviderHost )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderHost * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;
	}
	else if ( iid == IID_CServerObject_HostInterceptor )
	{
		*iplpv = ( LPVOID ) ( CServerObject_HostInterceptor * ) this ;
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_HostInterceptor :: AddRef ()
{
	return HostCacheElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_HostInterceptor :: Release ()
{
	return HostCacheElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: Initialize (

	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_InitializedEvent = CreateEvent ( NULL , TRUE , FALSE , NULL ) ;
		if ( m_InitializedEvent == NULL )
		{
			t_Result = t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: SetHost ( IUnknown *a_Unknown )
{
	m_Unknown = a_Unknown ;
	m_Unknown->AddRef () ;

	HRESULT t_Result = m_Unknown->QueryInterface ( IID_IWbemShutdown , ( void ** ) & m_Host_IWbemShutdown ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = m_Unknown->QueryInterface ( IID__IWmiProviderHost , ( void ** ) & m_Host_IWmiProviderHost ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: SetInitialized ( HRESULT a_InitializeResult )
{
	m_InitializeResult = a_InitializeResult ;

	InterlockedExchange ( & m_Initialized , 1 ) ;

	if ( m_InitializedEvent )
	{
		SetEvent ( m_InitializedEvent ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: IsIndependant ( IWbemContext *a_Context )
{
	BOOL t_DependantCall = FALSE ;
	HRESULT t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_DependantCall == FALSE )
		{
		}
		else
		{
			return S_FALSE ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: WaitHost ( IWbemContext *a_Context , ULONG a_Timeout )
{
	HRESULT t_Result = S_OK ;

	if ( m_Initialized == 0 )
	{
		if ( WaitForSingleObject ( m_InitializedEvent , a_Timeout ) != WAIT_OBJECT_0 )
		{
			return WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CServerObject_HostInterceptor :: CallBackInternalRelease ()
{
	if ( InterlockedCompareExchange ( & m_UnInitialized ,  1 , 0 ) == 0 )
	{
		WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

		if ( m_Unknown )
		{
			m_Unknown->Release () ;
			m_Unknown = NULL ;
		}

		if ( m_Host_IWmiProviderHost )
		{
			m_Host_IWmiProviderHost->Release () ; 
			m_Host_IWmiProviderHost = NULL ;
		}

		if ( m_Host_IWbemShutdown )
		{
			m_Host_IWbemShutdown->Release () ;
			m_Host_IWbemShutdown = NULL ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: GetObject (

	REFCLSID a_Clsid ,
	long a_Flags ,
	IWbemContext *a_Context ,
	REFIID a_Riid ,
	void **a_Interface
)
{
	HRESULT t_Result = S_OK ;

	if ( m_Host_IWmiProviderHost )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Host__IWmiProviderHost , IID__IWmiProviderHost , m_Host_IWmiProviderHost , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Host_IWmiProviderHost->GetObject (

					a_Clsid ,
					a_Flags ,
					a_Context ,
					a_Riid ,
					a_Interface
				) ;
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					_IWmiProviderHost *t_Host = ( _IWmiProviderHost * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Host ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Host->GetObject (

								a_Clsid ,
								a_Flags ,
								a_Context ,
								a_Riid ,
								a_Interface
							) ;

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}	

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Host__IWmiProviderHost , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: GetProcessIdentifier ( DWORD *a_ProcessIdentifier )
{
	HRESULT t_Result = S_OK ;

	if ( m_Host_IWmiProviderHost )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Host__IWmiProviderHost , IID__IWmiProviderHost , m_Host_IWmiProviderHost , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Host_IWmiProviderHost->GetProcessIdentifier (

					a_ProcessIdentifier
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					m_ProcessIdentifier = *a_ProcessIdentifier ;
				}
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					_IWmiProviderHost *t_Host = ( _IWmiProviderHost * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Host ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Host->GetProcessIdentifier (

								a_ProcessIdentifier
							) ;

							if ( SUCCEEDED ( t_Result ) ) 
							{
								m_ProcessIdentifier = *a_ProcessIdentifier ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}	

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Host__IWmiProviderHost , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	if ( m_Host_IWbemShutdown )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Host_IWbemShutdown , IID_IWbemShutdown , m_Host_IWbemShutdown , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Host_IWbemShutdown->Shutdown (

					a_Flags ,
					a_MaxMilliSeconds ,
					a_Context
				) ;
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemShutdown *t_Host = ( IWbemShutdown * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Host ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Host->Shutdown (

								a_Flags ,
								a_MaxMilliSeconds ,
								a_Context
							) ;

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}	

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Host_IWbemShutdown , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CServerObject_Host :: CServerObject_Host (

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_Host_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_Host :: ~CServerObject_Host ()
{
	LONG hosts = InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_Host_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_Host :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiProviderHost )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderHost * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * )this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_Host :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_Host :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_Host :: GetObject (

	REFCLSID a_Clsid ,
	long a_Flags ,
	IWbemContext *a_Context ,
	REFIID a_Riid ,
	void **a_Interface
)
{
	if ( a_Clsid == CLSID_WmiProviderHostedInProcFactory )
	{
		IUnknown *lpunk = ( _IWmiProviderFactory * ) new CServerObject_RawFactory ( *ProviderSubSystem_Globals :: s_Allocator );
		if ( lpunk )
		{
			HRESULT t_Result = lpunk->QueryInterface ( a_Riid , a_Interface ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
			}
			else
			{
				delete lpunk ;		
			}	

			return t_Result ;		
		}
		else
		{
			return E_OUTOFMEMORY ;
		}
	}
	else if ( a_Clsid == CLSID__WbemHostedRefresherMgr )
	{
		IUnknown *lpunk = ( _IWbemRefresherMgr * ) new CServerObject_ProviderRefresherManager ( *ProviderSubSystem_Globals :: s_Allocator );
		if ( lpunk )
		{
			HRESULT t_Result = lpunk->QueryInterface ( a_Riid , a_Interface ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
			}
			else
			{
				delete lpunk ;		
			}	

			return t_Result ;		
		}
		else
		{
			return E_OUTOFMEMORY ;
		}
	}
	else
	{
		return CLASS_E_CLASSNOTAVAILABLE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_Host :: GetProcessIdentifier ( DWORD *a_ProcessIdentifier )
{
	HRESULT t_Result = S_OK ;

	if ( a_ProcessIdentifier ) 
	{
		*a_ProcessIdentifier = GetCurrentProcessId () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_Host :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provload.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include <PreComp.h>
#include <wbemint.h>
#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvResv.h"
#include "ProvFact.h"
#include "ProvSubS.h"
#include "ProvRegInfo.h"
#include "ProvLoad.h"
#include "ProvWsv.h"
#include "ProvWsvS.h"
#include "ProvInSk.h"
#include "StaThread.h"
#include "Guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_RawFactory :: CServerObject_RawFactory (

	WmiAllocator &a_Allocator 

) : 
	m_Allocator ( a_Allocator ) ,
	m_ReferenceCount ( 0 ) ,
	m_Flags ( 0 ) ,
	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_NamespacePath ( NULL ) ,
	m_Repository ( NULL )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_RawFactory_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_RawFactory::~CServerObject_RawFactory ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace )
	{
		delete [] m_Namespace ;
	}

	if ( m_NamespacePath ) 
	{
		m_NamespacePath->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}

	if ( m_Service ) 
	{
		m_Service->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_RawFactory_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_RawFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiProviderFactory )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderFactory * ) this ;		
	}	
	else if ( iid == IID__IWmiProviderFactoryInitialize )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderFactoryInitialize * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * )this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_RawFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_RawFactory :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: CheckInterfaceConformance (

	CServerObject_ProviderRegistrationV1 &a_Registration ,
	IUnknown *a_Unknown
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Registration.GetClassProviderRegistration ().Supported () && ( a_Registration.GetClassProviderRegistration ().InteractionType () != e_InteractionType_Push ) )
	{
		IWbemServices *t_Services = NULL ;

		t_Result = a_Unknown->QueryInterface ( IID_IWbemServices , ( void ** ) & t_Services ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Services->Release () ;
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_LOAD_FAILURE  ;
		}
	}

	if (	SUCCEEDED ( t_Result ) && (a_Registration.GetInstanceProviderRegistration ().Supported () ||
			a_Registration.GetMethodProviderRegistration ().Supported ()) )
	{
		IWbemServices *t_Services = NULL ;

		t_Result = a_Unknown->QueryInterface ( IID_IWbemServices , ( void ** ) & t_Services ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Services->Release () ;
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_LOAD_FAILURE  ;
		}
	}

	if (SUCCEEDED ( t_Result ) &&	a_Registration.GetEventProviderRegistration ().Supported () )
	{
		IWbemEventProvider *t_EventProvider = NULL ;

		t_Result = a_Unknown->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & t_EventProvider ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_EventProvider->Release () ;
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_LOAD_FAILURE  ;
		}
	}

	if ( SUCCEEDED ( t_Result ) && a_Registration.GetPropertyProviderRegistration ().Supported () )
	{
			IWbemPropertyProvider *t_PropertyProvider = NULL ;

			t_Result = a_Unknown->QueryInterface ( IID_IWbemPropertyProvider , ( void ** ) & t_PropertyProvider ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_PropertyProvider->Release () ;
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_LOAD_FAILURE  ;
			}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: CreateInstance ( 

	CServerObject_ProviderRegistrationV1 &a_Registration ,
	const CLSID &a_ReferenceClsid ,
	LPUNKNOWN a_OuterUnknown ,
	const DWORD &a_ClassContext ,
	const UUID &a_ReferenceInterfaceId ,
	void **a_ObjectInterface
)
{
	HRESULT t_Result = S_OK ;

	COAUTHIDENTITY t_AuthenticationIdentity ;
	ZeroMemory ( & t_AuthenticationIdentity , sizeof ( t_AuthenticationIdentity ) ) ;

	t_AuthenticationIdentity.User = NULL ; 
	t_AuthenticationIdentity.UserLength = 0 ;
	t_AuthenticationIdentity.Domain = NULL ; 
	t_AuthenticationIdentity.DomainLength = 0 ; 
	t_AuthenticationIdentity.Password = NULL ; 
	t_AuthenticationIdentity.PasswordLength = 0 ; 
	t_AuthenticationIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE ; 

	COAUTHINFO t_AuthenticationInfo ;
	ZeroMemory ( & t_AuthenticationInfo , sizeof ( t_AuthenticationInfo ) ) ;

    t_AuthenticationInfo.dwAuthnSvc = RPC_C_AUTHN_DEFAULT ;
    t_AuthenticationInfo.dwAuthzSvc = RPC_C_AUTHZ_DEFAULT ;
    t_AuthenticationInfo.pwszServerPrincName = NULL ;
    t_AuthenticationInfo.dwAuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT ;
    t_AuthenticationInfo.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE  ;
    t_AuthenticationInfo.dwCapabilities = EOAC_NONE ;
    t_AuthenticationInfo.pAuthIdentityData = NULL ;

	COSERVERINFO t_ServerInfo ;
	ZeroMemory ( & t_ServerInfo , sizeof ( t_ServerInfo ) ) ;

	t_ServerInfo.pwszName = NULL ;
    t_ServerInfo.dwReserved2 = 0 ;
    t_ServerInfo.pAuthInfo = & t_AuthenticationInfo ;

	IClassFactory *t_ClassFactory = NULL ;

	t_Result = CoGetClassObject (

		a_ReferenceClsid ,
		a_ClassContext ,
		& t_ServerInfo ,
		IID_IClassFactory ,
		( void ** )  & t_ClassFactory
	) ;
 
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_ClassFactory->CreateInstance (

			a_OuterUnknown ,
			a_ReferenceInterfaceId ,
			a_ObjectInterface 
		);	

                if (FAILED(t_Result))
        	    DEBUGTRACE((LOG_PROVSS,"    IClassFactory::CreateInstance hr = %08x\n",t_Result ));

		t_ClassFactory->Release () ;
	}
	else
	{
        WCHAR String[64];
        StringFromGUID2(a_ReferenceClsid,String,64);
        DEBUGTRACE((LOG_PROVSS,"    CoGetClassObject(%S,%08x) hr = %08x\n",String,a_ClassContext,t_Result ));
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: CreateServerSide ( 

	CServerObject_ProviderRegistrationV1 &a_Registration ,
	GUID *a_TransactionIdentifier ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	wchar_t *a_NamespacePath ,
	IUnknown **a_ProviderInterface
)
{
	HRESULT t_Result = S_OK ;

	wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;

	if ( a_TransactionIdentifier )
	{
		StringFromGUID2 ( *a_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
	}

	DEBUGTRACE((LOG_PROVSS,"    CreateServerSide hosting %d\n",a_Registration.GetHosting()));

	switch ( a_Registration.GetHosting () )
	{
		case e_Hosting_WmiCoreOrSelfHost:
		{
			if ( a_Registration.GetComRegistration ().GetClsidServer ().Loaded () == e_True )
			{
				t_Result = CreateInstance (

					a_Registration ,
					a_Registration.GetClsid () ,
					NULL ,
					CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
					IID_IUnknown ,
					( void ** ) a_ProviderInterface 
				) ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;

				*a_ProviderInterface = NULL ;
			}
		}
		break ;

		case e_Hosting_WmiCore:
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedNetworkServiceHost:
		case e_Hosting_SharedLocalServiceHost:
		{
			if ( a_Registration.GetComRegistration ().GetClsidServer ().Loaded () == e_True )
			{
				t_Result = CreateInstance (

					a_Registration ,
					a_Registration.GetClsid () ,
					NULL ,
					CLSCTX_INPROC_SERVER ,
					IID_IUnknown ,
					( void ** ) a_ProviderInterface 
				) ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;

				*a_ProviderInterface = NULL ;
			}
		}
		break ;

		case e_Hosting_SharedLocalSystemHostOrSelfHost:
		{
			if ( a_Registration.GetComRegistration ().GetClsidServer ().Loaded () == e_True )
			{
				t_Result = CreateInstance (

					a_Registration ,
					a_Registration.GetClsid () ,
					NULL ,
					CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_ENABLE_AAA ,
					IID_IUnknown ,
					( void ** ) a_ProviderInterface 
				) ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;

				*a_ProviderInterface = NULL ;
			}
		}
		break ;

		case e_Hosting_NonCom:
		{
			t_Result = CreateInstance	(

				a_Registration ,
				CLSID_NCProvider ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IUnknown ,
				( void ** ) a_ProviderInterface 
			) ;
		}
		break ;

		case e_Hosting_SelfHost:
		{
			if ( a_Registration.GetComRegistration ().GetClsidServer ().Loaded () == e_True )
			{
				t_Result = CreateInstance	(

					a_Registration ,
					a_Registration.GetClsid () ,
					NULL ,
					CLSCTX_LOCAL_SERVER | CLSCTX_ENABLE_AAA ,
					IID_IUnknown ,
					( void ** ) a_ProviderInterface 
				) ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;

				*a_ProviderInterface = NULL ;
			}
		}
		break ;

		default:
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;

			*a_ProviderInterface = NULL ;
		}
		break ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ComServerLoadOperationEvent ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			a_NamespacePath,
			a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
			a_User ,
			a_Locale ,
			a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
			a_Registration.GetComRegistration ().GetClsidServer ().GetProviderClsid () ,
			a_Registration.GetComRegistration ().GetClsidServer ().GetServer_Name () ,
			a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
			a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
			a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetInProcServer32_Path () : NULL ,
			a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetLocalServer32_Path () : NULL
		) ;
	}
	else
	{
		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ComServerOperationFailureEvent ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			a_NamespacePath,
			a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
			a_User ,
			a_Locale ,
			a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
			a_Registration.GetComRegistration ().GetClsidServer ().GetProviderClsid () ,
			a_Registration.GetComRegistration ().GetClsidServer ().GetServer_Name () ,
			a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
			a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
			a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetInProcServer32_Path () : NULL ,
			a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetLocalServer32_Path () : NULL ,
			t_Result 
		);
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: GetApartmentInstanceProvider ( 

	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	REFIID a_RIID , 
	void **a_Interface ,
	CServerObject_ProviderRegistrationV1 &a_Registration
)
{
	wchar_t *t_NamespacePath = NULL ;

	HRESULT t_Result = ProviderSubSystem_Common_Globals :: GetNamespacePath ( 

		Direct_GetNamespacePath () , 
		t_NamespacePath
	) ;

	if ( SUCCEEDED ( t_Result ) ) 
	{
		CServerObject_StaThread *t_StaThread = new CServerObject_StaThread ( m_Allocator, a_Registration ) ;
		if ( t_StaThread )
		{
			t_StaThread->AddRef () ;

			t_Result = t_StaThread->SetProviderName ( a_Registration.GetProviderName () ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				WmiStatusCode t_StatusCode = t_StaThread-> WmiThread <ULONG> :: Initialize () ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					IWbemProviderInit *t_ThreadInit = NULL ;

					t_Result = t_StaThread->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & t_ThreadInit ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
						if ( t_ProviderInitSink )
						{
							t_ProviderInitSink->AddRef () ;

							t_Result = t_ProviderInitSink->SinkInitialize () ;
							if ( SUCCEEDED ( t_Result ) ) 
							{
								CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
								if ( t_Sink )
								{
									t_Sink->AddRef () ;

									t_Result = t_ThreadInit->Initialize (

										NULL ,
										0 ,
										NULL ,
										NULL ,
										NULL ,
										NULL ,
										t_Sink    
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										t_ProviderInitSink->Wait ( a_Registration.GetInitializationTimeoutMilliSeconds () ) ;

										if ( SUCCEEDED ( t_Result = t_ProviderInitSink->GetResult () ) )
										{
#ifdef INTERNAL_IDENTIFY
											CInterceptor_IWbemServices_Proxy *t_Proxy = new CInterceptor_IWbemServices_Proxy ( 

												NULL , 
												m_Allocator , 
												Direct_GetService () ,
												a_Registration
											) ;
#else
											CInterceptor_IWbemServices_Interceptor *t_Proxy = new CInterceptor_IWbemServices_Interceptor ( 

												m_Allocator , 
												Direct_GetService ()
											) ;
#endif

											if ( t_Proxy )
											{
												t_Proxy->AddRef () ;

												t_Result = t_Proxy->ServiceInitialize () ;
												if ( SUCCEEDED ( t_Result ) ) 
												{
													t_Result = t_StaThread->GetApartmentInstanceProvider (

														a_TransactionIdentifier ,
														a_Registration.GetComRegistration ().PerUserInitialization () ? a_User : NULL ,
														a_Registration.GetComRegistration ().PerLocaleInitialization () ? a_Locale : NULL ,
														Direct_GetNamespace () ,
														Direct_GetNamespacePath () ,
														t_Proxy ,
														a_Flags ,
														a_Context ,
														a_Scope ,
														a_Registration
													) ;

													if ( SUCCEEDED ( t_Result ) )
													{
														IUnknown *t_Unknown = NULL ;
														t_Result = t_StaThread->QueryInterface ( IID_IUnknown , ( void ** ) & t_Unknown ) ;
														if ( SUCCEEDED ( t_Result ) )
														{
															GUID t_Guid ;
															t_Result = CoCreateGuid ( & t_Guid ) ;
															if ( SUCCEEDED ( t_Result ) )
															{
																CInterceptor_IWbemSyncProvider *t_Interceptor = new CInterceptor_IWbemSyncProvider (

																	m_Allocator ,
																	t_Unknown , 
																	t_Proxy ,
																	ProviderSubSystem_Globals :: GetSyncProviderController () , 
																	a_Context ,
																	a_Registration ,
																	t_Guid 
																) ;

																if ( t_Interceptor ) 
																{
																	t_Interceptor->AddRef () ;

																	CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator ;

																	ProviderSubSystem_Globals :: GetSyncProviderController ()->Lock () ;

																	WmiStatusCode t_StatusCode = ProviderSubSystem_Globals :: GetSyncProviderController ()->Insert ( 

																		*t_Interceptor ,
																		t_Iterator
																	) ;

																	if ( t_StatusCode == e_StatusCode_Success ) 
																	{
																		ProviderSubSystem_Globals :: GetSyncProviderController ()->UnLock () ;

																		_IWmiProviderInitialize *t_InterceptorInit = NULL ;

																		t_Result = t_Interceptor->QueryInterface ( IID__IWmiProviderInitialize , ( void ** ) & t_InterceptorInit ) ;
																		if ( SUCCEEDED ( t_Result ) )
																		{
																			CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
																			if ( t_ProviderInitSink )
																			{
																				t_ProviderInitSink->AddRef () ;

																				t_Result = t_ProviderInitSink->SinkInitialize () ;
																				if ( SUCCEEDED ( t_Result ) ) 
																				{
																					CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
																					if ( t_Sink )
																					{
																						t_Sink->AddRef () ;

																						t_Result = t_InterceptorInit->Initialize (

																							0 ,
																							a_Context ,
																							a_TransactionIdentifier ,
																							a_Registration.GetComRegistration ().PerUserInitialization () ? ( BSTR ) a_User : NULL ,
																							a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( BSTR ) a_Locale : NULL  ,
																							t_NamespacePath ,
																							NULL ,
																							NULL ,
																							t_Sink    
																						) ;

																						if ( SUCCEEDED ( t_Result ) )
																						{
																							t_ProviderInitSink->Wait ( a_Registration.GetInitializationTimeoutMilliSeconds () ) ;

																							if ( SUCCEEDED ( t_Result = t_ProviderInitSink->GetResult () ) )
																							{
																								t_Result = t_Interceptor->QueryInterface ( a_RIID , a_Interface ) ;
																							}
																						}

																						t_Sink->Release () ;
																					}
																					else
																					{
																						t_Result = WBEM_E_OUT_OF_MEMORY ;
																					}
																				}

																				t_ProviderInitSink->Release () ;
																			}
																			else
																			{
																				t_Result = WBEM_E_OUT_OF_MEMORY ;
																			}

																			t_InterceptorInit->Release () ;
																		}
																	}
																	else
																	{
																		ProviderSubSystem_Globals :: GetSyncProviderController ()->UnLock () ;

																		t_Result = WBEM_E_OUT_OF_MEMORY ;
																	}

																	t_Interceptor->SetInitialized ( t_Result ) ;

																	t_Interceptor->Release () ;
																}
																else
																{
																	t_Result = WBEM_E_OUT_OF_MEMORY ;
																}
															}

															t_Unknown->Release () ;
														}
													}
												}

												t_Proxy->Release () ;
											}
											else
											{
												t_Result = WBEM_E_OUT_OF_MEMORY ;
											}
										}
									}

									t_Sink->Release () ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							t_ProviderInitSink->Release () ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

						t_ThreadInit->Release () ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
	
			t_StaThread->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;

		if ( a_TransactionIdentifier )
		{
			StringFromGUID2 ( *a_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
		}

		if ( SUCCEEDED ( t_Result ) ) 
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_LoadOperationEvent ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				t_NamespacePath,
				a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
				a_User ,
				a_Locale ,
				a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
				a_Registration.GetComRegistration ().GetClsidServer ().GetProviderClsid () ,
				a_Registration.GetComRegistration ().GetClsidServer ().GetServer_Name () ,
				a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
				a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
				a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetInProcServer32_Path () : NULL ,
				a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetLocalServer32_Path () : NULL ,
				( ULONG ) a_Registration.GetComRegistration ().GetClsidServer ().GetThreadingModel () ,
				( ULONG ) a_Registration.GetComRegistration ().GetClsidServer ().GetSynchronization ()
			) ;
		}
		else
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_LoadOperationFailureEvent ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				t_NamespacePath,
				a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
				a_User ,
				a_Locale ,
				a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
				a_Registration.GetComRegistration ().GetClsidServer ().GetProviderClsid () ,
				a_Registration.GetComRegistration ().GetClsidServer ().GetServer_Name () ,
				a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
				a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
				a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetInProcServer32_Path () : NULL ,
				a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetLocalServer32_Path () : NULL ,
				( ULONG ) a_Registration.GetComRegistration ().GetClsidServer ().GetThreadingModel () ,
				( ULONG ) a_Registration.GetComRegistration ().GetClsidServer ().GetSynchronization () ,
				t_Result 
			);
		}

		delete [] t_NamespacePath ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: CreateSyncProvider ( 

	IWbemServices *a_Stub ,
	IUnknown *a_ServerSideProvider ,
	wchar_t *a_NamespacePath ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	REFIID a_RIID , 
	void **a_Interface ,
	CServerObject_ProviderRegistrationV1 &a_Registration
)
{
	HRESULT t_Result = S_OK ;

	GUID t_Guid ;
	t_Result = CoCreateGuid ( & t_Guid ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		CInterceptor_IWbemSyncProvider *t_Interceptor = new CInterceptor_IWbemSyncProvider (

			m_Allocator , 
			a_ServerSideProvider ,
			a_Stub ,
			ProviderSubSystem_Globals :: GetSyncProviderController () , 
			a_Context ,
			a_Registration ,
			t_Guid
		) ;

		if ( t_Interceptor ) 
		{
		    DEBUGTRACE((LOG_PROVSS,"        %p = CInterceptor_IWbemSyncProvider(%p)\n",t_Interceptor,a_ServerSideProvider));
		    
			t_Interceptor->AddRef () ;

			CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator ;

			ProviderSubSystem_Globals :: GetSyncProviderController ()->Lock () ;

			WmiStatusCode t_StatusCode = ProviderSubSystem_Globals :: GetSyncProviderController ()->Insert ( 

				*t_Interceptor ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				ProviderSubSystem_Globals :: GetSyncProviderController ()->UnLock () ;

				_IWmiProviderInitialize *t_InterceptorInit = NULL ;

				t_Result = t_Interceptor->QueryInterface ( IID__IWmiProviderInitialize , ( void ** ) & t_InterceptorInit ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
					if ( t_ProviderInitSink )
					{
						t_ProviderInitSink->AddRef () ;

						t_Result = t_ProviderInitSink->SinkInitialize () ;
						if ( SUCCEEDED ( t_Result ) ) 
						{

							CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
							if ( t_Sink )
							{
								t_Sink->AddRef () ;

								t_Result = t_InterceptorInit->Initialize (

									0 ,
									a_Context ,
									a_TransactionIdentifier ,
									a_Registration.GetComRegistration ().PerUserInitialization () ? ( BSTR ) a_User : NULL ,
									a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( BSTR ) a_Locale : NULL  ,
									a_NamespacePath ,
									NULL ,
									NULL ,
									t_Sink    
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_ProviderInitSink->Wait ( a_Registration.GetInitializationTimeoutMilliSeconds () ) ;

									if ( SUCCEEDED ( t_Result = t_ProviderInitSink->GetResult () ) )
									{
										t_Result = t_Interceptor->QueryInterface ( a_RIID , a_Interface ) ;
										
										DEBUGTRACE((LOG_PROVSS,"          t_Interceptor->QI hr = %08x\n",t_Result));
										
										if ( SUCCEEDED ( t_Result ) )
										{
											t_Result = t_Interceptor->GetInitializeResult () ;											
										    // here is where the whole business of the 
										    // provider loading finishes
										}
									}
								}

								DEBUGTRACE((LOG_PROVSS,"      t_InterceptorInit->Initialize hr = %08x\n",t_Result,t_Result));								

								t_Sink->Release () ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}

						t_ProviderInitSink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					t_InterceptorInit->Release () ;
				}
			}
			else
			{
				ProviderSubSystem_Globals :: GetSyncProviderController ()->UnLock () ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			t_Interceptor->SetInitialized ( t_Result ) ;

			t_Interceptor->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: InitializeServerProvider ( 

	IWbemServices *a_Stub ,
	IUnknown *a_ProviderInterface ,
	wchar_t *a_NamespacePath ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	REFIID a_RIID , 
	void **a_Interface ,
	CServerObject_ProviderRegistrationV1 &a_Registration
)
{
	HRESULT t_Result = S_OK ;

	wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;

	if ( a_TransactionIdentifier )
	{
		StringFromGUID2 ( *a_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
	}

	if ( a_Registration.GetEventProviderRegistration ().Supported () )
	{
		IWbemProviderIdentity *t_ProviderIdentity = NULL ;
		t_Result = a_ProviderInterface->QueryInterface ( IID_IWbemProviderIdentity , ( void ** ) & t_ProviderIdentity ) ;
		DEBUGTRACE((LOG_PROVSS,"      QI(IID_IWbemProviderIdentity) hr = %08x\n",t_Result));
		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;

				IServerSecurity *t_ServerSecurity = NULL ;
				HRESULT t_TempResult = CoGetCallContext ( IID_IUnknown , ( void ** ) & t_ServerSecurity ) ;
				if ( SUCCEEDED ( t_TempResult ) )
				{
					t_Result = CoImpersonateClient () ;
					if ( SUCCEEDED ( t_Result ) )
					{
						t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						CoRevertToSelf () ;
					}

					t_ServerSecurity->Release () ;
				}

				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IDENTIFY )
					{
						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_NoImpersonation ( 
							
							IID_IWbemProviderIdentity , 
							t_ProviderIdentity , 
							t_Proxy , 
							t_Revert
						) ;
					}
					else
					{
						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
							
							IID_IWbemProviderIdentity , 
							t_ProviderIdentity , 
							t_Proxy , 
							t_Revert
						) ;
					}
				}

				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_ProviderIdentity->SetRegistrationObject (

							0 ,
							a_Registration.GetIdentity () 
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}

					CoRevertToSelf () ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemProviderIdentity *t_ProviderIdentityProxy = ( IWbemProviderIdentity * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_ProviderIdentityProxy ,
							RPC_C_AUTHN_LEVEL_DEFAULT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							try
							{
								t_Result = t_ProviderIdentityProxy->SetRegistrationObject (

									0 ,
									a_Registration.GetIdentity () 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}
						}

						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}	

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_ProviderIdentity->Release () ;
		}
	}

	IWbemProviderInit *t_ProviderInit = NULL ;
	t_Result = a_ProviderInterface->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & t_ProviderInit ) ;
	DEBUGTRACE((LOG_PROVSS,"      QI(IID_IWbemProviderInit) hr = %08x\n",t_Result));
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Registration.GetComRegistration ().PerUserInitialization () && a_Registration.GetComRegistration ().InitializeAsAdminFirst () )
		{
			CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
			if ( t_ProviderInitSink )
			{
				t_ProviderInitSink->AddRef () ;

				t_Result = t_ProviderInitSink->SinkInitialize ( a_Registration.GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						BOOL t_Impersonating = FALSE ;
						IUnknown *t_OldContext = NULL ;
						IServerSecurity *t_OldSecurity = NULL ;

						t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							BOOL t_Revert = FALSE ;
							IUnknown *t_Proxy = NULL ;

							DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;

							IServerSecurity *t_ServerSecurity = NULL ;
							HRESULT t_TempResult = CoGetCallContext ( IID_IUnknown , ( void ** ) & t_ServerSecurity ) ;
							if ( SUCCEEDED ( t_TempResult ) )
							{
								t_Result = CoImpersonateClient () ;
								if ( SUCCEEDED ( t_Result ) )
								{
									t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

									CoRevertToSelf () ;
								}

								t_ServerSecurity->Release () ;
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IDENTIFY )
								{
									t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_NoImpersonation ( 

										IID_IWbemProviderInit , 
										t_ProviderInit , 
										t_Proxy , 
										t_Revert
									) ;
								}
								else
								{
									t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 

										IID_IWbemProviderInit , 
										t_ProviderInit , 
										t_Proxy , 
										t_Revert
									) ;
								}
							}

							if ( t_Result == WBEM_E_NOT_FOUND )
							{
								try
								{
									t_Result = t_ProviderInit->Initialize (

										NULL ,
										0 ,
										( const BSTR ) a_NamespacePath ,
										a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
										a_Stub ,
										a_Context ,
										t_Sink    
									) ;
                                   	DEBUGTRACE((LOG_PROVSS,"      (Per User) t_ProviderInit->Initialize hr = %08x\n",t_Result));									
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								if ( SUCCEEDED ( t_Result ) )
								{
									IWbemProviderInit *t_ProviderInitProxy = ( IWbemProviderInit * ) t_Proxy ;

									// Set cloaking on the proxy
									// =========================

									DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

									t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

										t_ProviderInitProxy ,
										RPC_C_AUTHN_LEVEL_DEFAULT , 
										t_ImpersonationLevel
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										try
										{
											t_Result = t_ProviderInitProxy->Initialize (

												NULL ,
												0 ,
												( const BSTR ) a_NamespacePath ,
												a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
												a_Stub ,
												a_Context ,
												t_Sink    
											) ;

										}
										catch ( ... )
										{
											t_Result = WBEM_E_PROVIDER_FAILURE ;
										}
                                                                                DEBUGTRACE((LOG_PROVSS,"      (Per User) t_ProviderInitProxy->Initialize hr = %08x\n",t_Result));
									}	

									HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
								}
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								t_ProviderInitSink->Wait ( a_Registration.GetInitializationTimeoutMilliSeconds () ) ;
								t_Result = t_ProviderInitSink->GetResult () ;
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								WmiSetAndCommitObject (

									ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationEvent ] , 
									WMI_SENDCOMMIT_SET_NOT_REQUIRED,
									a_NamespacePath,
									a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
									a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
									a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
									a_TransactionIdentifier ? t_TransactionIdentifier : NULL
								) ;
							}
							else
							{
								WmiSetAndCommitObject (

									ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationFailureEvent ] , 
									WMI_SENDCOMMIT_SET_NOT_REQUIRED,
									a_NamespacePath,
									a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
									a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
									a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
									a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
									t_Result 
								) ;

								t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
							}

							ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
						}	

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				t_ProviderInitSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )	
		{
			CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
			if ( t_ProviderInitSink )
			{
				t_ProviderInitSink->AddRef () ;

				t_Result = t_ProviderInitSink->SinkInitialize ( a_Registration.GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						BOOL t_Impersonating = FALSE ;
						IUnknown *t_OldContext = NULL ;
						IServerSecurity *t_OldSecurity = NULL ;

						t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							BOOL t_Revert = FALSE ;
							IUnknown *t_Proxy = NULL ;

							DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;

							IServerSecurity *t_ServerSecurity = NULL ;
							HRESULT t_TempResult = CoGetCallContext ( IID_IUnknown , ( void ** ) & t_ServerSecurity ) ;
							if ( SUCCEEDED ( t_TempResult ) )
							{
								t_Result = CoImpersonateClient () ;
								if ( SUCCEEDED ( t_Result ) )
								{
									t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

									CoRevertToSelf () ;
								}

								t_ServerSecurity->Release () ;
							}

							if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IDENTIFY )
							{
								t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_NoImpersonation ( 

									IID_IWbemProviderInit , 
									t_ProviderInit , 
									t_Proxy , 
									t_Revert
								) ;
							}
							else
							{
								t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 

									IID_IWbemProviderInit , 
									t_ProviderInit , 
									t_Proxy , 
									t_Revert
								) ;
							}

							if ( t_Result == WBEM_E_NOT_FOUND )
							{
								try
								{
									t_Result = t_ProviderInit->Initialize (

										a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
										0 ,
										( const BSTR ) a_NamespacePath ,
										a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
										a_Stub ,
										a_Context ,
										t_Sink    
									) ;
                                	DEBUGTRACE((LOG_PROVSS,"      t_ProviderInit->Initialize hr = %08x\n",t_Result));									
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								if ( SUCCEEDED ( t_Result ) )
								{
									IWbemProviderInit *t_ProviderInitProxy = ( IWbemProviderInit * ) t_Proxy ;

									// Set cloaking on the proxy
									// =========================

									DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

									t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

										t_ProviderInitProxy ,
										RPC_C_AUTHN_LEVEL_DEFAULT , 
										t_ImpersonationLevel
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										try
										{
											t_Result = t_ProviderInitProxy->Initialize (
												a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
												0 ,
												( const BSTR ) a_NamespacePath ,
												a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
												a_Stub ,
												a_Context ,
												t_Sink    
											) ;

										}
										catch ( ... )
										{
											t_Result = WBEM_E_PROVIDER_FAILURE ;
										}
                                                                                DEBUGTRACE((LOG_PROVSS,"      t_ProviderInitProxy->Initialize hr = %08x\n",t_Result));
									}	

									HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
								}
							}	

							if ( SUCCEEDED ( t_Result ) )
							{
								t_ProviderInitSink->Wait ( a_Registration.GetInitializationTimeoutMilliSeconds () ) ;
								t_Result = t_ProviderInitSink->GetResult () ;
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								WmiSetAndCommitObject (

									ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationEvent ] , 
									WMI_SENDCOMMIT_SET_NOT_REQUIRED,
									a_NamespacePath,
									a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
									a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
									a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
									a_TransactionIdentifier ? t_TransactionIdentifier : NULL
								) ;
							}
							else
							{
								WmiSetAndCommitObject (

									ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationFailureEvent ] , 
									WMI_SENDCOMMIT_SET_NOT_REQUIRED,
									a_NamespacePath,
									a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
									a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
									a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
									a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
									t_Result 
								) ;

								t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
							}

							ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				t_ProviderInitSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		t_ProviderInit->Release () ;
	}
	else
	{
		if ( a_Registration.GetPropertyProviderRegistration ().Supported () || a_Registration.GetEventConsumerProviderRegistration ().Supported () )
		{
			if (	a_Registration.GetClassProviderRegistration ().Supported () ||
					a_Registration.GetInstanceProviderRegistration ().Supported () ||
					a_Registration.GetMethodProviderRegistration ().Supported () ||
					a_Registration.GetEventProviderRegistration ().Supported () )
			{
				t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
			else
			{
				t_Result = S_OK ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: InitializeNonApartmentProvider ( 

	IWbemServices *a_Stub ,
	IUnknown *a_ServerSideProviderInterface ,
	wchar_t *a_NamespacePath ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	REFIID a_RIID , 
	void **a_Interface ,
	CServerObject_ProviderRegistrationV1 &a_Registration
)
{
	HRESULT t_Result = S_OK ;

	if ( a_ServerSideProviderInterface )
	{
		t_Result = InitializeServerProvider (

			a_Stub ,
			a_ServerSideProviderInterface ,
			a_NamespacePath ,
			a_Flags ,
			a_Context ,
			a_TransactionIdentifier ,
			a_User ,
			a_Locale ,
			a_Scope,
			a_RIID , 
			a_Interface ,
			a_Registration
		) ;
	    DEBUGTRACE((LOG_PROVSS,"       InitializeServerProvider(%p) returned hr = %08x\n",a_ServerSideProviderInterface,t_Result ));
	}



	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateSyncProvider (

			a_Stub ,
			a_ServerSideProviderInterface ,
			a_NamespacePath ,
			a_Flags ,
			a_Context ,
			a_TransactionIdentifier ,
			a_User ,
			a_Locale ,
			a_Scope,
			a_RIID , 
			a_Interface ,
			a_Registration
		) ;

		if ( FAILED(t_Result) )
		{
    		DEBUGTRACE((LOG_PROVSS,"    CreateSyncProvider hr = %08x\n",t_Result ));
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: GetNonApartmentProvider ( 

	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	REFIID a_RIID , 
	void **a_Interface ,
	CServerObject_ProviderRegistrationV1 &a_Registration
)
{
	wchar_t *t_NamespacePath = NULL ;

	HRESULT t_Result = ProviderSubSystem_Common_Globals :: GetNamespacePath ( 

		Direct_GetNamespacePath () , 
		t_NamespacePath
	) ;

	if ( SUCCEEDED ( t_Result ) ) 
	{
		IUnknown *t_ServerSideProviderInterface = NULL ;

		t_Result = CreateServerSide (

			a_Registration ,
			a_TransactionIdentifier ,
			a_User ,
			a_Locale ,
			t_NamespacePath ,
			& t_ServerSideProviderInterface 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
            IWbemServices * t_Proxy = NULL;

            if (e_Hosting_WmiCore == a_Registration.GetHosting())
            {
                t_Proxy = new CInterceptor_IWbemServices_RestrictingInterceptor ( 

					m_Allocator , 
					Direct_GetService () ,
					a_Registration
				) ;
                
                if (t_Proxy)
                {
                	t_Proxy->AddRef () ;           
                	t_Result = ((CInterceptor_IWbemServices_RestrictingInterceptor *)t_Proxy)->ServiceInitialize () ;                	
                }
            }
            else
            {
                t_Proxy = Direct_GetService();
               	t_Proxy->AddRef () ;
            }

			if ( t_Proxy )
			{			                
				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = InitializeNonApartmentProvider (

						t_Proxy ,
						t_ServerSideProviderInterface ,
						t_NamespacePath ,
						a_Flags ,
						a_Context ,
						a_TransactionIdentifier ,
						a_User ,
						a_Locale ,
						a_Scope,
						a_RIID , 
						a_Interface ,
						a_Registration
					) ;

					DEBUGTRACE((LOG_PROVSS,"  CServerObject_RawFactory::GetNonApartmentProvider pNS %S hr = %08x\n",t_NamespacePath,t_Result ));
				}

				t_Proxy->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			if ( t_ServerSideProviderInterface )
			{
				t_ServerSideProviderInterface->Release () ;
			}
		}

		wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;

		if ( a_TransactionIdentifier )
		{
			StringFromGUID2 ( *a_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
		}

		if ( SUCCEEDED ( t_Result ) ) 
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_LoadOperationEvent ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				t_NamespacePath,
				a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
				a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
				a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
				a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
				a_Registration.GetComRegistration ().GetClsidServer ().GetProviderClsid () ,
				a_Registration.GetComRegistration ().GetClsidServer ().GetServer_Name () ,
				a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
				a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
				a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetInProcServer32_Path () : NULL ,
				a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetLocalServer32_Path () : NULL ,
				( ULONG ) a_Registration.GetComRegistration ().GetClsidServer ().GetThreadingModel () ,
				( ULONG ) a_Registration.GetComRegistration ().GetClsidServer ().GetSynchronization ()
			) ;
		}
		else
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_LoadOperationFailureEvent ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				t_NamespacePath,
				a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
				a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
				a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
				a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
				a_Registration.GetComRegistration ().GetClsidServer ().GetProviderClsid () ,
				a_Registration.GetComRegistration ().GetClsidServer ().GetServer_Name () ,
				a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
				a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
				a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetInProcServer32_Path () : NULL ,
				a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetLocalServer32_Path () : NULL ,
				( ULONG ) a_Registration.GetComRegistration ().GetClsidServer ().GetThreadingModel () ,
				( ULONG ) a_Registration.GetComRegistration ().GetClsidServer ().GetSynchronization () ,
				t_Result 
			);
		}

		if ( FAILED ( t_Result ) )
		{
			t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}

		delete [] t_NamespacePath ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: GetHostedProvider ( 
	
	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	LPCWSTR a_Name ,
	ULONG a_Host ,
	LPCWSTR a_HostingGroup ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = WBEM_E_NOT_SUPPORTED ;
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: GetClassProvider (

    LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	IWbemClassObject *a_Class ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	try 
	{
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: GetDynamicPropertyResolver (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	try 
	{
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: GetProvider ( 

	WmiInternalContext a_InternalContext ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope,
	LPCWSTR a_Name ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

    DEBUGTRACE((LOG_PROVSS,"+ CServerObject_RawFactory::GetProvider %S\n",a_Name));

	HRESULT t_Result = S_OK ;

	try 
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		if ( a_InternalContext.m_IdentifyHandle )
		{
			HANDLE t_IdentifyToken = ( HANDLE ) a_InternalContext.m_IdentifyHandle ;

			BOOL t_Status = SetThreadToken ( NULL , t_IdentifyToken ) ;
			if ( t_Status )
			{
				t_Result = ProviderSubSystem_Globals :: BeginThreadImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

				RevertToSelf () ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}

			CloseHandle ( t_IdentifyToken ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemPath *t_Scope = NULL ;

			if ( a_Scope ) 
			{
				t_Result = CoCreateInstance (

					CLSID_WbemDefPath ,
					NULL ,
					CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
					IID_IWbemPath ,
					( void ** )  & t_Scope
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Scope->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Scope ) ;
				}
			}

			if ( SUCCEEDED ( t_Result ) ) 
			{
				CServerObject_ProviderRegistrationV1 *t_Registration = new CServerObject_ProviderRegistrationV1 ;
				if ( t_Registration )
				{
					t_Registration->AddRef () ;

					t_Result = t_Registration->SetContext ( 

						a_Context ,
						Direct_GetNamespacePath () , 
						Direct_GetRepository ()
					) ;
					
					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_Registration->ObjectProvider () )
						{
							if ( t_Registration->EventProvider () )
							{
								t_Registration->SetUnloadTimeoutMilliSeconds (
								
									ProviderSubSystem_Globals :: s_ObjectCacheTimeout < ProviderSubSystem_Globals :: s_EventCacheTimeout ? 
									
										ProviderSubSystem_Globals :: s_EventCacheTimeout :	ProviderSubSystem_Globals :: s_ObjectCacheTimeout
								) ;
							}
							else
							{
								t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_ObjectCacheTimeout ) ;
							}
						}
						else
						{
							if ( t_Registration->EventProvider () )
							{
								t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_EventCacheTimeout ) ;
							}
						}

						t_Result = t_Registration->Load ( 

							e_All ,
							t_Scope , 
							a_Name
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
                            DEBUGTRACE((LOG_PROVSS,"   Hosting %d InProcServer %d\n",
                            	         t_Registration->GetComRegistration ().GetHosting(),
                            	         t_Registration->GetComRegistration ().GetClsidServer ().InProcServer32 ()));
						
							IUnknown *t_Unknown = NULL ;

							if ( t_Registration->GetComRegistration ().GetHosting () == e_Hosting_SelfHost )
							{
								t_Result = GetNonApartmentProvider ( 

									a_Flags ,
									a_Context ,
									a_TransactionIdentifier ,
									a_User ,
									a_Locale ,
									a_Scope,
									IID_IUnknown , 
									( void ** ) & t_Unknown ,
									*t_Registration
								) ;
							}
							else
							{
								if ( t_Registration->GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True )
								{
									switch ( t_Registration->GetThreadingModel () )
									{
										case e_Apartment:
										{
											t_Result = GetApartmentInstanceProvider ( 

												a_Flags ,
												a_Context ,
												a_TransactionIdentifier ,
												a_User ,
												a_Locale ,
												a_Scope,
												IID_IUnknown , 
												( void ** ) & t_Unknown ,
												*t_Registration
											) ;
										}
										break ;

										case e_Both:
										case e_Free:
										case e_Neutral:
										{
											t_Result = GetNonApartmentProvider ( 

												a_Flags ,
												a_Context ,
												a_TransactionIdentifier ,
												a_User ,
												a_Locale ,
												a_Scope,
												IID_IUnknown , 
												( void ** ) & t_Unknown ,
												*t_Registration
											) ;
										}
										break ;

										case e_ThreadingModel_Unknown:
										default:
										{
											t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
										}
										break ;
									}
								}
								else
								{
									t_Result = GetNonApartmentProvider ( 

										a_Flags ,
										a_Context ,
										a_TransactionIdentifier ,
										a_User ,
										a_Locale ,
										a_Scope,
										IID_IUnknown , 
										( void ** ) & t_Unknown ,
										*t_Registration
									) ;
								}
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{	
								t_Result = CheckInterfaceConformance (

									*t_Registration ,
									t_Unknown
								) ;								

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_Unknown->QueryInterface ( a_RIID , a_Interface ) ;
								}
								else
								{
								    ERRORTRACE((LOG_PROVSS,"   CheckInterfaceConformance for %S hr = %08x\n",a_Name,t_Result));
								}

								t_Unknown->Release () ;

							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND )
							{
								t_Result = WBEM_E_PROVIDER_NOT_FOUND ;
							}	
							else
							{
								t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
							}
						}
					}

					t_Registration->Release () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( t_Scope ) 
			{
				t_Scope->Release () ;
			}

			if ( a_InternalContext.m_IdentifyHandle )
			{
				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

				RevertToSelf () ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

    DEBUGTRACE((LOG_PROVSS,"- CServerObject_RawFactory::GetProvider hr = %08x\n",t_Result ));
    
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: GetDecoupledProvider (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope,
	LPCWSTR a_Name ,
	REFIID a_RIID , 
	void **a_Interface 
) 
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	try 
	{
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: Initialize (

	_IWmiProvSS *a_SubSys ,
	_IWmiProviderFactory *a_Factory ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Namespace ,
	IWbemServices *a_Repository ,
	IWbemServices *a_Service
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Namespace ) 
	{
		m_Namespace = DupString( a_Namespace );
		if ( m_Namespace == 0) 
		{	
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CoCreateInstance (

				CLSID_WbemDefPath ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IWbemPath ,
				( void ** )  & m_NamespacePath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = m_NamespacePath->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Namespace ) ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_Flags = a_Flags ;
		m_Context = a_Context ;
		m_Repository = a_Repository ;
		m_Service = a_Service ;

		if ( m_Context ) 
		{
			m_Context->AddRef () ;
		}

		if ( m_Repository ) 
		{
			m_Repository->AddRef () ;
		}

		if ( m_Service ) 
		{
			m_Service->AddRef () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	try 
	{
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
	}

	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provobsk.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <stdio.h>

#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvWsv.h"
#include "ProvObSk.h"
#include "Guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemObjectSink :: CInterceptor_IWbemObjectSink (

	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller 

)	:	ObjectSinkContainerElement ( 

			a_Controller ,
			a_InterceptedSink
		) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_Unknown ( a_Unknown ) ,
		m_StatusCalled ( FALSE ) ,
		m_SecurityDescriptor ( NULL ) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemObjectSink :: ~CInterceptor_IWbemObjectSink ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_IWbemObjectSink :: CallBackInternalRelease ()
{
	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 0 , 0 ) )
	{
		m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_UNEXPECTED ,
			NULL ,
			NULL
		) ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}

	if ( m_SecurityDescriptor )
	{
		delete [] m_SecurityDescriptor ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}
#ifdef INTERNAL_IDENTIFY
	else if ( iid == IID_Internal_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( Internal_IWbemObjectSink * ) this ;		
	}	
#endif
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemObjectSink :: AddRef ( void )
{
//	printf ( "\nCInterceptor_IWbemObjectSink :: AddRef ()" )  ;

	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemObjectSink :: Release ( void )
{
	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemObjectSink :: Initialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor )
{
	return ProviderSubSystem_Common_Globals :: SinkAccessInitialize ( a_SecurityDescriptor , m_SecurityDescriptor ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( SUCCEEDED ( t_Result = ProviderSubSystem_Common_Globals :: CheckAccess ( m_SecurityDescriptor , MASK_PROVIDER_BINDING_BIND , & g_ProviderBindingMapping ) ) )
		{
			t_Result = m_InterceptedSink->Indicate ( 

				a_ObjectCount ,
				a_ObjectArray
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( SUCCEEDED ( t_Result = ProviderSubSystem_Common_Globals :: CheckAccess ( m_SecurityDescriptor , MASK_PROVIDER_BINDING_BIND , & g_ProviderBindingMapping ) ) )
		{
			switch ( a_Flags )
			{
				case WBEM_STATUS_PROGRESS:
				{
					t_Result = m_InterceptedSink->SetStatus ( 

						a_Flags ,
						a_Result ,
						a_StringParam ,
						a_ObjectParam
					) ;
				}
				break ;

				case WBEM_STATUS_COMPLETE:
				{
					if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
					{
						t_Result = m_InterceptedSink->SetStatus ( 

							a_Flags ,
							a_Result ,
							a_StringParam ,
							a_ObjectParam
						) ;
					}
				}
				break ;

				default:
				{
					t_Result = WBEM_E_INVALID_PARAMETER ;
				}
				break ;
			}
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

#ifdef INTERNAL_IDENTIFY

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemObjectSink :: Internal_Indicate (

	WmiInternalContext a_InternalContext ,
	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Indicate (

			a_ObjectCount ,
			a_ObjectArray
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemObjectSink :: Internal_SetStatus (

	WmiInternalContext a_InternalContext ,
	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = SetStatus (

			a_Flags ,
			a_Result ,
			a_StringParam ,
			a_ObjectParam
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
	{
		t_Result = m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_SHUTTING_DOWN ,
			NULL ,
			NULL
		) ;
	}

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_DecoupledIWbemObjectSink :: CInterceptor_DecoupledIWbemObjectSink (

	IWbemServices *a_Provider ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller 

)	:	ObjectSinkContainerElement ( 

			a_Controller ,
			a_InterceptedSink
		) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_Unknown ( a_Unknown ) ,
		m_StatusCalled ( FALSE ) ,
		m_SecurityDescriptor ( NULL ) ,
		m_Provider ( a_Provider ) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( a_Provider ) 
	{
		m_Provider->AddRef () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_DecoupledIWbemObjectSink :: ~CInterceptor_DecoupledIWbemObjectSink ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemObjectSink :: Initialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor )
{
	return ProviderSubSystem_Common_Globals :: SinkAccessInitialize ( a_SecurityDescriptor , m_SecurityDescriptor ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_DecoupledIWbemObjectSink :: CallBackInternalRelease ()
{
	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 0 , 0 ) )
	{
		m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_UNEXPECTED ,
			NULL ,
			NULL
		) ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider ) 
	{
		m_Provider->Release () ;
	}

	if ( m_SecurityDescriptor )
	{
		delete [] m_SecurityDescriptor ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_DecoupledIWbemObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	
	else if ( iid == IID_IObjectSink_CancelOperation )
	{
		*iplpv = ( LPVOID ) ( IObjectSink_CancelOperation * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_DecoupledIWbemObjectSink :: AddRef ( void )
{
	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_DecoupledIWbemObjectSink :: Release ( void )
{
	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( SUCCEEDED ( t_Result = ProviderSubSystem_Common_Globals :: CheckAccess ( m_SecurityDescriptor , MASK_PROVIDER_BINDING_BIND , & g_ProviderBindingMapping ) ) )
		{
			t_Result = m_InterceptedSink->Indicate ( 

				a_ObjectCount ,
				a_ObjectArray
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		switch ( a_Flags )
		{
			if ( SUCCEEDED ( t_Result = ProviderSubSystem_Common_Globals :: CheckAccess ( m_SecurityDescriptor , MASK_PROVIDER_BINDING_BIND , & g_ProviderBindingMapping ) ) )
			{
				case WBEM_STATUS_PROGRESS:
				{
					t_Result = m_InterceptedSink->SetStatus ( 

						a_Flags ,
						a_Result ,
						a_StringParam ,
						a_ObjectParam
					) ;
				}
				break ;

				case WBEM_STATUS_COMPLETE:
				{
					if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
					{
						t_Result = m_InterceptedSink->SetStatus ( 

							a_Flags ,
							a_Result ,
							a_StringParam ,
							a_ObjectParam
						) ;
					}
				}
				break ;

				default:
				{
					t_Result = WBEM_E_INVALID_PARAMETER ;
				}
				break ;
			}
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
	{
		t_Result = m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_SHUTTING_DOWN ,
			NULL ,
			NULL
		) ;
	}

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemObjectSink :: Cancel (

	LONG a_Flags
)
{
	HRESULT t_Result = S_OK ;

	if ( m_Provider )
	{
		t_Result = m_Provider->CancelAsyncCall (

			this
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink :: CInterceptor_IWbemSyncObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	: CCommon_IWbemSyncObjectSink ( 

		a_Allocator ,
		a_InterceptedSink ,
		a_Unknown ,
		a_Controller ,
		a_Dependant 
	) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink :: ~CInterceptor_IWbemSyncObjectSink ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_GetObjectAsync :: CInterceptor_IWbemSyncObjectSink_GetObjectAsync (

	WmiAllocator &a_Allocator ,
	long a_Flags ,
	BSTR a_ObjectPath ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_IWbemSyncObjectSink (

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_ObjectPath ( a_ObjectPath ) ,
		m_Interceptor ( a_Interceptor ) 
{

	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_GetObjectAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_ObjectPath
		) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_GetObjectAsync :: ~CInterceptor_IWbemSyncObjectSink_GetObjectAsync ()
{
	if ( m_ObjectPath ) 
	{
		SysFreeString ( m_ObjectPath ) ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_GetObjectAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_GetObjectAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_ObjectPath ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync :: CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync (

	WmiAllocator &a_Allocator ,
	long a_Flags ,
	BSTR a_ObjectPath ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_IWbemSyncObjectSink (

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_ObjectPath ( a_ObjectPath ) ,
		m_Interceptor ( a_Interceptor ) 
{

	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_DeleteInstanceAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_ObjectPath
		) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync :: ~CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync ()
{
	if ( m_ObjectPath ) 
	{
		SysFreeString ( m_ObjectPath ) ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_DeleteInstanceAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_ObjectPath ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_DeleteClassAsync :: CInterceptor_IWbemSyncObjectSink_DeleteClassAsync (

	WmiAllocator &a_Allocator ,
	long a_Flags ,
	BSTR a_Class ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_IWbemSyncObjectSink (

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_Class ( a_Class ) ,
		m_Interceptor ( a_Interceptor ) 
{

	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_DeleteClassAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_Class
		) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_DeleteClassAsync :: ~CInterceptor_IWbemSyncObjectSink_DeleteClassAsync ()
{
	if ( m_Class ) 
	{
		SysFreeString ( m_Class ) ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_DeleteClassAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_DeleteClassAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_Class ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_PutClassAsync :: CInterceptor_IWbemSyncObjectSink_PutClassAsync (

	WmiAllocator &a_Allocator ,
	long a_Flags ,
	IWbemClassObject *a_Class ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_IWbemSyncObjectSink (

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_Class ( a_Class ) ,
		m_Interceptor ( a_Interceptor ) 
{
	if ( m_Class )
	{
		m_Class->AddRef () ;
	}

	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_PutClassAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_Class
		) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_PutClassAsync :: ~CInterceptor_IWbemSyncObjectSink_PutClassAsync ()
{
	if ( m_Class )
	{
		m_Class->Release () ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_PutClassAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_PutClassAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_Class ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_PutInstanceAsync :: CInterceptor_IWbemSyncObjectSink_PutInstanceAsync (

	WmiAllocator &a_Allocator ,
	long a_Flags ,
	IWbemClassObject *a_Instance ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_IWbemSyncObjectSink (

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_Instance ( a_Instance ) ,
		m_Interceptor ( a_Interceptor ) 
{
	if ( m_Instance )
	{
		m_Instance->AddRef () ;
	}

	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_PutInstanceAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_Instance
		) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_PutInstanceAsync :: ~CInterceptor_IWbemSyncObjectSink_PutInstanceAsync ()
{
	if ( m_Instance )
	{
		m_Instance->Release () ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_PutInstanceAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_PutInstanceAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_Instance ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync :: CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync (

	WmiAllocator &a_Allocator ,
	long a_Flags ,
	BSTR a_Class ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_Batching_IWbemSyncObjectSink (

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_Class ( a_Class ) ,
		m_Interceptor ( a_Interceptor ) 
{
	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_CreateInstanceEnumAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_Class
		) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync :: ~CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync ()
{
	if ( m_Class ) 
	{
		SysFreeString ( m_Class ) ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = CCommon_Batching_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_CreateInstanceEnumAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_Class ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync :: CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync (

	WmiAllocator &a_Allocator ,
	long a_Flags ,
	BSTR a_SuperClass ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_Batching_IWbemSyncObjectSink (

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_SuperClass ( a_SuperClass ) ,
		m_Interceptor ( a_Interceptor ) 
{
	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_CreateClassEnumAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_SuperClass
		) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync :: ~CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync ()
{
	if ( m_SuperClass ) 
	{
		SysFreeString ( m_SuperClass ) ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = CCommon_Batching_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_CreateClassEnumAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_SuperClass ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_ExecQueryAsync :: CInterceptor_IWbemSyncObjectSink_ExecQueryAsync (

	WmiAllocator &a_Allocator ,
	long a_Flags ,
	BSTR a_QueryLanguage ,
	BSTR a_Query ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_Batching_IWbemSyncObjectSink (

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_Query ( a_Query ) ,
		m_QueryLanguage ( a_QueryLanguage ) ,
		m_Interceptor ( a_Interceptor ) 
{
	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ExecQueryAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_QueryLanguage ,
			m_Query
		) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_ExecQueryAsync :: ~CInterceptor_IWbemSyncObjectSink_ExecQueryAsync ()
{
	if ( m_Query ) 
	{
		SysFreeString ( m_Query ) ;
	}

	if ( m_QueryLanguage ) 
	{
		SysFreeString ( m_QueryLanguage ) ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_ExecQueryAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = CCommon_Batching_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ExecQueryAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_QueryLanguage ,
				m_Query ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_ExecMethodAsync :: CInterceptor_IWbemSyncObjectSink_ExecMethodAsync (

	WmiAllocator &a_Allocator ,
	long a_Flags ,
	BSTR a_ObjectPath ,
	BSTR a_MethodName ,
	IWbemClassObject *a_InParameters ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_IWbemSyncObjectSink (

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_ObjectPath ( a_ObjectPath ) ,
		m_MethodName ( a_MethodName ) ,
		m_InParameters ( a_InParameters ) ,
		m_Interceptor ( a_Interceptor ) 
{
	if ( m_InParameters ) 
	{
		m_InParameters->AddRef () ;
	}

	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ExecMethodAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_ObjectPath ,
			m_MethodName ,
			m_InParameters
		) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_ExecMethodAsync :: ~CInterceptor_IWbemSyncObjectSink_ExecMethodAsync ()
{
	if ( m_MethodName ) 
	{
		SysFreeString ( m_MethodName ) ;
	}

	if ( m_ObjectPath ) 
	{
		SysFreeString ( m_ObjectPath ) ;
	}

	if ( m_InParameters ) 
	{
		m_InParameters->Release () ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_ExecMethodAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ExecMethodAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_ObjectPath ,
				m_MethodName ,
				m_InParameters ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemFilteringObjectSink :: CInterceptor_IWbemFilteringObjectSink (

	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query

)	:	CInterceptor_IWbemObjectSink ( 

			a_InterceptedSink ,
			a_Unknown ,
			a_Controller 
		) ,
		m_Filtering ( FALSE ) ,
		m_QueryFilter ( NULL )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemFilteringObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( a_Query )
	{
		m_Query = SysAllocString ( a_Query ) ;
	}

	if ( a_QueryLanguage ) 
	{
		m_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemFilteringObjectSink :: ~CInterceptor_IWbemFilteringObjectSink ()
{
	if ( m_QueryFilter )
	{
		m_QueryFilter->Release () ;
	}

	if ( m_Query )
	{
		SysFreeString ( m_Query ) ;
	}

	if ( m_QueryLanguage ) 
	{
		 SysFreeString ( m_QueryLanguage ) ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemFilteringObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemFilteringObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = CInterceptor_IWbemObjectSink :: Indicate ( 

		a_ObjectCount ,
		a_ObjectArray
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemFilteringObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	switch ( a_Flags )
	{
		case WBEM_STATUS_PROGRESS:
		{
			t_Result = CInterceptor_IWbemObjectSink :: SetStatus ( 

				a_Flags ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
		break ;

		case WBEM_STATUS_COMPLETE:
		{
			t_Result = CInterceptor_IWbemObjectSink :: SetStatus ( 

				a_Flags ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
		break ;

		case WBEM_STATUS_REQUIREMENTS:
		{
			t_Result = CInterceptor_IWbemObjectSink :: SetStatus ( 

				a_Flags ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
		break;

		default:
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncFilteringObjectSink :: CInterceptor_IWbemSyncFilteringObjectSink (

	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	ULONG a_Dependant 

)	:	ObjectSinkContainerElement ( 

			a_Controller ,
			a_InterceptedSink
		) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_Unknown ( a_Unknown ) ,
		m_StatusCalled ( FALSE ) ,
		m_Filtering ( FALSE ) ,
		m_QueryFilter ( NULL ) ,
		m_Dependant ( a_Dependant ) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncFilteringObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}

	if ( a_Query )
	{
		m_Query = SysAllocString ( a_Query ) ;
	}

	if ( a_QueryLanguage ) 
	{
		m_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncFilteringObjectSink :: ~CInterceptor_IWbemSyncFilteringObjectSink ()
{
	if ( m_QueryFilter )
	{
		m_QueryFilter->Release () ;
	}

	if ( m_Query )
	{
		SysFreeString ( m_Query ) ;
	}

	if ( m_QueryLanguage ) 
	{
		 SysFreeString ( m_QueryLanguage ) ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncFilteringObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_IWbemSyncFilteringObjectSink :: CallBackInternalRelease ()
{
	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 0 , 0 ) )
	{
		m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_UNEXPECTED ,
			NULL ,
			NULL
		) ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemSyncFilteringObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemSyncFilteringObjectSink :: AddRef ( void )
{
//	printf ( "\nCInterceptor_IWbemSyncFilteringObjectSink :: AddRef ()" )  ;

	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemSyncFilteringObjectSink :: Release ( void )
{
	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncFilteringObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedSink->Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncFilteringObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		switch ( a_Flags )
		{
			case WBEM_STATUS_PROGRESS:
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					a_Flags ,
					a_Result ,
					a_StringParam ,
					a_ObjectParam
				) ;
			}
			break ;

			case WBEM_STATUS_COMPLETE:
			{
				if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
				{
					t_Result = m_InterceptedSink->SetStatus ( 

						a_Flags ,
						a_Result ,
						a_StringParam ,
						a_ObjectParam
					) ;
				}
			}
			break ;

			case WBEM_STATUS_REQUIREMENTS:
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					a_Flags ,
					a_Result ,
					a_StringParam ,
					a_ObjectParam
				) ;
			}
			break;

			default:
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}
			break ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncFilteringObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
	{
		t_Result = m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_SHUTTING_DOWN ,
			NULL ,
			NULL
		) ;
	}

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_DecoupledIWbemCombiningObjectSink :: CInterceptor_DecoupledIWbemCombiningObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller

) : CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	ObjectSinkContainerElement ( 

			a_Controller ,
			a_InterceptedSink
	) ,
	m_InterceptedSink ( a_InterceptedSink ) ,
	m_Event ( NULL ) , 
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_StatusCalled ( FALSE ) ,
	m_SinkCount ( 0 )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemCombiningObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	CWbemGlobal_IWmiObjectSinkController :: Initialize () ;

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}

	m_Event = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_DecoupledIWbemCombiningObjectSink :: ~CInterceptor_DecoupledIWbemCombiningObjectSink ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemCombiningObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_DecoupledIWbemCombiningObjectSink :: CallBackInternalRelease ()
{
	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_Event ) 
	{
		CloseHandle ( m_Event ) ;
	}

	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_DecoupledIWbemCombiningObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	
	else if ( iid == IID_IObjectSink_CancelOperation )
	{
		*iplpv = ( LPVOID ) ( IObjectSink_CancelOperation * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_DecoupledIWbemCombiningObjectSink :: AddRef ()
{
	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_DecoupledIWbemCombiningObjectSink :: Release ()
{
	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedSink->Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( FAILED ( a_Result ) )
		{
			ULONG t_SinkCount = InterlockedDecrement ( & m_SinkCount ) ;

			if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					0 ,
					a_Result ,
					NULL ,
					NULL 
				) ;

				SetEvent ( m_Event ) ;
			}
		}
		else
		{
			ULONG t_SinkCount = InterlockedDecrement ( & m_SinkCount ) ;
			if ( t_SinkCount == 0 )
			{
				if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
				{
					t_Result = m_InterceptedSink->SetStatus ( 

						0 ,
						S_OK ,
						NULL ,
						NULL 
					) ;

					SetEvent ( m_Event ) ;
				}
			}
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
	{
		t_Result = m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_SHUTTING_DOWN ,
			NULL ,
			NULL
		) ;
	}

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: Wait ( ULONG a_Timeout ) 
{
	HRESULT t_Result = S_OK ;

	ULONG t_Status = WaitForSingleObject ( m_Event , a_Timeout ) ;
	switch ( t_Status )
	{
		case WAIT_TIMEOUT:
		{
			t_Result = WBEM_E_TIMED_OUT ;
		}
		break ;

		case WAIT_OBJECT_0:
		{
		}
		break ;

		default:
		{
			t_Result = WBEM_E_FAILED ;
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: Cancel (

	LONG a_Flags
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	Lock () ;

	if ( t_Container->Size () )
	{
		IObjectSink_CancelOperation **t_Elements = new IObjectSink_CancelOperation * [ t_Container->Size () ] ;
		if ( t_Elements )
		{
			CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

			ULONG t_Count = 0 ;
			while ( ! t_Iterator.Null () )
			{
				t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IObjectSink_CancelOperation , ( void ** ) & t_Elements [ t_Count ] ) ;

				t_Iterator.Increment () ;

				t_Count ++ ;
			}

			UnLock () ;

			for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
			{
				if ( t_Elements [ t_Index ] ) 
				{
					t_Result = t_Elements [ t_Index ]->Cancel ( 

						a_Flags
					) ;

					IWbemShutdown *t_Shutdown = NULL ;
					HRESULT t_TempResult = t_Elements [ t_Index ]->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
					if ( SUCCEEDED ( t_TempResult ) )
					{
						t_TempResult = t_Shutdown->Shutdown ( 

							0 , 
							0 , 
							NULL 
						) ;

						t_Shutdown->Release () ;
					}

					t_Elements [ t_Index ]->Release () ;
				}
			}

			delete [] t_Elements ;
		}
		else
		{
			UnLock () ;

			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		UnLock () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: EnQueue ( CInterceptor_DecoupledIWbemObjectSink *a_Sink ) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

	WmiStatusCode t_StatusCode = Lock () ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		t_StatusCode = Insert ( 

			*a_Sink ,
			t_Iterator
		) ;

		UnLock () ;
	}

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		InterlockedIncrement ( & m_SinkCount ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_DecoupledIWbemCombiningObjectSink :: Suspend ()
{
	InterlockedIncrement ( & m_SinkCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_DecoupledIWbemCombiningObjectSink :: Resume ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_SinkCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		InterlockedIncrement ( & m_InProgress ) ;

		if ( m_GateClosed == 1 )
		{
		}
		else
		{
			if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
			{
				HRESULT t_Result = m_InterceptedSink->SetStatus ( 

					0 ,
					S_OK ,
					NULL ,
					NULL 
				) ;

				SetEvent ( m_Event ) ;
			}			
		}

		InterlockedDecrement ( & m_InProgress ) ;

	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemWaitingObjectSink :: CInterceptor_IWbemWaitingObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemServices *a_Provider ,
	IWbemObjectSink *a_InterceptedSink ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration 

) : CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	ObjectSinkContainerElement ( 

			a_Controller ,
			a_InterceptedSink
	) ,
	m_Queue ( a_Allocator ) ,
	m_Event ( NULL ) , 
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_StatusCalled ( FALSE ) ,
	m_Result ( S_OK ) ,
	m_SecurityDescriptor ( NULL ) ,
	m_ReferenceCount ( 0 ) ,
	m_Registration ( a_Registration ) ,
	m_Provider ( a_Provider ) ,
	m_CriticalSection (NOTHROW_LOCK)
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemWaitingObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	m_Registration.AddRef () ;

	if ( m_Provider )
	{
		m_Provider->AddRef () ;
	}

	WmiStatusCode t_StatusCode = m_Queue.Initialize () ;

	CWbemGlobal_IWmiObjectSinkController :: Initialize () ;

	m_Event = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;

}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink :: ~CInterceptor_IWbemWaitingObjectSink ()
{
	if ( m_Event ) 
	{
		CloseHandle ( m_Event ) ;
	}

	ULONG t_Count = m_Queue.Size();
	for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
	{
		IWbemClassObject *t_ClassObject ;
		WmiStatusCode t_StatusCode = m_Queue.Top ( t_ClassObject ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_ClassObject->Release () ;
			t_StatusCode = m_Queue.DeQueue () ;
		}
	}
	m_Queue.UnInitialize () ;
	

	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	if ( m_SecurityDescriptor )
	{
		delete [] m_SecurityDescriptor ;
	}

	m_Registration.Release () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemWaitingObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: Initialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor )
{
	return m_CriticalSection.valid() ? ProviderSubSystem_Common_Globals :: SinkAccessInitialize ( a_SecurityDescriptor , m_SecurityDescriptor ) :
								WBEM_E_OUT_OF_MEMORY;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemWaitingObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	
	else if ( iid == IID_IObjectSink_CancelOperation )
	{
		*iplpv = ( LPVOID ) ( IObjectSink_CancelOperation * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemWaitingObjectSink :: AddRef ()
{
	LONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;

	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemWaitingObjectSink :: Release ()
{
	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 1 )
	{
		if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
		{
			if ( SUCCEEDED ( m_Result ) )
			{
				m_Result = WBEM_E_UNEXPECTED ;
			}

			SetEvent ( m_Event ) ;
		}
	}

	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_IWbemWaitingObjectSink :: CallBackInternalRelease ()
{
	if ( m_Provider )
	{
		m_Provider->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: Cancel (

	LONG a_Flags
)
{
	HRESULT t_Result = S_OK ;

	if ( m_Provider )
	{
		t_Result = m_Provider->CancelAsyncCall (

			this
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( SUCCEEDED ( t_Result = ProviderSubSystem_Common_Globals :: CheckAccess ( m_SecurityDescriptor , MASK_PROVIDER_BINDING_BIND , & g_ProviderBindingMapping ) ) )
		{
			WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_CriticalSection , FALSE ) ;
			if ( t_StatusCode == e_StatusCode_Success )
			{
				for ( LONG t_Index = 0 ; SUCCEEDED ( t_Result ) && ( t_Index < a_ObjectCount ) ; t_Index ++ )
				{
					if ( a_ObjectArray [ t_Index ] )
					{
						WmiStatusCode t_StatusCode = m_Queue.EnQueue ( a_ObjectArray [ t_Index ] ) ;
						if ( t_StatusCode == e_StatusCode_Success )
						{
							a_ObjectArray [ t_Index ]->AddRef () ;
						}
						else
						{
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_OBJECT ;
					}
				}
				WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( SUCCEEDED ( t_Result = ProviderSubSystem_Common_Globals :: CheckAccess ( m_SecurityDescriptor , MASK_PROVIDER_BINDING_BIND , & g_ProviderBindingMapping ) ) )
		{
			if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
			{
				if ( SUCCEEDED ( m_Result ) )
				{
					m_Result = a_Result ;
				}

				SetEvent ( m_Event ) ;
			}
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
	{
		m_Result = WBEM_E_SHUTTING_DOWN ;

		SetEvent ( m_Event ) ;
	}

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: Wait ( ULONG a_Timeout ) 
{
	HRESULT t_Result = S_OK ;

	ULONG t_Status = WaitForSingleObject ( m_Event , a_Timeout ) ;
	switch ( t_Status )
	{
		case WAIT_TIMEOUT:
		{
			t_Result = WBEM_E_TIMED_OUT ;
		}
		break ;

		case WAIT_OBJECT_0:
		{
		}
		break ;

		default:
		{
			t_Result = WBEM_E_FAILED ;
		}
		break ;
	}

	ObjectSinkContainerElement :: GetController ()->Lock () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	ObjectSinkContainerElement :: GetController ()->GetContainer ( t_Container ) ;
	t_Container->Delete ( VoidPointerContainerElement :: GetKey () ) ;

	ObjectSinkContainerElement :: GetController ()->UnLock () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink_GetObjectAsync :: CInterceptor_IWbemWaitingObjectSink_GetObjectAsync ( 

	WmiAllocator &m_Allocator ,
	IWbemServices *a_Provider ,
	IWbemObjectSink *a_InterceptedSink ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration 

) : CInterceptor_IWbemWaitingObjectSink (

		m_Allocator ,
		a_Provider ,
		a_InterceptedSink ,
		a_Controller ,
		a_Registration 
	) ,
	m_ObjectPath ( NULL ) ,
	m_Flags ( 0 ) ,
	m_Context ( NULL ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink_GetObjectAsync :: ~CInterceptor_IWbemWaitingObjectSink_GetObjectAsync ()
{
	if ( m_ObjectPath ) 
	{
		SysFreeString ( m_ObjectPath ) ;
	}

	if ( m_Context )
	{
		m_Context->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink_GetObjectAsync :: Initialize (

	SECURITY_DESCRIPTOR *a_SecurityDescriptor , 
	BSTR a_ObjectPath ,
	LONG a_Flags ,
	IWbemContext *a_Context 
)
{
	HRESULT t_Result = S_OK ;

	m_Flags = a_Flags ;

	m_Context = a_Context ;
	if ( m_Context )
	{
		m_Context->AddRef () ;
	}

	m_ObjectPath = SysAllocString ( a_ObjectPath ) ;
	if ( m_ObjectPath == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CInterceptor_IWbemWaitingObjectSink :: Initialize ( a_SecurityDescriptor ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync :: CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync ( 

	WmiAllocator &m_Allocator ,
	IWbemServices *a_Provider ,
	IWbemObjectSink *a_InterceptedSink ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration 

) : CInterceptor_IWbemWaitingObjectSink (

		m_Allocator ,
		a_Provider ,
		a_InterceptedSink ,
		a_Controller ,
		a_Registration 
	) ,
	m_Class ( NULL ) ,
	m_Flags ( 0 ) ,
	m_Context ( NULL ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync :: ~CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync ()
{
	if ( m_Class ) 
	{
		SysFreeString ( m_Class ) ;
	}

	if ( m_Context )
	{
		m_Context->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync :: Initialize (

	SECURITY_DESCRIPTOR *a_SecurityDescriptor , 
	BSTR a_Class ,
	LONG a_Flags ,
	IWbemContext *a_Context 
)
{
	HRESULT t_Result = S_OK ;

	m_Flags = a_Flags ;

	m_Context = a_Context ;
	if ( m_Context )
	{
		m_Context->AddRef () ;
	}

	m_Class = SysAllocString ( a_Class ) ;
	if ( m_Class == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CInterceptor_IWbemWaitingObjectSink :: Initialize ( a_SecurityDescriptor ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync :: CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync ( 

	WmiAllocator &m_Allocator ,
	IWbemServices *a_Provider ,
	IWbemObjectSink *a_InterceptedSink ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration 

) : CInterceptor_IWbemWaitingObjectSink (

		m_Allocator ,
		a_Provider ,
		a_InterceptedSink ,
		a_Controller ,
		a_Registration 
	) ,
	m_SuperClass ( NULL ) ,
	m_Flags ( 0 ) ,
	m_Context ( NULL ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync :: ~CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync ()
{
	if ( m_SuperClass ) 
	{
		SysFreeString ( m_SuperClass ) ;
	}

	if ( m_Context )
	{
		m_Context->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync :: Initialize (

	SECURITY_DESCRIPTOR *a_SecurityDescriptor , 
	BSTR a_SuperClass ,
	LONG a_Flags ,
	IWbemContext *a_Context 
)
{
	HRESULT t_Result = S_OK ;

	m_Flags = a_Flags ;

	m_Context = a_Context ;
	if ( m_Context )
	{
		m_Context->AddRef () ;
	}

	m_SuperClass = SysAllocString ( a_SuperClass ) ;
	if ( m_SuperClass == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CInterceptor_IWbemWaitingObjectSink :: Initialize ( a_SecurityDescriptor ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink_PutClassAsync :: CInterceptor_IWbemWaitingObjectSink_PutClassAsync ( 

	WmiAllocator &m_Allocator ,
	IWbemServices *a_Provider ,
	IWbemObjectSink *a_InterceptedSink ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration 

) : CInterceptor_IWbemWaitingObjectSink (

		m_Allocator ,
		a_Provider ,
		a_InterceptedSink ,
		a_Controller ,
		a_Registration 
	) ,
	m_ClassObject ( NULL ) ,
	m_Flags ( 0 ) ,
	m_Context ( NULL ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink_PutClassAsync :: ~CInterceptor_IWbemWaitingObjectSink_PutClassAsync ()
{
	if ( m_ClassObject ) 
	{
		m_ClassObject->Release () ;
	}

	if ( m_Context )
	{
		m_Context->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink_PutClassAsync :: Initialize (

	SECURITY_DESCRIPTOR *a_SecurityDescriptor , 
	IWbemClassObject *a_ClassObject ,
	LONG a_Flags ,
	IWbemContext *a_Context 
)
{
	HRESULT t_Result = S_OK ;

	m_Flags = a_Flags ;

	m_Context = a_Context ;
	if ( m_Context )
	{
		m_Context->AddRef () ;
	}

	m_ClassObject = a_ClassObject ;
	if ( m_ClassObject )
	{
		m_ClassObject->AddRef () ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CInterceptor_IWbemWaitingObjectSink :: Initialize ( a_SecurityDescriptor ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWaitingObjectSink :: CWaitingObjectSink (

	WmiAllocator &a_Allocator

) : m_Queue ( a_Allocator ) ,
	m_Event ( NULL ) , 
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_StatusCalled ( FALSE ) ,
	m_Result ( S_OK ) ,
	m_CriticalSection(NOTHROW_LOCK)
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWaitingObjectSink :: ~CWaitingObjectSink ()
{
	if ( m_Event ) 
	{
		CloseHandle ( m_Event ) ;
	}
	ULONG t_Count = m_Queue.Size();
	for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
	{
		IWbemClassObject *t_ClassObject ;
		WmiStatusCode t_StatusCode = m_Queue.Top ( t_ClassObject ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_ClassObject->Release () ;
			t_StatusCode = m_Queue.DeQueue () ;
		}
	}
	m_Queue.UnInitialize () ;
	
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWaitingObjectSink :: SinkInitialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = m_Queue.Initialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		if ( m_CriticalSection.valid() )
		{
			m_Event = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
			if ( m_Event == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CWaitingObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CWaitingObjectSink :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CWaitingObjectSink :: Release ()
{
	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWaitingObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_CriticalSection , FALSE ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			for ( LONG t_Index = 0 ; SUCCEEDED ( t_Result ) && ( t_Index < a_ObjectCount ) ; t_Index ++ )
			{
				if ( a_ObjectArray [ t_Index ] )
				{
					WmiStatusCode t_StatusCode = m_Queue.EnQueue ( a_ObjectArray [ t_Index ] ) ;
					if ( t_StatusCode == e_StatusCode_Success )
					{
						a_ObjectArray [ t_Index ]->AddRef () ;
					}
					else
					{
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_OBJECT ;
				}
			}
			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWaitingObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
		{
			if ( SUCCEEDED ( m_Result ) )
			{
				m_Result = a_Result ;
			}

			SetEvent ( m_Event ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWaitingObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
	{
		m_Result = WBEM_E_SHUTTING_DOWN ;

		SetEvent ( m_Event ) ;
	}

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWaitingObjectSink :: Wait ( ULONG a_Timeout ) 
{
	HRESULT t_Result = S_OK ;

	ULONG t_Status = WaitForSingleObject ( m_Event , a_Timeout ) ;
	switch ( t_Status )
	{
		case WAIT_TIMEOUT:
		{
			t_Result = WBEM_E_TIMED_OUT ;
		}
		break ;

		case WAIT_OBJECT_0:
		{
		}
		break ;

		default:
		{
			t_Result = WBEM_E_FAILED ;
		}
		break ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provresv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvResv.h"
#include "ProvFact.h"
#include "ProvSubS.h"
#include "guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DynamicPropertyProviderResolver :: CServerObject_DynamicPropertyProviderResolver (

	WmiAllocator &a_Allocator ,
	_IWmiProviderFactory *a_Factory ,
	IWbemServices *a_CoreStub

) : m_ReferenceCount ( 0 ) ,
	m_Allocator ( a_Allocator ) ,
	m_Factory ( a_Factory ) ,
	m_CoreStub ( a_CoreStub ) ,
	m_User ( NULL ) ,
	m_Locale ( NULL )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_DynamicPropertyProviderResolver_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_Factory ) 
	{
		m_Factory->AddRef () ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->AddRef () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DynamicPropertyProviderResolver::~CServerObject_DynamicPropertyProviderResolver ()
{
	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_Factory ) 
	{
		m_Factory->Release () ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_DynamicPropertyProviderResolver_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_DynamicPropertyProviderResolver::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiDynamicPropertyResolver )
	{
		*iplpv = ( LPVOID ) ( _IWmiDynamicPropertyResolver * ) this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * )this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_DynamicPropertyProviderResolver :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_DynamicPropertyProviderResolver :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderResolver :: GetClassAndInstanceContext (

	IWbemClassObject *a_Class ,
	IWbemClassObject *a_Instance ,
	BSTR &a_ClassContext ,
	BSTR &a_InstanceContext ,
	BOOL &a_Dynamic
)
{
	HRESULT t_Result = S_OK ;

	a_Dynamic = FALSE ;
	a_ClassContext = NULL ;
	a_InstanceContext = NULL ;

	IWbemQualifierSet *t_InstanceQualifierObject = NULL ;
	t_Result = a_Instance->GetQualifierSet ( & t_InstanceQualifierObject ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;
		t_Result = t_InstanceQualifierObject->Get (
			
			ProviderSubSystem_Globals :: s_DynProps ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BOOL ) 
			{
				if ( t_Variant.boolVal == VARIANT_TRUE )
				{
					a_Dynamic = TRUE ;
 
					VARIANT t_Variant ;
					VariantInit ( & t_Variant ) ;

					t_Flavour = 0 ;
					HRESULT t_TempResult = t_InstanceQualifierObject->Get (
						
						ProviderSubSystem_Globals :: s_InstanceContext ,
						0 ,
						& t_Variant ,
						& t_Flavour 
					) ;

					if ( SUCCEEDED ( t_TempResult ) ) 
					{
						if ( t_Variant.vt == VT_BSTR ) 
						{
							a_InstanceContext = SysAllocString ( t_Variant.bstrVal ) ;
							if ( a_InstanceContext == NULL )
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}

						VariantClear ( & t_Variant ) ;
					}
					else
					{
						if ( t_TempResult != WBEM_E_NOT_FOUND )
						{
							t_Result = t_TempResult ;
						}
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						VARIANT t_ClassContextVariant ;
						VariantInit ( & t_ClassContextVariant ) ;

						t_TempResult = t_InstanceQualifierObject->Get (
							
							ProviderSubSystem_Globals :: s_ClassContext ,
							0 ,
							& t_ClassContextVariant ,
							& t_Flavour 
						) ;

						if ( SUCCEEDED ( t_TempResult ) ) 
						{
							if ( t_ClassContextVariant.vt == VT_BSTR ) 
							{
								a_ClassContext = SysAllocString ( t_ClassContextVariant.bstrVal ) ;
								if ( a_ClassContext == NULL )
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}

							VariantClear ( & t_ClassContextVariant ) ;
						}
						else
						{
							if ( t_TempResult != WBEM_E_NOT_FOUND )
							{
								t_Result = t_TempResult ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( a_ClassContext == NULL )
							{
								IWbemQualifierSet *t_ClassQualifierObject = NULL ;
								t_Result = a_Class->GetQualifierSet ( & t_ClassQualifierObject ) ;
								if ( SUCCEEDED ( t_Result ) )
								{
									VARIANT t_Variant ;
									VariantInit ( & t_Variant ) ;

									LONG t_Flavour = 0 ;

									HRESULT t_TempResult = t_ClassQualifierObject->Get (
										
										ProviderSubSystem_Globals :: s_ClassContext ,
										0 ,
										& t_Variant ,
										& t_Flavour 
									) ;

									if ( SUCCEEDED ( t_TempResult ) ) 
									{
										if ( t_Variant.vt == VT_BSTR ) 
										{
											a_ClassContext = SysAllocString ( t_Variant.bstrVal ) ;
										}
										else
										{
											t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
										}

										VariantClear ( & t_Variant ) ;
									}
									else
									{
										if ( t_TempResult != WBEM_E_NOT_FOUND )
										{
											t_Result = t_TempResult ;
										}
									}

									t_ClassQualifierObject->Release () ;
								}
								else
								{
									t_Result = WBEM_E_CRITICAL_ERROR ;
								}
							}
						}
					}
				}
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}

			VariantClear ( & t_Variant ) ;
		}
		else
		{
			if ( t_Result != WBEM_E_NOT_FOUND )
			{
			}
			else
			{
				t_Result = S_OK ;
			}
		}

		t_InstanceQualifierObject->Release () ;
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderResolver :: ReadOrWrite (

	IWbemContext *a_Context ,
	IWbemClassObject *a_Instance ,
	BSTR a_ClassContext ,
	BSTR a_InstanceContext ,
	BSTR a_PropertyContext ,
	BSTR a_Provider ,
	BSTR a_Property ,
	BOOL a_Read
)
{
	IWbemPropertyProvider *t_Provider = NULL ;

	WmiInternalContext t_InternalContext ;
	ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

	HRESULT t_Result = m_Factory->GetProvider ( 

		t_InternalContext ,
		0 ,
		a_Context ,
		NULL ,
		m_User ,
		m_Locale ,
		NULL ,
		a_Provider ,
		IID_IWbemPropertyProvider , 
		( void ** ) & t_Provider 

	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		if ( a_Read )
		{
			t_Result = t_Provider->GetProperty ( 

				0 ,
				m_Locale ,
				a_ClassContext ,
				a_InstanceContext ,
				a_PropertyContext ,
				& t_Variant 			
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = a_Instance->Put ( a_Property , 0 , & t_Variant , 0 ) ;

				VariantClear ( & t_Variant ) ;
			}	
		}
		else
		{
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			t_Result = a_Instance->Get ( a_Property , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Provider->PutProperty ( 

					0 ,
					m_Locale ,
					a_ClassContext ,
					a_InstanceContext ,
					a_PropertyContext ,
					& t_Variant 			
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = a_Instance->Put ( a_Property , 0 , NULL , 0 ) ;
				}	

				VariantClear ( & t_Variant ) ;
			}
		}

		t_Provider->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderResolver :: ReadOrWrite (

	IWbemContext *a_Context ,
	IWbemClassObject *a_Class ,
	IWbemClassObject *a_Instance ,
	BOOL a_Read
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_ClassContext = NULL ;
	BSTR t_InstanceContext = NULL ;
	BOOL t_Dynamic = FALSE ;

	t_Result = GetClassAndInstanceContext (

		a_Class ,
		a_Instance ,
		t_ClassContext ,
		t_InstanceContext ,
		t_Dynamic
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Dynamic )
		{
			IWbemQualifierSet *t_InstanceQualifierObject = NULL ;
			t_Result = a_Instance->GetQualifierSet ( & t_InstanceQualifierObject ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;

				BSTR t_Property = NULL ;
				CIMTYPE t_Type = CIM_EMPTY ;

				a_Instance->BeginEnumeration ( WBEM_FLAG_NONSYSTEM_ONLY ) ;
				while ( SUCCEEDED ( t_Result ) && ( a_Instance->Next ( 0 , & t_Property , &t_Variant  , &t_Type , NULL ) == WBEM_NO_ERROR ) )
				{
					BSTR t_PropertyContext = NULL ;
					BSTR t_Provider = NULL ;

					IWbemQualifierSet *t_PropertyQualifierSet = NULL ;
					if ( ( a_Instance->GetPropertyQualifierSet ( t_Property , &t_PropertyQualifierSet ) ) == WBEM_NO_ERROR ) 
					{
						VARIANT t_DynamicVariant ;
						VariantInit ( & t_DynamicVariant ) ;

						LONG t_Flag = 0 ;

						if ( SUCCEEDED ( t_PropertyQualifierSet->Get ( ProviderSubSystem_Globals :: s_Dynamic  , 0 , & t_DynamicVariant , &t_Flag ) ) )
						{
							if ( t_DynamicVariant.vt == VT_BOOL )
							{
								if ( t_DynamicVariant.boolVal == VARIANT_TRUE )
								{
									VARIANT t_ProviderVariant ;
									VariantInit ( & t_ProviderVariant ) ;

									t_Flag = 0 ;
									if ( SUCCEEDED ( t_PropertyQualifierSet->Get ( ProviderSubSystem_Globals :: s_Provider  , 0 , & t_ProviderVariant , &t_Flag ) ) )
									{
										if ( t_ProviderVariant.vt == VT_BSTR )
										{
											t_Provider = SysAllocString ( t_ProviderVariant.bstrVal ) ;
										}
										else
										{
											t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
										}

										VariantClear ( & t_ProviderVariant ) ;
									}
									else
									{
										t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
									}

									VARIANT t_PropertyContextVariant ;
									VariantInit ( & t_PropertyContextVariant ) ;

									t_Flag = 0 ;
									if ( SUCCEEDED ( t_PropertyQualifierSet->Get ( ProviderSubSystem_Globals :: s_PropertyContext  , 0 , & t_PropertyContextVariant , &t_Flag ) ) )
									{
										if ( t_PropertyContextVariant.vt == VT_BSTR )
										{
											t_PropertyContext = SysAllocString ( t_PropertyContextVariant.bstrVal ) ;
										}
										else
										{
											t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
										}

										VariantClear ( & t_PropertyContextVariant ) ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}

							VariantClear ( & t_DynamicVariant ) ;
						}
						
						t_PropertyQualifierSet->Release();
					
					}

					if ( SUCCEEDED ( t_Result ) && t_Provider ) 
					{
					    //
					    // discard the error here, as we did in W2K
					    //
						HRESULT t_ResultInner = ReadOrWrite ( 

							a_Context ,
							a_Instance ,
							t_ClassContext ,
							t_InstanceContext ,
							t_PropertyContext ,
							t_Provider ,
							t_Property ,
							a_Read 
						) ;
					}

					if ( t_PropertyContext ) 
					{
						SysFreeString ( t_PropertyContext ) ;
					}

					if ( t_Provider )
					{
						SysFreeString ( t_Provider ) ;
					}

					VariantClear ( & t_Variant ) ;

					SysFreeString ( t_Property ) ;
				}

				t_InstanceQualifierObject->Release () ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( t_ClassContext ) 
		{
			SysFreeString ( t_ClassContext ) ;
		}

		if ( t_InstanceContext ) 
		{
			SysFreeString ( t_InstanceContext ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderResolver :: Read (

	IWbemContext *a_Context ,
	IWbemClassObject *a_Class ,
	IWbemClassObject **a_Instance
)
{
	IWbemClassObject *t_Object = *a_Instance ;

	HRESULT t_Result = ReadOrWrite ( 

		a_Context ,
		a_Class ,
		t_Object ,
		TRUE 
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderResolver :: Write (

	IWbemContext *a_Context ,
    IWbemClassObject *a_Class ,
    IWbemClassObject *a_Instance
)
{
	HRESULT t_Result = ReadOrWrite ( 

		a_Context ,
		a_Class ,
		a_Instance ,
		FALSE
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderResolver :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_Core ,         // For anybody
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	if ( a_User )
	{
		m_User = SysAllocString ( a_User ) ;
		if ( ! m_User ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Locale )
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( ! m_Locale ) 
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderResolver :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provself.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include <PreComp.h>
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvResv.h"
#include "ProvFact.h"
#include "ProvSubS.h"
#include "ProvRegInfo.h"
#include "ProvSelf.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_IWbemServices :: CServerObject_IWbemServices (

	WmiAllocator &a_Allocator
) : 
	m_ReferenceCount ( 0 ) , 
	m_Service ( NULL ) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_IWbemServices_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_IWbemServices :: ~CServerObject_IWbemServices ()
{
	if ( m_Service )
	{
		m_Service->Release () ; 
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_IWbemServices_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_IWbemServices :: AddRef ( void )
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_IWbemServices :: Release ( void )
{
	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_IWbemServices :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices::OpenNamespace ( 

	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemServices **a_NamespaceService, 
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: QueryObjectSink ( 

	long a_Flags,		
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: GetObject ( 
		
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject **a_Object,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: Write_Msft_WmiProvider_Counters ( 
	
	IWbemClassObject *a_Object 
)
{
	if ( ProviderSubSystem_Globals :: GetSharedCounters () )
	{
		_IWmiObject *t_FastObject = NULL ;
		HRESULT t_Result = a_Object->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastObject ) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_FastObject->WriteProp (

				L"ProviderOperation_GetObjectAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_GetObjectAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_PutClassAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_PutClassAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_DeleteClassAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_DeleteClassAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_CreateClassEnumAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_CreateClassEnumAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_PutInstanceAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_PutInstanceAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_CreateInstanceEnumAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_CreateInstanceEnumAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_ExecQueryAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_ExecQueryAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_ExecNotificationQueryAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_ExecNotificationQueryAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_DeleteInstanceAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_DeleteInstanceAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_ExecMethodAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_ExecMethodAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_QueryInstances" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_QueryInstances
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_CreateRefresher" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_CreateRefresher
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_CreateRefreshableObject" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_CreateRefreshableObject
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_StopRefreshing" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_StopRefreshing
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_CreateRefreshableEnum" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_CreateRefreshableEnum
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_GetObjects" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_GetObjects
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_GetProperty" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_GetProperty
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_PutProperty" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_PutProperty
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_ProvideEvents" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_ProvideEvents
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_NewQuery" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_NewQuery
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_CancelQuery" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_CancelQuery
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_AccessCheck" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_AccessCheck
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_SetRegistrationObject" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_SetRegistrationObject
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_FindConsumer" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_FindConsumer
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_ValidateSubscription" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_ValidateSubscription
			) ;

			t_FastObject->Release () ;
		}

		return t_Result ;
	}

	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: GetObjectAsync_Msft_WmiProvider_Counters ( 
	
	IWbemPath *a_Path,
	BSTR a_Class ,
	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	ULONGLONG t_Information = 0 ;

	t_Result = a_Path->GetInfo (

		0 ,
		& t_Information
	) ;

	if ( t_Information & WBEMPATH_INFO_IS_SINGLETON )
	{
		IWbemClassObject *t_Object = NULL ;

		t_Result = m_Service->GetObject (

			a_Class ,
			0 ,
			a_Context ,
			& t_Object ,
			NULL 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_Instance = NULL ;
			t_Result = t_Object->SpawnInstance ( 

				0 , 
				& t_Instance 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Write_Msft_WmiProvider_Counters ( 
	
					t_Instance
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = a_Sink->Indicate ( 1 , & t_Instance ) ;

					t_Instance->Release () ;
				}
			}
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_OBJECT_PATH ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: GetObjectAsync_Msft_Providers ( 
	
	IWbemPath *a_Path,
	BSTR a_Class ,
	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProvSubSysController *t_SubSystemController = ProviderSubSystem_Globals :: GetProvSubSysController () ;
	if ( t_SubSystemController )
	{
		t_SubSystemController->Lock () ;

		CWbemGlobal_IWmiProvSubSysController_Container *t_Container = NULL ;
		t_SubSystemController->GetContainer ( t_Container ) ;

		if ( t_Container->Size () )
		{
			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator = t_Container->Begin ();

			_IWmiProviderConfiguration **t_ControllerElements = new _IWmiProviderConfiguration * [ t_Container->Size () ] ;
			if ( t_ControllerElements )
			{
				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				t_SubSystemController->UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ControllerElements [ t_Index ] )
					{
						t_Result = t_ControllerElements [ t_Index ]->Get ( 

							m_Service ,
							a_Flags, 
							a_Context,
							a_Class ,
							a_ObjectPath, 
							a_Sink
						) ;

						t_ControllerElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ControllerElements ;
			}
			else
			{
				t_SubSystemController->UnLock () ;
			}
		}
		else
		{
			t_SubSystemController->UnLock () ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	IWbemPath *t_Path = NULL ;

	if ( a_ObjectPath ) 
	{
		t_Result = CoCreateInstance (

			CLSID_WbemDefPath ,
			NULL ,
			CLSCTX_INPROC_SERVER ,
			IID_IWbemPath ,
			( void ** )  & t_Path
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Path->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_ObjectPath ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				ULONG t_Length = 32 ; // None of supported classes is longer than this length
				BSTR t_Class = SysAllocStringLen ( NULL , t_Length ) ; 

				if ( t_Class )
				{
					t_Result = t_Path->GetClassName (

						& t_Length ,
						t_Class
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( wbem_wcsicmp ( t_Class , L"Msft_WmiProvider_Counters" ) == 0 )
						{
							t_Result = GetObjectAsync_Msft_WmiProvider_Counters (

								t_Path ,
								t_Class ,
								a_ObjectPath, 
								a_Flags, 
								a_Context,
								a_Sink
							) ;
						}
						else if ( wbem_wcsicmp ( t_Class , L"Msft_Providers" ) == 0 )
						{
							t_Result = GetObjectAsync_Msft_Providers (

								t_Path ,
								t_Class ,
								a_ObjectPath, 
								a_Flags, 
								a_Context,
								a_Sink
							) ;
						}
						else
						{
							t_Result = WBEM_E_INVALID_CLASS ;
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_CLASS ;
					}

					SysFreeString ( t_Class ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
		}

		t_Path->Release () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: PutClass ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: PutClassAsync ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: DeleteClass ( 
		
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: DeleteClassAsync ( 
		
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: CreateClassEnum ( 

	const BSTR a_Superclass, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CServerObject_IWbemServices :: CreateClassEnumAsync (

	const BSTR a_Superclass, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: PutInstance (

    IWbemClassObject *a_Instance,
    long a_Flags,
    IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags, 
    IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: DeleteInstance ( 

	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CServerObject_IWbemServices :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext FAR *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: CreateInstanceEnumAsync_Msft_Providers (

 	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink 
) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProvSubSysController *t_SubSystemController = ProviderSubSystem_Globals :: GetProvSubSysController () ;
	if ( t_SubSystemController )
	{
		t_SubSystemController->Lock () ;

		CWbemGlobal_IWmiProvSubSysController_Container *t_Container = NULL ;
		t_SubSystemController->GetContainer ( t_Container ) ;

		if ( t_Container->Size () )
		{
			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator = t_Container->Begin ();

			_IWmiProviderConfiguration **t_ControllerElements = new _IWmiProviderConfiguration * [ t_Container->Size () ] ;
			if ( t_ControllerElements )
			{
				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				t_SubSystemController->UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ControllerElements [ t_Index ] )
					{
						HRESULT t_Result = t_ControllerElements [ t_Index ]->Enumerate ( 

							m_Service ,
							a_Flags, 
							a_Context,
 							a_Class, 
							a_Sink 
						) ;

						t_ControllerElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ControllerElements ;
			}
			else
			{
				t_SubSystemController->UnLock () ;
			}
		}
		else
		{
			t_SubSystemController->UnLock () ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: CreateInstanceEnumAsync_Msft_WmiProvider_Counters (

 	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink 
) 
{
	IWbemClassObject *t_Object = NULL ;
	HRESULT t_Result = m_Service->GetObject (

		a_Class ,
		0 ,
		a_Context ,
		& t_Object ,
		NULL 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemClassObject *t_Instance = NULL ;
		t_Result = t_Object->SpawnInstance ( 

			0 , 
			& t_Instance 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = Write_Msft_WmiProvider_Counters ( 

				t_Instance
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = a_Sink->Indicate ( 1 , & t_Instance ) ;
			}

			t_Instance->Release () ;
		}

		t_Object->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: CreateInstanceEnumAsync (

 	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink 
) 
{
	HRESULT t_Result = S_OK ;

	if ( wbem_wcsicmp ( a_Class , L"Msft_WmiProvider_Counters" ) == 0 )
	{
		t_Result = CreateInstanceEnumAsync_Msft_WmiProvider_Counters (

 			a_Class, 
			a_Flags, 
			a_Context,
			a_Sink 
		) ;
	}
	else if ( wbem_wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
	{
		t_Result = CreateInstanceEnumAsync_Msft_Providers (

 			a_Class, 
			a_Flags, 
			a_Context,
			a_Sink 
		) ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CServerObject_IWbemServices :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CServerObject_IWbemServices :: ExecMethod ( 

	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
    IWbemClassObject **a_OutParams,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: Helper_ExecMethodAsync_Suspend ( 

    IWbemPath *a_Path ,
	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProvSubSysController *t_SubSystemController = ProviderSubSystem_Globals :: GetProvSubSysController () ;
	if ( t_SubSystemController )
	{
		t_SubSystemController->Lock () ;

		CWbemGlobal_IWmiProvSubSysController_Container *t_Container = NULL ;
		t_SubSystemController->GetContainer ( t_Container ) ;

		if ( t_Container->Size () )
		{
			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator = t_Container->Begin ();

			_IWmiProviderConfiguration **t_ControllerElements = new _IWmiProviderConfiguration * [ t_Container->Size () ] ;
			if ( t_ControllerElements )
			{
				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				t_SubSystemController->UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ControllerElements [ t_Index ] )
					{
						t_Result = t_ControllerElements [ t_Index ]->Call ( 

							m_Service ,
							a_Flags ,
							a_Context ,
							L"Msft_Providers" ,
							a_ObjectPath ,		
							a_MethodName ,
							a_InParams,
							a_Sink
						) ;

						t_ControllerElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ControllerElements ;
			}
			else
			{
				t_SubSystemController->UnLock () ;
			}
		}
		else
		{
			t_SubSystemController->UnLock () ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: Helper_ExecMethodAsync_Resume ( 

    IWbemPath *a_Path ,
	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProvSubSysController *t_SubSystemController = ProviderSubSystem_Globals :: GetProvSubSysController () ;
	if ( t_SubSystemController )
	{
		t_SubSystemController->Lock () ;

		CWbemGlobal_IWmiProvSubSysController_Container *t_Container = NULL ;
		t_SubSystemController->GetContainer ( t_Container ) ;

		if ( t_Container->Size () )
		{
			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator = t_Container->Begin ();

			_IWmiProviderConfiguration **t_ControllerElements = new _IWmiProviderConfiguration * [ t_Container->Size () ] ;
			if ( t_ControllerElements )
			{
				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				t_SubSystemController->UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ControllerElements [ t_Index ] )
					{
						t_Result = t_ControllerElements [ t_Index ]->Call ( 

							m_Service ,
							a_Flags ,
							a_Context ,
							L"Msft_Providers" ,
							a_ObjectPath ,		
							a_MethodName ,
							a_InParams,
							a_Sink
						) ;

						t_ControllerElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ControllerElements ;
			}
			else
			{
				t_SubSystemController->UnLock () ;
			}
		}
		else
		{
			t_SubSystemController->UnLock () ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: Helper_ExecMethodAsync_Load ( 

    IWbemPath *a_Path ,
	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProvSubSysController *t_SubSystemController = ProviderSubSystem_Globals :: GetProvSubSysController () ;
	if ( t_SubSystemController )
	{
		t_SubSystemController->Lock () ;

		CWbemGlobal_IWmiProvSubSysController_Container *t_Container = NULL ;
		t_SubSystemController->GetContainer ( t_Container ) ;

		if ( t_Container->Size () )
		{
			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator = t_Container->Begin ();

			_IWmiProviderConfiguration **t_ControllerElements = new _IWmiProviderConfiguration * [ t_Container->Size () ] ;
			if ( t_ControllerElements )
			{
				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				t_SubSystemController->UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ControllerElements [ t_Index ] )
					{
						t_Result = t_ControllerElements [ t_Index ]->Call ( 

							m_Service ,
							a_Flags ,
							a_Context ,
							L"Msft_Providers" ,
							a_ObjectPath ,		
							a_MethodName ,
							a_InParams,
							a_Sink
						) ;

						t_ControllerElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ControllerElements ;
			}
			else
			{
				t_SubSystemController->UnLock () ;
			}
		}
		else
		{
			t_SubSystemController->UnLock () ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: Helper_ExecMethodAsync_UnLoad ( 

    IWbemPath *a_Path ,
	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProvSubSysController *t_SubSystemController = ProviderSubSystem_Globals :: GetProvSubSysController () ;
	if ( t_SubSystemController )
	{
		t_SubSystemController->Lock () ;

		CWbemGlobal_IWmiProvSubSysController_Container *t_Container = NULL ;
		t_SubSystemController->GetContainer ( t_Container ) ;

		if ( t_Container->Size () )
		{
			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator = t_Container->Begin ();

			_IWmiProviderConfiguration **t_ControllerElements = new _IWmiProviderConfiguration * [ t_Container->Size () ] ;
			if ( t_ControllerElements )
			{
				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				t_SubSystemController->UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ControllerElements [ t_Index ] )
					{
						t_Result = t_ControllerElements [ t_Index ]->Call ( 

							m_Service ,
							a_Flags ,
							a_Context ,
							L"Msft_Providers" ,
							a_ObjectPath ,		
							a_MethodName ,
							a_InParams,
							a_Sink
						) ;

						t_ControllerElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ControllerElements ;
			}
			else
			{
				t_SubSystemController->UnLock () ;
			}
		}
		else
		{
			t_SubSystemController->UnLock () ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	t_Result = CoImpersonateClient () ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ProviderSubSystem_Common_Globals :: Check_SecurityDescriptor_CallIdentity (

			ProviderSubSystem_Common_Globals :: GetMethodSecurityDescriptor () , 
			MASK_PROVIDER_BINDING_BIND ,
			& g_ProviderBindingMapping
		) ;

		CoRevertToSelf () ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemPath *t_Path = NULL ;

		if ( a_ObjectPath && a_MethodName ) 
		{
			t_Result = CoCreateInstance (

				CLSID_WbemDefPath ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IWbemPath ,
				( void ** )  & t_Path
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Path->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_ObjectPath ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					ULONG t_Length = 32 ; // None of supported classes is longer than this length
					BSTR t_Class = SysAllocStringLen ( NULL , t_Length ) ; 
					if ( t_Class )
					{
						t_Result = t_Path->GetClassName (

							& t_Length ,
							t_Class
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( wbem_wcsicmp ( t_Class , L"Msft_Providers" ) == 0 ) 
							{
								if ( wbem_wcsicmp ( a_MethodName , L"Suspend" ) == 0 ) 
								{
									t_Result = Helper_ExecMethodAsync_Suspend (

										t_Path ,
										a_ObjectPath,
										a_MethodName,
										a_Flags,
										a_Context,
										a_InParams,
										a_Sink
									) ;
								}
								else if ( wbem_wcsicmp ( a_MethodName , L"Resume" ) == 0 ) 
								{
									t_Result = Helper_ExecMethodAsync_Resume (

										t_Path ,
										a_ObjectPath,
										a_MethodName,
										a_Flags,
										a_Context,
										a_InParams,
										a_Sink
									) ;
								}
								else if ( wbem_wcsicmp ( a_MethodName , L"Load" ) == 0 ) 
								{
									t_Result = Helper_ExecMethodAsync_Load (

										t_Path ,
										a_ObjectPath,
										a_MethodName,
										a_Flags,
										a_Context,
										a_InParams,
										a_Sink
									) ;
								}
								else if ( wbem_wcsicmp ( a_MethodName , L"UnLoad" ) == 0 ) 
								{
									t_Result = Helper_ExecMethodAsync_UnLoad (

										t_Path ,
										a_ObjectPath,
										a_MethodName,
										a_Flags,
										a_Context,
										a_InParams,
										a_Sink
									) ;
								}
							}
							else
							{
								t_Result = WBEM_E_INVALID_CLASS ;
							}
						}

						SysFreeString ( t_Class ) ;
					}
				}

				t_Path->Release () ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
			t_Result = WBEM_E_INVALID_OBJECT_PATH ;
		}
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_Core ,
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	m_Service = a_Core ;
	if ( m_Service )
	{
		m_Service->AddRef () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provrmgr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvSubS.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <wbemint.h>

#include <HelperFuncs.h>
#include <Logging.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ClassFac.h"
#include "ProvRMgr.h"
#include "Guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerProvRefreshManagerClassFactory :: CServerProvRefreshManagerClassFactory () : m_ReferenceCount ( 0 )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerProvRefreshManagerClassFactory_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerProvRefreshManagerClassFactory :: ~CServerProvRefreshManagerClassFactory ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerProvRefreshManagerClassFactory_ObjectsInProgress  ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;	
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerProvRefreshManagerClassFactory :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) ( IClassFactory * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerProvRefreshManagerClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerProvRefreshManagerClassFactory :: Release ()
{
	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerProvRefreshManagerClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR *ppvObject
)
{
	HRESULT t_Result = S_OK ;

	if ( pUnkOuter )
	{
		t_Result = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		CServerObject_ProviderRefresherManager *t_Manager = new CServerObject_ProviderRefresherManager (

			*ProviderSubSystem_Globals :: s_Allocator
		) ;

		if ( t_Manager == NULL )
		{
			t_Result = E_OUTOFMEMORY ;
		}
		else
		{
			t_Result = t_Manager->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( t_Result ) )
			{
				delete t_Manager ;
			}
			else
			{
			}
		}			
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerProvRefreshManagerClassFactory :: LockServer ( BOOL fLock )
{
/*
 * Place code in critical section
 */

	if ( fLock )
	{
		InterlockedIncrement ( & ProviderSubSystem_Globals :: s_LocksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & ProviderSubSystem_Globals :: s_LocksInProgress ) ;
	}

	return S_OK	;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CServerObject_InterceptorProviderRefresherManager :: CServerObject_InterceptorProviderRefresherManager (

	CWbemGlobal_IWbemRefresherMgrController *a_Controller ,
	const ULONG &a_Period ,
	WmiAllocator &a_Allocator ,
	IWbemContext *a_InitializationContext

) : RefresherManagerCacheElement ( 

		a_Controller ,
		this ,
		a_Period 
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Manager ( NULL ) ,
	m_ProxyContainer ( m_Allocator , 2 , MAX_PROXIES ) ,
	m_Shutdown ( NULL ) ,
	m_Host ( NULL ) ,
	m_ReferenceCount ( 0 ) ,
	m_UnInitialized ( 0 ) ,
	m_Initialized ( 0 ) ,
	m_InitializeResult ( S_OK ) ,
	m_InitializedEvent ( NULL ) , 
	m_InitializationContext ( a_InitializationContext )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_InterceptorProviderRefresherManager_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_InitializationContext )
	{
		m_InitializationContext->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_InterceptorProviderRefresherManager :: ~CServerObject_InterceptorProviderRefresherManager ()
{
	if ( m_Manager )
	{
		m_Manager->Release () ;
	}

	if ( m_Host )
	{
		m_Host->Release () ;	
	}

	if ( m_Shutdown )
	{
		m_Shutdown->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_InterceptorProviderRefresherManager_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: AbnormalShutdown () 
{
	WmiStatusCode t_StatusCode = ProviderSubSystem_Globals :: GetRefresherManagerController ()->Shutdown ( this ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: SetManager ( _IWmiProviderHost *a_Host , _IWbemRefresherMgr *a_Manager )
{
	if ( a_Manager )
	{
		m_Manager = a_Manager ;
		m_Manager->AddRef () ;
	}

	if ( a_Host )
	{
		m_Host = a_Host ;
		m_Host->AddRef () ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: SetInitialized ( HRESULT a_InitializeResult )
{
	m_InitializeResult = a_InitializeResult ;

	InterlockedExchange ( & m_Initialized , 1 ) ;

	if ( m_InitializedEvent )
	{
		SetEvent ( m_InitializedEvent ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: IsIndependant ( IWbemContext *a_Context )
{
	BOOL t_DependantCall = FALSE ;
	HRESULT t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_DependantCall == FALSE )
		{
		}
		else
		{
			return S_FALSE ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout )
{
	HRESULT t_Result = WBEM_E_UNEXPECTED ;

	if ( m_Initialized == 0 )
	{
		BOOL t_DependantCall = FALSE ;
		t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_DependantCall == FALSE )
			{
				if ( WaitForSingleObject ( m_InitializedEvent , a_Timeout ) == WAIT_TIMEOUT )
				{
					return WBEM_E_PROVIDER_LOAD_FAILURE ;
				}
			}
			else
			{
				if ( WaitForSingleObject ( m_InitializedEvent , 0 ) == WAIT_TIMEOUT )
				{
					return S_FALSE ;
				}
			}
		}
	}
	else
	{
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: Initialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_InterceptorProviderRefresherManager :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * )this ;		
	}	
	else if ( iid == IID__IWbemRefresherMgr )
	{
		*iplpv = ( LPVOID ) ( _IWbemRefresherMgr * ) this ;		
	}	
	else if ( iid == IID_CServerObject_InterceptorProviderRefresherManager )
	{
		*iplpv = ( LPVOID ) this ;
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_InterceptorProviderRefresherManager :: AddRef ()
{
	return RefresherManagerCacheElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_InterceptorProviderRefresherManager :: Release ()
{
	return RefresherManagerCacheElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: Startup (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	_IWmiProvSS *a_ProvSS
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , IID__IWbemRefresherMgr , m_Manager , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Manager->Startup ( 

					a_Flags ,
					a_Context ,
					a_ProvSS
				) ;
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					_IWbemRefresherMgr *t_Manager = ( _IWbemRefresherMgr * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Manager ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Manager->Startup ( 

								a_Flags ,
								a_Context ,
								a_ProvSS
							) ;

							if ( FAILED ( t_Result ) )
							{
								if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
								{
									AbnormalShutdown () ;
								}
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}	

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = m_Manager->QueryInterface ( IID_IWbemShutdown , ( void ** ) & m_Shutdown ) ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		if ( m_Shutdown )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemShutdown , IID_IWbemShutdown , m_Shutdown , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_Shutdown->Shutdown ( 

						a_Flags ,
						a_MaxMilliSeconds ,
						a_Context
					) ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemShutdown *t_Shutdown = ( IWbemShutdown * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Shutdown ,
							RPC_C_AUTHN_LEVEL_DEFAULT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Shutdown->Shutdown ( 

									a_Flags ,
									a_MaxMilliSeconds ,
									a_Context
								) ;

								if ( FAILED ( t_Result ) )
								{
									if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
									{
										AbnormalShutdown () ;
									}
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}	

						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemShutdown , t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: AddObjectToRefresher (

	IWbemServices *a_Service, 
	LPCWSTR a_ServerName, 
	LPCWSTR a_Namespace, 
	IWbemClassObject* pClassObject,
	WBEM_REFRESHER_ID *a_DestinationRefresherId, 
	IWbemClassObject *a_InstanceTemplate, 
	long a_Flags, 
	IWbemContext *a_Context,
	IUnknown* a_pLockMgr,
	WBEM_REFRESH_INFO *a_Information
) 
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	if ( m_Initialized == 0 )
	{
		return WBEM_E_NOT_FOUND ;
	}

	HRESULT t_Result = S_OK ;

	try
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , IID__IWbemRefresherMgr , m_Manager , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Manager->AddObjectToRefresher (

					a_Service, 
					a_ServerName, 
					a_Namespace, 
					pClassObject,
					a_DestinationRefresherId, 
					a_InstanceTemplate, 
					a_Flags, 
					a_Context,
					a_pLockMgr,
					a_Information
				) ;
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					_IWbemRefresherMgr *t_Manager = ( _IWbemRefresherMgr * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Manager ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Manager->AddObjectToRefresher (

								a_Service, 
								a_ServerName, 
								a_Namespace, 
								pClassObject,
								a_DestinationRefresherId, 
								a_InstanceTemplate, 
								a_Flags, 
								a_Context,
								a_pLockMgr,
								a_Information
							) ;

							if ( FAILED ( t_Result ) )
							{
								if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
								{
									AbnormalShutdown () ;
								}
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}	

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: AddEnumToRefresher (

	IWbemServices *a_Service, 
	LPCWSTR a_ServerName, 
	LPCWSTR a_Namespace, 
	IWbemClassObject* pClassObject,
	WBEM_REFRESHER_ID *a_DestinationRefresherId, 
	IWbemClassObject *a_InstanceTemplate, 
	LPCWSTR a_Class,
	long a_Flags, 
	IWbemContext *a_Context, 
	IUnknown* a_pLockMgr,
	WBEM_REFRESH_INFO *a_Information
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	if ( m_Initialized == 0 )
	{
		return WBEM_E_NOT_FOUND ;
	}

	HRESULT t_Result = S_OK ;

	try
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , IID__IWbemRefresherMgr , m_Manager , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Manager->AddEnumToRefresher (

					a_Service, 
					a_ServerName, 
					a_Namespace, 
					pClassObject,
					a_DestinationRefresherId, 
					a_InstanceTemplate, 
					a_Class,
					a_Flags, 
					a_Context, 
					a_pLockMgr,
					a_Information
				) ;
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					_IWbemRefresherMgr *t_Manager = ( _IWbemRefresherMgr * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Manager ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Manager->AddEnumToRefresher (

								a_Service, 
								a_ServerName, 
								a_Namespace, 
								pClassObject,
								a_DestinationRefresherId, 
								a_InstanceTemplate, 
								a_Class,
								a_Flags, 
								a_Context, 
								a_pLockMgr,
								a_Information
							) ;

							if ( FAILED ( t_Result ) )
							{
								if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
								{
									AbnormalShutdown () ;
								}
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}	

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: GetRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId , 
	long a_Flags, 
	BOOL a_AddRefresher,
	IWbemRemoteRefresher **a_RemoteRefresher ,  
	IUnknown* a_pLockMgr,
	GUID *a_Guid
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	if ( m_Initialized == 0 )
	{
		return WBEM_E_NOT_FOUND ;
	}

	HRESULT t_Result = S_OK ;

	try
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , IID__IWbemRefresherMgr , m_Manager , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Manager->GetRemoteRefresher (

					a_RefresherId , 
					a_Flags,
					a_AddRefresher,
					a_RemoteRefresher ,  
					a_pLockMgr,
					a_Guid
				) ;
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					_IWbemRefresherMgr *t_Manager = ( _IWbemRefresherMgr * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Manager ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Manager->GetRemoteRefresher (

								a_RefresherId , 
								a_Flags,
								a_AddRefresher,
								a_RemoteRefresher ,
								a_pLockMgr,
								a_Guid
							) ;

							if ( FAILED ( t_Result ) )
							{
								if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
								{
									AbnormalShutdown () ;
								}
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}	

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: LoadProvider (

	IWbemServices *a_Service ,
	LPCWSTR a_ProviderName ,
	LPCWSTR a_Namespace,
	IWbemContext * a_Context,
	IWbemHiPerfProvider **a_Provider,
	_IWmiProviderStack** a_ProvStack
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	if ( m_Initialized == 0 )
	{
		return WBEM_E_NOT_FOUND ;
	}

	HRESULT t_Result = S_OK ;

	try
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , IID__IWbemRefresherMgr , m_Manager , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Manager->LoadProvider (

					a_Service , 
					a_ProviderName ,
					a_Namespace ,
					a_Context ,
					a_Provider,
					a_ProvStack
				) ;
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					_IWbemRefresherMgr *t_Manager = ( _IWbemRefresherMgr * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Manager ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Manager->LoadProvider (

								a_Service , 
								a_ProviderName ,
								a_Namespace ,
								a_Context ,
								a_Provider ,
								a_ProvStack
							) ;

							if ( FAILED ( t_Result ) )
							{
								if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
								{
									AbnormalShutdown () ;
								}
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}	

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRefresherManager :: CServerObject_ProviderRefresherManager (

	WmiAllocator &a_Allocator

) : m_Allocator ( a_Allocator ) ,
	m_Manager ( NULL ) ,
	m_Shutdown ( NULL ) ,
	m_ReferenceCount ( 0 )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_ProviderRefresherManager_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRefresherManager :: ~CServerObject_ProviderRefresherManager ()
{
	if ( m_Manager )
	{
		m_Manager->Release () ;
	}

	if ( m_Shutdown )
	{
		m_Shutdown->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_ProviderRefresherManager_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_ProviderRefresherManager :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * )this ;		
	}	
	else if ( iid == IID__IWbemRefresherMgr )
	{
		*iplpv = ( LPVOID ) ( _IWbemRefresherMgr * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_ProviderRefresherManager :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_ProviderRefresherManager :: Release ()
{
	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRefresherManager :: Startup (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	_IWmiProvSS *a_ProvSS
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		t_Result = ProviderSubSystem_Common_Globals :: CreateInstance	(

			CLSID__WbemRefresherMgr ,
			NULL ,
			CLSCTX_INPROC_SERVER ,
			IID__IWbemRefresherMgr ,
			( void ** ) & m_Manager
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = m_Manager->Startup ( 

				a_Flags ,
				a_Context ,
				a_ProvSS
			) ;

			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = m_Manager->QueryInterface ( IID_IWbemShutdown , ( void ** ) & m_Shutdown ) ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRefresherManager :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		t_Result = m_Shutdown->Shutdown ( 

			a_Flags ,
			a_MaxMilliSeconds ,
			a_Context
		) ;
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRefresherManager :: AddObjectToRefresher (

	IWbemServices *a_Service, 
	LPCWSTR a_ServerName, 
	LPCWSTR a_Namespace, 
	IWbemClassObject* pClassObject,
	WBEM_REFRESHER_ID *a_DestinationRefresherId, 
	IWbemClassObject *a_InstanceTemplate, 
	long a_Flags, 
	IWbemContext *a_Context,
	IUnknown* a_pLockMgr,
	WBEM_REFRESH_INFO *a_Information
) 
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		t_Result = m_Manager->AddObjectToRefresher (

			a_Service, 
			a_ServerName, 
			a_Namespace, 
			pClassObject,
			a_DestinationRefresherId, 
			a_InstanceTemplate, 
			a_Flags, 
			a_Context,
			a_pLockMgr,
			a_Information
		) ;
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRefresherManager :: AddEnumToRefresher (

	IWbemServices *a_Service, 
	LPCWSTR a_ServerName, 
	LPCWSTR a_Namespace, 
	IWbemClassObject* pClassObject,
	WBEM_REFRESHER_ID *a_DestinationRefresherId, 
	IWbemClassObject *a_InstanceTemplate, 
	LPCWSTR a_Class,
	long a_Flags, 
	IWbemContext *a_Context, 
	IUnknown* a_pLockMgr,
	WBEM_REFRESH_INFO *a_Information
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		t_Result = m_Manager->AddEnumToRefresher (

			a_Service, 
			a_ServerName, 
			a_Namespace, 
			pClassObject,
			a_DestinationRefresherId, 
			a_InstanceTemplate, 
			a_Class,
			a_Flags, 
			a_Context, 
			a_pLockMgr,
			a_Information
		) ;
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRefresherManager :: GetRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId , 
	long a_Flags, 
	BOOL fAddRefresher,
	IWbemRemoteRefresher **a_RemoteRefresher ,  
	IUnknown* a_pLockMgr,
	GUID *a_Guid
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		t_Result = m_Manager->GetRemoteRefresher (

			a_RefresherId , 
			a_Flags,
			fAddRefresher,
			a_RemoteRefresher ,  
			a_pLockMgr,
			a_Guid
		) ;
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRefresherManager :: LoadProvider (

	IWbemServices *a_Service ,
	LPCWSTR a_ProviderName ,
	LPCWSTR a_Namespace,
	IWbemContext * a_Context,
	IWbemHiPerfProvider **a_Provider,
	_IWmiProviderStack** a_ProvStack
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		t_Result = m_Manager->LoadProvider (

			a_Service , 
			a_ProviderName ,
			a_Namespace ,
			a_Context ,
			a_Provider ,
			a_ProvStack
		) ;
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provsubs.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvSubS.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <wbemint.h>

#include <HelperFuncs.h>
#include <Logging.h>

#include <CGlobals.h>
#include "Globals.h"
#include "ClassFac.h"
#include "ProvResv.h"
#include "ProvFact.h"
#include "ProvSubS.h"
#include "ProvAggr.h"
#include "ProvHost.h"
#include "ProvLoad.h"
#include "ProvRMgr.h"
#include "StrobeThread.h"
#include "ProvCache.h"
#include "ProvDnf.h"
#include "Guids.h"
#include "winmgmtr.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWmiProvSSSink :: CInterceptor_IWmiProvSSSink (

	_IWmiProvSSSink *a_InterceptedSink ,
	CWbemGlobal_VoidPointerController *a_Controller 

)	:	VoidPointerContainerElement ( 

			a_Controller ,
			a_InterceptedSink
		) ,
		m_InterceptedSink ( a_InterceptedSink )
{
	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWmiProvSSSink :: ~CInterceptor_IWmiProvSSSink  ()
{
	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}


	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWmiProvSSSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiProvSSSink )
	{
		*iplpv = ( LPVOID ) ( _IWmiProvSSSink * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWmiProvSSSink :: AddRef ( void )
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWmiProvSSSink :: Release ( void )
{
	return VoidPointerContainerElement:: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWmiProvSSSink :: Synchronize (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Namespace ,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = m_InterceptedSink->Synchronize (

		a_Flags ,
		a_Context ,
		a_Namespace ,
		a_Provider

	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerProvSubSysClassFactory :: CServerProvSubSysClassFactory () : m_ReferenceCount ( 0 )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerProvSubSysClassFactory :: ~CServerProvSubSysClassFactory ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerProvSubSysClassFactory :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) ( IClassFactory * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerProvSubSysClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerProvSubSysClassFactory :: Release ()
{
	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerProvSubSysClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR *ppvObject
)
{
	HRESULT t_Result = S_OK ;

	if ( pUnkOuter )
	{
		t_Result = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		CWbemGlobal_IWmiProvSubSysController *t_Controller = ProviderSubSystem_Globals :: GetProvSubSysController () ;

		CServerObject_ProviderSubSystem *t_ProvSubSys = new CServerObject_ProviderSubSystem (

			*ProviderSubSystem_Globals :: s_Allocator ,
			t_Controller
		) ;

		if ( t_ProvSubSys == NULL )
		{
			t_Result = E_OUTOFMEMORY ;
		}
		else
		{
			t_ProvSubSys->AddRef () ;

			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator ;

			t_Controller->Lock () ;

			WmiStatusCode t_StatusCode = t_Controller->Insert (

				*t_ProvSubSys ,
				t_Iterator
			) ;

			if ( t_StatusCode != e_StatusCode_Success )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			t_Controller->UnLock () ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_ProvSubSys->QueryInterface ( riid , ppvObject ) ;
				if ( FAILED ( t_Result ) )
				{
					t_ProvSubSys->Release () ;
				}
			}

			t_ProvSubSys->Release () ;			
		}			
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerProvSubSysClassFactory :: LockServer ( BOOL fLock )
{
/*
 * Place code in critical section
 */

	if ( fLock )
	{
		InterlockedIncrement ( & ProviderSubSystem_Globals :: s_LocksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & ProviderSubSystem_Globals :: s_LocksInProgress ) ;
	}

	return S_OK	;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CServerObject_ProviderSubSystem :: CServerObject_ProviderSubSystem (

	WmiAllocator &a_Allocator ,
	CWbemGlobal_IWmiProvSubSysController *a_Controller

) : CWbemGlobal_IWmiFactoryController ( a_Allocator ) ,
	ProvSubSysContainerElement (

		a_Controller ,
		this
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Core ( NULL ) ,
	m_Internal ( this ) ,
	m_SinkController ( NULL ) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_ProviderSubSystem_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderSubSystem :: ~CServerObject_ProviderSubSystem ()
{
	CWbemGlobal_IWmiFactoryController :: UnInitialize () ;

	ClearSinkController () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_ProviderSubSystem_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: ClearSinkController ()
{
	HRESULT t_Result = S_OK ;

	if ( m_SinkController )
	{
		CWbemGlobal_VoidPointerController_Container *t_Container = NULL ;
		
		m_SinkController->GetContainer ( t_Container ) ;

		m_SinkController->Lock () ;

		if ( t_Container->Size () )
		{
			CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator = t_Container->Begin ();
			while ( ! t_Iterator.Null () )
			{
				_IWmiProvSSSink *t_Sink = NULL ;

				t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProvSSSink  , ( void ** ) & t_Sink ) ;

				t_Iterator.Increment () ;

				t_Sink->Release () ;

				t_Sink->Release () ;
			}

			m_SinkController->UnLock () ;
		}
		else
		{
			m_SinkController->UnLock () ;
		}

		m_SinkController->CWbemGlobal_VoidPointerController :: UnInitialize () ;

		delete m_SinkController ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_ProviderSubSystem :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiProvSS )
	{
		*iplpv = ( LPVOID ) ( _IWmiProvSS * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * )this ;		
	}	
	else if ( iid == IID__IWmiProviderConfiguration )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderConfiguration * ) this ;		
	}	
	else if ( iid == IID_CWbemGlobal_IWmiFactoryController )
	{
		*iplpv = ( LPVOID ) ( CWbemGlobal_IWmiFactoryController * ) this ;		
	}	
	else if ( iid == IID_CWbemProviderSubSystem )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_CWbemSubSystemHook )
	{
		*iplpv = ( LPVOID ) & ( this->m_Internal ) ;
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_ProviderSubSystem :: AddRef ()
{
	return ProvSubSysContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_ProviderSubSystem :: Release ()
{
	return ProvSubSysContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CServerObject_ProviderSubSystem :: CallBackInternalRelease ()
{
	if ( m_Core )
	{
		m_Core->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: GetWmiService (

	const BSTR a_Namespace ,
	const BSTR a_User ,
	const BSTR a_Locale ,
	IWbemServices *&a_Service
)
{
	LONG t_Flags = WMICORE_FLAG_FULL_SERVICES | WMICORE_CLIENT_TYPE_PROVIDER ;

	HRESULT t_Result = m_Core->GetServices (

		a_Namespace ,
		a_User ,
		a_Locale ,
		t_Flags ,
		IID_IWbemServices ,
		( void ** ) & a_Service
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: GetWmiService (

	IWbemPath *a_Namespace ,
	const BSTR a_User ,
	const BSTR a_Locale ,
	IWbemServices *&a_Service
)
{
	wchar_t *t_NamespacePath = NULL ;

	HRESULT t_Result = ProviderSubSystem_Common_Globals :: GetNamespacePath (

		a_Namespace ,
		t_NamespacePath
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		LONG t_Flags = WMICORE_FLAG_FULL_SERVICES | WMICORE_CLIENT_TYPE_PROVIDER ;

		t_Result = m_Core->GetServices (

			t_NamespacePath ,
			a_User ,
			a_Locale ,
			t_Flags ,
			IID_IWbemServices ,
			( void ** ) & a_Service
		) ;

		delete [] t_NamespacePath ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: GetWmiRepositoryService (

	IWbemPath *a_Namespace ,
	const BSTR a_User ,
	const BSTR a_Locale ,
	IWbemServices *&a_Service
)
{
	wchar_t *t_NamespacePath = NULL ;

	HRESULT t_Result = ProviderSubSystem_Common_Globals :: GetNamespacePath (

		a_Namespace ,
		t_NamespacePath
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		LONG t_Flags = WMICORE_FLAG_REPOSITORY | WMICORE_CLIENT_TYPE_PROVIDER ;

		t_Result = m_Core->GetServices (

			t_NamespacePath ,
			a_User ,
			a_Locale ,
			t_Flags ,
			IID_IWbemServices ,
			( void ** ) & a_Service
		) ;

		delete [] t_NamespacePath ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: GetWmiRepositoryService (

	const BSTR a_Namespace ,
	const BSTR a_User ,
	const BSTR a_Locale ,
	IWbemServices *&a_Service
)
{
	LONG t_Flags = WMICORE_FLAG_REPOSITORY | WMICORE_CLIENT_TYPE_PROVIDER ;

	HRESULT t_Result = m_Core->GetServices (

		a_Namespace ,
		a_User ,
		a_Locale ,
		t_Flags ,
		IID_IWbemServices ,
		( void ** ) & a_Service
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: RegisterNotificationSink (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	_IWmiProvSSSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	CInterceptor_IWmiProvSSSink *t_Sink = new CInterceptor_IWmiProvSSSink (

		a_Sink ,
		m_SinkController
	) ;

	if ( t_Sink )
	{
		t_Sink->AddRef () ;

		CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

		m_SinkController->Lock () ;

		WmiStatusCode t_StatusCode = m_SinkController->Insert (

			*t_Sink ,
			t_Iterator 
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
		}
		else
		{
			t_Sink->Release () ;

			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		m_SinkController->UnLock () ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;	
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: UnRegisterNotificationSink (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	_IWmiProvSSSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

	m_SinkController->Lock () ;

	WmiStatusCode t_StatusCode = m_SinkController->Find (

		a_Sink ,
		t_Iterator 
	) ;

	if ( t_StatusCode == e_StatusCode_Success )
	{
		m_SinkController->UnLock () ;

		VoidPointerContainerElement *t_Element = t_Iterator.GetElement () ;			

		t_Element->Release () ;

		t_Element->Release () ;
	}
	else
	{
		m_SinkController->UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;	
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: ForwardReload (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Namespace ,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_VoidPointerController_Container *t_Container = NULL ;
		
	m_SinkController->GetContainer ( t_Container ) ;

	m_SinkController->Lock () ;

	if ( t_Container->Size () )
	{
		_IWmiProvSSSink **t_Elements = new _IWmiProvSSSink * [ t_Container->Size () ] ;
		if ( t_Elements )
		{
			CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator = t_Container->Begin ();

			ULONG t_Count = 0 ;
			while ( ! t_Iterator.Null () )
			{
				t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProvSSSink  , ( void ** ) & t_Elements [ t_Count ] ) ;

				t_Iterator.Increment () ;

				t_Count ++ ;
			}

			m_SinkController->UnLock () ;

			for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
			{
				if ( t_Elements [ t_Index ] ) 
				{
					t_Result = t_Elements [ t_Index ]->Synchronize ( 

						a_Flags ,
						a_Context ,
						a_Namespace ,
						a_Provider
					) ;

					t_Elements [ t_Index ]->Release () ;
				}
			}

			delete [] t_Elements ;
		}
		else
		{
			m_SinkController->UnLock () ;

			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		m_SinkController->UnLock () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Cache (

	LPCWSTR a_Namespace ,
	IWbemPath *a_NamespacePath ,
	CServerObject_BindingFactory *a_Factory ,
	BindingFactoryCacheKey &a_Key ,
	REFIID a_RIID ,
	void **a_Interface
)
{
	CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator ;

	HRESULT t_Result = S_OK ;

	Lock () ;

	WmiStatusCode t_StatusCode = Insert (

		*a_Factory ,
		t_Iterator
	) ;

	if ( t_StatusCode == e_StatusCode_Success )
	{
		UnLock () ;

		t_Result = a_Factory->QueryInterface (

			a_RIID ,
			a_Interface
		) ;
	}
	else
	{
		if ( t_StatusCode == e_StatusCode_AlreadyExists )
		{
			WmiStatusCode t_StatusCode = Find ( a_Key , t_Iterator ) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
				BindingFactoryCacheElement *t_Factory = t_Iterator.GetElement () ;

				t_Result = t_Factory->QueryInterface (

					a_RIID ,
					a_Interface
				) ;

				t_Factory->Release () ;

				UnLock () ;
			}
			else
			{
				UnLock () ;
			}
		}
		else
		{
			UnLock () ;

			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: CreateAndCache (

	IWbemServices *a_Core ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Namespace ,
	IWbemPath *a_NamespacePath ,
	BindingFactoryCacheKey &a_Key ,
	REFIID a_RIID ,
	void **a_Interface
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		CServerObject_BindingFactory *t_Factory = NULL ;

		try
		{
			t_Factory = new CServerObject_BindingFactory (

				m_Allocator ,
				this ,
				a_Key ,
				ProviderSubSystem_Globals :: s_InternalCacheTimeout
			) ;

			if ( t_Factory == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		catch ( Wmi_Heap_Exception &a_Exception )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Factory->AddRef () ;

/*
*	Just set the context, since we want status regarding construction of object.
*/
			_IWmiProviderFactoryInitialize *t_FactoryInitializer = NULL ;

			t_Result = t_Factory->QueryInterface (

				IID__IWmiProviderFactoryInitialize ,
				( void ** ) & t_FactoryInitializer
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_FactoryInitializer->Initialize (

					this ,
					NULL ,
					a_Flags ,
					a_Context ,
					a_Namespace ,
					a_Core ,
					NULL
				) ;
		
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = Cache (

						a_Namespace ,
						a_NamespacePath ,
						t_Factory ,
						a_Key ,
						a_RIID ,
						a_Interface
					) ;
				}

				t_FactoryInitializer->Release () ;
			}

			t_Factory->Release () ;
		}
		else
		{
			delete t_Factory ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Create (

	IWbemServices *a_Core ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Namespace ,
	REFIID a_RIID ,
	void **a_Interface
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

/*
 *	At this stage just allocate the object, we might move to CoCreateInstance
 *	if it becomes necessary to remote the object.
 */
	try
	{
		IWbemPath *t_Path = NULL ;
		t_Result = CoCreateInstance (

			CLSID_WbemDefPath ,
			NULL ,
			CLSCTX_INPROC_SERVER ,
			IID_IWbemPath ,
			( void ** )  & t_Path
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Path->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Namespace ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				wchar_t *t_NamespacePath = NULL ;
				t_Result = ProviderSubSystem_Common_Globals :: GetNamespacePath (

					t_Path  ,
					t_NamespacePath
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator ;

					try
					{
						BindingFactoryCacheKey t_Key ( t_NamespacePath ) ;

						Lock () ;

						WmiStatusCode t_StatusCode = Find ( t_Key , t_Iterator ) ;

						if ( t_StatusCode == e_StatusCode_Success )
						{
							BindingFactoryCacheElement *t_Factory = t_Iterator.GetElement () ;

							t_Result = t_Factory->QueryInterface (

								a_RIID ,
								a_Interface
							) ;

							t_Factory->Release () ;

							UnLock () ;
						}
						else
						{
							UnLock () ;

							t_Result = CreateAndCache (

								a_Core ,
								a_Flags ,
								a_Context ,
								a_Namespace ,
								t_Path ,
								t_Key ,
								a_RIID ,
								a_Interface
							) ;
						}
					}
					catch ( Wmi_Heap_Exception &a_Exception )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}

					delete [] t_NamespacePath ;
				}
			}
			else
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}

			t_Path->Release () ;
		}
		else
		{
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: CreateRefresherManager (

	IWbemServices *a_Core ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	REFIID a_RIID ,
	void **a_Interface
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		RefresherManagerController *t_Controller = ProviderSubSystem_Globals :: GetRefresherManagerController () ;

		CWbemGlobal_IWbemRefresherMgrController_Cache *t_Cache = NULL ;
		t_Controller->GetCache ( t_Cache ) ;

		t_Controller->Lock () ;

		CWbemGlobal_IWbemRefresherMgrController_Cache_Iterator t_Iterator = t_Cache->Begin () ;

		if ( ! t_Iterator.Null () )
		{
			RefresherManagerCacheElement *t_Element = t_Iterator.GetElement () ;

			CServerObject_InterceptorProviderRefresherManager *t_RefresherManager = NULL ;

			t_Result = t_Element->QueryInterface (

				IID_CServerObject_InterceptorProviderRefresherManager ,
				( void ** ) & t_RefresherManager
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Controller->UnLock () ;

				t_Result = t_RefresherManager->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Result == S_FALSE )
					{
						t_Result = t_Element->QueryInterface (

							a_RIID ,
							a_Interface
						) ;

						t_RefresherManager->Release () ;

						return t_Result ;
					}

					if ( SUCCEEDED ( t_Result = t_RefresherManager->GetInitializeResult () ) )
					{
						t_Result = t_Element->QueryInterface (

							a_RIID ,
							a_Interface
						) ;
					}
				}

				t_RefresherManager->Release () ;
			}
			else
			{
				t_Controller->UnLock () ;
			}
		}
		else
		{
			CServerObject_InterceptorProviderRefresherManager *t_Manager = NULL ;

			try
			{
				t_Manager = new CServerObject_InterceptorProviderRefresherManager (

					t_Controller , 
					ProviderSubSystem_Globals :: s_InternalCacheTimeout ,
					m_Allocator ,
					a_Context 
				) ;

				if ( t_Manager )
				{
					t_Manager->AddRef () ;

					t_Result = t_Manager->Initialize () ;
					if ( SUCCEEDED ( t_Result ) )
					{
						CWbemGlobal_IWbemRefresherMgrController_Cache_Iterator t_Iterator ;

						WmiStatusCode t_StatusCode = t_Controller->Insert (

							*t_Manager ,
							t_Iterator
						) ;

						if ( t_StatusCode != e_StatusCode_Success )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;

							t_Manager->Release () ;
						}
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			t_Controller->UnLock () ;

			if ( SUCCEEDED ( t_Result ) )
			{
				// Should be a global?
				_IWbemRefresherMgr*	t_RefresherMgr = NULL;
				_IWmiProviderHost *t_Host = NULL ;

				try
				{
					HostCacheKey t_Key ( 

						HostCacheKey :: e_HostDesignation_Shared ,
						CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedNetworkServiceHost ,
						HostCacheKey :: e_IdentityDesignation_NetworkService ,
						NULL
					) ;

					t_Result = CServerObject_HostInterceptor :: CreateUsingAccount (

						t_Key ,
						L"NetworkService" ,
						L"NT AUTHORITY" ,
						& t_Host ,
						& t_RefresherMgr ,
						a_Context
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Manager->SetManager ( t_Host , t_RefresherMgr ) ;
						if ( SUCCEEDED ( t_Result ) ) 
						{
							t_Result = t_Manager->Startup ( 0L, a_Context, this );
							if ( SUCCEEDED( t_Result ) )
							{
								t_Result = t_Manager->QueryInterface( a_RIID, a_Interface );
							}
						}

						t_RefresherMgr->Release();

						if ( t_Host )
						{
							t_Host->Release () ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				t_Manager->SetInitialized ( t_Result ) ;

				t_Manager->Release () ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Get (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemObjectSink *a_Sink
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	BOOL t_Found = FALSE ;

	try 
	{
		if ( wbem_wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
		{
			wchar_t *t_Namespace = NULL ; 

			IWbemPath *t_PathObject = NULL ;

			t_Result = CoCreateInstance (

				CLSID_WbemDefPath ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IWbemPath ,
				( void ** )  & t_PathObject
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_PathObject->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_Path ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					IWbemPathKeyList *t_Keys = NULL ;

					t_Result = t_PathObject->GetKeyList (

						& t_Keys 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						ULONG t_KeyCount = 0 ;
						t_Result = t_Keys->GetCount (

							& t_KeyCount 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_KeyCount == 7 )
							{
								for ( ULONG t_Index = 0 ; ( t_Index < t_KeyCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
								{
									wchar_t t_Key [ 32 ] ; 
									wchar_t *t_KeyValue = NULL ; 
									ULONG t_KeyLength = 32 ;
									ULONG t_KeyValueLength = 0 ;
									ULONG t_KeyType = 0 ;

									t_Result = t_Keys->GetKey (

										t_Index ,
										0 ,
										& t_KeyLength ,
										t_Key ,
										& t_KeyValueLength ,
										t_KeyValue ,
										& t_KeyType
									) ;

									if ( SUCCEEDED ( t_Result ) ) 
									{
										if ( t_KeyType == CIM_STRING )
										{
											t_KeyValue = new wchar_t [ t_KeyValueLength ] ;
											if ( t_KeyValue )
											{
												t_Result = t_Keys->GetKey (

													t_Index ,
													0 ,
													& t_KeyLength ,
													t_Key ,
													& t_KeyValueLength ,
													t_KeyValue ,
													& t_KeyType
												) ;

												if ( SUCCEEDED ( t_Result ) )
												{
													if ( wbem_wcsicmp ( L"Namespace" , t_Key ) == 0 )
													{
														t_Namespace = t_KeyValue ;
													}
													else
													{
														delete [] t_KeyValue ;
													}
												}
												else
												{
													t_Result = WBEM_E_CRITICAL_ERROR ;
												}
											}
											else
											{
												t_Result = WBEM_E_OUT_OF_MEMORY ;
											}	
										}
										else if ( t_KeyType == CIM_SINT32 )
										{
										}
										else
										{
											t_Result = WBEM_E_INVALID_OBJECT_PATH ;
										}
									}
									else
									{
										t_Result = WBEM_E_CRITICAL_ERROR ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_INVALID_OBJECT_PATH ;
							}
						}
                        t_Keys->Release();
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				t_PathObject->Release () ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator ;

				BindingFactoryCacheElement *t_Factory = NULL ;

				Lock () ;

				try
				{
					BindingFactoryCacheKey t_Key ( t_Namespace ) ;

					WmiStatusCode t_StatusCode = Find ( t_Key , t_Iterator ) ;
					if ( t_StatusCode == e_StatusCode_Success )
					{
						t_Factory = t_Iterator.GetElement () ;
					}
					else
					{
						t_Result = WBEM_E_NOT_FOUND ;
					}
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				UnLock () ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Found = TRUE ;

					_IWmiProviderConfiguration *t_Configuration = NULL ;

					t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_Configuration ) ;

					t_Result = t_Configuration->Get ( 

						a_Service ,
						a_Flags, 
						a_Context,
 						a_Class, 
						a_Path,
						a_Sink 
					) ;

					t_Configuration->Release () ;

					t_Factory->Release () ;
				}
			}

			if ( t_Namespace )
			{
				delete [] t_Namespace ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( ! t_Found )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Set (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_OldObject ,
	IWbemClassObject *a_NewObject  

)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Deleted (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_Object  
) 
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Enumerate (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	IWbemObjectSink *a_Sink
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		if ( wbem_wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
		{
			Lock () ;

			CWbemGlobal_IWmiFactoryController_Cache *t_Cache = NULL ;
			GetCache ( t_Cache ) ;

			if ( t_Cache->Size () )
			{
				CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator = t_Cache->Begin ();

				_IWmiProviderConfiguration **t_ControllerElements = new _IWmiProviderConfiguration * [ t_Cache->Size () ] ;
				if ( t_ControllerElements )
				{
					ULONG t_Count = 0 ;
					while ( ! t_Iterator.Null () )
					{
						HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

						t_Iterator.Increment () ;

						t_Count ++ ;
					}

					UnLock () ;

					for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
					{
						if ( t_ControllerElements [ t_Index ] )
						{
							HRESULT t_Result = t_ControllerElements [ t_Index ]->Enumerate ( 

								a_Service ,
								a_Flags, 
								a_Context,
 								a_Class, 
								a_Sink 
							) ;

							t_ControllerElements [ t_Index ]->Release () ;
						}
					}

					delete [] t_ControllerElements ;
				}
				else
				{
					UnLock () ;
				}
			}
			else
			{
				UnLock () ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Call_Load (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,		
	LPCWSTR a_Method,
	IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		t_Result = a_InParams->Get ( L"Namespace" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BSTR )
			{
				IWbemServices *t_Services = NULL ;

				BSTR t_Namespace = SysAllocString ( t_Variant.bstrVal ) ;
				if ( t_Namespace )
				{
					t_Result = GetWmiService (

						t_Namespace ,
						NULL ,
						NULL ,
						t_Services
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					_IWmiProviderFactory *t_Factory = NULL ;

					t_Result = Create (

						t_Services ,
						0 ,
						a_Context ,
						t_Namespace ,
						IID__IWmiProviderFactory,
						( void ** ) & t_Factory 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;
					
						LONG t_VarType = 0 ;
						LONG t_Flavour = 0 ;

						BSTR t_User = NULL ;
						BSTR t_Locale = NULL ;
						BSTR t_TransactionIdentifier = NULL ;
						BSTR t_Provider = NULL ;
						GUID t_TransactionIdentifierGuid ;

						t_Result = a_InParams->Get ( L"User" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_Variant.vt == VT_BSTR )		
							{
								t_User = SysAllocString ( t_Variant.bstrVal ) ;
								if (NULL == t_User)
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else if ( t_Variant.vt == VT_NULL )
							{
							}
							else
							{
								t_Result = WBEM_E_INVALID_PARAMETER ;
							}
						}
						else
						{
							t_Result = ( t_Result == WBEM_E_NOT_FOUND ) ? S_OK : t_Result ;
						}
			
						VariantClear ( & t_Variant ) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = a_InParams->Get ( L"Locale" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_Variant.vt == VT_BSTR )		
								{
									t_Locale = SysAllocString ( t_Variant.bstrVal ) ;
									if (NULL == t_Locale)
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}
									
								}
								else if ( t_Variant.vt == VT_NULL )
								{
								}
								else
								{
									t_Result = WBEM_E_INVALID_PARAMETER ;
								}
							}
							else
							{
								t_Result = ( t_Result == WBEM_E_NOT_FOUND ) ? S_OK : t_Result ;
							}
				
							VariantClear ( & t_Variant ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = a_InParams->Get ( L"Provider" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_Variant.vt == VT_BSTR )		
								{
									t_Provider = SysAllocString ( t_Variant.bstrVal ) ;
									if (NULL == t_Provider)
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}
									
								}
								else
								{
									t_Result = WBEM_E_INVALID_PARAMETER ;
								}
							}
							else
							{
								t_Result = ( t_Result == WBEM_E_NOT_FOUND ) ? S_OK : t_Result ;
							}
				
							VariantClear ( & t_Variant ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = a_InParams->Get ( L"TransactionIdentifier" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_Variant.vt == VT_BSTR )		
								{
									t_TransactionIdentifier = SysAllocString ( t_Variant.bstrVal ) ;
									if (t_TransactionIdentifier)
									{
										t_Result = CLSIDFromString (
											t_TransactionIdentifier ,
											& t_TransactionIdentifierGuid
									) ;
									}
									else
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}

									if ( FAILED ( t_Result ) )
									{
										t_Result = WBEM_E_INVALID_PARAMETER ;
									}
								}
								else if ( t_Variant.vt == VT_NULL )
								{
								}
								else
								{
									t_Result = WBEM_E_INVALID_PARAMETER ;
								}
							}
							else
							{
								t_Result = ( t_Result == WBEM_E_NOT_FOUND ) ? S_OK : t_Result ;
							}
				
							VariantClear ( & t_Variant ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							CServerObject_ProviderRegistrationV1 *t_Registration = new CServerObject_ProviderRegistrationV1 ;
							if ( t_Registration )
							{
								t_Registration->AddRef () ;

								IWbemPath *t_NamespacePath = NULL ;

								t_Result = CoCreateInstance (

									CLSID_WbemDefPath ,
									NULL ,
									CLSCTX_INPROC_SERVER ,
									IID_IWbemPath ,
									( void ** )  & t_NamespacePath
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_NamespacePath->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , t_Namespace ) ;
									if ( SUCCEEDED ( t_Result ) )
									{
										t_Result = t_Registration->SetContext ( 

											a_Context ,
											t_NamespacePath , 
											t_Services
										) ;
										
										if ( SUCCEEDED ( t_Result ) )
										{
											t_Result = t_Registration->Load ( 

												e_All ,
												NULL , 
												t_Provider
											) ;

											if ( SUCCEEDED ( t_Result ) )
											{
												ProviderSubSystem_Globals :: DeleteGuidTag ( t_Registration->GetClsid () ) ;
											}
										}
									}

									t_NamespacePath->Release () ;
								}

								t_Registration->Release () ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							IUnknown *t_Unknown = NULL ;

							WmiInternalContext t_InternalContext ;
							ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

							t_Result = t_Factory->GetProvider ( 

								t_InternalContext ,
								0 ,
								a_Context ,
								t_TransactionIdentifier ? & t_TransactionIdentifierGuid : NULL ,
								t_User ,
								t_Locale ,
								NULL ,
								t_Provider ,
								IID_IUnknown, 
								( void ** ) & t_Unknown
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								_IWmiProviderLoad *t_Load = NULL ;

								t_Result = t_Unknown->QueryInterface ( IID__IWmiProviderLoad , ( void ** ) & t_Load ) ;
								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_Load->Load ( 

										0 ,
										a_Context
									) ;

									t_Load->Release () ;
								}
								else
								{
									t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
								}

								t_Unknown->Release () ;
							}
						}
 
						t_Factory->Release () ;

						if ( t_User )
						{
							SysFreeString ( t_User ) ;
						}

						if ( t_Locale ) 
						{
							SysFreeString ( t_Locale ) ;
						}

						if ( t_Provider ) 
						{
							SysFreeString( t_Provider ) ;
						}

						if ( t_TransactionIdentifier ) 
						{
							SysFreeString ( t_TransactionIdentifier ) ;
						}
					}

					t_Services->Release () ;
				}

				if ( t_Namespace )
				{
					SysFreeString ( t_Namespace ) ;
				}
			}
			else
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}

			VariantClear ( & t_Variant ) ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Call (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,		
	LPCWSTR a_Method,
	IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	BOOL t_Found = FALSE ;

	try 
	{
		if ( wbem_wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
		{
			if ( wbem_wcsicmp ( a_Method , L"Load" ) == 0 )
			{
				t_Result = Call_Load ( 

					a_Flags, 
					a_Context,
 					a_Class, 
					a_Path,
					a_Method,
					a_InParams,
					a_Sink 
				) ;

				t_Found = TRUE ;
			}
			else
			{
				wchar_t *t_Namespace = NULL ; 

				IWbemPath *t_PathObject = NULL ;

				t_Result = CoCreateInstance (

					CLSID_WbemDefPath ,
					NULL ,
					CLSCTX_INPROC_SERVER ,
					IID_IWbemPath ,
					( void ** )  & t_PathObject
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_PathObject->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_Path ) ;
					if ( SUCCEEDED ( t_Result ) ) 
					{
						IWbemPathKeyList *t_Keys = NULL ;

						t_Result = t_PathObject->GetKeyList (

							& t_Keys 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							ULONG t_KeyCount = 0 ;
							t_Result = t_Keys->GetCount (

								& t_KeyCount 
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_KeyCount == 7 )
								{
									for ( ULONG t_Index = 0 ; ( t_Index < t_KeyCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
									{
										wchar_t t_Key [ 32 ] ; 
										wchar_t *t_KeyValue = NULL ; 
										ULONG t_KeyLength = 32 ;
										ULONG t_KeyValueLength = 0 ;
										ULONG t_KeyType = 0 ;

										t_Result = t_Keys->GetKey (

											t_Index ,
											0 ,
											& t_KeyLength ,
											t_Key ,
											& t_KeyValueLength ,
											t_KeyValue ,
											& t_KeyType
										) ;

										if ( SUCCEEDED ( t_Result ) ) 
										{
											if ( t_KeyType == CIM_STRING )
											{
												t_KeyValue = new wchar_t [ t_KeyValueLength ] ;
												if ( t_KeyValue )
												{
													t_Result = t_Keys->GetKey (

														t_Index ,
														0 ,
														& t_KeyLength ,
														t_Key ,
														& t_KeyValueLength ,
														t_KeyValue ,
														& t_KeyType
													) ;

													if ( SUCCEEDED ( t_Result ) )
													{
														if ( wbem_wcsicmp ( L"Namespace" , t_Key ) == 0 )
														{
															t_Namespace = t_KeyValue ;
														}
														else
														{
															delete [] t_KeyValue ;
														}
													}
													else
													{
														t_Result = WBEM_E_CRITICAL_ERROR ;
													}
												}
												else
												{
													t_Result = WBEM_E_OUT_OF_MEMORY ;
												}	
											}
											else if ( t_KeyType == CIM_SINT32 )
											{
											}
											else
											{
												t_Result = WBEM_E_INVALID_OBJECT_PATH ;
											}
										}
										else
										{
											t_Result = WBEM_E_CRITICAL_ERROR ;
										}
									}
								}
								else
								{
									t_Result = WBEM_E_INVALID_OBJECT_PATH ;
								}
							}
                            t_Keys->Release();
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}

					t_PathObject->Release () ;
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator ;

					BindingFactoryCacheElement *t_Factory = NULL ;

					Lock () ;

					try
					{
						BindingFactoryCacheKey t_Key ( t_Namespace ) ;

						WmiStatusCode t_StatusCode = Find ( t_Key , t_Iterator ) ;
						if ( t_StatusCode == e_StatusCode_Success )
						{
							t_Factory = t_Iterator.GetElement () ;
						}
						else
						{
							t_Result = WBEM_E_NOT_FOUND ;
						}
					}
					catch ( Wmi_Heap_Exception &a_Exception )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}

					UnLock () ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Found = TRUE ;

						_IWmiProviderConfiguration *t_Configuration = NULL ;

						t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_Configuration ) ;

						t_Result = t_Configuration->Call ( 

							a_Service ,
							a_Flags, 
							a_Context,
 							a_Class, 
							a_Path,
							a_Method,
							a_InParams,
							a_Sink 
						) ;

						t_Configuration->Release () ;

						t_Factory->Release () ;
					}
				}

				if ( t_Namespace )
				{
					delete [] t_Namespace ;
				}
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( ! t_Found )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Shutdown (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	ULONG a_MilliSeconds
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Query (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
	WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
	VARIANT *a_Value 
)
{
	return WBEM_E_NOT_SUPPORTED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState CServerObject_ProviderSubSystem :: IsA (

	IWbemClassObject *a_Left ,
	BSTR a_Right
) 
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_False ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	LONG t_VarType = 0 ;
	LONG t_Flavour = 0 ;

	HRESULT t_Result = a_Left->Get ( L"__Class" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Variant.vt == ( VT_NULL ) )
		{
		}
		else
		{
			if ( wbem_wcsicmp ( t_Variant.bstrVal , a_Right ) == 0 )
			{
				t_Status = QueryPreprocessor :: State_True ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}
	else
	{
		t_Status = QueryPreprocessor :: State_Error ;
	}

	if ( t_Status == QueryPreprocessor :: State_False )
	{
		VARIANT t_LeftSafeArray ;
		VariantInit ( & t_LeftSafeArray ) ;

		t_Result = a_Left->Get ( L"__Derivation" , 0 , & t_LeftSafeArray , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_LeftSafeArray.vt == ( VT_BSTR | VT_ARRAY ) )
			{
				SAFEARRAY *t_LeftArray = t_LeftSafeArray.parray ;
				if ( SafeArrayGetDim ( t_LeftSafeArray.parray ) == 1 )
				{
					LONG t_Dimension = 1 ; 

					LONG t_Lower ;
					SafeArrayGetLBound ( t_LeftSafeArray.parray , t_Dimension , & t_Lower ) ;

					LONG t_Upper ;
					SafeArrayGetUBound ( t_LeftSafeArray.parray , t_Dimension , & t_Upper ) ;

					for ( LONG t_Index = t_Lower ; t_Index <= t_Upper ; t_Index ++ )
					{
						BSTR t_Element = NULL ;
						if ( SUCCEEDED ( SafeArrayGetElement ( t_LeftSafeArray.parray , & t_Index , & t_Element ) ) )
						{
							if ( wbem_wcsicmp ( t_Element , a_Right ) == 0 )
							{
								SysFreeString ( t_Element ) ;

								t_Status = QueryPreprocessor :: State_True ;

								break ;
							}

							SysFreeString ( t_Element ) ;
						}
						else
						{
							t_Status = QueryPreprocessor :: State_Error ;

							break ;
						}
					}
				}
				else
				{
					t_Status = QueryPreprocessor :: State_Error ;
				}
			}
			else
			{
				t_Status = QueryPreprocessor :: State_Error ;
			}
		}
		else
		{
			t_Status = QueryPreprocessor :: State_Error ;
		}

		VariantClear ( & t_LeftSafeArray ) ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: ReportEvent ( 

	CServerObject_ProviderRegistrationV1 &a_Registration ,
	const BSTR a_NamespacePath
)
{
	HRESULT t_Result = S_OK ;

	BOOL t_DataProvider =	a_Registration.GetClassProviderRegistration ().Supported () ||
							a_Registration.GetInstanceProviderRegistration ().Supported () ||
							a_Registration.GetPropertyProviderRegistration ().Supported () ||
							a_Registration.GetMethodProviderRegistration ().Supported () ;

	if ( t_DataProvider && ( ( a_Registration.GetHosting () == e_Hosting_SharedLocalSystemHost ) || ( a_Registration.GetHosting () == e_Hosting_SharedLocalSystemHostOrSelfHost ) || 
		( a_Registration.GetHosting () == e_Hosting_SelfHost )) )
	{
		t_Result= VerifySecureLocalSystemProviders ( a_Registration.GetComRegistration ().GetClsidServer ().GetProviderClsid () ) ;
		if ( FAILED ( t_Result ) )
		{
			_IWmiCallSec *t_CallSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: CreateInstance (

				CLSID__IWbemCallSec ,
				NULL ,
				CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
				IID__IWmiCallSec ,
				( void ** ) & t_CallSecurity 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				ULONG t_Size = 0 ;
				PSID t_Sid = NULL ;

				t_Result = CoImpersonateClient () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_CallSecurity->GetUserSid ( 

						& t_Size ,
						t_Sid
					) ;

					if ( SUCCEEDED ( t_Result ) ) 
					{
						t_Sid = ( PSID ) new BYTE [ t_Size ] ;
						if ( t_Sid )
						{
							t_Result = t_CallSecurity->GetUserSid ( 

								& t_Size ,
								t_Sid
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_FAILED ;
					}
				}

				CoRevertToSelf () ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					wchar_t *t_Array [ 2 ] ;

					t_Array [ 0 ] = a_Registration.GetProviderName () ;
					t_Array [ 1 ] = a_NamespacePath ;

					BOOL t_Status = :: ReportEvent (

					  ProviderSubSystem_Globals :: GetNtEventSource () ,
					  EVENTLOG_WARNING_TYPE ,
					  0 ,
					  WBEM_MC_PROVIDER_SUBSYSTEM_LOCALSYSTEM_PROVIDER_LOAD ,
					  t_Sid ,
					  2 ,
					  0 ,
					  ( LPCWSTR * ) t_Array ,
					  NULL
					) ;

					if ( t_Status == 0 )
					{
						DWORD t_LastError = GetLastError () ;
					}
				}

				t_CallSecurity->Release () ;

				if ( t_Sid )
				{
					delete [] ( BYTE * ) t_Sid ;
				}
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: VerifySecurity ( 

	IWbemContext *a_Context ,
	const BSTR a_Provider ,
	const BSTR a_NamespacePath
)
{
	IWbemServices *t_RepositoryService = NULL ;
	HRESULT t_Result = GetWmiRepositoryService ( a_NamespacePath , NULL , NULL , t_RepositoryService ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		IWbemPath *t_Namespace = NULL ;
		if ( a_NamespacePath ) 
		{
			t_Result = CoCreateInstance (

				CLSID_WbemDefPath ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IWbemPath ,
				( void ** )  & t_Namespace
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Namespace->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_NamespacePath ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CServerObject_ProviderRegistrationV1 t_Registration ;

					t_Result = t_Registration.SetContext ( 

						a_Context ,
						t_Namespace , 
						t_RepositoryService
					) ;
					
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Registration.Load ( 

							e_All ,
							NULL , 
							a_Provider
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							HRESULT t_TempResult = ReportEvent ( 

								t_Registration ,
								a_NamespacePath
							) ;
						}
					}
				}

				t_Namespace->Release () ;
			}
		}

		t_RepositoryService->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: GetPath (

    IWbemClassObject *a_Object ,
    IWbemPath *&a_Path ,
	LPWSTR &a_PathText
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Object )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		t_Result = a_Object->Get ( L"__Path" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			a_PathText = DupString(t_Variant.bstrVal);
			if ( a_PathText == 0)
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = CoCreateInstance (

					CLSID_WbemDefPath ,
					NULL ,
					CLSCTX_INPROC_SERVER ,
					IID_IWbemPath ,
					( void ** )  & a_Path
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = a_Path->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_PathText ) ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: GetProvider (

    LPCWSTR a_Class ,
    IWbemPath *a_Path ,
    IWbemClassObject *a_Object ,
    LPWSTR &a_Provider
)
{
	HRESULT t_Result = S_OK ;

	QueryPreprocessor :: QuadState t_State = IsA ( a_Object  , L"__Win32Provider" ) ;
	if ( t_State == QueryPreprocessor :: State_Error )
	{
		return WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_State == QueryPreprocessor :: State_True )
	{
		IWbemPathKeyList *t_ProviderKeys = NULL ;

		t_Result = a_Path->GetKeyList (

			& t_ProviderKeys
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			ULONG t_ProviderNameLength = 0 ;
			ULONG t_Type = 0 ;

			t_Result = t_ProviderKeys->GetKey (

				0 ,
				0 ,
				NULL ,
				NULL ,
				& t_ProviderNameLength ,
				a_Provider ,
				& t_Type
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				a_Provider = new wchar_t [ ( t_ProviderNameLength / sizeof ( wchar_t ) ) + 1 ] ;
				if ( a_Provider )
				{
					t_Result = t_ProviderKeys->GetKey (

						0 ,
						0 ,
						NULL ,
						NULL ,
						& t_ProviderNameLength ,
						a_Provider ,
						& t_Type
					) ;

					if ( FAILED ( t_Result ) )
					{
						delete [] a_Provider ;

						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			t_ProviderKeys->Release () ;
		}
	}
	else
	{
		if ( t_State == QueryPreprocessor :: State_False )
		{
			t_State = IsA ( a_Object  , L"__EventProviderRegistration" ) ;
			if ( t_State == QueryPreprocessor :: State_Error )
			{
				return WBEM_E_OUT_OF_MEMORY ;
			}

			if ( t_State == QueryPreprocessor :: State_False )
			{
				t_State = IsA ( a_Object  , L"__EventProviderRegistration" ) ;
				if ( t_State == QueryPreprocessor :: State_Error )
				{
					return WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( t_State == QueryPreprocessor :: State_False )
			{
				t_State = IsA ( a_Object  , L"__EventConsumerProviderRegistration" ) ;
				if ( t_State == QueryPreprocessor :: State_Error )
				{
					return WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( t_State == QueryPreprocessor :: State_False )
			{
				t_State = IsA ( a_Object  , L"__InstanceProviderRegistration" ) ;
				if ( t_State == QueryPreprocessor :: State_Error )
				{
					return WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( t_State == QueryPreprocessor :: State_False )
			{
				t_State = IsA ( a_Object  , L"__MethodProviderRegistration" ) ;
				if ( t_State == QueryPreprocessor :: State_Error )
				{
					return WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( t_State == QueryPreprocessor :: State_False )
			{
				t_State = IsA ( a_Object  , L"__PropertyProviderRegistration" ) ;
				if ( t_State == QueryPreprocessor :: State_Error )
				{
					return WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( t_State == QueryPreprocessor :: State_False )
			{
				t_State = IsA ( a_Object  , L"__ClassProviderRegistration" ) ;
				if ( t_State == QueryPreprocessor :: State_Error )
				{
					return WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( t_State == QueryPreprocessor :: State_True )
			{
				IWbemPathKeyList *t_RegistrationKeys = NULL ;

				t_Result = a_Path->GetKeyList (

					& t_RegistrationKeys
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					wchar_t *t_ProviderReference = NULL ;
					ULONG t_ProviderReferenceLength = 0 ;
					ULONG t_Type = 0 ;

					t_Result = t_RegistrationKeys->GetKey (

						0 ,
						0 ,
						NULL ,
						NULL ,
						& t_ProviderReferenceLength ,
						t_ProviderReference ,
						& t_Type
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_ProviderReference = new wchar_t [ ( t_ProviderReferenceLength / sizeof ( wchar_t ) ) + 1 ] ;
						if ( t_ProviderReference )
						{
							t_Result = t_RegistrationKeys->GetKey (

								0 ,
								0 ,
								NULL ,
								NULL ,
								& t_ProviderReferenceLength ,
								t_ProviderReference ,
								& t_Type
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								IWbemPath *t_ProviderPath = NULL ;

								t_Result = CoCreateInstance (

									CLSID_WbemDefPath ,
									NULL ,
									CLSCTX_INPROC_SERVER ,
									IID_IWbemPath ,
									( void ** )  & t_ProviderPath
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_ProviderPath->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , t_ProviderReference ) ;
									if ( SUCCEEDED ( t_Result ) )
									{
										IWbemPathKeyList *t_ProviderKeys = NULL ;

										t_Result = t_ProviderPath->GetKeyList (

											& t_ProviderKeys
										) ;

										if ( SUCCEEDED ( t_Result ) )
										{
											ULONG t_ProviderLength = 0 ;
											ULONG t_Type = 0 ;

											t_Result = t_ProviderKeys->GetKey (

												0 ,
												0 ,
												NULL ,
												NULL ,
												& t_ProviderLength ,
												a_Provider ,
												& t_Type
											) ;

											if ( SUCCEEDED ( t_Result ) )
											{
												a_Provider = new wchar_t [ ( t_ProviderLength / sizeof ( wchar_t ) ) + 1 ] ;
												if ( a_Provider )
												{
													t_Result = t_ProviderKeys->GetKey (

														0 ,
														0 ,
														NULL ,
														NULL ,
														& t_ProviderLength ,
														a_Provider ,
														& t_Type
													) ;

													if ( FAILED ( t_Result ) )
													{
														delete [] a_Provider ;
													}
												}
												else
												{
													t_Result = WBEM_E_OUT_OF_MEMORY ;
												}
											}

											t_ProviderKeys->Release () ;
										}
									}

									t_ProviderPath->Release () ;
								}
							}

							delete [] t_ProviderReference ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_RegistrationKeys->Release () ;
				}
			}
			else
			{
				t_Result = WBEM_E_NOT_FOUND ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: PrePut (

    long a_Flags ,
    long a_UserFlags ,
    IWbemContext *a_Context ,
    IWbemPath *a_Path ,
    LPCWSTR a_Namespace ,
    LPCWSTR a_Class ,
    _IWmiObject *a_Copy
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = WBEM_S_NO_POSTHOOK;

	try
	{
		if ( ( a_Flags & WBEM_FLAG_INST_PUT ) == WBEM_FLAG_INST_PUT )
		{
			IWbemClassObject *t_Object = NULL ;
			t_Result = a_Copy->QueryInterface ( IID_IWbemClassObject , ( void ** ) & t_Object ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				QueryPreprocessor :: QuadState t_State = IsA ( t_Object  , L"__Win32Provider" ) ;
				if ( t_State == QueryPreprocessor :: State_Error )
				{
					t_Object->Release () ;

					return WBEM_E_OUT_OF_MEMORY ;
				}

				if ( t_State == QueryPreprocessor :: State_True )
				{
					CServerObject_ComProviderRegistrationV1 t_Registration ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Registration.QueryProperties ( 

							e_All ,
							t_Object , 
							NULL
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
#ifdef DEV_BUILD
							if ( SUCCEEDED ( t_Result ) ) 
							{
								t_Result = WBEM_S_POSTHOOK_WITH_BOTH ;
							}
#else
							if ( ( t_Registration.GetHosting () == e_Hosting_WmiCore ) || ( t_Registration.GetHosting () == e_Hosting_WmiCoreOrSelfHost ) ) 
							{
								t_Result = VerifySecureSvcHostProviders ( t_Registration.GetClsidServer ().GetProviderClsid () ) ;
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{
								t_Result = WBEM_S_POSTHOOK_WITH_BOTH ;
							}
#endif

						}
						else
						{
							t_Result = WBEM_E_VETO_PUT ;
						}
					}
				}
				else
				{
					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_Object  , L"__EventProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							t_Object->Release () ;
							return WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_Object  , L"__EventConsumerProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							t_Object->Release () ;
							return WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_Object  , L"__InstanceProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							t_Object->Release () ;
							return WBEM_E_OUT_OF_MEMORY ;
						}
						else if ( t_State == QueryPreprocessor :: State_True )
						{
							CServerObject_InstanceProviderRegistrationV1 t_Registration ;

							t_Result = t_Registration.QueryProperties ( 

								e_All ,
								t_Object
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = WBEM_S_POSTHOOK_WITH_BOTH ;
							}
							else
							{
								t_Result = WBEM_E_VETO_PUT ;
							}
						}
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_Object  , L"__MethodProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							t_Object->Release () ;
							return WBEM_E_OUT_OF_MEMORY ;
						}
						else if ( t_State == QueryPreprocessor :: State_True )
						{
							CServerObject_MethodProviderRegistrationV1 t_Registration ;

							t_Result = t_Registration.QueryProperties ( 

								e_All ,
								t_Object
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = WBEM_S_POSTHOOK_WITH_BOTH ;
							}
							else
							{
								t_Result = WBEM_E_VETO_PUT ;
							}
						}
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_Object  , L"__PropertyProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							t_Object->Release () ;
							return WBEM_E_OUT_OF_MEMORY ;
						}
						else if ( t_State == QueryPreprocessor :: State_True )
						{
							CServerObject_DynamicPropertyProviderRegistrationV1 t_Registration ;

							t_Result = t_Registration.QueryProperties ( 

								e_All ,
								t_Object
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = WBEM_S_POSTHOOK_WITH_BOTH ;
							}
							else
							{
								t_Result = WBEM_E_VETO_PUT ;
							}
						}
					}


					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_Object  , L"__ClassProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							t_Object->Release () ;
							return WBEM_E_OUT_OF_MEMORY ;
						}
						else if ( t_State == QueryPreprocessor :: State_True )
						{
							CServerObject_ClassProviderRegistrationV1 t_Registration ;

							t_Result = t_Registration.QueryProperties ( 

								e_All ,
								t_Object
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = WBEM_S_POSTHOOK_WITH_BOTH ;
							}
							else
							{
								t_Result = WBEM_E_VETO_PUT ;
							}
						}
					}
				}

				t_Object->Release () ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: PostPut (

    long a_Flags ,
    HRESULT hRes,
    IWbemContext *a_Context ,
    IWbemPath *a_Path ,
    LPCWSTR a_Namespace ,
    LPCWSTR a_Class ,
    _IWmiObject *a_New ,
    _IWmiObject *a_Old
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		IWbemClassObject *t_OldObject = NULL ;
		IWbemClassObject *t_NewObject = NULL ;

		if ( a_Old ) 
		{
			t_Result = a_Old->QueryInterface ( IID_IWbemClassObject , ( void ** ) & t_OldObject ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( a_New )
			{
				t_Result = a_New->QueryInterface ( IID_IWbemClassObject , ( void ** ) & t_NewObject ) ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			LPWSTR t_Class = NULL ;
			LPWSTR t_Path = NULL ;
			IWbemPath *t_PathObject = NULL ;

			if ( a_Class == NULL )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_NewObject->Get ( L"__Class" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Class = DupString(t_Variant.bstrVal);
					if ( t_Class == 0)
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					VariantClear ( & t_Variant ) ;
				}
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( a_Path == NULL )
				{
					t_Result = GetPath ( t_NewObject , t_PathObject , t_Path ) ;
				}
				else
				{
					t_Result = ProviderSubSystem_Common_Globals :: GetPathText (

						a_Path ,
						t_Path
					) ;
				}
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				LPWSTR t_Provider = NULL ;

				t_Result = GetProvider (

					a_Class ? a_Class : t_Class ,
					a_Path ? a_Path : t_PathObject ,
					t_NewObject ,
					t_Provider
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = VerifySecurity ( 

						a_Context ,
						( const BSTR ) t_Provider ,
						( const BSTR ) a_Namespace
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator ;

						BindingFactoryCacheElement *t_Factory = NULL ;

						Lock () ;

						try
						{
							BindingFactoryCacheKey t_Key ( a_Namespace ) ;

							WmiStatusCode t_StatusCode = Find ( t_Key , t_Iterator ) ;

							if ( t_StatusCode == e_StatusCode_Success )
							{
								t_Factory = t_Iterator.GetElement () ;
							}
							else
							{
								t_Result = WBEM_E_NOT_FOUND ;
							}
						}
						catch ( Wmi_Heap_Exception &a_Exception )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}

						UnLock () ;

						if ( SUCCEEDED ( t_Result  ) )
						{
							_IWmiProviderConfiguration *t_Configuration = NULL ;
							t_Result = t_Factory->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_Configuration ) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Configuration->Set (

									NULL ,
									a_Flags ,
									a_Context ,
									t_Provider ,
									a_Class ? a_Class : t_Class ,
									t_Path ,
									t_OldObject ,
									t_NewObject
								) ;

								t_Configuration->Release () ;
							}

							t_Factory->Release () ;
						}
					}

					delete [] t_Provider ;
				}
			}

			if ( t_Class )
			{
				delete [] t_Class ;
			}

			if ( t_Path )
			{
				delete [] t_Path ;
			}

			if ( t_PathObject )
			{
				t_PathObject->Release () ;
			}

			if ( t_OldObject )
			{
				t_OldObject->Release () ;
			}	
	
			t_NewObject->Release () ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: PreDelete (

    long a_Flags ,
    long a_UserFlags ,
    IWbemContext *a_Context ,
    IWbemPath *a_Path,
    LPCWSTR a_Namespace,
    LPCWSTR a_Class
)
{
	return WBEM_S_POSTHOOK_WITH_OLD ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: PostDelete_ProviderRegistration (

    long a_Flags ,
    HRESULT hRes,
    IWbemContext *a_Context ,
    IWbemPath *a_Path,
    LPCWSTR a_PathString ,
    LPCWSTR a_Namespace,
    LPCWSTR a_Class,
    IWbemClassObject *a_Old
)
{
	LPWSTR t_Provider = NULL ;

	HRESULT t_Result = GetProvider (

		a_Class ,
		a_Path ,
		a_Old ,
		t_Provider
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator ;

		BindingFactoryCacheElement *t_Factory = NULL ;

		Lock () ;

		try
		{
			BindingFactoryCacheKey t_Key ( a_Namespace ) ;

			WmiStatusCode t_StatusCode = Find ( t_Key , t_Iterator ) ;
			if ( t_StatusCode == e_StatusCode_Success )
			{
				t_Factory = t_Iterator.GetElement () ;
			}
			else
			{
				t_Result = WBEM_E_NOT_FOUND ;
			}
		}
		catch ( Wmi_Heap_Exception &a_Exception )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		UnLock () ;

		if ( SUCCEEDED ( t_Result ) )
		{
			_IWmiProviderConfiguration *t_Configuration = NULL ;
			t_Result = t_Factory->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_Configuration ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Configuration->Deleted (

					NULL ,
					a_Flags ,
					a_Context ,
					t_Provider ,
					a_Class ,
					a_PathString ,
					a_Old 
				) ;

				t_Configuration->Release () ;
			}

			t_Factory->Release () ;
		}

		delete [] t_Provider ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

wchar_t *CServerObject_ProviderSubSystem :: Strip_Slash ( wchar_t *a_String )
{
	wchar_t *t_String = DupString( a_String );
	if ( t_String )
	{
		wchar_t *t_Scan = t_String ;
		while ( *t_Scan != NULL )
		{
			if ( *t_Scan == '/' )
			{
				*t_Scan = '\\' ;
			}

			t_Scan ++ ;
		}
	}

	return t_String ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

wchar_t *CServerObject_ProviderSubSystem :: Strip_Server ( wchar_t *a_String , wchar_t *&a_FreeString )
{
	wchar_t *t_Mark = a_FreeString = Strip_Slash ( a_String ) ;
	if ( t_Mark )
	{
		wchar_t *t_Scan = t_Mark ;

		ULONG t_State = 0 ;
		while ( t_State < 0x80000000 )
		{
			switch ( t_State )
			{
				case 0:
				{
					if ( *t_Scan == '\\' )
					{
						t_State = 1 ;
					}
					else if ( *t_Scan == 0 )
					{
						t_State = 0x80000000 ;
					}
					else
					{
						t_State = 0x80000000 ;
					}
				}
				break ;

				case 1:
				{
					if ( *t_Scan == '\\' )
					{
						t_State = 2 ;
					}
					else
					{
						t_State = 0xFFFFFFFF ;
					}
				}
				break ;

				case 2:
				{
					t_State = 3 ;
					t_Mark = t_Scan ;
				}
				break ;

				case 3:
				{
					if ( ( *t_Scan == '\\' ) || ( *t_Scan == NULL ) )
					{
						t_State = 0x80000000 ;
					}
				}
				break ;

				case 0x80000000:
				case 0xFFFFFFFF:
				default:
				{
					t_State = 0xFFFFFFFF ;
				}
				break ;
			}

			if ( t_State < 0x80000000 )
			{
				t_Scan ++ ;
			}
		}

		if ( t_State != 0x80000000 )
		{
			delete [] a_FreeString ;
			t_Mark = NULL ;
		}
	}

	return t_Mark ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: IsChild_Namespace (

	wchar_t *a_Left ,
	wchar_t *a_Right
)
{
	HRESULT t_Result = S_OK ;

	wchar_t *t_Free = NULL ;
	wchar_t *t_Right = Strip_Server ( a_Right , t_Free ) ;
	if ( t_Right )
	{
		t_Result = ( wbem_wcsnicmp ( a_Left , t_Right , wcslen ( a_Left ) ) == 0 ) ? S_OK : S_FALSE ;

		delete [] t_Free ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: PostDelete_Namespace (

    long a_Flags ,
    HRESULT hRes,
    IWbemContext *a_Context ,
    IWbemPath *a_Path,
    LPCWSTR a_PathString ,
    LPCWSTR a_Namespace,
    LPCWSTR a_Class,
    IWbemClassObject *a_Old
)
{
	HRESULT t_Result = S_OK ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	LONG t_VarType = 0 ;
	LONG t_Flavour = 0 ;

	t_Result = a_Old->Get ( L"Name" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Variant.vt == VT_BSTR )
		{
			BSTR t_Namespace = NULL ;
			t_Result = WmiHelper :: ConcatenateStrings ( 

				3 ,
				& t_Namespace ,
				a_Namespace , 
				L"\\" ,
				t_Variant.bstrVal
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				wchar_t *t_ToDelete = NULL ;
				wchar_t *t_ToScan = Strip_Server ( t_Namespace , t_ToDelete ) ;
				if ( t_ToScan )
				{
					CWbemGlobal_IWmiFactoryController_Cache *t_Cache = NULL ;
					GetCache ( t_Cache ) ;

					Lock () ;

					if ( t_Cache->Size () )
					{
						IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Cache->Size () ] ;
						if ( t_ShutdownElements )
						{
							CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator = t_Cache->Begin ();

							ULONG t_Count = 0 ;
							while ( ! t_Iterator.Null () )
							{
								CWbemGlobal_IWmiFactoryController_Cache_Iterator t_NextIterator = t_Iterator ;
								t_NextIterator.Increment () ;

								t_Result = IsChild_Namespace ( t_ToScan , t_Iterator.GetKey ().m_Namespace ) ;
								if ( t_Result == S_OK )
								{
									t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;
	
									CWbemGlobal_IWmiFactoryController :: Shutdown ( t_Iterator.GetKey () ) ;
								}

								t_Iterator = t_NextIterator  ;

								t_Count ++ ;
							}

							UnLock () ;

							for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
							{
								if ( t_ShutdownElements [ t_Index ] ) 
								{
									t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

										0 ,
										0 ,
										NULL
									) ;

									t_ShutdownElements [ t_Index ]->Release () ;
								}
							}

							delete [] t_ShutdownElements ;
						}
						else
						{
							UnLock () ;

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						UnLock () ;
					}

					delete [] t_ToDelete ;
				}

				SysFreeString ( t_Namespace ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROPERTY ;
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: GetDeleteInfo (

	IWbemClassObject *a_OldObject ,
	LPCWSTR a_Class ,
    IWbemPath *a_Path ,
	LPWSTR &a_OutClass ,
	LPWSTR &a_OutStringPath ,
    IWbemPath *&a_OutPathObject
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Class == NULL )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		t_Result = a_OldObject->Get ( L"__Class" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			a_OutClass = DupString( t_Variant.bstrVal ) ;
			if ( a_OutClass == 0)
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Path == NULL )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			t_Result = a_OldObject->Get ( L"__Path" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				a_OutStringPath = DupString(t_Variant.bstrVal );
				if ( a_OutStringPath == 0)
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = CoCreateInstance (

						CLSID_WbemDefPath ,
						NULL ,
						CLSCTX_INPROC_SERVER ,
						IID_IWbemPath ,
						( void ** )  & a_OutPathObject
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = a_OutPathObject->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_OutStringPath ) ;
					}
				}

				VariantClear ( & t_Variant ) ;
			}
		}
		else
		{
			t_Result = ProviderSubSystem_Common_Globals :: GetPathText (

				a_Path ,
				a_OutStringPath
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: PostDelete (

    long a_Flags ,
    HRESULT hRes,
    IWbemContext *a_Context ,
    IWbemPath *a_Path,
    LPCWSTR a_Namespace,
    LPCWSTR a_Class,
    _IWmiObject *a_Old
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		IWbemClassObject *t_OldObject = NULL ;
		t_Result = a_Old->QueryInterface ( IID_IWbemClassObject , ( void ** ) & t_OldObject ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			QueryPreprocessor :: QuadState t_State = IsA ( t_OldObject  , L"__Namespace" ) ;
			if ( t_State == QueryPreprocessor :: State_Error )
			{
				t_OldObject->Release () ;

				return WBEM_E_OUT_OF_MEMORY ;
			}

			if ( t_State == QueryPreprocessor :: State_True )
			{
				LPWSTR t_Class = NULL ;
				LPWSTR t_Path = NULL ;
				IWbemPath *t_PathObject = NULL ;

				t_Result = GetDeleteInfo (

					t_OldObject ,
					a_Class ,
					a_Path ,
					t_Class ,
					t_Path ,
					t_PathObject
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = PostDelete_Namespace ( 

						a_Flags ,
						hRes,
						a_Context ,
						a_Path ? a_Path : t_PathObject ,
						t_Path ,
						a_Namespace,
						a_Class ? a_Class : t_Class ,
						a_Old
					) ;
				}

				if ( t_Class )
				{
					delete [] t_Class ;
				}

				if ( t_Path )
				{
					delete [] t_Path ;
				}

				if ( t_PathObject )
				{
					t_PathObject->Release () ;
				}
			}
			else
			{
				if ( t_State == QueryPreprocessor :: State_False )
				{
					t_State = IsA ( t_OldObject  , L"__EventProviderRegistration" ) ;
					if ( t_State == QueryPreprocessor :: State_Error )
					{
						return WBEM_E_OUT_OF_MEMORY ;
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_OldObject  , L"__EventProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							return WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_OldObject  , L"__EventConsumerProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							return WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_OldObject  , L"__InstanceProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							return WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_OldObject  , L"__MethodProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							return WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_OldObject  , L"__PropertyProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							return WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_OldObject  , L"__ClassProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							return WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( t_State == QueryPreprocessor :: State_True )
					{
						LPWSTR t_Class = NULL ;
						LPWSTR t_Path = NULL ;
						IWbemPath *t_PathObject = NULL ;

						t_Result = GetDeleteInfo (

							t_OldObject ,
							a_Class ,
							a_Path ,
							t_Class ,
							t_Path ,
							t_PathObject
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = PostDelete_ProviderRegistration ( 

								a_Flags ,
								hRes,
								a_Context ,
								a_Path ? a_Path : t_PathObject ,
								t_Path ,
								a_Namespace,
								a_Class ? a_Class : t_Class ,
								a_Old
							) ;
						}

						if ( t_Class )
						{
							delete [] t_Class ;
						}

						if ( t_Path )
						{
							delete [] t_Path ;
						}

						if ( t_PathObject )
						{
							t_PathObject->Release () ;
						}
					}
				}
			}

			t_OldObject->Release () ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Initialize (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	_IWmiCoreServices *a_Core
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		if ( a_Core )
		{
			m_Core = a_Core ;
			m_Core->AddRef () ;
		}

		WmiStatusCode t_StatusCode = CWbemGlobal_IWmiFactoryController :: Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				_IWmiCoreWriteHook *t_ThisHook = NULL ;
				t_Result = this->QueryInterface ( IID_CWbemSubSystemHook , ( void ** ) & t_ThisHook ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = m_Core->RegisterWriteHook (

						WBEM_FLAG_INST_PUT|WBEM_FLAG_INST_DELETE ,
						t_ThisHook
					) ;

					t_ThisHook->Release () ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			ProviderSubSystem_Globals :: s_DecoupledRegistrar = new CDecoupled_ProviderSubsystemRegistrar ( *ProviderSubSystem_Globals :: s_Allocator  , this ) ;
			if ( ProviderSubSystem_Globals :: s_DecoupledRegistrar )
			{
				ProviderSubSystem_Globals :: s_DecoupledRegistrar->AddRef () ;

				t_Result = ProviderSubSystem_Globals :: s_DecoupledRegistrar->Save () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}


		if ( SUCCEEDED ( t_Result ) )
		{
			m_SinkController = new CWbemGlobal_VoidPointerController ( 

				m_Allocator 
			)  ;

			if ( m_SinkController ) 
			{
				m_SinkController->AddRef () ;

				WmiStatusCode t_StatusCode = m_SinkController->CWbemGlobal_VoidPointerController :: Initialize () ;
				if ( t_StatusCode != e_StatusCode_Success ) 
				{
					m_SinkController->Release () ;
					m_SinkController = NULL ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

void ClearHostsCache(void)
{
	CWbemGlobal_IWmiHostController_Cache *t_Cache = NULL ;
	ProviderSubSystem_Globals::GetHostController()->GetCache(t_Cache);
		
	ProviderSubSystem_Globals::GetHostController()->Lock();
	CWbemGlobal_IWmiHostController_Cache_Iterator t_HostIterator = t_Cache->Begin();
	while (!t_HostIterator.Null())
	{
		ProviderSubSystem_Globals::GetHostController()->UnLock();
		ProviderSubSystem_Globals::GetHostController()->Shutdown(t_HostIterator.GetKey()); 
		ProviderSubSystem_Globals::GetHostController()->Lock();
		t_HostIterator = t_Cache->Begin();
	}
	ProviderSubSystem_Globals::GetHostController()->UnLock();
};
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT CServerObject_ProviderSubSystem :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		if ( m_Core ) 
		{
			_IWmiCoreWriteHook *t_ThisHook = NULL ;
			t_Result = this->QueryInterface ( IID_CWbemSubSystemHook , ( void ** ) & t_ThisHook ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = m_Core->UnregisterWriteHook (

					t_ThisHook
				) ;

				t_ThisHook->Release () ;
			}
		}

		Lock () ;

		CWbemGlobal_IWmiFactoryController_Cache *t_Cache = NULL ;
		GetCache ( t_Cache ) ;

		if ( t_Cache->Size () )
		{
			IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Cache->Size () ] ;
			if ( t_ShutdownElements )
			{
				CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator = t_Cache->Begin ();

				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ShutdownElements [ t_Index ] )
					{
						t_Result = t_ShutdownElements [ t_Index ]->Shutdown (

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;

						t_ShutdownElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ShutdownElements ;
			}
			else
			{
				UnLock () ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else	
		{
			UnLock () ;
		}

		CWbemGlobal_IWmiFactoryController :: Shutdown () ;

		if ( ProviderSubSystem_Globals :: s_DecoupledRegistrar )
		{
			t_Result = ProviderSubSystem_Globals :: s_DecoupledRegistrar->Delete () ;

			ProviderSubSystem_Globals :: s_DecoupledRegistrar->Release () ;
			ProviderSubSystem_Globals :: s_DecoupledRegistrar = NULL ;
		}

		ProviderSubSystem_Globals::GetHostController()->Shutdown();

		ProviderSubSystem_Globals :: ClearGuidTag();
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CServerObject_ProviderSubSystem :: Strobe ( ULONG &a_NextStrobeDelta )
{
	Lock () ;

	CWbemGlobal_IWmiFactoryController_Cache *t_Cache = NULL ;
	GetCache ( t_Cache ) ;

	if ( t_Cache->Size () )
	{
		CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator = t_Cache->Begin ();

		CServerObject_StrobeInterface **t_ControllerElements = new CServerObject_StrobeInterface * [ t_Cache->Size () ] ;
		if ( t_ControllerElements )
		{
			ULONG t_Count = 0 ;
			while ( ! t_Iterator.Null () )
			{
				HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_CWbemGlobal_IWmiProviderController , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

				t_Iterator.Increment () ;

				t_Count ++ ;
			}

			UnLock () ;

			for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
			{
				if ( t_ControllerElements [ t_Index ] )
				{
					HRESULT t_Result = t_ControllerElements [ t_Index ]->Strobe ( a_NextStrobeDelta ) ;

					t_ControllerElements [ t_Index ]->Release () ;
				}
			}

			delete [] t_ControllerElements ;
		}
		else
		{
			UnLock () ;
		}
	}
	else
	{
		UnLock () ;
	}

	return CWbemGlobal_IWmiFactoryController :: Strobe ( a_NextStrobeDelta ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CServerObject_ProviderSubSystem :: StrobeBegin ( const ULONG &a_Period )
{
	ULONG t_Timeout = ProviderSubSystem_Globals :: GetStrobeThread ().GetTimeout () ;
	ProviderSubSystem_Globals :: GetStrobeThread ().SetTimeout ( t_Timeout < a_Period ? t_Timeout : a_Period ) ;

	return e_StatusCode_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provswsv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"

#include <wbemint.h>
#include <stdio.h>
#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvFact.h"
#include "ProvObSk.h"
#include "ProvInSk.h"
#include "ProvWsv.h"
#include "ProvCache.h"

#include "arrtempl.h"

#include "Guids.h"

#ifdef WMIASLOCAL
#include "Main.h"
#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CheckThreadToken () 
{
	HANDLE t_ThreadToken ;
	BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		MAXIMUM_ALLOWED ,
		TRUE ,
		& t_ThreadToken
	) ;

	if ( ! t_Status ) 
	{
		DWORD t_LastError = GetLastError () ;
		if ( t_LastError == ERROR_ACCESS_DENIED )
		{
#ifdef DBG                  
			DebugBreak () ;
#endif
		}
	}
	else
	{
		CloseHandle ( t_ThreadToken ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncUnboundObjectSink :: CInterceptor_IWbemSyncUnboundObjectSink (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) :	VoidPointerContainerElement (

		a_Controller ,
		this 
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Registration ( & a_Registration ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_UnBoundSync_Size , MAX_PROXIES )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncUnboundObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	if ( a_ServerSideProvider ) 
	{
		m_Unknown = a_ServerSideProvider ;
		m_Unknown->AddRef () ;

		HRESULT t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
		if (FAILED(t_Result)) DEBUGTRACE((LOG_PROVSS,"        CInterceptor_IWbemSyncUnboundObjectSink->QI hr = %08x\n",t_Result));
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncUnboundObjectSink :: ~CInterceptor_IWbemSyncUnboundObjectSink ()
{
	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncUnboundObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncUnboundObjectSink :: Initialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemSyncUnboundObjectSink :: AddRef ()
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemSyncUnboundObjectSink :: Release ()
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemSyncUnboundObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID__IWmiProviderSite )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderSite * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncUnboundObjectSink :: Begin_Interface_Consumer (

	bool a_Identify ,
	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	if ( a_Identify )
	{
		DWORD t_AuthenticationLevel = 0 ;

		t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( 
			
			a_OldContext , 
			a_OldSecurity , 
			a_Impersonating , 
			& t_AuthenticationLevel 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
					
				m_ProxyContainer , 
				a_ProxyIndex , 
				a_InterfaceIdentifier , 
				a_ServerInterface , 
				a_Proxy , 
				a_Revert
			) ;

			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				a_Interface = a_ServerInterface ;
				a_IsProxy = FALSE ;
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					a_IsProxy = TRUE ;

					a_Interface = ( IUnknown * ) a_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						a_Interface ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( FAILED ( t_Result ) )
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

							m_ProxyContainer , 
							a_ProxyIndex , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}
			}

			if ( FAILED ( t_Result ) && t_Result != WBEM_E_NOT_FOUND )
			{
				ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
			}
		}
	}
	else
	{
		DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;

		IServerSecurity *t_ServerSecurity = NULL ;
		HRESULT t_TempResult = CoGetCallContext ( IID_IUnknown , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_Result = CoImpersonateClient () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				CoRevertToSelf () ;
			}

			t_ServerSecurity->Release () ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IDENTIFY )
			{
				t_Result = CoSwitchCallContext ( NULL , &a_OldContext ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						a_Impersonating = a_OldSecurity->IsImpersonating () ;
					}
				}

				a_Interface = a_ServerInterface ;
				a_IsProxy = FALSE ;
			}
			else
			{
				DWORD t_AuthenticationLevel = 0 ;

				t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( 
					
					a_OldContext , 
					a_OldSecurity , 
					a_Impersonating , 
					& t_AuthenticationLevel 
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
							
						m_ProxyContainer , 
						a_ProxyIndex , 
						a_InterfaceIdentifier , 
						a_ServerInterface , 
						a_Proxy , 
						a_Revert
					) ;

					if ( t_Result == WBEM_E_NOT_FOUND )
					{
						t_Result = S_OK ;
						a_Interface = a_ServerInterface ;
						a_IsProxy = FALSE ;
					}
					else
					{
						if ( SUCCEEDED ( t_Result ) )
						{
							a_IsProxy = TRUE ;

							a_Interface = ( IUnknown * ) a_Proxy ;

							// Set cloaking on the proxy
							// =========================

							DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

							t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

								a_Interface ,
								RPC_C_AUTHN_LEVEL_DEFAULT , 
								t_ImpersonationLevel
							) ;

							if ( FAILED ( t_Result ) )
							{
								HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

									m_ProxyContainer , 
									a_ProxyIndex , 
									a_Proxy , 
									a_Revert
								) ;
							}
						}
					}

					if ( FAILED ( t_Result ) && t_Result != WBEM_E_NOT_FOUND )
					{
						ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
					}
				}
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncUnboundObjectSink :: End_Interface_Consumer (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

			m_ProxyContainer , 
			a_ProxyIndex , 
			a_Proxy , 
			a_Revert
		) ;
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncUnboundObjectSink :: Internal_IndicateToConsumer (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = InternalEx_IndicateToConsumer (

			true ,
			a_LogicalConsumer ,
			a_ObjectCount ,
			a_Objects
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncUnboundObjectSink :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	return InternalEx_IndicateToConsumer (

		false ,
		a_LogicalConsumer ,
		a_ObjectCount ,
		a_Objects
	) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncUnboundObjectSink :: InternalEx_IndicateToConsumer (

	bool a_Identify ,
	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemUnboundObjectSink ;
		REFIID t_InterfaceIdentifier = IID_IWbemUnboundObjectSink ;
		DWORD t_ProxyIndex = ProxyIndex_UnBound_IWbemUnboundObjectSink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		HRESULT t_Result = Begin_Interface_Consumer (

			a_Identify ,
			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			try
			{
				t_Result = ( ( IWbemUnboundObjectSink * ) t_Interface )->IndicateToConsumer (

					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			End_Interface_Consumer (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncUnboundObjectSink :: Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncUnboundObjectSink :: GetSite ( DWORD *a_ProcessIdentifier )
{
	HRESULT t_Result = S_OK ;

	if ( a_ProcessIdentifier ) 
	{
		*a_ProcessIdentifier = GetCurrentProcessId () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncUnboundObjectSink :: SetContainer ( IUnknown *a_Container )
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncProvider :: CInterceptor_IWbemSyncProvider (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	IWbemServices *a_CoreStub ,
	CWbemGlobal_IWbemSyncProviderController *a_Controller ,
	IWbemContext *a_InitializationContext ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	GUID &a_Guid 

) :	CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	SyncProviderContainerElement (

		a_Controller ,
		a_Guid
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemServices ( NULL ) ,
	m_Provider_IWbemPropertyProvider ( NULL ) ,
	m_Provider_IWbemHiPerfProvider ( NULL ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_ExtendedStatusObject ( NULL ) ,
	m_CoreStub ( a_CoreStub ) ,
	m_Quota ( NULL ) ,
	m_Registration ( & a_Registration ) ,
	m_Locale ( NULL ) ,
	m_User ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_Provider_Size , MAX_PROXIES ) ,
	m_ProviderOperation_GetObjectAsync ( 0 ) ,
	m_ProviderOperation_PutClassAsync ( 0 ) ,
	m_ProviderOperation_DeleteClassAsync ( 0 ) ,
	m_ProviderOperation_CreateClassEnumAsync ( 0 ) ,
	m_ProviderOperation_PutInstanceAsync ( 0 ) ,
	m_ProviderOperation_DeleteInstanceAsync ( 0 ) ,
	m_ProviderOperation_CreateInstanceEnumAsync ( 0 ) ,
	m_ProviderOperation_ExecQueryAsync ( 0 ) ,
	m_ProviderOperation_ExecNotificationQueryAsync ( 0 ) ,
	m_ProviderOperation_ExecMethodAsync ( 0 ) ,
	m_ProviderOperation_QueryInstances ( 0 ) ,
	m_ProviderOperation_CreateRefresher ( 0 ) ,
	m_ProviderOperation_CreateRefreshableObject ( 0 ) ,
	m_ProviderOperation_StopRefreshing ( 0 ) ,
	m_ProviderOperation_CreateRefreshableEnum ( 0 ) ,
	m_ProviderOperation_GetObjects ( 0 ) ,
	m_ProviderOperation_GetProperty ( 0 ) ,
	m_ProviderOperation_PutProperty ( 0 ) ,
	m_ProviderOperation_ProvideEvents ( 0 ) ,
	m_ProviderOperation_NewQuery ( 0 ) ,
	m_ProviderOperation_CancelQuery ( 0 ) ,
	m_ProviderOperation_AccessCheck ( 0 ) ,
	m_ProviderOperation_SetRegistrationObject ( 0 ) ,
	m_ProviderOperation_FindConsumer ( 0 ) ,
	m_ProviderOperation_ValidateSubscription ( 0 ) ,
	m_Initialized ( 0 ) ,
	m_InitializeResult ( S_OK ) ,
	m_InitializedEvent ( NULL ) , 
	m_InitializationContext ( a_InitializationContext )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( a_InitializationContext )
	{
		a_InitializationContext->AddRef () ;
	}

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->AddRef () ;
	}

	if ( a_ServerSideProvider ) 
	{
		m_Unknown = a_ServerSideProvider ;
		m_Unknown->AddRef () ;

		HRESULT t_Result;
		BOOL t_OneSucceded = FALSE;
		
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemServices , ( void ** ) & m_Provider_IWbemServices ) ;
				
		if ( FAILED( t_Result) )
		{
		    if (t_Result != E_NOINTERFACE )
			{
				DEBUGTRACE((LOG_PROVSS,"        ServerSideProvider->QI(IID_IWbemServices) hr = %08x\n",t_Result ));		
				m_InitializeResult = t_Result ;
				return ;
			}		    
		} 
		else
		    t_OneSucceded = TRUE;
		
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemPropertyProvider , ( void ** ) & m_Provider_IWbemPropertyProvider ) ;
		
		if ( FAILED( t_Result) )
		{				
		    if (E_NOINTERFACE != t_Result)
		    {
			    DEBUGTRACE((LOG_PROVSS,"        ServerSideProvider->QI(IID_IWbemPropertyProvider) hr = %08x\n",t_Result ));
    			m_InitializeResult = t_Result ;
	    		return ;
		    }
		}
		else
		    t_OneSucceded = TRUE;		
		
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
		
		if ( FAILED( t_Result) )
		{		
		    if (E_NOINTERFACE != t_Result)
		    {
			    DEBUGTRACE((LOG_PROVSS,"        ServerSideProvider->QI(IID_IWbemEventProvider) hr = %08x\n",t_Result ));
    			m_InitializeResult = t_Result ;
	    		return ;
		    }
		}
		else
		    t_OneSucceded = TRUE;		
		
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;

		if ( FAILED( t_Result) )
		{
		    if (E_NOINTERFACE != t_Result)
		    {		
				DEBUGTRACE((LOG_PROVSS,"        ServerSideProvider->QI(IID_IWbemEventProviderQuerySink) hr = %08x\n",t_Result ));
				m_InitializeResult = t_Result ;
				return ;
		    }
		}
		else
		    t_OneSucceded = TRUE;		
		
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
		
		if ( FAILED( t_Result) )
		{
		    if (E_NOINTERFACE != t_Result)
		    {		
				DEBUGTRACE((LOG_PROVSS,"        ServerSideProvider->QI(IID_IWbemEventProviderSecurity) hr = %08x\n",t_Result ));
				m_InitializeResult = t_Result ;
				return ;
		    }
		}
		else
		    t_OneSucceded = TRUE;		
		
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_IWbemEventConsumerProviderEx ) ;
		
		if ( FAILED( t_Result) )
		{		
			if (E_NOINTERFACE != t_Result)
		    {
				DEBUGTRACE((LOG_PROVSS,"        ServerSideProvider->QI(IID_IWbemEventConsumerProviderEx ) hr = %08x\n",t_Result ));
				m_InitializeResult = t_Result ;
				return ;
			}
		}
		else
		    t_OneSucceded = TRUE;
		
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
		
		if ( FAILED( t_Result) )
		{	
		    if (E_NOINTERFACE != t_Result)
		    {		
				DEBUGTRACE((LOG_PROVSS,"        ServerSideProvider->QI(IID_IWbemEventConsumerProvider) hr = %08x\n",t_Result ));			
				m_InitializeResult = t_Result ;
				return ;
		    }
		}		
		else
		    t_OneSucceded = TRUE;		
		
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
		
		if ( FAILED( t_Result) )
		{
		    if (E_NOINTERFACE != t_Result)
		    {		
				DEBUGTRACE((LOG_PROVSS,"        ServerSideProvider->QI(IID_IWbemUnboundObjectSink) hr = %08x\n",t_Result ));
				m_InitializeResult = t_Result ;
				return ;
		    }
		}
		else
		    t_OneSucceded = TRUE;		
		
	    t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemHiPerfProvider , ( void ** ) & m_Provider_IWbemHiPerfProvider ) ;

		if ( FAILED( t_Result) )
		{	    
		    if ( E_NOINTERFACE != t_Result )
		    {
			    DEBUGTRACE((LOG_PROVSS,"        ServerSideProvider->QI(IID_IWbemHiPerfProvider) hr = %08x\n",t_Result ));
				m_InitializeResult = t_Result ;
				return ;
		    }
		}
		else
		    t_OneSucceded = TRUE;		

		if (FALSE == t_OneSucceded)
		{
			m_InitializeResult = E_NOINTERFACE;
		}

	}

}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncProvider :: ~CInterceptor_IWbemSyncProvider ()
{
	WmiSetAndCommitObject (

		ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_UnLoadOperationEvent ] , 
		WMI_SENDCOMMIT_SET_NOT_REQUIRED,
		m_Namespace ,
		m_Registration->GetProviderName () ,
		m_User ,
		m_Locale ,
		NULL 
	) ;

	if ( m_ExtendedStatusObject )
	{
		m_ExtendedStatusObject->Release () ;
	}

	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemServices )
	{
		m_Provider_IWbemServices->Release () ; 
	}

	if ( m_Provider_IWbemPropertyProvider )
	{
		m_Provider_IWbemPropertyProvider->Release () ; 
	}

	if ( m_Provider_IWbemHiPerfProvider )
	{
		m_Provider_IWbemHiPerfProvider->Release () ;
	}

	if ( m_Provider_IWbemEventProvider )
	{
		m_Provider_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		m_Provider_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		m_Provider_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		m_Provider_IWbemEventConsumerProviderEx->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProvider )
	{
		m_Provider_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->Release () ;
	}

	if ( m_Quota )
	{
		m_Quota->Release () ;
	}

	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	if ( m_InitializationContext )
	{
		m_InitializationContext->Release () ;
	}

	if ( m_InitializedEvent )
	{
		CloseHandle ( m_InitializedEvent ) ;
	}

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
	
#ifdef WMIASLOCAL
	SetProviderDestruction();
#endif
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemSyncProvider :: AddRef ()
{
	return SyncProviderContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemSyncProvider :: Release ()
{
	return SyncProviderContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemSyncProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		if ( m_Provider_IWbemServices || m_Provider_IWbemHiPerfProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemServices * ) this ;
		}
	}
	else if ( iid == IID_IWbemPropertyProvider )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemPropertyProvider * ) this ;
		}
	}	
	else if ( iid == IID_IWbemHiPerfProvider )
	{
		if ( m_Provider_IWbemHiPerfProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemHiPerfProvider * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProvider )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProvider * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID__IWmiProviderSite )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderSite * ) this ;		
	}
	else if ( iid == IID__IWmiProviderQuota )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderQuota * ) this ;		
	}
	else if ( iid == IID__IWmiProviderInitialize )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderInitialize * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}
	else if ( iid == IID__IWmiProviderConfiguration )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderConfiguration * ) this ;		
	}	
	else if ( iid == IID_CWbemGlobal_IWmiObjectSinkController )
	{
		*iplpv = ( LPVOID ) ( CWbemGlobal_IWmiObjectSinkController * ) this ;		
	}	
	else if ( iid == IID_CacheElement )
	{
		*iplpv = ( LPVOID ) ( SyncProviderContainerElement * ) this ;		
	}
	else if ( iid == IID_Internal_IWbemServices )
	{
		if ( m_Provider_IWbemServices || m_Provider_IWbemHiPerfProvider )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemServices * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWbemPropertyProvider )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemPropertyProvider * ) this ;
		}
	}	
	else if ( iid == IID_Internal_IWbemEventProvider )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemEventProvider * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWmiProviderConfiguration )
	{
		*iplpv = ( LPVOID ) ( Internal_IWmiProviderConfiguration * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_OpenNamespace ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = OpenNamespace (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_NamespaceService ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_CancelAsyncCall ( 
	
	WmiInternalContext a_InternalContext ,		
	IWbemObjectSink *a_Sink
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CancelAsyncCall (
		
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_QueryObjectSink ( 

	WmiInternalContext a_InternalContext ,
	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryObjectSink (

			a_Flags ,	
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_GetObject ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetObject (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_Object ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_GetObjectAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetObjectAsync (

			a_ObjectPath ,
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_PutClass ( 

	WmiInternalContext a_InternalContext ,		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutClass (

			a_Object ,
			a_Flags , 
			a_Context ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_PutClassAsync ( 
		
	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_Object , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutClassAsync (

			a_Object , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_DeleteClass ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteClass (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_DeleteClassAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteClassAsync (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_CreateClassEnum ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_SuperClass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateClassEnum (

			a_SuperClass ,
			a_Flags, 
			a_Context ,
			a_Enum
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_CreateClassEnumAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_SuperClass , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateClassEnumAsync (

			a_SuperClass ,
			a_Flags, 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_PutInstance (

	WmiInternalContext a_InternalContext ,
    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutInstance (

			a_Instance ,
			a_Flags ,
			a_Context ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_PutInstanceAsync ( 

	WmiInternalContext a_InternalContext ,		
	IWbemClassObject *a_Instance , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutInstanceAsync (

			a_Instance , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_DeleteInstance ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteInstance (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_DeleteInstanceAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteInstanceAsync (

			a_ObjectPath ,
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_CreateInstanceEnum ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateInstanceEnum (

			a_Class ,
			a_Flags , 
			a_Context , 
			a_Enum
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_CreateInstanceEnumAsync (

	WmiInternalContext a_InternalContext ,
 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateInstanceEnumAsync (

			a_Class ,
			a_Flags ,
			a_Context ,
			a_Sink 
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_ExecQuery ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecQuery (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Enum
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_ExecQueryAsync ( 

	WmiInternalContext a_InternalContext ,		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecQueryAsync (

			a_QueryLanguage ,
			a_Query, 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_ExecNotificationQuery ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecNotificationQuery (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Enum
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemSyncProvider :: Internal_ExecNotificationQueryAsync ( 

	WmiInternalContext a_InternalContext ,            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecNotificationQueryAsync (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Sink 
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_ExecMethod (

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecMethod (

			a_ObjectPath ,
			a_MethodName ,
			a_Flags ,
			a_Context ,
			a_InParams ,
			a_OutParams ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_ExecMethodAsync ( 

	WmiInternalContext a_InternalContext ,		
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecMethodAsync (

			a_ObjectPath ,
			a_MethodName ,
			a_Flags ,
			a_Context ,
			a_InParams ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_GetProperty (

	WmiInternalContext a_InternalContext ,
    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetProperty ( 

			a_Flags ,
			a_Locale ,
			a_ClassMapping ,
			a_InstanceMapping ,
			a_PropertyMapping ,
			a_Value
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_PutProperty (

	WmiInternalContext a_InternalContext ,
    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutProperty ( 

			a_Flags ,
			a_Locale ,
			a_ClassMapping ,
			a_InstanceMapping ,
			a_PropertyMapping ,
			a_Value
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_ProvideEvents (

	WmiInternalContext a_InternalContext ,
	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = InternalEx_ProvideEvents (

			true ,
			a_Sink ,
			a_Flags 
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_NewQuery (

	WmiInternalContext a_InternalContext ,
	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = InternalEx_NewQuery (

			true ,
			a_Id ,
			a_QueryLanguage ,
			a_Query
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_CancelQuery (

	WmiInternalContext a_InternalContext ,
	unsigned long a_Id
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = InternalEx_CancelQuery (

			true ,
			a_Id
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_AccessCheck (

	WmiInternalContext a_InternalContext ,
	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = InternalEx_AccessCheck (

			true ,
			a_QueryLanguage ,
			a_Query ,
			a_SidLength ,
			a_Sid
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_FindConsumer (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = InternalEx_FindConsumer (

			true ,
			a_LogicalConsumer ,
			a_Consumer
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_ValidateSubscription (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = InternalEx_ValidateSubscription (

			true ,
			a_LogicalConsumer
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_IndicateToConsumer (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = InternalEx_IndicateToConsumer (

			true ,
			a_LogicalConsumer ,
			a_ObjectCount ,
			a_Objects
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_Get (

	WmiInternalContext a_InternalContext ,
	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemObjectSink *a_Sink
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Get (
		
			a_Service ,
			a_Flags ,
			a_Context ,
			a_Class ,
			a_Path ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_Set (

	WmiInternalContext a_InternalContext ,
	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_OldObject ,
	IWbemClassObject *a_NewObject  
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Set (
		
			a_Service ,
			a_Flags ,
			a_Context ,
			a_Provider ,
			a_Class ,
			a_Path ,
			a_OldObject ,
			a_NewObject  
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_Deleted (

	WmiInternalContext a_InternalContext ,
	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_Object  
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Deleted (
		
			a_Service ,
			a_Flags ,
			a_Context ,
			a_Provider ,
			a_Class ,
			a_Path ,
			a_Object  
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_Enumerate (

	WmiInternalContext a_InternalContext ,
	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	IWbemObjectSink *a_Sink
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Enumerate (
		
			a_Service ,
			a_Flags ,
			a_Context ,
			a_Class ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_Call (

	WmiInternalContext a_InternalContext ,
	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	LPCWSTR a_Method,
	IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Call (
		
			a_Service ,
			a_Flags ,
			a_Context ,
			a_Class ,
			a_Path ,
			a_Method,
			a_InParams,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_Query (

	WmiInternalContext a_InternalContext ,
	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
	WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
	VARIANT *a_Value 
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Query (
		
			a_Service ,
			a_Flags ,
			a_Context ,
			a_ClassIdentifier ,
			a_PropertyIdentifier ,
			a_Value 
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_Shutdown (

	WmiInternalContext a_InternalContext ,
	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	ULONG a_MilliSeconds
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Shutdown (
		
			a_Service ,
			a_Flags ,
			a_Context ,
			a_Provider ,
			a_MilliSeconds
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: AdjustGetContext (

    IWbemContext *a_Context
)
{
    // See if per-property get are being used.
    // ========================================

    HRESULT t_Result = S_OK ;

    if ( a_Context )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		t_Result = a_Context->GetValue ( L"__GET_EXTENSIONS" , 0, & t_Variant ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			// If here, they are being used.  Next we have to check and see
			// if the reentrancy flag is set or not.
			// =============================================================

			VariantClear ( & t_Variant ) ;

			t_Result = a_Context->GetValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 , & t_Variant ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				
				VariantClear ( & t_Variant ) ;

				a_Context->DeleteValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 ) ;
			}
			else
			{
				// If here, we have to clear out the get extensions.
				// =================================================

				a_Context->DeleteValue ( L"__GET_EXTENSIONS" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_KEYS_ONLY" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_PROPERTIES" , 0 ) ;
			}
		}
	}

    return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: SetStatus ( 

	LPWSTR a_Operation ,
	LPWSTR a_Parameters ,
	LPWSTR a_Description ,
	HRESULT a_Result ,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	if ( m_ExtendedStatusObject )
	{
		IWbemClassObject *t_StatusObject ;
		t_Result = m_ExtendedStatusObject ->SpawnInstance ( 

			0 , 
			& t_StatusObject
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: Set_String ( t_StatusObject , L"Provider" , m_Registration->GetProviderName () ) ;

			if ( a_Operation ) 
			{
				ProviderSubSystem_Common_Globals :: Set_String ( t_StatusObject , L"Operation" , a_Operation ) ;
			}

			if ( a_Parameters ) 
			{
				ProviderSubSystem_Common_Globals :: Set_String ( t_StatusObject , L"ParameterInfo" , a_Parameters ) ;
			}

			if ( a_Description ) 
			{
				ProviderSubSystem_Common_Globals :: Set_String ( t_StatusObject , L"Description" , a_Description ) ;
			}

			_IWmiObject *t_FastStatusObject ;
			t_Result = t_StatusObject->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastStatusObject ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				ProviderSubSystem_Common_Globals :: Set_Uint32 ( t_FastStatusObject , L"StatusCode" , a_Result ) ;

				t_FastStatusObject->Release () ;
			}

			t_Result = a_Sink->SetStatus ( 0 , a_Result , L"Provider Subsystem Error Report" , t_StatusObject ) ;

			t_StatusObject->Release () ;
		}
		else
		{
			t_Result = a_Sink->SetStatus ( 0 , a_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = a_Sink->SetStatus ( 0 , a_Result , NULL , NULL ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Begin_IWbemServices (

	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IWbemServices *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalServiceHost:
		case e_Hosting_SharedNetworkServiceHost:
		{
			a_Interface = m_Provider_IWbemServices ;
			a_IsProxy = FALSE ;
		}
		break ;

		default:
		{
			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , a_Proxy , a_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					a_Interface = m_Provider_IWbemServices ;
					a_IsProxy = FALSE ;
					t_Result = S_OK ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						a_IsProxy = TRUE ;

						a_Interface = ( IWbemServices * ) a_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							a_Interface ,
							RPC_C_AUTHN_LEVEL_DEFAULT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						if ( FAILED ( t_Result ) )
						{
							HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

								m_ProxyContainer , 
								ProxyIndex_IWbemServices , 
								a_Proxy , 
								a_Revert
							) ;
						}
					}
				}

				if ( FAILED ( t_Result ) && t_Result != WBEM_E_NOT_FOUND )
				{
					ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
				}
			}
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: End_IWbemServices (

	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IWbemServices *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

			m_ProxyContainer , 
			ProxyIndex_IWbemServices , 
			a_Proxy , 
			a_Revert
		) ;
	}

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalServiceHost:
		case e_Hosting_SharedNetworkServiceHost:
		{
		}
		break ;

		default:
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
		break ;
	}
	
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Begin_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalServiceHost:
		case e_Hosting_SharedNetworkServiceHost:
		{
			a_Interface = a_ServerInterface ;
			a_IsProxy = FALSE ;
		}
		break ;

		default:
		{
			DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_DEFAULT ;
			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating , & t_AuthenticationLevel ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;

				IServerSecurity *t_ServerSecurity = NULL ;
				HRESULT t_TempResult = CoGetCallContext ( IID_IUnknown , ( void ** ) & t_ServerSecurity ) ;
				if ( SUCCEEDED ( t_TempResult ) )
				{
					t_Result = CoImpersonateClient () ;
					if ( SUCCEEDED ( t_Result ) )
					{
						t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						CoRevertToSelf () ;
					}

					t_ServerSecurity->Release () ;
				}

				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IDENTIFY )
					{
						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_NoImpersonation ( 
						
							m_ProxyContainer , 
							a_ProxyIndex , 
							a_InterfaceIdentifier , 
							a_ServerInterface , 
							a_Proxy , 
							a_Revert
						) ;
					}
					else
					{
						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
						
							m_ProxyContainer , 
							a_ProxyIndex , 
							a_InterfaceIdentifier , 
							a_ServerInterface , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}

				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					a_Interface = a_ServerInterface ;
					a_IsProxy = FALSE ;
					t_Result = S_OK ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						a_IsProxy = TRUE ;

						a_Interface = ( IUnknown * ) a_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							a_Interface ,
							RPC_C_AUTHN_LEVEL_DEFAULT , 
							t_ImpersonationLevel
						) ;

						if ( FAILED ( t_Result ) )
						{
							HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

								m_ProxyContainer , 
								a_ProxyIndex , 
								a_Proxy , 
								a_Revert
							) ;
						}
					}
				}

				if ( FAILED ( t_Result ) && t_Result != WBEM_E_NOT_FOUND )
				{
					ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
				}
			}
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: End_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

			m_ProxyContainer , 
			a_ProxyIndex , 
			a_Proxy , 
			a_Revert
		) ;
	}

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalServiceHost:
		case e_Hosting_SharedNetworkServiceHost:
		{
		}
		break ;

		default:
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
		break ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Begin_Interface_Events (

	bool a_Identify ,
	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	if ( a_Identify )
	{
		DWORD t_AuthenticationLevel = 0 ;

		t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( 
			
			a_OldContext , 
			a_OldSecurity , 
			a_Impersonating , 
			& t_AuthenticationLevel 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
					
				m_ProxyContainer , 
				a_ProxyIndex , 
				a_InterfaceIdentifier , 
				a_ServerInterface , 
				a_Proxy , 
				a_Revert
			) ;

			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				a_Interface = a_ServerInterface ;
				a_IsProxy = FALSE ;
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					a_IsProxy = TRUE ;

					a_Interface = ( IUnknown * ) a_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						a_Interface ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( FAILED ( t_Result ) )
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

							m_ProxyContainer , 
							a_ProxyIndex , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}
			}

			if ( FAILED ( t_Result ) && t_Result != WBEM_E_NOT_FOUND )
			{
				ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
			}
		}
	}
	else
	{
		DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;

		IServerSecurity *t_ServerSecurity = NULL ;
		HRESULT t_TempResult = CoGetCallContext ( IID_IUnknown , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_Result = CoImpersonateClient () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				CoRevertToSelf () ;
			}

			t_ServerSecurity->Release () ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IDENTIFY )
			{
				t_Result = CoSwitchCallContext ( NULL , &a_OldContext ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						a_Impersonating = a_OldSecurity->IsImpersonating () ;
					}
				}

				a_Interface = a_ServerInterface ;
				a_IsProxy = FALSE ;
			}
			else
			{
				DWORD t_AuthenticationLevel = 0 ;

				t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( 
					
					a_OldContext , 
					a_OldSecurity , 
					a_Impersonating , 
					& t_AuthenticationLevel 
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
							
						m_ProxyContainer , 
						a_ProxyIndex , 
						a_InterfaceIdentifier , 
						a_ServerInterface , 
						a_Proxy , 
						a_Revert
					) ;

					if ( t_Result == WBEM_E_NOT_FOUND )
					{
						t_Result = S_OK ;
						a_Interface = a_ServerInterface ;
						a_IsProxy = FALSE ;
					}
					else
					{
						if ( SUCCEEDED ( t_Result ) )
						{
							a_IsProxy = TRUE ;

							a_Interface = ( IUnknown * ) a_Proxy ;

							// Set cloaking on the proxy
							// =========================

							DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

							t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

								a_Interface ,
								RPC_C_AUTHN_LEVEL_DEFAULT , 
								t_ImpersonationLevel
							) ;

							if ( FAILED ( t_Result ) )
							{
								HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

									m_ProxyContainer , 
									a_ProxyIndex , 
									a_Proxy , 
									a_Revert
								) ;
							}
						}
					}

					if ( FAILED ( t_Result ) && t_Result != WBEM_E_NOT_FOUND )
					{
						ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
					}
				}
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: End_Interface_Events (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

			m_ProxyContainer , 
			a_ProxyIndex , 
			a_Proxy , 
			a_Revert
		) ;
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Find ( 

			a_Sink ,
			t_Iterator
		) ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			ObjectSinkContainerElement *t_Element = t_Iterator.GetElement () ;

			UnLock () ;

			IWbemObjectSink *t_ObjectSink = NULL ;
			t_Result = t_Element->QueryInterface ( IID_IWbemObjectSink , ( void ** ) & t_ObjectSink ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_Impersonating ;
				IUnknown *t_OldContext ;
				IServerSecurity *t_OldSecurity ;
				BOOL t_IsProxy ;
				IWbemServices *t_Interface ;
				BOOL t_Revert ;
				IUnknown *t_Proxy ;

				t_Result = Begin_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Interface->CancelAsyncCall (

						t_ObjectSink
					) ;

					End_IWbemServices (

						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;
				}

				t_ObjectSink->Release () ;
			}

			IWbemShutdown *t_Shutdown = NULL ;
			HRESULT t_TempResult = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				t_TempResult = t_Shutdown->Shutdown ( 

					0 , 
					0 , 
					NULL 
				) ;

				t_Shutdown->Release () ;
			}

			t_Element->Release () ;
		}
		else
		{
			UnLock () ;

			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_GetObjectAsync (

	BOOL a_IsProxy ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
		if ( t_ObjectPath ) 
		{
			CInterceptor_IWbemSyncObjectSink_GetObjectAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_GetObjectAsync (

				m_Allocator ,
				a_Flags ,
				t_ObjectPath ,
				this ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				t_Dependant
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_GetObjectAsync () ;
							}

							Increment_ProviderOperation_GetObjectAsync () ;

							try	
							{
								t_Result = a_Service->GetObjectAsync (

 									t_ObjectPath ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_GetObjectAsync () ;
							}

							Increment_ProviderOperation_GetObjectAsync () ;

							if ( a_IsProxy )
							{
								t_Result = CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{
								try
								{
									t_Result = a_Service->GetObjectAsync (

 										t_ObjectPath ,
										a_Flags ,
										t_ContextCopy ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( FAILED ( t_Result ) )
					{
						HRESULT t_TempResult = SetStatus ( L"GetObjectAsync" , NULL , NULL , t_Result , t_Sink ) ;
					}
				}

				t_Sink->Release () ;
			}
			else
			{
				SysFreeString ( t_ObjectPath ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_HiPerfGetObjectAsync (

	IWbemHiPerfProvider *a_HighPerformanceProvider ,
 	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
    IWbemClassObject *t_Instance = NULL ;

	// Parse the path
	// ==============

	IWbemPath*	pPathParser = NULL;
	WCHAR*	pwszClassName = NULL;
	HRESULT t_Result = CoCreateInstance( CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER, IID_IWbemPath, (void**) &pPathParser );

	if ( SUCCEEDED( t_Result ) )
	{
		t_Result = pPathParser->SetText( WBEMPATH_CREATE_ACCEPT_ALL, a_ObjectPath );

		if ( SUCCEEDED( t_Result ) )
		{
			ULONG	uLength = 0;

			// Get the length of the name
			t_Result = pPathParser->GetClassName( &uLength, NULL );

			if ( SUCCEEDED( t_Result ) )
			{
				// Allocate memory and get it for real
				uLength++;
				pwszClassName = new WCHAR[uLength];

				if ( NULL != pwszClassName )
				{
					t_Result = pPathParser->GetClassName( &uLength, pwszClassName );
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY;
				}

			}	// IF Buffer too small

		}	// IF SetText

	}	// IF CoCreateInstance
	
	// Cleanup the parser and any allocated memory
	CReleaseMe	rmPP( pPathParser );
	CVectorDeleteMe<WCHAR>	vdm( pwszClassName );

	if ( FAILED( t_Result ) )
	{
		return t_Result;
	}

	// Get the class
	// =============

	IWbemClassObject* pClass = NULL;

	// Must use a BSTR in case the call gets marshaled
	BSTR	bstrClass = SysAllocString( pwszClassName );
	if ( NULL == bstrClass )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	CSysFreeMe	sfm( bstrClass );

	// Note that WBEM_FLAG_USE_AMENDED_QUALIFIERS is a valid flag
	t_Result = m_CoreStub->GetObject( bstrClass, 0L, NULL, &pClass, NULL);
	CReleaseMe	rmClass( pClass );

	if(FAILED(t_Result))
	{
		return WBEM_E_INVALID_CLASS;
	}

	_IWmiObject*	pWmiClass = NULL;
	t_Result = pClass->QueryInterface( IID__IWmiObject, (void**) &pWmiClass );
	CReleaseMe		rmObj( pWmiClass );

	// Get a Keyed instance and continue
	if ( SUCCEEDED( t_Result ) )
	{
		_IWmiObject*	pTempInst = NULL;

		t_Result = pWmiClass->SpawnKeyedInstance( 0L, a_ObjectPath, &pTempInst );
		CReleaseMe	rmTempInst( pTempInst );

		if ( SUCCEEDED( t_Result ) )
		{
			t_Result = pTempInst->QueryInterface( IID_IWbemClassObject, (void**) &t_Instance );
		}
	}
	
	CReleaseMe	rmInst( t_Instance );

    if ( SUCCEEDED ( t_Result ) )
    {
		try
		{
			t_Result = a_HighPerformanceProvider->GetObjects (

				m_CoreStub , 
				1 ,
				( IWbemObjectAccess ** ) & t_Instance , 
				0 ,
				a_Context
			) ;
		}
		catch ( ... )
		{
			t_Result = WBEM_E_PROVIDER_FAILURE ;
		}

		CoRevertToSelf () ;

        if ( SUCCEEDED ( t_Result ) && t_Instance )
        {
            a_Sink->Indicate ( 1 , & t_Instance ) ;
        }
        else
		{
			if ( 
				SUCCEEDED ( t_Result ) ||
				t_Result == WBEM_E_PROVIDER_NOT_CAPABLE ||
				t_Result == WBEM_E_METHOD_NOT_IMPLEMENTED ||
				t_Result == E_NOTIMPL ||
				t_Result == WBEM_E_NOT_SUPPORTED
			)
			{

				IWbemRefresher *t_Refresher = NULL ;

				try
				{
					t_Result = a_HighPerformanceProvider->CreateRefresher (
		
						m_CoreStub , 
						0 , 
						& t_Refresher
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;

				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemObjectAccess *t_Object = NULL ;
	                long t_Id = 0 ;

					try
					{
						t_Result = a_HighPerformanceProvider->CreateRefreshableObject (

							m_CoreStub , 
							( IWbemObjectAccess * ) t_Instance ,
							t_Refresher , 
							0, 
							a_Context , 
							& t_Object, 
							& t_Id
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}

					CoRevertToSelf () ;

					if ( SUCCEEDED ( t_Result ) )
					{
						try
						{
							t_Result = t_Refresher->Refresh ( 0 ) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;

						if ( SUCCEEDED( t_Result ) )
						{
							a_Sink->Indicate ( 1, ( IWbemClassObject ** ) & t_Object );
						}

						t_Object->Release () ;
					}

					t_Refresher->Release () ;
				}
			}
		}
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsGet () || m_Registration->GetClassProviderRegistration ().SupportsGet () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_GetObjectAsync ( 

					t_IsProxy ,
					a_ObjectPath ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}
	else
	{
		if ( m_Provider_IWbemHiPerfProvider )
		{
			t_Result = Helper_HiPerfGetObjectAsync (

				m_Provider_IWbemHiPerfProvider ,
 				a_ObjectPath ,
				a_Flags ,
				a_Context ,
				a_Sink
			) ;

			// Send back the final status
			a_Sink->SetStatus( WBEM_STATUS_COMPLETE, t_Result, NULL, NULL );
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_PutClassAsync (

	BOOL a_IsProxy ,
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CInterceptor_IWbemSyncObjectSink_PutClassAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_PutClassAsync (

			m_Allocator ,
			a_Flags ,
			a_Object ,
			this ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			t_Dependant
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( ProviderSubSystem_Globals :: GetSharedCounters () )
						{
							ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_PutClassAsync () ;
						}

						Increment_ProviderOperation_PutClassAsync () ;

						try
						{
							t_Result = a_Service->PutClassAsync (

 								a_Object ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_PutClassAsync () ;
							}

							Increment_ProviderOperation_PutClassAsync () ;

							try
							{
								t_Result = a_Service->PutClassAsync (

 									a_Object ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"PutClassAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsPut () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_PutClassAsync ( 

					t_IsProxy ,
					a_Object ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_DeleteClassAsync (

	BOOL a_IsProxy ,
	const BSTR a_Class , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		BSTR t_Class = SysAllocString ( a_Class ) ;
		if ( t_Class ) 
		{
			CInterceptor_IWbemSyncObjectSink_DeleteClassAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_DeleteClassAsync (

				m_Allocator ,
				a_Flags ,
				t_Class ,
				this ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				t_Dependant
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_DeleteClassAsync () ;
							}

							Increment_ProviderOperation_DeleteClassAsync () ;

							try
							{
								t_Result = a_Service->DeleteClassAsync (

 									t_Class ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							if ( a_IsProxy )
							{
								t_Result = CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{
								if ( ProviderSubSystem_Globals :: GetSharedCounters () )
								{
									ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_DeleteClassAsync () ;
								}

								Increment_ProviderOperation_DeleteClassAsync () ;

								try
								{
									t_Result = a_Service->DeleteClassAsync (

 										t_Class ,
										a_Flags ,
										t_ContextCopy ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( FAILED ( t_Result ) )
					{
						HRESULT t_TempResult = SetStatus ( L"DeleteClassAsync" , NULL , NULL , t_Result , t_Sink ) ;
					}
				}

				t_Sink->Release () ;
			}
			else
			{
				SysFreeString ( t_Class ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: DeleteClassAsync ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsDelete () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_DeleteClassAsync ( 

					t_IsProxy ,
					a_Class ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_CreateClassEnumAsync (

	BOOL a_IsProxy ,
	const BSTR a_SuperClass , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		BSTR t_SuperClass = SysAllocString ( a_SuperClass ) ;
		if ( t_SuperClass ) 
		{
			CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync (

				m_Allocator ,
				a_Flags ,
				t_SuperClass ,
				this ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				t_Dependant
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CreateClassEnumAsync () ;
							}

							Increment_ProviderOperation_CreateClassEnumAsync () ;

							try
							{
								t_Result = a_Service->CreateClassEnumAsync (

 									t_SuperClass ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							if ( a_IsProxy )
							{
								t_Result = CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{
								if ( ProviderSubSystem_Globals :: GetSharedCounters () )
								{
									ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CreateClassEnumAsync () ;
								}

								Increment_ProviderOperation_CreateClassEnumAsync () ;

								try
								{
									t_Result = a_Service->CreateClassEnumAsync (

 										t_SuperClass ,
										a_Flags ,
										t_ContextCopy ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( FAILED ( t_Result ) )
					{
						HRESULT t_TempResult = SetStatus ( L"CreateClassEnumAsync" , NULL , NULL , t_Result , t_Sink ) ;
					}
				}

				t_Sink->Release () ;
			}
			else
			{
				SysFreeString ( t_SuperClass ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: CreateClassEnumAsync ( 
		
	const BSTR a_SuperClass , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsEnumeration () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_CreateClassEnumAsync ( 

					t_IsProxy ,
					a_SuperClass ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: PutInstance (

    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_PutInstanceAsync (

	BOOL a_IsProxy ,
	IWbemClassObject *a_Instance ,
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CInterceptor_IWbemSyncObjectSink_PutInstanceAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_PutInstanceAsync (

			m_Allocator ,
			a_Flags ,
			a_Instance ,
			this ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			t_Dependant
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) ) 
					{
						if ( ProviderSubSystem_Globals :: GetSharedCounters () )
						{
							ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_PutInstanceAsync () ;
						}

						Increment_ProviderOperation_PutInstanceAsync () ;

						try
						{
							t_Result = a_Service->PutInstanceAsync (

 								a_Instance ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_PutInstanceAsync () ;
							}

							Increment_ProviderOperation_PutInstanceAsync () ;

							try
							{
								t_Result = a_Service->PutInstanceAsync (

 									a_Instance ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"PutInstanceAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsPut () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_PutInstanceAsync ( 

					t_IsProxy ,
					a_Instance ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: DeleteInstance ( 

	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_DeleteInstanceAsync (

	BOOL a_IsProxy ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
		if ( t_ObjectPath ) 
		{
			CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync (

				m_Allocator ,
				a_Flags ,
				t_ObjectPath ,
				this ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				t_Dependant
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_DeleteInstanceAsync () ;
							}

							Increment_ProviderOperation_DeleteInstanceAsync () ;

							try
							{
								t_Result = a_Service->DeleteInstanceAsync (

 									t_ObjectPath ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							if ( a_IsProxy )
							{
								t_Result = CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{
								if ( ProviderSubSystem_Globals :: GetSharedCounters () )
								{
									ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_DeleteInstanceAsync () ;
								}

								Increment_ProviderOperation_DeleteInstanceAsync () ;

								try
								{
									t_Result = a_Service->DeleteInstanceAsync (

 										t_ObjectPath ,
										a_Flags ,
										t_ContextCopy ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( FAILED ( t_Result ) )
					{
						HRESULT t_TempResult = SetStatus ( L"DeleteInstanceAsync" , NULL , NULL , t_Result , t_Sink ) ;
					}
				}

				t_Sink->Release () ;
			}
			else
			{
				SysFreeString ( t_ObjectPath ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: DeleteInstanceAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsDelete () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_DeleteInstanceAsync ( 

					t_IsProxy ,
					a_ObjectPath ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: CreateInstanceEnum ( 

	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_CreateInstanceEnumAsync (

	BOOL a_IsProxy ,
 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		BSTR t_Class = SysAllocString ( a_Class ) ;
		if ( t_Class ) 
		{
			CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync (

				m_Allocator ,
				a_Flags ,
				t_Class ,
				this ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				t_Dependant
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CreateInstanceEnumAsync () ;
							}

							Increment_ProviderOperation_CreateInstanceEnumAsync () ;

							try
							{
								t_Result = a_Service->CreateInstanceEnumAsync (

 									t_Class ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;

#if DBG
								CheckThreadToken () ;
#endif

							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							if ( a_IsProxy )
							{
								t_Result = CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

								if ( ProviderSubSystem_Globals :: GetSharedCounters () )
								{
									ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CreateInstanceEnumAsync () ;
								}

								Increment_ProviderOperation_CreateInstanceEnumAsync () ;

								try
								{
									t_Result = a_Service->CreateInstanceEnumAsync (

 										t_Class ,
										a_Flags ,
										t_ContextCopy ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"CreateInstanceEnumAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				SysFreeString ( t_Class ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_QueryInstancesAsync (

	IWbemHiPerfProvider *a_PerformanceProvider ,
 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
	HRESULT t_Result = S_OK ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		CInterceptor_IWbemSyncObjectSink *t_Sink = new CInterceptor_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			t_Dependant
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					BSTR t_Class = SysAllocString ( a_Class ) ;
					if ( t_Class ) 
					{
						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( ProviderSubSystem_Globals :: GetSharedCounters () )
						{
							ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_QueryInstances () ;
						}

						Increment_ProviderOperation_QueryInstances () ;

						try
						{
							t_Result = a_PerformanceProvider->QueryInstances (

								m_CoreStub ,
								a_Class, 
								a_Flags, 
								a_Context, 
								t_Sink
							) ;
						}
						catch ( ... ) 
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_QueryInstances () ;
							}

							Increment_ProviderOperation_QueryInstances () ;

							try
							{
								a_PerformanceProvider->QueryInstances (

									m_CoreStub,
									a_Class, 
									a_Flags, 
									a_Context, 
									t_Sink
								) ;
							}
							catch ( ... ) 
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}

						SysFreeString ( t_Class ) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_CreateInstanceEnumAsync ( 

					t_IsProxy ,
					a_Class ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}
	else
	{
		if ( m_Provider_IWbemHiPerfProvider )
		{
			t_Result = Helper_QueryInstancesAsync ( 

				m_Provider_IWbemHiPerfProvider ,
				a_Class ,
				a_Flags , 
				a_Context ,
				a_Sink
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ExecQuery ( 

	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_ExecQueryAsync (

	BOOL a_IsProxy ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Context )
		{
			t_Result = a_Context->Clone ( & t_ContextCopy ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = S_OK ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;
		if ( ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_UnarySelect ) ||  ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_V1ProviderDefined ) ) 
		{
			BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
			BSTR t_Query = SysAllocString ( a_Query ) ;

			if ( t_QueryLanguage && t_Query ) 
			{
				CInterceptor_IWbemSyncObjectSink_ExecQueryAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_ExecQueryAsync (

					m_Allocator ,
					a_Flags ,
					t_QueryLanguage ,
					t_Query ,
					this ,
					a_Sink , 
					( IWbemServices * ) this , 
					( CWbemGlobal_IWmiObjectSinkController * ) this ,
					t_Dependant
				) ;

				if ( t_Sink )
				{
					t_Sink->AddRef () ;

					t_Result = t_Sink->SinkInitialize () ;
					if ( SUCCEEDED ( t_Result ) )
					{
						CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

						Lock () ;

						WmiStatusCode t_StatusCode = Insert ( 

							*t_Sink ,
							t_Iterator
						) ;

						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							UnLock () ;

							if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
							{
								a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
							}

							if ( a_IsProxy )
							{
								t_Result = CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								if ( ProviderSubSystem_Globals :: GetSharedCounters () )
								{
									ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_ExecQueryAsync () ;
								}

								Increment_ProviderOperation_ExecQueryAsync () ;

								try
								{
									t_Result = a_Service->ExecQueryAsync (

										t_QueryLanguage ,
										t_Query, 
										a_Flags ,
										t_ContextCopy ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}

							if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
							{
								a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

								if ( a_IsProxy )
								{
									t_Result = CoImpersonateClient () ;
								}
								else
								{
									t_Result = S_OK ;
								}

								if ( SUCCEEDED ( t_Result ) ) 
								{
									if ( ProviderSubSystem_Globals :: GetSharedCounters () )
									{
										ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_ExecQueryAsync () ;
									}

									Increment_ProviderOperation_ExecQueryAsync () ;

									try
									{
										t_Result = a_Service->ExecQueryAsync (

											t_QueryLanguage ,
											t_Query, 
											a_Flags ,
											t_ContextCopy ,
											t_Sink 
										) ;
									}
									catch ( ... )
									{
										t_Result = WBEM_E_PROVIDER_FAILURE ;
									}

									CoRevertToSelf () ;
								}
								else
								{
									t_Result = WBEM_E_ACCESS_DENIED ;
								}
							}
						}
						else
						{
							UnLock () ;

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

						if ( FAILED ( t_Result ) )
						{
							HRESULT t_TempResult = SetStatus ( L"ExecQueryAsync" , NULL , NULL , t_Result , t_Sink ) ;
						}
					}

					t_Sink->Release () ;
				}
				else
				{
					SysFreeString ( t_Query ) ;
					SysFreeString ( t_QueryLanguage ) ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else if ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () )
		{
			IWbemQuery *t_QueryFilter = NULL ;
			t_Result = ProviderSubSystem_Common_Globals :: CreateInstance	(

				CLSID_WbemQuery ,
				NULL ,
				CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
				IID_IWbemQuery ,
				( void ** ) & t_QueryFilter
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_QueryFilter->Parse ( 

					a_QueryLanguage ,
					a_Query , 
					0 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					SWbemRpnEncodedQuery *t_Expression = NULL ;

					t_Result = t_QueryFilter->GetAnalysis (

						WMIQ_ANALYSIS_RPN_SEQUENCE ,
						0 ,
						( void ** ) & t_Expression
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_Expression->m_uFromTargetType == WMIQ_RPN_FROM_UNARY )
						{
							BSTR t_Class = SysAllocString ( t_Expression->m_ppszFromList [ 0 ] ) ;
							if ( t_Class )
							{
								CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync (

									m_Allocator ,
									a_Flags ,
									t_Class ,
									this ,
									a_Sink , 
									( IWbemServices * ) this , 
									( CWbemGlobal_IWmiObjectSinkController * ) this ,
									t_Dependant
								) ;

								if ( t_Sink )
								{
									t_Sink->AddRef () ;

									t_Result = t_Sink->SinkInitialize () ;
									if ( SUCCEEDED ( t_Result ) )
									{
										a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , 0 , NULL , NULL ) ;

										CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

										Lock () ;

										WmiStatusCode t_StatusCode = Insert ( 

											*t_Sink ,
											t_Iterator
										) ;

										if ( t_StatusCode == e_StatusCode_Success ) 
										{
											UnLock () ;

											if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
											{
												a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
											}

											if ( a_IsProxy )
											{
												t_Result = CoImpersonateClient () ;
											}
											else
											{
												t_Result = S_OK ;
											}

											if ( SUCCEEDED ( t_Result ) )
											{
												a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , 0 , NULL , NULL ) ;

												if ( ProviderSubSystem_Globals :: GetSharedCounters () )
												{
													ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CreateInstanceEnumAsync () ;
												}

												Increment_ProviderOperation_CreateInstanceEnumAsync () ;

												try
												{
													t_Result = a_Service->CreateInstanceEnumAsync (

 														t_Class ,
														a_Flags ,
														t_ContextCopy ,
														t_Sink 
													) ;
												}
												catch ( ... )
												{
													t_Result = WBEM_E_PROVIDER_FAILURE ;
												}
				
												CoRevertToSelf () ;
											}
											else
											{
												t_Result = WBEM_E_ACCESS_DENIED ;
											}

											if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
											{
												a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

												if ( a_IsProxy )
												{
													t_Result = CoImpersonateClient () ;
												}
												else
												{
													t_Result = S_OK ;
												}

												if ( SUCCEEDED ( t_Result ) ) 
												{
													if ( ProviderSubSystem_Globals :: GetSharedCounters () )
													{
														ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CreateInstanceEnumAsync () ;
													}

													Increment_ProviderOperation_CreateInstanceEnumAsync () ;

													try
													{
														t_Result = a_Service->CreateInstanceEnumAsync (

 															t_Class ,
															a_Flags ,
															t_ContextCopy ,
															t_Sink 
														) ;
													}
													catch ( ... )
													{
														t_Result = WBEM_E_PROVIDER_FAILURE ;
													}
					
													CoRevertToSelf () ;
												}
												else
												{
													t_Result = WBEM_E_ACCESS_DENIED ;
												}
											}
										}
										else
										{
											UnLock () ;

											t_Result = WBEM_E_OUT_OF_MEMORY ;
										}
									}

									if ( FAILED ( t_Result ) )
									{
										HRESULT t_TempResult = SetStatus ( L"CreateInstanceEnumAsync" , NULL , NULL , t_Result , t_Sink ) ;
									}

                                    t_Sink->Release () ;
								}
								else
								{
									SysFreeString ( t_Class ) ;

									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = WBEM_E_NOT_SUPPORTED ;
						}

						t_QueryFilter->FreeMemory ( t_Expression ) ;
					}
					else
					{
						t_Result = WBEM_E_UNEXPECTED ;
					}
				}
				else
				{
					t_Result = WBEM_E_NOT_SUPPORTED ;
				}

				t_QueryFilter->Release () ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_SUPPORTED ;
		}
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_UnarySelect ) || ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_V1ProviderDefined ) || ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () ) )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_ExecQueryAsync ( 

					t_IsProxy ,
					a_QueryLanguage ,
					a_Query, 
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}
	else
	{
		if ( m_Provider_IWbemHiPerfProvider )
		{
			IWbemQuery *t_QueryFilter = NULL ;
			t_Result = ProviderSubSystem_Common_Globals :: CreateInstance	(

				CLSID_WbemQuery ,
				NULL ,
				CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
				IID_IWbemQuery ,
				( void ** ) & t_QueryFilter
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_QueryFilter->Parse ( 

					a_QueryLanguage ,
					a_Query , 
					0 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					SWbemRpnEncodedQuery *t_Expression = NULL ;

					t_Result = t_QueryFilter->GetAnalysis (

						WMIQ_ANALYSIS_RPN_SEQUENCE ,
						0 ,
						( void ** ) & t_Expression
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_Expression->m_uFromTargetType == WMIQ_RPN_FROM_UNARY )
						{
							BSTR t_Class = SysAllocString ( t_Expression->m_ppszFromList [ 0 ] ) ;
							if ( t_Class )
							{
								a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , 0 , NULL , NULL ) ;

								t_Result = Helper_QueryInstancesAsync ( 

									m_Provider_IWbemHiPerfProvider ,
									t_Class ,
									a_Flags , 
									a_Context ,
									a_Sink
								) ;

								SysFreeString ( t_Class ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = WBEM_E_NOT_SUPPORTED ;
						}

						t_QueryFilter->FreeMemory ( t_Expression ) ;
					}
					else
					{
						t_Result = WBEM_E_UNEXPECTED ;
					}
				}
				else
				{
					t_Result = WBEM_E_NOT_SUPPORTED ;
				}

				t_QueryFilter->Release () ;
			}
		}
		else
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemSyncProvider :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ExecMethod (

	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_ExecMethodAsync (

	BOOL a_IsProxy ,
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
		BSTR t_MethodName = SysAllocString ( a_MethodName ) ;
		if ( t_ObjectPath && t_MethodName ) 
		{
			CInterceptor_IWbemSyncObjectSink_ExecMethodAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_ExecMethodAsync (

				m_Allocator ,
				a_Flags ,
				t_ObjectPath ,
				t_MethodName ,
				a_InParams ,
				this ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				t_Dependant
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_ExecMethodAsync () ;
							}

							Increment_ProviderOperation_ExecMethodAsync () ;

							try
							{
								t_Result = a_Service->ExecMethodAsync (

 									t_ObjectPath ,
									t_MethodName ,
									a_Flags ,
									t_ContextCopy ,
									a_InParams ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							if ( a_IsProxy )
							{
								t_Result = CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{
								if ( ProviderSubSystem_Globals :: GetSharedCounters () )
								{
									ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_ExecMethodAsync () ;
								}

								Increment_ProviderOperation_ExecMethodAsync () ;

								try
								{
									t_Result = a_Service->ExecMethodAsync (

 										t_ObjectPath ,
										t_MethodName ,
										a_Flags ,
										t_ContextCopy ,
										a_InParams ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( FAILED ( t_Result ) )
					{
						HRESULT t_TempResult = SetStatus ( L"ExecMethodAsync" , NULL , NULL , t_Result , t_Sink ) ;
					}
				}

				t_Sink->Release () ;
			}
			else
			{
				SysFreeString ( t_ObjectPath ) ;
				SysFreeString ( t_MethodName ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ExecMethodAsync ( 
		
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetMethodProviderRegistration ().SupportsMethods () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_ExecMethodAsync ( 

					t_IsProxy ,
					a_ObjectPath ,
					a_MethodName ,
					a_Flags ,
					a_Context ,
					a_InParams ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: GetProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		if ( m_Registration->GetPropertyProviderRegistration ().SupportsGet () )
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_GetProperty () ;
			}

			Increment_ProviderOperation_GetProperty () ;

			HRESULT t_Result = S_OK ;

			try
			{
				t_Result = m_Provider_IWbemPropertyProvider->GetProperty ( 

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;

				CoRevertToSelf () ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;

				CoRevertToSelf () ;
			}

			return t_Result ;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: PutProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		if ( m_Registration->GetPropertyProviderRegistration ().SupportsPut () )
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_PutProperty () ;
			}

			Increment_ProviderOperation_PutProperty () ;

			HRESULT t_Result = S_OK ;

			try
			{
				t_Result = m_Provider_IWbemPropertyProvider->PutProperty ( 

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;

				CoRevertToSelf () ;

				return t_Result ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;

				CoRevertToSelf () ;
			}

			return t_Result ;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	return InternalEx_ProvideEvents (

		false ,
		a_Sink ,
		a_Flags 
	) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	return InternalEx_NewQuery (

		false ,
		a_Id ,
		a_QueryLanguage ,
		a_Query
	) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: CancelQuery (

	unsigned long a_Id
)
{
	return InternalEx_CancelQuery (

		false ,
		a_Id
	) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	return InternalEx_AccessCheck (

		false ,
		a_QueryLanguage ,
		a_Query ,
		a_SidLength ,
		a_Sid
	) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	return InternalEx_FindConsumer (

		false ,
		a_LogicalConsumer ,
		a_Consumer
	) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	return InternalEx_ValidateSubscription (

		false ,
		a_LogicalConsumer
	) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	return InternalEx_IndicateToConsumer (

		false ,
		a_LogicalConsumer ,
		a_ObjectCount ,
		a_Objects
	) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: InternalEx_ProvideEvents (

	bool a_Identify ,
	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	if ( m_Provider_IWbemEventProvider )
	{
		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ProvideEvents_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Namespace ,
			m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_User ,
			m_Locale ,
			m_TransactionIdentifier ,
			a_Flags
		) ;

		IUnknown *t_ServerInterface = m_Provider_IWbemEventProvider ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProvider ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProvider ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		HRESULT t_Result = Begin_Interface_Events (

			a_Identify ,
			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_ProvideEvents () ;
			}

			Increment_ProviderOperation_ProvideEvents () ;

			try
			{
				t_Result = ( ( IWbemEventProvider * ) t_Interface )->ProvideEvents (

					a_Sink ,
					a_Flags 
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			End_Interface_Events (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ProvideEvents_Post ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Namespace ,
			m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_User ,
			m_Locale ,
			m_TransactionIdentifier ,
			a_Flags ,
			t_Result 
		) ;

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: InternalEx_NewQuery (

	bool a_Identify ,
	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_NewQuery_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Namespace ,
			m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_User ,
			m_Locale ,
			m_TransactionIdentifier ,
			a_Id ,
			a_QueryLanguage ,
			a_Query 
		) ;

		IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderQuerySink ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProviderQuerySink ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderQuerySink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		HRESULT t_Result = Begin_Interface_Events (

			a_Identify ,
			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_NewQuery () ;
			}

			Increment_ProviderOperation_NewQuery () ;

			try
			{
				t_Result = ( ( IWbemEventProviderQuerySink * ) t_Interface )->NewQuery (

					a_Id ,
					a_QueryLanguage ,
					a_Query
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			End_Interface_Events (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_NewQuery_Post ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Namespace ,
			m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_User ,
			m_Locale ,
			m_TransactionIdentifier ,
			a_Id ,
			a_QueryLanguage ,
			a_Query ,
			t_Result 
		) ;

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: InternalEx_CancelQuery (

	bool a_Identify ,
	unsigned long a_Id
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_CancelQuery_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Namespace ,
			m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_User ,
			m_Locale ,
			m_TransactionIdentifier ,
			a_Id
		) ;

		IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderQuerySink ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProviderQuerySink ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderQuerySink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		HRESULT t_Result = Begin_Interface_Events (

			a_Identify ,
			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CancelQuery () ;
			}

			Increment_ProviderOperation_CancelQuery () ;

			try
			{
				t_Result = ( ( IWbemEventProviderQuerySink * ) t_Interface )->CancelQuery (

					a_Id
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			End_Interface_Events (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_CancelQuery_Post ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Namespace ,
			m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_User ,
			m_Locale ,
			m_TransactionIdentifier ,
			a_Id ,
			t_Result 
		) ;

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: InternalEx_AccessCheck (

	bool a_Identify ,
	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	if ( m_Provider_IWbemEventProviderSecurity )
	{
		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_AccessCheck_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Namespace ,
			m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_User ,
			m_Locale ,
			m_TransactionIdentifier ,
			a_QueryLanguage ,
			a_Query ,
			a_Sid,
 			a_SidLength 
		) ;

		IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderSecurity ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProviderSecurity ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderSecurity ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		HRESULT t_Result ;
		
		if ( a_Sid )
		{
			t_Result = Begin_Interface_Events (

				a_Identify ,
				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
		else
		{
			t_Result = Begin_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_AccessCheck () ;
			}

			Increment_ProviderOperation_AccessCheck () ;

			try
			{
				t_Result = ( ( IWbemEventProviderSecurity * ) t_Interface )->AccessCheck (

					a_QueryLanguage ,
					a_Query ,
					a_SidLength ,
					a_Sid
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			if ( a_Sid )
			{
				End_Interface_Events (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
			else
			{
				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_AccessCheck_Post ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Namespace ,
			m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_User ,
			m_Locale ,
			m_TransactionIdentifier ,
			a_QueryLanguage ,
			a_Query ,
			a_Sid ,
			a_SidLength
		) ;

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::SetRegistrationObject (

	long a_Flags ,
	IWbemClassObject *a_ProviderRegistration
)
{
	if ( m_Provider_IWbemProviderIdentity )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemProviderIdentity ;
		REFIID t_InterfaceIdentifier = IID_IWbemProviderIdentity ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemProviderIdentity ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		HRESULT t_Result = Begin_Interface_Events (

			false ,
			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_SetRegistrationObject () ;
			}

			Increment_ProviderOperation_SetRegistrationObject () ;

			try
			{
				t_Result = ( ( IWbemProviderIdentity * ) t_Interface )->SetRegistrationObject (

					a_Flags ,
					a_ProviderRegistration 
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			End_Interface_Events (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: InternalEx_FindConsumer (

	bool a_Identify ,
	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	if ( m_Provider_IWbemEventConsumerProvider )
	{
		IWbemUnboundObjectSink *t_Consumer = NULL ;

		IUnknown *t_ServerInterface = m_Provider_IWbemEventConsumerProvider ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventConsumerProvider ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventConsumerProvider ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		HRESULT t_Result = Begin_Interface_Events (

			a_Identify ,
			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_FindConsumer () ;
			}

			Increment_ProviderOperation_FindConsumer () ;

			try
			{
				t_Result = ( ( IWbemEventConsumerProvider * ) t_Interface )->FindConsumer (

					a_LogicalConsumer ,
					& t_Consumer
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			End_Interface_Events (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( a_Consumer )
			{
				CInterceptor_IWbemSyncUnboundObjectSink *t_UnboundObjectSink = new CInterceptor_IWbemSyncUnboundObjectSink (

						m_Allocator ,
						t_Consumer , 
						this ,
						*m_Registration
				) ;

				if ( t_UnboundObjectSink )
				{
					t_UnboundObjectSink->AddRef () ;

					t_Result = t_UnboundObjectSink->Initialize () ;
					if ( SUCCEEDED ( t_Result ) )
					{
						CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

						Lock () ;

						WmiStatusCode t_StatusCode = Insert ( 

							*t_UnboundObjectSink ,
							t_Iterator
						) ;

						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							UnLock () ;

							*a_Consumer = t_UnboundObjectSink ;

							t_UnboundObjectSink->AddRef () ;
						}
						else
						{
							UnLock () ;

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_UnboundObjectSink->Release () ;
				}
			}
		}

		if ( t_Consumer )
		{
			t_Consumer->Release () ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: InternalEx_ValidateSubscription (

	bool a_Identify ,
	IWbemClassObject *a_LogicalConsumer
)
{
	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventConsumerProviderEx ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventConsumerProviderEx ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventConsumerProviderEx ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		HRESULT t_Result = Begin_Interface_Events (

			a_Identify ,
			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_ValidateSubscription () ;
			}

			Increment_ProviderOperation_ValidateSubscription () ;

			try
			{
				t_Result = ( ( IWbemEventConsumerProviderEx * ) t_Interface )->ValidateSubscription (

					a_LogicalConsumer
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			End_Interface_Events (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: InternalEx_IndicateToConsumer (

	bool a_Identify ,
	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemUnboundObjectSink ;
		REFIID t_InterfaceIdentifier = IID_IWbemUnboundObjectSink ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemUnboundObjectSink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		HRESULT t_Result = Begin_Interface_Events (

			a_Identify ,
			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			try
			{
				t_Result = ( ( IWbemUnboundObjectSink * ) t_Interface )->IndicateToConsumer (

					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			End_Interface_Events (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::QueryInstances (

	IWbemServices *a_Namespace ,
	WCHAR *a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
)
{
	if ( m_Provider_IWbemHiPerfProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_QueryInstances () ;
			}

			Increment_ProviderOperation_QueryInstances () ;

			try
			{
				t_Result = m_Provider_IWbemHiPerfProvider->QueryInstances (

					a_Namespace ,
					a_Class ,
					a_Flags ,
					a_Context ,
					a_Sink
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			CoRevertToSelf () ;

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

			return t_Result;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::CreateRefresher (

	IWbemServices *a_Namespace ,
	long a_Flags ,
	IWbemRefresher **a_Refresher
)
{
	if ( m_Provider_IWbemHiPerfProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CreateRefresher () ;
			}

			Increment_ProviderOperation_CreateRefresher () ;

			try
			{
				t_Result = m_Provider_IWbemHiPerfProvider->CreateRefresher (

					a_Namespace ,
					a_Flags ,
					a_Refresher
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			CoRevertToSelf () ;

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

			return t_Result;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
} 

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::CreateRefreshableObject (

	IWbemServices *a_Namespace ,
	IWbemObjectAccess *a_Template ,
	IWbemRefresher *a_Refresher ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectAccess **a_Refreshable ,
	long *a_Id
)
{
	if ( m_Provider_IWbemHiPerfProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CreateRefreshableObject () ;
			}

			Increment_ProviderOperation_CreateRefreshableObject () ;

			try
			{
				t_Result = m_Provider_IWbemHiPerfProvider->CreateRefreshableObject (

					a_Namespace ,
					a_Template ,
					a_Refresher ,
					a_Flags ,
					a_Context ,
					a_Refreshable ,
					a_Id
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			CoRevertToSelf () ;

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

			return t_Result;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::StopRefreshing (

	IWbemRefresher *a_Refresher ,
	long a_Id ,
	long a_Flags
)
{
	if ( m_Provider_IWbemHiPerfProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_StopRefreshing () ;
			}

			Increment_ProviderOperation_StopRefreshing () ;

			try
			{
				t_Result = m_Provider_IWbemHiPerfProvider->StopRefreshing (

					a_Refresher ,
					a_Id ,
					a_Flags
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			CoRevertToSelf () ;

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

			return t_Result;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::CreateRefreshableEnum (

	IWbemServices *a_Namespace ,
	LPCWSTR a_Class ,
	IWbemRefresher *a_Refresher ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemHiPerfEnum *a_HiPerfEnum ,
	long *a_Id
)
{
	if ( m_Provider_IWbemHiPerfProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CreateRefreshableEnum () ;
			}

			Increment_ProviderOperation_CreateRefreshableEnum () ;

			try
			{
				t_Result = m_Provider_IWbemHiPerfProvider->CreateRefreshableEnum (

					a_Namespace ,
					a_Class ,
					a_Refresher ,
					a_Flags ,
					a_Context ,
					a_HiPerfEnum ,
					a_Id
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			CoRevertToSelf () ;

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

			return t_Result;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::GetObjects (

	IWbemServices *a_Namespace ,
	long a_ObjectCount ,
	IWbemObjectAccess **a_Objects ,
	long a_Flags ,
	IWbemContext *a_Context
)
{
	if ( m_Provider_IWbemHiPerfProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_GetObjects () ;
			}

			Increment_ProviderOperation_GetObjects () ;

			try
			{
				t_Result = m_Provider_IWbemHiPerfProvider->GetObjects (

					a_Namespace ,
					a_ObjectCount ,
					a_Objects ,
					a_Flags ,
					a_Context
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			CoRevertToSelf () ;

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

			return t_Result;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Get (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	if ( wbem_wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
	{
		IWbemClassObject *t_Object = NULL ;

		BSTR t_Class = SysAllocString ( a_Class ) ;
		if ( t_Class ) 
		{
			t_Result = a_Service->GetObject (

				t_Class ,
				0 ,
				a_Context ,
				& t_Object ,
				NULL 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemClassObject *t_Instance = NULL ;
				t_Result = t_Object->SpawnInstance ( 

					0 , 
					& t_Instance 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					_IWmiObject *t_FastObject = NULL ;
					t_Instance->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastObject ) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_GetObjectAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_GetObjectAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_PutClassAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_PutClassAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_DeleteClassAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_DeleteClassAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateClassEnumAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_CreateClassEnumAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_PutInstanceAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_PutInstanceAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateInstanceEnumAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_CreateInstanceEnumAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ExecQueryAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_ExecQueryAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ExecNotificationQueryAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_ExecNotificationQueryAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_DeleteInstanceAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_DeleteInstanceAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ExecMethodAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_ExecMethodAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_QueryInstances" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_QueryInstances
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateRefresher" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_CreateRefresher
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateRefreshableObject" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_CreateRefreshableObject
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_StopRefreshing" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_StopRefreshing
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateRefreshableEnum" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_CreateRefreshableEnum
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_GetObjects" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_GetObjects
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_GetProperty" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_GetProperty
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_PutProperty" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_PutProperty
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ProvideEvents" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_ProvideEvents
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_NewQuery" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_NewQuery
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CancelQuery" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_CancelQuery
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_AccessCheck" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_AccessCheck
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_SetRegistrationObject" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_SetRegistrationObject
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_FindConsumer" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_FindConsumer
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ValidateSubscription" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_ValidateSubscription
					) ;

					t_FastObject->Release () ;

					VARIANT t_VariantProcessIdentifier ;
					VariantInit ( & t_VariantProcessIdentifier ) ;
					t_VariantProcessIdentifier.vt = VT_I4 ;
					t_VariantProcessIdentifier.lVal = GetCurrentProcessId () ;
					t_Instance->Put ( L"HostProcessIdentifier" , 0 , & t_VariantProcessIdentifier , 0 ) ;
					VariantClear ( & t_VariantProcessIdentifier ) ;

					t_Result = a_Sink->Indicate ( 1 , & t_Instance ) ;

					t_Instance->Release () ;
				}

				t_Object->Release () ;
			}

			SysFreeString ( t_Class ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_CLASS ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Set (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_OldObject ,
	IWbemClassObject *a_NewObject  
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Deleted (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_Object  
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Enumerate (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	if ( wbem_wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
	{
		IWbemClassObject *t_Object = NULL ;

		BSTR t_Class = SysAllocString ( a_Class ) ;
		if ( t_Class ) 
		{
			t_Result = a_Service->GetObject (

				t_Class ,
				0 ,
				a_Context ,
				& t_Object ,
				NULL 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemClassObject *t_Instance = NULL ;
				t_Result = t_Object->SpawnInstance ( 

					0 , 
					& t_Instance 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					_IWmiObject *t_FastObject = NULL ;
					t_Instance->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastObject ) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_GetObjectAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_GetObjectAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_PutClassAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_PutClassAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_DeleteClassAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_DeleteClassAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateClassEnumAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_CreateClassEnumAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_PutInstanceAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_PutInstanceAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateInstanceEnumAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_CreateInstanceEnumAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ExecQueryAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_ExecQueryAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ExecNotificationQueryAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_ExecNotificationQueryAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_DeleteInstanceAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_DeleteInstanceAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ExecMethodAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_ExecMethodAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_QueryInstances" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_QueryInstances
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateRefresher" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_CreateRefresher
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateRefreshableObject" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_CreateRefreshableObject
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_StopRefreshing" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_StopRefreshing
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateRefreshableEnum" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_CreateRefreshableEnum
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_GetObjects" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_GetObjects
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_GetProperty" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_GetProperty
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_PutProperty" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_PutProperty
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ProvideEvents" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_ProvideEvents
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_NewQuery" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_NewQuery
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CancelQuery" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_CancelQuery
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_AccessCheck" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_AccessCheck
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_SetRegistrationObject" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_SetRegistrationObject
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_FindConsumer" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_FindConsumer
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ValidateSubscription" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_ValidateSubscription
					) ;

					t_FastObject->Release () ;

					VARIANT t_VariantProcessIdentifier ;
					VariantInit ( & t_VariantProcessIdentifier ) ;
					t_VariantProcessIdentifier.vt = VT_I4 ;
					t_VariantProcessIdentifier.lVal = GetCurrentProcessId () ;
					t_Instance->Put ( L"HostProcessIdentifier" , 0 , & t_VariantProcessIdentifier , 0 ) ;
					VariantClear ( & t_VariantProcessIdentifier ) ;

					t_Result = a_Sink->Indicate ( 1 , & t_Instance ) ;

					t_Instance->Release () ;
				}

				t_Object->Release () ;
			}

			SysFreeString ( t_Class ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_CLASS ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Call (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	LPCWSTR a_Method,
	IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Query (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
	WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
	VARIANT *a_Value 
)
{
	HRESULT t_Result = WBEM_E_INVALID_PROPERTY ;

	if ( a_ClassIdentifier == WBEM_PROVIDER_CONFIGURATION_CLASS_ID_INSTANCE_PROVIDER_REGISTRATION ) 
	{
		if ( a_PropertyIdentifier == WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID_EXTENDEDQUERY_SUPPORT )
		{
			if ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_V1ProviderDefined ) 
			{
				a_Value->vt = VT_BOOL ;
				a_Value->boolVal = VARIANT_TRUE ;
			}
			else
			{
				a_Value->vt = VT_BOOL ;
				a_Value->boolVal = VARIANT_FALSE ;
			}

			t_Result = S_OK ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ForceReload ()
{
	return WBEM_E_NOT_SUPPORTED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Shutdown (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	ULONG a_MilliSeconds
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Violation (

	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemClassObject *a_Object	
)
{
	if ( m_Quota )
	{
		return m_Quota->Violation (

			a_Flags ,
			a_Context ,
			a_Object	
		) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: GetSite ( DWORD *a_ProcessIdentifier )
{
	HRESULT t_Result = S_OK ;

	if ( a_ProcessIdentifier ) 
	{
		*a_ProcessIdentifier = GetCurrentProcessId () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: SetContainer ( IUnknown *a_Container )
{
	if ( a_Container )
	{
		HRESULT t_Result = a_Container->QueryInterface ( IID__IWmiProviderQuota , ( void ** ) & m_Quota ) ;
		return t_Result ;
	}
	
	return WBEM_E_INVALID_PARAMETER ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: SetInitialized ( HRESULT a_InitializeResult )
{
	m_InitializeResult = a_InitializeResult ;

	InterlockedExchange ( & m_Initialized , 1 ) ;

	if ( m_InitializedEvent )
	{
		SetEvent ( m_InitializedEvent ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout )
{
	HRESULT t_Result = WBEM_E_UNEXPECTED ;

	if ( m_Initialized == 0 )
	{
		BOOL t_DependantCall = FALSE ;
		t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_DependantCall == FALSE )
			{
				if ( WaitForSingleObject ( m_InitializedEvent , a_Timeout ) == WAIT_TIMEOUT )
				{
					return WBEM_E_PROVIDER_LOAD_FAILURE ;
				}
			}
			else
			{
				if ( WaitForSingleObject ( m_InitializedEvent , 0 ) == WAIT_TIMEOUT )
				{
					return S_FALSE ;
				}
			}
		}
	}
	else
	{
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Initialize (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Namespace ,
	IWbemServices *a_Repository ,
	IWbemServices *a_Service ,
	IWbemProviderInitSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_TransactionIdentifier )
		{
			wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;

			if ( a_TransactionIdentifier )
			{
				StringFromGUID2 ( *a_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
			}

			m_TransactionIdentifier = SysAllocString ( t_TransactionIdentifier ) ;
		}
	}

	if ( a_Repository )
	{
		t_Result = a_Repository->GetObject ( 

			L"__ExtendedStatus" ,
			0 , 
			a_Context ,
			& m_ExtendedStatusObject ,
			NULL
		) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_InitializedEvent = CreateEvent ( NULL , TRUE , FALSE , NULL ) ;
		if ( m_InitializedEvent == NULL )
		{
			t_Result = t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	IWbemShutdown *t_Shutdown = NULL ;

	if ( m_Unknown )
	{
		t_Result = m_Unknown->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , IID_IWbemShutdown , t_Shutdown , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_Shutdown->Shutdown (

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}

					CoRevertToSelf () ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemShutdown *t_Provider = ( IWbemShutdown * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_DEFAULT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								try
								{
									t_Result = t_Provider->Shutdown (

										a_Flags ,
										a_MaxMilliSeconds ,
										a_Context
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
						}

						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_Shutdown->Release () ;
		}
	}

	if ( m_CoreStub )
	{
		t_Shutdown = NULL ;
		t_Result = m_CoreStub->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Shutdown->Shutdown (

				a_Flags ,
				a_MaxMilliSeconds ,
				a_Context
			) ;

			t_Shutdown->Release () ;
		}
	}

	Lock () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Container->Size () ] ;
	if ( t_ShutdownElements )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

		ULONG t_Count = 0 ;
		while ( ! t_Iterator.Null () )
		{
			t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

			t_Iterator.Increment () ;

			t_Count ++ ;
		}

		UnLock () ;

		for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
		{
			if ( t_ShutdownElements [ t_Index ] ) 
			{
				t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

					a_Flags ,
					a_MaxMilliSeconds ,
					a_Context
				) ;

				t_ShutdownElements [ t_Index ]->Release () ;
			}
		}

		delete [] t_ShutdownElements ;
	}
	else
	{	
		UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\dll\makefile.inc ===
!include $(_NTDRIVE)$(_NTROOT)\ADMIN\WMI\WBEM\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provwsvs.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvCache.h"
#include "ProvObSk.h"
#include "ProvInSk.h"
#include "ProvWsvS.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemServices_Interceptor :: CInterceptor_IWbemServices_Interceptor (

	WmiAllocator &a_Allocator ,
	IWbemServices *a_Service

) : m_ReferenceCount ( 0 ) , 
	m_Core_IWbemServices ( a_Service ) ,
	m_Core_IWbemRefreshingServices ( NULL ) ,
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_Allocator ( a_Allocator ),
	m_CriticalSection (NOTHROW_LOCK)
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Interceptor_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	HRESULT t_Result = m_Core_IWbemServices->QueryInterface ( IID_IWbemRefreshingServices , ( void ** ) & m_Core_IWbemRefreshingServices ) ;

	m_Core_IWbemServices->AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemServices_Interceptor :: ~CInterceptor_IWbemServices_Interceptor ()
{
	if ( m_Core_IWbemServices )
	{
		m_Core_IWbemServices->Release () ; 
	}

	if ( m_Core_IWbemRefreshingServices )
	{
		m_Core_IWbemRefreshingServices->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Interceptor_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_Interceptor :: AddRef ( void )
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_Interceptor :: Release ( void )
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemServices_Interceptor :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}
	else if ( iid == IID_IWbemRefreshingServices )
	{
		*iplpv = ( LPVOID ) ( IWbemRefreshingServices * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->OpenNamespace (

			a_ObjectPath, 
			a_Flags, 
			a_Context ,
			a_NamespaceService, 
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->CancelAsyncCall (

			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->QueryObjectSink (

			a_Flags,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->GetObject (

			a_ObjectPath,
			a_Flags,
			a_Context ,
			a_Object,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->GetObjectAsync (

			a_ObjectPath, 
			a_Flags, 
			a_Context ,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->PutClass (

			a_Object, 
			a_Flags, 
			a_Context,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->PutClassAsync (

			a_Object, 
			a_Flags, 
			a_Context ,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->DeleteClass (

			a_Class, 
			a_Flags, 
			a_Context,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: DeleteClassAsync ( 
		
	const BSTR a_Class ,
	long a_Flags,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->DeleteClassAsync (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->CreateClassEnum (

			a_Superclass, 
			a_Flags, 
			a_Context,
			a_Enum
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CInterceptor_IWbemServices_Interceptor :: CreateClassEnumAsync (

	const BSTR a_Superclass ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->CreateClassEnumAsync (

			a_Superclass, 
			a_Flags, 
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: PutInstance (

    IWbemClassObject *a_Instance,
    long a_Flags,
    IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->PutInstance (

			a_Instance,
			a_Flags,
			a_Context,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags, 
    IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->PutInstanceAsync (

			a_Instance, 
			a_Flags, 
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: DeleteInstance ( 

	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->DeleteInstance (

			a_ObjectPath,
			a_Flags,
			a_Context,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_Interceptor :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink	
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->DeleteInstanceAsync (

			a_ObjectPath,
			a_Flags,
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->CreateInstanceEnum (

			a_Class, 
			a_Flags, 
			a_Context, 
			a_Enum
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: CreateInstanceEnumAsync (

 	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink

) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->CreateInstanceEnumAsync (

 			a_Class, 
			a_Flags, 
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecQuery (

			a_QueryLanguage, 
			a_Query, 
			a_Flags, 
			a_Context,
			a_Enum
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecQueryAsync (

			a_QueryLanguage, 
			a_Query, 
			a_Flags, 
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecNotificationQuery (

			a_QueryLanguage,
			a_Query,
			a_Flags,
			a_Context,
			a_Enum
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_Interceptor :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecNotificationQueryAsync (

			a_QueryLanguage,
			a_Query,
			a_Flags,
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CInterceptor_IWbemServices_Interceptor :: ExecMethod ( 

	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
    IWbemClassObject **a_OutParams,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecMethod (

			a_ObjectPath,
			a_MethodName,
			a_Flags,
			a_Context,
			a_InParams,
			a_OutParams,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CInterceptor_IWbemServices_Interceptor :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecMethodAsync (

			a_ObjectPath,
			a_MethodName,
			a_Flags,
			a_Context,
			a_InParams,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: ServiceInitialize ()
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;
			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: AddObjectToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Path,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->AddObjectToRefresher (

				a_RefresherId ,
				a_Path,
				a_Flags ,
				a_Context,
				a_ClientRefresherVersion ,
				a_Information ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: AddObjectToRefresherByTemplate (

	WBEM_REFRESHER_ID *a_RefresherId ,
	IWbemClassObject *a_Template ,
	long a_Flags ,
	IWbemContext *a_Context ,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->AddObjectToRefresherByTemplate (

				a_RefresherId ,
				a_Template ,
				a_Flags ,
				a_Context ,
				a_ClientRefresherVersion ,
				a_Information ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: AddEnumToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->AddEnumToRefresher (

				a_RefresherId ,
				a_Class ,
				a_Flags ,
				a_Context,
				a_ClientRefresherVersion ,
				a_Information ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: RemoveObjectFromRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Id ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->RemoveObjectFromRefresher (

				a_RefresherId ,
				a_Id ,
				a_Flags ,
				a_ClientRefresherVersion ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: GetRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	IWbemRemoteRefresher **a_RemoteRefresher ,
	GUID *a_Guid ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->GetRemoteRefresher (

				a_RefresherId ,
				a_Flags ,
				a_ClientRefresherVersion ,
				a_RemoteRefresher ,
				a_Guid ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: ReconnectRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId,
	long a_Flags,
	long a_NumberOfObjects,
	DWORD a_ClientRefresherVersion ,
	WBEM_RECONNECT_INFO *a_ReconnectInformation ,
	WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->ReconnectRemoteRefresher (

				a_RefresherId,
				a_Flags,
				a_NumberOfObjects,
				a_ClientRefresherVersion ,
				a_ReconnectInformation ,
				a_ReconnectResults ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemServices_RestrictingInterceptor :: CInterceptor_IWbemServices_RestrictingInterceptor (

	WmiAllocator &a_Allocator ,
	IWbemServices *a_Service ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) : m_ReferenceCount ( 0 ) , 
	m_Core_IWbemServices ( a_Service ) ,
	m_Core_IWbemRefreshingServices ( NULL ) ,
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_Registration ( a_Registration ) , 
	m_Allocator ( a_Allocator ) ,
	m_ProxyContainer ( a_Allocator , 3 , MAX_PROXIES ),
	m_CriticalSection(NOTHROW_LOCK)
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_RestrictingInterceptor_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	HRESULT t_Result = m_Core_IWbemServices->QueryInterface ( IID_IWbemRefreshingServices , ( void ** ) & m_Core_IWbemRefreshingServices ) ;

	m_Core_IWbemServices->AddRef () ;

	m_Registration.AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemServices_RestrictingInterceptor :: ~CInterceptor_IWbemServices_RestrictingInterceptor ()
{
	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	if ( m_Core_IWbemServices )
	{
		m_Core_IWbemServices->Release () ; 
	}

	if ( m_Core_IWbemRefreshingServices )
	{
		m_Core_IWbemRefreshingServices->Release () ;
	}

	m_Registration.Release () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_RestrictingInterceptor_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_RestrictingInterceptor :: AddRef ( void )
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_RestrictingInterceptor :: Release ( void )
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemServices_RestrictingInterceptor :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}
	else if ( iid == IID_IWbemRefreshingServices )
	{
		*iplpv = ( LPVOID ) ( IWbemRefreshingServices * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: Begin_IWbemServices (

	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IWbemServices *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context 
)
{
	HRESULT t_Result = S_OK ;

	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Proxy_IWbemServices , IID_IWbemServices , m_Core_IWbemServices , a_Proxy , a_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = m_Core_IWbemServices ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IWbemServices * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_DEFAULT , 
					t_ImpersonationLevel
				) ;

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

						m_ProxyContainer , 
						ProxyIndex_Proxy_IWbemServices , 
						a_Proxy , 
						a_Revert
					) ;
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: End_IWbemServices (

	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IWbemServices *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

			m_ProxyContainer , 
			ProxyIndex_Proxy_IWbemServices , 
			a_Proxy , 
			a_Revert
		) ;
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: Begin_IWbemRefreshingServices (

	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IWbemRefreshingServices *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context 
)
{
	HRESULT t_Result = S_OK ;

	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Proxy_IWbemRefreshingServices , IID_IWbemRefreshingServices , m_Core_IWbemRefreshingServices , a_Proxy , a_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = m_Core_IWbemRefreshingServices ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IWbemRefreshingServices * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_DEFAULT , 
					t_ImpersonationLevel
				) ;

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

						m_ProxyContainer , 
						ProxyIndex_Proxy_IWbemRefreshingServices , 
						a_Proxy , 
						a_Revert
					) ;
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: End_IWbemRefreshingServices (

	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IWbemRefreshingServices *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

			m_ProxyContainer , 
			ProxyIndex_Proxy_IWbemRefreshingServices , 
			a_Proxy , 
			a_Revert
		) ;
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->OpenNamespace (

				a_ObjectPath, 
				a_Flags, 
				a_Context ,
				a_NamespaceService, 
				a_CallResult
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->CancelAsyncCall (

				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->QueryObjectSink (

				a_Flags,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->GetObject (

				a_ObjectPath,
				a_Flags,
				a_Context ,
				a_Object,
				a_CallResult
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->GetObjectAsync (

				a_ObjectPath, 
				a_Flags, 
				a_Context ,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->PutClass (

				a_Object, 
				a_Flags, 
				a_Context,
				a_CallResult
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->PutClassAsync (

				a_Object, 
				a_Flags, 
				a_Context ,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->DeleteClass (

				a_Class, 
				a_Flags, 
				a_Context,
				a_CallResult
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: DeleteClassAsync ( 
		
	const BSTR a_Class ,
	long a_Flags,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->DeleteClassAsync (

				a_Class , 
				a_Flags , 
				a_Context ,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->CreateClassEnum (

				a_Superclass, 
				a_Flags, 
				a_Context,
				a_Enum
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CInterceptor_IWbemServices_RestrictingInterceptor :: CreateClassEnumAsync (

	const BSTR a_Superclass ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_