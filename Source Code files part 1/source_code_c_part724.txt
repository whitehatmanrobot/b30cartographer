 CRefPtrCOM<IAutoComplete2>  spAC2;  // auto complete 2 interface
        CRefPtrCOM<IUnknown>        spACS;  // auto complete source (IEnumString & IACList)

        // initialize all the objects & hook them up
        if( SUCCEEDED(hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER,
                IID_IAutoComplete, (void**)&spAC)) &&
            SUCCEEDED(hr = CPrintersACS_CreateInstance(&spACS)) &&
            SUCCEEDED(hr = spAC->Init(hwndEdit, spACS, NULL, NULL)) &&
            SUCCEEDED(hr = spAC->QueryInterface(IID_IAutoComplete2, (void **)&spAC2)) &&
            SUCCEEDED(hr = spAC2->SetOptions(ACO_AUTOSUGGEST)) )
        {
            hr = S_OK;
        }
    }

    return hr;
}

// helpers for the Enum* idioms
HRESULT EnumPrintersWrap(DWORD dwFlags, DWORD dwLevel, LPCTSTR pszName, BYTE **ppBuffer, DWORD *pcReturned)
{
    HRESULT hr = E_INVALIDARG;

    if( ppBuffer && pcReturned )
    {
        int iTry = -1;
        DWORD cbNeeded = 0;
        DWORD cReturned = 0;
        CAutoPtrArray<BYTE> pData;
        BOOL bStatus = FALSE;

        for( ;; )
        {
            if( iTry++ >= ENUM_MAX_RETRY )
            {
                // max retry count reached. this is also
                // considered out of memory case
                pData = NULL;
                break;
            }

            // call EnumPrinters...
            bStatus = EnumPrinters(dwFlags, const_cast<LPTSTR>(pszName), dwLevel,
                pData, cbNeeded, &cbNeeded, &cReturned);

            if( !bStatus && ERROR_INSUFFICIENT_BUFFER == GetLastError() && cbNeeded )
            {
                // buffer too small case
                pData = new BYTE[cbNeeded];
                continue;
            }

            break;
        }

        // setup the error code properly
        hr = bStatus ? S_OK : GetLastError() != ERROR_SUCCESS ? HRESULT_FROM_WIN32(GetLastError()) :
             !pData ? E_OUTOFMEMORY : E_FAIL;

        // setup the out parameters
        if( SUCCEEDED(hr) )
        {
            *ppBuffer = pData.Detach();
            *pcReturned = cReturned;
        }
        else
        {
            *ppBuffer = NULL;
            *pcReturned = 0;
        }
    }

    return hr;
}

// helpers for the GetJob API - see the SDK for mor information.
HRESULT GetJobWrap(HANDLE hPrinter, DWORD JobId, DWORD dwLevel, BYTE **ppBuffer, DWORD *pcReturned)
{
    HRESULT hr = E_INVALIDARG;

    if( ppBuffer && pcReturned )
    {
        int iTry = -1;
        DWORD cbNeeded = 0;
        CAutoPtrArray<BYTE> pData;
        BOOL bStatus = FALSE;

        for( ;; )
        {
            if( iTry++ >= ENUM_MAX_RETRY )
            {
                // max retry count reached. this is also
                // considered out of memory case
                pData = NULL;
                break;
            }

            // call GetJob...
            bStatus = GetJob(hPrinter, JobId, dwLevel, pData, cbNeeded, &cbNeeded);

            if( !bStatus && ERROR_INSUFFICIENT_BUFFER == GetLastError() && cbNeeded )
            {
                // buffer too small case
                pData = new BYTE[cbNeeded];
                continue;
            }

            break;
        }

        // setup the error code properly
        hr = bStatus ? S_OK : GetLastError() != ERROR_SUCCESS ? HRESULT_FROM_WIN32(GetLastError()) :
             !pData ? E_OUTOFMEMORY : E_FAIL;

        // setup the out parameters
        if( SUCCEEDED(hr) )
        {
            *ppBuffer = pData.Detach();
            *pcReturned = cbNeeded;
        }
        else
        {
            *ppBuffer = NULL;
            *pcReturned = 0;
        }
    }

    return hr;
}

typedef NET_API_STATUS
type_NetAPI_NetShareEnum(
  LPWSTR servername,
  DWORD level,
  LPBYTE *bufptr,
  DWORD prefmaxlen,
  LPDWORD entriesread,
  LPDWORD totalentries,
  LPDWORD resume_handle
);

typedef NET_API_STATUS
type_NetAPI_NetApiBufferFree(
  LPVOID Buffer
);

typedef NET_API_STATUS
type_NetAPI_NetApiBufferSize(
  LPVOID Buffer,
  LPDWORD ByteCount
);

// enumerates the shared resources on a server, for more info see SDK for NetShareEnum API.
HRESULT NetAPI_EnumShares(LPCTSTR pszServer, DWORD dwLevel, BYTE **ppBuffer, DWORD *pcReturned)
{
    HRESULT hr = E_INVALIDARG;

    if( ppBuffer && pcReturned )
    {
        hr = E_FAIL;

        *pcReturned = 0;
        *ppBuffer = NULL;

        LPBYTE pNetBuf = NULL;
        DWORD dwRead, dwTemp;

        CDllLoader dll(TEXT("netapi32.dll"));
        if( dll )
        {
            // netapi32.dll loaded here...
            type_NetAPI_NetShareEnum *pfnNetShareEnum = (type_NetAPI_NetShareEnum *)dll.GetProcAddress("NetShareEnum");
            type_NetAPI_NetApiBufferSize *pfnNetApiBufferSize = (type_NetAPI_NetApiBufferSize *)dll.GetProcAddress("NetApiBufferSize");
            type_NetAPI_NetApiBufferFree *pfnNetApiBufferFree = (type_NetAPI_NetApiBufferFree *)dll.GetProcAddress("NetApiBufferFree");

            if( pfnNetShareEnum && pfnNetApiBufferSize && pfnNetApiBufferFree &&
                NERR_Success == pfnNetShareEnum(const_cast<LPTSTR>(pszServer), dwLevel,
                &pNetBuf, MAX_PREFERRED_LENGTH, &dwRead, &dwTemp, NULL) &&
                dwRead && pNetBuf &&
                NERR_Success == pfnNetApiBufferSize(pNetBuf, &dwTemp) )

            {
                *ppBuffer = new BYTE[dwTemp];
                if( *ppBuffer )
                {
                    // copy the bits first
                    memcpy(*ppBuffer, pNetBuf, dwTemp);

                    // adjust the pointers here - a little bit ugly, but works
                    for( DWORD dw = 0; dw < dwRead; dw++ )
                    {
                        // adjust shi1_netname
                        reinterpret_cast<SHARE_INFO_1*>(*ppBuffer)[dw].shi1_netname =
                            reinterpret_cast<LPWSTR>(
                                (*ppBuffer) +
                                (reinterpret_cast<BYTE*>(
                                    reinterpret_cast<SHARE_INFO_1*>(pNetBuf)[dw].shi1_netname) -
                                    pNetBuf));

                        // adjust shi1_remark
                        reinterpret_cast<SHARE_INFO_1*>(*ppBuffer)[dw].shi1_remark =
                            reinterpret_cast<LPWSTR>(
                                (*ppBuffer) +
                                (reinterpret_cast<BYTE*>(
                                    reinterpret_cast<SHARE_INFO_1*>(pNetBuf)[dw].shi1_remark) -
                                    pNetBuf));
                    }

                    // number of structures returned
                    *pcReturned = dwRead;
                }
                hr = ((*ppBuffer) ? S_OK : E_OUTOFMEMORY);
                CHECK(NERR_Success == pfnNetApiBufferFree(pNetBuf));
            }
        }
    }

    if( E_FAIL == hr && ERROR_SUCCESS != GetLastError() )
    {
        // if failed, let's be more spcific about what the error is...
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

} // namespace ShellServices

// utility functions
HRESULT LoadXMLDOMDoc(LPCTSTR pszURL, IXMLDOMDocument **ppXMLDoc)
{
    HRESULT hr = E_INVALIDARG;
    CRefPtrCOM<IXMLDOMDocument> spXMLDoc;

    if( pszURL && ppXMLDoc )
    {
        *ppXMLDoc = NULL;

        // create an instance of XMLDOM
        hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void **)&spXMLDoc);

        if( SUCCEEDED(hr) )
        {
            CComVariant xmlSource(pszURL);
            if( VT_BSTR == xmlSource.vt )
            {
                // just load the XML document here
                VARIANT_BOOL fIsSuccessful = VARIANT_TRUE;
                hr = spXMLDoc->load(xmlSource, &fIsSuccessful);

                if( S_FALSE == hr || VARIANT_FALSE == fIsSuccessful )
                {
                    // this isn't a valid XML file.
                    hr = E_FAIL;
                }
                else
                {
                    // everything looks successful here - just return the XML document
                    *ppXMLDoc = spXMLDoc.Detach();
                }
            }
            else
            {
                // xmlSource failed to allocate the string
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

HRESULT CreateStreamFromURL(LPCTSTR pszURL, IStream **pps)
{
    HRESULT hr = E_INVALIDARG;
    if( pszURL && pps )
    {
        *pps = NULL;
        TCHAR szBuf[INTERNET_MAX_SCHEME_LENGTH];
        DWORD cch = ARRAYSIZE(szBuf);


        if( SUCCEEDED(hr = CoInternetParseUrl(pszURL, PARSE_SCHEMA, 0, szBuf, cch, &cch, 0)) &&
            0 == lstrcmp(szBuf, TEXT("res")) )
        {
            // check if this is a res:// URL to handle explicitly since
            // this protocol doesn't report filename and therefore can't
            // be used in conditions where caching is required - we can't
            // call URLOpenBlockingStream - use alternatives.

            // not impl. yet...
            ASSERT(FALSE);
        }

        hr = URLOpenBlockingStream(NULL, pszURL, pps, 0, NULL);
    }
    return hr;
}

HRESULT CreateStreamFromResource(LPCTSTR pszModule, LPCTSTR pszResType, LPCTSTR pszResName, IStream **pps)
{
    HRESULT hr = E_INVALIDARG;
    if( pszResType && pszResName )
    {
        hr = E_FAIL;
        *pps = NULL;

        HINSTANCE hModule = NULL;
        if( (NULL == pszModule) || (hModule = LoadLibrary(pszModule)) )
        {
            HRSRC hHint = NULL;
            ULONG uSize = 0;

            if( (hHint = FindResource(hModule, pszResName, pszResType)) &&
                (uSize = SizeofResource(hModule, hHint)) )
            {
                HGLOBAL hResData = LoadResource(hModule, hHint);
                if( hResData )
                {
                    LPVOID lpResData = LockResource(hResData);
                    if( lpResData )
                    {
                        if( (*pps = SHCreateMemStream(reinterpret_cast<LPBYTE>(lpResData), uSize)) )
                        {
                            hr = S_OK;
                        }
                        UnlockResource(lpResData);
                    }
                    FreeResource(hResData);
                }
            }
        }

        if( hModule )
        {
            FreeLibrary(hModule);
        }
    }
    return hr;
}

HRESULT Gdiplus2HRESULT(Gdiplus::Status status)
{
    // can't think of a better way to do this now
    HRESULT hr = E_FAIL;

    switch( status )
    {
        case Gdiplus::Ok:
            hr = S_OK;
            break;

        case Gdiplus::InvalidParameter:
            hr = E_INVALIDARG;
            break;

        case Gdiplus::OutOfMemory:
            hr = E_OUTOFMEMORY;
            break;

        case Gdiplus::InsufficientBuffer:
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            break;

        case Gdiplus::Aborted:
            hr = E_ABORT;
            break;

        case Gdiplus::ObjectBusy:
            hr = E_PENDING;
            break;

        case Gdiplus::FileNotFound:
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            break;

        case Gdiplus::AccessDenied:
            hr = E_ACCESSDENIED;
            break;

        case Gdiplus::UnknownImageFormat:
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PIXEL_FORMAT);
            break;

        case Gdiplus::NotImplemented:
            hr = E_NOTIMPL;
            break;

        case Gdiplus::Win32Error:
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;

        case Gdiplus::ValueOverflow:
        case Gdiplus::FontFamilyNotFound:
        case Gdiplus::FontStyleNotFound:
        case Gdiplus::NotTrueTypeFont:
        case Gdiplus::UnsupportedGdiplusVersion:
        case Gdiplus::GdiplusNotInitialized:
        case Gdiplus::WrongState:
            break;
    }

    return hr;
}

HRESULT LoadAndScaleBmp(LPCTSTR pszURL, UINT nWidth, UINT nHeight, Gdiplus::Bitmap **ppBmp)
{
    CRefPtrCOM<IStream> spStream;
    HRESULT hr = CreateStreamFromURL(pszURL, &spStream);
    if( SUCCEEDED(hr) )
    {
        hr = LoadAndScaleBmp(spStream, nWidth, nHeight, ppBmp);
    }
    return hr;
}

HRESULT LoadAndScaleBmp(IStream *pStream, UINT nWidth, UINT nHeight, Gdiplus::Bitmap **ppBmp)
{
    HRESULT hr = E_INVALIDARG;
    if( pStream && nWidth && nHeight && ppBmp )
    {
        hr = E_FAIL;
        *ppBmp = NULL;

        Gdiplus::Bitmap bmp(pStream);
        if( SUCCEEDED(hr = Gdiplus2HRESULT(bmp.GetLastStatus())) )
        {
            hr = E_OUTOFMEMORY;
            CAutoPtr<Gdiplus::Bitmap> spBmpNew = new Gdiplus::Bitmap(nWidth, nHeight);

            if( spBmpNew && SUCCEEDED(hr = Gdiplus2HRESULT(spBmpNew->GetLastStatus())) )
            {
                Gdiplus::Graphics g(spBmpNew);
                if( SUCCEEDED(hr = Gdiplus2HRESULT(g.GetLastStatus())) )
                {
                    if( SUCCEEDED(hr = g.DrawImage(&bmp, 0, 0, nWidth, nHeight)) )
                    {
                        *ppBmp = spBmpNew.Detach();
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

//
// This function is trying to get the last active popup of the top
// level owner of the current thread active window.
//
HRESULT GetCurrentThreadLastPopup(HWND *phwnd)
{
    HRESULT hr = E_INVALIDARG;

    if( phwnd )
    {
        hr = E_FAIL;

        if( NULL == *phwnd )
        {
            // if *phwnd is NULL then get the current thread active window
            GUITHREADINFO ti = {0};
            ti.cbSize = sizeof(ti);
            if( GetGUIThreadInfo(0, &ti) && ti.hwndActive )
            {
                *phwnd = ti.hwndActive;
            }
        }

        if( *phwnd )
        {
            HWND hwndOwner, hwndParent;

            // climb up to the top parent in case it's a child window...
            while( hwndParent = GetParent(*phwnd) )
            {
                *phwnd = hwndParent;
            }

            // get the owner in case the top parent is owned
            hwndOwner = GetWindow(*phwnd, GW_OWNER);
            if( hwndOwner )
            {
                *phwnd = hwndOwner;
            }

            // get the last popup of the owner of the top level parent window
            *phwnd = GetLastActivePopup(*phwnd);
            hr = (*phwnd) ? S_OK : E_FAIL;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\lib\psutil\wiadbgcl.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       WIADBGCL.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/4/1999
 *
 *  DESCRIPTION: Debug client.  Linked statically.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <windows.h>
#include "simreg.h"
#include "wiadebug.h"
#include "tchar.h"

#define DOESNT_MATTER_WHAT_THIS_IS ((UINT)7)

#define BACK_SLASH TEXT("\\")

//
// Static class data members
//
CWiaDebugClient g_TheDebugClient;


//
// Sole constructor
//
CWiaDebugClient::CWiaDebugClient(void)
  : m_hDebugModule(NULL),
    m_hCurrentModuleInstance(NULL),
    m_pfnIncrementDebugIndentLevel(NULL),
    m_pfnDecrementDebugIndentLevel(NULL),
    m_pfnPrintDebugMessageW(NULL),
    m_pfnPrintDebugMessageA(NULL),
    m_pfnGetDebugMask(NULL),
    m_pfnSetDebugMask(NULL),
    m_pfnAllocateDebugColor(NULL),
    m_pfnGetStringFromGuidA(NULL),
    m_pfnGetStringFromGuidW(NULL),
    m_pfnDoRecordAllocation(NULL),
    m_pfnDoRecordFree(NULL),
    m_pfnDoReportLeaks(NULL),
    m_crForegroundColor(DEFAULT_DEBUG_COLOR),
    m_dwModuleDebugMask(0),
    m_bHaveModuleInformation(false),
    m_bDebugLibLoadAttempted(false),
    m_pfnGetStringFromMsgA(NULL),
    m_pfnGetStringFromMsgW(NULL)
{
    CAutoCriticalSection cs(m_CriticalSection);
    m_szModuleNameW[0] = 0;
    m_szModuleNameA[0] = 0;

    if (LoadWiaDebugExports())
    {
        InitializeModuleInfo();
    }
}


template <class T>
static T GetProc( HINSTANCE hModule, LPCSTR pszFunctionName )
{
    return reinterpret_cast<T>(GetProcAddress( hModule, pszFunctionName ));
}

bool CWiaDebugClient::LoadWiaDebugExports()
{
    CAutoCriticalSection cs(m_CriticalSection);

    //
    // No need to call this more than once, so return true if the
    // load was successful, false if it was not
    //
    if (m_bDebugLibLoadAttempted)
    {
        return (NULL != m_hDebugModule);
    }

    //
    // Prevent future loading attempts
    //
    m_bDebugLibLoadAttempted = true;

    //
    // Assume failure
    //
    bool bResult = false;

    //
    // Get the system directory path
    //
    TCHAR szDllName[MAX_PATH] = {0};
    if (GetSystemDirectory( szDllName, ARRAYSIZE(szDllName)))
    {
        //
        // Make sure our string can hold the full path to the DLL
        //
        if ((lstrlen(szDllName) + lstrlen(DEBUG_DLL_NAME) + lstrlen(BACK_SLASH)) < ARRAYSIZE(szDllName))
        {
            //
            // Construct the full path to the DLL
            //
            lstrcat( szDllName, BACK_SLASH );
            lstrcat( szDllName, DEBUG_DLL_NAME );

            //
            // Load the library
            //
            m_hDebugModule = LoadLibrary( DEBUG_DLL_NAME );
            if (m_hDebugModule)
            {
                m_pfnIncrementDebugIndentLevel = GetProc<IncrementDebugIndentLevelProc>( m_hDebugModule, INCREMENT_DEBUG_INDENT_LEVEL_NAME );
                m_pfnDecrementDebugIndentLevel = GetProc<DecrementDebugIndentLevelProc>( m_hDebugModule, DECREMENT_DEBUG_INDENT_LEVEL_NAME );
                m_pfnPrintDebugMessageA        = GetProc<PrintDebugMessageAProc>( m_hDebugModule, PRINT_DEBUG_MESSAGE_NAMEA );
                m_pfnPrintDebugMessageW        = GetProc<PrintDebugMessageWProc>( m_hDebugModule, PRINT_DEBUG_MESSAGE_NAMEW );
                m_pfnGetDebugMask              = GetProc<GetDebugMaskProc>( m_hDebugModule, GET_DEBUG_MASK_NAME );
                m_pfnSetDebugMask              = GetProc<SetDebugMaskProc>( m_hDebugModule, SET_DEBUG_MASK_NAME );
                m_pfnAllocateDebugColor        = GetProc<AllocateDebugColorProc>( m_hDebugModule, ALLOCATE_DEBUG_COLOR_NAME );
                m_pfnGetStringFromGuidA        = GetProc<GetStringFromGuidAProc>( m_hDebugModule, GET_STRING_FROM_GUID_NAMEA );
                m_pfnGetStringFromGuidW        = GetProc<GetStringFromGuidWProc>( m_hDebugModule, GET_STRING_FROM_GUID_NAMEW );
                m_pfnDoRecordAllocation        = GetProc<DoRecordAllocationProc>( m_hDebugModule, DO_RECORD_ALLOCATION );
                m_pfnDoRecordFree              = GetProc<DoRecordFreeProc>( m_hDebugModule, DO_RECORD_FREE );
                m_pfnDoReportLeaks             = GetProc<DoReportLeaksProc>( m_hDebugModule, DO_REPORT_LEAKS );
                m_pfnGetStringFromMsgA         = GetProc<GetStringFromMsgAProc>( m_hDebugModule, GET_STRING_FROM_MSGA );
                m_pfnGetStringFromMsgW         = GetProc<GetStringFromMsgWProc>( m_hDebugModule, GET_STRING_FROM_MSGW );

                bResult = (m_pfnIncrementDebugIndentLevel &&
                           m_pfnDecrementDebugIndentLevel &&
                           m_pfnPrintDebugMessageA &&
                           m_pfnPrintDebugMessageW &&
                           m_pfnGetDebugMask &&
                           m_pfnSetDebugMask &&
                           m_pfnAllocateDebugColor &&
                           m_pfnGetStringFromGuidA &&
                           m_pfnGetStringFromGuidW &&
                           m_pfnDoRecordAllocation &&
                           m_pfnDoRecordFree &&
                           m_pfnDoReportLeaks &&
                           m_pfnGetStringFromMsgA &&
                           m_pfnGetStringFromMsgW);
            }
        }
    }
    return bResult;
}

bool CWiaDebugClient::IsInitialized()
{
    bool bResult = false;
    CAutoCriticalSection cs(m_CriticalSection);
    if (LoadWiaDebugExports())
    {
        bResult = InitializeModuleInfo();
    }
    return bResult;
}

LPTSTR CWiaDebugClient::GetJustTheFileName( LPCTSTR pszPath, LPTSTR pszFileName, int nMaxLen )
{
    //
    // Make sure we have valid arguments
    //
    if (!pszPath || !pszFileName || !nMaxLen)
    {
        return NULL;
    }

    //
    // Initialize the return string
    //
    lstrcpy( pszFileName, TEXT("") );

    //
    // Loop through the filename, looking for the last \
    //
    LPCTSTR pszLastBackslash = NULL;
    for (LPCTSTR pszCurr=pszPath;pszCurr && *pszCurr;pszCurr = CharNext(pszCurr))
    {
        if (TEXT('\\') == *pszCurr)
        {
            pszLastBackslash = pszCurr;
        }
    }
    
    //
    // If we found any \'s, point to the next character
    //
    if (pszLastBackslash)
    {
        pszLastBackslash = CharNext(pszLastBackslash);
    }
    
    //
    // Otherwise, we will copy the entire path
    //
    else
    {
        pszLastBackslash = pszPath;
    }
    
    //
    // If we have a valid starting point, copy the string to the target buffer and terminate it
    //
    if (pszLastBackslash)
    {
        lstrcpyn( pszFileName, pszLastBackslash, nMaxLen-1 );
        pszFileName[nMaxLen-1] = TEXT('\0');
    }

    return pszFileName;
}


bool CWiaDebugClient::InitializeModuleInfo()
{
    CAutoCriticalSection cs(m_CriticalSection);

    //
    // If we've already been initialized, return true
    //
    if (m_bHaveModuleInformation)
    {
        return true;
    }

    //
    // If we haven't got a valid HINSTANCE, return false
    //
    if (!m_hCurrentModuleInstance)
    {
        return false;
    }


    //
    // Make sure we start out with empty module name strings
    //
    m_szModuleNameW[0] = 0;
    m_szModuleNameA[0] = 0;

    //
    // Get default debug setting
    //
    m_dwModuleDebugMask = CSimpleReg( HKEY_LOCAL_MACHINE, DEBUG_REGISTRY_PATH, false, KEY_READ ).Query( DEBUG_REGISTRY_DEFAULT_FLAGS, 0 );

    //
    // Initialize the module name, in case we can't determine it.  It is OK
    // that wsprintfW will return ERROR_NOT_IMPLEMENTED under win9x, since
    // we won't be using this variable at all on this OS
    //
    wsprintfW( m_szModuleNameW, L"0x%08X", GetCurrentProcessId() );
    wsprintfA( m_szModuleNameA, "0x%08X", GetCurrentProcessId() );
    
    //
    // Get the next available color
    //
    m_crForegroundColor = m_pfnAllocateDebugColor();

    //
    // Get the module name
    //
    TCHAR szModulePathName[MAX_PATH] = TEXT("");
    if (GetModuleFileName( m_hCurrentModuleInstance, szModulePathName, ARRAYSIZE(szModulePathName)))
    {
        //
        // Get rid of the path
        //
        TCHAR szFilename[MAX_PATH] = TEXT("");
        GetJustTheFileName( szModulePathName, szFilename, ARRAYSIZE(szFilename) );

        //
        // Make sure we have a valid filename
        //
        if (lstrlen(szFilename))
        {
            m_dwModuleDebugMask = CSimpleReg( HKEY_LOCAL_MACHINE, DEBUG_REGISTRY_PATH_FLAGS, false, KEY_READ ).Query( szFilename, 0 );

            //
            // Save the ANSI and UNICODE versions of the module name
            //
            #ifdef UNICODE
            WideCharToMultiByte( CP_ACP, 0, szFilename, -1, m_szModuleNameA, ARRAYSIZE(m_szModuleNameA), NULL, NULL );
            lstrcpynW( m_szModuleNameW, szFilename, ARRAYSIZE(m_szModuleNameW) );
            #else
            MultiByteToWideChar( CP_ACP, 0, szFilename, -1, m_szModuleNameW, ARRAYSIZE(m_szModuleNameW) );
            lstrcpynA( m_szModuleNameA, szFilename, ARRAYSIZE(m_szModuleNameA) );
            #endif
            
            //
            // Success!
            //
            m_bHaveModuleInformation = true;
            
            //
            // Tell the debugger we're here.  This way, the user can get the expected module name correct.
            //
            m_pfnPrintDebugMessageA( WiaDebugSeverityNormal, 0xFFFFFFFF, RGB(0xFF,0xFF,0xFF), RGB(0x00,0x00,0x00), m_szModuleNameA, "Created debug client" );
        }
    }

    return m_bHaveModuleInformation;
}


void CWiaDebugClient::Destroy(void)
{
    CAutoCriticalSection cs(m_CriticalSection);

    //
    // NULL out all of the function pointers
    //
    m_pfnIncrementDebugIndentLevel = NULL;
    m_pfnDecrementDebugIndentLevel = NULL;
    m_pfnPrintDebugMessageA = NULL;
    m_pfnPrintDebugMessageW = NULL;
    m_pfnGetDebugMask = NULL;
    m_pfnSetDebugMask = NULL;
    m_pfnAllocateDebugColor = NULL;
    m_pfnGetStringFromGuidW = NULL;
    m_pfnGetStringFromGuidA = NULL;
    m_pfnDoRecordAllocation = NULL;
    m_pfnDoRecordFree       = NULL;
    m_pfnDoReportLeaks      = NULL;
    m_pfnGetStringFromMsgA  = NULL;
    m_pfnGetStringFromMsgW  = NULL;

    //
    // Unload the DLL
    //
    if (m_hDebugModule)
    {
        FreeLibrary( m_hDebugModule );
        m_hDebugModule = NULL;
    }

    m_bHaveModuleInformation = false;
    m_bDebugLibLoadAttempted = false;
}

CWiaDebugClient::~CWiaDebugClient(void)
{
    CAutoCriticalSection cs(m_CriticalSection);
    Destroy();
}



DWORD CWiaDebugClient::GetDebugMask(void)
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        return m_pfnGetDebugMask();
    }
    return 0;
}

DWORD CWiaDebugClient::SetDebugMask( DWORD dwNewMask )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        return m_pfnSetDebugMask( dwNewMask );
    }
    return 0;
}


int CWiaDebugClient::IncrementIndentLevel(void)
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        return m_pfnIncrementDebugIndentLevel();
    }
    return 0;
}


int CWiaDebugClient::DecrementIndentLevel(void)
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        return m_pfnDecrementDebugIndentLevel();
    }
    return 0;
}


void CWiaDebugClient::RecordAllocation( LPVOID pv, size_t Size )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        m_pfnDoRecordAllocation( pv, Size );
    }
}

void CWiaDebugClient::RecordFree( LPVOID pv )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        m_pfnDoRecordFree( pv );
    }
}

void CWiaDebugClient::ReportLeaks( VOID )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        #ifdef UNICODE
        m_pfnDoReportLeaks(m_szModuleNameW);
        #else
        m_pfnDoReportLeaks(m_szModuleNameA);
        #endif
    }
}


CPushTraceMask::CPushTraceMask( DWORD dwTraceMask )
: m_dwOldMask(0)
{
    CAutoCriticalSection cs( g_TheDebugClient.m_CriticalSection );
    g_TheDebugClient.SetDebugMask( dwTraceMask );
}


CPushTraceMask::~CPushTraceMask(void)
{
    CAutoCriticalSection cs( g_TheDebugClient.m_CriticalSection );
    g_TheDebugClient.SetDebugMask( m_dwOldMask );
}


CPushIndentLevel::CPushIndentLevel( LPCTSTR pszFmt, ... )
: m_nIndentLevel(0)
{
    CAutoCriticalSection cs( g_TheDebugClient.m_CriticalSection );

    m_nIndentLevel = g_TheDebugClient.IncrementIndentLevel();

    TCHAR szMsg[1024] = {0};
    va_list arglist;

    va_start( arglist, pszFmt );
    _vsntprintf( szMsg, ARRAYSIZE(szMsg)-1, pszFmt, arglist );
    va_end( arglist );

    g_TheDebugClient.PrintTraceMessage( TEXT("Entering function %s [Level %d]"), szMsg, m_nIndentLevel );
}


CPushIndentLevel::~CPushIndentLevel(void)
{
    CAutoCriticalSection cs( g_TheDebugClient.m_CriticalSection );
    if (m_nIndentLevel)
    {
        g_TheDebugClient.DecrementIndentLevel();
        g_TheDebugClient.PrintTraceMessage( TEXT("") );
    }
}


CPushTraceMaskAndIndentLevel::CPushTraceMaskAndIndentLevel( DWORD dwTraceMask, LPCTSTR pszFmt, ... )
: m_dwOldMask(0), m_nIndentLevel(0)
{
    CAutoCriticalSection cs( g_TheDebugClient.m_CriticalSection );
    
    m_dwOldMask = g_TheDebugClient.SetDebugMask( dwTraceMask );
    m_nIndentLevel = g_TheDebugClient.IncrementIndentLevel();

    TCHAR szMsg[1024] = {0};
    va_list arglist;

    va_start( arglist, pszFmt );
    _vsntprintf( szMsg, ARRAYSIZE(szMsg)-1, pszFmt, arglist );
    va_end( arglist );

    g_TheDebugClient.PrintTraceMessage( TEXT("Entering function %s [Level %d]"), szMsg, m_nIndentLevel );
}


CPushTraceMaskAndIndentLevel::~CPushTraceMaskAndIndentLevel(void)
{
    CAutoCriticalSection cs( g_TheDebugClient.m_CriticalSection );
    if (m_nIndentLevel)
    {
        g_TheDebugClient.DecrementIndentLevel();
        g_TheDebugClient.PrintTraceMessage( TEXT("") );
        g_TheDebugClient.SetDebugMask( m_dwOldMask );
    }
}

////////////////////////////////////////////////////////////////
// UNICODE Versions of the output functions
////////////////////////////////////////////////////////////////
void CWiaDebugClient::PrintWarningMessage( LPCWSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        WCHAR szMsg[1024] = {0};
        va_list arglist;

        va_start( arglist, pszFmt );
        _vsnwprintf( szMsg, ARRAYSIZE(szMsg)-1, pszFmt, arglist );
        va_end( arglist );

        m_pfnPrintDebugMessageW( WiaDebugSeverityWarning, m_dwModuleDebugMask, WARNING_FOREGROUND_COLOR, WARNING_BACKGROUND_COLOR, m_szModuleNameW, szMsg );
    }
}

void CWiaDebugClient::PrintErrorMessage( LPCWSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        WCHAR szMsg[1024] = {0};
        va_list arglist;

        va_start( arglist, pszFmt );
        _vsnwprintf( szMsg, ARRAYSIZE(szMsg)-1, pszFmt, arglist );
        va_end( arglist );

        m_pfnPrintDebugMessageW( WiaDebugSeverityError, m_dwModuleDebugMask, ERROR_FOREGROUND_COLOR, ERROR_BACKGROUND_COLOR, m_szModuleNameW, szMsg );
    }
}

void CWiaDebugClient::PrintTraceMessage( LPCWSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        WCHAR szMsg[1024] = {0};
        va_list arglist;

        va_start( arglist, pszFmt );
        _vsnwprintf( szMsg, ARRAYSIZE(szMsg)-1, pszFmt, arglist );
        va_end( arglist );

        m_pfnPrintDebugMessageW( WiaDebugSeverityNormal, m_dwModuleDebugMask, m_crForegroundColor, DEFAULT_DEBUG_COLOR, m_szModuleNameW, szMsg );
    }
}

void CWiaDebugClient::PrintMessage( DWORD dwSeverity, COLORREF crForegroundColor, COLORREF crBackgroundColor, LPCWSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        WCHAR szMsg[1024] = {0};
        va_list arglist;

        va_start( arglist, pszFmt );
        _vsnwprintf( szMsg, ARRAYSIZE(szMsg)-1, pszFmt, arglist );
        va_end( arglist );

        m_pfnPrintDebugMessageW( dwSeverity, m_dwModuleDebugMask, crForegroundColor, crBackgroundColor, m_szModuleNameW, szMsg );
    }
}


void CWiaDebugClient::PrintHResult( HRESULT hr, LPCWSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        WCHAR szMsg[1024] = {0};
        va_list arglist;

        va_start( arglist, pszFmt );
        _vsnwprintf( szMsg, ARRAYSIZE(szMsg)-1, pszFmt, arglist );
        va_end( arglist );

        DWORD   dwLen = 0;
        LPTSTR  pMsgBuf = NULL;
        dwLen = ::FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                                NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                (LPWSTR)&pMsgBuf, 0, NULL);

        COLORREF crForegroundColor;
        COLORREF crBackgroundColor;
        DWORD    dwSeverity;
        if (FAILED(hr))
        {
            crForegroundColor = ERROR_FOREGROUND_COLOR;
            crBackgroundColor = ERROR_BACKGROUND_COLOR;
            dwSeverity        = WiaDebugSeverityError;
        }
        else if (S_OK == hr)
        {
            crForegroundColor = m_crForegroundColor;
            crBackgroundColor = DEFAULT_DEBUG_COLOR;
            dwSeverity        = WiaDebugSeverityNormal;
        }
        else
        {
            crForegroundColor = WARNING_FOREGROUND_COLOR;
            crBackgroundColor = WARNING_BACKGROUND_COLOR;
            dwSeverity        = WiaDebugSeverityWarning;
        }
        if (dwLen)
        {
            PrintMessage( dwSeverity, crForegroundColor, crBackgroundColor, TEXT("%ws: [0x%08X] %ws"), szMsg, hr, pMsgBuf );
            LocalFree(pMsgBuf);
        }
        else
        {
            PrintMessage( dwSeverity, crForegroundColor, crBackgroundColor, TEXT("%ws: Unable to format message [0x%08X]"), szMsg, hr );
        }
    }
}


void CWiaDebugClient::PrintGuid( const IID &iid, LPCWSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        WCHAR szMsg[1024]=L"";
        va_list arglist;

        va_start( arglist, pszFmt );
        ::wvsprintfW( szMsg, pszFmt, arglist );
        va_end( arglist );

        WCHAR szGuid[MAX_PATH]=L"";
        if (m_pfnGetStringFromGuidW( &iid, szGuid, sizeof(szGuid)/sizeof(szGuid[0]) ) )
        {
            PrintMessage( 0, m_crForegroundColor, DEFAULT_DEBUG_COLOR, TEXT("%ws: %ws"), szMsg, szGuid );
        }
    }
}

void CWiaDebugClient::PrintWindowMessage( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LPCWSTR szMessage )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        WCHAR szWindowMessage[MAX_PATH]=L"";
        if (m_pfnGetStringFromMsgW( uMsg, szWindowMessage, sizeof(szWindowMessage)/sizeof(szWindowMessage[0]) ) )
        {
            PrintMessage( 0, m_crForegroundColor, DEFAULT_DEBUG_COLOR, TEXT("0x%p, %-30ws, 0x%p, 0x%p%ws%ws"), hWnd, szWindowMessage, wParam, lParam, (szMessage && lstrlenW(szMessage)) ? L" : " : L"", (szMessage && lstrlenW(szMessage)) ? szMessage : L"" );
        }
    }
}

////////////////////////////////////////////////////////////////
// ANSI Versions of the output functions
////////////////////////////////////////////////////////////////
void CWiaDebugClient::PrintWarningMessage( LPCSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        CHAR szMsg[1024] = {0};
        va_list arglist;

        va_start( arglist, pszFmt );
        _vsnprintf( szMsg, ARRAYSIZE(szMsg)-1, pszFmt, arglist );
        va_end( arglist );

        m_pfnPrintDebugMessageA( WiaDebugSeverityWarning, m_dwModuleDebugMask, WARNING_FOREGROUND_COLOR, WARNING_BACKGROUND_COLOR, m_szModuleNameA, szMsg );
    }
}

void CWiaDebugClient::PrintErrorMessage( LPCSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        CHAR szMsg[1024] = {0};
        va_list arglist;

        va_start( arglist, pszFmt );
        _vsnprintf( szMsg, ARRAYSIZE(szMsg)-1, pszFmt, arglist );
        va_end( arglist );

        m_pfnPrintDebugMessageA( WiaDebugSeverityError, m_dwModuleDebugMask, ERROR_FOREGROUND_COLOR, ERROR_BACKGROUND_COLOR, m_szModuleNameA, szMsg );
    }
}

void CWiaDebugClient::PrintTraceMessage( LPCSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        CHAR szMsg[1024] = {0};
        va_list arglist;

        va_start( arglist, pszFmt );
        _vsnprintf( szMsg, ARRAYSIZE(szMsg)-1, pszFmt, arglist );
        va_end( arglist );

        m_pfnPrintDebugMessageA( WiaDebugSeverityNormal, m_dwModuleDebugMask, m_crForegroundColor, DEFAULT_DEBUG_COLOR, m_szModuleNameA, szMsg );
    }
}

void CWiaDebugClient::PrintMessage( DWORD dwSeverity, COLORREF crForegroundColor, COLORREF crBackgroundColor, LPCSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        CHAR szMsg[1024] = {0};
        va_list arglist;

        va_start( arglist, pszFmt );
        _vsnprintf( szMsg, ARRAYSIZE(szMsg)-1, pszFmt, arglist );
        va_end( arglist );

        m_pfnPrintDebugMessageA( dwSeverity, m_dwModuleDebugMask, crForegroundColor, crBackgroundColor, m_szModuleNameA, szMsg );
    }
}


void CWiaDebugClient::PrintHResult( HRESULT hr, LPCSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        CHAR szMsg[1024] = {0};
        va_list arglist;

        va_start( arglist, pszFmt );
        _vsnprintf( szMsg, ARRAYSIZE(szMsg)-1, pszFmt, arglist );
        va_end( arglist );

        DWORD   dwLen = 0;
        LPTSTR  pMsgBuf = NULL;
        dwLen = ::FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                                NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                (LPSTR)&pMsgBuf, 0, NULL);

        COLORREF crForegroundColor;
        COLORREF crBackgroundColor;
        DWORD    dwSeverity;
        if (FAILED(hr))
        {
            crForegroundColor = ERROR_FOREGROUND_COLOR;
            crBackgroundColor = ERROR_BACKGROUND_COLOR;
            dwSeverity        = WiaDebugSeverityError;
        }
        else if (S_OK == hr)
        {
            crForegroundColor = m_crForegroundColor;
            crBackgroundColor = DEFAULT_DEBUG_COLOR;
            dwSeverity        = WiaDebugSeverityNormal;
        }
        else
        {
            crForegroundColor = WARNING_FOREGROUND_COLOR;
            crBackgroundColor = WARNING_BACKGROUND_COLOR;
            dwSeverity        = WiaDebugSeverityWarning;
        }
        if (dwLen)
        {
            PrintMessage( dwSeverity, crForegroundColor, crBackgroundColor, TEXT("%hs: [0x%08X] %hs"), szMsg, hr, pMsgBuf );
            LocalFree(pMsgBuf);
        }
        else
        {
            PrintMessage( dwSeverity, crForegroundColor, crBackgroundColor, TEXT("%hs: Unable to format message [0x%08X]"), szMsg, hr );
        }
    }
}


void CWiaDebugClient::PrintGuid( const IID &iid, LPCSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        CHAR szMsg[1024] = {0};
        va_list arglist;

        va_start( arglist, pszFmt );
        _vsnprintf( szMsg, ARRAYSIZE(szMsg)-1, pszFmt, arglist );
        va_end( arglist );

        CHAR szGuid[MAX_PATH]="";
        if (m_pfnGetStringFromGuidA( &iid, szGuid, sizeof(szGuid)/sizeof(szGuid[0]) ) )
        {
            PrintMessage( 0, m_crForegroundColor, DEFAULT_DEBUG_COLOR, TEXT("%hs: %hs"), szMsg, szGuid );
        }
    }
}

void CWiaDebugClient::PrintWindowMessage( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LPCSTR szMessage )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        CHAR szWindowMessage[MAX_PATH]="";
        if (m_pfnGetStringFromMsgA( uMsg, szWindowMessage, sizeof(szWindowMessage)/sizeof(szWindowMessage[0]) ) )
        {
            PrintMessage( 0, m_crForegroundColor, DEFAULT_DEBUG_COLOR, TEXT("0x%p, %-30hs, 0x%p, 0x%p%hs%hs"), hWnd, szWindowMessage, wParam, lParam, (szMessage && lstrlenA(szMessage)) ? " : " : "", (szMessage && lstrlenA(szMessage)) ? szMessage : "" );
        }
    }
}

void CWiaDebugClient::SetInstance( HINSTANCE hInstance )
{
    m_hCurrentModuleInstance = hInstance;
}


static CSimpleString ForceFailureProgramKey( LPCTSTR pszProgramName )
{
    CSimpleString strAppKey( REGSTR_FORCEERR_KEY );
    strAppKey += TEXT("\\");
    strAppKey += pszProgramName;
    return strAppKey;
}

DWORD CWiaDebugClient::GetForceFailurePoint( LPCTSTR pszProgramName )
{
    return CSimpleReg( HKEY_FORCEERROR, ForceFailureProgramKey(pszProgramName) ).Query( REGSTR_ERROR_POINT, 0 );
}
    
HRESULT CWiaDebugClient::GetForceFailureValue( LPCTSTR pszProgramName, bool bPrintWarning )
{
    HRESULT hr = HRESULT_FROM_WIN32(CSimpleReg( HKEY_FORCEERROR, ForceFailureProgramKey(pszProgramName) ).Query( REGSTR_ERROR_VALUE, 0 ));
    if (bPrintWarning)
    {
        g_TheDebugClient.PrintHResult( hr, TEXT("FORCEERR: Forcing error return for program %s"), pszProgramName );
    }
    return hr;
}

void CWiaDebugClient::SetForceFailurePoint( LPCTSTR pszProgramName, DWORD dwErrorPoint )
{
    CSimpleReg( HKEY_FORCEERROR, ForceFailureProgramKey(pszProgramName), true ).Set( REGSTR_ERROR_POINT, dwErrorPoint );
}

void CWiaDebugClient::SetForceFailureValue( LPCTSTR pszProgramName, HRESULT hr )
{
    CSimpleReg( HKEY_FORCEERROR, ForceFailureProgramKey(pszProgramName), true ).Set( REGSTR_ERROR_VALUE, hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\lib\psutil\sources.inc ===
TARGETPATH=$(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\$(_OBJ_DIR)

INCLUDES=   $(INCLUDES);                      \
            $(PROJECT_ROOT)\inc;              \
            $(PROJECT_ROOT)\inc\psutil;       \
            $(SDK_INC_PATH)\gdiplus;          \
            $(SHELL_INC_PATH);

TARGETNAME=psutil
TARGETTYPE=LIBRARY

USE_STL=1

USE_ATL=1
ATL_VER=30

#
# Necessary for gdiplus
#
C_DEFINES=$(C_DEFINES) \
    -DDCR_USE_NEW_105760 \
    -DDCR_USE_NEW_125467 \
    -DDCR_USE_NEW_127084 \
    -DDCR_USE_NEW_135429 \
    -DDCR_USE_NEW_137252 \
    -DDCR_USE_NEW_140782 \
    -DDCR_USE_NEW_140855 \
    -DDCR_USE_NEW_140857 \
    -DDCR_USE_NEW_140861 \
    -DDCR_USE_NEW_145135 \
    -DDCR_USE_NEW_145138 \
    -DDCR_USE_NEW_145139 \
    -DDCR_USE_NEW_145804 \
    -DDCR_USE_NEW_146933 \
    -DDCR_USE_NEW_152154 \
    -DDCR_USE_NEW_168772 \
    -DDCR_USE_NEW_174340 \
    -DDCR_USE_NEW_175866 \
    -DDCR_USE_NEW_186091 \
    -DDCR_USE_NEW_186151 \
    -DDCR_USE_NEW_186764 \
    -DDCR_USE_NEW_188922 \
    -DDCR_USE_NEW_197819 \
    -DDCR_USE_NEW_202903 \
    -DDCR_USE_NEW_235072 \
    -DDCR_USE_NEW_250932 \
    -DDCR_USE_NEW_284635 \
    -DDCR_USE_NEW_284841 \
    -DDCR_USE_NEW_293849 \
    -DDCR_USE_NEW_299162

SOURCES=..\wiadbgcl.cpp \
        ..\gphelper.cpp \
        ..\tmplutil.cpp \
        ..\simreg.cpp   \
        ..\fusutils.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\kernelmode\usbprint\deviceid.c ===
#define DRIVER

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"
#include "deviceid.h"
#include <usb.h>
#include <usbdrivr.h>
#include "usbdlib.h"



#include "usbprint.h"


VOID StringSubst
(
    PUCHAR lpS,
    UCHAR chTargetChar,
    UCHAR chReplacementChar,
    USHORT cbS
)
{
    USHORT  iCnt = 0;

    while ((lpS != '\0') && (iCnt++ < cbS))
        if (*lpS == chTargetChar)
            *lpS++ = chReplacementChar;
        else
            ++lpS;
}

VOID
FixupDeviceId(
    IN OUT PUCHAR DeviceId
    )
/*++

Routine Description:

    This routine parses the NULL terminated string and replaces any invalid
    characters with an underscore character.

    Invalid characters are:
        c <= 0x20 (' ')
        c >  0x7F
        c == 0x2C (',')

Arguments:

    DeviceId - specifies a device id string (or part of one), must be
               null-terminated.

Return Value:

    None.

--*/

{
    PUCHAR p;
    for( p = DeviceId; *p; ++p ) {
        if( (*p <= ' ') || (*p > (UCHAR)0x7F) || (*p == ',') ) {
            *p = '_';
        }
    }
}




NTSTATUS
ParPnpGetId
(
    IN PUCHAR DeviceIdString,
    IN ULONG Type,
    OUT PUCHAR resultString
)
/*
    Description:

        Creates Id's from the device id retrieved from the printer

    Parameters:

        DeviceId - String with raw device id
        Type - What of id we want as a result
        Id - requested id

    Return Value:
        NTSTATUS

*/
{
    NTSTATUS status;
    USHORT          checkSum=0;                     // A 16 bit check sum
    // The following are used to generate sub-strings from the Device ID string
    // to get the DevNode name, and to update the registry
    PUCHAR          MFG = NULL;                   // Manufature name
    PUCHAR          MDL = NULL;                   // Model name
    PUCHAR          CLS = NULL;                   // Class name
    PUCHAR          AID = NULL;                   // Hardare ID
    PUCHAR          CID = NULL;                   // Compatible IDs
    PUCHAR          DES = NULL;                   // Device Description

	USBPRINT_KdPrint2 (("'USBPRINT.SYS: Enter ParPnpGetId\n"));
    status = STATUS_SUCCESS;

    switch(Type) {

    case BusQueryDeviceID:
		 USBPRINT_KdPrint3 (("'USBPRINT.SYS: Inside case BusQueryID, DeviceIdString==%s\n",DeviceIdString));
        // Extract the usefull fields from the DeviceID string.  We want
        // MANUFACTURE (MFG):
        // MODEL (MDL):
        // AUTOMATIC ID (AID):
        // COMPATIBLE ID (CID):
        // DESCRIPTION (DES):
        // CLASS (CLS):

        ParPnpFindDeviceIdKeys(&MFG, &MDL, &CLS, &DES, &AID, &CID, DeviceIdString);
		USBPRINT_KdPrint3 (("'USBPRINT.SYS: After FindDeviceIdKeys\n"));

        // Check to make sure we got MFG and MDL as absolute minimum fields.  If not
        // we cannot continue.
        if (!MFG || !MDL)
        {
            status = STATUS_NOT_FOUND;
			USBPRINT_KdPrint2 (("'USBPRINT.SYS: STATUS_NOT_FOUND\n"));
            goto ParPnpGetId_Cleanup;
        }
        //
        // Concatenate the provided MFG and MDL P1284 fields
        // Checksum the entire MFG+MDL string
        //
        sprintf(resultString, "%s%s\0",MFG,MDL);
        break;

    case BusQueryHardwareIDs:

        GetCheckSum(DeviceIdString, (USHORT)strlen(DeviceIdString), &checkSum);
        sprintf(resultString,"%.20s%04X",DeviceIdString,checkSum);
        break;

    case BusQueryCompatibleIDs:

        //
        // return only 1 id
        //
        GetCheckSum(DeviceIdString, (USHORT)strlen(DeviceIdString), &checkSum);
        sprintf(resultString,"%.20s%04X",DeviceIdString,checkSum);

        break;
    }

    if (Type!=BusQueryDeviceID) {
        //
        // Convert and spaces in the Hardware ID to underscores
        //
        StringSubst ((PUCHAR) resultString, ' ', '_', (USHORT)strlen(resultString));
    }

ParPnpGetId_Cleanup:

    return(status);
}


VOID
ParPnpFindDeviceIdKeys
(
    PUCHAR   *lppMFG,
    PUCHAR   *lppMDL,
    PUCHAR   *lppCLS,
    PUCHAR   *lppDES,
    PUCHAR   *lppAID,
    PUCHAR   *lppCID,
    PUCHAR   lpDeviceID
)
/*

    Description:
        This function will parse a P1284 Device ID string looking for keys
        of interest to the LPT enumerator. Got it from win95 lptenum

    Parameters:
        lppMFG      Pointer to MFG string pointer
        lppMDL      Pointer to MDL string pointer
        lppMDL      Pointer to CLS string pointer
        lppDES      Pointer to DES string pointer
        lppCIC      Pointer to CID string pointer
        lppAID      Pointer to AID string pointer
        lpDeviceID  Pointer to the Device ID string

    Return Value:
        no return VALUE.
        If found the lpp parameters are set to the approprate portions
        of the DeviceID string, and they are NULL terminated.
        The actual DeviceID string is used, and the lpp Parameters just
        reference sections, with appropriate null thrown in.

*/

{
    PUCHAR   lpKey = lpDeviceID;     // Pointer to the Key to look at
    PUCHAR   lpValue;                // Pointer to the Key's value
    USHORT   wKeyLength;             // Length for the Key (for stringcmps)

    // While there are still keys to look at.

    while (lpKey!=NULL)
    {
        while (*lpKey == ' ')
            ++lpKey;

        // Is there a terminating COLON character for the current key?

        if (!(lpValue = StringChr(lpKey, ':')) )
        {
            // N: OOPS, somthing wrong with the Device ID
            return;
        }

        // The actual start of the Key value is one past the COLON

        ++lpValue;

        //
        // Compute the Key length for Comparison, including the COLON
        // which will serve as a terminator
        //

        wKeyLength = (USHORT)(lpValue - lpKey);

        //
        // Compare the Key to the Know quantities.  To speed up the comparison
        // a Check is made on the first character first, to reduce the number
        // of strings to compare against.
        // If a match is found, the appropriate lpp parameter is set to the
        // key's value, and the terminating SEMICOLON is converted to a NULL
        // In all cases lpKey is advanced to the next key if there is one.
        //

        switch (*lpKey)
        {
            case 'M':
                // Look for MANUFACTURE (MFG) or MODEL (MDL)
                if ((RtlCompareMemory(lpKey, "MANUFACTURER", wKeyLength)>5) ||
                    (RtlCompareMemory(lpKey, "MFG", wKeyLength)==3) )
                {
                    *lppMFG = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=NULL)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else if ((RtlCompareMemory(lpKey, "MODEL", wKeyLength)==5) ||
                         (RtlCompareMemory(lpKey, "MDL", wKeyLength)==3) )
                {
                    *lppMDL = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else
                {
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                break;

            case 'C':
                // Look for CLASS (CLS)
                if ((RtlCompareMemory(lpKey, "CLASS", wKeyLength)==5) ||
                    (RtlCompareMemory(lpKey, "CLS", wKeyLength)==3) )
                {
                    *lppCLS = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else if ((RtlCompareMemory(lpKey, "COMPATIBLEID", wKeyLength)>5) ||
                         (RtlCompareMemory(lpKey, "CID", wKeyLength)==3) )
                {
                    *lppCID = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else
                {
                    if ((lpKey = StringChr(lpValue,';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                break;

            case 'D':
                // Look for DESCRIPTION (DES)
                if (RtlCompareMemory(lpKey, "DESCRIPTION", wKeyLength) ||
                    RtlCompareMemory(lpKey, "DES", wKeyLength) )
                {
                    *lppDES = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else
                {
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                break;

            case 'A':
                // Look for AUTOMATIC ID (AID)
                if (RtlCompareMemory(lpKey, "AUTOMATICID", wKeyLength) ||
                    RtlCompareMemory(lpKey, "AID", wKeyLength) )
                {
                    *lppAID = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else
                {
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                break;

            default:
                // The key is uninteresting.  Go to the next Key
                if ((lpKey = StringChr(lpValue, ';'))!=0)
                {
                    *lpKey = '\0';
                    ++lpKey;
                }
                break;
        }
    }
}



VOID
GetCheckSum(
    PUCHAR Block,
    USHORT Len,
    PUSHORT CheckSum
    )
{
    USHORT i;
    USHORT crc = 0;

    unsigned short crc16a[] = {
        0000000,  0140301,  0140601,  0000500,
        0141401,  0001700,  0001200,  0141101,
        0143001,  0003300,  0003600,  0143501,
        0002400,  0142701,  0142201,  0002100,
    };
    unsigned short crc16b[] = {
        0000000,  0146001,  0154001,  0012000,
        0170001,  0036000,  0024000,  0162001,
        0120001,  0066000,  0074000,  0132001,
        0050000,  0116001,  0104001,  0043000,
    };

    //
    // Calculate CRC using tables.
    //

    UCHAR tmp;
    for ( i=0; i<Len;  i++) {
         tmp = Block[i] ^ (UCHAR)crc;
         crc = (crc >> 8) ^ crc16a[tmp & 0x0f] ^ crc16b[tmp >> 4];
    }

    *CheckSum = crc;

}

PUCHAR
StringChr(PCHAR string, CHAR c)
{
    ULONG   i=0;

    if (!string)
        return(NULL);

    while (*string) {
        if (*string==c)
            return(string);
        string++;
        i++;
    }

    return(NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\lib\psutil\simreg.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SIMREG.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/12/1998
 *
 *  DESCRIPTION: Simple registry access class
 *
 *******************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <simreg.h>

CSimpleReg::CSimpleReg( HKEY hkRoot, const CSimpleString &strSubKey, bool bCreate, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpsa )
  : m_strKeyName(strSubKey),
    m_hRootKey(hkRoot),
    m_hKey(NULL),
    m_bCreate(bCreate),
    m_lpsaSecurityAttributes(lpsa),
    m_samDesiredAccess(samDesired)
{
    Open();
}

CSimpleReg::CSimpleReg(void)
  : m_strKeyName(TEXT("")),
    m_hRootKey(NULL),
    m_hKey(NULL),
    m_bCreate(false),
    m_lpsaSecurityAttributes(NULL),
    m_samDesiredAccess(0)
{
}

CSimpleReg::CSimpleReg(const CSimpleReg &other)
  : m_strKeyName(other.GetSubKeyName()),
    m_hRootKey(other.GetRootKey()),
    m_hKey(NULL),
    m_bCreate(other.GetCreate()),
    m_lpsaSecurityAttributes(other.GetSecurityAttributes()),
    m_samDesiredAccess(other.DesiredAccess())
{
    Open();
}

CSimpleReg::~CSimpleReg(void)
{
    Close();
    m_hRootKey = NULL;
    m_lpsaSecurityAttributes = NULL;
}

CSimpleReg &CSimpleReg::operator=(const CSimpleReg &other )
{
    if (this != &other)
    {
        Close();
        m_strKeyName = other.GetSubKeyName();
        m_hRootKey = other.GetRootKey();
        m_bCreate = other.GetCreate();
        m_lpsaSecurityAttributes = other.GetSecurityAttributes();
        m_samDesiredAccess = other.DesiredAccess();
        Open();
    }
    return *this;
}

bool CSimpleReg::Open(void)
{
    HKEY hkKey = NULL;
    LONG nRet;
    DWORD bCreatedNewKey = 0;

    Close();
    if (m_bCreate)
    {
        nRet = RegCreateKeyEx( m_hRootKey, m_strKeyName.String(), 0, TEXT(""), REG_OPTION_NON_VOLATILE, m_samDesiredAccess?m_samDesiredAccess:KEY_ALL_ACCESS, m_lpsaSecurityAttributes, &hkKey, &bCreatedNewKey );
    }
    else
    {
        nRet = RegOpenKeyEx( m_hRootKey, m_strKeyName.String(), 0, m_samDesiredAccess ? m_samDesiredAccess : KEY_ALL_ACCESS, &hkKey );
    }

    if (nRet == ERROR_SUCCESS)
    {
        m_hKey = hkKey;
    }

    return m_hKey != NULL;
}

bool CSimpleReg::Close(void)
{
    //
    // In case the key was closed by someone else
    //
    __try
    {
        if (OK())
        {
            RegCloseKey(m_hKey);
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
#ifdef DBG
        OutputDebugString(TEXT("CSimpleReg::Close(): An exception occurred while closing the handle.  Make sure the handle wasn't already freed."));
        DebugBreak();
#endif
    }
    m_hKey = NULL;
    
    return true;
}

bool CSimpleReg::Flush(void)
{
    if (!OK())
    {
        return false;
    }
    return (ERROR_SUCCESS == RegFlushKey(m_hKey));
}

bool CSimpleReg::IsStringValue( DWORD nType )
{
    if (nType != REG_SZ && nType != REG_EXPAND_SZ && nType != REG_MULTI_SZ && nType != REG_LINK && nType != REG_RESOURCE_LIST)
    {
        return false;
    }
    else return true;
}

// Query functions
DWORD CSimpleReg::Size( const CSimpleString &strValueName ) const
{
    if (!OK())
    {
        return 0;
    }
    DWORD nType;
    DWORD nSize=0;
    LONG Ret = RegQueryValueEx( m_hKey, strValueName.String(), NULL, &nType, NULL, &nSize);
    if (Ret==ERROR_SUCCESS)
    {
        return nSize;
    }
    return 0;
}

DWORD CSimpleReg::Type( const CSimpleString &key ) const
{
    if (!OK())
    {
        return 0;
    }
    DWORD dwType;
    DWORD dwSize;
    LONG Ret = RegQueryValueEx( m_hKey, key.String(), NULL, &dwType, NULL, &dwSize);
    if (Ret==ERROR_SUCCESS)
    {
        return dwType;
    }
    return 0;
}


CSimpleString CSimpleReg::Query( const CSimpleString &strValueName, const CSimpleString &strDef ) const
{
    // If the key is not open, or if this value is not a string type, return the default
    if (!OK() || !IsStringValue(Type(strValueName)))
    {
        return strDef;
    }
    DWORD nSize = Size(strValueName) / sizeof(TCHAR);
    //
    //  NOTE: There are some cases when components (e.g. usbscan.sys) write a string value to the registry, 
    //          and dont NULL terminate it correctly.  Now nSize contains the number of characters, NOT 
    //          including the NULL terminator.  To get around this, we actually allocate one more 
    //          character than needed.  Then, after reading in up to a maximum of nSize characters, we 
    //          set the extra character to TEXT('\0), ensuring that our string is always NULL terminated
    //          correctly, without losing the last character (which would happen if we simply allocated
    //          nSize and set lpszTmp[nSize-1] to TEXT('\0')).
    //
    LPTSTR lpszTmp = nSize ? new TCHAR[nSize + 1] : NULL;
    CSimpleString strTmp;
    if (lpszTmp)
    {
        Query( strValueName, strDef, lpszTmp, nSize );
        
        //
        //  Ensure that we are correctly NULL terminated.  Note that we null out the extra character
        //  allocated for us - not any of the actual data.
        //
        lpszTmp[nSize] = TEXT('\0');
        strTmp = lpszTmp;

        delete[] lpszTmp;
    }
    return strTmp;
}

LPTSTR CSimpleReg::Query( const CSimpleString &strValueName, const CSimpleString &strDef, LPTSTR pszBuffer, DWORD nLen ) const
{
    //
    // If the programmer passes 0 for some reason, return NULL
    //
    if (!nLen)
    {
        return NULL;
    }

    //
    // Initialize the result
    //
    *pszBuffer = 0;

    //
    // If the key is not open, or if this value is not a string type, return the default
    //
    if (!OK() || !IsStringValue(Type(strValueName)))
    {
        //
        // Make sure we have a valid default string
        //
        if (strDef.String())
        {
            lstrcpyn( pszBuffer, strDef.String(), nLen );
        }

        //
        // Early return
        //
        return pszBuffer;
    }

    DWORD nSize = (DWORD)(nLen * sizeof(pszBuffer[0]));
    DWORD nType;
    LONG nRet = RegQueryValueEx( m_hKey, strValueName.String(), NULL, &nType, (PBYTE)pszBuffer, &nSize );
    if (ERROR_SUCCESS != nRet)
    {
        lstrcpyn( pszBuffer, strDef.String(), nLen );
        pszBuffer[nLen-1] = TEXT('\0');
    }
    return pszBuffer;
}

DWORD CSimpleReg::Query( const CSimpleString &strValueName, DWORD nDef ) const
{
    if (!OK() || (REG_DWORD != Type(strValueName)) || (sizeof(DWORD) != Size(strValueName)))
    {
        return nDef;
    }
    DWORD nValue;
    DWORD nType;
    DWORD nSize = sizeof(DWORD);
    LONG nRet;
    nRet = RegQueryValueEx( m_hKey, strValueName.String(), NULL, &nType, (PBYTE)&nValue, &nSize);
    if (ERROR_SUCCESS == nRet)
    {
        return nValue;
    }
    else
    {
        return nDef;
    }
}


bool CSimpleReg::Set( const CSimpleString &strValueName, const CSimpleString &strValue, DWORD nType ) const
{  // Set a REG_SZ value for the specified key.
    if (!OK())
    {
        return false;
    }
    LONG nRet;
    nRet = RegSetValueEx( m_hKey, strValueName.String(), 0, nType, (PBYTE)strValue.String(), sizeof(strValue[0])*(strValue.Length()+1) );
    return (ERROR_SUCCESS==nRet);
}

bool CSimpleReg::Set( const CSimpleString &strValueName, DWORD nValue ) const
{  // Set a REG_SZ value for the specified key.
    if (!OK())
        return false;
    LONG nRet;
    nRet = RegSetValueEx( m_hKey, strValueName.String(), 0, REG_DWORD, (PBYTE)&nValue, sizeof(DWORD) );
    return (ERROR_SUCCESS==nRet);
}

DWORD CSimpleReg::QueryBin( const CSimpleString &strValueName, PBYTE pData, DWORD nMaxLen ) const
{
    if (!OK())
    {
        return 0;
    }
    if (nMaxLen <= 0)
    {
        return Size(strValueName.String());
    }
    DWORD nType;
    DWORD nSize = nMaxLen;
    LONG nRet = RegQueryValueEx( m_hKey, strValueName.String(), NULL, &nType, pData, &nSize );
    if (ERROR_SUCCESS!=nRet)
    {
        return 0;
    }
    return nSize;
}

bool CSimpleReg::SetBin( const CSimpleString &strValueName, const PBYTE pValue, DWORD nLen, DWORD dwType ) const
{
    if (!OK())
        return false;
    LONG nRet = RegSetValueEx( m_hKey, strValueName.String(), 0, dwType, (PBYTE)pValue, nLen );
    return (ERROR_SUCCESS==nRet);
}

DWORD CSimpleReg::SubKeyCount(void) const
{
    TCHAR szClass[256]=TEXT("");
    DWORD nClassSize = sizeof(szClass)/sizeof(szClass[0]);
    DWORD nSubKeyCount=0;
    RegQueryInfoKey(m_hKey,szClass,&nClassSize,NULL,&nSubKeyCount,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
    return nSubKeyCount;
}

HKEY CSimpleReg::GetHkeyFromName( const CSimpleString &strName )
{
    static const struct
    {
        LPCTSTR pszName;
        HKEY hkKey;
    } KeyNames[] =
    {
        { TEXT("HKEY_CLASSES_ROOT"),   HKEY_CLASSES_ROOT},
        { TEXT("HKEY_CURRENT_USER"),   HKEY_CURRENT_USER},
        { TEXT("HKEY_LOCAL_MACHINE"),  HKEY_LOCAL_MACHINE},
        { TEXT("HKEY_USERS"),          HKEY_USERS},
        { TEXT("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG},
        { TEXT("HKEY_DYN_DATA"),       HKEY_DYN_DATA},
        { TEXT("HKCR"),                HKEY_CLASSES_ROOT},
        { TEXT("HKCU"),                HKEY_CURRENT_USER},
        { TEXT("HKLM"),                HKEY_LOCAL_MACHINE},
        { TEXT("HKU"),                 HKEY_USERS},
        { TEXT("HKCC"),                HKEY_CURRENT_CONFIG},
        { TEXT("HKDD"),                HKEY_DYN_DATA},
        { NULL, NULL}
    };
    for (int i=0;KeyNames[i].pszName;i++)
    {
        if (!lstrcmpi(strName.String(),KeyNames[i].pszName))
        {
            return KeyNames[i].hkKey;
        }
    }
    return NULL;
}

bool CSimpleReg::Delete( HKEY hkRoot, const CSimpleString &strKeyName )
{
    return (RegDeleteKey(hkRoot, strKeyName.String()) == ERROR_SUCCESS);
}

bool CSimpleReg::Delete( const CSimpleString &strValue )
{
    if (!OK())
    {
        return false;
    }
    return (RegDeleteValue( m_hKey, strValue.String() ) == ERROR_SUCCESS);
}

bool CSimpleReg::DeleteRecursively( HKEY hkRoot, const CSimpleString &strKeyName )
{
    if (CSimpleReg( hkRoot, strKeyName ).RecurseKeys( DeleteEnumKeyProc, NULL, CSimpleReg::PostOrder ))
    {
        return CSimpleReg::Delete( hkRoot, strKeyName );
    }
    return false;
}

bool CSimpleReg::EnumValues( SimRegValueEnumProc enumProc, LPARAM lParam )
{
    TCHAR szName[256];
    DWORD nSize;
    DWORD nType;
    bool bResult = true;
    for (int i=0;;i++)
    {
        nSize = sizeof(szName) / sizeof(szName[0]);
        if (RegEnumValue(m_hKey,i,szName,&nSize,NULL,&nType,NULL,NULL) != ERROR_SUCCESS)
            break;
        CValueEnumInfo info(*this,szName,nType,nSize,lParam);
        if (enumProc)
        {
            if (!enumProc(info))
            {
                bResult = false;
                break;
            }
        }
    }
    return bResult;
}

bool CSimpleReg::RecurseKeys( SimRegKeyEnumProc enumProc, LPARAM lParam, int recurseOrder, bool bFailOnOpenError ) const
{
    return DoRecurseKeys(m_hKey, TEXT(""), enumProc, lParam, 0, recurseOrder, bFailOnOpenError );
}

bool CSimpleReg::EnumKeys( SimRegKeyEnumProc enumProc, LPARAM lParam, bool bFailOnOpenError ) const
{
    return DoEnumKeys(m_hKey, TEXT(""), enumProc, lParam, bFailOnOpenError );
}

bool CSimpleReg::DoRecurseKeys( HKEY hkKey, const CSimpleString &root, SimRegKeyEnumProc enumProc, LPARAM lParam, int nLevel, int recurseOrder, bool bFailOnOpenError )
{
    TCHAR szName[256]=TEXT("");
    DWORD nNameSize;
    TCHAR szClass[256]=TEXT("");
    DWORD nClassSize;
    FILETIME ftFileTime;
    CSimpleReg reg(hkKey,root);
    if (!reg.OK())
    {
        return (bFailOnOpenError ? false : true);
    }
    DWORD nSubKeyCount = reg.SubKeyCount();
    for (DWORD i=nSubKeyCount;i>0;i--)
    {
        nNameSize = sizeof(szName)/sizeof(szName[0]);
        nClassSize = sizeof(szClass)/sizeof(szClass[0]);
        
        LONG lRes = RegEnumKeyEx(reg.GetKey(),i-1,szName,&nNameSize,NULL,szClass,&nClassSize,&ftFileTime);
        if (lRes != ERROR_SUCCESS)
        {
            break;
        }
        CKeyEnumInfo EnumInfo;
        EnumInfo.strName = szName;
        EnumInfo.hkRoot = reg.GetKey();
        EnumInfo.nLevel = nLevel;
        EnumInfo.lParam = lParam;
        if (enumProc && recurseOrder==PreOrder)
        {
            if (!enumProc(EnumInfo))
            {
                return false;
            }
        }
        if (!DoRecurseKeys(reg.GetKey(),szName,enumProc,lParam,nLevel+1,recurseOrder, bFailOnOpenError))
        {
            return false;
        }
        if (enumProc && recurseOrder==PostOrder)
        {
            if (!enumProc(EnumInfo))
            {
                return false;
            }
        }
    }
    return true;
}

bool CSimpleReg::DoEnumKeys( HKEY hkKey, const CSimpleString &root, SimRegKeyEnumProc enumProc, LPARAM lParam, bool bFailOnOpenError )
{
    TCHAR szName[256]=TEXT("");
    DWORD szNameSize;
    TCHAR szClass[256]=TEXT("");
    DWORD szClassSize;
    FILETIME ftFileTime;
    CSimpleReg reg(hkKey,root);
    LONG lRes;
    if (!reg.OK())
    {
        return (bFailOnOpenError ? false : true);
    }
    DWORD nSubKeyCount = reg.SubKeyCount();
    for (DWORD i=nSubKeyCount;i>0;i--)
    {
        szNameSize = sizeof(szName)/sizeof(szName[0]);
        szClassSize = sizeof(szClass)/sizeof(szClass[0]);
        if ((lRes=RegEnumKeyEx(reg.GetKey(),i-1,szName,&szNameSize,NULL,szClass,&szClassSize,&ftFileTime)) != ERROR_SUCCESS)
        {
            break;
        }
        CKeyEnumInfo EnumInfo;
        EnumInfo.strName = szName;
        EnumInfo.hkRoot = reg.GetKey();
        EnumInfo.nLevel = 0;
        EnumInfo.lParam = lParam;
        if (!enumProc(EnumInfo))
        {
            return false;
        }
    }
    return true;
}

bool CSimpleReg::DeleteEnumKeyProc( CSimpleReg::CKeyEnumInfo &enumInfo )
{
    return CSimpleReg::Delete( enumInfo.hkRoot, enumInfo.strName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\kernelmode\usbprint\deviceid.h ===
VOID StringSubst (
    IN OUT  PUCHAR lpS,
    IN      UCHAR chTargetChar,
    IN      UCHAR chReplacementChar,
    IN      USHORT cbS
    );

VOID
FixupDeviceId(
    IN OUT PUCHAR DeviceId
    );

NTSTATUS
ParPnpGetId (
    IN  PUCHAR  DeviceIdString,
    IN  ULONG   Type,
    OUT PUCHAR  resultString
    );

VOID
ParPnpFindDeviceIdKeys (
    OUT PUCHAR   *lppMFG,
    OUT PUCHAR   *lppMDL,
    OUT PUCHAR   *lppCLS,
    OUT PUCHAR   *lppDES,
    OUT PUCHAR   *lppAID,
    OUT PUCHAR   *lppCID,
    IN  PUCHAR   lpDeviceID
    );

VOID
GetCheckSum (
    IN  PUCHAR  Block,
    IN  USHORT  Len,
    OUT PUSHORT CheckSum
    );

PUCHAR
StringChr (
    IN  PCHAR string,
    IN  CHAR c
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\kernelmode\usbprint\ioctl.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   ioctl.c

Abstract:

    Device driver for USB printers

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5-4-96 : created

--*/

#define DRIVER

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include <usb.h>
#include <usbdrivr.h>
#include "usbdlib.h"
#include "usbprint.h"

#include "ioctl.h"
#include "usbdlib.h"
#include "ntddpar.h"


int USBPRINT_GetLptStatus(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS HPUsbIOCTLVendorSetCommand(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp);
NTSTATUS HPUsbIOCTLVendorGetCommand(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp);
NTSTATUS HPUsbVendorSetCommand(IN PDEVICE_OBJECT DeviceObject,IN PUCHAR buffer,IN ULONG  length);
NTSTATUS HPUsbVendorGetCommand(IN PDEVICE_OBJECT DeviceObject,IN PUCHAR buffer,IN ULONG  length,OUT PULONG pBytesRead);

NTSTATUS USBPRINT_SoftReset(IN PDEVICE_OBJECT DeviceObject)
/*++

Routine Description:
  Issues the class specific "Soft reset" command to the printer

Arguments:

    DeviceObject - pointer to the device object for this instance of the printer device.


Return Value:

  ntStatus of the URB

--*/
{
    NTSTATUS ntStatus;
    PURB urb;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = NULL;
    PDEVICE_EXTENSION deviceExtension;
    LARGE_INTEGER   timeOut;

    USBPRINT_KdPrint2 (("'USBPRINT.SYS: enter USBPRINT_SoftReset\n"));

        deviceExtension = DeviceObject->DeviceExtension;
    urb = ExAllocatePoolWithTag(NonPagedPool,sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), USBP_TAG);

    if (urb) {
        UsbBuildVendorRequest(urb, //urb
                                          URB_FUNCTION_CLASS_INTERFACE, //request target
                                          sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), //request len
                                                          USBD_TRANSFER_DIRECTION_OUT|USBD_SHORT_TRANSFER_OK, //flags
                                                          0, //reserved bits
                                                          2, //request code
                                                          0,  //wValue
                                                          deviceExtension->Interface->InterfaceNumber<<8, //wIndex
                                                          NULL, //return buffer address
                                                          NULL, //mdl
                                                          0, //return length
                                                          NULL); //link param

        timeOut.QuadPart = FAILURE_TIMEOUT;
                ntStatus = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);
                USBPRINT_KdPrint3 (("'USBPRINT.SYS: urb->Hdr.Status=%d\n",((struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *)urb)->Hdr.Status));

        if (NT_SUCCESS(ntStatus)    &&
            urb->UrbControlVendorClassRequest.TransferBufferLength > 2)
        {
            USBPRINT_KdPrint3 (("'USBPRINT.SYS: CallUSBD succeeded\n"));
        }
        else
        {
          USBPRINT_KdPrint1(("'USBPRINT.SYS: Error;  CallUSBD failed"));
        }
        ExFreePool(urb);
        } /*end if URB OK*/
        else
      {
         USBPRINT_KdPrint1(("'USBPRINT.SYS: Error;  urb allocation failed"));
         ntStatus=STATUS_NO_MEMORY;
      }
    return ntStatus;
} /*end function Get1284_Id*/



int USBPRINT_Get1284Id(IN PDEVICE_OBJECT DeviceObject,PVOID pIoBuffer,int iLen)
/*++

Routine Description:
  Requests and returns Printer 1284 Device ID

Arguments:

    DeviceObject - pointer to the device object for this instance of the printer device.
        pIoBuffer    - pointer to IO buffer from user mode
        iLen         - Length of *pIoBuffer;




Return Value:

    Success: Length of data written to *pIoBuffer (icluding lenght field in first two bytes of data)
        Failure: -1

--*/
{
    NTSTATUS ntStatus;
    PURB urb;
    ULONG siz;
    int iReturn = -1;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = NULL;
    PDEVICE_EXTENSION deviceExtension;
    LARGE_INTEGER   timeOut;

    USBPRINT_KdPrint2 (("'USBPRINT.SYS: enter USBPRINT_Get1284\n"));

        deviceExtension = DeviceObject->DeviceExtension;
    urb = ExAllocatePoolWithTag(NonPagedPool,sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), USBP_TAG);

    if (urb) {
        siz = iLen;
        UsbBuildVendorRequest(urb, //urb

                                          URB_FUNCTION_CLASS_INTERFACE, //request target
                                          sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), //request len
                                                          USBD_TRANSFER_DIRECTION_IN|USBD_SHORT_TRANSFER_OK, //flags
                                                          0, //reserved bits
                                                          0, //request code
                                                          0,  //wValue
                                                          deviceExtension->Interface->InterfaceNumber<<8, //wIndex
                                                          pIoBuffer, //return buffer address
                                                          NULL, //mdl
                                                          iLen, //return length
                                                          NULL); //link param

        timeOut.QuadPart = FAILURE_TIMEOUT;
        ntStatus = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);
        USBPRINT_KdPrint3 (("'USBPRINT.SYS: urb->Hdr.Status=%d\n",((struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *)urb)->Hdr.Status));

        if (NT_SUCCESS(ntStatus)    &&
            urb->UrbControlVendorClassRequest.TransferBufferLength > 2)
        {
            USBPRINT_KdPrint3 (("'USBPRINT.SYS: CallUSBD succeeded\n"));
            iReturn= *((unsigned char *)pIoBuffer);
            iReturn<<=8;
            iReturn+=*(((unsigned char *)pIoBuffer)+1);
            if ( iReturn > 0 && iReturn < iLen )
            {

                *(((char *)pIoBuffer)+iReturn)='\0';
                USBPRINT_KdPrint3 (("'USBPRINT.SYS: return size ==%d\n",iReturn));
            }
            else
            {
                iReturn = -1;
            }
        }
        else
                {
                        USBPRINT_KdPrint1(("'USBPRINT.SYS: Error;  CallUSBD failed\n"));
                        iReturn=-1;
                }
        ExFreePool(urb);
        } /*end if URB OK*/
        else
        {
                USBPRINT_KdPrint1(("'USBPRINT.SYS: Error;  urb allocation failed"));
                iReturn=-1;
        }
    return iReturn;
} /*end function Get1284_Id*/

int USBPRINT_GetLptStatus(IN PDEVICE_OBJECT DeviceObject)
/*++

Routine Description:
  Requests and returns Printer status byte from USB printer

Arguments:

    DeviceObject - pointer to the device object for this instance of the printer   device.


Return Value:

    Success: status value 0-255
        Failure: -1

--*/
{

    NTSTATUS ntStatus;
    PURB urb;
    ULONG siz;
        unsigned char RETURN_BUFF[1];
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = NULL;
    PDEVICE_EXTENSION deviceExtension;
    LARGE_INTEGER   timeOut;


    RETURN_BUFF[0] = 0;

    timeOut.QuadPart = FAILURE_TIMEOUT;

        deviceExtension = DeviceObject->DeviceExtension;
    urb = ExAllocatePoolWithTag(NonPagedPool,sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), USBP_TAG);

    if (urb) {


        siz = sizeof(RETURN_BUFF);


        UsbBuildVendorRequest(urb,
                                          URB_FUNCTION_CLASS_INTERFACE,
                                          sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
                                                          USBD_TRANSFER_DIRECTION_IN|USBD_SHORT_TRANSFER_OK,
                                                          0, //reserved bits
                                                          1, //request code
                                                          0,
                                                          deviceExtension->Interface->InterfaceNumber,
                                                          RETURN_BUFF, //return buffer address
                                                          NULL, //mdl
                                                          sizeof(RETURN_BUFF), //return length
                                                          NULL); //link param


                ntStatus = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);
                USBPRINT_KdPrint3 (("'USBPRINT.SYS: urb->Hdr.Status=%d\n",((struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *)urb)->Hdr.Status));
                ExFreePool(urb);

        if (NT_SUCCESS(ntStatus))
                {
                        USBPRINT_KdPrint3 (("'USBPRINT.SYS: CallUSBD succeeded\n"));
                        return (int) RETURN_BUFF[0];
                }
                else
                {
                        USBPRINT_KdPrint1(("'USBPRINT.SYS: Error;  CallUSBD failed"));
            return -1;
                }
        } /*end if URB OK*/
    else {
        return -1;
    }

} /*end function GetLptStatus*/


NTSTATUS
USBPRINT_GetPortStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PULONG PortStatus
    )
/*++

Routine Description:

    returns the port status for our device

Arguments:

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION deviceExtension;

    USBPRINT_KdPrint2 (("'USBPRINT.SYS: enter USBPRINT_GetPortStatus\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    *PortStatus = 0;

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_GET_PORT_STATUS,
                deviceExtension->TopOfStackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);
    if(irp==NULL)
    {
        ioStatus.Status=STATUS_NO_MEMORY;
        goto GetPortStatusDone;

    }

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = PortStatus;

    USBPRINT_KdPrint3 (("'USBPRINT.SYS: calling USBD port status api\n"));

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                            irp);

    USBPRINT_KdPrint3 (("'USBPRINT.SYS: return from IoCallDriver USBD (in getportstatus)%x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {

        USBPRINT_KdPrint3 (("'USBPRINT.SYS: Wait for single object\n"));

        status = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);

        USBPRINT_KdPrint3 (("'USBPRINT.SYS: Wait for single object, returned %x\n", status));

    } else {
        ioStatus.Status = ntStatus;
    }

         if (!NT_SUCCESS(ntStatus))
         {
           USBPRINT_KdPrint1 (("'USBPRINT.SYS: Error! IoCallDriver failed\n"));
         }
         else
         {
           USBPRINT_KdPrint3 (("'USBPRINT.SYS: Success! IoCallDriver did not fail\n"));
         }


    USBPRINT_KdPrint3 (("'USBPRINT.SYS: Port status = %x\n", *PortStatus));

    //
    // USBD maps the error code for us
    //
    GetPortStatusDone:
    ntStatus = ioStatus.Status;

    USBPRINT_KdPrint3 (("'USBPRINT.SYS: USBPRINT_GetPortStatus (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBPRINT_ResetParentPort(
    IN IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Reset the our parent port

Arguments:

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION deviceExtension;

    USBPRINT_KdPrint2 (("'USBPRINT.SYS: enter USBPRINT_ResetPort\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_RESET_PORT,
                deviceExtension->TopOfStackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    if(irp==NULL)
    {
        ioStatus.Status=STATUS_NO_MEMORY;
        goto ResetPortDone;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    USBPRINT_KdPrint3 (("'USBPRINT.SYS: calling USBD enable port api\n"));

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                            irp);

    USBPRINT_KdPrint3 (("'USBPRINT.SYS: return from IoCallDriver USBD (in reset parent port)%x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {

        USBPRINT_KdPrint3 (("'USBPRINT.SYS: Wait for single object\n"));

        status = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);

        USBPRINT_KdPrint3 (("'USBPRINT.SYS: Wait for single object, returned %x\n", status));

    } else {
        ioStatus.Status = ntStatus;
    }

    //
    // USBD maps the error code for us
    //
    ResetPortDone:
    ntStatus = ioStatus.Status;

    USBPRINT_KdPrint3 (("'USBPRINT.SYS: USBPRINT_ResetPort (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBPRINT_ProcessIOCTL(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to the device object for this printer


Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpStack;
    PVOID ioBuffer;
    ULONG inputBufferLength;
    ULONG outputBufferLength;
    PDEVICE_EXTENSION deviceExtension;
    ULONG ioControlCode;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    PUCHAR pch;

    USBPRINT_KdPrint2 (("'USBPRINT.SYS: IRP_MJ_DEVICE_CONTROL\n"));

    USBPRINT_IncrementIoCount(DeviceObject);

    //
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    //

    deviceExtension = DeviceObject->DeviceExtension;

    if (deviceExtension->IsChildDevice == TRUE) 
    {
        ntStatus = STATUS_NOT_SUPPORTED;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp,IO_NO_INCREMENT);
        USBPRINT_DecrementIoCount(DeviceObject);
        return ntStatus;
    }

    if (deviceExtension->AcceptingRequests == FALSE) 
    {
        ntStatus = STATUS_DEVICE_DATA_ERROR;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp,IO_NO_INCREMENT);
        USBPRINT_DecrementIoCount(DeviceObject);
        return ntStatus;
    }

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    Irp->IoStatus.Information = 0;

    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

    //
    // Handle Ioctls from User mode
    //

    switch (ioControlCode) {


    case IOCTL_PAR_QUERY_DEVICE_ID:
    {
        int iReturn;
        char * pTempBuffer;


        USBPRINT_KdPrint1 (("'USBPRINT.SYS: Enter in PAR_QUERY_DEVICE_ID\n"));

        pTempBuffer=ExAllocatePool(NonPagedPool,outputBufferLength+3); //3 == 2 bytes for the size at the beginning, plus 1 for the null at the end
        if(pTempBuffer==NULL)
        {
                         Irp->IoStatus.Information=0;
                         ntStatus=STATUS_NO_MEMORY;
        }
        else
        {
                   iReturn=USBPRINT_Get1284Id(DeviceObject,pTempBuffer,outputBufferLength+2);
                   if(iReturn>0)
                   {
                         USBPRINT_KdPrint3 (("'USBPRINT.SYS: Success in PAR_QUERY_DEVICE_ID\n"));
                         Irp->IoStatus.Information=iReturn-1;
             *(pTempBuffer+iReturn)='\0';
             RtlCopyBytes(ioBuffer,pTempBuffer+2,iReturn-1); //+2 to step past the size bytes at the beginning, -1 is +1 for null -2 for size bytes
                         ntStatus=STATUS_SUCCESS;
                   } /*if success*/
                   else
                   {
                         USBPRINT_KdPrint1 (("'USBPRINT.SYS: Failure in PAR_QUERY_DEVICE_ID\n"));
                         Irp->IoStatus.Information=0;
                         ntStatus=STATUS_DEVICE_DATA_ERROR;
                   } /*else failure*/
           ExFreePool(pTempBuffer);
        } /*end else malloc OK*/
        USBPRINT_KdPrint1 (("'USBPRINT.SYS: Exit in PAR_QUERY_DEVICE_ID\n"));
    }
    break;

    case IOCTL_USBPRINT_SOFT_RESET:

        ntStatus=USBPRINT_SoftReset(DeviceObject);

        Irp->IoStatus.Information=0;
    break;



    case IOCTL_USBPRINT_GET_1284_ID:
        {
                 int iReturn;

                 pch = (PUCHAR) ioBuffer;

                 if(outputBufferLength<sizeof(UCHAR))
                 {
                   USBPRINT_KdPrint1 (("'USBPRINT.SYS: Buffer to small in GET_1284_ID\n"));
                   Irp->IoStatus.Information=0;
                   ntStatus=STATUS_BUFFER_TOO_SMALL;
                 }
                 else
                 {
                   iReturn=USBPRINT_Get1284Id(DeviceObject,ioBuffer,outputBufferLength);
                   if(iReturn>=0)
                   {
                         USBPRINT_KdPrint3 (("'USBPRINT.SYS: Success in GET_1284_ID\n"));
                         *pch=(UCHAR)iReturn;
                         Irp->IoStatus.Information=iReturn;
                         ntStatus=STATUS_SUCCESS;
                   } /*if success*/
                   else
                   {
                         USBPRINT_KdPrint1 (("'USBPRINT.SYS: Failure in GET_1284_ID\n"));
                         Irp->IoStatus.Information=0;
                         ntStatus=STATUS_DEVICE_DATA_ERROR;
                   } /*else failure*/
                 } /*end else buffer len OK*/
        }
        break; //end case GET_1284_ID

        case IOCTL_USBPRINT_GET_LPT_STATUS:
        {
                 int iReturn;
                 pch = (PUCHAR) ioBuffer;

                 if(outputBufferLength<sizeof(UCHAR))
                 {
                   USBPRINT_KdPrint1 (("'USBPRINT.SYS: Buffer to small in GET_LPT_STATUS\n"));
                   Irp->IoStatus.Information=0;
                   ntStatus=STATUS_BUFFER_TOO_SMALL;
                 }
                 else
                 {
                   iReturn= USBPRINT_GetLptStatus(DeviceObject);
                   if(iReturn>=0)
                   {
                         USBPRINT_KdPrint3 (("'USBPRINT.SYS: Success in GET_LPT_STATUS\n"));
                         *pch=(UCHAR)iReturn;
                         Irp->IoStatus.Information=1;
                         ntStatus=STATUS_SUCCESS;
                   } /*if success*/
                   else
                   {
                         USBPRINT_KdPrint1 (("'USBPRINT.SYS: Failure in GET_LPT_STATUS\n"));
                         Irp->IoStatus.Information=0;
                         ntStatus=STATUS_DEVICE_DATA_ERROR;
                   } /*else failure*/
                 } /*end else buffer OK*/
        }
        break;


    case IOCTL_USBPRINT_VENDOR_SET_COMMAND:

        ntStatus=HPUsbIOCTLVendorSetCommand(DeviceObject,Irp);

    break;


    case IOCTL_USBPRINT_VENDOR_GET_COMMAND:

        ntStatus=HPUsbIOCTLVendorGetCommand(DeviceObject,Irp);

    break;


    case IOCTL_USBPRINT_RESET_DEVICE:

        {
        ULONG portStatus;

        USBPRINT_KdPrint3 (("'USBPRINT.SYS: Reset Device Test\n"));

        TRAP(); // test this
        //
        // Check the port state, if it is disabled we will need
        // to re-enable it
        //
        ntStatus = USBPRINT_GetPortStatus(DeviceObject, &portStatus);

          if (NT_SUCCESS(ntStatus) && !(portStatus & USBD_PORT_ENABLED) &&portStatus & USBD_PORT_CONNECTED)
                  {
            //
            // port is disabled, attempt reset   
            //
            //USBPRINT_EnableParentPort(DeviceObject);
                        USBPRINT_KdPrint2 (("'USBPRINT.SYS: Resetting port\n"));
            USBPRINT_ResetParentPort(DeviceObject);
                  }

        }
        break;


    default:

        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    Irp->IoStatus.Status = ntStatus;

    IoCompleteRequest (Irp,
                       IO_NO_INCREMENT
                       );

    USBPRINT_DecrementIoCount(DeviceObject);

    return ntStatus;

}







/****************STUFF FROM HP:*************************/

/*-------------------------------------------------------------------------------
 * HPUsbIOCTLVendorSetCommand() - Send a vendor defined SET command
 *-------------------------------------------------------------------------------
 */
NTSTATUS HPUsbIOCTLVendorSetCommand(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp)
{
        // Local Variables
    NTSTATUS                    ntStatus;
    PIO_STACK_LOCATION  currentIrpStack;

        // Set up a local pointer to the Irp stack
    currentIrpStack = IoGetCurrentIrpStackLocation(Irp);

        // Send the SET command
        ntStatus = HPUsbVendorSetCommand(DeviceObject,
                                         (PUCHAR) Irp->AssociatedIrp.SystemBuffer,
                                                                     currentIrpStack->Parameters.DeviceIoControl.InputBufferLength);

        // Set the Irp information values
        Irp->IoStatus.Status            = ntStatus;
        Irp->IoStatus.Information       = 0;

        // Return
        return ntStatus;
}

/*-------------------------------------------------------------------------------
 * HPUsbIOCTLVendorGetCommand() - Send a vendor defined GET command
 *-------------------------------------------------------------------------------
 */
NTSTATUS HPUsbIOCTLVendorGetCommand(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp)
{
        // Local Variables
    NTSTATUS                    ntStatus;
    PIO_STACK_LOCATION  currentIrpStack;
        ULONG                           bytesRead = 0;

        // Set up a local pointer to the Irp stack
    currentIrpStack = IoGetCurrentIrpStackLocation(Irp);

        // Get the port status
        ntStatus = HPUsbVendorGetCommand(DeviceObject,
                                         (PUCHAR) Irp->AssociatedIrp.SystemBuffer,
                                                                     currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
                                                                     &bytesRead);

        // Set the Irp information values
        Irp->IoStatus.Status            = ntStatus;
        Irp->IoStatus.Information       = bytesRead;

        // Return
        return ntStatus;
}



/*-------------------------------------------------------------------------------
 * HPUsbVendorSetCommand() - Send a vendor specified SET command
 *
 * Inputs:
 *     buffer[0] - Vendor Request Code (bRequest function code)
 *     buffer[1] - Vendor Request Value Most Significant Byte (wValue MSB)
 *     buffer[2] - Vendor Request Value Least Significant Byte (wValue LSB)
 *     buffer[3...] - Any data to be sent as part of the command
 *
 *-------------------------------------------------------------------------------
 */
NTSTATUS HPUsbVendorSetCommand(IN PDEVICE_OBJECT DeviceObject,
                               IN PUCHAR buffer,
                               IN ULONG  length)
{
        // Local variables
    NTSTATUS                                    ntStatus;
        PDEVICE_EXTENSION               deviceExtension;
        PUSBD_INTERFACE_INFORMATION interface;
    PURB                                                urb;
        ULONG                                           size;
        UCHAR                       bRequest;
        USHORT                      wValue;
        USHORT                                          wIndex;

    if ( buffer == NULL || length < 3 )
        return STATUS_INVALID_PARAMETER;

        // Set up a local pointer to the device extension
        deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

        // Set up a local pointer to the interface
        interface = deviceExtension->Interface;

        // Determine the size of the URB
        size = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);

        // Allocate memory for the USB Request Block (URB)
//    urb = (PURB)
//          ExAllocatePoolWithTag(NonPagedPool,size,HPUSB_ALLOC_TAG);
    urb = ExAllocatePoolWithTag(NonPagedPool,size, USBP_TAG);
        // Check for an error
        if (urb == NULL)
                return STATUS_NO_MEMORY;

        // Store the vendor request code
        bRequest = buffer[0];

        // Store the vendor request parameter
        wValue = (buffer[1] << 8) | buffer[2];

        // Create the wIndex value (Interface:Alternate)
        wIndex = (interface->InterfaceNumber << 8) |
                         (interface->AlternateSetting);

    // Use a macro in the standard USB header files to build the URB
        UsbBuildVendorRequest(urb,
                                                  URB_FUNCTION_VENDOR_INTERFACE,
                          (USHORT) size,
                          0,
                          0,
                          bRequest,
                                                  wValue,
                                                  wIndex,
                          buffer,
                          NULL,
                          length,
                          NULL);

    //
    // Timeout cancellation should happen from user mode
    //
    ntStatus = USBPRINT_CallUSBD(DeviceObject,urb, NULL);

        // Free allocated memory
    ExFreePool(urb);

        // Return Success
        return ntStatus;
}

/*-------------------------------------------------------------------------------
 * HPUsbVendorGetCommand() - Send a vendor specified GET command
 *
 * Inputs:
 *     buffer[0] - Vendor Request Code (bRequest function code)
 *     buffer[1] - Vendor Request Value Most Significant Byte (wValue MSB)
 *     buffer[2] - Vendor Request Value Least Significant Byte (wValue LSB)
 * Outputs:
 *     buffer[ ] - Response data
 *
 *-------------------------------------------------------------------------------
 */
NTSTATUS HPUsbVendorGetCommand(IN PDEVICE_OBJECT DeviceObject,
                               IN PUCHAR buffer,
                               IN ULONG  length,
                               OUT PULONG pBytesRead)
{
        // Local variables
    NTSTATUS                                    ntStatus;
        PDEVICE_EXTENSION               deviceExtension;
        PUSBD_INTERFACE_INFORMATION interface;
    PURB                                                urb;
        ULONG                                           size;
        UCHAR                       bRequest;
        USHORT                      wValue;
        USHORT                                          wIndex;

    if ( buffer == NULL || length < 3 )
        return STATUS_INVALID_PARAMETER;

        // Initialize the pBytesRead return value
        *pBytesRead = 0;

        // Set up a local pointer to the device extension
        deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

        // Set up a local pointer to the interface
        interface = deviceExtension->Interface;

        // Determine the size of the URB
        size = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);

        // Allocate memory for the USB Request Block (URB)
  //  urb = (PURB)
    //      ExAllocatePoolWithTag(NonPagedPool,size,HPUSB_ALLOC_TAG);
    urb = ExAllocatePoolWithTag(NonPagedPool,size, USBP_TAG);

        // Check for an error
        if (urb == NULL)
                return STATUS_NO_MEMORY;

        // Store the vendor request code
        bRequest = buffer[0];

        // Store the vendor request parameter
        wValue = (buffer[1] << 8) | buffer[2];

        // Create the wIndex value (Interface:Alternate)
        wIndex = (interface->InterfaceNumber << 8) |
                         (interface->AlternateSetting);

    // Use a macro in the standard USB header files to build the URB
        UsbBuildVendorRequest(urb,
                                                  URB_FUNCTION_VENDOR_INTERFACE,
                          (USHORT) size,
                          USBD_TRANSFER_DIRECTION_IN |
                          USBD_SHORT_TRANSFER_OK,
                          0,
                          bRequest,
                                                  wValue,
                                                  wIndex,
                          buffer,
                          NULL,
                          length,
                          NULL);

    //
    // Timeout cancellation should happen from user mode
    //
    ntStatus = USBPRINT_CallUSBD(DeviceObject,urb, NULL);

        // Retrieve the number of bytes read
        if (NT_SUCCESS(ntStatus))
                *pBytesRead = urb->UrbControlVendorClassRequest.TransferBufferLength;

        // Free allocated memory
    ExFreePool(urb);

        // Return Success
        return ntStatus;
}

/*
// -----------------------------------------------------------
// Kernel Mode Usage
// -----------------------------------------------------------

        // Create the channel change request
        Buffer[0] = HP_VENDOR_COMMAND_DO_SOMETHING;
        Buffer[1] = HP_PARAMETER_UPPER_BYTE;
        Buffer[2] = HP_PARAMETER_LOWER_BYTE;

    // Send the request
    status = CallDeviceIoControl(
                m_pTargetDeviceObject,                  // the device to send the new irp to
                IOCTL_HPUSB_VENDOR_GET_COMMAND, // the ioctl to send to the driver              ,
                Buffer,                                 // the input buffer for the ioctl
                3,                                              // the length of the input buffer
                Buffer,                         // the output buffer for the ioctl
                1,                                      // the length of the output buffer
                FALSE,                                  // create the irp with IRP_MJ_DEVICE_CONTROL
                NULL);                                  // use the provided completion routine


  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\kernelmode\usbprint\ioctl.h ===
/*++

Copyright (c) 1998 - 2000  Microsoft Corporation

Module Name:

    ioctl.h

Abstract:

        

Environment:

    Kernel & user mode

Revision History:


--*/

#define USBPRINT_IOCTL_INDEX  0x0000


// @@BEGIN_DDKSPLIT



#define IOCTL_USBPRINT_GET_PIPE_INFO     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_GET_CONFIG_DESCRIPTOR     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+1,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)
                                                   
#define IOCTL_USBPRINT_SET_PIPE_PARAMETER     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+2,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_STOP_ISO_STREAM     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+3,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_START_ISO_STREAM     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+4,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                   

#define IOCTL_USBPRINT_REGISTER_NOTIFY_EVENT   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+5,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                   
                                                   
#define IOCTL_USBPRINT_START_PERF_TIMER   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+6,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                   
                                                   
#define IOCTL_USBPRINT_STOP_PERF_TIMER   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+7,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                   
                                                   
#define IOCTL_USBPRINT_RETURN_PERF_DATA   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+8,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                   

#define IOCTL_USBPRINT_RESET_DEVICE   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+9,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                              
                                                   
#define IOCTL_USBPRINT_CLOCK_MASTER_TEST   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+10,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)      

#define IOCTL_USBPRINT_RESET_PIPE  CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+11,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                           

// @@END_DDKSPLIT
#define IOCTL_USBPRINT_GET_LPT_STATUS  CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+12,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                           

#define IOCTL_USBPRINT_GET_1284_ID     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+13,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                           

#define IOCTL_USBPRINT_VENDOR_SET_COMMAND CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+14,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                           

#define IOCTL_USBPRINT_VENDOR_GET_COMMAND CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+15,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                           

#define IOCTL_USBPRINT_SOFT_RESET         CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+16,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                           

// @@BEGIN_DDKSPLIT

#include <PSHPACK1.H>

#define BULK      0
#define INTERRUPT 1
#define CONTROL   2
#define ISO       3

typedef struct _USBPRINT_PIPE_PERF_INFO {
    ULONG					BytesPerSecond;
	ULONG					ClockCyclesPerByte;
} USBPRINT_PIPE_PERF_INFO, *PUSBPRINT_PIPE_PERF_INFO;

typedef struct _USBPRINT_PIPE_INFO {
    BOOLEAN					In;
    UCHAR					PipeType;
    UCHAR					EndpointAddress;
    UCHAR					Interval;
    ULONG					MaximumPacketSize;
    ULONG					MaximumTransferSize;
    UCHAR					Name[32];
	USBPRINT_PIPE_PERF_INFO	PerfInfo;
} USBPRINT_PIPE_INFO, *PUSBPRINT_PIPE_INFO;


typedef struct _USBPRINT_INTERFACE_INFO {
    ULONG PipeCount;
    USBPRINT_PIPE_INFO Pipes[0];    
} USBPRINT_INTERFACE_INFO, *PUSBPRINT_INTERFACE_INFO;



#include <POPPACK.H>


// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\kernelmode\usbprint\usbprint.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    USBPRINT.h

Abstract:


							
Environment:

    Kernel & user mode

Revision History:

    5-10-96 : created

--*/


#ifdef DRIVER


extern int iGMessageLevel;
#define BOOL CHAR
#define TRUE 1
#define FALSE 0
#define MAX_ID_SIZE 1024
#define ID_OVERHEAD 15 //this is enough for the 'USBPRINT' at the beginning of the ID, and the crc at the end
#define MAX_NUM_PRINTERS 512


#define USBP_TAG            0x50425355      /* "USBP" */

#define FAILURE_TIMEOUT     -10000 * 5000  // 5 seconds

#define USBPRINT_NAME_MAX  64
#define USB_BASE_NAME L"USB"

#define DEVICE_CAPABILITY_VERSION       1
//
// we support up to 10 pipe handles
//
#define USBPRINT_MAX_PIPES 10

//
// defines used for ISO test
//

#define USBPRINT_MAX_IRP  2
#define USBPRINT_NUM_ISO_PACKETS_PER_REQUEST  32
#define USBPRINT_MAX_STREAM_PACKET 8
#define PORT_NUM_VALUE_NAME L"Port Number"
#define PORT_BASE_NAME L"Base Name"


#define BOGUS_PNP_ID "UnknownPrinter"
#define USBPRINT_STREAM_TIMEOUT_INTERVAL  100


// {28D78FAD-5A12-11d1-AE5B-0000F803A8C2}
static const GUID USBPRINT_GUID = 
{ 0x28d78fad, 0x5a12, 0x11d1, { 0xae, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa8, 0xc2 } };



/*typedef struct _USBPRINT_PIPE {        we don't use this struct anymore.  Just use PUSBD_PIPE_INFORMATION directly
    BOOLEAN Opened;
    UCHAR Pad[3];
    PUSBD_PIPE_INFORMATION PipeInfo;
    WCHAR Name[USBPRINT_NAME_MAX];
	LARGE_INTEGER BytesXfered;
	LARGE_INTEGER ElapsedTime;
	LARGE_INTEGER TimerStart;
	LARGE_INTEGER ElapsedCycles;
	LARGE_INTEGER CyclesStart;
	BOOLEAN           bPerfTimerEnabled; //yy Bunch of perf fields here.  remove them 
} USBPRINT_PIPE, *PUSBPRINT_PIPE; */

typedef struct _USBPRINT_RW_CONTEXT {
    PURB Urb;
    BOOLEAN IsWrite;
    PDEVICE_OBJECT DeviceObject;
} USBPRINT_RW_CONTEXT, *PUSBPRINT_RW_CONTEXT;


#define MAX_INTERFACE 2

// 999 is limit of USBMON's scope due to USB_XXX port name format.
#define MAX_PORT_NUMBER 999
// USB_001 is the lowest port number available.
#define MIN_PORT_NUMBER 1

//
//  Structure representing blocks of unallocated ports.
//
typedef struct _FREE_PORTS
{
	ULONG iBottomOfRange;				// The bottom free port number in this block.
	ULONG iTopOfRange;					// The top free port number in this block.
	struct _FREE_PORTS * pNextBlock;	// Pointer to the next block pf free ports.
} FREE_PORTS, *PFREE_PORTS;

typedef struct _DEVICE_EXTENSION {

	BOOLEAN IsChildDevice;

    // Device object we call when submitting Urbs
    PDEVICE_OBJECT TopOfStackDeviceObject;

    PDEVICE_OBJECT PhysicalDeviceObject;

	PDEVICE_OBJECT ChildDevice;
    BOOL bChildDeviceHere;
    UCHAR DeviceIdString[MAX_ID_SIZE];
    BOOLEAN bBadDeviceID;

    KSPIN_LOCK WakeSpinLock;
	BOOLEAN bD0IrpPending;
    DEVICE_POWER_STATE CurrentDevicePowerState;


    // configuration handle for the configuration the
    // device is currently in
    USBD_CONFIGURATION_HANDLE ConfigurationHandle;

    // ptr to the USB device descriptor
    // for this device
    PUSB_DEVICE_DESCRIPTOR DeviceDescriptor;

    // we support one interface
    // this is a copy of the info structure
    // returned from select_configuration or
    // select_interface
    PUSBD_INTERFACE_INFORMATION Interface;

    DEVICE_CAPABILITIES DeviceCapabilities;
    BOOLEAN bReadSupported;

    PIRP PowerIrp;
    KEVENT RemoveEvent;
    ULONG PendingIoCount;

    // Name buffer for our named Functional device object link
    WCHAR DeviceLinkNameBuffer[USBPRINT_NAME_MAX];

    BOOLEAN AcceptingRequests;

    UCHAR Pad[3];

    PUSBD_PIPE_INFORMATION pWritePipe;
	PUSBD_PIPE_INFORMATION pReadPipe;
	BOOL bReadPipeExists;
	UNICODE_STRING DeviceLinkName;
    ULONG ulInstanceNumber;
    ULONG OpenCnt;
	
	HANDLE hInterfaceKey;
    
    LONG ResetWorkItemPending;

	// selective suspend support
    PIRP                    		PendingIdleIrp;
    PUSB_IDLE_CALLBACK_INFO 		IdleCallbackInfo;
    DEVICE_POWER_STATE              DeviceWake;



} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


typedef struct _CHILD_DEVICE_EXTENSION 
{
	BOOLEAN IsChildDevice;

	PDEVICE_OBJECT ParentDeviceObject;
	ULONG ulInstanceNumber;

} CHILD_DEVICE_EXTENSION, *PCHILD_DEVICE_EXTENSION;


typedef struct _USBPRINT_TRANSFER_OBJECT {
    struct _USBPRINT_STREAM_OBJECT *StreamObject;
    PIRP Irp;
    PURB Urb;
    PUCHAR DataBuffer;
} USBPRINT_TRANSFER_OBJECT, *PUSBPRINT_TRANSFER_OBJECT;

typedef struct _USBPRINT_STREAM_OBJECT {
    PDEVICE_OBJECT DeviceObject;
    ULONG PendingIrps;
    PIRP StopIrp;
    PUSBPRINT_TRANSFER_OBJECT TransferObjectList[USBPRINT_MAX_IRP];
    PUSBD_PIPE_INFORMATION PipeInfo;
    KDPC TimeoutDpc;
    KTIMER  TimeoutTimer;

    BOOLEAN EnableTimeoutDPC;
    BOOLEAN StreamError;
} USBPRINT_STREAM_OBJECT, *PUSBPRINT_STREAM_OBJECT;


typedef struct _USBPRINT_WORKITEM_CONTEXT
{
    PIO_WORKITEM ioWorkItem;
    PDEVICE_OBJECT deviceObject;
     PUSBD_PIPE_INFORMATION pPipeInfo;
    PIRP irp;

} USBPRINT_WORKITEM_CONTEXT,*PUSBPRINT_WORKITEM_CONTEXT;


#if DBG

#define USBPRINT_KdPrint_old(_x_) \
{\
DbgPrint _x_ ;\
DbgPrint("Old USBPRINT\n");\
}

#define USBPRINT_KdPrint0(_x_) \
{ \
  if(iGMessageLevel>=0) \
    DbgPrint _x_; \
}

#define USBPRINT_KdPrint1(_x_) \
{ \
  if(iGMessageLevel>=1) \
    DbgPrint _x_; \
}

#define USBPRINT_KdPrint2(_x_) \
{ \
  if(iGMessageLevel>=2) \
    DbgPrint _x_; \
}

#define USBPRINT_KdPrint3(_x_) \
{ \
  if(iGMessageLevel>=3) \
    DbgPrint _x_; \
}





#ifdef NTKERN
#define TRAP() _asm {int 3}
#else
#define TRAP() DbgBreakPoint()
#endif

#else

#define USBPRINT_KdPrint_old(_x_)
#define USBPRINT_KdPrint0(_x_)
#define USBPRINT_KdPrint1(_x_)
#define USBPRINT_KdPrint2(_x_)
#define USBPRINT_KdPrint3(_x_)
#define USBPRINT_KdPrint4(_x_)

#define TRAP()

#endif

NTSTATUS
USBPRINT_Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
USBPRINT_Unload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
USBPRINT_StartDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBPRINT_StopDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBPRINT_RemoveDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBPRINT_CallUSBD(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb,
    IN PLARGE_INTEGER   pTimeout
    );

NTSTATUS
USBPRINT_PnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
USBPRINT_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
USBPRINT_ConfigureDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBPRINT_Write(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
USBPRINT_Create(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
USBPRINT_Read(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
USBPRINT_ProcessIOCTL(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
USBPRINT_SelectInterface(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    );


NTSTATUS
USBPRINT_BuildPipeList(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBPRINT_Close(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
USBPRINT_ResetPipe(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE_INFORMATION Pipe,
    IN BOOLEAN IsoClearStall
    );

NTSTATUS
USBPRINT_StopIsoStream(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBPRINT_STREAM_OBJECT StreamObject,
    IN PIRP Irp
    );    

NTSTATUS
USBPRINT_StartIsoStream(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE_INFORMATION PipeInfo,
    IN PIRP Irp
    );    

NTSTATUS
USBPRINT_IsoIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
	IN PVOID Context
    );   

VOID
USBPRINT_IncrementIoCount(
    IN PDEVICE_OBJECT DeviceObject
    );

LONG
USBPRINT_DecrementIoCount(
    IN PDEVICE_OBJECT DeviceObject
    );   

NTSTATUS
USBPRINT_ReconfigureDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBPRINT_ProcessPowerIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );    

int
USBPRINT_Get1284Id(
    IN PDEVICE_OBJECT   DeviceObject,
	PVOID pIoBuffer,int iLen
	);


NTSTATUS USBPRINT_ResetWorkItem(IN PDEVICE_OBJECT deviceObject, IN PVOID Context);
NTSTATUS USBPRINT_AbortPendingRequests(PDEVICE_OBJECT DeviceObject);
NTSTATUS USBPRINT_GetPhysicalUSBPortStatus(PDEVICE_OBJECT DeviceObject,ULONG *PortStatus);



VOID
USBPRINT_FdoIdleNotificationCallback(IN PDEVICE_EXTENSION DevExt);

NTSTATUS
USBPRINT_FdoIdleNotificationRequestComplete(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PDEVICE_EXTENSION DevExt
    );

NTSTATUS
USBPRINT_FdoSubmitIdleRequestIrp(IN PDEVICE_EXTENSION DevExt);

VOID
USBPRINT_FdoRequestWake(IN PDEVICE_EXTENSION DevExt);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\kernelmode\usbprint\ocrw.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   ocrw.c

Abstract:

   read/write io code for printing

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5-4-96 : created

--*/

#define DRIVER

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include <usb.h>
#include <usbdrivr.h>
#include "usbdlib.h"
#include "usbprint.h"



//******************************************************************************
//
// USBPRINT_CompletionStop()
//
// IO Completion Routine which just stops further completion of the Irp
//
//******************************************************************************

NTSTATUS
USBPRINT_CompletionStop (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    return STATUS_MORE_PROCESSING_REQUIRED;
}



PURB
USBPRINT_BuildAsyncRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PUSBD_PIPE_INFORMATION PipeHandle,
    IN BOOLEAN Read
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to the device extension for this instance of the
		     printer

    Irp -

    PipeHandle -

Return Value:

    initialized async urb.

--*/
{
    ULONG siz;
    ULONG length;
    PURB urb = NULL;

    USBPRINT_KdPrint3 (("USBPRINT.SYS: handle = 0x%x\n", PipeHandle));

    if ( Irp->MdlAddress == NULL )
        return NULL;

    length = MmGetMdlByteCount(Irp->MdlAddress);

    USBPRINT_KdPrint3 (("USBPRINT.SYS: length = 0x%x\n", length));

    siz = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    urb = ExAllocatePoolWithTag(NonPagedPool, siz, USBP_TAG);

    USBPRINT_KdPrint3 (("USBPRINT.SYS: siz = 0x%x urb 0x%x\n", siz, urb));

    if (urb) {
	RtlZeroMemory(urb, siz);

	urb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT) siz;
	urb->UrbBulkOrInterruptTransfer.Hdr.Function =
		    URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
	urb->UrbBulkOrInterruptTransfer.PipeHandle =
		   PipeHandle->PipeHandle;
	urb->UrbBulkOrInterruptTransfer.TransferFlags =
	    Read ? USBD_TRANSFER_DIRECTION_IN : 0;

	// short packet is not treated as an error.
	urb->UrbBulkOrInterruptTransfer.TransferFlags |= 
	    USBD_SHORT_TRANSFER_OK;            
		
	//
	// no linkage for now
	//

	urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

	urb->UrbBulkOrInterruptTransfer.TransferBufferMDL =
	    Irp->MdlAddress;
	urb->UrbBulkOrInterruptTransfer.TransferBufferLength =
	    length;

	USBPRINT_KdPrint3 (("USBPRINT.SYS: Init async urb Length = 0x%x buf = 0x%x, mdlBuff=0x%x\n",
	    urb->UrbBulkOrInterruptTransfer.TransferBufferLength,
	    urb->UrbBulkOrInterruptTransfer.TransferBuffer,
        urb->UrbBulkOrInterruptTransfer.TransferBufferMDL));
    }

    USBPRINT_KdPrint3 (("USBPRINT.SYS: exit USBPRINT_BuildAsyncRequest\n"));

    return urb;
}



NTSTATUS
USBPRINT_AsyncReadWrite_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:


Arguments:

    DeviceObject - Pointer to the device object for the USBPRINT device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    PURB                                urb;
    PUSBPRINT_RW_CONTEXT  context = Context;
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION           deviceExtension;
    PUSBPRINT_WORKITEM_CONTEXT pResetWorkItemObj;
    LONG ResetPending;
    
    //Always mark irp pending in dispatch routine now
//    if (Irp->PendingReturned) {
//	IoMarkIrpPending(Irp);
//    }

    urb = context->Urb;
    deviceObject = context->DeviceObject;
    deviceExtension=deviceObject->DeviceExtension;
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS:  Async Completion: Length %d, Status 0x%08X\n",
		     urb->UrbBulkOrInterruptTransfer.TransferBufferLength,
		     urb->UrbHeader.Status));


    //ASSERT(urb->UrbHeader.Status==0);

    ntStatus=urb->UrbHeader.Status;

    //
    // set the length based on the TransferBufferLength
    // value in the URB
    //
    Irp->IoStatus.Information =
	urb->UrbBulkOrInterruptTransfer.TransferBufferLength;


    if((!NT_SUCCESS(ntStatus))&&(ntStatus!=STATUS_CANCELLED)&&(ntStatus!=STATUS_DEVICE_NOT_CONNECTED)&&(ntStatus!=STATUS_DELETE_PENDING))
    { //We've got an error, and it's not "not connected" or "cancelled", we need to reset the connection
        ResetPending=InterlockedCompareExchange(&deviceExtension->ResetWorkItemPending, 
                                             1,
                                             0);       //Check to see if ResetWorkItem is 0, if so, set it to 1, and start a Reset
        if(!ResetPending)
        {
            pResetWorkItemObj=ExAllocatePoolWithTag(NonPagedPool,sizeof(USBPRINT_WORKITEM_CONTEXT),USBP_TAG);
            if(pResetWorkItemObj)
            {
                pResetWorkItemObj->ioWorkItem=IoAllocateWorkItem(DeviceObject);
                if(pResetWorkItemObj==NULL)
                {
                    USBPRINT_KdPrint1 (("USBPRINT.SYS: Unable to allocate IoAllocateWorkItem in ReadWrite_Complete\n"));
                    ExFreePool(pResetWorkItemObj);
                    pResetWorkItemObj=NULL;
                }
            } //if ALloc RestWorkItem OK
            else
            {
               USBPRINT_KdPrint1 (("USBPRINT.SYS: Unable to allocate WorkItemObj in ReadWrite_Complete\n"));
            }
            if(pResetWorkItemObj)
            {
               pResetWorkItemObj->irp=Irp;
               pResetWorkItemObj->deviceObject=DeviceObject;
               if(context->IsWrite)
                   pResetWorkItemObj->pPipeInfo=deviceExtension->pWritePipe;
               else
                   pResetWorkItemObj->pPipeInfo=deviceExtension->pReadPipe;

               USBPRINT_IncrementIoCount(deviceObject);
               IoQueueWorkItem(pResetWorkItemObj->ioWorkItem,
                               USBPRINT_ResetWorkItem,
                               DelayedWorkQueue,
                               pResetWorkItemObj);
               ntStatus=STATUS_MORE_PROCESSING_REQUIRED; 
               //Leave the IRP pending until the reset is complete.  This way we won't get flooded with irp's we're not
               //prepaired to deal with.  The Reset WorkItem completes the IRP when it's done.
            } //end if the allocs went OK
        }   //end if ! Reset Pending
    }   //end if we need to reset
    
    USBPRINT_DecrementIoCount(deviceObject); //still +1 on the IO count after this, leaving one for the workitem to decrement                       
    
    ExFreePool(context);
    ExFreePool(urb);        

    return ntStatus;
}


NTSTATUS USBPRINT_ResetWorkItem(IN PDEVICE_OBJECT deviceObject, IN PVOID Context)
{   

    PUSBPRINT_WORKITEM_CONTEXT pResetWorkItemObj;
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS ntStatus;
    ULONG portStatus;
    PDEVICE_OBJECT devObj;


    USBPRINT_KdPrint2(("USBPRINT.SYS: Entering USBPRINT_ResetWorkItem\n"));
    pResetWorkItemObj=(PUSBPRINT_WORKITEM_CONTEXT)Context;
    DeviceExtension=pResetWorkItemObj->deviceObject->DeviceExtension;
    ntStatus=USBPRINT_ResetPipe(pResetWorkItemObj->deviceObject,pResetWorkItemObj->pPipeInfo,FALSE);
    IoCompleteRequest(pResetWorkItemObj->irp,IO_NO_INCREMENT);
    IoFreeWorkItem(pResetWorkItemObj->ioWorkItem);

    // save off work item device object before freeing work item
    devObj = pResetWorkItemObj->deviceObject;
    
    ExFreePool(pResetWorkItemObj);
    InterlockedExchange(&(DeviceExtension->ResetWorkItemPending),0);
    USBPRINT_DecrementIoCount(devObj);
    return ntStatus;
}


NTSTATUS
USBPRINT_Read(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to the device object for this instance of a printer.


Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_PIPE_INFORMATION pipeHandle = NULL;
    PFILE_OBJECT fileObject;
    PIO_STACK_LOCATION irpStack, nextStack;
    PDEVICE_EXTENSION deviceExtension;
    PURB urb;
    PUSBPRINT_RW_CONTEXT context = NULL;

    USBPRINT_KdPrint3 (("USBPRINT.SYS: /*dd enter USBPRINT_Read\n\n\n\n\n\n"));
    USBPRINT_KdPrint3 (("USBPRINT.SYS: /*dd **************************************************************************\n"));

    USBPRINT_IncrementIoCount(DeviceObject);

    deviceExtension = DeviceObject->DeviceExtension;

    if (deviceExtension->IsChildDevice == TRUE) 
    {
  	  ntStatus = STATUS_NOT_SUPPORTED;
	  Irp->IoStatus.Status = ntStatus;
	  Irp->IoStatus.Information = 0;
	  IoCompleteRequest (Irp,IO_NO_INCREMENT);
  	  USBPRINT_DecrementIoCount(DeviceObject);                          
	  return ntStatus;
    }
    
    if (deviceExtension->AcceptingRequests == FALSE) 
    {
  	  ntStatus = STATUS_DELETE_PENDING;
	  Irp->IoStatus.Status = ntStatus;
	  Irp->IoStatus.Information = 0;
	  IoCompleteRequest (Irp,IO_NO_INCREMENT);
  	  USBPRINT_DecrementIoCount(DeviceObject);                          
	  return ntStatus;
    }
    
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    fileObject = irpStack->FileObject;

    pipeHandle =  deviceExtension->pReadPipe;

    if (!pipeHandle) {
       ntStatus = STATUS_INVALID_HANDLE;
       goto USBPRINT_Read_Reject;
    }

    //
    // submit the Read request to USB
    //

    switch (pipeHandle->PipeType) {
    case UsbdPipeTypeInterrupt:
    case UsbdPipeTypeBulk:
	urb = USBPRINT_BuildAsyncRequest(DeviceObject,
				       Irp,
				       pipeHandle,
				       TRUE);
	if (urb) {
	    context = ExAllocatePoolWithTag(NonPagedPool, sizeof(USBPRINT_RW_CONTEXT), USBP_TAG);

        if ( !context )
           ExFreePool(urb);
	}
	
	if (urb && context) {
	    context->Urb = urb;
	    context->DeviceObject = DeviceObject;
        context->IsWrite=FALSE;
	    
	    nextStack = IoGetNextIrpStackLocation(Irp);
	    ASSERT(nextStack != NULL);
	    ASSERT(DeviceObject->StackSize>1);

	    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	    nextStack->Parameters.Others.Argument1 = urb;
	    nextStack->Parameters.DeviceIoControl.IoControlCode =
		IOCTL_INTERNAL_USB_SUBMIT_URB;

	    IoSetCompletionRoutine(Irp,
				   USBPRINT_AsyncReadWrite_Complete,
				   context,
				   TRUE,
				   TRUE,
				   TRUE);

	    USBPRINT_KdPrint3 (("USBPRINT.SYS: IRP = 0x%x current = 0x%x next = 0x%x\n",
		Irp, irpStack, nextStack));

			// start perf timer here if needed
		
        IoMarkIrpPending(Irp);
	    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,
				    Irp);
        ntStatus=STATUS_PENDING;
	    goto USBPRINT_Read_Done;
	} 
    else 
    {
	    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
	}

	break;
    default:
	ntStatus = STATUS_INVALID_PARAMETER;
	TRAP();
    }

USBPRINT_Read_Reject:

    USBPRINT_DecrementIoCount(DeviceObject);
    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest (Irp,
		       IO_NO_INCREMENT
		       );

USBPRINT_Read_Done:

    return ntStatus;
}


NTSTATUS
USBPRINT_Write(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function services WRITE requests for this device (probably from the user mode USB port monitor) 

Arguments:

    DeviceObject - pointer to the device object for this printer


Return Value:

    NT status code

  --*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_PIPE_INFORMATION pipeHandle = NULL;
    PFILE_OBJECT fileObject;
    PIO_STACK_LOCATION irpStack, nextStack;
    PDEVICE_EXTENSION deviceExtension;
    PURB urb;
    PUSBPRINT_RW_CONTEXT context = NULL;
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS: enter USBPRINT_Write (foo)\n"));
    
    USBPRINT_IncrementIoCount(DeviceObject);
    
    deviceExtension = DeviceObject->DeviceExtension;
    
    if (deviceExtension->IsChildDevice == TRUE) 
    {
        USBPRINT_KdPrint1 (("USBPRINT.SYS: failure because bChildDevice=TRUE\n"));
        ntStatus = STATUS_NOT_SUPPORTED;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        USBPRINT_DecrementIoCount(DeviceObject);
        IoCompleteRequest (Irp,IO_NO_INCREMENT);
        return ntStatus;
    }
    if (deviceExtension->AcceptingRequests == FALSE) 
    {
        USBPRINT_KdPrint1 (("USBPRINT.SYS: failure because AcceptingRequests=FALSE\n"));
        ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        USBPRINT_DecrementIoCount(DeviceObject);
        IoCompleteRequest (Irp,IO_NO_INCREMENT);
        return ntStatus;
    }
    
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    

    fileObject = irpStack->FileObject;
    
    //    MmProbeAndLockPages(Irp->MdlAddress,
    //                        KernelMode,
    //                        IoReadAccess);
    
    pipeHandle =  deviceExtension->pWritePipe;
    if (!pipeHandle)
    {
        USBPRINT_KdPrint1 (("USBPRINT.SYS: failure because pipe is bad\n"));
        ntStatus = STATUS_INVALID_HANDLE;
        goto USBPRINT_Write_Reject;
    }
    
    //
    // submit the write request to USB
    //
    
    switch (pipeHandle->PipeType) 
    {
    case UsbdPipeTypeInterrupt:
    case UsbdPipeTypeBulk:
        urb = USBPRINT_BuildAsyncRequest(DeviceObject,
            Irp,
            pipeHandle,
            FALSE);
        
        if (urb) 
        {
            context = ExAllocatePoolWithTag(NonPagedPool, sizeof(USBPRINT_RW_CONTEXT), USBP_TAG);

            if(!context)
               ExFreePool(urb);
        
        }

        if (urb && context) 
        {
            context->Urb = urb;
            context->DeviceObject = DeviceObject;                                       
            context->IsWrite=TRUE;
            
            nextStack = IoGetNextIrpStackLocation(Irp);
            ASSERT(nextStack != NULL);
            ASSERT(DeviceObject->StackSize>1);
            
            nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            nextStack->Parameters.Others.Argument1 = urb;
            nextStack->Parameters.DeviceIoControl.IoControlCode =
                IOCTL_INTERNAL_USB_SUBMIT_URB;
            
            IoSetCompletionRoutine(Irp,
                USBPRINT_AsyncReadWrite_Complete,
                context,
                TRUE,
                TRUE,
                TRUE);
            
            USBPRINT_KdPrint3 (("USBPRINT.SYS: IRP = 0x%x current = 0x%x next = 0x%x\n",Irp, irpStack, nextStack));
            
            IoMarkIrpPending(Irp);
            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,Irp);
            ntStatus=STATUS_PENDING;
            goto USBPRINT_Write_Done;
        } 
        else 
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        
        break;
    default:
        ntStatus = STATUS_INVALID_PARAMETER;
        TRAP();
    }
    
USBPRINT_Write_Reject:
    
    USBPRINT_DecrementIoCount(DeviceObject);
    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;
    
    IoCompleteRequest (Irp,
        IO_NO_INCREMENT
        );
    
USBPRINT_Write_Done:
    USBPRINT_KdPrint3 (("USBPRINT.SYS: Write Done, status= 0x%08X\n",ntStatus));
    return ntStatus;
}


NTSTATUS
USBPRINT_Close(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to the device object for this printer


Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;
    PFILE_OBJECT fileObject;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION deviceExtension;
    PUSBD_PIPE_INFORMATION pipeHandle = NULL;
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS: entering USBPRINT_Close\n"));
    
    USBPRINT_IncrementIoCount(DeviceObject);
    
    deviceExtension = DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    fileObject = irpStack->FileObject;
    
    if (fileObject->FsContext) 
    {
        // closing pipe handle
        pipeHandle =  fileObject->FsContext;
        USBPRINT_KdPrint3 (("USBPRINT.SYS: closing pipe %x\n", pipeHandle));
        
    }
   deviceExtension->OpenCnt--;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    
    
    ntStatus = Irp->IoStatus.Status;
    
    IoCompleteRequest (Irp,IO_NO_INCREMENT);
    
    USBPRINT_DecrementIoCount(DeviceObject);

    if(!deviceExtension->IsChildDevice)
    {
        USBPRINT_FdoSubmitIdleRequestIrp(deviceExtension);
    }

    
    return ntStatus;
}


NTSTATUS
USBPRINT_Create(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp)
/*++

Routine Description:

    //
    // Entry point for CreateFile calls
    // user mode apps open device interfaces via
    // SetupDiEnumDeviceInterfaces

Arguments:

    DeviceObject - pointer to the device object for this printer.


Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFILE_OBJECT fileObject;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION deviceExtension;
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS: entering USBPRINT_Create\n"));
    USBPRINT_IncrementIoCount(DeviceObject);
    deviceExtension = DeviceObject->DeviceExtension;
    if (deviceExtension->IsChildDevice==TRUE) {
      ntStatus = STATUS_NOT_SUPPORTED;
      Irp->IoStatus.Status = ntStatus;
      Irp->IoStatus.Information = 0;
      IoCompleteRequest (Irp,IO_NO_INCREMENT);
      USBPRINT_DecrementIoCount(DeviceObject);                          
    return ntStatus;
    }
    if (deviceExtension->AcceptingRequests == FALSE) {
        ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp,IO_NO_INCREMENT);
        USBPRINT_DecrementIoCount(DeviceObject);                          
        return ntStatus;
    }

    USBPRINT_FdoRequestWake(deviceExtension);

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    fileObject = irpStack->FileObject;
    // fscontext is null for device
    fileObject->FsContext = NULL;
    deviceExtension->OpenCnt++;
    ntStatus = STATUS_SUCCESS;
    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp,IO_NO_INCREMENT);
    USBPRINT_DecrementIoCount(DeviceObject);                               
    USBPRINT_KdPrint2 (("USBPRINT.SYS: exit USBPRINT_Create %x\n", ntStatus));
    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\kernelmode\usbprint\usbprint.c ===
/*++                                                   

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    USBPRINT.c

Abstract:

    Device driver for USB printers

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5-4-96 : created

--*/

#define DRIVER
//Windows includes
#include "wdm.h"
#include "ntddpar.h"
#include "initguid.h"
#include "wdmguid.h"



NTSTATUS
USBPRINT_SystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBPRINT_SystemControl)
#endif


#include "stdarg.h"
#include "stdio.h"

//USB includes
#include <usb.h>
#include <usbdrivr.h>
#include "usbdlib.h"

//My includes
#include "usbprint.h"
#include "deviceid.h"

//
// Global pointer to Driver Object
//

PDRIVER_OBJECT USBPRINT_DriverObject;

int iGMessageLevel;
PFREE_PORTS pGPortList;
HANDLE GLogHandle;



NTSTATUS QueryDeviceRelations(PDEVICE_OBJECT DeviceObject,PIRP Irp,DEVICE_RELATION_TYPE,BOOL *pbComplete);
NTSTATUS GetPortNumber(HANDLE hInterfaceKey,ULONG *ulPortNumber);
NTSTATUS ProduceQueriedID(PDEVICE_EXTENSION deviceExtension,PIO_STACK_LOCATION irpStack,PIRP Irp,PDEVICE_OBJECT DeviceObject);
int iGetMessageLevel();
NTSTATUS USBPRINT_ProcessChildPowerIrp(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp);
NTSTATUS USBPRINT_ProcessFdoPowerIrp(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp);

NTSTATUS InitFreePorts( PFREE_PORTS * pHead );
NTSTATUS bAddPortInUseItem(PFREE_PORTS * pFreePorts,ULONG iPortNumber );
NTSTATUS LoadPortsUsed(GUID *pPrinterGuid,PFREE_PORTS * pPortList,WCHAR *wcBaseName);
void ClearFreePorts(PFREE_PORTS * pHead);
NTSTATUS LoadPortsUsed(GUID *pPrinterGuid,PFREE_PORTS * pPortList,WCHAR *wcBaseName);
void vClaimPortNumber(ULONG ulPortNumber,HANDLE hInterfaceKey,PFREE_PORTS * pPortsUsed);
NTSTATUS GetNewPortNumber(PFREE_PORTS * pFreePorts, ULONG *pulPortNumber);
BOOL bDeleteIfRecyclable(HANDLE hInterfaceKey);
NTSTATUS SetValueToZero(HANDLE hRegKey,PUNICODE_STRING ValueName);
USBPRINT_GetDeviceID(PDEVICE_OBJECT ParentDeviceObject);
void WritePortDescription(PDEVICE_EXTENSION deviceExtension);
void vOpenLogFile(IN HANDLE *pHandle);
void vWriteToLogFile(IN HANDLE *pHandle,IN CHAR *pszString);
void vCloseLogFile(IN HANDLE *pHandle);


NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );




NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject,IN PUNICODE_STRING RegistryPath)
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
           to driver-specific key in the registry

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject = NULL;
    

    



    USBPRINT_DriverObject = DriverObject;

    //
    // Create dispatch points for device control, create, close.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = USBPRINT_Create;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = USBPRINT_Close;
    DriverObject->DriverUnload = USBPRINT_Unload;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = USBPRINT_ProcessIOCTL;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = USBPRINT_Write;
    DriverObject->MajorFunction[IRP_MJ_READ] = USBPRINT_Read;

    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = USBPRINT_SystemControl;
    DriverObject->MajorFunction[IRP_MJ_PNP] = USBPRINT_Dispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER] = USBPRINT_ProcessPowerIrp;
    DriverObject->DriverExtension->AddDevice = USBPRINT_PnPAddDevice;

    iGMessageLevel=iGetMessageLevel();
    USBPRINT_KdPrint2 (("USBPRINT.SYS: entering (USBPRINT) DriverEntry\n")); 
    USBPRINT_KdPrint2 (("USBPRINT.SYS: MessageLevel=%d\n",iGMessageLevel));
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS: About to load ports\n"));
    pGPortList = NULL;
    ntStatus=InitFreePorts(&pGPortList);
    if(NT_SUCCESS(ntStatus) && pGPortList!=NULL)
    {
        ntStatus=LoadPortsUsed((GUID *)&USBPRINT_GUID,&pGPortList,USB_BASE_NAME);
        if(!NT_SUCCESS(ntStatus))
        {
          USBPRINT_KdPrint1 (("USBPRINT.SYS: DriverInit: Unable to load used ports; error=%u\n", ntStatus));
        }
    }
    else
    {
        USBPRINT_KdPrint1 (("USBPRINT.SYS: exiting (USBPRINT) DriverEntry (%x)\n", ntStatus));
        if(NT_SUCCESS(ntStatus))
        {
            ntStatus=STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    
    



    USBPRINT_KdPrint2 (("USBPRINT.SYS: exiting (USBPRINT) DriverEntry (%x)\n", ntStatus));

    if ( !NT_SUCCESS(ntStatus))
        ClearFreePorts(&pGPortList);

    return ntStatus;
}

/*********************************************
 * Message Levels:
 * 0 == None, except critical, about to crash the machine failures
 * 1 == Error messages only
 * 2 == Informative messages
 * 3 == Verbose informative messages
 ******************************************************/
int iGetMessageLevel()
{
  OBJECT_ATTRIBUTES rObjectAttribs;
  HANDLE hRegHandle;
  UNICODE_STRING KeyName;
  UNICODE_STRING ValueName;
  ULONG ulSizeUsed;
  PKEY_VALUE_PARTIAL_INFORMATION pValueStruct;
  NTSTATUS ntStatus;
  int iReturn;

 

  
  RtlInitUnicodeString(&KeyName,L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\USBPRINT");
  RtlInitUnicodeString(&ValueName,L"DriverMessageLevel");
  InitializeObjectAttributes(&rObjectAttribs,&KeyName,OBJ_CASE_INSENSITIVE,NULL,NULL);
  ntStatus=ZwOpenKey(&hRegHandle,KEY_QUERY_VALUE,&rObjectAttribs); 
  if(NT_SUCCESS(ntStatus))
  {
    ulSizeUsed=sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(ULONG); //this is a byte to much.  Oh well
    pValueStruct=ExAllocatePoolWithTag(NonPagedPool,ulSizeUsed, USBP_TAG); 
    if(pValueStruct==NULL)
    {
      USBPRINT_KdPrint0(("'USBPRINT.SYS: iGetMessageLevel; Unable to allocate memory\n"));
      ZwClose(hRegHandle);
      return 1;
    }
    ntStatus=ZwQueryValueKey(hRegHandle,&ValueName,KeyValuePartialInformation,pValueStruct,ulSizeUsed,&ulSizeUsed);
    if(!NT_SUCCESS(ntStatus))
    {
      USBPRINT_KdPrint3(("Failed to Query value Key\n"));
      iReturn=1;
    }
    else
    {
      iReturn=(int)*((ULONG *)(pValueStruct->Data));
    }
    ExFreePool(pValueStruct);
    ZwClose(hRegHandle);
  }
  else
  {
     iReturn=1;
  }
  return iReturn;
} /*end iGetMessageLevel*/


NTSTATUS
USBPRINT_PoRequestCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PIRP irp;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT deviceObject = Context;
    NTSTATUS ntStatus;

    deviceExtension = deviceObject->DeviceExtension;
    irp = deviceExtension->PowerIrp;
    
    USBPRINT_KdPrint2(("USBPRINT_PoRequestCompletion\n"));
    
    PoStartNextPowerIrp(irp);
    IoCopyCurrentIrpStackLocationToNext(irp);      
    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject,
         irp);   

    USBPRINT_DecrementIoCount(deviceObject);                 

    return ntStatus;
}


NTSTATUS
USBPRINT_PowerIrp_Complete(
    IN PDEVICE_OBJECT NullDeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION deviceExtension;

    USBPRINT_KdPrint2(("USBPRINT.SYS:   enter USBPRINT_PowerIrp_Complete\n"));

    deviceObject = (PDEVICE_OBJECT) Context;

    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;


    if (Irp->PendingReturned) {
    IoMarkIrpPending(Irp);
    }

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);
    ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
    ASSERT(irpStack->Parameters.Power.Type==DevicePowerState);
    ASSERT(irpStack->Parameters.Power.State.DeviceState==PowerDeviceD0);

    deviceExtension->CurrentDevicePowerState = PowerDeviceD0;
    deviceExtension->bD0IrpPending=FALSE;

    
    
 //   if (deviceExtension->Interface) 
 //     ExFreePool(deviceExtension->Interface);
 //   ntStatus=USBPRINT_ConfigureDevice(deviceObject);
 //   ntStatus = USBPRINT_BuildPipeList(deviceObject);
 //   if(!NT_SUCCESS(ntStatus))
 //       USBPRINT_KdPrint1(("USBPRINT.SYS :  Unable to reconfigure device after wakeup.  Error %x\n",ntStatus));

    Irp->IoStatus.Status = ntStatus;

    USBPRINT_DecrementIoCount(deviceObject); 

    return ntStatus;
}


NTSTATUS
USBPRINT_SetDevicePowerState(
    IN PDEVICE_OBJECT DeviceObject,
    IN DEVICE_POWER_STATE DeviceState,
    IN PBOOLEAN HookIt
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    DeviceState - Device specific power state to set the device in to.

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (DeviceState) {
    case PowerDeviceD3:

    //
    // device will be going OFF, save any state now.
    //

    USBPRINT_KdPrint2(("USBPRINT.SYS:  PowerDeviceD3 (OFF)*******************************/*dd\n"));

    deviceExtension->CurrentDevicePowerState = DeviceState;
    break;

    case PowerDeviceD1:
    case PowerDeviceD2:
    //
    // power states D1,D2 translate to USB suspend

    USBPRINT_KdPrint2(("USBPRINT.SYS:  PowerDeviceD1/D2 (SUSPEND)*******************************/*dd\n"));        

    deviceExtension->CurrentDevicePowerState = DeviceState;
    break;

    case PowerDeviceD0:


    USBPRINT_KdPrint2(("USBPRINT.SYS:  PowerDeviceD0 (ON)*******************************/*dd\n"));

    //
    // finish the rest in the completion routine
    //

    *HookIt = TRUE;

    // pass on to PDO
    break;

    default:
    
    USBPRINT_KdPrint1(("USBPRINT.SYS:  Bogus DeviceState = %x\n", DeviceState));
    }

    return ntStatus;
}


NTSTATUS
USBPRINT_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = Context;


    KeSetEvent(event,1,FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
    
}


NTSTATUS
USBPRINT_QueryCapabilities(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN PDEVICE_CAPABILITIES DeviceCapabilities
    )

/*++

Routine Description:

    This routine reads or write config space.

Arguments:

    DeviceObject        - Physical DeviceObject for this USB controller.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus;
    KEVENT event;

    PAGED_CODE();
    irp = IoAllocateIrp(PdoDeviceObject->StackSize, FALSE);

    if (!irp) {
    return STATUS_INSUFFICIENT_RESOURCES;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= IRP_MN_QUERY_CAPABILITIES;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
               USBPRINT_DeferIrpCompletion,
               &event,
               TRUE,
               TRUE,
               TRUE);
               
    //this is different from the latest version of busdd.doc
    nextStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

    ntStatus = IoCallDriver(PdoDeviceObject,
                irp);

    USBPRINT_KdPrint3(("USBPRINT.SYS:  ntStatus from IoCallDriver to PCI = 0x%x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {
       // wait for irp to complete
       
       
       
       KeWaitForSingleObject(
        &event,
        Suspended,
        KernelMode,
        FALSE,
        NULL);
    }

#if DBG                    
    if (!NT_SUCCESS(ntStatus)) {
    // failed? this is probably a bug
    USBPRINT_KdPrint1(("USBPRINT.SYS:  QueryCapabilities failed, why?\n"));
    }
#endif

    IoFreeIrp(irp);

    return STATUS_SUCCESS;
}




NTSTATUS
USBPRINT_ProcessPowerIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
  PDEVICE_EXTENSION deviceExtension;
  BOOLEAN hookIt = FALSE;
    NTSTATUS ntStatus;

  USBPRINT_KdPrint2(("USBPRINT.SYS:  /*****************************************************************IRP_MJ_POWER\n"));

  deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    if(deviceExtension->IsChildDevice)
        ntStatus=USBPRINT_ProcessChildPowerIrp(DeviceObject,Irp);
  else
        ntStatus=USBPRINT_ProcessFdoPowerIrp(DeviceObject,Irp);
    USBPRINT_KdPrint3(("USBPRINT.SYS:  /*****************************************************************Leaving power IRP_MJ_POWER\n"));
    return ntStatus;    

}  /*end function USBPRINT_ProcessPowerIrp*/


NTSTATUS
USBPRINT_ProcessChildPowerIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
   PIO_STACK_LOCATION irpStack;
   NTSTATUS ntStatus;
   PCHILD_DEVICE_EXTENSION pDeviceExtension;
 

     USBPRINT_KdPrint2(("USBPRINT.SYS: IRP_MJ_POWER for child PDO\n"));

     pDeviceExtension=(PCHILD_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
     irpStack=IoGetCurrentIrpStackLocation(Irp);

     switch(irpStack->MinorFunction)
     {
         case IRP_MN_SET_POWER:
           USBPRINT_KdPrint3(("USBPRINT.SYS: IRP_MJ_POWER, IRP_MN_SET_POWER\n"));
             ntStatus=STATUS_SUCCESS;
         break;


         case IRP_MN_QUERY_POWER:
             USBPRINT_KdPrint3(("USBPRINT.SYS: IRP_MJ_POWER, IRP_MN_QUERY_POWER\n"));
             ntStatus=STATUS_SUCCESS;
         break;

         default:
            ntStatus = Irp->IoStatus.Status;
     } /*end switch irpStack->MinorFunction*/

   PoStartNextPowerIrp(Irp);
   Irp->IoStatus.Status=ntStatus;
     IoCompleteRequest(Irp,IO_NO_INCREMENT);

     return ntStatus;

} /*end function USBPRINT_ProcessChildPowerIrp*/



NTSTATUS
USBPRINT_ProcessFdoPowerIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Process the Power IRPs sent to the PDO for this device.

    

Arguments:

    DeviceObject - pointer to a hcd device object (FDO)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{

    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    BOOLEAN hookIt = FALSE;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    if(deviceExtension->IsChildDevice)
    {
        USBPRINT_KdPrint1(("USBPRINT.SYS  Is child device inside fdo function.  Error!*/\n"));
    }
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    USBPRINT_IncrementIoCount(DeviceObject);

    switch(irpStack->MinorFunction)
    {
    
    case IRP_MN_SET_POWER:
        {

            switch(irpStack->Parameters.Power.Type)
            {
            case SystemPowerState:
                //
                // find the device power state equivalent to the given system state
                //

                {
                    POWER_STATE powerState;

                    USBPRINT_KdPrint3(("USBPRINT.SYS:  Set Power, SystemPowerState (%d)\n", 
                                       irpStack->Parameters.Power.State.SystemState));                    

                    powerState.DeviceState = deviceExtension->DeviceCapabilities.DeviceState[irpStack->Parameters.Power.State.SystemState];

                    //
                    // are we already in this state?
                    //

                    if(powerState.DeviceState != deviceExtension->CurrentDevicePowerState)
                    {

                        // No,
                        // request that we be put into this state
                        //Don't touch the Irp any more after this.  It could complete at any time
                        deviceExtension->PowerIrp = Irp;
                        IoMarkIrpPending(Irp); 
                        ntStatus = PoRequestPowerIrp(deviceExtension->PhysicalDeviceObject,
                                                     IRP_MN_SET_POWER,
                                                     powerState,
                                                     USBPRINT_PoRequestCompletion,
                                                     DeviceObject,
                                                     NULL);
                        hookIt = TRUE;

                    }
                    else
                    {
                        // Yes,
                        // just pass it on
                        PoStartNextPowerIrp(Irp);
                        IoCopyCurrentIrpStackLocationToNext(Irp);
                        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject,
                                                Irp);

                    }

                } 
                break;

            case DevicePowerState:

                ntStatus = USBPRINT_SetDevicePowerState(DeviceObject,
                                                        irpStack->Parameters.Power.State.DeviceState,
                                                        &hookIt);

                PoStartNextPowerIrp(Irp);
                IoCopyCurrentIrpStackLocationToNext(Irp);

                if(hookIt)
                {
                    USBPRINT_KdPrint2(("USBPRINT.SYS:  Set PowerIrp Completion Routine\n"));
                    IoSetCompletionRoutine(Irp,USBPRINT_PowerIrp_Complete,DeviceObject,TRUE,TRUE,TRUE);
                }
                ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject,Irp);
                break;
            } /* switch irpStack->Parameters.Power.Type */

        } 
        break; /* IRP_MN_SET_POWER */

    default:

        USBPRINT_KdPrint1(("USBPRINT.SYS:  UNKNOWN POWER MESSAGE (%x)\n", irpStack->MinorFunction));

        //
        // All unahndled PnP messages are passed on to the PDO
        //

        PoStartNextPowerIrp(Irp);
        IoCopyCurrentIrpStackLocationToNext(Irp);
        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject,
                                Irp);

    } /* irpStack->MinorFunction */

    if( !hookIt )
        USBPRINT_DecrementIoCount(DeviceObject);
    return ntStatus;
} /*end function ProcessFdoPowerIrp*/


NTSTATUS
USBPRINT_Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object
                                         
    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{

    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT stackDeviceObject;
    BOOL bHandled=FALSE;

    //Irp->IoStatus.Status = STATUS_SUCCESS;
    //Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    //

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    //
    // Get a pointer to the device extension
    //

    deviceExtension = DeviceObject->DeviceExtension;
    stackDeviceObject = deviceExtension->TopOfStackDeviceObject;

#ifdef  MYDEBUG
    DbgPrint("USBPRINT_Dispatch entry for pnp event %d\n", irpStack->MinorFunction);
    ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);
#endif
    
    USBPRINT_IncrementIoCount(DeviceObject);

        switch (irpStack->MinorFunction) 
        {
          case IRP_MN_START_DEVICE:
          {
            if(deviceExtension->IsChildDevice==FALSE)
            {
              KEVENT event;
              USBPRINT_KdPrint2 (("USBPRINT.SYS: IRP_MN_START_DEVICE\n"));
              KeInitializeEvent(&event, NotificationEvent, FALSE);
              IoCopyCurrentIrpStackLocationToNext(Irp);  
              IoSetCompletionRoutine(Irp,USBPRINT_DeferIrpCompletion,&event,TRUE,TRUE,TRUE);
              ntStatus = IoCallDriver(stackDeviceObject,Irp);
              if (ntStatus == STATUS_PENDING) 
              {
                KeWaitForSingleObject(&event,Suspended,KernelMode,FALSE,NULL);
                ntStatus = Irp->IoStatus.Status;
              }
              if ( NT_SUCCESS(ntStatus) ) {

                //
                // You start the device after everyone below you have started it
                //
                Irp->IoStatus.Status = ntStatus = USBPRINT_StartDevice(DeviceObject);
              }
            } /*end if not child*/
            else
            {
                ntStatus = Irp->IoStatus.Status = STATUS_SUCCESS;
            }

            bHandled = TRUE;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            USBPRINT_DecrementIoCount(DeviceObject);
            
          } //end case IRP_MN_START_DEVICE
          break;

          case IRP_MN_STOP_DEVICE:
            if(deviceExtension->IsChildDevice)
            {
                Irp->IoStatus.Status = STATUS_SUCCESS;
                ntStatus=STATUS_SUCCESS;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            else
            {
              USBPRINT_KdPrint2 (("USBPRINT.SYS: IRP_MN_STOP_DEVICE\n")); 
              
              //
              // You stop the device first and then let everyone below you deal with it
              //
              ntStatus = USBPRINT_StopDevice(DeviceObject);
              ASSERT(NT_SUCCESS(ntStatus));

              //
              // We want to stop the device anyway ..
              //
              Irp->IoStatus.Status = STATUS_SUCCESS;
              IoSkipCurrentIrpStackLocation(Irp);
              ntStatus = IoCallDriver(stackDeviceObject,Irp);
            }
            bHandled = TRUE;
            USBPRINT_DecrementIoCount(DeviceObject);
          break;

          case IRP_MN_SURPRISE_REMOVAL:
            if(deviceExtension->IsChildDevice)
            {
                Irp->IoStatus.Status = STATUS_SUCCESS;
                ntStatus=STATUS_SUCCESS;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            else
            {
                USBPRINT_KdPrint2(("USBPRINT.SYS:   Surprise Remove")); 
                
                ntStatus = USBPRINT_StopDevice(DeviceObject);
                ASSERT(NT_SUCCESS(ntStatus));
                Irp->IoStatus.Status=STATUS_SUCCESS;  

                deviceExtension->AcceptingRequests=FALSE;
                IoSkipCurrentIrpStackLocation(Irp);
                ntStatus = IoCallDriver(stackDeviceObject,Irp);
            } /*end else NOT child device*/

            bHandled = TRUE;
            USBPRINT_DecrementIoCount(DeviceObject);
          break;

          case IRP_MN_REMOVE_DEVICE:
             
            if(deviceExtension->IsChildDevice==FALSE)
            {
                USBPRINT_KdPrint2 (("USBPRINT.SYS: IRP_MN_REMOVE_DEVICE\n")); 
                
                // match the inc at the begining of the dispatch routine
                USBPRINT_DecrementIoCount(DeviceObject);

                ntStatus = USBPRINT_StopDevice(DeviceObject);
                ASSERT(NT_SUCCESS(ntStatus));
                Irp->IoStatus.Status=STATUS_SUCCESS;  

                //
                // ounce this flag is set no irps will be pased 
                // down the stack to lower drivers
                //
                deviceExtension->AcceptingRequests = FALSE;
                if(deviceExtension->bChildDeviceHere)
                {
                  deviceExtension->bChildDeviceHere=FALSE;
                  IoDeleteDevice(deviceExtension->ChildDevice);
                  USBPRINT_KdPrint3(("USBPRINT.SYS: Deleted child device\n"));
                }
              if (NT_SUCCESS(ntStatus)) 
              {
                LONG pendingIoCount;
                USBPRINT_KdPrint3(("USBPRINT.SYS: About to copy current IrpStackLocation\n"));
                IoCopyCurrentIrpStackLocationToNext(Irp);  
                ntStatus = IoCallDriver(stackDeviceObject,Irp);
                

    //          Irp->IoStatus.Information = 0;
                //
                // final decrement will trigger the remove
                //
                pendingIoCount = USBPRINT_DecrementIoCount(DeviceObject);

                {
                  NTSTATUS status;

                  // wait for any io request pending in our driver to
                  // complete for finishing the remove
                  status = KeWaitForSingleObject(&deviceExtension->RemoveEvent,Suspended,KernelMode,FALSE,NULL);
//                    TRAP();
                } /*end of non-controled code block*/
                //
                // Delete the link and FDO we created
                //
                USBPRINT_RemoveDevice(DeviceObject);
                USBPRINT_KdPrint3 (("USBPRINT.SYS: Detaching from %08X\n",deviceExtension->TopOfStackDeviceObject));
                IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
                USBPRINT_KdPrint3 (("USBPRINT.SYS: Deleting %08X\n",DeviceObject));

                IoDeleteDevice (DeviceObject);
                } /*end if NT_SUCCESS(ntStatus)*/
            } /*end if IsChildDevice==FALSE*/
            else
            {
                USBPRINT_DecrementIoCount(DeviceObject);
                Irp->IoStatus.Status = STATUS_SUCCESS;
                ntStatus=STATUS_SUCCESS;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            bHandled = TRUE;
          break; //case IRP_MN_REMOVE_DEVICE

          case IRP_MN_QUERY_CAPABILITIES:
          {
            if(deviceExtension->IsChildDevice==FALSE) //if it's the parent, pass down the irp, and set SurpriseRemovalOK on the way back up
            {
              KEVENT event;
              KeInitializeEvent(&event, NotificationEvent, FALSE);
              IoCopyCurrentIrpStackLocationToNext(Irp);  
              IoSetCompletionRoutine(Irp,USBPRINT_DeferIrpCompletion,&event,TRUE,TRUE,TRUE);
              ntStatus = IoCallDriver(stackDeviceObject,Irp);
              if (ntStatus == STATUS_PENDING) 
              {
                KeWaitForSingleObject(&event,Suspended,KernelMode,FALSE,NULL);
                ntStatus = Irp->IoStatus.Status;
              }

              if ( NT_SUCCESS(ntStatus) )
                irpStack->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = TRUE;

                // get device wake for selective suspend
                deviceExtension->DeviceWake = irpStack->Parameters.DeviceCapabilities.Capabilities->DeviceWake;
            }
            else
            {
               irpStack->Parameters.DeviceCapabilities.Capabilities->RawDeviceOK = TRUE;
               irpStack->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = TRUE;
 
                Irp->IoStatus.Status = STATUS_SUCCESS;

              ntStatus=STATUS_SUCCESS;
            }
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
          
            bHandled = TRUE;
            USBPRINT_DecrementIoCount(DeviceObject);
          }
          break;

          case IRP_MN_QUERY_DEVICE_TEXT:
            USBPRINT_KdPrint2 (("USBPRINT.SYS: IRP_MN_QUERY_DEVICE_TEXT\n"));
            if(deviceExtension->IsChildDevice==TRUE)
            {
                PCHILD_DEVICE_EXTENSION pChildDeviceExtension=(PCHILD_DEVICE_EXTENSION)deviceExtension;
                PDEVICE_EXTENSION pParentExtension=pChildDeviceExtension->ParentDeviceObject->DeviceExtension;
                USBPRINT_KdPrint2(("USBPRINT.SYS: Is child PDO, will complete locally\n"));
                switch(irpStack->Parameters.QueryDeviceText.DeviceTextType)
                {
                  case DeviceTextDescription:
                  {
                     ANSI_STRING     AnsiTextString;
                     UNICODE_STRING  UnicodeDeviceText;

                     RtlInitAnsiString(&AnsiTextString,pParentExtension->DeviceIdString);
                     ntStatus=RtlAnsiStringToUnicodeString(&UnicodeDeviceText,&AnsiTextString,TRUE);
                     USBPRINT_KdPrint2(("USBPRINT.SYS: QUERY_DEVICE_TEXT, DeviceID=%s\n",pParentExtension->DeviceIdString));
                     if(NT_SUCCESS(ntStatus))
                         Irp->IoStatus.Information=(ULONG_PTR)UnicodeDeviceText.Buffer;
                  }
                  break;
                  default:
                    ntStatus=Irp->IoStatus.Status;
                }
                bHandled=TRUE;
                USBPRINT_DecrementIoCount(DeviceObject);
                Irp->IoStatus.Status = ntStatus;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }


          break;


          case IRP_MN_QUERY_BUS_INFORMATION:

              if(deviceExtension->IsChildDevice==TRUE)
              {
                PPNP_BUS_INFORMATION  pBusInfo = ExAllocatePool( PagedPool, sizeof(PNP_BUS_INFORMATION) );
    
                USBPRINT_KdPrint2(("USBPRINT.SYS: IRP_MN_QUERY_BUS_INFORMATION\n"));
    
                if( pBusInfo )
                {
                    pBusInfo->BusTypeGuid      = GUID_BUS_TYPE_USBPRINT;
                    pBusInfo->LegacyBusType    = PNPBus;
                    pBusInfo->BusNumber        = 0;
                    ntStatus                   = STATUS_SUCCESS;
                    Irp->IoStatus.Information = (ULONG_PTR)pBusInfo;
                }
                else
                {
                    ntStatus = STATUS_NO_MEMORY;
                }
    
                bHandled = TRUE;
                USBPRINT_DecrementIoCount(DeviceObject);
                Irp->IoStatus.Status = ntStatus;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
              }
          break;






          case IRP_MN_QUERY_ID:
          {  
            USBPRINT_KdPrint2 (("USBPRINT.SYS: IRP_MN_QUERY_ID\n"));
            if(deviceExtension->IsChildDevice==TRUE)
            {
                USBPRINT_KdPrint2(("USBPRINT.SYS: Is child PDO, will complete locally\n"));
                ntStatus=ProduceQueriedID(deviceExtension,irpStack,Irp,DeviceObject);
                bHandled = TRUE;
                USBPRINT_DecrementIoCount(DeviceObject);
                Irp->IoStatus.Status = ntStatus;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            } /*end if child PDO*/
          } /*end case QUERY_ID*/
          break;

          case IRP_MN_QUERY_DEVICE_RELATIONS:
            USBPRINT_KdPrint2 (("USBPRINT.SYS: IRP_MN_QUERY_DEVICE_RELATIONS\n"));
            ntStatus=QueryDeviceRelations(DeviceObject,Irp,irpStack->Parameters.QueryDeviceRelations.Type,&bHandled);
            if ( bHandled )
                USBPRINT_DecrementIoCount(DeviceObject);
          break;

          case IRP_MN_QUERY_STOP_DEVICE:
          case IRP_MN_CANCEL_STOP_DEVICE:
          case IRP_MN_QUERY_REMOVE_DEVICE:
          case IRP_MN_CANCEL_REMOVE_DEVICE:
            if(deviceExtension->IsChildDevice)
            {
                Irp->IoStatus.Status = STATUS_SUCCESS;
                ntStatus=STATUS_SUCCESS;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            else
            {
                ntStatus = Irp->IoStatus.Status = STATUS_SUCCESS;
                IoSkipCurrentIrpStackLocation(Irp);
                ntStatus = IoCallDriver(stackDeviceObject,Irp);
            }
            USBPRINT_DecrementIoCount(DeviceObject);
            bHandled = TRUE;
            break;
          
  
        } /* end IRP_MN swich inside IRP_MJ_PNP case */


        if(!bHandled)
        {
          if(deviceExtension->IsChildDevice==TRUE)
          {
            USBPRINT_KdPrint3(("USBPRINT.SYS: unsupported child pnp IRP\n"));
            ntStatus = Irp->IoStatus.Status;
            IoCompleteRequest (Irp,IO_NO_INCREMENT);
          } /*end if child device*/
          else
          {
            IoSkipCurrentIrpStackLocation(Irp);
            ntStatus = IoCallDriver(stackDeviceObject,Irp);
          }

          USBPRINT_DecrementIoCount(DeviceObject);
        } /*end if !bHandled*/

#ifdef  MYDEBUG
    DbgPrint("Returning %d\n", ntStatus);
#endif
    return ntStatus;
} /*end function USBPRINT_Dispatch*/


NTSTATUS
USBPRINT_SystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;
    PDEVICE_OBJECT stackDeviceObject;

    PAGED_CODE();

    //
    // Get a pointer to the device extension
    //
    deviceExtension = DeviceObject->DeviceExtension;
    stackDeviceObject = deviceExtension->TopOfStackDeviceObject;

    USBPRINT_IncrementIoCount(DeviceObject);

    if(deviceExtension->IsChildDevice==TRUE)
    {
        USBPRINT_KdPrint3(("USBPRINT.SYS: unsupported child SystemControl IRP\n"));
        ntStatus = Irp->IoStatus.Status;
        IoCompleteRequest (Irp,IO_NO_INCREMENT);
    } /*end if child device*/
    else
    {
        IoSkipCurrentIrpStackLocation(Irp);
        ntStatus = IoCallDriver(stackDeviceObject,Irp);
    }

    USBPRINT_DecrementIoCount(DeviceObject);
    return ntStatus;
}


NTSTATUS QueryDeviceRelations(PDEVICE_OBJECT DeviceObject,PIRP Irp,DEVICE_RELATION_TYPE RelationType,BOOL *pbComplete)
{
        PIO_STACK_LOCATION irpSp;
        NTSTATUS ntStatus;
        PDEVICE_EXTENSION pExtension;
        PDEVICE_RELATIONS pRelations;
        *pbComplete=FALSE;



        pExtension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
        ntStatus=Irp->IoStatus.Status;
        irpSp=IoGetCurrentIrpStackLocation(Irp);

        if(!pExtension->IsChildDevice)
        {
            USBPRINT_KdPrint2 (("USBPRINT.SYS: Parent QueryDeviceRelations\n"));
                if(RelationType==BusRelations)
                {
                  *pbComplete=TRUE;
                  pRelations=(PDEVICE_RELATIONS)ExAllocatePoolWithTag(NonPagedPool,sizeof(DEVICE_RELATIONS), USBP_TAG);
                  if(pRelations!=NULL)
                  {
                          //Some drivers check for pre-existing children and preserve them.  This would happen if there is a filter driver above us, but we're not REALLY a bus driver

                          pRelations->Objects[0]=pExtension->ChildDevice;
                          pRelations->Count = 1;
                          ObReferenceObject(pExtension->ChildDevice);
                          Irp->IoStatus.Information=(ULONG_PTR)pRelations;
              Irp->IoStatus.Status = STATUS_SUCCESS;

                  IoCopyCurrentIrpStackLocationToNext(Irp);
                  ntStatus = IoCallDriver(pExtension->TopOfStackDeviceObject,Irp);
                  } /*end !NULL*/
                  else
                  {
                         ntStatus=STATUS_NO_MEMORY;
                         Irp->IoStatus.Status = ntStatus;
                         IoCompleteRequest(Irp, IO_NO_INCREMENT);
                  }
                //Port info will be written to the registry in the IRP_MN_QUERY_ID case.  It can't be used before then anyway
                } /*end if BusRelations*/

        } else {

            USBPRINT_KdPrint2 (("USBPRINT.SYS: Child QueryDeviceRelations\n"));
            if(RelationType==TargetDeviceRelation)
                {
                  *pbComplete=TRUE;
                  pRelations=(PDEVICE_RELATIONS)ExAllocatePoolWithTag(NonPagedPool,sizeof(DEVICE_RELATIONS), USBP_TAG);
                  if(pRelations!=NULL)
                  {
                        pRelations->Count = 1;
                          pRelations->Objects[0]=DeviceObject;
                          ObReferenceObject(DeviceObject);
                          Irp->IoStatus.Information=(ULONG_PTR)pRelations;
                          ntStatus = STATUS_SUCCESS;
                          Irp->IoStatus.Status = ntStatus;
                          IoCompleteRequest(Irp, IO_NO_INCREMENT);

                  } /*end !NULL*/
                  else
                  {
                         ntStatus=STATUS_NO_MEMORY;
                         Irp->IoStatus.Status = ntStatus;
                         IoCompleteRequest(Irp, IO_NO_INCREMENT);
                  }
                //Port info will be written to the registry in the IRP_MN_QUERY_ID case.  It can't be used before then anyway
                } /*end if BusRelations*/
        }
    return ntStatus;
}


VOID
USBPRINT_Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++    

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object

Return Value:


--*/
{
    USBPRINT_KdPrint2 (("USBPRINT.SYS:  enter USBPRINT_Unload\n"));
    
   if(pGPortList!=NULL)
    {
        ClearFreePorts(&pGPortList);
    }
 
//  if(pPortsUsed!=NULL)
//    ExFreePool(pPortsUsed);



    //
    // Free any global resources allocated
    // in DriverEntry
    //
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS:  exit USBPRINT_Unload\n"));
}


NTSTATUS
USBPRINT_StartDevice(
    IN  PDEVICE_OBJECT DeviceObject
    
    )
/*++

Routine Description:

    Initializes a given instance of the device on the USB.
    All we do here is get the device descriptor and store it

Arguments:

    DeviceObject - pointer to the device object for this instance of a  printer
                                          

Return Value:

    NT status code
    
      --*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;
    UNICODE_STRING KeyName;
    PUSB_DEVICE_DESCRIPTOR deviceDescriptor = NULL;
    PURB urb=NULL;
    ULONG siz;
    ULONG dwVidPid;
    PDEVICE_OBJECT NewDevice;
    LARGE_INTEGER   timeOut;
        
    PCHILD_DEVICE_EXTENSION pChildExtension;
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS: enter USBPRINT_StartDevice\n")); 
    

    
    deviceExtension = DeviceObject->DeviceExtension;
    
    
    ntStatus = USBPRINT_ConfigureDevice(DeviceObject);
    if(NT_SUCCESS(ntStatus))
    {
      urb = ExAllocatePoolWithTag(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST), USBP_TAG);
    }
    else
    {
        USBPRINT_KdPrint1(("USBPRINT.SYS:  USBPRINT_ConfigureDevice Failed\n"));   
        urb=NULL;
    }
    if (urb) 
    {
         siz = sizeof(USB_DEVICE_DESCRIPTOR);
        
        deviceDescriptor = ExAllocatePoolWithTag(NonPagedPool,siz, USBP_TAG); 
        
        if (deviceDescriptor) 
        {
            
            
            UsbBuildGetDescriptorRequest(urb,
                (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                USB_DEVICE_DESCRIPTOR_TYPE,
                0,
                0,
                deviceDescriptor,
                NULL,
                siz,
                NULL);
            
            timeOut.QuadPart = FAILURE_TIMEOUT;
            ntStatus = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);
            
            
            if (NT_SUCCESS(ntStatus)) 
            {
                USBPRINT_KdPrint3 (("USBPRINT.SYS: Device Descriptor = %x, len %x\n",
                    deviceDescriptor,
                    urb->UrbControlDescriptorRequest.TransferBufferLength));
                
                USBPRINT_KdPrint3 (("USBPRINT.SYS: USBPRINT Device Descriptor:\n"));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: -------------------------\n"));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: bLength %d\n", deviceDescriptor->bLength));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: bDescriptorType 0x%x\n", deviceDescriptor->bDescriptorType));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: bcdUSB 0x%x\n", deviceDescriptor->bcdUSB));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: bDeviceClass 0x%x\n", deviceDescriptor->bDeviceClass));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: bDeviceSubClass 0x%x\n", deviceDescriptor->bDeviceSubClass));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: bDeviceProtocol 0x%x\n", deviceDescriptor->bDeviceProtocol));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: bMaxPacketSize0 0x%x\n", deviceDescriptor->bMaxPacketSize0));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: idVendor 0x%x\n", deviceDescriptor->idVendor));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: idProduct 0x%x\n", deviceDescriptor->idProduct));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: bcdDevice 0x%x\n", deviceDescriptor->bcdDevice));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: iManufacturer 0x%x\n", deviceDescriptor->iManufacturer));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: iProduct 0x%x\n", deviceDescriptor->iProduct));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: iSerialNumber 0x%x\n", deviceDescriptor->iSerialNumber));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: bNumConfigurations 0x%x\n", deviceDescriptor->bNumConfigurations));
                
                dwVidPid=deviceDescriptor->idVendor;
                dwVidPid<<=16;
                dwVidPid+=deviceDescriptor->idProduct;
                
                USBPRINT_KdPrint3 (("USBPRINT.SYS: Math OK\n"));
                
            }
            else
            {
              USBPRINT_KdPrint1(("USBPRINT.SYS: Get Device Descriptor failed\n"));
              ntStatus=STATUS_DEVICE_CONFIGURATION_ERROR;
            }
        } 
        else 
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            USBPRINT_KdPrint1(("USBPRINT.SYS: Insufficient resources to allocate device descriptor in StartDevice\n"));
        }
        
        if (NT_SUCCESS(ntStatus)) 
        {
            deviceExtension->DeviceDescriptor = deviceDescriptor;
        } else if (deviceDescriptor) 
        {
            ExFreePool(deviceDescriptor);
        }
        
        ExFreePool(urb);
        
    }
    else 
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        USBPRINT_KdPrint1(("USBPRINT.SYS: Insufficient resources to allocate urb in StartDevice\n"));
 
    }
    

    if(deviceExtension->bChildDeviceHere==FALSE)
    {
      if(NT_SUCCESS(ntStatus))
      {
         ntStatus=IoCreateDevice(USBPRINT_DriverObject,
         sizeof(CHILD_DEVICE_EXTENSION),
         NULL,
         FILE_DEVICE_PARALLEL_PORT,
         FILE_AUTOGENERATED_DEVICE_NAME,
         TRUE,
         &NewDevice);    
      
      }
      if(NT_SUCCESS(ntStatus))
      {
   
         USBPRINT_KdPrint3(("USBPRINT.SYS:  IoCreateDevice succeeded for child device\n"));
         NewDevice->Flags|=DO_POWER_PAGABLE;
         pChildExtension=NewDevice->DeviceExtension;
         pChildExtension->ParentDeviceObject=DeviceObject;
         deviceExtension->ChildDevice=NewDevice;
         deviceExtension->bChildDeviceHere=TRUE;
         pChildExtension->IsChildDevice=TRUE;
         pChildExtension->ulInstanceNumber=deviceExtension->ulInstanceNumber;

      
      }
    
      else
      {
           USBPRINT_KdPrint1(("USBPRINT.SYS:  IoCreateDevice failed for child device\n"));
      }
    } /*end if we need to make a child device*/
    if(NT_SUCCESS(ntStatus))
    {
   
        USBPRINT_GetDeviceID(DeviceObject);
        WritePortDescription(deviceExtension);
        ntStatus=IoSetDeviceInterfaceState(&(deviceExtension->DeviceLinkName),TRUE);


    }

    if (NT_SUCCESS(ntStatus)) 
    {
        ntStatus = USBPRINT_BuildPipeList(DeviceObject);
        if(!deviceExtension->IsChildDevice)
        {
            USBPRINT_FdoSubmitIdleRequestIrp(deviceExtension);
        }
    }
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS: exit USBPRINT_StartDevice (%x)\n", ntStatus)); 
    
    return ntStatus;
}

void WritePortDescription(PDEVICE_EXTENSION deviceExtension)
{
    UNICODE_STRING ValueName;
    ANSI_STRING     AnsiTextString;
    UNICODE_STRING Description;
    UNICODE_STRING BaseName,BaseValueName;
 



    RtlInitUnicodeString(&ValueName,L"Port Description");
    
    RtlInitAnsiString(&AnsiTextString,deviceExtension->DeviceIdString);
    RtlAnsiStringToUnicodeString(&Description,&AnsiTextString,TRUE);

                                                                                                           
    ZwSetValueKey(deviceExtension->hInterfaceKey,&ValueName,0,REG_SZ,Description.Buffer,Description.Length+2);
    RtlFreeUnicodeString(&Description);


    RtlInitUnicodeString(&BaseName,L"USB");
    RtlInitUnicodeString(&BaseValueName,L"Base Name");
    ZwSetValueKey(deviceExtension->hInterfaceKey,&BaseValueName,0,REG_SZ,BaseName.Buffer,BaseName.Length+2);
}


NTSTATUS
USBPRINT_RemoveDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Stops a given instance of printer

Arguments:

    DeviceObject - pointer to the device object for this instance of the (parent) printer object

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    USBPRINT_KdPrint2 (("USBPRINT.SYS: enter USBPRINT_RemoveDevice\n"));
    

    deviceExtension = DeviceObject->DeviceExtension;


    ZwClose(deviceExtension->hInterfaceKey);
    USBPRINT_KdPrint2(("USBPRINT.SYS:  Closeing interface key in RemoveDevice\n"));  

    ntStatus=IoSetDeviceInterfaceState(&(deviceExtension->DeviceLinkName),FALSE);
    if(!NT_SUCCESS(ntStatus))
    {
        USBPRINT_KdPrint1 (("USBPRINT.SYS: ioSetDeviceInterface to false failed\n"));
    }

    RtlFreeUnicodeString(&(deviceExtension->DeviceLinkName));

    

    //
    // Free device descriptor structure
    //

    if (deviceExtension->DeviceDescriptor) {
    ExFreePool(deviceExtension->DeviceDescriptor);
    }

    //
    // Free up any interface structures
    //

    if (deviceExtension->Interface) {
    ExFreePool(deviceExtension->Interface);
    }

    USBPRINT_KdPrint2 (("USBPRINT.SYS: exit USBPRINT_RemoveDevice (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBPRINT_StopDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Stops a given instance of a printer  on the USB, this is only
    stuff we need to do if the device is still present.

Arguments:

    DeviceObject - pointer to the device object for this printer

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;
    ULONG siz;
    LARGE_INTEGER   timeOut;


    timeOut.QuadPart = FAILURE_TIMEOUT;


    USBPRINT_KdPrint3 (("USBPRINT.SYS: enter USBPRINT_StopDevice\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Send the select configuration urb with a NULL pointer for the configuration
    // handle, this closes the configuration and puts the device in the 'unconfigured'
    // state.
    //

    siz = sizeof(struct _URB_SELECT_CONFIGURATION);

    urb = ExAllocatePoolWithTag(NonPagedPool,siz, USBP_TAG);

    if (urb) {
    NTSTATUS status;

    UsbBuildSelectConfigurationRequest(urb,
                      (USHORT) siz,
                      NULL);

    status = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);

    USBPRINT_KdPrint3 (("USBPRINT.SYS: Device Configuration Closed status = %x usb status = %x.\n",
            status, urb->UrbHeader.Status));

    ExFreePool(urb);                                                                                   
    } else {
    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    USBPRINT_KdPrint2 (("USBPRINT.SYS: exit USBPRINT_StopDevice (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBPRINT_PnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    This routine is called to create a new instance of the device

Arguments:

    DriverObject - pointer to the driver object for this instance of USBPRINT

    PhysicalDeviceObject - pointer to a device object created by the bus

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT          deviceObject = NULL;
    PDEVICE_EXTENSION       deviceExtension;
    USBD_VERSION_INFORMATION versionInformation;
    ULONG ulPortNumber;
    GUID * pPrinterGuid;
    
    static ULONG instance = 0;
    //UNICODE_STRING deviceLinkUnicodeString;
    HANDLE hInterfaceKey;
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS:  enter USBPRINT_PnPAddDevice\n"));
    


    //
    // create our funtional device object (FDO)
    //

    ntStatus =
    USBPRINT_CreateDeviceObject(DriverObject, &deviceObject);

    if (NT_SUCCESS(ntStatus)) {
    deviceExtension = deviceObject->DeviceExtension;

    //
    // we support direct io for read/write
    //
    deviceObject->Flags |= DO_DIRECT_IO;
    deviceObject->Flags |= DO_POWER_PAGABLE;
    

    //** initialize our device extension
    //
    // remember the Physical device Object
    //
    deviceExtension->PhysicalDeviceObject=PhysicalDeviceObject;

    // init selective suspend stuff
    deviceExtension->PendingIdleIrp 	= NULL;
    deviceExtension->IdleCallbackInfo 	= NULL;
    deviceExtension->OpenCnt=0;
    deviceExtension->bD0IrpPending=FALSE;
    KeInitializeSpinLock(&(deviceExtension->WakeSpinLock));

    //
    // Attach to the PDO
    //

    deviceExtension->TopOfStackDeviceObject=IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);
    if(deviceExtension->TopOfStackDeviceObject==NULL)
    {
      USBPRINT_KdPrint1(("USBPRINT.SYS:  IoAttachDeviceToDeviceStack failed\n"));
    }                                                                                                                                                        
    else
    {
      USBPRINT_KdPrint3(("USBPRINT.SYS:  IoAttachDeviceToDeviceStack worked\n"));
    }

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    USBPRINT_KdPrint3(("'USBPRINT.SYS:  Before ioRegisterDeviceInterface\n"));
    pPrinterGuid=(GUID *)&USBPRINT_GUID;
    ntStatus=IoRegisterDeviceInterface(PhysicalDeviceObject,pPrinterGuid,NULL,&(deviceExtension->DeviceLinkName));
    if(!NT_SUCCESS(ntStatus))
    {
      USBPRINT_KdPrint1(("'USBPRINT.SYS:  ioRegisterDeviceInterface failed\n"));  
      goto AddDeviceFailure;
    }


    ntStatus=IoOpenDeviceInterfaceRegistryKey(&(deviceExtension->DeviceLinkName),KEY_ALL_ACCESS,&hInterfaceKey);
    USBPRINT_KdPrint2(("USBPRINT.SYS:  Opened Device Interface reg key in AddDevice\n"));  
    // moved to RemoveDevice RtlFreeUnicodeString(&deviceLinkUnicodeString);
    if(!NT_SUCCESS(ntStatus))
    {
      USBPRINT_KdPrint1(("USBPRINT.SYS: IoOpenDeviceInterfaceRegistryKey failed\n"));
      goto AddDeviceFailure;
    }
    USBPRINT_KdPrint3(("USBPRINT.SYS: IoOpenDeviceInterfaceRegistryKey succeeded\n"));
    deviceExtension->hInterfaceKey=hInterfaceKey;
    
    ntStatus=GetPortNumber(hInterfaceKey,&ulPortNumber);
    if(!NT_SUCCESS(ntStatus))
    {
      USBPRINT_KdPrint1(("USBPRINT.SYS: GetPortNumber failed\n"));
      goto AddDeviceFailure;
    }
    deviceExtension->ulInstanceNumber=ulPortNumber;
    USBPRINT_KdPrint2(("USBPRINT.SYS:   Allocated port # %u\n",ulPortNumber));
    
/*    ntStatus=IoSetDeviceInterfaceState(&(deviceExtension->DeviceLinkName),TRUE);


    if(NT_SUCCESS(ntStatus))
    {
      USBPRINT_KdPrint3(("USBPRINT.SYS:  IoSetDeviceInterfaceState worked\n"));
    }
    else
    {
      USBPRINT_KdPrint1(("USBPRINT.SYS:  IoSetDeviceInterfaceState did not work\n"));
      goto AddDeviceFailure;
    }

  */
    USBPRINT_QueryCapabilities(PhysicalDeviceObject,
                 &deviceExtension->DeviceCapabilities);            

    //
    // display the device  caps
    //
#if DBG
    {
    ULONG i;
    
    USBPRINT_KdPrint3(("USBPRINT.SYS:  >>>>>> DeviceCaps\n"));  
    USBPRINT_KdPrint3(("USBPRINT.SYS:  SystemWake = (%d)\n", 
        deviceExtension->DeviceCapabilities.SystemWake));    
    USBPRINT_KdPrint3(("USBPRINT.SYS:  DeviceWake = (D%d)\n",
        deviceExtension->DeviceCapabilities.DeviceWake-1));

    for (i=PowerSystemUnspecified; i< PowerSystemMaximum; i++) {
        
        USBPRINT_KdPrint3(("USBPRINT.SYS:  Device State Map: sysstate %d = devstate 0x%x\n", i, 
         deviceExtension->DeviceCapabilities.DeviceState[i]));       
    }
    USBPRINT_KdPrint3(("USBPRINT.SYS:  '<<<<<<<<DeviceCaps\n"));
    }
#endif
    //
    // transition to zero signals the event
    //
    USBPRINT_IncrementIoCount(deviceObject);                                 
    }

    USBD_GetUSBDIVersion(&versionInformation);
AddDeviceFailure:
    USBPRINT_KdPrint2 (("USBPRINT.SYS: exit USBPRINT_PnPAddDevice (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBPRINT_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *DeviceObject
    )
/*++

Routine Description:

    Creates a Functional DeviceObject

Arguments:

    DriverObject - pointer to the driver object for device

    DeviceObject - pointer to DeviceObject pointer to return
            created device object.

    Instance - instnace of the device create.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION deviceExtension;
    ULONG instance;

    USBPRINT_KdPrint2 (("USBPRINT.SYS: enter USBPRINT_CreateDeviceObject\n"));

    //
    // This driver supports up to 9 instances
    //



    ntStatus = IoCreateDevice (DriverObject,
                   sizeof (DEVICE_EXTENSION),
                   NULL,
                   FILE_DEVICE_UNKNOWN,
                   0,
                   FALSE,
                   DeviceObject);
    //
    // Initialize our device extension
    //

    deviceExtension = (PDEVICE_EXTENSION) ((*DeviceObject)->DeviceExtension);

    deviceExtension->IsChildDevice=FALSE;
    deviceExtension->ResetWorkItemPending=0; //init to "no workitem pending"
    deviceExtension->bChildDeviceHere=FALSE;

    deviceExtension->DeviceDescriptor = NULL;
    deviceExtension->Interface = NULL;
    deviceExtension->ConfigurationHandle = NULL;
    deviceExtension->AcceptingRequests = TRUE;
    deviceExtension->PendingIoCount = 0;

    deviceExtension->DeviceCapabilities.Size    = sizeof(DEVICE_CAPABILITIES);
    deviceExtension->DeviceCapabilities.Version = DEVICE_CAPABILITY_VERSION;
    deviceExtension->DeviceCapabilities.Address = (ULONG) -1;
    deviceExtension->DeviceCapabilities.UINumber= (ULONG) -1;

    deviceExtension->DeviceCapabilities.DeviceState[PowerSystemWorking] = PowerDeviceD0;
    deviceExtension->DeviceCapabilities.DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
    deviceExtension->DeviceCapabilities.DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
    deviceExtension->DeviceCapabilities.DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
    deviceExtension->DeviceCapabilities.DeviceState[PowerSystemHibernate] = PowerDeviceD3;
    deviceExtension->DeviceCapabilities.DeviceState[PowerSystemShutdown] = PowerDeviceD3;

    KeInitializeEvent(&deviceExtension->RemoveEvent, NotificationEvent, FALSE);

    USBPRINT_KdPrint2 (("USBPRINT.SYS: exit USBPRINT_CreateDeviceObject (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBPRINT_CallUSBD(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb,
    IN PLARGE_INTEGER   pTimeout 
    )
/*++

Routine Description:

    Passes a URB to the USBD class driver

Arguments:

    DeviceObject - pointer to the device object for this printer

    Urb - pointer to Urb request block

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    PIRP irp;
    KEVENT event;
    PIO_STACK_LOCATION nextStack;



    USBPRINT_KdPrint2 (("USBPRINT.SYS: enter USBPRINT_CallUSBD\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    if ( (irp = IoAllocateIrp(deviceExtension->TopOfStackDeviceObject->StackSize,
                              FALSE)) == NULL )
        return STATUS_INSUFFICIENT_RESOURCES;

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    //
    // pass the URB to the USB driver stack
    //
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
    nextStack->Parameters.Others.Argument1 = Urb;

    IoSetCompletionRoutine(irp,
               USBPRINT_DeferIrpCompletion,
               &event,
               TRUE,
               TRUE,
               TRUE);
               
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                irp);

    if ( ntStatus == STATUS_PENDING ) 
    {
        status = KeWaitForSingleObject(&event,Suspended,KernelMode,FALSE,pTimeout);
        //
        // If the request timed out cancel the request
        // and wait for it to complete
        //
        if ( status == STATUS_TIMEOUT ) {

#ifdef  MYDEBUG
            DbgPrint("Call_USBD: Cancelling IRP %X because of timeout\n", irp);
#endif

            IoCancelIrp(irp);
            KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, NULL);
        }

        ntStatus = irp->IoStatus.Status;
    }

    IoFreeIrp(irp);

    USBPRINT_KdPrint2 (("USBPRINT.SYS: exit USBPRINT_CallUSBD (%x)\n", ntStatus));

    USBPRINT_KdPrint3 (("USBPRINT.SYS: About to return from CallUSBD, status=%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBPRINT_ConfigureDevice(
                         IN  PDEVICE_OBJECT DeviceObject
                         )
/*++
                         
Routine Description:
     Initializes a given instance of the device on the USB and selects the configuration.
                             
Arguments:
     DeviceObject - pointer to the device object for this printer devcice.

 Return Value:  
     NT status code
                                       
--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;
    PURB urb;
    ULONG siz;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = NULL;
    LARGE_INTEGER   timeOut;
    int tries=0;


    timeOut.QuadPart = FAILURE_TIMEOUT;

    
    USBPRINT_KdPrint2 (("USBPRINT.SYS: enter USBPRINT_ConfigureDevice\n")); 
    
    deviceExtension = DeviceObject->DeviceExtension;
    
    //
    // first configure the device
    //
    
    urb = ExAllocatePoolWithTag(NonPagedPool,sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST), USBP_TAG);
    
    if (urb) 
    {
        siz = sizeof(USB_CONFIGURATION_DESCRIPTOR)+256;
        
get_config_descriptor_retry:
        
        configurationDescriptor = ExAllocatePoolWithTag(NonPagedPool,siz, USBP_TAG);
        
        if (configurationDescriptor) 
        {
            
            UsbBuildGetDescriptorRequest(urb,
                (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                USB_CONFIGURATION_DESCRIPTOR_TYPE,
                0,
                0,
                configurationDescriptor,
                NULL,
                siz,
                NULL);
            
            ntStatus = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);
            if(!NT_SUCCESS(ntStatus))
            {
                USBPRINT_KdPrint1 (("USBPRINT.SYS: Get Configuration descriptor failed\n"));
            }
            else
            {
                //
                // if we got some data see if it was enough.
                //
                // NOTE: we may get an error in URB because of buffer overrun
                if (urb->UrbControlDescriptorRequest.TransferBufferLength>0 &&configurationDescriptor->wTotalLength > siz)
                {
                
                    #define MAX_MEM_FOR_DESCRIPTOR 1024 * 25

                    if((siz>MAX_MEM_FOR_DESCRIPTOR)||((tries++)==10))
                    {
                        USBPRINT_KdPrint3 (("USBPRINT.SYS: ConfigureDevice, this device appears to be lying to us about descriptor size\n"));
                        ExFreePool(configurationDescriptor);
                        configurationDescriptor = NULL;
                        ntStatus=STATUS_DEVICE_CONFIGURATION_ERROR;
                    }
                    else
                    {
                    
                        siz = configurationDescriptor->wTotalLength;
                        ExFreePool(configurationDescriptor);
                        configurationDescriptor = NULL;
                        goto get_config_descriptor_retry;
                    }
                } //end if not big enough
            }  //end else we got some sort of descriptor
            
            USBPRINT_KdPrint3 (("USBPRINT.SYS: Configuration Descriptor = %x, len %x\n",
                configurationDescriptor,
                urb->UrbControlDescriptorRequest.TransferBufferLength));
        } 
        else 
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            USBPRINT_KdPrint1(("USBPRINT.SYS: Insufficient resources to allocate configuration descriptor in ConfigureDevice\n"));
        }
                
        ExFreePool(urb);
        
    } 
    else 
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    if (configurationDescriptor) 
    {
        
        USBPRINT_KdPrint2(("USBPRINT.SYS: ConfigureDevice, We have a configuration descriptor!\n"));
        //
        // We have the configuration descriptor for the configuration
        // we want.
        //
        // Now we issue the select configuration command to get
        // the  pipes associated with this configuration.
        //
        if(NT_SUCCESS(ntStatus))
        {
          ntStatus = USBPRINT_SelectInterface(DeviceObject,configurationDescriptor);
          
        }
        ExFreePool(configurationDescriptor);
    }
    else
    {
            USBPRINT_KdPrint1(("USBPRINT.SYS: ConfigureDevice, No Configuration descriptor.\n"));
    }
    
    
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS: exit USBPRINT_ConfigureDevice (%x)\n", ntStatus));
    
    return ntStatus;
}


NTSTATUS USBPRINT_SelectInterface(IN PDEVICE_OBJECT DeviceObject,IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor)
/*++

Routine Description:

    Initializes a printer with multiple interfaces

Arguments:

    DeviceObject - pointer to the device object for this printer
            

    ConfigurationDescriptor - pointer to the USB configuration
            descriptor containing the interface and endpoint
            descriptors.

Return Value:

    NT status code

  --*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;
    PURB urb = NULL;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor = NULL;
    PUSBD_INTERFACE_INFORMATION Interface = NULL;
    USBD_INTERFACE_LIST_ENTRY InterfaceList[2];
    LARGE_INTEGER   timeOut;


    timeOut.QuadPart = FAILURE_TIMEOUT;

    
    USBPRINT_KdPrint2 (("USBPRINT.SYS: enter USBPRINT_SelectInterface\n"));
    deviceExtension = DeviceObject->DeviceExtension;
    
    //starting at offset 0, search for an alternate interface with protocol code 2;  Ignore InterfaceNumber, AlternateSetting, InterfaceClass, InterfaceSubClass
    interfaceDescriptor=USBD_ParseConfigurationDescriptorEx(ConfigurationDescriptor,ConfigurationDescriptor,-1,-1,-1,-1,2);
    if(!interfaceDescriptor)
    {
        USBPRINT_KdPrint3 (("USBPRINT.SYS:  First ParseConfigurationDescriptorEx failed\n"));
        interfaceDescriptor=USBD_ParseConfigurationDescriptorEx(ConfigurationDescriptor,ConfigurationDescriptor,-1,-1,-1,-1,1);
        if(!interfaceDescriptor)
        {
            USBPRINT_KdPrint1 (("USBPRINT.SYS:  second ParseConfigurationDescriptorEx failed\n"));
            ntStatus=STATUS_DEVICE_CONFIGURATION_ERROR;
        }
        else
        {
            USBPRINT_KdPrint3 (("USBPRINT.SYS:  second ParseConfigurationDescriptorEx success\n"));
            deviceExtension->bReadSupported=FALSE;
        } /*end second ParseConfigDescriptor worked*/
    }
    else
    {
        deviceExtension->bReadSupported=TRUE;
        USBPRINT_KdPrint3 (("USBPRINT.SYS:  First ParseConfigurationDescriptorEx success\n"));
    }
    if(interfaceDescriptor)
    {
        InterfaceList[0].InterfaceDescriptor=interfaceDescriptor;
        InterfaceList[1].InterfaceDescriptor=NULL;
        urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor,InterfaceList);
        if (urb) 
        {
            Interface = InterfaceList[0].Interface;
            ntStatus = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);
        } 
        else 
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            USBPRINT_KdPrint1 (("USBPRINT.SYS: CreateConfigurationRequest failed\n"));
        }
    } //end found good interface
    else
    {
        USBPRINT_KdPrint1 (("USBPRINT.SYS: failed to locate apropriate interface\n"));
    } //end no interface
    
   
    if (NT_SUCCESS(ntStatus)) 
    {
        
        //
        // Save the configuration handle for this device
        //
        
        USBPRINT_KdPrint3 (("USBPRINT.SYS: SelectInterface, Inside good config case\n"));
        deviceExtension->ConfigurationHandle = urb->UrbSelectConfiguration.ConfigurationHandle;
        
        deviceExtension->Interface = ExAllocatePoolWithTag(NonPagedPool,Interface->Length, USBP_TAG);
        
        if (deviceExtension->Interface) 
        {
            ULONG j;
            //
            // save a copy of the interface information returned
            //
            RtlCopyMemory(deviceExtension->Interface, Interface, Interface->Length);
            
            //
            // Dump the interface to the debugger
            //
            USBPRINT_KdPrint3 (("USBPRINT.SYS: ---------\n"));
            USBPRINT_KdPrint3 (("USBPRINT.SYS: NumberOfPipes 0x%x\n", deviceExtension->Interface->NumberOfPipes));
            USBPRINT_KdPrint3 (("USBPRINT.SYS: Length 0x%x\n", deviceExtension->Interface->Length));
            USBPRINT_KdPrint3 (("USBPRINT.SYS: Alt Setting 0x%x\n", deviceExtension->Interface->AlternateSetting));
            USBPRINT_KdPrint3 (("USBPRINT.SYS: Interface Number 0x%x\n", deviceExtension->Interface->InterfaceNumber));
            USBPRINT_KdPrint3 (("USBPRINT.SYS: Class, subclass, protocol 0x%x 0x%x 0x%x\n",
                deviceExtension->Interface->Class,
                deviceExtension->Interface->SubClass,
                deviceExtension->Interface->Protocol));
            
            // Dump the pipe info
            
            for (j=0; j<Interface->NumberOfPipes; j++) 
            {
                PUSBD_PIPE_INFORMATION pipeInformation;
                
                pipeInformation = &deviceExtension->Interface->Pipes[j];
                
                USBPRINT_KdPrint3 (("USBPRINT.SYS: ---------\n"));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: PipeType 0x%x\n", pipeInformation->PipeType));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: EndpointAddress 0x%x\n", pipeInformation->EndpointAddress));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: MaxPacketSize 0x%x\n", pipeInformation->MaximumPacketSize));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: Interval 0x%x\n", pipeInformation->Interval));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: Handle 0x%x\n", pipeInformation->PipeHandle));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: MaximumTransferSize 0x%x\n", pipeInformation->MaximumTransferSize));
            }
            
            USBPRINT_KdPrint3 (("USBPRINT.SYS: ---------\n"));
        } /*end if interface Alloc OK*/
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            USBPRINT_KdPrint1 (("USBPRINT.SYS: Alloc failed in SelectInterface\n"));
        }
    }
    
    if (urb) 
    {
        ExFreePool(urb);
    }
    USBPRINT_KdPrint2 (("USBPRINT.SYS: exit USBPRINT_SelectInterface (%x)\n", ntStatus));
    
    return ntStatus;
}


NTSTATUS
USBPRINT_BuildPipeList(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to the device object for this printer
            devcice.


Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    ULONG i;
    WCHAR Name[] = L"\\PIPE00";
    PUSBD_INTERFACE_INFORMATION InterfaceDescriptor;
    BOOL bFoundWritePipe=FALSE,bFoundReadPipe=FALSE,bNeedReadPipe=FALSE;
    

    deviceExtension = DeviceObject->DeviceExtension;
    InterfaceDescriptor = deviceExtension->Interface;

    USBPRINT_KdPrint2 (("USBPRINT.SYS: enter USBPRINT_BuildPipeList\n"));

    deviceExtension = DeviceObject->DeviceExtension;
    if(InterfaceDescriptor->Protocol==2)
        bNeedReadPipe=TRUE;
    else
        bNeedReadPipe=FALSE;


    for (i=0; i<InterfaceDescriptor->NumberOfPipes; i++) {
        USBPRINT_KdPrint3 (("USBPRINT.SYS: about to look at endpoint with address 0x%x)\n",InterfaceDescriptor->Pipes[i].EndpointAddress));
        if(((InterfaceDescriptor->Pipes[i].EndpointAddress)&0x80)==0) //if bit 7 is 0, it's an OUT endpoint
        {
          if(bFoundWritePipe==TRUE)
          {
            USBPRINT_KdPrint1 (("USBPRINT.SYS: Warning!!  Multiple OUT pipes detected on printer.  Defaulting to first pipe\n"));
          } /*end if we've already found a write pipe*/
          else
          {
            USBPRINT_KdPrint3 (("USBPRINT.SYS: Found write pipe\n"));
            deviceExtension->pWritePipe=&(InterfaceDescriptor->Pipes[i]);
            bFoundWritePipe=TRUE;
          } /*else we haven't seen an OUT endpont before*/
        } /*end if it's an OUT endpoint*/
        else
        {
          if(!bNeedReadPipe)
          {
            USBPRINT_KdPrint1 (("USBPRINT.SYS: Warning!!  unexpected IN pipe (not specified in protocol field)\n"));
          } /*end if we don't need a read pipe, but we found one*/
          else if(bFoundReadPipe)
          {
              USBPRINT_KdPrint1 (("USBPRINT.SYS: Warning!!  Multiple IN pipes detected on printer.  Defaulting to first pipe\n"));
          } /*end if we've already found a read pipe*/
          else
          {     
            USBPRINT_KdPrint3 (("USBPRINT.SYS: Found read pipe\n"));
            deviceExtension->pReadPipe=&(InterfaceDescriptor->Pipes[i]);
            bFoundReadPipe=TRUE;
          } /*end else we're supposed to have an IN pipe, and this is the first one we've seen*/
        } /*end else it's an IN endpoint*/
    } /*end for*/
    if((bNeedReadPipe==TRUE)&&(bFoundReadPipe==FALSE))
    {
        USBPRINT_KdPrint1 (("USBPRINT.SYS: Warning!!  IN pipe was specified in protocol field, but was not found\n"));
    } /*end if we needed a read pipe, and didn't find one*/
    deviceExtension->bReadPipeExists=bFoundReadPipe;
    return STATUS_SUCCESS;
} /*end function BuildPipeList*/


NTSTATUS
USBPRINT_ResetPipe(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE_INFORMATION Pipe,
    IN BOOLEAN IsoClearStall
    )
/*++

Routine Description:

    Reset a given USB pipe.
    
    NOTES:

    This will reset the host to Data0 and should also reset the device
    to Data0 for Bulk and Interrupt pipes.

    For Iso pipes this will set the virgin state of pipe so that ASAP
    transfers begin with the current bus frame instead of the next frame
    after the last transfer occurred.

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PURB urb;
    LARGE_INTEGER   timeOut;


    timeOut.QuadPart = FAILURE_TIMEOUT;


    USBPRINT_KdPrint2 (("USBPRINT.SYS: Entering Reset Pipe; pipe # %x\n", Pipe)); 

    urb = ExAllocatePoolWithTag(NonPagedPool,sizeof(struct _URB_PIPE_REQUEST), USBP_TAG);

    if (urb) {

    urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
    urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
    urb->UrbPipeRequest.PipeHandle =
        Pipe->PipeHandle;

    ntStatus = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);
    
    if(!NT_SUCCESS(ntStatus))
    {
      USBPRINT_KdPrint1(("USBPRINT.SYS: CallUSBD failed in ResetPipe\n"));
    }
    else
    {
      USBPRINT_KdPrint3(("USBPRINT.SYS: CallUSBD Succeeded in ResetPipe\n"));
    }

    ExFreePool(urb);

    } else {
    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Memphis RESET_PIPE will send a Clear-Feature Endpoint Stall to
    // reset the data toggle of non-Iso pipes as part of a RESET_PIPE
    // request.  It does not do this for Iso pipes as Iso pipes do not use
    // the data toggle (all Iso packets are Data0).  However, we also use
    // the Clear-Feature Endpoint Stall request in our device firmware to
    // reset data buffer points inside the device so we explicitly send
    // this request to the device for Iso pipes if desired.
    //
    if (NT_SUCCESS(ntStatus) && IsoClearStall &&
    (Pipe->PipeType == UsbdPipeTypeIsochronous)) {
    
    urb = ExAllocatePoolWithTag(NonPagedPool,sizeof(struct _URB_CONTROL_FEATURE_REQUEST), USBP_TAG);

    if (urb) {

        UsbBuildFeatureRequest(urb,
                   URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT,
                   USB_FEATURE_ENDPOINT_STALL,
                   Pipe->EndpointAddress,
                   NULL);

        ntStatus = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);
            

        ExFreePool(urb);
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    }

    return ntStatus;
}


LONG
USBPRINT_DecrementIoCount(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PDEVICE_EXTENSION deviceExtension;
    LONG ioCount=0;

    deviceExtension = DeviceObject->DeviceExtension;
    if(!(deviceExtension->IsChildDevice))
    {
      ioCount = InterlockedDecrement(&deviceExtension->PendingIoCount);

#ifdef  MYDEBUG
    DbgPrint("USBPRINT_DecrementIoCount -- IoCount %d\n", deviceExtension->PendingIoCount);
#endif
      USBPRINT_KdPrint3 (("USBPRINT.SYS: Pending io count = %x\n", ioCount));

      if (ioCount==0) {
      KeSetEvent(&deviceExtension->RemoveEvent,
           1,
           FALSE);
      }
    } /*end if ! child device*/

    return ioCount;
}


VOID
USBPRINT_IncrementIoCount(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = DeviceObject->DeviceExtension;
    if(!(deviceExtension->IsChildDevice))
    {
      InterlockedIncrement(&deviceExtension->PendingIoCount);
#ifdef  MYDEBUG
    DbgPrint("USBPRINT_IncrementIoCount -- IoCount %d\n", deviceExtension->PendingIoCount);
#endif
      //
      // Everytime iocount goes to 0 we set this event
      // so we must cleat it when we have a new io
      //
      KeClearEvent(&deviceExtension->RemoveEvent);
    }
}


NTSTATUS
USBPRINT_ReconfigureDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Initializes a given instance of the device on the USB and selects the
    configuration.

Arguments:

    DeviceObject - pointer to the device object for this printer
            


Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_INTERFACE_INFORMATION InterfaceDescriptor;

    USBPRINT_KdPrint2 (("USBPRINT.SYS: enter USBPRINT_ReconfigureDevice\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    if (NT_SUCCESS(ntStatus)) {
    ntStatus = USBPRINT_ConfigureDevice(DeviceObject);
    }

    //
    // new InterfaceDescriptor structure is now set up
    //

    InterfaceDescriptor = deviceExtension->Interface;

    //
    // set up the pipe handles again
    //


    return ntStatus;
}


NTSTATUS LoadPortsUsed(GUID *pPrinterGuid,PFREE_PORTS * pPortList,WCHAR *wcBaseName)
{
    NTSTATUS ReturnStatus=STATUS_SUCCESS,Result=STATUS_SUCCESS;
    PWSTR pDeviceList;
    PWSTR pWalk;
    UNICODE_STRING wNumberValueName,wBaseValueName,wLinkName;
    ULONG ulPortNum;
    ULONG ulBaseNameSizeIn,ulBaseNameSizeOut,ulPortNumSizeIn,ulPortNumSizeOut;
    PKEY_VALUE_PARTIAL_INFORMATION pBaseValueStruct,pNumberValueStruct;
    HANDLE hInterfaceKey;
    BOOL bFoundUsbPort;
    
    
    
    Result=IoGetDeviceInterfaces(pPrinterGuid,NULL,DEVICE_INTERFACE_INCLUDE_NONACTIVE,&pDeviceList);
    if(Result==STATUS_SUCCESS)
    {
        RtlInitUnicodeString(&wNumberValueName,PORT_NUM_VALUE_NAME);
        RtlInitUnicodeString(&wBaseValueName,PORT_BASE_NAME);
        pWalk=pDeviceList;
        ulBaseNameSizeIn=sizeof(KEY_VALUE_PARTIAL_INFORMATION)+((wcslen(wcBaseName)+1)*sizeof(WCHAR)); //this is a byte to much.  Oh well
        ulPortNumSizeIn=sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(ULONG);
        pBaseValueStruct=ExAllocatePoolWithTag(NonPagedPool,ulBaseNameSizeIn, USBP_TAG);
        pNumberValueStruct=ExAllocatePoolWithTag(NonPagedPool,ulPortNumSizeIn, USBP_TAG);
        if((pBaseValueStruct!=NULL)&&(pNumberValueStruct!=NULL))
        {
            while( *pWalk!=0 && NT_SUCCESS(ReturnStatus) )
            {
                RtlInitUnicodeString(&wLinkName,pWalk);
                Result=IoOpenDeviceInterfaceRegistryKey(&wLinkName,KEY_ALL_ACCESS,&hInterfaceKey);
                if(NT_SUCCESS(Result))
                {
                    
                    //The following is:  If there is not a value, or there is a value that matches what we expect, then set bFoundUsbPort to true
                    bFoundUsbPort=TRUE;
                    Result=ZwQueryValueKey(hInterfaceKey,&wBaseValueName,KeyValuePartialInformation,pBaseValueStruct,ulBaseNameSizeIn,&ulBaseNameSizeOut);
                    if(NT_SUCCESS(Result))
                    {
                        if(wcscmp(wcBaseName,(WCHAR *)(pBaseValueStruct->Data))!=0)
                            bFoundUsbPort=FALSE;
                    }//end if Query OK 
                    else if(STATUS_OBJECT_NAME_NOT_FOUND!=Result)
                    {
                        bFoundUsbPort=FALSE;
                    }
                    if(bFoundUsbPort)
                    {
                        Result=ZwQueryValueKey(hInterfaceKey,&wNumberValueName,KeyValuePartialInformation,pNumberValueStruct,ulPortNumSizeIn,&ulPortNumSizeOut);
                        if(NT_SUCCESS(Result))
                        {
                            ulPortNum=*((ULONG *)(pNumberValueStruct->Data));
                            if(!bDeleteIfRecyclable(hInterfaceKey))
                            {
                                USBPRINT_KdPrint2(("USBPRINT.SYS:  Adding port number\n"));
                                ReturnStatus=bAddPortInUseItem(pPortList,ulPortNum);
                                if(!NT_SUCCESS(ReturnStatus))
                                {
                                    USBPRINT_KdPrint1(("USBPRINT.SYS:  Unable to add port %u to port list\n",ulPortNum));
                                    USBPRINT_KdPrint1(("USBPRINT.SYS:  Failing out of LoadPortsUsed due to ntstatus failure %d\n",ReturnStatus));
                                } //end if AddPortInUse failed
                            } //end if port not deleted
                            else
                            {
//                                ReturnStatus=STATUS_INVALID_PARAMETER;
                                USBPRINT_KdPrint1(("USBPRINT.SYS:  Invalid port number %u\n",ulPortNum));
                            }
                        } //end if Query Port Number OK
                        //no else.  If there's no port number, we ignore this interface
                    } //End if bFoundUSbPort
                    ZwClose(hInterfaceKey);
                } //end if OpenReg ok
                pWalk=pWalk+wcslen(pWalk)+1;
            } //end while
        } //end ExAllocatePool OK
        else
        {
            USBPRINT_KdPrint1(("USBPRINT.SYS:  Unable to allocate memory"));
            ReturnStatus=STATUS_INSUFFICIENT_RESOURCES;
        }   /*end else ExAllocatePool failed*/
        if(pBaseValueStruct!=NULL)
            ExFreePool(pBaseValueStruct);
        if(pNumberValueStruct!=NULL)
            ExFreePool(pNumberValueStruct);
        ExFreePool(pDeviceList);
    } /*end if IoGetDeviceInterfaces success*/
    else
    {
        USBPRINT_KdPrint1(("USBPRINT.SYS:  IoGetDeviceInterfaces failed"));
        ReturnStatus=Result; //do some error translation here?
    }
    return ReturnStatus;
} /*end function LoadPortsUsed*/
                                

NTSTATUS GetPortNumber(HANDLE hInterfaceKey,
                       ULONG *ulReturnNumber)
{
  ULONG ulPortNumber,ulSizeUsed;
  NTSTATUS ntStatus=STATUS_SUCCESS;
  UNICODE_STRING uncValueName;
  PKEY_VALUE_PARTIAL_INFORMATION pValueStruct;


  ulSizeUsed=sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(ULONG); //this is a byte to much.  Oh well
  pValueStruct=ExAllocatePoolWithTag(PagedPool,ulSizeUsed, USBP_TAG);
  if(pValueStruct==NULL)
      return STATUS_INSUFFICIENT_RESOURCES;
  RtlInitUnicodeString(&uncValueName,PORT_NUM_VALUE_NAME);
  ntStatus=ZwQueryValueKey(hInterfaceKey,&uncValueName,KeyValuePartialInformation,(PVOID)pValueStruct,ulSizeUsed,&ulSizeUsed);
  if(!NT_SUCCESS(ntStatus))
  {
    USBPRINT_KdPrint2(("USBPRINT.SYS: GetPortNumber; ZwQueryValueKey failed\n"));
    switch(ntStatus)
    {
    case STATUS_BUFFER_OVERFLOW:          
      USBPRINT_KdPrint2(("USBPRINT.SYS: GetPortNumber zwQueryValueKey returned STATUS_BUFFER_OVERFLOW\n"));
    break;
    
    case STATUS_INVALID_PARAMETER:
      USBPRINT_KdPrint2(("USBPRINT.SYS: GetPortNumber zwQueryValueKey returned STATUS_INVALID_PARAMETER\n"));
    break;


    case STATUS_OBJECT_NAME_NOT_FOUND:
      USBPRINT_KdPrint2(("USBPRINT.SYS: GetPortNumber zwQueryValueKey returned STATUS_OBJECT_NAME_NOT_FOUND\n"));
    break;

    default:
          USBPRINT_KdPrint2(("USBPRINT.SYS: GetPortNumber zwQueryValueKey returned unkown error\n"));
    }
    ntStatus=GetNewPortNumber(&pGPortList,&ulPortNumber);

  }
  else
  { 
    ulPortNumber=*((ULONG *)&(pValueStruct->Data));
    if(ulPortNumber==0) //zero is a placeholder for "not there" which we use because win9x is missing the zwDeleteValueKey api
      ntStatus=GetNewPortNumber(&pGPortList,&ulPortNumber);
    else
      vClaimPortNumber(ulPortNumber,hInterfaceKey,&pGPortList);
  }
  if(!NT_SUCCESS(ntStatus))
  {
    USBPRINT_KdPrint1(("USBPRINT.SYS: GetPortNumber; failed to allocate new port number\n"));
  }
  else
  {
    
      *ulReturnNumber=ulPortNumber;
      USBPRINT_KdPrint3(("USBPRINT.SYS: GetPortNumber; Inside \"write back to reg\" case, ulPortNumber==%d\n",ulPortNumber));
      USBPRINT_KdPrint3(("USBPRINT.SYS: GetPortNumber; Before ntstatys=success\n"));
      ntStatus=STATUS_SUCCESS;
      USBPRINT_KdPrint3(("USBPRINT.SYS: GetPortNumber; Before ZwSetValueKey\n"));
      ntStatus=ZwSetValueKey(hInterfaceKey,&uncValueName,0,REG_DWORD,&ulPortNumber,sizeof(ulPortNumber));
      if(!NT_SUCCESS(ntStatus))
      {
        USBPRINT_KdPrint1(("USBPRINT.SYS: GetPortNumber; Unable to set value key\n"));
      }
      else
      {
        *ulReturnNumber=ulPortNumber;
      }
  }
  ExFreePool(pValueStruct);
  return ntStatus;
} /*end function GetPortNumber*/


USBPRINT_GetDeviceID(PDEVICE_OBJECT ParentDeviceObject)
{
    UCHAR *p1284Id;
    NTSTATUS ntStatus;
    int iReturnSize;
    PDEVICE_EXTENSION pParentExtension;
    

    pParentExtension=ParentDeviceObject->DeviceExtension;

    USBPRINT_KdPrint1 (("USBPRINT.SYS: GetDeviceID enter\n"));  /*dd*/


    p1284Id=ExAllocatePoolWithTag(NonPagedPool,MAX_ID_SIZE, USBP_TAG);
    if(p1284Id==NULL)
    {
        pParentExtension->bBadDeviceID=TRUE;
        USBPRINT_KdPrint1 (("USBPRINT.SYS: Memory Allocation failed in GetDeviceID\n"));
        sprintf(pParentExtension->DeviceIdString,BOGUS_PNP_ID);
    }
    else
    {
        
        iReturnSize=USBPRINT_Get1284Id(ParentDeviceObject,p1284Id,MAX_ID_SIZE-ID_OVERHEAD); //
        
        if(iReturnSize==-1)
        {
            pParentExtension->bBadDeviceID=TRUE;
            USBPRINT_KdPrint1 (("USBPRINT.SYS: Get1284Id Failed\n"));
            sprintf(pParentExtension->DeviceIdString,BOGUS_PNP_ID);
        } /*end if Get1284 failed*/
        else
        {
            USBPRINT_KdPrint3 (("USBPRINT.SYS: Get1284Id Succeeded\n"));
            USBPRINT_KdPrint2 (("USBPRINT.SYS: 1284 ID == %s\n",(p1284Id+2)));
            ntStatus=ParPnpGetId(p1284Id+2,BusQueryDeviceID,pParentExtension->DeviceIdString);
            USBPRINT_KdPrint3 (("USBPRINT.SYS: After call to ParPnpGetId"));
            if(!NT_SUCCESS(ntStatus))
            {
                USBPRINT_KdPrint1 (("USBPRINT.SYS: ParPnpGetId failed, error== 0x%0X\n",ntStatus));
                sprintf(pParentExtension->DeviceIdString,BOGUS_PNP_ID);
                pParentExtension->bBadDeviceID=TRUE;

            }
            else
            {
                USBPRINT_KdPrint3 (("USBPRINT.SYS: After ParPnpGetID\n"));
                USBPRINT_KdPrint2 (("USBPRINT.SYS: DeviceIdString=%s\n",pParentExtension->DeviceIdString));
            }
        } /*end if the request didn't fail*/
        ExFreePool(p1284Id);
    }
    USBPRINT_KdPrint2 (("USBPRINT.SYS: GetDeviceID exit\n"));
} /*end function USBPRINT_GetDeviceID*/


NTSTATUS ProduceQueriedID(PDEVICE_EXTENSION deviceExtension,PIO_STACK_LOCATION irpStack,PIRP Irp,PDEVICE_OBJECT DeviceObject)
{

    PDEVICE_EXTENSION pParentExtension;
    NTSTATUS ntStatus=STATUS_SUCCESS;
    WCHAR wTempString1[30];
    PWSTR pWalk;
    HANDLE hChildRegKey;
    UCHAR *pRawString,*pTempString;
    UNICODE_STRING UnicodeDeviceId;
    UNICODE_STRING uncPortValueName;
    ANSI_STRING AnsiIdString;
    PCHILD_DEVICE_EXTENSION pChildExtension;
    int iReturnSize;
    int iFirstLen,iSecondLen, iTotalLen;
    
    pChildExtension=(PCHILD_DEVICE_EXTENSION)deviceExtension;
     pParentExtension=pChildExtension->ParentDeviceObject->DeviceExtension;
    
    USBPRINT_KdPrint1(("USBPRINT.SYS:  head of ProduceQueriedID\n")); /*dd*/
    
    pRawString=ExAllocatePool(NonPagedPool,MAX_ID_SIZE);
    pTempString=ExAllocatePool(NonPagedPool,MAX_ID_SIZE);
    if((pTempString==NULL)||(pRawString==NULL))
    {
        USBPRINT_KdPrint1 (("USBPRINT.SYS: BusQueryDeviceIDs; No memory.  Failing\n"));
        ntStatus=STATUS_NO_MEMORY;
        iReturnSize=-1;
    }
    else
    {
        if(pParentExtension->DeviceIdString[0]!=0)
        {
            switch(irpStack->Parameters.QueryId.IdType)
            { 
            case BusQueryDeviceID:
                USBPRINT_KdPrint1 (("USBPRINT.SYS: Received BusQueryDeviceID message\n"));
                sprintf(pRawString,"USBPRINT\\%s",pParentExtension->DeviceIdString); //this sprintf safe.. DeviceIDString guaranteed to be 15 less than RawString
                FixupDeviceId((PUCHAR)pRawString);
                RtlInitAnsiString(&AnsiIdString,pRawString);
                if(!NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeDeviceId,&AnsiIdString,TRUE))) //Make a unicode string out of this
                {
                  USBPRINT_KdPrint1 (("USBPRINT.SYS: RtlAnsiStringToUnicodeString failed\n"));
                  ntStatus=STATUS_NO_MEMORY;
                  iReturnSize=-1;
                  Irp->IoStatus.Information=0;
                  break;
                }
                ntStatus=STATUS_SUCCESS;
                Irp->IoStatus.Information=(ULONG_PTR)UnicodeDeviceId.Buffer;
                USBPRINT_KdPrint1(("USBPRINT.SYS: returing DeviceID\n")); /*dd*/
                break;
                
            case BusQueryInstanceID:
                USBPRINT_KdPrint2 (("USBPRINT.SYS: Received BusQueryInstanceID message\n"));
                USBPRINT_KdPrint2 (("USBPRINT.SYS: returning instance %u\n",pChildExtension->ulInstanceNumber));
                sprintf(pRawString,"USB%03u",pChildExtension->ulInstanceNumber);
                USBPRINT_KdPrint2 (("USBPRINT.SYS: RawString=%s\n",pRawString));
                RtlInitAnsiString(&AnsiIdString,pRawString);
                if(!NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeDeviceId,&AnsiIdString,TRUE))) //Make a unicode string out of this
                {
                  ntStatus=STATUS_NO_MEMORY;
                  iReturnSize=-1;
                  Irp->IoStatus.Information=0;
                  break;
                }

                ntStatus=STATUS_SUCCESS;
                Irp->IoStatus.Information=(ULONG_PTR)UnicodeDeviceId.Buffer;
                break;
                
            case BusQueryHardwareIDs:
                USBPRINT_KdPrint2 (("USBPRINT.SYS: Received BusQueryHardwareIDs message\n")); 
#ifndef WIN9XBUILD
                USBPRINT_KdPrint2 (("USBPRINT.SYS: inside IF NT\n"));
                ntStatus=IoOpenDeviceRegistryKey(DeviceObject,PLUGPLAY_REGKEY_DEVICE,KEY_ALL_ACCESS,&hChildRegKey);
#else
                USBPRINT_KdPrint2 (("USBPRINT.SYS: inside not NT\n")); 
               
                ntStatus=IoOpenDeviceRegistryKey(pParentExtension->PhysicalDeviceObject,PLUGPLAY_REGKEY_DEVICE,KEY_ALL_ACCESS,&hChildRegKey);
#endif
                if(!NT_SUCCESS(ntStatus))
                {
                    USBPRINT_KdPrint1 (("USBPRINT.SYS: BusQueryHardwareIDs; IoOpenDeviceRegistryKey failed\n"));
                    break;
                }
                swprintf(wTempString1,L"USB%03u",pChildExtension->ulInstanceNumber);
                RtlInitUnicodeString(&uncPortValueName,L"PortName");
                ntStatus=ZwSetValueKey(hChildRegKey,&uncPortValueName,0,REG_SZ,wTempString1,(wcslen(wTempString1)+1)*sizeof(WCHAR));
                if(!NT_SUCCESS(ntStatus))
                {
                    USBPRINT_KdPrint1 (("USBPRINT.SYS: BusQueryHardwareIDs; ZwSetValueKey failed\n"));
                }
                else
                {
                    USBPRINT_KdPrint3 (("USBPRINT.SYS: BusQueryHardwareIDs; ZwSetValueKey worked, wcslen(wTempString1)==%u\n",wcslen(wTempString1)));
                    ntStatus=STATUS_SUCCESS;
                }
                ZwClose(hChildRegKey);
                
                if(pParentExtension->DeviceIdString[0]==0)
                {
                    ntStatus=STATUS_NOT_FOUND;
                    USBPRINT_KdPrint2 (("USBPRINT.SYS: BusQueryCompatibleIDs; DeviceIdString is null.  Can't continue\n"));
                    break;
                }
                ntStatus=ParPnpGetId(pParentExtension->DeviceIdString,irpStack->Parameters.QueryId.IdType,pRawString); 
                if(!NT_SUCCESS(ntStatus))
                {
                    USBPRINT_KdPrint1 (("USBPRINT.SYS: BusQueryDeviceIDs; ParPnpGetID failed\n"));
                    break;
                } 
                
                if((strlen(pRawString)+ID_OVERHEAD)*2>MAX_ID_SIZE)
                {
                  ntStatus=STATUS_NO_MEMORY;
                  USBPRINT_KdPrint1 (("USBPRINT.SYS: BusQueryDeviceIDs; ID's to long.  Failing\n"));
                  iReturnSize=-1;
                  break;
                }
                sprintf(pTempString,"USBPRINT\\%s",pRawString);
                iFirstLen=strlen(pTempString);
                *(pTempString+iFirstLen)=' ';  //make the old null be a space so that RtlInitAnsiString will step past it
                *(pTempString+iFirstLen+1)='\0'; //add an extra null at the end of the string
                strcat(pTempString,pRawString);
                iTotalLen=strlen(pTempString);
#ifdef USBPRINT_LIE_ABOUT_LPT
                *(pTempString+iTotalLen)=' ';
                *(pTempString+iTotalLen+1)='\0';
                iSecondLen=iTotalLen;
                strcat(pTempString,"LPTENUM\\");
                strcat(pTempString,pRawString);
                iTotalLen=strlen(pTempString);
#endif
                *(pTempString+iTotalLen)=' ';
                *(pTempString+iTotalLen+1)='\0';
                
                FixupDeviceId((PUCHAR)pTempString);

                
                RtlInitAnsiString(&AnsiIdString,pTempString);  //make a counted ansi string
                if(!NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeDeviceId,&AnsiIdString,TRUE))) //Make a unicode string out of this
                {
                  ntStatus=STATUS_NO_MEMORY;
                  iReturnSize=-1;
                  Irp->IoStatus.Information=0;
                  break;
                }
                pWalk = UnicodeDeviceId.Buffer+iFirstLen; //Set a pointer to the beginning of the string
                *pWalk=L'\0'; //set the space to be a unicode null

#ifdef USBPRINT_LIE_ABOUT_LPT
                pWalk = UnicodeDeviceId.Buffer+iSecondLen; //Set a pointer to the beginning of the string
                *pWalk=L'\0'; //set the space to be a unicode null
#endif

                pWalk = UnicodeDeviceId.Buffer+iTotalLen; //set a pointer to the space at the end of the total string
                *pWalk=L'\0';   //set the space to be a unicode null, so that we now have a double unicode null.
                Irp->IoStatus.Information = (ULONG_PTR)UnicodeDeviceId.Buffer;
                break;
                
            case BusQueryCompatibleIDs:
                USBPRINT_KdPrint2 (("USBPRINT.SYS: Received BusQueryCompatibleIDs message\n")); 
                Irp->IoStatus.Information = (ULONG_PTR) NULL; //(ULONG_PTR)UnicodeDeviceId.Buffer;
                break;

            default:
             {
                USBPRINT_KdPrint2 (("USBPRINT.SYS: Received unkown BusQuery message\n")); 
                ntStatus = Irp->IoStatus.Status;
             }
            } /*end switch ID type*/
            
        }  /*end no 1284 ID*/
        else
        {
            ntStatus=STATUS_NOT_FOUND;
        }
    }
    if(pTempString!=NULL)
        ExFreePool(pTempString);
    if(pRawString!=NULL)
        ExFreePool(pRawString);
    return ntStatus;
} /*End function QueryID*/


//
//  Function: bAddPortInUseItem
// 
//  Description : iPortNumber is removed from the free ports list structure.
//  
//  Parameters: IN\OUT pFreePorts - is the beginning of the list and on return will contain the beginning of the list.
//                                  pFreePorts may change during the call.
//              IN iPortNumber - the port number that is in use.
//
//  Returns: NTSTATUS value - STATUS_NO_MEMORY
//                          - STATUS_SUCCESS
//
NTSTATUS bAddPortInUseItem(PFREE_PORTS * pFreePorts,ULONG iPortNumber )
{
    NTSTATUS ntstatus     = STATUS_SUCCESS;
    PFREE_PORTS pBefore   = *pFreePorts;
    PFREE_PORTS pHead     = *pFreePorts;
    PFREE_PORTS pNewBlock = NULL;

    USBPRINT_KdPrint2 (("  USBPRINT.SYS:  Head of bAddPortInUseItem\n"));  
    
    //
    // Traverse the FREE_PORT structure to remove the port number from the list.
    // Note - This function will not be needed to be called by anyone else other than LoadPortsUsed
    // as the GetNewPortNumber will do this functionality automatically.
    //
    while( *pFreePorts )
    {
        if( iPortNumber >= (*pFreePorts)->iBottomOfRange && iPortNumber <= (*pFreePorts)->iTopOfRange )
        {
            // We're where we want to be - so decide what to do...
            if( iPortNumber == (*pFreePorts)->iBottomOfRange )
            {
                if( (++((*pFreePorts)->iBottomOfRange)) > (*pFreePorts)->iTopOfRange )
                {
                    // Case of the Port Number being the first and only element in the first block.
                    if( *pFreePorts == pHead )
                    {
                        pHead = (*pFreePorts)->pNextBlock;
                    }
                    else    // Case of the Port Number being the first element in another block.
                    {
                        pBefore->pNextBlock = (*pFreePorts)->pNextBlock;
                    }
                    ExFreePool( *pFreePorts );
                }
            }
            else 
            {
                if( iPortNumber == (*pFreePorts)->iTopOfRange )
                {   // Deletion case handled in the above case, so just need to decrement.
                    ((*pFreePorts)->iTopOfRange)--;
                }
                else    // Otherwise we're in the middle of the block and we need to split it.
                {
                    pNewBlock = ExAllocatePoolWithTag( NonPagedPool, sizeof(FREE_PORTS), USBP_TAG);
                    if( !pNewBlock )
                    {
                        ntstatus = STATUS_NO_MEMORY;
                        goto Cleanup;
                    }

                    pNewBlock->iTopOfRange    = (*pFreePorts)->iTopOfRange;
                    (*pFreePorts)->iTopOfRange   = iPortNumber - 1;
                    pNewBlock->iBottomOfRange = iPortNumber + 1;
                    pNewBlock->pNextBlock     = (*pFreePorts)->pNextBlock;
                    (*pFreePorts)->pNextBlock    = pNewBlock;
                }
            }
            break;
        }
        else
        {
            if( iPortNumber < (*pFreePorts)->iBottomOfRange )
            {   // The port number has already been used - not in the free list.
                USBPRINT_KdPrint2 (("  USBPRINT.SYS:  Port number %n is allocated already from free list.\n", iPortNumber));
                break;
            }
            pBefore = *pFreePorts;
            *pFreePorts = (*pFreePorts)->pNextBlock;
        }
    }

    if( NULL == *pFreePorts )
    {
        ntstatus = STATUS_INVALID_PARAMETER;
        // Assert this as we could never allocate a port number that is not in the initial ranges 1-999 
        //     - but if we assert here, we have run off the end of the port allocation numbers.
        ASSERT( *pFreePorts );
    }

Cleanup:
    *pFreePorts = pHead;

    return ntstatus;

} /*end function bAddPortInUseItem*/


void vClaimPortNumber(ULONG ulPortNumber,HANDLE hInterfaceKey,PFREE_PORTS * pPortsUsed)
{
    UNICODE_STRING wRecycle;
    WCHAR *pName;

    pName=L"RECYCLABLE";
    RtlInitUnicodeString(&wRecycle,pName);
    #if WIN95_BUILD==1
    SetValueToZero(hInterfaceKey,&wRecycle);
    #else
    ZwDeleteValueKey(hInterfaceKey,&wRecycle);
    #endif

    // Do we need to fail out gracefully from the below?  
    // The func doesn't have a return, but we could fail a mem alloc inside the below call!!
//    bAddPortInUseItem(pPortsUsed,ulPortNumber);
} /*end function vClaimPortNumber*/


NTSTATUS GetNewPortNumber(PFREE_PORTS * pFreePorts, ULONG *pulPortNumber)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    PFREE_PORTS pTemp  = *pFreePorts;

    USBPRINT_KdPrint2 (("USBPRINT.SYS: Head of GetNewPortNumber\n"));

    if( NULL == *pFreePorts )
    {
        // If the pFreePorts list is empty - try to reconstruct it.
        ntstatus=InitFreePorts(pFreePorts);
        if(NT_SUCCESS(ntstatus))
            ntstatus=LoadPortsUsed((GUID *)&USBPRINT_GUID,pFreePorts,USB_BASE_NAME);
        if( NULL == *pFreePorts && NT_SUCCESS(ntstatus))
        {
            ntstatus=STATUS_INVALID_PORT_HANDLE;    
        }

        if(!NT_SUCCESS(ntstatus)) 
        {
            *pulPortNumber = 0;
            goto Cleanup;
        }
    }

    *pulPortNumber = (*pFreePorts)->iBottomOfRange;

    if( (++((*pFreePorts)->iBottomOfRange)) > (*pFreePorts)->iTopOfRange )
    {
        // Case of the Port Number being the first and only element in the first block.
        *pFreePorts = (*pFreePorts)->pNextBlock;
        ExFreePool( pTemp );
    }

Cleanup:

    return ntstatus;

} /*end function GetNewPortNumber*/


BOOL bDeleteIfRecyclable(HANDLE hRegKey)
{
    BOOL bReturn=FALSE;
    UNICODE_STRING wcValueName;
    NTSTATUS ntStatus;
    USBPRINT_KdPrint2 (("USBPRINT.SYS:  Head of bDeleteifRecyclable\n"));
    RtlInitUnicodeString(&wcValueName,L"recyclable");
    #if WIN95_BUILD==1
    ntStatus=SetValueToZero(hRegKey,&wcValueName);
    #else
    ntStatus=ZwDeleteValueKey(hRegKey,&wcValueName);
    #endif
    if(NT_SUCCESS(ntStatus))
    {
        RtlInitUnicodeString(&wcValueName,L"Port Number");
        #if WIN95_BUILD==1
        ntStatus=SetValueToZero(hRegKey,&wcValueName);
        #else
        ntStatus=ZwDeleteValueKey(hRegKey,&wcValueName);
        #endif
        if(NT_SUCCESS(ntStatus)) 
            bReturn=TRUE;
    } // end function bDeleteIfRecyclable
    if(bReturn)
    {
        USBPRINT_KdPrint3 (("USBPRINT.SYS: bDeleteIfRecyclable, returning TRUE\n"));
    }
    else
    {
        USBPRINT_KdPrint3 (("USBPRINT.SYS: bDeleteIfRecyclable, returning FALSE\n"));
    }
    return bReturn;
} //End function bDeleteIfRecycable
   
//
// Initialises the free ports structure list.
// pHead must be NULL or a valid pointer to a FREE_PORTS structure.
//
NTSTATUS InitFreePorts( PFREE_PORTS * pHead )
{
    PFREE_PORTS pNext = *pHead;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    while(pNext)
    {
        pNext = (*pHead)->pNextBlock;
        ExFreePool(*pHead);
        *pHead = pNext;
    }

    //
    // Any old list will be cleared from memory and pHead will be NULL
    //

    *pHead = ExAllocatePoolWithTag(NonPagedPool, sizeof(FREE_PORTS), USBP_TAG);
    if( *pHead )
    {
        (*pHead)->iBottomOfRange = MIN_PORT_NUMBER;
        (*pHead)->iTopOfRange = MAX_PORT_NUMBER;
        (*pHead)->pNextBlock = NULL;
    }
    else
        ntstatus = STATUS_NO_MEMORY;

    return ntstatus;
}

void ClearFreePorts( PFREE_PORTS * pHead )
{
    PFREE_PORTS pTemp = *pHead;

    while( *pHead )
    {
        *pHead = (*pHead)->pNextBlock;
        ExFreePool( pTemp );
        pTemp = *pHead;
    }
}


/********************************************************
 * SetValueToZero.  Sets and interger reg key to zero.    
 * Returns failure if reg key does not exist, or if     
 * The key already is set to zero.  Mimics ZwDeleteValueKey
 * (which is not currently avaiable on Milinium) by 
 * useing the value 0 to mean deleted
 **************************************************************/
NTSTATUS SetValueToZero(HANDLE hRegKey,PUNICODE_STRING ValueName)
{
    PKEY_VALUE_PARTIAL_INFORMATION pValueStruct;
    NTSTATUS ReturnCode;
    ULONG dwZero=0;
    ULONG ulSizeUsed;
    NTSTATUS ntStatus;
    int iValue;

    ulSizeUsed=sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(ULONG); //this is a byte to much.  Oh well
    pValueStruct=ExAllocatePool(NonPagedPool,ulSizeUsed); 
    if(pValueStruct==NULL)
    {
      USBPRINT_KdPrint1(("USBPRINT.SYS: SetValueToZero; Unable to allocate memory\n"));
      return STATUS_NO_MEMORY;
     
    }
    ntStatus=ZwQueryValueKey(hRegKey,ValueName,KeyValuePartialInformation,pValueStruct,ulSizeUsed,&ulSizeUsed);
    if(!NT_SUCCESS(ntStatus))
    {
	  USBPRINT_KdPrint3(("Failed to Query value Key\n"));
      ExFreePool(pValueStruct);
      return STATUS_OBJECT_NAME_NOT_FOUND;
    }
    iValue=(int)*((ULONG *)(pValueStruct->Data));
    ExFreePool(pValueStruct);
    if(iValue==0)
        return STATUS_OBJECT_NAME_NOT_FOUND;

    //if we make it to here, the value exists, and is nonzero
    ReturnCode=ZwSetValueKey(hRegKey,ValueName,0,REG_DWORD,&dwZero,sizeof(dwZero));
    return ReturnCode;
} /*end function SetValueToZero*/

VOID
USBPRINT_FdoIdleNotificationCallback(IN PDEVICE_EXTENSION DevExt)
/*++

Routine Description:

    Called when it is time to idle out USB printer


--*/
{
    POWER_STATE 	powerState;
    NTSTATUS 		ntStatus;

    USBPRINT_KdPrint1(("USB Printer (%08X) going idle\n", DevExt));

    if(!DevExt->AcceptingRequests ||  DevExt->OpenCnt) 
    {

        // Don't idle this printer if the printer is not accepting requests

        USBPRINT_KdPrint1(("USB Printer (%08X) not accepting requests, abort idle\n", DevExt));
        return;
    }


    powerState.DeviceState = DevExt->DeviceWake;

	// request new device power state, wait wake Irp will be posted on request
    PoRequestPowerIrp(DevExt->PhysicalDeviceObject,
                      IRP_MN_SET_POWER,
                      powerState,
                      NULL,
                      NULL,
                      NULL);

} // USBPRINT_FdoIdleNotificationCallback


NTSTATUS
USBPRINT_FdoIdleNotificationRequestComplete(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PDEVICE_EXTENSION DevExt
    )
/*++

Routine Description:

    Completion routine for the Idle request IRP for the USB printer device

--*/
{
    NTSTATUS 					ntStatus;
    PUSB_IDLE_CALLBACK_INFO 	idleCallbackInfo;

    //
    // DeviceObject is NULL because we sent the irp
    //
    UNREFERENCED_PARAMETER(DeviceObject);

    USBPRINT_KdPrint1(("Idle notification IRP for USB Printer (%08X) completed (%08X)\n",
            DevExt, Irp->IoStatus.Status));

	// save completion status in device extension
    idleCallbackInfo 			= DevExt->IdleCallbackInfo;
    DevExt->IdleCallbackInfo 	= NULL;
    DevExt->PendingIdleIrp 		= NULL;

	// free up callback info
    if(idleCallbackInfo) 
    {
        ExFreePool(idleCallbackInfo);
    }

    ntStatus = Irp->IoStatus.Status;

    return ntStatus;
} // USBPRINT_FdoIdleNotificationRequestComplete


NTSTATUS
USBPRINT_FdoSubmitIdleRequestIrp(IN PDEVICE_EXTENSION DevExt)
/*++

Routine Description:

    Called when all handles to the USB printer are closed. This function allocates 
    an idle request IOCTL IRP and passes it to the parent's PDO.

--*/
{
    PIRP 					irp = NULL;
    NTSTATUS 				ntStatus = STATUS_SUCCESS;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo = NULL;

    USBPRINT_KdPrint1(("USBPRINT_FdoSubmitIdleRequestIrp (%08X)\n", DevExt));

    // if we have an Irp pending, don't bother to send another
    if(DevExt->PendingIdleIrp || DevExt->CurrentDevicePowerState == DevExt->DeviceWake)
        return ntStatus;

    idleCallbackInfo = ExAllocatePoolWithTag(NonPagedPool,
                                             sizeof(struct _USB_IDLE_CALLBACK_INFO), USBP_TAG);

    if (idleCallbackInfo) 
    {

        idleCallbackInfo->IdleCallback 	= USBPRINT_FdoIdleNotificationCallback;
        idleCallbackInfo->IdleContext 	= (PVOID)DevExt;

        DevExt->IdleCallbackInfo = idleCallbackInfo;

        irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION,
                DevExt->PhysicalDeviceObject,
                idleCallbackInfo,
                sizeof(struct _USB_IDLE_CALLBACK_INFO),
                NULL,
                0,
                TRUE, /* INTERNAL */
                NULL,
                NULL);

        if (irp == NULL) 
        {
        
            ExFreePool(idleCallbackInfo);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        IoSetCompletionRoutine(irp,
                               USBPRINT_FdoIdleNotificationRequestComplete,
                               DevExt,
                               TRUE,
                               TRUE,
                               TRUE);

        ntStatus = IoCallDriver(DevExt->PhysicalDeviceObject, irp);

        if(ntStatus == STATUS_PENDING) 
        {
            // Successfully posted an Idle IRP.

            DevExt->PendingIdleIrp 	= irp;
        }
    }

    return ntStatus;
} // USBPRINT_FdoSubmitIdleRequestIrp

VOID
USBPRINT_FdoRequestWake(IN PDEVICE_EXTENSION DevExt)
/*++

Routine Description:

	Called when we want to wake up the device after an idle request

--*/
{
    POWER_STATE 	powerState;
    KIRQL OldIrql;
    BOOL bExit=FALSE;

    USBPRINT_KdPrint1(("USBPRINT: USB Printer (%08X) waking up\n", DevExt));

    KeAcquireSpinLock(&(DevExt->WakeSpinLock),&OldIrql);
    if(!DevExt->AcceptingRequests || DevExt->CurrentDevicePowerState == PowerDeviceD0 || DevExt->bD0IrpPending) 
    {

        // Don't wake this printer if it's not accepting requests or we're already at power state D0
        if(!DevExt->AcceptingRequests)
          USBPRINT_KdPrint1(("USBPRINT: USB Printer (%08X) not accepting requests, abort wake\n", DevExt));
        if(DevExt->CurrentDevicePowerState == PowerDeviceD0)
          USBPRINT_KdPrint1(("USBPRINT: USB Printer (%08X) already at D0, abort wake\n", DevExt));
        if(DevExt->bD0IrpPending == TRUE)
          USBPRINT_KdPrint1(("USBPRINT: USB Printer (%08X) already has D0 irp pending, abort wake\n", DevExt));
        bExit=TRUE;
    }
    else
      DevExt->bD0IrpPending=TRUE;  
    KeReleaseSpinLock(&(DevExt->WakeSpinLock),OldIrql);
    if(bExit)
        return;



    
    powerState.DeviceState = PowerDeviceD0;

	// request new device power state, wake up the device

 
    PoRequestPowerIrp(DevExt->PhysicalDeviceObject,
                      IRP_MN_SET_POWER,
                      powerState,
                      NULL,
                      NULL,
                      NULL);

} // USBPRINT_FdoRequestWake


void vOpenLogFile(HANDLE *pHandle)
{
    NTSTATUS ntStatus;
    OBJECT_ATTRIBUTES FileAttributes;
    IO_STATUS_BLOCK StatusBlock;
    UNICODE_STRING PathName;

    RtlInitUnicodeString(&PathName,L"\\??\\C:\\USBPRINT.LOG");

    InitializeObjectAttributes(&FileAttributes,&PathName,0,NULL,NULL);
    ntStatus=ZwCreateFile(pHandle,
                          GENERIC_WRITE,
                          &FileAttributes,
                          &StatusBlock,
                          0,
                          0,
                          FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                          FILE_OPEN_IF,
                          FILE_NON_DIRECTORY_FILE|FILE_WRITE_THROUGH|FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);
    if(!NT_SUCCESS(ntStatus))
    {
        USBPRINT_KdPrint1(("USBPRINT: Unable to open C:\\USBPRINT.LOG"));
    }
    else
    {
        USBPRINT_KdPrint1(("USBPRINT: Opened logfile C:\\USBPRINT.LOG")); /*dd*/
    }
}


void vWriteToLogFile(HANDLE *pHandle,IN CHAR *pszString)
{
    HANDLE hFileHandle;
    ULONG BufferSize;
    NTSTATUS ntStatus;
    IO_STATUS_BLOCK StatusBlock;
    LARGE_INTEGER WriteOffset;

    WriteOffset.LowPart=FILE_WRITE_TO_END_OF_FILE;
    WriteOffset.HighPart=-1;
    
    BufferSize=strlen(pszString);
    ntStatus=ZwWriteFile(*pHandle,
                         NULL,
                         NULL,
                         NULL,
                         &StatusBlock,
                         pszString,
                         BufferSize,
                         &WriteOffset,
                         NULL);

    if(!NT_SUCCESS(ntStatus))
    {
        USBPRINT_KdPrint1(("USBPRINT: Unable to write to log file C:\\USBPRINT.LOG"));
    }
    else
    {
        USBPRINT_KdPrint1(("USBPRINT: write to log file C:\\USBPRINT.LOG")); /*dd*/
    }
} /*end function vWriteToLog*/


void vCloseLogFile(IN HANDLE *pHandle)
{
  ZwClose(*pHandle);
} /*end function vCloseLogFile*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\print.inc ===
!if 0

Copyright (c) 1996  Microsoft Corporation

Common stuff for all printer drivers

!endif

BUFFER_OVERFLOW_CHECKS=1

OEMDRV_ROOT=$(BASEDIR)\printscan\oem\src\print\drivers\usermode\oemdrv

C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE

INCLUDES=$(PRNROOT)\inc


!ifndef SDXROOT
# This block is used to build in Windows 2000 building environment
# where SDXROOT is not defined
WINDOWS_LIB_PATH=$(SDK_LIB_PATH)
!endif

!if defined(WINNT_40)       # NT4 kernel-mode driver

C_DEFINES=$(C_DEFINES) -DMEMDEBUG -DWINNT_40

!elseif defined(KM_DRIVER)  # NT5 kernel-mode driver

C_DEFINES=$(C_DEFINES) -DMEMDEBUG

!else                       # NT5 user-mode driver

C_DEFINES=$(C_DEFINES) -DUSERMODE_DRIVER

!endif

MSC_WARNING_LEVEL=/W3 /WX

!ifndef FREEBUILD
# Tweak to work with NT4 makefile.def
!ifdef NTDEBUG
FREEBUILD=0
!else
FREEBUILD=1
!endif
!endif
!ifndef AXP64
AXP64=0
!endif


!ifdef DDKBUILD
BUILD_FROM_DDK=1
C_DEFINES=$(C_DEFINES) -DBUILD_FROM_DDK
!endif

!if defined(ADOBE)
C_DEFINES=$(C_DEFINES) -DADOBE
!endif

!if $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\devmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Devmode.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for devmode functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _DEVMODE_H
#define _DEVMODE_H


////////////////////////////////////////////////////////
//      OEM Devmode Defines
////////////////////////////////////////////////////////




////////////////////////////////////////////////////////
//      OEM Devmode Type Definitions
////////////////////////////////////////////////////////

//
//Can add info to the private devmode bellow here.
//Note :
//		This structure must be prefixed by OEM_DMEXTRAHEADER
//		Your plug-in must implement the IPrintOemUI::DevMode method
//
typedef struct tagOEMDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    DWORD               dwDriverData;
    DWORD               dwAdvancedData;

	//
	//Private DevMode Members
	//

} OEMDEV, *POEMDEV;

typedef const OEMDEV *PCOEMDEV;



/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam);
BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut);
BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode);
void Dump(PCOEMDEV pOEMDevIn);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'
#define MAX_LOOP                10



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize      = DEBUG_BUFFER_SIZE;
    DWORD   dwLoop      = 0;
    LPSTR   lpszMsgBuf  = NULL;
    HRESULT hr;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
        {
            return FALSE;
        }

        hr = StringCbVPrintfA(lpszMsgBuf, (dwSize + 1) * sizeof(CHAR), lpszMessage, arglist);

    // Pass the variable parameters to wvsprintf to be formated.
    } while (FAILED(hr) && (STRSAFE_E_INSUFFICIENT_BUFFER == hr) && (++dwLoop < MAX_LOOP) );

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return SUCCEEDED(hr);
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR      lpszMsgBuf;
    HRESULT     hResult;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    hResult = StringCbVPrintfW(lpszMsgBuf, (dwSize + 1) * sizeof(WCHAR), lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return SUCCEEDED(hResult);
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(TEXT("pPublisherInfo:\r\n"));
    if(NULL == pPublisherInfo)
    {
        VERBOSE(TEXT("\tpPublisherInfo is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(TEXT("pOemDMParam:\r\n"));
    if(NULL == pOemDMParam)
    {
        VERBOSE(TEXT("\tpOemDMParam is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}

void Dump(PPROPSHEETUI_INFO pPSUIInfo)
{
    VERBOSE(TEXT("pPSUIInfo:\r\n"));
    if(NULL == pPSUIInfo)
    {
        VERBOSE(TEXT("\tpPSUIInfo is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize          = %d\r\n"), pPSUIInfo->cbSize);
    VERBOSE(TEXT("\tVersion         = %#x\r\n"), pPSUIInfo->Version);
    VERBOSE(TEXT("\tFlags           = %#x\r\n"), pPSUIInfo->Flags);
    VERBOSE(TEXT("\tReason          = %d\r\n"), pPSUIInfo->Reason);
    VERBOSE(TEXT("\thComPropSheet   = %#x\r\n"), pPSUIInfo->hComPropSheet);
    VERBOSE(TEXT("\tpfnComPropSheet = %#x\r\n"), pPSUIInfo->pfnComPropSheet);
    VERBOSE(TEXT("\tlParamInit      = %#x\r\n"), pPSUIInfo->lParamInit);
    VERBOSE(TEXT("\tUserData        = %#x\r\n"), pPSUIInfo->UserData);
    VERBOSE(TEXT("\tResult          = %#x\r\n"), pPSUIInfo->Result);
}

void Dump(POPTITEM pOptItem)
{
    VERBOSE(TEXT("pOptItem:\r\n"));
    if(NULL == pOptItem)
    {
        VERBOSE(TEXT("\tpOptItem is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize          = %d\r\n"),     pOptItem->cbSize);
    VERBOSE(TEXT("\tLevel           = %d\r\n"),     pOptItem->Level);
    VERBOSE(TEXT("\tDlgPageIdx      = %d\r\n"),     pOptItem->DlgPageIdx);
    VERBOSE(TEXT("\tFlags           = 0x%x\r\n"),   pOptItem->Flags);
    VERBOSE(TEXT("\tUserData        = 0x%p\r\n"),   pOptItem->UserData);
    VERBOSE(TEXT("\tpName           = %s\r\n"),     pOptItem->pName ? pOptItem->pName : TEXT("<NULL>"));
    VERBOSE(TEXT("\tpSel            = 0x%p\r\n"),   pOptItem->pSel);
    VERBOSE(TEXT("\tpExtChkBox      = 0x%p\r\n"),   pOptItem->pExtChkBox);
    VERBOSE(TEXT("\tpExtChkBox      = 0x%p\r\n"),   pOptItem->pExtChkBox);
    VERBOSE(TEXT("\tHelpIndex       = 0x%x\r\n"),   pOptItem->HelpIndex);
    VERBOSE(TEXT("\tDMPubID         = 0x%x\r\n"),   pOptItem->DMPubID);
    VERBOSE(TEXT("\tUserItemID      = 0x%x\r\n"),   pOptItem->UserItemID);
    VERBOSE(TEXT("\twReserved       = 0x%x\r\n"),   pOptItem->wReserved);
    VERBOSE(TEXT("\tpOIExt          = 0x%p\r\n"),   pOptItem->pOIExt);

    Dump(pOptItem->pOptType);
}

void Dump(POPTTYPE pOptType)
{
    VERBOSE(TEXT("\tpOptType:\r\n"));
    if(NULL == pOptType)
    {
        VERBOSE(TEXT("\t\tpOptType is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\t\tcbSize    = %d\r\n"),     pOptType->cbSize);
    VERBOSE(TEXT("\t\tType      = 0x%x\r\n"),   pOptType->Type);
    VERBOSE(TEXT("\t\tFlags     = 0x%x\r\n"),   pOptType->Flags);
    VERBOSE(TEXT("\t\tCount     = %d\r\n"),     pOptType->Count);
    VERBOSE(TEXT("\t\tCount     = 0x%x\r\n"),   pOptType->BegCtrlID);
    VERBOSE(TEXT("\t\tStyle     = 0x%x\r\n"),   pOptType->Style);

    Dump(pOptType->pOptParam, pOptType->Count);
}

void Dump(POPTPARAM pOptParam, WORD wCount)
{
    if(NULL == pOptParam)
    {
        VERBOSE(TEXT("\t\tpOptParam is NULL!\r\n"));
        return;
    }

    for(WORD wIndex = 0; wIndex < wCount; ++wIndex)
    {
        VERBOSE(TEXT("\t\tpOptParam[wIndex]:\r\n"));
        VERBOSE(TEXT("\t\t\tcbSize    = %d\r\n"),     pOptParam[wIndex].cbSize);
        VERBOSE(TEXT("\t\t\tFlags     = 0x%x\r\n"),   pOptParam[wIndex].Flags);
        VERBOSE(TEXT("\t\t\tStyle     = 0x%x\r\n"),   pOptParam[wIndex].Style);
        VERBOSE(TEXT("\t\t\tpData     = 0x%p\r\n"),   pOptParam[wIndex].pData);
        VERBOSE(TEXT("\t\t\tIconID    = 0x%p\r\n"),   pOptParam[wIndex].IconID);
        VERBOSE(TEXT("\t\t\tlParam    = 0x%p\r\n"),   pOptParam[wIndex].lParam);
    }
}


PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\devmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Devmode.cpp
//    
//
//  PURPOSE:  Implementation of Devmode functions shared with OEM UI and OEM rendering modules.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oemui.h"
#include "debug.h"
#include "devmode.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>


//
//Performs operation on UI Plugins Private DevMode Members.
//Called via IOemUI::DevMode
//

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam)
{
    POEMDEV pOEMDevIn;
    POEMDEV pOEMDevOut;


    // Verify parameters.
    if( (NULL == pOemDMParam)
        ||
        ( (OEMDM_SIZE != dwMode)
          &&
          (OEMDM_DEFAULT != dwMode)
          &&
          (OEMDM_CONVERT != dwMode)
          &&
          (OEMDM_MERGE != dwMode)
        )
      )
    {
        ERR(ERRORTEXT("DevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOemDMParam = %#lx.\r\n"), dwMode, pOemDMParam);

        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Cast generic (i.e. PVOID) to OEM private devomode pointer type.
    pOEMDevIn = (POEMDEV) pOemDMParam->pOEMDMIn;
    pOEMDevOut = (POEMDEV) pOemDMParam->pOEMDMOut;

    switch(dwMode)
    {
		//
		//The Method should return the size of the memory allocation needed to store the UI plugin Private DEVMODE.
		//
        case OEMDM_SIZE:
            pOemDMParam->cbBufSize = sizeof(OEMDEV);
            break;

		//
		//Should fill the Private DEVMODE with the default values.
		//
        case OEMDM_DEFAULT:
			//
			//OEM_DMEXTRAHEADER Members
			//
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;

			//
			//Private members
			//
            pOEMDevOut->dwDriverData            = 0;
            pOEMDevOut->dwAdvancedData          = 0;

            VERBOSE(DLLTEXT("pOEMDevOut after setting default values:\r\n"));
            Dump(pOEMDevOut);			
            break;
			
		//
		//The method should convert private DEVMODE members to the current version, if necessary.
		//
        case OEMDM_CONVERT:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            break;
		
		//
		//The method should validate the information contained in private DEVMODE members and merge validated values into a private DEVMODE structure containing default values
		//
        case OEMDM_MERGE:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            MakeOEMDevmodeValid(pOEMDevOut);
            break;
    }
    Dump(pOemDMParam);

    return S_OK;
}


BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut)
{
    if( (NULL == pOEMDevIn)
        ||
        (NULL == pOEMDevOut)
      )
    {
        ERR(ERRORTEXT("ConvertOEMDevmode() invalid parameters.\r\n"));
        return FALSE;
    }

    // Check OEM Signature, if it doesn't match ours,
    // then just assume DMIn is bad and use defaults.
    if(pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature)
    {
        VERBOSE(DLLTEXT("Converting private OEM Devmode.\r\n"));
        VERBOSE(DLLTEXT("pOEMDevIn:\r\n"));
        Dump(pOEMDevIn);

        // Set the devmode defaults so that anything the isn't copied over will
        // be set to the default value.
        pOEMDevOut->dwDriverData    = 0;
        pOEMDevOut->dwAdvancedData  = 0;

        // Copy the old structure in to the new using which ever size is the smaller.
        // Devmode maybe from newer Devmode (not likely since there is only one), or
        // Devmode maybe a newer Devmode, in which case it maybe larger,
        // but the first part of the structure should be the same.

        // DESIGN ASSUMPTION: the private DEVMODE structure only gets added to;
        // the fields that are in the DEVMODE never change only new fields get added to the end.

        memcpy(pOEMDevOut, pOEMDevIn, __min(pOEMDevOut->dmOEMExtra.dwSize, pOEMDevIn->dmOEMExtra.dwSize));

        // Re-fill in the size and version fields to indicated 
        // that the DEVMODE is the current private DEVMODE version.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
    }
    else
    {
        WARNING(DLLTEXT("Unknown DEVMODE signature, pOEMDMIn ignored.\r\n"));

        // Don't know what the input DEVMODE is, so just use defaults.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
        pOEMDevOut->dwDriverData            = 0;
        pOEMDevOut->dwAdvancedData          = 0;
    }

    return TRUE;
}


BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode)
{
    if(NULL == pOEMDevmode)
    {
        return FALSE;
    }

    // ASSUMPTION: pOEMDevmode is large enough to contain OEMDEV structure.

    // Make sure that dmOEMExtra indicates the current OEMDEV structure.
    pOEMDevmode->dmOEMExtra.dwSize       = sizeof(OEMDEV);
    pOEMDevmode->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
    pOEMDevmode->dmOEMExtra.dwVersion    = OEM_VERSION;

    // Set driver data, if not valid.
    if(pOEMDevmode->dwDriverData > 100)
    {
        pOEMDevmode->dwDriverData = 0;
    }

    // Set Advanced driver data, if not valid.
    if(pOEMDevmode->dwAdvancedData > 100)
    {
        pOEMDevmode->dwAdvancedData = 0;
    }

    return TRUE;
}


void Dump(PCOEMDEV pOEMDevmode)
{
    if( (NULL != pOEMDevmode)
        &&
        (pOEMDevmode->dmOEMExtra.dwSize >= sizeof(OEMDEV))
        &&
        (OEM_SIGNATURE == pOEMDevmode->dmOEMExtra.dwSignature)
      )
    {
        VERBOSE(TEXT("\tdmOEMExtra.dwSize      = %d\r\n"), pOEMDevmode->dmOEMExtra.dwSize);
        VERBOSE(TEXT("\tdmOEMExtra.dwSignature = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwSignature);
        VERBOSE(TEXT("\tdmOEMExtra.dwVersion   = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwVersion);
        VERBOSE(TEXT("\tdwDriverData           = %#x\r\n"), pOEMDevmode->dwDriverData);
        VERBOSE(TEXT("\tdwAdvancedData         = %#x\r\n"), pOEMDevmode->dwAdvancedData);
    }
    else
    {
        ERR(ERRORTEXT("Dump(POEMDEV) unknown private OEM DEVMODE.\r\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _DEBUG_H
#define _DEBUG_H


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);
void Dump(PPROPSHEETUI_INFO pPSUIInfo);
void Dump(POPTITEM pOptItem);
void Dump(POPTTYPE pOptType);
void Dump(POPTPARAM pOptParam, WORD wCount);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\globals.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Globals.cpp
//    
//
//  PURPOSE:  File that contains all the globals.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//
#define _GLOBALS_H

#include "precomp.h"
#include "oemui.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>


///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
HINSTANCE   ghInstance = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oemui.h"
#include "debug.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>


// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));
            ghInstance = hInst;
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}


}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\globals.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Globals.h
//    
//
//  PURPOSE:   Lists of globals declared in Globals.cpp.
//
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _GLOBALS_H
#define _GLOBALS_H


///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
extern HINSTANCE   ghInstance;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\intrface.cpp ===
/*++

Copyright (c) 1996-2003  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows 2000, Windows XP, Windows Server 2003

Revision History:

              Created it.

--*/

#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "oemui.h"
#include "debug.h"
#include "intrface.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks



////////////////////////////////////////////////////////////////////////////////
//
// IOemUI body
//
IOemUI::~IOemUI()
{
    // Make sure that helper interface is released.
    if(NULL != m_pOEMHelp)
    {
        m_pOEMHelp->Release();
        m_pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == m_cRef);
}

HRESULT __stdcall IOemUI::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE(DLLTEXT("IOemUI:QueryInterface entry.\r\n\r\n")); 
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE(DLLTEXT("IOemUI:Return pointer to IUnknown.\r\n\r\n")); 
    }
    else if (iid == IID_IPrintOemUI)
    {
        *ppv = static_cast<IPrintOemUI*>(this) ;
        VERBOSE(DLLTEXT("IOemUI:Return pointer to IPrintOemUI.\r\n")); 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE(DLLTEXT("IOemUI:No Interface. Return NULL.\r\n")); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemUI::AddRef()
{
    VERBOSE(DLLTEXT("IOemUI:AddRef entry.\r\n")); 
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemUI::Release() 
{
    VERBOSE(DLLTEXT("IOemUI:Release entry.\r\n"));
    ASSERT( 0 != m_cRef);
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        
    }
    return cRef;
}

//
//(Implamentation is required) Supplies a pointer to UNIDRIVE /PScript IPrintOemDriverUI
//
HRESULT __stdcall IOemUI::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IOemUI:PublishDriverInterface entry.\r\n")); 

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (m_pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUI, (void** ) &(m_pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            m_pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}

//
//(Implamentation is required) Returns the UI Plugin's identification information
//
HRESULT __stdcall IOemUI::GetInfo(
    DWORD  dwMode,
    PVOID  pBuffer,
    DWORD  cbSize,
    PDWORD pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemUI::GetInfo(%d) entry.\r\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        WARNING(DLLTEXT("IOemUI::GetInfo() exit pcbNeeded is NULL! ERROR_INVALID_PARAMETER\r\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size and number of bytes written.
    *pcbNeeded = sizeof(DWORD);

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        WARNING(DLLTEXT("IOemUI::GetInfo() exit insufficient buffer!\r\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = OEM_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = OEM_VERSION;
            break;

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            WARNING(DLLTEXT("IOemUI::GetInfo() exit mode not supported.\r\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IOemUI::GetInfo() exit S_OK, (*pBuffer is %#x).\r\r\n"), *(PDWORD)pBuffer);
    return S_OK;
}


//
//Performs operation on UI Plugins Private DevMode Members.
//
HRESULT __stdcall IOemUI::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IOemUI:DevMode(%d, %#x) entry.\r\n"), dwMode, pOemDMParam); 

    return hrOEMDevMode(dwMode, pOemDMParam);
}


//
//Allows UI Plugin to Modifiy Existing printer porp sheet and document property sheet page..
//
HRESULT __stdcall IOemUI::CommonUIProp(
    DWORD  dwMode,
    POEMCUIPPARAM   pOemCUIPParam)
{
    VERBOSE(DLLTEXT("IOemUI:CommonUIProp entry.\r\n")); 

    return hrOEMPropertyPage(dwMode, pOemCUIPParam);
}


//
//Adds a New page to the device Documment property sheet.
//

HRESULT __stdcall IOemUI::DocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DocumentPropertySheets entry.\r\n")); 

    return hrOEMDocumentPropertySheets(pPSUIInfo, lParam, m_pOEMHelp);
}

//
//Adds a New page to the device printer property page.
//
HRESULT __stdcall IOemUI::DevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DevicePropertySheets entry.\r\n")); 

    return hrOEMDevicePropertySheets(pPSUIInfo, lParam);
}


//
//Allows the UI plugin to spec Customized device capabilaties (TODO)
//
HRESULT __stdcall IOemUI::DeviceCapabilities(
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult)
{
    VERBOSE(DLLTEXT("IOemUI:DeviceCapabilities entry.\r\n"));
	
    return E_NOTIMPL;
}


//
//Allows the UI plugin to help determine if a print Job is printable.
//
HRESULT __stdcall IOemUI::DevQueryPrintEx(
    POEMUIOBJ               poemuiobj,
    PDEVQUERYPRINT_INFO     pDQPInfo,
    PDEVMODE                pPublicDM,
    PVOID                   pOEMDM)
{
    VERBOSE(DLLTEXT("IOemUI:DevQueryPrintEx entry.\r\n"));

    return E_NOTIMPL;
}


//
//Allows the UI Plugin to upgrade its dev options stored in the registry.
//
HRESULT __stdcall IOemUI::UpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo)
{
    VERBOSE(DLLTEXT("IOemUI:UpgradePrinter entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::PrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI:PrinterEvent entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::DriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DriverEvent entry.\r\n"));

    return E_NOTIMPL;
};


#define PROFILE_NAME    L"OEMPROFILE.icm\0"

HRESULT __stdcall IOemUI::QueryColorProfile(
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulQueryMode,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData)
{
    HRESULT Result = E_FAIL;


    VERBOSE(DLLTEXT("IOemUI:QueryColorProfile entry.\r\n"));


    if(QCP_DEVICEPROFILE == ulQueryMode)
    {
        if(NULL == pvProfileData)
        {
            *pcbProfileData = sizeof(PROFILE_NAME);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
            if(*pcbProfileData < sizeof(PROFILE_NAME))
            {
                *pcbProfileData = sizeof(PROFILE_NAME);
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
            }
            else
            {
                Result = StringCbCopy((LPWSTR)pvProfileData, *pcbProfileData, PROFILE_NAME);
                *pcbProfileData = sizeof(PROFILE_NAME);
                *pflProfileData = QCP_PROFILEDISK;

                if(FAILED(Result))
                {
                    SetLastError(Result);
                }
            }
        }
    }

    return Result;
};

HRESULT __stdcall IOemUI::FontInstallerDlgProc(
        HWND    hWnd,
        UINT    usMsg,
        WPARAM  wParam,
        LPARAM  lParam) 
{
    VERBOSE(DLLTEXT("IOemUI:FontInstallerDlgProc entry.\r\n"));

    return E_NOTIMPL;
};

HRESULT __stdcall IOemUI::UpdateExternalFonts(
        HANDLE  hPrinter,
        HANDLE  hHeap,
        PWSTR   pwstrCartridges)
{
    VERBOSE(DLLTEXT("IOemUI:UpdateExternalFonts entry.\r\n"));

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemUI* pOemCB = new IOemUI ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }
    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Exported functions
//


// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    //
    // To avoid leaving OEM DLL still in memory when Unidrv or Pscript drivers 
    // are unloaded, Unidrv and Pscript driver ignore the return value of 
    // DllCanUnloadNow of the OEM DLL, and always call FreeLibrary on the OEMDLL.
    //
    // If OEM DLL spins off a working thread that also uses the OEM DLL, the 
    // thread needs to call LoadLibrary and FreeLibraryAndExitThread, otherwise 
    // it may crash after Unidrv or Pscript calls FreeLibrary.
    //

    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:Create class factory.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMUI)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif


// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
#include <WINDDI.H>
#include <WINSPOOL.H>
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRSHT.H>
#include <COMPSTUI.H>
#include <WINDDIUI.H>
#include <PRINTOEM.H>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//   Windows 2000, Windows XP, and Windows Server 2003
//  
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\oemui.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	OEMUI.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for OEMUI Test Module.
//
//  PLATFORMS:
//     Windows 2000, Windows XP, and Windows Server 2003
//
//
#ifndef _OEMUI_H
#define _OEMUI_H

#include <PRCOMOEM.H>

#include "OEM.H"
#include "DEVMODE.H"
#include "globals.h"

////////////////////////////////////////////////////////
//		Custom Help Defines
////////////////////////////////////////////////////////
#define CUSDRV_HELPTOPIC_1 15001
#define CUSDRV_HELPTOPIC_2 15002


////////////////////////////////////////////////////////
//      OEM UI Defines
////////////////////////////////////////////////////////


// OEM Signature and version.
#define PROP_TITLE      L"OEM UI Page"
#define DLLTEXT(s)      __TEXT("UI:  ") __TEXT(s)

// OEM UI Misc defines.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


// Printer registry keys where OEM data is stored.
#define OEMUI_VALUE             TEXT("OEMUI_VALUE")
#define OEMUI_DEVICE_VALUE      TEXT("OEMUI_DEVICE_VALUE")


////////////////////////////////////////////////////////
//      Prototypes
////////////////////////////////////////////////////////

HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, IPrintOemDriverUI*  pOEMHelp);
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\intrface.h ===
/*++

Copyright (c) 1996-2003  Microsoft Corporation

Module Name:

     comoem.h

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows 2000, Windows XP, Windows Server 2003

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// IOemUI
//
class IOemUI: public IPrintOemUI
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD  dwMode, PVOID  pBuffer, DWORD  cbSize,
                           PDWORD pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_  DWORD  dwMode, POEMDMPARAM pOemDMParam) ;

    //
    // OEMCommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_  
            DWORD  dwMode, 
            POEMCUIPPARAM   pOemCUIPParam
            );

    //
    // OEMDocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );

    //
    // OEMDevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );


    //
    // OEMDevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            );

    //
    // OEMDeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            );

    //
    // OEMUpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            );

    //
    // OEMPrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            );

    //
    // OEMDriverEvent
    //

    STDMETHOD(DriverEvent)(THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            );
 
    //
    // OEMQueryColorProfile
    //

    STDMETHOD( QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData);

    //
    // OEMFontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_ 
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            );
    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
            );


    IOemUI() { m_cRef = 1; m_pOEMHelp = NULL; };
    ~IOemUI();

protected:
    LONG                m_cRef;
    IPrintOemDriverUI*  m_pOEMHelp;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\oemui.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    OEMUI.cpp
//    
//
//  PURPOSE:  Main file for OEM UI test module.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "resource.h"
#include "debug.h"
#include "oemui.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>


////////////////////////////////////////////////////////
//      INTERNAL MACROS and DEFINES
////////////////////////////////////////////////////////

typedef struct _tagCBUserData 
{
    HANDLE          hComPropSheet;
    HANDLE          hPropPage;
    POEMUIPSPARAM   pOEMUIParam;
    PFNCOMPROPSHEET pfnComPropSheet;

} CBUSERDATA, *PCBUSERDATA;


////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUICallBack2(PCPSUICBPARAM pCallbackParam);
INT_PTR CALLBACK DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
static BOOL AddCustomUIHelp (HANDLE hPrinter, HANDLE hHeap, HANDLE hModule, POPTITEM pOptItem, DWORD HelpIndex, DWORD HelpFile);
static POIEXT CreateOIExt(HANDLE hHeap);
static POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems);
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems);
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams);
static PTSTR GetHelpFile (HANDLE hPrinter, HANDLE hHeap, HANDLE hModule, UINT uResource);
static PTSTR GetStringResource(HANDLE hHeap, HANDLE hModule, UINT uResource);
LPBYTE WrapGetPrinterDriver (HANDLE hHeap, HANDLE hPrinter, DWORD dwLevel);



////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM device or document property UI.
// Called via IOemUI::CommonUIProp
//
HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    HRESULT hResult = S_OK;


    VERBOSE(DLLTEXT("hrOEMPropertyPage(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (OEMCUIP_DOCPROP != dwMode)
        &&
        (OEMCUIP_PRNPROP != dwMode)        
      )
    {
        ERR(ERRORTEXT("hrOEMPropertyPage() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOEMUIParam = %#lx.\r\n"), dwMode, pOEMUIParam);

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        case OEMCUIP_DOCPROP:
            hResult = hrDocumentPropertyPage(dwMode, pOEMUIParam);
            break;

        case OEMCUIP_PRNPROP:
            hResult = hrPrinterPropertyPage(dwMode, pOEMUIParam);
            break;

        default:
            // Should never reach this!
            ERR(ERRORTEXT("hrOEMPropertyPage() Invalid dwMode, %d"), dwMode);
            SetLastError(ERROR_INVALID_PARAMETER);
            hResult = E_FAIL;
            break;
    }

    return hResult;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM document property UI.
//
static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM document property UI.
        pOEMUIParam->cOEMOptItems = 1;

        VERBOSE(DLLTEXT("hrDocumentPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
        POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


        VERBOSE(DLLTEXT("hrDocumentPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMDocUICallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // New section.
        pOEMUIParam->pOEMOptItems[0].Level  = 1;
        pOEMUIParam->pOEMOptItems[0].Flags  = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].pName  = GetStringResource(pOEMUIParam->hOEMHeap, pOEMUIParam->hModule, IDS_ADV_SECTION);
        pOEMUIParam->pOEMOptItems[0].Sel    = pOEMDev->dwAdvancedData;

        pOEMUIParam->pOEMOptItems[0].pOptType= CreateOptType(pOEMUIParam->hOEMHeap, 2);
		
		//
		//Setup the Optional Item
		//
        pOEMUIParam->pOEMOptItems[0].pOptType->Type = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam = 100;

		
		//
		//Allows You to apply Customised help to this Control.
		//
		//Notes:
		//	You must use a fully qualified path for pHelpFile
		//	OPTITEM Flags member must have OPTIF_HAS_POIEXT flag set. This indicates that the data in OIEXT is valid.
		//	OPTITEM is allocated on the Heap see (AddCustomUIHelp, GetHelpFile, CreateOIExt)
		//
		AddCustomUIHelp (pOEMUIParam->hPrinter,
						 pOEMUIParam->hOEMHeap,
						 pOEMUIParam->hModule,
						 &(pOEMUIParam->pOEMOptItems[0]),
						 CUSDRV_HELPTOPIC_2, IDS_HELPFILE);
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM printer property UI.
//
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM printer property UI.
        pOEMUIParam->cOEMOptItems = 1;

        VERBOSE(DLLTEXT("hrPrinterPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
		//
		//This is the second time we are called Now setup the optional items.
		//
        DWORD   dwError;
        DWORD   dwDeviceValue;
        DWORD   dwType;
        DWORD   dwNeeded;


        VERBOSE(DLLTEXT("hrPrinterPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Get device settings value from printer.
        dwError = GetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, &dwType, (PBYTE) &dwDeviceValue,
                                   sizeof(dwDeviceValue), &dwNeeded);
        if( (ERROR_SUCCESS != dwError)
            ||
            (dwDeviceValue > 100)
          )
        {
            // Failed to get the device value or value is invalid, just use the default.
            dwDeviceValue = 0;
        }

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMPrinterUICallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // New section.
        pOEMUIParam->pOEMOptItems[0].Level = 1;
        pOEMUIParam->pOEMOptItems[0].Flags = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].pName = GetStringResource(pOEMUIParam->hOEMHeap, pOEMUIParam->hModule, IDS_DEV_SECTION);
        pOEMUIParam->pOEMOptItems[0].Sel = dwDeviceValue;

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

		//
		//Setup the Optional Item
		//
	    pOEMUIParam->pOEMOptItems[0].pOptType->Type = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam = 100;	
		
		//
		//Allows You to apply Customised help to this Control
		//
		AddCustomUIHelp (pOEMUIParam->hPrinter,
						 pOEMUIParam->hOEMHeap, 
						 pOEMUIParam->hModule, 
						 &(pOEMUIParam->pOEMOptItems[0]), 
						 CUSDRV_HELPTOPIC_1, 
						 IDS_HELPFILE);
    }
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to Document property sheet. Called via IOemUI::DocumentPropertySheets
//
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, 
                                    IPrintOemDriverUI*  pOEMHelp)
{
    LONG_PTR    lResult;


    VERBOSE(DLLTEXT("OEMDocumentPropertySheets() entry.\r\n"));

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("OEMDocumentPropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return  E_FAIL;
    }

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                DWORD           dwSheets = 0;
                PCBUSERDATA     pUserData;
                POEMUIPSPARAM   pOEMUIParam = (POEMUIPSPARAM) pPSUIInfo->lParamInit;
                HANDLE          hHeap = pOEMUIParam->hOEMHeap;
				HANDLE          hModule = pOEMUIParam->hModule;
                POEMDEV         pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;
                COMPROPSHEETUI  Sheet;


                // Init property page.
                memset(&Sheet, 0, sizeof(COMPROPSHEETUI));
                Sheet.cbSize            = sizeof(COMPROPSHEETUI);
                Sheet.Flags             = CPSUIF_UPDATE_PERMISSION;
                Sheet.hInstCaller       = ghInstance;
                Sheet.pCallerName       = GetStringResource(hHeap, ghInstance, IDS_NAME);
                Sheet.pHelpFile         = NULL;
                Sheet.pfnCallBack       = OEMDocUICallBack2;
                Sheet.pDlgPage          = CPSUI_PDLGPAGE_TREEVIEWONLY;
                Sheet.cOptItem          = 1;
                Sheet.IconID            = IDI_CPSUI_PRINTER;
                Sheet.pOptItemName      = GetStringResource(hHeap, ghInstance, IDS_SECTION);
                Sheet.CallerVersion     = 0x100;
                Sheet.OptItemVersion    = 0x100;

                // Init user data.
                pUserData = (PCBUSERDATA) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(CBUSERDATA));
                pUserData->hComPropSheet = pPSUIInfo->hComPropSheet;
                pUserData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
                pUserData->pOEMUIParam = pOEMUIParam;
                Sheet.UserData = (ULONG_PTR) pUserData;

                // Create OptItems for page.
                Sheet.pOptItem = CreateOptItems(hHeap, Sheet.cOptItem);

                // Initialize OptItems
                Sheet.pOptItem[0].Level = 1;
                Sheet.pOptItem[0].Flags = OPTIF_COLLAPSE;
                Sheet.pOptItem[0].pName = GetStringResource(hHeap, ghInstance, IDS_SECTION);
                Sheet.pOptItem[0].Sel = pOEMDev->dwDriverData;
								
                Sheet.pOptItem[0].pOptType = CreateOptType(hHeap, 2);
				
				//
				//Set the UI prop of this OPTYPE item.
				//
				Sheet.pOptItem[0].pOptType->Type = TVOT_UDARROW;
                Sheet.pOptItem[0].pOptType->pOptParam[1].IconID = 0;
                Sheet.pOptItem[0].pOptType->pOptParam[1].lParam = 100;

				//
				//Allows You to apply Customised help to this Control.
				//See Function : AddCustomUIHelp, For more details on implamentation.
				//
				AddCustomUIHelp (pOEMUIParam->hPrinter,
								 hHeap, 
								 hModule, 
								 &(Sheet.pOptItem[0]), 
								 CUSDRV_HELPTOPIC_1, 
								 IDS_HELPFILE);
                
                // Adds the  property sheets.
                lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PCOMPROPSHEETUI, 
                                                     (LPARAM)&Sheet, (LPARAM)&dwSheets);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }

    pPSUIInfo->Result = lResult;
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to printer property sheet. Called via IOemUI::DevicePropertySheets
//
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam)
{
    LONG_PTR    lResult;


    VERBOSE(DLLTEXT("hrOEMDevicePropertySheets(%#x, %#x) entry\r\n"), pPSUIInfo, lParam);

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("hrOEMDevicePropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    Dump(pPSUIInfo);

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                PROPSHEETPAGE   Page;

                // Init property page.
                memset(&Page, 0, sizeof(PROPSHEETPAGE));
                Page.dwSize = sizeof(PROPSHEETPAGE);
                Page.dwFlags = PSP_DEFAULT;
                Page.hInstance = ghInstance;
                Page.pszTemplate = MAKEINTRESOURCE(IDD_DEVICE_PROPPAGE);
                Page.pfnDlgProc = DevicePropPageProc;

                // Add property sheets.
                lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PROPSHEETPAGE, (LPARAM)&Page, 0);

                VERBOSE(DLLTEXT("hrOEMDevicePropertySheets() pfnComPropSheet returned %d.\r\n"), lResult);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }

    pPSUIInfo->Result = lResult;
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM printer property UI.
//
LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMPrinterUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            {
                DWORD   dwDriverValue = pOEMUIParam->pOEMOptItems[0].Sel;

                // Store OptItems state in printer data.
                SetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, REG_DWORD, (PBYTE) &dwDriverValue, sizeof(DWORD));
            }
            break;

        default:
            break;
    }

    return lReturn;
}


////////////////////////////////////////////////////////////////////////////////
//
// Call back for OEM device property UI.
//
INT_PTR CALLBACK DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg)
    {
        case WM_COMMAND:
            switch(HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch(LOWORD(wParam))
                    {
                        case IDC_CALIBRATE:
                            // Just display a message that the printer is calibrated,
                            // since we don't acutally calibrate anything.
                            {
                                TCHAR   szName[MAX_PATH];
                                TCHAR   szCalibrated[MAX_PATH];


                                LoadString(ghInstance, IDS_NAME, szName, sizeof(szName)/sizeof(szName[0]));
                                LoadString(ghInstance, IDS_CALIBRATED, szCalibrated, sizeof(szCalibrated)/sizeof(szCalibrated[0]));
                                MessageBox(hDlg, szCalibrated, szName, MB_OK);
                            }
                            break;
                    }
                    break;

                default:
                    return FALSE;
            }
            return TRUE;

        case WM_NOTIFY:
            {
                switch (((LPNMHDR)lParam)->code)  // type of notification message
                {
                    case PSN_SETACTIVE:
                        break;
    
                    case PSN_KILLACTIVE:
                        break;

                    case PSN_APPLY:
                        break;

                    case PSN_RESET:
                        break;
                }
            }
            break;
    }

    return FALSE;
} 


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM document property UI.
//
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            // Store OptItems state in DEVMODE.
            pOEMDev->dwAdvancedData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

        case CPSUICB_REASON_KILLACTIVE:
            pOEMDev->dwAdvancedData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

        case CPSUICB_REASON_SETACTIVE:
            if(pOEMUIParam->pOEMOptItems[0].Sel != pOEMDev->dwAdvancedData)
            {
                pOEMUIParam->pOEMOptItems[0].Sel = pOEMDev->dwAdvancedData;
                pOEMUIParam->pOEMOptItems[0].Flags |= OPTIF_CHANGED;
                lReturn = CPSUICB_ACTION_OPTIF_CHANGED;
            }
            break;

        default:
            break;
    }

    return lReturn;
}


LONG APIENTRY OEMDocUICallBack2(PCPSUICBPARAM pCallbackParam)
{
    LONG            lReturn = CPSUICB_ACTION_NONE;
    PCBUSERDATA     pUserData = (PCBUSERDATA) pCallbackParam->UserData;
    POEMDEV         pOEMDev = (POEMDEV) pUserData->pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUICallBack2() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            pOEMDev->dwDriverData = pCallbackParam->pOptItem[0].Sel;
            pUserData->pfnComPropSheet(pUserData->hComPropSheet, CPSFUNC_SET_RESULT,
            	                       (LPARAM)pUserData->hPropPage,
               	                       (LPARAM)CPSUI_OK);
            break;

        case CPSUICB_REASON_KILLACTIVE:
            pOEMDev->dwDriverData = pCallbackParam->pOptItem[0].Sel;
            break;

        case CPSUICB_REASON_SETACTIVE:
            if(pCallbackParam->pOptItem[0].Sel != pOEMDev->dwDriverData)
            {
                pCallbackParam->pOptItem[0].Sel = pOEMDev->dwDriverData;
                pCallbackParam->pOptItem[0].Flags |= OPTIF_CHANGED;
                lReturn = CPSUICB_ACTION_OPTIF_CHANGED;
            }
            break;

        default:
            break;
    }

    return lReturn;
}


////////////////////////////////////////////////////////////////////////////////
//
// Creates and Initializes OptItems.
//
static POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems)
{
    POPTITEM    pOptItems = NULL;


    // Allocate memory for OptItems;
    pOptItems = (POPTITEM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTITEM) * dwOptItems);
    if(NULL != pOptItems)
    {
        InitOptItems(pOptItems, dwOptItems);
    }
    else
    {
        ERR(ERRORTEXT("CreateOptItems() failed to allocate memory for OPTITEMs!\r\n"));
    }

    return pOptItems;
}


////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems.
//
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems)
{
    VERBOSE(DLLTEXT("InitOptItems() entry.\r\n"));

    // Zero out memory.
    memset(pOptItems, 0, sizeof(OPTITEM) * dwOptItems);

    // Set each OptItem's size, and Public DM ID.
    for(DWORD dwCount = 0; dwCount < dwOptItems; dwCount++)
    {
        pOptItems[dwCount].cbSize = sizeof(OPTITEM);
        pOptItems[dwCount].DMPubID = DMPUB_NONE;
    }
}



////////////////////////////////////////////////////////////////////////////////
//
// Adds Custom help top a OPTTYPE UI item.
//
// Note :
//	The OPTITEM member HelpIndex must be set the the correct HELP ID number.
//		HelpIndex is the index that you assigned in the hlp file to this item of help.	
//	The OPTITEM, pOIExt member must point to a valid OIEXT structure.
//	The phelpfile is member of OIEXT must have the fully qualified path to the driver file.
//
//
//  It is also possible to overide common help items in UNIDRIVE via the HelpIndex in the GPD.
//  For further information on using HelpIndex in the GPD see the relavent section in the DDK
//  It is not possible to custimse help however via the PPD. The OPTITEM must be modified in the OEM Plugin.
//
static BOOL AddCustomUIHelp (HANDLE hPrinter, HANDLE hHeap, HANDLE hModule, 
							 POPTITEM pOptItem, DWORD HelpIndex, DWORD HelpFile)
{
	
	VERBOSE(DLLTEXT("AddCustomUIHelp() entry.\r\n"));
	POIEXT pOIExt = NULL;

	//
	//Allocate a new OIEXT structure on the heap
	//
	if (pOptItem->pOIExt == NULL)
	{
		pOptItem->pOIExt = CreateOIExt(hHeap);
	}

	if ( pOptItem->pOIExt == NULL )
	{
		ERR(ERRORTEXT("AddCustomUIHelp() Error Allocation Failed.\r\n"));
		return FALSE;
	}

	pOIExt = pOptItem->pOIExt;

	//
	//Set to the full absolute path of the driver file. 
	//(It should be in the Printer Driver Directrory in most cases)
	//This String needs to be allocated on the heap (The Driver will clean it up).
	//
	pOIExt->pHelpFile = GetHelpFile (hPrinter, hHeap, hModule, HelpFile);
			
	//
	//Set to show tha there is a valid OIEXT structure and data
	//
	pOptItem->Flags |= OPTIF_HAS_POIEXT;

	//
	//This needs to be set if you have ansi strings in your help file. (NOTE!)
	//
	//pOiExt->Flags |= OIEXTF_ANSI_STRING;

	//
	//Add the help this the index in the .hlp file.
	//
	pOptItem->HelpIndex = HelpIndex;

	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////
//
// Allocates and initializes OIEXT for OptItem.
//
static POIEXT CreateOIExt(HANDLE hHeap)
{

	POIEXT pOiExt = NULL;
	
	VERBOSE(DLLTEXT("CreateOIExt() entry.\r\n"));

    // Allocate memory from the heap for the OPTTYPE; the driver will take care of clean up.
    pOiExt = (POIEXT) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OIEXT));
    if(NULL != pOiExt)
    {
		//
		// Initialize OPTTYPE. (These members are setup by AddCustomUIHelp)
		//
        pOiExt->cbSize = sizeof(OIEXT);
		pOiExt->Flags = 0;
        pOiExt->hInstCaller = NULL;
		pOiExt->pHelpFile = NULL;
	}

	return pOiExt;
}

////////////////////////////////////////////////////////////////////////////////
//
// Allocates and initializes OptType for OptItem.
//
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams)
{
    POPTTYPE    pOptType = NULL;


    VERBOSE(DLLTEXT("CreateOptType() entry.\r\n"));

    // Allocate memory from the heap for the OPTTYPE; the driver will take care of clean up.
    pOptType = (POPTTYPE) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTTYPE));
    if(NULL != pOptType)
    {
        // Initialize OPTTYPE.
        pOptType->cbSize = sizeof(OPTTYPE);
        pOptType->Count = wOptParams;

        // Allocate memory from the heap for the OPTPARAMs for the OPTTYPE.
        pOptType->pOptParam = (POPTPARAM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, wOptParams * sizeof(OPTPARAM));
        if(NULL != pOptType->pOptParam)
        {
            // Initialize the OPTPARAMs.
            for(WORD wCount = 0; wCount < wOptParams; wCount++)
            {
                pOptType->pOptParam[wCount].cbSize = sizeof(OPTPARAM);
            }
        }
        else
        {
            ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTPARAMs!\r\n"));

            // Free allocated memory and return NULL.
            HeapFree(hHeap, 0, pOptType);
            pOptType = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTTYPE!\r\n"));
    }

    return pOptType;
}


////////////////////////////////////////////////////////////////////////////////
//
// Allocates space on the heap and gets the help file name from the resource file.
// Note you need to allocate this on the heap so that it stays allocated as long as the driver UI is loaded.
// The OPTITEM->pOIExt ref this data.
//
static PTSTR GetHelpFile (HANDLE hPrinter, HANDLE hHeap, HANDLE hModule, UINT uResource)
{	
	
	DWORD   nResult = 0;
    DWORD   dwSize = MAX_PATH;
	PTSTR   pszString  = NULL;
	PTSTR   pszTemp    = NULL;
	PDRIVER_INFO_2 pDriverInfo = NULL;
	
	VERBOSE(DLLTEXT("GetHelpFile (%#x, %#x, %d) entered.\r\n"), hHeap, hModule, uResource);
	
	//
	// Allocate buffer for string resource from heap;
	//
    pszTemp = (PTSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize * sizeof(TCHAR));
	pDriverInfo = (PDRIVER_INFO_2)WrapGetPrinterDriver (hHeap, hPrinter, 2);

	//
	//Get the Full Driver Dir from pDriverPath it must include the \version\ 
	//
    if(NULL != pszTemp && pDriverInfo && pDriverInfo->pDriverPath)
	{	
        HRESULT hCopy;

		hCopy = StringCchCopy(pszTemp, dwSize, pDriverInfo->pDriverPath);
        if(FAILED(hCopy))
        {
    		ERR(ERRORTEXT("StringCchCopy() failed to copy driver path to temp buffer!\r\n"));
        }
		pszString = _tcsrchr (pszTemp, _T('\\') ) + 1;
	}

	//
	//The Help file is installed with the driver in the version drictory.
	//
	if(NULL != pszString)
    {
		//
		//The Buffer size is in characters for the unicode version of LoadString
		//
		nResult = LoadString((HMODULE)hModule, uResource, pszString, (dwSize - _tcslen(pszTemp)) );
	}
	else
	{
		ERR(ERRORTEXT("GetStringResource() failed to allocate string buffer!\r\n"));
	}

	if(nResult > 0)
	{
		//
		//Reallocate this so that we don't waist space on the heap (free any non used heap in MAX_PATH)
		//
		pszString = (PTSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, pszTemp, (_tcslen(pszTemp) + 1) * sizeof(TCHAR));
		if(NULL == pszString)
		{
			pszTemp = pszString;
			ERR(ERRORTEXT("GetStringResource() HeapReAlloc() of string retrieved failed! (Last Error was %d)\r\n"), GetLastError());
		}
	}
	else
	{
		ERR(ERRORTEXT("LoadString() returned %d! (Last Error was %d)\r\n"), nResult, GetLastError());
		ERR(ERRORTEXT("GetStringResource() failed to load string resource %d!\r\n"), uResource);
		pszString = NULL;
	}
	
	//
	//Clean up the Driverinfo that was allocated. It is not needed. (Always free this it is only temp data)
	//
	if (pDriverInfo)
	{
		HeapFree(hHeap, 0, pDriverInfo);
	}
	
	return pszString;
}	

////////////////////////////////////////////////////////////////////////////////////
//
//  Retrieves pointer to a String resource.
//
static PTSTR GetStringResource(HANDLE hHeap, HANDLE hModule, UINT uResource)
{
    int     nResult;
    DWORD   dwSize = MAX_PATH;
    PTSTR   pszString = NULL;


    VERBOSE(DLLTEXT("GetStringResource(%#x, %#x, %d) entered.\r\n"), hHeap, hModule, uResource);

    // Allocate buffer for string resource from heap; let the driver clean it up.
    pszString = (PTSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize * sizeof(TCHAR));
    if(NULL != pszString)
    {
        // Load string resource; resize after loading so as not to waste memory.
        nResult = LoadString((HMODULE)hModule, uResource, pszString, dwSize);
        if(nResult > 0)
        {
            PTSTR   pszTemp;


            VERBOSE(DLLTEXT("LoadString() returned %d!\r\n"), nResult);
            VERBOSE(DLLTEXT("String load was \"%s\".\r\n"), pszString);

            pszTemp = (PTSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, pszString, (nResult + 1) * sizeof(TCHAR));
            if(NULL != pszTemp)
            {
                pszString = pszTemp;
            }
            else
            {
                ERR(ERRORTEXT("GetStringResource() HeapReAlloc() of string retrieved failed! (Last Error was %d)\r\n"), GetLastError());
            }
        }
        else
        {
            ERR(ERRORTEXT("LoadString() returned %d! (Last Error was %d)\r\n"), nResult, GetLastError());
            ERR(ERRORTEXT("GetStringResource() failed to load string resource %d!\r\n"), uResource);

            pszString = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("GetStringResource() failed to allocate string buffer!\r\n"));
    }

    return pszString;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Wrapper to help retrive the PrinterDriverInfo, 
//  Note the MEM is orphaned by this call on success
//

LPBYTE WrapGetPrinterDriver (HANDLE hHeap, HANDLE hPrinter, DWORD dwLevel)
{
	//
	//Get the PrinterINFO so that we know where the driver help file is.
	//
	BOOL    bGet        = TRUE;
    DWORD   dwSize      = 0;
    DWORD   dwNeeded    = 0;
    DWORD   dwError     = ERROR_SUCCESS;
    DWORD   dwLoop      = 0;
	LPBYTE  pBuffer		= NULL;

    do
    {
        if(!bGet && (dwError == ERROR_INSUFFICIENT_BUFFER ) )
        {
            dwSize = dwNeeded;

			if (pBuffer)
			{
                PBYTE   pTemp;


				pTemp = (LPBYTE)HeapReAlloc (hHeap, HEAP_ZERO_MEMORY, (LPVOID)pBuffer, dwSize);
                if(NULL != pTemp)
                {
                    pBuffer = pTemp;
                }
			}
			else
			{
				pBuffer = (LPBYTE)HeapAlloc (hHeap, HEAP_ZERO_MEMORY, dwSize);
			}
		}

        bGet = GetPrinterDriver(hPrinter, NULL, dwLevel, pBuffer, dwSize, &dwNeeded);
        dwError = GetLastError();

    } while (!bGet && (dwLoop++ < 4));

    if(!bGet)
    {
        if (pBuffer)
		{
			HeapFree(hHeap, 0, pBuffer);
			pBuffer = NULL;
		}
		ERR(ERRORTEXT("GetPrinterDriver(%p, %d, %p, %d) failed with error %d."), 
               hPrinter, dwLevel, pBuffer, dwError);
    }

	return pBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by oemui.rc
//
#define IDS_SECTION                     1
#define IDS_CALIBRATED                  2
#define IDS_NAME                        3
#define IDS_HELPFILE                    4
#define IDS_DEV_SECTION                 5
#define IDS_ADV_SECTION                 10
#define IDD_DEVICE_PROPPAGE             106
#define IDD_DOC_PROPPAGE                107
#define IDC_CALIBRATE                   1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\customhelp\customdrv.h ===
//
//
//
//
//////////////////////////////////////////////////////////////////

#define CUSDRV_HELPTOPIC_1 = 15001
#define CUSDRV_HELPTOPIC_2 = 15002
#define CUSDRV_HELPTOPIC_3 = 15003
#define CUSDRV_HELPTOPIC_4 = 15004
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\command.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:  Command.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for OEM Command function(s).
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _COMMAND_H
#define _COMMAND_H




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT PSCommand(PDEVOBJ, DWORD, PVOID, DWORD, IPrintOemDriverPS*, PDWORD);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\ddihook.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	 DDIHook.cpp
//    
//
//  PURPOSE:  DDI Hook routines for User Mode COM Customization DLL.
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "debug.h"
#include "oemps.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>




//
// OEMBitBlt
//

BOOL APIENTRY
OEMBitBlt(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMBitBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoTrg->dhpdev;

    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvBitBlt)(poempdev->pfnPS[UD_DrvBitBlt])) (
           psoTrg,
           psoSrc,
           psoMask,
           pco,
           pxlo,
           prclTrg,
           pptlSrc,
           pptlMask,
           pbo,
           pptlBrush,
           rop4));

}

//
// OEMStretchBlt
//

BOOL APIENTRY
OEMStretchBlt(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStretchBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;


    //
    // turn around to call PS
    //

    return (((PFN_DrvStretchBlt)(poempdev->pfnPS[UD_DrvStretchBlt])) (
            psoDest,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDest,
            prclSrc,
            pptlMask,
            iMode));

}


//
// OEMCopyBits
//

BOOL APIENTRY
OEMCopyBits(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDest,
    POINTL         *pptlSrc
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMCopyBits() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvCopyBits)(poempdev->pfnPS[UD_DrvCopyBits])) (
            psoDest,
            psoSrc,
            pco,
            pxlo,
            prclDest,
            pptlSrc));

}

//
// OEMTextOut
//

BOOL APIENTRY
OEMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMTextOut() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvTextOut)(poempdev->pfnPS[UD_DrvTextOut])) (
            pso,
            pstro,
            pfo,
            pco,
            prclExtra,
            prclOpaque,
            pboFore,
            pboOpaque,
            pptlOrg,
            mix));

}

//
// OEMStrokePath
//

BOOL APIENTRY
OEMStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStokePath() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvStrokePath)(poempdev->pfnPS[UD_DrvStrokePath])) (
            pso,
            ppo,
            pco,
            pxo,
            pbo,
            pptlBrushOrg,
            plineattrs,
            mix));

}

//
// OEMFillPath
//

BOOL APIENTRY
OEMFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMFillPath() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvFillPath)(poempdev->pfnPS[UD_DrvFillPath])) (
            pso,
            ppo,
            pco,
            pbo,
            pptlBrushOrg,
            mix,
            flOptions));

}

//
// OEMStrokeAndFillPath
//

BOOL APIENTRY
OEMStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStrokeAndFillPath() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvStrokeAndFillPath)(poempdev->pfnPS[UD_DrvStrokeAndFillPath])) (
            pso,
            ppo,
            pco,
            pxo,
            pboStroke,
            plineattrs,
            pboFill,
            pptlBrushOrg,
            mixFill,
            flOptions));

}

//
// OEMRealizeBrush
//

BOOL APIENTRY
OEMRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMRealizeBrush() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoTarget->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // the OEM DLL should NOT hook out this function unless it wants to draw
    // graphics directly to the device surface. In that case, it calls
    // EngRealizeBrush which causes GDI to call DrvRealizeBrush.
    // Note that it cannot call back into PS since PS doesn't hook it.
    //

    //
    // In this test DLL, the drawing hooks does not call EngRealizeBrush. So this
    // this function will never be called. Do nothing.
    //

    return TRUE;
}

//
// OEMStartPage
//

BOOL APIENTRY
OEMStartPage(
    SURFOBJ    *pso
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStartPage() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvStartPage)(poempdev->pfnPS[UD_DrvStartPage]))(pso));

}

#define OEM_TESTSTRING  "The DDICMDCB DLL adds this line of text."

//
// OEMSendPage
//

BOOL APIENTRY
OEMSendPage(
    SURFOBJ    *pso
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMSendPage() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // print a line of text, just for testing
    //
    if (pso->iType == STYPE_BITMAP)
    {
        pdevobj->pDrvProcs->DrvXMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvYMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj, OEM_TESTSTRING,
                                             sizeof(OEM_TESTSTRING));
    }

    //
    // turn around to call PS
    //

    return (((PFN_DrvSendPage)(poempdev->pfnPS[UD_DrvSendPage]))(pso));

}

//
// OEMEscape
//

ULONG APIENTRY
OEMEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMEscape() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvEscape)(poempdev->pfnPS[UD_DrvEscape])) (
            pso,
            iEsc,
            cjIn,
            pvIn,
            cjOut,
            pvOut));

}

//
// OEMStartDoc
//

BOOL APIENTRY
OEMStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStartDoc() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvStartDoc)(poempdev->pfnPS[UD_DrvStartDoc])) (
            pso,
            pwszDocName,
            dwJobId));

}

//
// OEMEndDoc
//

BOOL APIENTRY
OEMEndDoc(
    SURFOBJ    *pso,
    FLONG       fl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMEndDoc() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvEndDoc)(poempdev->pfnPS[UD_DrvEndDoc])) (
            pso,
            fl));

}

////////
// NOTE:
// OEM DLL needs to hook out the following six font related DDI calls only
// if it enumerates additional fonts beyond what's in the GPD file.
// And if it does, it needs to take care of its own fonts for all font DDI
// calls and DrvTextOut call.
///////

//
// OEMQueryFont
//

PIFIMETRICS APIENTRY
OEMQueryFont(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG_PTR  *pid
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMQueryFont() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvQueryFont)(poempdev->pfnPS[UD_DrvQueryFont])) (
            dhpdev,
            iFile,
            iFace,
            pid));

}

//
// OEMQueryFontTree
//

PVOID APIENTRY
OEMQueryFontTree(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG_PTR  *pid
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMQueryFontTree() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvQueryFontTree)(poempdev->pfnPS[UD_DrvQueryFontTree])) (
            dhpdev,
            iFile,
            iFace,
            iMode,
            pid));

}

//
// OEMQueryFontData
//

LONG APIENTRY
OEMQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMQueryFontData() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvQueryFontData)(poempdev->pfnPS[UD_DrvQueryFontData])) (
            dhpdev,
            pfo,
            iMode,
            hg,
            pgd,
            pv,
            cjSize));

}

//
// OEMQueryAdvanceWidths
//

BOOL APIENTRY
OEMQueryAdvanceWidths(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMQueryAdvanceWidths() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvQueryAdvanceWidths)
             (poempdev->pfnPS[UD_DrvQueryAdvanceWidths])) (
                   dhpdev,
                   pfo,
                   iMode,
                   phg,
                   pvWidths,
                   cGlyphs));

}

//
// OEMFontManagement
//

ULONG APIENTRY
OEMFontManagement(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMFontManagement() entry.\r\n"));

    //
    // Note that PS will not call OEM DLL for iMode==QUERYESCSUPPORT.
    // So pso is not NULL for sure.
    //
    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvFontManagement)(poempdev->pfnPS[UD_DrvFontManagement])) (
            pso,
            pfo,
            iMode,
            cjIn,
            pvIn,
            cjOut,
            pvOut));

}

//
// OEMGetGlyphMode
//

ULONG APIENTRY
OEMGetGlyphMode(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMGetGlyphMode() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvGetGlyphMode)(poempdev->pfnPS[UD_DrvGetGlyphMode])) (
            dhpdev,
            pfo));

}


//
// OEMStretchBltROP
//

BOOL APIENTRY
OEMStretchBltROP(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStretchBltROP() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvStretchBltROP)(poempdev->pfnPS[UD_DrvStretchBltROP])) (
            psoDest,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDest,
            prclSrc,
            pptlMask,
            iMode,
            pbo,
            rop4
            ));


}

//
// OEMPlgBlt
//

BOOL APIENTRY
OEMPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMPlgBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvPlgBlt)(poempdev->pfnPS[UD_DrvPlgBlt])) (
            psoDst,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlBrushOrg,
            pptfixDest,
            prclSrc,
            pptlMask,
            iMode));

}

//
// OEMAlphaBlend
//

BOOL APIENTRY
OEMAlphaBlend(
    SURFOBJ    *psoDest,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDest,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMAlphaBlend() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvAlphaBlend)(poempdev->pfnPS[UD_DrvAlphaBlend])) (
            psoDest,
            psoSrc,
            pco,
            pxlo,
            prclDest,
            prclSrc,
            pBlendObj
            ));

}

//
// OEMGradientFill
//

BOOL APIENTRY
OEMGradientFill(
        SURFOBJ    *psoDest,
        CLIPOBJ    *pco,
        XLATEOBJ   *pxlo,
        TRIVERTEX  *pVertex,
        ULONG       nVertex,
        PVOID       pMesh,
        ULONG       nMesh,
        RECTL      *prclExtents,
        POINTL     *pptlDitherOrg,
        ULONG       ulMode
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMGradientFill() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvGradientFill)(poempdev->pfnPS[UD_DrvGradientFill])) (
            psoDest,
            pco,
            pxlo,
            pVertex,
            nVertex,
            pMesh,
            nMesh,
            prclExtents,
            pptlDitherOrg,
            ulMode
            ));

}

BOOL APIENTRY
OEMTransparentBlt(
        SURFOBJ    *psoDst,
        SURFOBJ    *psoSrc,
        CLIPOBJ    *pco,
        XLATEOBJ   *pxlo,
        RECTL      *prclDst,
        RECTL      *prclSrc,
        ULONG      iTransColor,
        ULONG      ulReserved
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMTransparentBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvTransparentBlt)(poempdev->pfnPS[UD_DrvTransparentBlt])) (
            psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            prclSrc,
            iTransColor,
            ulReserved
            ));

}

HANDLE APIENTRY
OEMIcmCreateColorTransform(
    DHPDEV           dhpdev,
    LPLOGCOLORSPACEW pLogColorSpace,
    PVOID            pvSourceProfile,
    ULONG            cjSourceProfile,
    PVOID            pvDestProfile,
    ULONG            cjDestProfile,
    PVOID            pvTargetProfile,
    ULONG            cjTargetProfile,
    DWORD            dwReserved
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMCreateColorTransform() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvIcmCreateColorTransform)(poempdev->pfnPS[UD_DrvIcmCreateColorTransform])) (
            dhpdev,
            pLogColorSpace,
            pvSourceProfile,
            cjSourceProfile,
            pvDestProfile,
            cjDestProfile,
            pvTargetProfile,
            cjTargetProfile,
            dwReserved
            ));

}

BOOL APIENTRY
OEMIcmDeleteColorTransform(
    DHPDEV dhpdev,
    HANDLE hcmXform
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMDeleteColorTransform() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvIcmDeleteColorTransform)(poempdev->pfnPS[UD_DrvIcmDeleteColorTransform])) (
            dhpdev,
            hcmXform
            ));

}

BOOL APIENTRY
OEMQueryDeviceSupport(
    SURFOBJ    *pso,
    XLATEOBJ   *pxlo,
    XFORMOBJ   *pxo,
    ULONG      iType,
    ULONG      cjIn,
    PVOID      pvIn,
    ULONG      cjOut,
    PVOID      pvOut
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMQueryDeviceSupport() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvQueryDeviceSupport)(poempdev->pfnPS[UD_DrvQueryDeviceSupport])) (
            pso,
            pxlo,
            pxo,
            iType,
            cjIn,
            pvIn,
            cjOut,
            pvOut
            ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\command.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	command.cpp
//    
//
//  PURPOSE:  Source module for OEM customized Command(s).
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include <PRCOMOEM.H>
#include "oemps.h"
#include "debug.h"
#include "command.h"
#include "resource.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      Internal String Literals
////////////////////////////////////////////////////////

const CHAR TEST_BEGINSTREAM[]                   = "%%Test: Before begin stream\r\n";
const CHAR TEST_PSADOBE[]                       = "%%Test: Before %!PS-Adobe\r\n";
const CHAR TEST_PAGESATEND[]                    = "%%Test: Replace driver's %%PagesAtend\r\n";
const CHAR TEST_PAGES[]                         = "%%Test: Replace driver's %%Pages: (atend)\r\n";
const CHAR TEST_DOCUMENTPROCESSCOLORS[]         = "%%Test: Replace driver's %%DocumentProcessColors: (atend)\r\n";
const CHAR TEST_COMMENTS[]                      = "%%Test: Before %%EndComments\r\n";
const CHAR TEST_DEFAULTS[]                      = "%%Test: Before %%BeginDefaults and %%EndDefaults\r\n";
const CHAR TEST_BEGINPROLOG[]                   = "%%Test: After %%BeginProlog\r\n";
const CHAR TEST_ENDPROLOG[]                     = "%%Test: Before %%EndProlog\r\n";
const CHAR TEST_BEGINSETUP[]                    = "%%Test: After %%BeginSetup\r\n";
const CHAR TEST_ENDSETUP[]                      = "%%Test: Before %%EndSetup\r\n";
const CHAR TEST_BEGINPAGESETUP[]                = "%%Test: After %%BeginPageSetup\r\n";
const CHAR TEST_ENDPAGESETUP[]                  = "%%Test: Before %%EndpageSetup\r\n";
const CHAR TEST_PAGETRAILER[]                   = "%%Test: After %%PageTrailer\r\n";
const CHAR TEST_TRAILER[]                       = "%%Test: After %%Trailer\r\n";
const CHAR TEST_PAGENUMBER[]                    = "%%Test: Replace driver's %%Page:\r\n";
const CHAR TEST_PAGEORDER[]                     = "%%Test: Replace driver's %%PageOrder:\r\n";
const CHAR TEST_ORIENTATION[]                   = "%%Test: Replace driver's %%Orientation:\r\n";
const CHAR TEST_BOUNDINGBOX[]                   = "%%Test: Replace driver's %%BoundingBox:\r\n";
const CHAR TEST_DOCNEEDEDRES[]                  = "%%Test: Append to driver's %%DocumentNeededResourc\r\n";
const CHAR TEST_DOCSUPPLIEDRES[]                = "%%Test: Append to driver's %%DocumentSuppliedResou\r\n";
const CHAR TEST_EOF[]                           = "%%Test: After %%EOF\r\n";
const CHAR TEST_ENDSTREAM[]                     = "%%Test: After the last byte of job stream\r\n";
const CHAR TEST_DOCUMENTPROCESSCOLORSATEND[]    = "%%Test: DocumentProcessColorsAtend\r\n";
const CHAR TEST_VMSAVE[]                        = "%%Test: %%VMSave\r\n";
const CHAR TEST_VMRESTORE[]                     = "%%Test: %%VMRestore\r\n";
const CHAR TEST_PLATECOLOR[]                    = "%%Test: %%PlateColor:\r\n";
const CHAR TEST_SHOWPAGE[]                      = "%%Test: %%SowPage:\r\n";
const CHAR TEST_PAGEBBOX[]                      = "%%Test: %%PageBox:\r\n";
const CHAR TEST_ENDPAGECOMMENTS[]               = "%%Test: %%EndPageComments:\r\n";




////////////////////////////////////////////////////////////////////////////////////
//    The PSCRIPT driver calls this OEM function at specific points during output
//    generation. This gives the OEM DLL an opportunity to insert code fragments
//    at specific injection points in the driver's code. It should use
//    DrvWriteSpoolBuf for generating any output it requires.

HRESULT PSCommand(PDEVOBJ pdevobj, DWORD dwIndex, PVOID pData, DWORD cbSize, 
                  IPrintOemDriverPS* pOEMHelp, PDWORD pdwReturn)
{
    PCSTR   pProcedure  = NULL;
    DWORD   dwLen       = 0;
    DWORD   dwSize      = 0;
    HRESULT hResult     = E_FAIL;


    VERBOSE(DLLTEXT("Entering OEMCommand...\r\n"));

    switch (dwIndex)
    {
        case PSINJECT_BEGINSTREAM:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_BEGINSTREAM\n"));
            pProcedure = TEST_BEGINSTREAM;
            break;

        case PSINJECT_PSADOBE:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_PSADOBE\n"));
            pProcedure = TEST_PSADOBE;
            break;

        case PSINJECT_PAGESATEND:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_PAGESATEND\n"));
            pProcedure = TEST_PAGESATEND;
            break;

        case PSINJECT_PAGES:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_PAGES\n"));
            pProcedure = TEST_PAGES;
            break;

        case PSINJECT_DOCNEEDEDRES:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_DOCNEEDEDRES\n"));
            pProcedure = TEST_DOCNEEDEDRES;
            break;

        case PSINJECT_DOCSUPPLIEDRES:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_DOCSUPPLIEDRES\n"));
            pProcedure = TEST_DOCSUPPLIEDRES;
            break;

        case PSINJECT_PAGEORDER:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_PAGEORDER\n"));
            pProcedure = TEST_PAGEORDER;
            break;

        case PSINJECT_ORIENTATION:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_ORIENTATION\n"));
            pProcedure = TEST_ORIENTATION;
            break;

        case PSINJECT_BOUNDINGBOX:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_BOUNDINGBOX\n"));
            pProcedure = TEST_BOUNDINGBOX;
            break;

        case PSINJECT_DOCUMENTPROCESSCOLORS:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_DOCUMENTPROCESSCOLORS\n"));
            pProcedure = TEST_DOCUMENTPROCESSCOLORS;
            break;

        case PSINJECT_COMMENTS:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_COMMENTS\n"));
            pProcedure = TEST_COMMENTS;
            break;

        case PSINJECT_BEGINDEFAULTS:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_BEGINDEFAULTS\n"));
            pProcedure = TEST_DEFAULTS;
            break;

        case PSINJECT_ENDDEFAULTS:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_BEGINDEFAULTS\n"));
            pProcedure = TEST_DEFAULTS;
            break;

        case PSINJECT_BEGINPROLOG:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_BEGINPROLOG\n"));
            pProcedure = TEST_BEGINPROLOG;
            break;

        case PSINJECT_ENDPROLOG:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_ENDPROLOG\n"));
            pProcedure = TEST_ENDPROLOG;
            break;

        case PSINJECT_BEGINSETUP:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_BEGINSETUP\n"));
            pProcedure = TEST_BEGINSETUP;
            break;

        case PSINJECT_ENDSETUP:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_ENDSETUP\n"));
            pProcedure = TEST_ENDSETUP;
            break;

        case PSINJECT_BEGINPAGESETUP:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_BEGINPAGESETUP\n"));
            pProcedure = TEST_BEGINPAGESETUP;
            break;

        case PSINJECT_ENDPAGESETUP:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_ENDPAGESETUP\n"));
            pProcedure = TEST_ENDPAGESETUP;
            break;

        case PSINJECT_PAGETRAILER:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_PAGETRAILER\n"));
            pProcedure = TEST_PAGETRAILER;
            break;

        case PSINJECT_TRAILER:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_TRAILER\n"));
            pProcedure = TEST_TRAILER;
            break;

        case PSINJECT_PAGENUMBER:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_PAGENUMBER\n"));
            pProcedure = TEST_PAGENUMBER;
            break;

        case PSINJECT_EOF:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_EOF\n"));
            pProcedure = TEST_EOF;
            break;

        case PSINJECT_ENDSTREAM:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_ENDSTREAM\n"));
            pProcedure = TEST_ENDSTREAM;
            break;

        case PSINJECT_DOCUMENTPROCESSCOLORSATEND:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_DOCUMENTPROCESSCOLORSATEND\n"));
            pProcedure = TEST_DOCUMENTPROCESSCOLORSATEND;
            break;

        case PSINJECT_VMSAVE:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_VMSAVE\n"));
            pProcedure = TEST_VMSAVE;
            break;

        case PSINJECT_VMRESTORE:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_VMRESTORE\n"));
            pProcedure = TEST_VMRESTORE;
            break;

        case PSINJECT_PLATECOLOR:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_PLATECOLOR\n"));
            pProcedure = TEST_PLATECOLOR;
            break;

        case PSINJECT_SHOWPAGE:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_SHOWPAGE\n"));
            pProcedure = TEST_SHOWPAGE;
            break;

        case PSINJECT_PAGEBBOX:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_PAGEBBOX\n"));
            pProcedure = TEST_PAGEBBOX;
            break;

        case PSINJECT_ENDPAGECOMMENTS:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_ENDPAGECOMMENTS\n"));
            pProcedure = TEST_ENDPAGECOMMENTS;
            break;

        default:
            ERR(DLLTEXT("Undefined PSCommand %d!\r\n"), dwIndex);
            *pdwReturn = ERROR_NOT_SUPPORTED;
            return E_NOTIMPL;
    }

    // INVARIANT: should have injection string.

    if(NULL != pProcedure)
    {
        // Write PostScript to spool file.
        dwLen = strlen(pProcedure);
        hResult = pOEMHelp->DrvWriteSpoolBuf(pdevobj, const_cast<PSTR>(pProcedure), dwLen, &dwSize);

        // Dump DrvWriteSpoolBuf parameters.
        VERBOSE(DLLTEXT("dwLen  = %d\r\n"), dwLen);
        VERBOSE(DLLTEXT("dwSize = %d\r\n"), dwSize);
        //VERBOSE(DLLTEXT("pProcedure is:\r\n\t%hs\r\n"), pProcedure);

        // Set return values.
        if(SUCCEEDED(hResult) && (dwLen == dwSize))
        {
            *pdwReturn = ERROR_SUCCESS;
        }
        else
        {
            // Try to return meaningful
            // error value.
            *pdwReturn = GetLastError();
            if(ERROR_SUCCESS == *pdwReturn)
            {
                *pdwReturn = ERROR_WRITE_FAULT;
            }

            // Make sure we return failure
            // if the write didn't succeded.
            if(SUCCEEDED(hResult))
            {
                hResult = HRESULT_FROM_WIN32(*pdwReturn);
            }
        }
    }
    else
    {
        // This should never be reached.
        // Hence the RIP, but if we do
        // in non-debug version, we should
        // return appropriate values.
        RIP(DLLTEXT("PSCommand pProcedure is NULL!\r\n"));

        *pdwReturn = ERROR_NOT_SUPPORTED;
        hResult = E_NOTIMPL;
    }

    // dwLen should always equal dwSize.
    ASSERTMSG(dwLen == dwSize, DLLTEXT("number of bytes wrote should equal number of bytes written!"));

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'
#define MAX_LOOP                10


// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize      = DEBUG_BUFFER_SIZE;
    DWORD   dwLoop      = 0;
    LPSTR   lpszMsgBuf  = NULL;
    HRESULT hr;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
        {
            return FALSE;
        }

        hr = StringCbVPrintfA(lpszMsgBuf, (dwSize + 1) * sizeof(CHAR), lpszMessage, arglist);

    // Pass the variable parameters to wvsprintf to be formated.
    } while (FAILED(hr) && (STRSAFE_E_INSUFFICIENT_BUFFER == hr) && (++dwLoop < MAX_LOOP) );

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return SUCCEEDED(hr);
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    HRESULT     hResult;
    LPWSTR      lpszMsgBuf;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    hResult = StringCbVPrintfW(lpszMsgBuf, (dwSize + 1) * sizeof(WCHAR), lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return SUCCEEDED(hResult);
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(TEXT("pPublisherInfo:\r\n"));
    VERBOSE(TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(TEXT("pOemDMParam:\r\n"));
    VERBOSE(TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}



PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _DEBUG_H
#define _DEBUG_H



// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\devmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Devmode.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for devmode functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _DEVMODE_H
#define _DEVMODE_H


////////////////////////////////////////////////////////
//      OEM Devmode Defines
////////////////////////////////////////////////////////




////////////////////////////////////////////////////////
//      OEM Devmode Type Definitions
////////////////////////////////////////////////////////

typedef struct tagOEMDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    BOOL                dwDriverData;

} OEMDEV, *POEMDEV;

typedef const OEMDEV *PCOEMDEV;



/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam);
BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut);
BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode);
void Dump(PCOEMDEV pOEMDevIn);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\devmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Devmode.cpp
//    
//
//  PURPOSE:  Implementation of Devmode functions shared with OEM UI and OEM rendering modules.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oemps.h"
#include "debug.h"
#include "devmode.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam)
{
    POEMDEV pOEMDevIn;
    POEMDEV pOEMDevOut;


    // Verify parameters.
    if( (NULL == pOemDMParam)
        ||
        ( (OEMDM_SIZE != dwMode)
          &&
          (OEMDM_DEFAULT != dwMode)
          &&
          (OEMDM_CONVERT != dwMode)
          &&
          (OEMDM_MERGE != dwMode)
        )
      )
    {
        ERR(ERRORTEXT("DevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOemDMParam = %#lx.\r\n"), dwMode, pOemDMParam);

        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Cast generic (i.e. PVOID) to OEM private devomode pointer type.
    pOEMDevIn = (POEMDEV) pOemDMParam->pOEMDMIn;
    pOEMDevOut = (POEMDEV) pOemDMParam->pOEMDMOut;

    switch(dwMode)
    {
        case OEMDM_SIZE:
            pOemDMParam->cbBufSize = sizeof(OEMDEV);
            break;

        case OEMDM_DEFAULT:
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
            pOEMDevOut->dwDriverData            = 0;
            VERBOSE(DLLTEXT("pOEMDevOut after setting default values:\r\n"));
            Dump(pOEMDevOut);
            break;

        case OEMDM_CONVERT:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            break;

        case OEMDM_MERGE:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            MakeOEMDevmodeValid(pOEMDevOut);
            break;
    }
    Dump(pOemDMParam);

    return S_OK;
}


BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut)
{
    if( (NULL == pOEMDevIn)
        ||
        (NULL == pOEMDevOut)
      )
    {
        ERR(ERRORTEXT("ConvertOEMDevmode() invalid parameters.\r\n"));
        return FALSE;
    }

    // Check OEM Signature, if it doesn't match ours,
    // then just assume DMIn is bad and use defaults.
    if(pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature)
    {
        VERBOSE(DLLTEXT("Converting private OEM Devmode.\r\n"));
        VERBOSE(DLLTEXT("pOEMDevIn:\r\n"));
        Dump(pOEMDevIn);

        // Set the devmode defaults so that anything the isn't copied over will
        // be set to the default value.
        pOEMDevOut->dwDriverData = 0;

        // Copy the old structure in to the new using which ever size is the smaller.
        // Devmode maybe from newer Devmode (not likely since there is only one), or
        // Devmode maybe a newer Devmode, in which case it maybe larger,
        // but the first part of the structure should be the same.

        // DESIGN ASSUMPTION: the private DEVMODE structure only gets added to;
        // the fields that are in the DEVMODE never change only new fields get added to the end.

        memcpy(pOEMDevOut, pOEMDevIn, __min(pOEMDevOut->dmOEMExtra.dwSize, pOEMDevIn->dmOEMExtra.dwSize));

        // Re-fill in the size and version fields to indicated 
        // that the DEVMODE is the current private DEVMODE version.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
    }
    else
    {
        WARNING(DLLTEXT("Unknown DEVMODE signature, pOEMDMIn ignored.\r\n"));

        // Don't know what the input DEVMODE is, so just use defaults.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
        pOEMDevOut->dwDriverData            = 0;
    }

    return TRUE;
}


BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode)
{
    if(NULL == pOEMDevmode)
    {
        return FALSE;
    }

    // ASSUMPTION: pOEMDevmode is large enough to contain OEMDEV structure.

    // Make sure that dmOEMExtra indicates the current OEMDEV structure.
    pOEMDevmode->dmOEMExtra.dwSize       = sizeof(OEMDEV);
    pOEMDevmode->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
    pOEMDevmode->dmOEMExtra.dwVersion    = OEM_VERSION;

    // Set driver data.
    pOEMDevmode->dwDriverData = 0;

    return TRUE;
}


void Dump(PCOEMDEV pOEMDevmode)
{
    if( (NULL != pOEMDevmode)
        &&
        (pOEMDevmode->dmOEMExtra.dwSize >= sizeof(OEMDEV))
        &&
        (OEM_SIGNATURE == pOEMDevmode->dmOEMExtra.dwSignature)
      )
    {
        VERBOSE(_TEXT("\tdmOEMExtra.dwSize      = %d\r\n"), pOEMDevmode->dmOEMExtra.dwSize);
        VERBOSE(_TEXT("\tdmOEMExtra.dwSignature = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwSignature);
        VERBOSE(_TEXT("\tdmOEMExtra.dwVersion   = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwVersion);
        VERBOSE(_TEXT("\tdwDriverData           = %#x\r\n"), pOEMDevmode->dwDriverData);
    }
    else
    {
        ERR(ERRORTEXT("Dump(POEMDEV) unknown private OEM DEVMODE.\r\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\enable.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 -2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Enable.cpp
//    
//
//  PURPOSE:  Enable routines for User Mode COM Customization DLL.
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "debug.h"
#include "oemps.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      Internal Constants
////////////////////////////////////////////////////////

///////////////////////////////////////////////////////
// Warning: the following array order must match the 
//          order in enum ENUMHOOKS.
///////////////////////////////////////////////////////
static const DRVFN OEMHookFuncs[] =
{
    { INDEX_DrvRealizeBrush,                (PFN) OEMRealizeBrush               },
    { INDEX_DrvCopyBits,                    (PFN) OEMCopyBits                   },
    { INDEX_DrvBitBlt,                      (PFN) OEMBitBlt                     },
    { INDEX_DrvStretchBlt,                  (PFN) OEMStretchBlt                 },
    { INDEX_DrvTextOut,                     (PFN) OEMTextOut                    },
    { INDEX_DrvStrokePath,                  (PFN) OEMStrokePath                 },
    { INDEX_DrvFillPath,                    (PFN) OEMFillPath                   },
    { INDEX_DrvStrokeAndFillPath,           (PFN) OEMStrokeAndFillPath          },
    { INDEX_DrvStartPage,                   (PFN) OEMStartPage                  },
    { INDEX_DrvSendPage,                    (PFN) OEMSendPage                   },
    { INDEX_DrvEscape,                      (PFN) OEMEscape                     },
    { INDEX_DrvStartDoc,                    (PFN) OEMStartDoc                   },
    { INDEX_DrvEndDoc,                      (PFN) OEMEndDoc                     },
    { INDEX_DrvQueryFont,                   (PFN) OEMQueryFont                  },
    { INDEX_DrvQueryFontTree,               (PFN) OEMQueryFontTree              },
    { INDEX_DrvQueryFontData,               (PFN) OEMQueryFontData              },
    { INDEX_DrvQueryAdvanceWidths,          (PFN) OEMQueryAdvanceWidths         },
    { INDEX_DrvFontManagement,              (PFN) OEMFontManagement             },
    { INDEX_DrvGetGlyphMode,                (PFN) OEMGetGlyphMode               },
    { INDEX_DrvStretchBltROP,               (PFN) OEMStretchBltROP              },
    { INDEX_DrvPlgBlt,                      (PFN) OEMPlgBlt                     },
    { INDEX_DrvTransparentBlt,              (PFN) OEMTransparentBlt             },
    { INDEX_DrvAlphaBlend,                  (PFN) OEMAlphaBlend                 },
    { INDEX_DrvGradientFill,                (PFN) OEMGradientFill               },
    { INDEX_DrvIcmCreateColorTransform,     (PFN) OEMIcmCreateColorTransform    },
    { INDEX_DrvIcmDeleteColorTransform,     (PFN) OEMIcmDeleteColorTransform    },
    { INDEX_DrvQueryDeviceSupport,          (PFN) OEMQueryDeviceSupport         },
};







PDEVOEM APIENTRY OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded        // Unidrv's hook table
    )
{
    POEMPDEV    poempdev;
    INT         i, j;
    DWORD       dwDDIIndex;
    PDRVFN      pdrvfn;

    VERBOSE(DLLTEXT("OEMEnablePDEV() entry.\r\n"));

    //
    // Allocate the OEMDev
    //
    poempdev = new OEMPDEV;
    if (NULL == poempdev)
    {
        return NULL;
    }

    //
    // Fill in OEMDEV as you need
    //

    //
    // Fill in OEMDEV
    //

    for (i = 0; i < MAX_DDI_HOOKS; i++)
    {
        //
        // search through Unidrv's hooks and locate the function ptr
        //
        dwDDIIndex = OEMHookFuncs[i].iFunc;
        for (j = pded->c, pdrvfn = pded->pdrvfn; j > 0; j--, pdrvfn++)
        {
            if (dwDDIIndex == pdrvfn->iFunc)
            {
                poempdev->pfnPS[i] = pdrvfn->pfn;
                break;
            }
        }
        if (j == 0)
        {
            //
            // didn't find the Unidrv hook. Should happen only with DrvRealizeBrush
            //
            poempdev->pfnPS[i] = NULL;
        }

    }

    return (POEMPDEV) poempdev;
}


VOID APIENTRY OEMDisablePDEV(
    PDEVOBJ pdevobj
    )
{
    VERBOSE(DLLTEXT("OEMDisablePDEV() entry.\r\n"));


    //
    // Free memory for OEMPDEV and any memory block that hangs off OEMPDEV.
    //
    assert(NULL != pdevobj->pdevOEM);
    delete pdevobj->pdevOEM;
}


BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    )
{
    VERBOSE(DLLTEXT("OEMResetPDEV() entry.\r\n"));


    //
    // If you want to carry over anything from old pdev to new pdev, do it here.
    //

    return TRUE;
}


VOID APIENTRY OEMDisableDriver()
{
    VERBOSE(DLLTEXT("OEMDisableDriver() entry.\r\n"));
}


BOOL APIENTRY OEMEnableDriver(DWORD dwOEMintfVersion, DWORD dwSize, PDRVENABLEDATA pded)
{
    VERBOSE(DLLTEXT("OEMEnableDriver() entry.\r\n"));

    // List DDI functions that are hooked.
    pded->iDriverVersion =  PRINTER_OEMINTF_VERSION;
    pded->c = sizeof(OEMHookFuncs) / sizeof(DRVFN);
    pded->pdrvfn = (DRVFN *) OEMHookFuncs;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oemps.h"
#include "debug.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//

// DllMain isn't called/used for kernel mode version.
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}



}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _DEBUG_H
#define _DEBUG_H


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);
void Dump(PPROPSHEETUI_INFO pPSUIInfo);
void Dump(POPTITEM pOptItem);
void Dump(POPTTYPE pOptType);
void Dump(POPTPARAM pOptParam, WORD wCount);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\intrface.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Intrface.H
//    
//
//  PURPOSE:	Define COM interface for User Mode Printer Customization DLL.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _INTERFACE_H
#define _INTERFACE_H



////////////////////////////////////////////////////////////////////////////////
//
//  IOemPS
//
//  Interface for PostScript OEM sample rendering module
//
class IOemPS : public IPrintOemPS
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);


    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);
    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommand - PSCRIPT only, return E_NOTIMPL on Unidrv
    //

    STDMETHOD(Command) (THIS_ PDEVOBJ     pdevobj,
                              DWORD       dwIndex,
                              PVOID       pData,
                              DWORD       cbSize,
                              OUT DWORD   *pdwResult);

    //

    IOemPS();
    ~IOemPS();

protected:
    long                m_cRef;
    IPrintOemDriverPS*  m_pOEMHelp;
};





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\devmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Devmode.cpp
//    
//
//  PURPOSE:  Implementation of Devmode functions shared with OEM UI and OEM rendering modules.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oemui.h"
#include "debug.h"
#include "devmode.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>


//
//Performs operation on UI Plugins Private DevMode Members.
//Called via IOemUI::DevMode
//

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam)
{
    POEMDEV pOEMDevIn;
    POEMDEV pOEMDevOut;


    // Verify parameters.
    if( (NULL == pOemDMParam)
        ||
        ( (OEMDM_SIZE != dwMode)
          &&
          (OEMDM_DEFAULT != dwMode)
          &&
          (OEMDM_CONVERT != dwMode)
          &&
          (OEMDM_MERGE != dwMode)
        )
      )
    {
        ERR(ERRORTEXT("DevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOemDMParam = %#lx.\r\n"), dwMode, pOemDMParam);

        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Cast generic (i.e. PVOID) to OEM private devomode pointer type.
    pOEMDevIn = (POEMDEV) pOemDMParam->pOEMDMIn;
    pOEMDevOut = (POEMDEV) pOemDMParam->pOEMDMOut;

    switch(dwMode)
    {
		//
		//The Method should return the size of the memory allocation needed to store the UI plugin Private DEVMODE.
		//
        case OEMDM_SIZE:
            pOemDMParam->cbBufSize = sizeof(OEMDEV);
            break;

		//
		//Should fill the Private DEVMODE with the default values.
		//
        case OEMDM_DEFAULT:
			//
			//OEM_DMEXTRAHEADER Members
			//
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;

			//
			//Private members
			//
            pOEMDevOut->dwDriverData            = 0;
            pOEMDevOut->dwAdvancedData          = 0;

            VERBOSE(DLLTEXT("pOEMDevOut after setting default values:\r\n"));
            Dump(pOEMDevOut);			
            break;
			
		//
		//The method should convert private DEVMODE members to the current version, if necessary.
		//
        case OEMDM_CONVERT:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            break;
		
		//
		//The method should validate the information contained in private DEVMODE members and merge validated values into a private DEVMODE structure containing default values
		//
        case OEMDM_MERGE:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            MakeOEMDevmodeValid(pOEMDevOut);
            break;
    }
    Dump(pOemDMParam);

    return S_OK;
}


BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut)
{
    if( (NULL == pOEMDevIn)
        ||
        (NULL == pOEMDevOut)
      )
    {
        ERR(ERRORTEXT("ConvertOEMDevmode() invalid parameters.\r\n"));
        return FALSE;
    }

    // Check OEM Signature, if it doesn't match ours,
    // then just assume DMIn is bad and use defaults.
    if(pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature)
    {
        VERBOSE(DLLTEXT("Converting private OEM Devmode.\r\n"));
        VERBOSE(DLLTEXT("pOEMDevIn:\r\n"));
        Dump(pOEMDevIn);

        // Set the devmode defaults so that anything the isn't copied over will
        // be set to the default value.
        pOEMDevOut->dwDriverData    = 0;
        pOEMDevOut->dwAdvancedData  = 0;

        // Copy the old structure in to the new using which ever size is the smaller.
        // Devmode maybe from newer Devmode (not likely since there is only one), or
        // Devmode maybe a newer Devmode, in which case it maybe larger,
        // but the first part of the structure should be the same.

        // DESIGN ASSUMPTION: the private DEVMODE structure only gets added to;
        // the fields that are in the DEVMODE never change only new fields get added to the end.

        memcpy(pOEMDevOut, pOEMDevIn, __min(pOEMDevOut->dmOEMExtra.dwSize, pOEMDevIn->dmOEMExtra.dwSize));

        // Re-fill in the size and version fields to indicated 
        // that the DEVMODE is the current private DEVMODE version.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
    }
    else
    {
        WARNING(DLLTEXT("Unknown DEVMODE signature, pOEMDMIn ignored.\r\n"));

        // Don't know what the input DEVMODE is, so just use defaults.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
        pOEMDevOut->dwDriverData            = 0;
        pOEMDevOut->dwAdvancedData          = 0;
    }

    return TRUE;
}


BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode)
{
    if(NULL == pOEMDevmode)
    {
        return FALSE;
    }

    // ASSUMPTION: pOEMDevmode is large enough to contain OEMDEV structure.

    // Make sure that dmOEMExtra indicates the current OEMDEV structure.
    pOEMDevmode->dmOEMExtra.dwSize       = sizeof(OEMDEV);
    pOEMDevmode->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
    pOEMDevmode->dmOEMExtra.dwVersion    = OEM_VERSION;

    // Set driver data, if not valid.
    if(pOEMDevmode->dwDriverData > 100)
    {
        pOEMDevmode->dwDriverData = 0;
    }

    // Set Advanced driver data, if not valid.
    if(pOEMDevmode->dwAdvancedData > 100)
    {
        pOEMDevmode->dwAdvancedData = 0;
    }

    return TRUE;
}


void Dump(PCOEMDEV pOEMDevmode)
{
    if( (NULL != pOEMDevmode)
        &&
        (pOEMDevmode->dmOEMExtra.dwSize >= sizeof(OEMDEV))
        &&
        (OEM_SIGNATURE == pOEMDevmode->dmOEMExtra.dwSignature)
      )
    {
        VERBOSE(TEXT("\tdmOEMExtra.dwSize      = %d\r\n"), pOEMDevmode->dmOEMExtra.dwSize);
        VERBOSE(TEXT("\tdmOEMExtra.dwSignature = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwSignature);
        VERBOSE(TEXT("\tdmOEMExtra.dwVersion   = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwVersion);
        VERBOSE(TEXT("\tdwDriverData           = %#x\r\n"), pOEMDevmode->dwDriverData);
        VERBOSE(TEXT("\tdwAdvancedData         = %#x\r\n"), pOEMDevmode->dwAdvancedData);
    }
    else
    {
        ERR(ERRORTEXT("Dump(POEMDEV) unknown private OEM DEVMODE.\r\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\devmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Devmode.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for devmode functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _DEVMODE_H
#define _DEVMODE_H


////////////////////////////////////////////////////////
//      OEM Devmode Defines
////////////////////////////////////////////////////////




////////////////////////////////////////////////////////
//      OEM Devmode Type Definitions
////////////////////////////////////////////////////////

//
//Can add info to the private devmode bellow here.
//Note :
//		This structure must be prefixed by OEM_DMEXTRAHEADER
//		Your plug-in must implement the IPrintOemUI::DevMode method
//
typedef struct tagOEMDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    DWORD               dwDriverData;
    DWORD               dwAdvancedData;

	//
	//Private DevMode Members
	//

} OEMDEV, *POEMDEV;

typedef const OEMDEV *PCOEMDEV;



/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam);
BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut);
BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode);
void Dump(PCOEMDEV pOEMDevIn);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oemui.h"
#include "debug.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>


// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));
            ghInstance = hInst;
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}


}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\oemps.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	OEMPS.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _OEMPS_H
#define _OEMPS_H

#include "OEM.H"
#include "DEVMODE.H"


////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define DLLTEXT(s)      TEXT("OEMPS:  ") TEXT(s)
#define ERRORTEXT(s)    TEXT("ERROR ") DLLTEXT(s)


///////////////////////////////////////////////////////
// Warning: the following enum order must match the 
//          order in OEMHookFuncs[].
///////////////////////////////////////////////////////
typedef enum tag_Hooks {
    UD_DrvRealizeBrush,
    UD_DrvCopyBits,
    UD_DrvBitBlt,
    UD_DrvStretchBlt,
    UD_DrvTextOut,
    UD_DrvStrokePath,
    UD_DrvFillPath,
    UD_DrvStrokeAndFillPath,
    UD_DrvStartPage,
    UD_DrvSendPage,
    UD_DrvEscape,
    UD_DrvStartDoc,
    UD_DrvEndDoc,
    UD_DrvQueryFont,
    UD_DrvQueryFontTree,
    UD_DrvQueryFontData,
    UD_DrvQueryAdvanceWidths,
    UD_DrvFontManagement,
    UD_DrvGetGlyphMode,
    UD_DrvStretchBltROP,
    UD_DrvPlgBlt,
    UD_DrvTransparentBlt,
    UD_DrvAlphaBlend,
    UD_DrvGradientFill,
    UD_DrvIcmCreateColorTransform,
    UD_DrvIcmDeleteColorTransform,
    UD_DrvQueryDeviceSupport,

    MAX_DDI_HOOKS,

} ENUMHOOKS;


typedef struct _OEMPDEV {
    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    // This test DLL hooks out every drawing DDI. So it needs to remember
    // PS's hook function pointer so it call back.
    //
    PFN     pfnPS[MAX_DDI_HOOKS];

    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    DWORD     dwReserved[1];

} OEMPDEV, *POEMPDEV;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\globals.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Globals.cpp
//    
//
//  PURPOSE:  File that contains all the globals.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//
#define _GLOBALS_H

#include "precomp.h"
#include "oemui.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>


///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
HINSTANCE   ghInstance = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OEMPS.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif


// Required header files that shouldn't change often.

#include <STDDEF.H>
#include <STDLIB.H>
#ifdef OEMCOM
  #include <OBJBASE.H>
#endif
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
extern "C" 
{
    #include <WINDDI.H>
}
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRINTOEM.H>


#define COUNTOF(p)  (sizeof(p)/sizeof(*(p)))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\intrface.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Intrface.cpp
//    
//
//  PURPOSE:  Interface for User Mode COM Customization DLL.
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "oemps.h"
#include "debug.h"
#include "command.h"
#include "intrface.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents;     // Count of active components
static long g_cServerLocks;    // Count of locks






////////////////////////////////////////////////////////////////////////////////
//
// IOemPS body
//
IOemPS::IOemPS() 
{ 
    VERBOSE(DLLTEXT("IOemPS::IOemPS() entered.\r\n"));

    // Increment COM component count.
    InterlockedIncrement(&g_cComponents);

    InterlockedIncrement(&m_cRef);
    m_pOEMHelp = NULL; 

    VERBOSE(DLLTEXT("IOemPS::IOemPS() leaving.\r\n"));
}


IOemPS::~IOemPS()
{
    // Make sure that helper interface is released.
    if(NULL != m_pOEMHelp)
    {
        m_pOEMHelp->Release();
        m_pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == m_cRef);

    // Decrement COM compontent count.
    InterlockedDecrement(&g_cComponents);
}


HRESULT __stdcall IOemPS::QueryInterface(const IID& iid, void** ppv)
{    
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE(DLLTEXT("IOemPS::QueryInterface IUnknown.\r\n")); 
    }
    else if (iid == IID_IPrintOemPS)
    {
        *ppv = static_cast<IPrintOemPS*>(this);
        VERBOSE(DLLTEXT("IOemPS::QueryInterface IPrintOemPs.\r\n")); 
    }
    else
    {
#if DBG && defined(USERMODE_DRIVER)
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        VERBOSE(DLLTEXT("IOemPS::QueryInterface %s not supported.\r\n"), szOutput); 
#endif
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

ULONG __stdcall IOemPS::AddRef()
{
    VERBOSE(DLLTEXT("IOemPS::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemPS::Release() 
{
   VERBOSE(DLLTEXT("IOemPS::Release() entry.\r\n"));
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}


HRESULT __stdcall IOemPS::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemPS::GetInfo(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        ERR(DLLTEXT("IOemPS::GetInfo() exit pcbNeeded is NULL!\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size.
    if(OEMGI_GETPUBLISHERINFO != dwMode)
    {
        *pcbNeeded = sizeof(DWORD);
    }
    else
    {
        *pcbNeeded = sizeof(PUBLISHERINFO);
        return E_FAIL;
    }

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        ERR(DLLTEXT("IOemPS::GetInfo() exit insufficient buffer!\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = OEM_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = OEM_VERSION;
            break;

        case OEMGI_GETPUBLISHERINFO:
            Dump((PPUBLISHERINFO)pBuffer);
            // Fall through to default case.

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            ERR(DLLTEXT("IOemPS::GetInfo() exit, mode not supported.\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IOemPS::GetInfo() exit S_OK, (*pBuffer is %#x).\r\n"), *(PDWORD)pBuffer);

    return S_OK;
}

HRESULT __stdcall IOemPS::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IOemPS::PublishDriverInterface() entry.\r\n"));

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->m_pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverPS, (void** ) &(this->m_pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->m_pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}


HRESULT __stdcall IOemPS::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    VERBOSE(DLLTEXT("IOemPS::EnableDriver() entry.\r\n"));

    OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Even if nothing is done, need to return S_OK so 
    // that DisableDriver() will be called, which releases
    // the reference to the Printer Driver's interface.
    // If error occurs, return E_FAIL.
    return S_OK;
}

HRESULT __stdcall IOemPS::DisableDriver(VOID)
{
    VERBOSE(DLLTEXT("IOemPS::DisaleDriver() entry.\r\n"));

    OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->m_pOEMHelp)
    {
        this->m_pOEMHelp->Release();
        this->m_pOEMHelp = NULL;
    }

    return S_OK;
}

HRESULT __stdcall IOemPS::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    VERBOSE(DLLTEXT("IOemPS::DisablePDEV() entry.\r\n"));

    OEMDisablePDEV(pdevobj);

    return S_OK;
};

HRESULT __stdcall IOemPS::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE(DLLTEXT("IOemPS::EnablePDEV() entry.\r\n"));

    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns,  phsurfPatterns,
                             cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);

    return (NULL != *pDevOem ? S_OK : E_FAIL);
}


HRESULT __stdcall IOemPS::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    BOOL    bResult;


    VERBOSE(DLLTEXT("IOemPS::ResetPDEV() entry.\r\n"));

    bResult = OEMResetPDEV(pdevobjOld, pdevobjNew);

    return (bResult ? S_OK : E_FAIL);
}


HRESULT __stdcall IOemPS::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IOemPS:DevMode(%d, %#x) entry.\n"), dwMode, pOemDMParam); 
    return hrOEMDevMode(dwMode, pOemDMParam);
}

HRESULT __stdcall IOemPS::Command(
    PDEVOBJ     pdevobj,
    DWORD       dwIndex,
    PVOID       pData,
    DWORD       cbSize,
    OUT DWORD   *pdwResult)
{
    HRESULT hResult = E_NOTIMPL;


    VERBOSE(DLLTEXT("IOemPS::Command() entry.\r\n"));
    hResult = PSCommand(pdevobj, dwIndex, pData, cbSize, m_pOEMHelp, pdwResult);

    return hResult;
}


////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);
   
    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF();
    ~IOemCF();

protected:
    long    m_cRef;
};

///////////////////////////////////////////////////////////
//
// Class factory body
//
IOemCF::IOemCF()
{ 
    VERBOSE(DLLTEXT("IOemCF::IOemCF() entered.\r\n"));

    InterlockedIncrement(&m_cRef);
}

IOemCF::~IOemCF() 
{ 
    VERBOSE(DLLTEXT("IOemCF::~IOemCF() entered.\r\n"));

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == m_cRef);
}

HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE(DLLTEXT("IOemCF::QueryInterface entered.\r\n"));

    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this); 
    }
    else
    {
#if DBG && defined(USERMODE_DRIVER)
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        WARNING(DLLTEXT("IOemCF::QueryInterface %s not supported.\r\n"), szOutput); 
#endif

        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();

    VERBOSE(DLLTEXT("IOemCF::QueryInterface leaving.\r\n"));

    return S_OK;
}

ULONG __stdcall IOemCF::AddRef()
{
    VERBOSE(DLLTEXT("IOemCF::AddRef() called.\r\n"));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release() 
{
   VERBOSE(DLLTEXT("IOemCF::Release() called.\r\n"));

   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv) 
{
    VERBOSE(DLLTEXT("Class factory:  Create component.\r\n"));

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        WARNING(DLLTEXT("Class factory:  non-Null pUnknownOuter.\r\n"));

        return CLASS_E_NOAGGREGATION;
    }

    // Create component.
    IOemPS* pOemCP = new IOemPS;
    if (pOemCP == NULL)
    {
        ERR(ERRORTEXT("Class factory:  failed to allocate IOemPS.\r\n"));

        return E_OUTOFMEMORY;
    }

    // Get the requested interface.
    HRESULT hr = pOemCP->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCP->Release();
    return hr;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock) 
{
    VERBOSE(DLLTEXT("IOemCF::LockServer(%d) entered.\r\n"), bLock);

    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }

    VERBOSE(DLLTEXT("IOemCF::LockServer() leaving.\r\n"));
    return S_OK;
}


//
// Registration functions
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    //
    // To avoid leaving OEM DLL still in memory when Unidrv or Pscript drivers 
    // are unloaded, Unidrv and Pscript driver ignore the return value of 
    // DllCanUnloadNow of the OEM DLL, and always call FreeLibrary on the OEMDLL.
    //
    // If OEM DLL spins off a working thread that also uses the OEM DLL, the 
    // thread needs to call LoadLibrary and FreeLibraryAndExitThread, otherwise 
    // it may crash after Unidrv or Pscript calls FreeLibrary.
    //

    VERBOSE(DLLTEXT("DllCanUnloadNow entered.\r\n"));

    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:  Create class factory entered.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        ERR(ERRORTEXT("DllGetClassObject:  doesn't support clsid %#x!\r\n"), clsid);
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        ERR(ERRORTEXT("DllGetClassObject:  memory allocation failed!\r\n"));
        return E_OUTOFMEMORY;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();


    VERBOSE(DLLTEXT("DllGetClassObject:  Create class factory leaving.\r\n"));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\globals.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Globals.h
//    
//
//  PURPOSE:   Lists of globals declared in Globals.cpp.
//
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _GLOBALS_H
#define _GLOBALS_H


///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
extern HINSTANCE   ghInstance;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'
#define MAX_LOOP                10



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize      = DEBUG_BUFFER_SIZE;
    DWORD   dwLoop      = 0;
    LPSTR   lpszMsgBuf  = NULL;
    HRESULT hr;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
        {
            return FALSE;
        }

        hr = StringCbVPrintfA(lpszMsgBuf, (dwSize + 1) * sizeof(CHAR), lpszMessage, arglist);

    // Pass the variable parameters to wvsprintf to be formated.
    } while (FAILED(hr) && (STRSAFE_E_INSUFFICIENT_BUFFER == hr) && (++dwLoop < MAX_LOOP) );

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return SUCCEEDED(hr);
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR      lpszMsgBuf;
    HRESULT     hResult;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    hResult = StringCbVPrintfW(lpszMsgBuf, (dwSize + 1) * sizeof(WCHAR), lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return SUCCEEDED(hResult);
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(TEXT("pPublisherInfo:\r\n"));
    if(NULL == pPublisherInfo)
    {
        VERBOSE(TEXT("\tpPublisherInfo is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(TEXT("pOemDMParam:\r\n"));
    if(NULL == pOemDMParam)
    {
        VERBOSE(TEXT("\tpOemDMParam is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}

void Dump(PPROPSHEETUI_INFO pPSUIInfo)
{
    VERBOSE(TEXT("pPSUIInfo:\r\n"));
    if(NULL == pPSUIInfo)
    {
        VERBOSE(TEXT("\tpPSUIInfo is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize          = %d\r\n"), pPSUIInfo->cbSize);
    VERBOSE(TEXT("\tVersion         = %#x\r\n"), pPSUIInfo->Version);
    VERBOSE(TEXT("\tFlags           = %#x\r\n"), pPSUIInfo->Flags);
    VERBOSE(TEXT("\tReason          = %d\r\n"), pPSUIInfo->Reason);
    VERBOSE(TEXT("\thComPropSheet   = %#x\r\n"), pPSUIInfo->hComPropSheet);
    VERBOSE(TEXT("\tpfnComPropSheet = %#x\r\n"), pPSUIInfo->pfnComPropSheet);
    VERBOSE(TEXT("\tlParamInit      = %#x\r\n"), pPSUIInfo->lParamInit);
    VERBOSE(TEXT("\tUserData        = %#x\r\n"), pPSUIInfo->UserData);
    VERBOSE(TEXT("\tResult          = %#x\r\n"), pPSUIInfo->Result);
}

void Dump(POPTITEM pOptItem)
{
    VERBOSE(TEXT("pOptItem:\r\n"));
    if(NULL == pOptItem)
    {
        VERBOSE(TEXT("\tpOptItem is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize          = %d\r\n"),     pOptItem->cbSize);
    VERBOSE(TEXT("\tLevel           = %d\r\n"),     pOptItem->Level);
    VERBOSE(TEXT("\tDlgPageIdx      = %d\r\n"),     pOptItem->DlgPageIdx);
    VERBOSE(TEXT("\tFlags           = 0x%x\r\n"),   pOptItem->Flags);
    VERBOSE(TEXT("\tUserData        = 0x%p\r\n"),   pOptItem->UserData);
    VERBOSE(TEXT("\tpName           = %s\r\n"),     pOptItem->pName ? pOptItem->pName : TEXT("<NULL>"));
    VERBOSE(TEXT("\tpSel            = 0x%p\r\n"),   pOptItem->pSel);
    VERBOSE(TEXT("\tpExtChkBox      = 0x%p\r\n"),   pOptItem->pExtChkBox);
    VERBOSE(TEXT("\tpExtChkBox      = 0x%p\r\n"),   pOptItem->pExtChkBox);
    VERBOSE(TEXT("\tHelpIndex       = 0x%x\r\n"),   pOptItem->HelpIndex);
    VERBOSE(TEXT("\tDMPubID         = 0x%x\r\n"),   pOptItem->DMPubID);
    VERBOSE(TEXT("\tUserItemID      = 0x%x\r\n"),   pOptItem->UserItemID);
    VERBOSE(TEXT("\twReserved       = 0x%x\r\n"),   pOptItem->wReserved);
    VERBOSE(TEXT("\tpOIExt          = 0x%p\r\n"),   pOptItem->pOIExt);

    Dump(pOptItem->pOptType);
}

void Dump(POPTTYPE pOptType)
{
    VERBOSE(TEXT("\tpOptType:\r\n"));
    if(NULL == pOptType)
    {
        VERBOSE(TEXT("\t\tpOptType is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\t\tcbSize    = %d\r\n"),     pOptType->cbSize);
    VERBOSE(TEXT("\t\tType      = 0x%x\r\n"),   pOptType->Type);
    VERBOSE(TEXT("\t\tFlags     = 0x%x\r\n"),   pOptType->Flags);
    VERBOSE(TEXT("\t\tCount     = %d\r\n"),     pOptType->Count);
    VERBOSE(TEXT("\t\tCount     = 0x%x\r\n"),   pOptType->BegCtrlID);
    VERBOSE(TEXT("\t\tStyle     = 0x%x\r\n"),   pOptType->Style);

    Dump(pOptType->pOptParam, pOptType->Count);
}

void Dump(POPTPARAM pOptParam, WORD wCount)
{
    if(NULL == pOptParam)
    {
        VERBOSE(TEXT("\t\tpOptParam is NULL!\r\n"));
        return;
    }

    for(WORD wIndex = 0; wIndex < wCount; ++wIndex)
    {
        VERBOSE(TEXT("\t\tpOptParam[wIndex]:\r\n"));
        VERBOSE(TEXT("\t\t\tcbSize    = %d\r\n"),     pOptParam[wIndex].cbSize);
        VERBOSE(TEXT("\t\t\tFlags     = 0x%x\r\n"),   pOptParam[wIndex].Flags);
        VERBOSE(TEXT("\t\t\tStyle     = 0x%x\r\n"),   pOptParam[wIndex].Style);
        VERBOSE(TEXT("\t\t\tpData     = 0x%p\r\n"),   pOptParam[wIndex].pData);
        VERBOSE(TEXT("\t\t\tIconID    = 0x%p\r\n"),   pOptParam[wIndex].IconID);
        VERBOSE(TEXT("\t\t\tlParam    = 0x%p\r\n"),   pOptParam[wIndex].lParam);
    }
}


PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by OEMUI.rc
//
#define IDS_SECTION                     1
#define IDS_CALIBRATED                  2
#define IDS_NAME                        3
#define IDS_DEV_SECTION                 4
#define IDS_DEVICE_SECTION              4
#define IDS_ADV_SECTION                 10
#define IDD_DEVICE_PROPPAGE             106
#define IDD_DOC_PROPPAGE                107
#define IDC_CALIBRATE                   1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\intrface.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Intrface.cpp
//    
//
//  PURPOSE:  Implementation of interface for PScript4, PScript5, Unidrv4, 
//            Unidrv5 UI plug-ins.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//


#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "oemui.h"
#include "debug.h"
#include "intrface.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>


////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks



////////////////////////////////////////////////////////////////////////////////
//
// IOemUI body
//
IOemUI::~IOemUI()
{
    // Make sure that helper interface is released.
    if(NULL != m_pOEMHelp)
    {
        m_pOEMHelp->Release();
        m_pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == m_cRef);
}

HRESULT __stdcall IOemUI::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE(DLLTEXT("IOemUI:QueryInterface entry.\r\n\r\n")); 
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE(DLLTEXT("IOemUI:Return pointer to IUnknown.\r\n\r\n")); 
    }
    else if (iid == IID_IPrintOemUI)
    {
        *ppv = static_cast<IPrintOemUI*>(this) ;
        VERBOSE(DLLTEXT("IOemUI:Return pointer to IPrintOemUI.\r\n")); 
    }
    else
    {
#if DBG
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        VERBOSE(DLLTEXT("IOemUI::QueryInterface %s not supported.\r\n"), szOutput); 
#endif

        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemUI::AddRef()
{
    VERBOSE(DLLTEXT("IOemUI:AddRef entry.\r\n")); 
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemUI::Release() 
{
   VERBOSE(DLLTEXT("IOemUI:Release entry.\r\n")); 
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}

HRESULT __stdcall IOemUI::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IOemUI:PublishDriverInterface entry.\r\n")); 

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (m_pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUI, (void** ) &(m_pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            m_pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}

HRESULT __stdcall IOemUI::GetInfo(
    DWORD  dwMode,
    PVOID  pBuffer,
    DWORD  cbSize,
    PDWORD pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemUI::GetInfo(%d) entry.\r\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        WARNING(DLLTEXT("IOemUI::GetInfo() exit pcbNeeded is NULL! ERROR_INVALID_PARAMETER\r\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size and number of bytes written.
    *pcbNeeded = sizeof(DWORD);

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        WARNING(DLLTEXT("IOemUI::GetInfo() exit insufficient buffer!\r\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = OEM_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = OEM_VERSION;
            break;

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            WARNING(DLLTEXT("IOemUI::GetInfo() exit mode not supported.\r\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IOemUI::GetInfo() exit S_OK, (*pBuffer is %#x).\r\r\n"), *(PDWORD)pBuffer);
    return S_OK;
}

HRESULT __stdcall IOemUI::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IOemUI:DevMode(%d, %#x) entry.\r\n"), dwMode, pOemDMParam); 

    return hrOEMDevMode(dwMode, pOemDMParam);
}

HRESULT __stdcall IOemUI::CommonUIProp(
    DWORD  dwMode,
    POEMCUIPPARAM   pOemCUIPParam)
{
    VERBOSE(DLLTEXT("IOemUI:CommonUIProp entry.\r\n")); 

    return hrOEMPropertyPage(dwMode, pOemCUIPParam);
}


HRESULT __stdcall IOemUI::DocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DocumentPropertySheets entry.\r\n")); 

    return hrOEMDocumentPropertySheets(pPSUIInfo, lParam, m_pOEMHelp);
}

HRESULT __stdcall IOemUI::DevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DevicePropertySheets entry.\r\n")); 

    return hrOEMDevicePropertySheets(pPSUIInfo, lParam);
}

HRESULT __stdcall IOemUI::DeviceCapabilities(
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult)
{
    VERBOSE(DLLTEXT("IOemUI:DeviceCapabilities entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::DevQueryPrintEx(
    POEMUIOBJ               poemuiobj,
    PDEVQUERYPRINT_INFO     pDQPInfo,
    PDEVMODE                pPublicDM,
    PVOID                   pOEMDM)
{
    VERBOSE(DLLTEXT("IOemUI:DevQueryPrintEx entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::UpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo)
{
    VERBOSE(DLLTEXT("IOemUI:UpgradePrinter entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::PrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI:PrinterEvent entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::DriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DriverEvent entry.\r\n"));

    return E_NOTIMPL;
};


#define PROFILE_NAME    L"OEMPROFILE.icm\0"

HRESULT __stdcall IOemUI::QueryColorProfile(
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulQueryMode,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData)
{
    HRESULT Result = E_FAIL;


    VERBOSE(DLLTEXT("IOemUI:QueryColorProfile entry.\r\n"));


    if(QCP_DEVICEPROFILE == ulQueryMode)
    {
        if(NULL == pvProfileData)
        {
            *pcbProfileData = sizeof(PROFILE_NAME);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
            if(*pcbProfileData < sizeof(PROFILE_NAME))
            {
                *pcbProfileData = sizeof(PROFILE_NAME);
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
            }
            else
            {
                Result = StringCbCopy((LPWSTR)pvProfileData, *pcbProfileData, PROFILE_NAME);
                *pcbProfileData = sizeof(PROFILE_NAME);
                *pflProfileData = QCP_PROFILEDISK;

                if(FAILED(Result))
                {
                    SetLastError(Result);
                }
            }
        }
    }

    return Result;
};

HRESULT __stdcall IOemUI::FontInstallerDlgProc(
        HWND    hWnd,
        UINT    usMsg,
        WPARAM  wParam,
        LPARAM  lParam) 
{
    VERBOSE(DLLTEXT("IOemUI:FontInstallerDlgProc entry.\r\n"));

    return E_NOTIMPL;
};

HRESULT __stdcall IOemUI::UpdateExternalFonts(
        HANDLE  hPrinter,
        HANDLE  hHeap,
        PWSTR   pwstrCartridges)
{
    VERBOSE(DLLTEXT("IOemUI:UpdateExternalFonts entry.\r\n"));

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
#if DBG && defined(USERMODE_DRIVER)
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        VERBOSE(DLLTEXT("IOemCF::QueryInterface %s not supported.\r\n"), szOutput); 
#endif

        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemUI* pOemCB = new IOemUI ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }
    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Exported functions
//


// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    //
    // To avoid leaving OEM DLL still in memory when Unidrv or Pscript drivers 
    // are unloaded, Unidrv and Pscript driver ignore the return value of 
    // DllCanUnloadNow of the OEM DLL, and always call FreeLibrary on the OEMDLL.
    //
    // If OEM DLL spins off a working thread that also uses the OEM DLL, the 
    // thread needs to call LoadLibrary and FreeLibraryAndExitThread, otherwise 
    // it may crash after Unidrv or Pscript calls FreeLibrary.
    //

    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:Create class factory.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMUI)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _DEBUG_H
#define _DEBUG_H



// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif


// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
#include <WINDDI.H>
#include <WINSPOOL.H>
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRSHT.H>
#include "COMPSTUI.H"
#include <WINDDIUI.H>
#include <PRINTOEM.H>

// Define from ntdef.h in Win2K SDK.
// NT 4 may not have this defined
// in the public headers.
#ifndef NOP_FUNCTION
  #if (_MSC_VER >= 1210)
    #define NOP_FUNCTION __noop
  #else
    #define NOP_FUNCTION (void)0
  #endif
#endif


#define COUNTOF(p)  (sizeof(p)/sizeof(*(p)))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\oemui.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	OEMUI.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for OEMUI Test Module.
//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _OEMUI_H
#define _OEMUI_H

#include <PRCOMOEM.H>

#include "OEM.H"
#include "DEVMODE.H"
#include "globals.h"


////////////////////////////////////////////////////////
//      OEM UI Defines
////////////////////////////////////////////////////////


// OEM Signature and version.
#define PROP_TITLE      L"OEM UI Page"
#define DLLTEXT(s)      TEXT("UI:  ") TEXT(s)

// OEM UI Misc defines.
#define ERRORTEXT(s)    TEXT("ERROR ") DLLTEXT(s)


// Printer registry keys where OEM data is stored.
#define OEMUI_VALUE             TEXT("OEMUI_VALUE")
#define OEMUI_DEVICE_VALUE      TEXT("OEMUI_DEVICE_VALUE")



////////////////////////////////////////////////////////
//      Prototypes
////////////////////////////////////////////////////////

HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, IPrintOemDriverUI*  pOEMHelp);
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\oemui.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    OEMUI.cpp
//    
//
//  PURPOSE:  Main file for OEM UI test module.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "resource.h"
#include "debug.h"
#include "oemui.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>


////////////////////////////////////////////////////////
//      INTERNAL MACROS and DEFINES
////////////////////////////////////////////////////////

typedef struct _tagCBUserData 
{
    HANDLE          hComPropSheet;
    HANDLE          hPropPage;
    POEMUIPSPARAM   pOEMUIParam;
    PFNCOMPROPSHEET pfnComPropSheet;

} CBUSERDATA, *PCBUSERDATA;



////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUICallBack2(PCPSUICBPARAM pCallbackParam);
INT_PTR CALLBACK DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
static POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems);
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems);
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams);
static PTSTR GetStringResource(HANDLE hHeap, HANDLE hModule, UINT uResource);



////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM device or document property UI.
//
HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    HRESULT hResult = S_OK;


    VERBOSE(DLLTEXT("hrOEMPropertyPage(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (OEMCUIP_DOCPROP != dwMode)
        &&
        (OEMCUIP_PRNPROP != dwMode)        
      )
    {
        ERR(ERRORTEXT("hrOEMPropertyPage() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOEMUIParam = %#lx.\r\n"), dwMode, pOEMUIParam);

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        case OEMCUIP_DOCPROP:
            hResult = hrDocumentPropertyPage(dwMode, pOEMUIParam);
            break;

        case OEMCUIP_PRNPROP:
            hResult = hrPrinterPropertyPage(dwMode, pOEMUIParam);
            break;

        default:
            // Should never reach this!
            ERR(ERRORTEXT("hrOEMPropertyPage() Invalid dwMode, %d"), dwMode);
            SetLastError(ERROR_INVALID_PARAMETER);
            hResult = E_FAIL;
            break;
    }

    return hResult;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM document property UI.
//
static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM document property UI.
        pOEMUIParam->cOEMOptItems = 1;

        VERBOSE(DLLTEXT("hrDocumentPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
        POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


        VERBOSE(DLLTEXT("hrDocumentPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMDocUICallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // New section.
        pOEMUIParam->pOEMOptItems[0].Level = 1;
        pOEMUIParam->pOEMOptItems[0].Flags = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].pName = GetStringResource(pOEMUIParam->hOEMHeap, pOEMUIParam->hModule, IDS_ADV_SECTION);
        pOEMUIParam->pOEMOptItems[0].Sel = pOEMDev->dwAdvancedData;

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

        pOEMUIParam->pOEMOptItems[0].pOptType->Type = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam = 100;
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM printer property UI.
//
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM printer property UI.
        pOEMUIParam->cOEMOptItems = 1;

        VERBOSE(DLLTEXT("hrPrinterPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
        DWORD   dwError;
        DWORD   dwDeviceValue;
        DWORD   dwType;
        DWORD   dwNeeded;


        VERBOSE(DLLTEXT("hrPrinterPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Get device settings value from printer.
        dwError = GetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, &dwType, (PBYTE) &dwDeviceValue,
                                   sizeof(dwDeviceValue), &dwNeeded);
        if( (ERROR_SUCCESS != dwError)
            ||
            (dwDeviceValue > 100)
          )
        {
            // Failed to get the device value or value is invalid, just use the default.
            dwDeviceValue = 0;
        }

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMPrinterUICallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // New section.
        pOEMUIParam->pOEMOptItems[0].Level = 1;
        pOEMUIParam->pOEMOptItems[0].Flags = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].pName = GetStringResource(pOEMUIParam->hOEMHeap, pOEMUIParam->hModule, IDS_DEV_SECTION);
        pOEMUIParam->pOEMOptItems[0].Sel = dwDeviceValue;

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

        pOEMUIParam->pOEMOptItems[0].pOptType->Type = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam = 100;
    }

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to Document property sheet.
//
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, 
                                    IPrintOemDriverUI*  pOEMHelp)
{
    LONG_PTR    lResult;


    VERBOSE(DLLTEXT("OEMDocumentPropertySheets() entry.\r\n"));

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("OEMDocumentPropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return  E_FAIL;
    }

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                DWORD           dwSheets        = 0;
                PCBUSERDATA     pUserData       = NULL;
                POEMUIPSPARAM   pOEMUIParam     = (POEMUIPSPARAM) pPSUIInfo->lParamInit;
                HANDLE          hHeap           = pOEMUIParam->hOEMHeap;
                POEMDEV         pOEMDev         = (POEMDEV) pOEMUIParam->pOEMDM;
                COMPROPSHEETUI  Sheet;


                // Init property page.
                memset(&Sheet, 0, sizeof(COMPROPSHEETUI));
                Sheet.cbSize            = sizeof(COMPROPSHEETUI);
                Sheet.Flags             = CPSUIF_UPDATE_PERMISSION;
                Sheet.hInstCaller       = ghInstance;
                Sheet.pCallerName       = GetStringResource(hHeap, ghInstance, IDS_NAME);
                Sheet.pHelpFile         = NULL;
                Sheet.pfnCallBack       = OEMDocUICallBack2;
                Sheet.pDlgPage          = CPSUI_PDLGPAGE_TREEVIEWONLY;
                Sheet.cOptItem          = 1;
                Sheet.IconID            = IDI_CPSUI_PRINTER;
                Sheet.pOptItemName      = GetStringResource(hHeap, ghInstance, IDS_SECTION);
                Sheet.CallerVersion     = 0x100;
                Sheet.OptItemVersion    = 0x100;

                // Init user data.
                pUserData = (PCBUSERDATA) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(CBUSERDATA));
                pUserData->hComPropSheet    = pPSUIInfo->hComPropSheet;
                pUserData->pfnComPropSheet  = pPSUIInfo->pfnComPropSheet;
                pUserData->pOEMUIParam      = pOEMUIParam;
                Sheet.UserData              = (ULONG_PTR) pUserData;

                // Create OptItems for page.
                Sheet.pOptItem = CreateOptItems(hHeap, Sheet.cOptItem);

                // Initialize OptItems
                Sheet.pOptItem[0].Level = 1;
                Sheet.pOptItem[0].Flags = OPTIF_COLLAPSE;
                Sheet.pOptItem[0].pName = GetStringResource(hHeap, ghInstance, IDS_SECTION);
                Sheet.pOptItem[0].Sel   = pOEMDev->dwDriverData;

                Sheet.pOptItem[0].pOptType = CreateOptType(hHeap, 2);

                Sheet.pOptItem[0].pOptType->Type                = TVOT_UDARROW;
                Sheet.pOptItem[0].pOptType->pOptParam[1].IconID = 0;
                Sheet.pOptItem[0].pOptType->pOptParam[1].lParam = 100;


                // Add property sheets.
                lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PCOMPROPSHEETUI, 
                                                     (LPARAM)&Sheet, (LPARAM)&dwSheets);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }

    pPSUIInfo->Result = lResult;
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to printer property sheet.
//
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam)
{
    LONG_PTR    lResult;


    VERBOSE(DLLTEXT("hrOEMDevicePropertySheets(%#x, %#x) entry\r\n"), pPSUIInfo, lParam);

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("hrOEMDevicePropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    Dump(pPSUIInfo);

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                PROPSHEETPAGE   Page;

                // Init property page.
                memset(&Page, 0, sizeof(PROPSHEETPAGE));
                Page.dwSize = sizeof(PROPSHEETPAGE);
                Page.dwFlags = PSP_DEFAULT;
                Page.hInstance = ghInstance;
                Page.pszTemplate = MAKEINTRESOURCE(IDD_DEVICE_PROPPAGE);
                Page.pfnDlgProc = DevicePropPageProc;

                // Add property sheets.
                lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PROPSHEETPAGE, (LPARAM)&Page, 0);

                VERBOSE(DLLTEXT("hrOEMDevicePropertySheets() pfnComPropSheet returned %d.\r\n"), lResult);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }

    pPSUIInfo->Result = lResult;
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM printer property UI.
//
LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMPrinterUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            {
                DWORD   dwDriverValue = pOEMUIParam->pOEMOptItems[0].Sel;

                // Store OptItems state in printer data.
                SetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, REG_DWORD, (PBYTE) &dwDriverValue, sizeof(DWORD));
            }
            break;

        default:
            break;
    }

    return lReturn;
}


////////////////////////////////////////////////////////////////////////////////
//
// Call back for OEM device property UI.
//
INT_PTR CALLBACK DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg)
    {
        case WM_COMMAND:
            switch(HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch(LOWORD(wParam))
                    {
                        case IDC_CALIBRATE:
                            // Just display a message that the printer is calibrated,
                            // since we don't acutally calibrate anything.
                            {
                                TCHAR   szName[MAX_PATH];
                                TCHAR   szCalibrated[MAX_PATH];


                                LoadString(ghInstance, IDS_NAME, szName, sizeof(szName)/sizeof(szName[0]));
                                LoadString(ghInstance, IDS_CALIBRATED, szCalibrated, sizeof(szCalibrated)/sizeof(szCalibrated[0]));
                                MessageBox(hDlg, szCalibrated, szName, MB_OK);
                            }
                            break;
                    }
                    break;

                default:
                    return FALSE;
            }
            return TRUE;

        case WM_NOTIFY:
            {
                switch (((LPNMHDR)lParam)->code)  // type of notification message
                {
                    case PSN_SETACTIVE:
                        break;
    
                    case PSN_KILLACTIVE:
                        break;

                    case PSN_APPLY:
                        break;

                    case PSN_RESET:
                        break;
                }
            }
            break;
    }

    return FALSE;
} 


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM document property UI.
//
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            // Update UI item data.
            pOEMDev->dwAdvancedData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

        case CPSUICB_REASON_KILLACTIVE:
            // Update devmode if settings have changed.
            if(pOEMDev->dwAdvancedData != pOEMUIParam->pOEMOptItems[0].Sel)
            {
                // Update OEM Devmode driver data.
                pOEMDev->dwAdvancedData = pOEMUIParam->pOEMOptItems[0].Sel;
            }
            break;

        case CPSUICB_REASON_SETACTIVE:
            if(pOEMUIParam->pOEMOptItems[0].Sel != pOEMDev->dwAdvancedData)
            {
                pOEMUIParam->pOEMOptItems[0].Sel = pOEMDev->dwAdvancedData;
                pOEMUIParam->pOEMOptItems[0].Flags |= OPTIF_CHANGED;
                lReturn = CPSUICB_ACTION_OPTIF_CHANGED;
            }
            break;

        default:
            break;
    }

    return lReturn;
}


LONG APIENTRY OEMDocUICallBack2(PCPSUICBPARAM pCallbackParam)
{
    LONG            lReturn = CPSUICB_ACTION_NONE;
    PCBUSERDATA     pUserData = (PCBUSERDATA) pCallbackParam->UserData;
    POEMDEV         pOEMDev = (POEMDEV) pUserData->pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUICallBack2() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            // Update OEM devmode driver data.
            pOEMDev->dwDriverData = pCallbackParam->pOptItem[0].Sel;
            pUserData->pfnComPropSheet(pUserData->hComPropSheet, CPSFUNC_SET_RESULT,
            	                    (LPARAM)pUserData->hPropPage,
               	                    (LPARAM)CPSUI_OK);
            break;

        case CPSUICB_REASON_KILLACTIVE:
            if(pOEMDev->dwDriverData != pCallbackParam->pOptItem[0].Sel)
            {
                // Update OEM devmode driver data.
                pOEMDev->dwDriverData = pCallbackParam->pOptItem[0].Sel;
            }
            break;

        case CPSUICB_REASON_SETACTIVE:
            if(pCallbackParam->pOptItem[0].Sel != pOEMDev->dwDriverData)
            {
                pCallbackParam->pOptItem[0].Sel = pOEMDev->dwDriverData;
                pCallbackParam->pOptItem[0].Flags |= OPTIF_CHANGED;
                lReturn = CPSUICB_ACTION_OPTIF_CHANGED;
            }
            break;

        default:
            break;
    }

    return lReturn;
}


////////////////////////////////////////////////////////////////////////////////
//
// Creates and Initializes OptItems.
//
static POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems)
{
    POPTITEM    pOptItems = NULL;


    // Allocate memory for OptItems;
    pOptItems = (POPTITEM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTITEM) * dwOptItems);
    if(NULL != pOptItems)
    {
        InitOptItems(pOptItems, dwOptItems);
    }
    else
    {
        ERR(ERRORTEXT("CreateOptItems() failed to allocate memory for OPTITEMs!\r\n"));
    }

    return pOptItems;
}


////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems.
//
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems)
{
    VERBOSE(DLLTEXT("InitOptItems() entry.\r\n"));

    // Zero out memory.
    memset(pOptItems, 0, sizeof(OPTITEM) * dwOptItems);

    // Set each OptItem's size, and Public DM ID.
    for(DWORD dwCount = 0; dwCount < dwOptItems; dwCount++)
    {
        pOptItems[dwCount].cbSize = sizeof(OPTITEM);
        pOptItems[dwCount].DMPubID = DMPUB_NONE;
    }
}


////////////////////////////////////////////////////////////////////////////////
//
// Allocates and initializes OptType for OptItem.
//
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams)
{
    POPTTYPE    pOptType = NULL;


    VERBOSE(DLLTEXT("CreateOptType() entry.\r\n"));

    // Allocate memory from the heap for the OPTTYPE; the driver will take care of clean up.
    pOptType = (POPTTYPE) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTTYPE));
    if(NULL != pOptType)
    {
        // Initialize OPTTYPE.
        pOptType->cbSize = sizeof(OPTTYPE);
        pOptType->Count = wOptParams;

        // Allocate memory from the heap for the OPTPARAMs for the OPTTYPE.
        pOptType->pOptParam = (POPTPARAM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, wOptParams * sizeof(OPTPARAM));
        if(NULL != pOptType->pOptParam)
        {
            // Initialize the OPTPARAMs.
            for(WORD wCount = 0; wCount < wOptParams; wCount++)
            {
                pOptType->pOptParam[wCount].cbSize = sizeof(OPTPARAM);
            }
        }
        else
        {
            ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTPARAMs!\r\n"));

            // Free allocated memory and return NULL.
            HeapFree(hHeap, 0, pOptType);
            pOptType = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTTYPE!\r\n"));
    }

    return pOptType;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Retrieves pointer to a String resource.
//
static PTSTR GetStringResource(HANDLE hHeap, HANDLE hModule, UINT uResource)
{
    int     nResult;
    DWORD   dwSize = MAX_PATH;
    PTSTR   pszString = NULL;


    VERBOSE(DLLTEXT("GetStringResource(%#x, %#x, %d) entered.\r\n"), hHeap, hModule, uResource);

    // Allocate buffer for string resource from heap; let the driver clean it up.
    pszString = (PTSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize * sizeof(TCHAR));
    if(NULL != pszString)
    {
        // Load string resource; resize after loading so as not to waste memory.
        nResult = LoadString((HMODULE)hModule, uResource, pszString, dwSize);
        if(nResult > 0)
        {
            PTSTR   pszTemp;


            VERBOSE(DLLTEXT("LoadString() returned %d!\r\n"), nResult);
            VERBOSE(DLLTEXT("String load was \"%s\".\r\n"), pszString);

            pszTemp = (PTSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, pszString, (nResult + 1) * sizeof(TCHAR));
            if(NULL != pszTemp)
            {
                pszString = pszTemp;
            }
            else
            {
                ERR(ERRORTEXT("GetStringResource() HeapReAlloc() of string retrieved failed! (Last Error was %d)\r\n"), GetLastError());
            }
        }
        else
        {
            ERR(ERRORTEXT("LoadString() returned %d! (Last Error was %d)\r\n"), nResult, GetLastError());
            ERR(ERRORTEXT("GetStringResource() failed to load string resource %d!\r\n"), uResource);

            pszString = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("GetStringResource() failed to allocate string buffer!\r\n"));
    }

    return pszString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\ddihook.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	 DDIHook.cpp
//    
//
//  PURPOSE:  DDI Hook routines for User Mode COM Customization DLL.
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "debug.h"
#include "oemuni.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



//
// OEMBitBlt
//

BOOL APIENTRY
OEMBitBlt(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMBitBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoTrg->dhpdev;

    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvBitBlt)(poempdev->pfnUnidrv[UD_DrvBitBlt])) (
           psoTrg,
           psoSrc,
           psoMask,
           pco,
           pxlo,
           prclTrg,
           pptlSrc,
           pptlMask,
           pbo,
           pptlBrush,
           rop4));

}

//
// OEMStretchBlt
//

BOOL APIENTRY
OEMStretchBlt(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStretchBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;


    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStretchBlt)(poempdev->pfnUnidrv[UD_DrvStretchBlt])) (
            psoDest,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDest,
            prclSrc,
            pptlMask,
            iMode));

}

//
// OEMCopyBits
//

BOOL APIENTRY
OEMCopyBits(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDest,
    POINTL         *pptlSrc
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMCopyBits() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvCopyBits)(poempdev->pfnUnidrv[UD_DrvCopyBits])) (
            psoDest,
            psoSrc,
            pco,
            pxlo,
            prclDest,
            pptlSrc));

}

//
// OEMTextOut
//

BOOL APIENTRY
OEMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMTextOut() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvTextOut)(poempdev->pfnUnidrv[UD_DrvTextOut])) (
            pso,
            pstro,
            pfo,
            pco,
            prclExtra,
            prclOpaque,
            pboFore,
            pboOpaque,
            pptlOrg,
            mix));

}

//
// OEMStrokePath
//

BOOL APIENTRY
OEMStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStokePath() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStrokePath)(poempdev->pfnUnidrv[UD_DrvStrokePath])) (
            pso,
            ppo,
            pco,
            pxo,
            pbo,
            pptlBrushOrg,
            plineattrs,
            mix));

}

//
// OEMFillPath
//

BOOL APIENTRY
OEMFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMFillPath() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvFillPath)(poempdev->pfnUnidrv[UD_DrvFillPath])) (
            pso,
            ppo,
            pco,
            pbo,
            pptlBrushOrg,
            mix,
            flOptions));

}

//
// OEMStrokeAndFillPath
//

BOOL APIENTRY
OEMStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStrokeAndFillPath() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStrokeAndFillPath)(poempdev->pfnUnidrv[UD_DrvStrokeAndFillPath])) (
            pso,
            ppo,
            pco,
            pxo,
            pboStroke,
            plineattrs,
            pboFill,
            pptlBrushOrg,
            mixFill,
            flOptions));

}

//
// OEMRealizeBrush
//

BOOL APIENTRY
OEMRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMRealizeBrush() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoTarget->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // the OEM DLL should NOT hook out this function unless it wants to draw
    // graphics directly to the device surface. In that case, it calls
    // EngRealizeBrush which causes GDI to call DrvRealizeBrush.
    // Note that it cannot call back into Unidrv since Unidrv doesn't hook it.
    //

    //
    // In this test DLL, the drawing hooks does not call EngRealizeBrush. So this
    // this function will never be called. Do nothing.
    //

    return TRUE;
}

//
// OEMStartPage
//

BOOL APIENTRY
OEMStartPage(
    SURFOBJ    *pso
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStartPage() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStartPage)(poempdev->pfnUnidrv[UD_DrvStartPage]))(pso));

}

#define OEM_TESTSTRING  "The DDICMDCB DLL adds this line of text."

//
// OEMSendPage
//

BOOL APIENTRY
OEMSendPage(
    SURFOBJ    *pso
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMSendPage() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // print a line of text, just for testing
    //
    if (pso->iType == STYPE_BITMAP)
    {
        pdevobj->pDrvProcs->DrvXMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvYMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj, OEM_TESTSTRING,
                                             sizeof(OEM_TESTSTRING));
    }

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvSendPage)(poempdev->pfnUnidrv[UD_DrvSendPage]))(pso));

}

//
// OEMEscape
//

ULONG APIENTRY
OEMEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMEscape() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvEscape)(poempdev->pfnUnidrv[UD_DrvEscape])) (
            pso,
            iEsc,
            cjIn,
            pvIn,
            cjOut,
            pvOut));

}

//
// OEMStartDoc
//

BOOL APIENTRY
OEMStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStartDoc() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStartDoc)(poempdev->pfnUnidrv[UD_DrvStartDoc])) (
            pso,
            pwszDocName,
            dwJobId));

}

//
// OEMEndDoc
//

BOOL APIENTRY
OEMEndDoc(
    SURFOBJ    *pso,
    FLONG       fl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMEndDoc() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvEndDoc)(poempdev->pfnUnidrv[UD_DrvEndDoc])) (
            pso,
            fl));

}

////////
// NOTE:
// OEM DLL needs to hook out the following six font related DDI calls only
// if it enumerates additional fonts beyond what's in the GPD file.
// And if it does, it needs to take care of its own fonts for all font DDI
// calls and DrvTextOut call.
///////

//
// OEMQueryFont
//

PIFIMETRICS APIENTRY
OEMQueryFont(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG_PTR  *pid
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMQueryFont() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvQueryFont)(poempdev->pfnUnidrv[UD_DrvQueryFont])) (
            dhpdev,
            iFile,
            iFace,
            pid));

}

//
// OEMQueryFontTree
//

PVOID APIENTRY
OEMQueryFontTree(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG_PTR  *pid
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMQueryFontTree() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvQueryFontTree)(poempdev->pfnUnidrv[UD_DrvQueryFontTree])) (
            dhpdev,
            iFile,
            iFace,
            iMode,
            pid));

}

//
// OEMQueryFontData
//

LONG APIENTRY
OEMQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMQueryFontData() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvQueryFontData)(poempdev->pfnUnidrv[UD_DrvQueryFontData])) (
            dhpdev,
            pfo,
            iMode,
            hg,
            pgd,
            pv,
            cjSize));

}

//
// OEMQueryAdvanceWidths
//

BOOL APIENTRY
OEMQueryAdvanceWidths(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMQueryAdvanceWidths() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvQueryAdvanceWidths)
             (poempdev->pfnUnidrv[UD_DrvQueryAdvanceWidths])) (
                   dhpdev,
                   pfo,
                   iMode,
                   phg,
                   pvWidths,
                   cGlyphs));

}

//
// OEMFontManagement
//

ULONG APIENTRY
OEMFontManagement(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMFontManagement() entry.\r\n"));

    //
    // Note that Unidrv will not call OEM DLL for iMode==QUERYESCSUPPORT.
    // So pso is not NULL for sure.
    //
    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvFontManagement)(poempdev->pfnUnidrv[UD_DrvFontManagement])) (
            pso,
            pfo,
            iMode,
            cjIn,
            pvIn,
            cjOut,
            pvOut));

}

//
// OEMGetGlyphMode
//

ULONG APIENTRY
OEMGetGlyphMode(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMGetGlyphMode() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvGetGlyphMode)(poempdev->pfnUnidrv[UD_DrvGetGlyphMode])) (
            dhpdev,
            pfo));

}

BOOL APIENTRY
OEMNextBand(
    SURFOBJ *pso,
    POINTL *pptl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMNextBand() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvNextBand)(poempdev->pfnUnidrv[UD_DrvNextBand])) (
            pso,
            pptl));

}

BOOL APIENTRY
OEMStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStartBanding() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStartBanding)(poempdev->pfnUnidrv[UD_DrvStartBanding])) (
            pso,
            pptl));


}

ULONG APIENTRY
OEMDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMDitherColor() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvDitherColor)(poempdev->pfnUnidrv[UD_DrvDitherColor])) (
            dhpdev,
            iMode,
            rgbColor,
            pulDither));

}

BOOL APIENTRY
OEMPaint(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMPaint() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvPaint)(poempdev->pfnUnidrv[UD_DrvPaint])) (
            pso,
            pco,
            pbo,
            pptlBrushOrg,
            mix));

}

BOOL APIENTRY
OEMLineTo(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMLineTo() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvLineTo)(poempdev->pfnUnidrv[UD_DrvLineTo])) (
            pso,
            pco,
            pbo,
            x1,
            y1,
            x2,
            y2,
            prclBounds,
            mix));

}


//
// OEMStretchBltROP
//

BOOL APIENTRY
OEMStretchBltROP(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStretchBltROP() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStretchBltROP)(poempdev->pfnUnidrv[UD_DrvStretchBltROP])) (
            psoDest,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDest,
            prclSrc,
            pptlMask,
            iMode,
            pbo,
            rop4
            ));


}

//
// OEMPlgBlt
//

BOOL APIENTRY
OEMPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMPlgBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvPlgBlt)(poempdev->pfnUnidrv[UD_DrvPlgBlt])) (
            psoDst,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlBrushOrg,
            pptfixDest,
            prclSrc,
            pptlMask,
            iMode));

}

//
// OEMAlphaBlend
//

BOOL APIENTRY
OEMAlphaBlend(
    SURFOBJ    *psoDest,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDest,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMAlphaBlend() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvAlphaBlend)(poempdev->pfnUnidrv[UD_DrvAlphaBlend])) (
            psoDest,
            psoSrc,
            pco,
            pxlo,
            prclDest,
            prclSrc,
            pBlendObj
            ));

}

//
// OEMGradientFill
//

BOOL APIENTRY
OEMGradientFill(
        SURFOBJ    *psoDest,
        CLIPOBJ    *pco,
        XLATEOBJ   *pxlo,
        TRIVERTEX  *pVertex,
        ULONG       nVertex,
        PVOID       pMesh,
        ULONG       nMesh,
        RECTL      *prclExtents,
        POINTL     *pptlDitherOrg,
        ULONG       ulMode
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMGradientFill() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvGradientFill)(poempdev->pfnUnidrv[UD_DrvGradientFill])) (
            psoDest,
            pco,
            pxlo,
            pVertex,
            nVertex,
            pMesh,
            nMesh,
            prclExtents,
            pptlDitherOrg,
            ulMode
            ));

}

BOOL APIENTRY
OEMTransparentBlt(
        SURFOBJ    *psoDst,
        SURFOBJ    *psoSrc,
        CLIPOBJ    *pco,
        XLATEOBJ   *pxlo,
        RECTL      *prclDst,
        RECTL      *prclSrc,
        ULONG      iTransColor,
        ULONG      ulReserved
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMTransparentBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvTransparentBlt)(poempdev->pfnUnidrv[UD_DrvTransparentBlt])) (
            psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            prclSrc,
            iTransColor,
            ulReserved
            ));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\intrface.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Intrface.cpp
//    
//
//  PURPOSE:  Header of interface for PScript4, PScript5, Unidrv4, 
//            Unidrv5 UI plug-ins.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//


////////////////////////////////////////////////////////////////////////////////
//
// IOemUI
//
class IOemUI: public IPrintOemUI
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD  dwMode, PVOID  pBuffer, DWORD  cbSize,
                           PDWORD pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_  DWORD  dwMode, POEMDMPARAM pOemDMParam) ;

    //
    // OEMCommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_  
            DWORD  dwMode, 
            POEMCUIPPARAM   pOemCUIPParam
            );

    //
    // OEMDocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );

    //
    // OEMDevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );


    //
    // OEMDevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            );

    //
    // OEMDeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            );

    //
    // OEMUpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            );

    //
    // OEMPrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            );

    //
    // OEMDriverEvent
    //

    STDMETHOD(DriverEvent)(THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            );
 
    //
    // OEMQueryColorProfile
    //

    STDMETHOD( QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData);

    //
    // OEMFontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_ 
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            );
    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
            );


    IOemUI() { m_cRef = 1; m_pOEMHelp = NULL; };
    ~IOemUI();

protected:
    LONG                m_cRef;
    IPrintOemDriverUI*  m_pOEMHelp;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\devmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Devmode.cpp
//    
//
//  PURPOSE:  Implementation of Devmode functions shared with OEM UI and OEM rendering modules.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oemuni.h"
#include "debug.h"
#include "devmode.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>


HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam)
{
    POEMDEV pOEMDevIn;
    POEMDEV pOEMDevOut;


    // Verify parameters.
    if( (NULL == pOemDMParam)
        ||
        ( (OEMDM_SIZE != dwMode)
          &&
          (OEMDM_DEFAULT != dwMode)
          &&
          (OEMDM_CONVERT != dwMode)
          &&
          (OEMDM_MERGE != dwMode)
        )
      )
    {
        VERBOSE(ERRORTEXT("DevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOemDMParam = %#lx.\r\n"), dwMode, pOemDMParam);

        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Cast generic (i.e. PVOID) to OEM private devomode pointer type.
    pOEMDevIn = (POEMDEV) pOemDMParam->pOEMDMIn;
    pOEMDevOut = (POEMDEV) pOemDMParam->pOEMDMOut;

    switch(dwMode)
    {
        case OEMDM_SIZE:
            pOemDMParam->cbBufSize = sizeof(OEMDEV);
            break;

        case OEMDM_DEFAULT:
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
            pOEMDevOut->dwDriverData            = 0;
            VERBOSE(DLLTEXT("pOEMDevOut after setting default values:\r\n"));
            Dump(pOEMDevOut);
            break;

        case OEMDM_CONVERT:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            break;

        case OEMDM_MERGE:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            MakeOEMDevmodeValid(pOEMDevOut);
            break;
    }
    Dump(pOemDMParam);

    return S_OK;
}


BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut)
{
    if( (NULL == pOEMDevIn)
        ||
        (NULL == pOEMDevOut)
      )
    {
        VERBOSE(ERRORTEXT("ConvertOEMDevmode() invalid parameters.\r\n"));
        return FALSE;
    }

    // Check OEM Signature, if it doesn't match ours,
    // then just assume DMIn is bad and use defaults.
    if(pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature)
    {
        VERBOSE(DLLTEXT("Converting private OEM Devmode.\r\n"));
        VERBOSE(DLLTEXT("pOEMDevIn:\r\n"));
        Dump(pOEMDevIn);

        // Set the devmode defaults so that anything the isn't copied over will
        // be set to the default value.
        pOEMDevOut->dwDriverData = 0;

        // Copy the old structure in to the new using which ever size is the smaller.
        // Devmode maybe from newer Devmode (not likely since there is only one), or
        // Devmode maybe a newer Devmode, in which case it maybe larger,
        // but the first part of the structure should be the same.

        // DESIGN ASSUMPTION: the private DEVMODE structure only gets added to;
        // the fields that are in the DEVMODE never change only new fields get added to the end.

        memcpy(pOEMDevOut, pOEMDevIn, __min(pOEMDevOut->dmOEMExtra.dwSize, pOEMDevIn->dmOEMExtra.dwSize));

        // Re-fill in the size and version fields to indicated 
        // that the DEVMODE is the current private DEVMODE version.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
    }
    else
    {
        VERBOSE(DLLTEXT("Unknown DEVMODE signature, pOEMDMIn ignored.\r\n"));

        // Don't know what the input DEVMODE is, so just use defaults.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
        pOEMDevOut->dwDriverData            = 0;
    }

    return TRUE;
}


BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode)
{
    if(NULL == pOEMDevmode)
    {
        return FALSE;
    }

    // ASSUMPTION: pOEMDevmode is large enough to contain OEMDEV structure.

    // Make sure that dmOEMExtra indicates the current OEMDEV structure.
    pOEMDevmode->dmOEMExtra.dwSize       = sizeof(OEMDEV);
    pOEMDevmode->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
    pOEMDevmode->dmOEMExtra.dwVersion    = OEM_VERSION;

    // Set driver data.
    pOEMDevmode->dwDriverData = 0;

    return TRUE;
}


void Dump(PCOEMDEV pOEMDevmode)
{
    if( (NULL != pOEMDevmode)
        &&
        (pOEMDevmode->dmOEMExtra.dwSize >= sizeof(OEMDEV))
        &&
        (OEM_SIGNATURE == pOEMDevmode->dmOEMExtra.dwSignature)
      )
    {
        VERBOSE(TEXT("\tdmOEMExtra.dwSize      = %d\r\n"), pOEMDevmode->dmOEMExtra.dwSize);
        VERBOSE(TEXT("\tdmOEMExtra.dwSignature = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwSignature);
        VERBOSE(TEXT("\tdmOEMExtra.dwVersion   = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwVersion);
        VERBOSE(TEXT("\tdwDriverData           = %#x\r\n"), pOEMDevmode->dwDriverData);
    }
    else
    {
        VERBOSE(ERRORTEXT("Dump(POEMDEV) unknown private OEM DEVMODE.\r\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'
#define MAX_LOOP                10


// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize      = DEBUG_BUFFER_SIZE;
    DWORD   dwLoop      = 0;
    LPSTR   lpszMsgBuf  = NULL;
    HRESULT hr;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
        {
            return FALSE;
        }

        hr = StringCbVPrintfA(lpszMsgBuf, (dwSize + 1) * sizeof(CHAR), lpszMessage, arglist);

    // Pass the variable parameters to wvsprintf to be formated.
    } while (FAILED(hr) && (STRSAFE_E_INSUFFICIENT_BUFFER == hr) && (++dwLoop < MAX_LOOP) );

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return SUCCEEDED(hr);
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR      lpszMsgBuf;
    HRESULT     hResult;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    hResult = StringCbVPrintfW(lpszMsgBuf, (dwSize + 1) * sizeof(WCHAR), lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return SUCCEEDED(hResult);
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(TEXT("pPublisherInfo:\r\n"));
    VERBOSE(TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(TEXT("pOemDMParam:\r\n"));
    VERBOSE(TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}



PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\devmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Devmode.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for devmode functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _DEVMODE_H
#define _DEVMODE_H


////////////////////////////////////////////////////////
//      OEM Devmode Defines
////////////////////////////////////////////////////////




////////////////////////////////////////////////////////
//      OEM Devmode Type Definitions
////////////////////////////////////////////////////////

typedef struct tagOEMDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    BOOL                dwDriverData;

} OEMDEV, *POEMDEV;

typedef const OEMDEV *PCOEMDEV;



/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam);
BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut);
BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode);
void Dump(PCOEMDEV pOEMDevIn);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\intrface.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Intrface.H
//    
//
//  PURPOSE:	Define COM interface for User Mode Printer Customization DLL.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _INTERFACE_H
#define _INTERFACE_H




////////////////////////////////////////////////////////////////////////////////
//
//  IOemUni
//
//  Interface for Unidrv OEM sample rendering module
//
class IOemUni : public IPrintOemUni
{
public:
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    
    IOemUni() { m_cRef = 1; m_pOEMHelp = NULL; };
    ~IOemUni();

protected:
    LONG                m_cRef;
    IPrintOemDriverUni* m_pOEMHelp;
};





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oemuni.h"
#include "debug.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//

// DllMain isn't called/used for kernel mode version.
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}





}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\enable.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Enable.cpp
//    
//
//  PURPOSE:  Enable routines for User Mode COM Customization DLL.
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "debug.h"
#include "oemuni.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      Internal Constants
////////////////////////////////////////////////////////

///////////////////////////////////////////////////////
// Warning: the following array order must match the 
//          order in enum ENUMHOOKS.
///////////////////////////////////////////////////////
static const DRVFN OEMHookFuncs[] =
{
    { INDEX_DrvRealizeBrush,        (PFN) OEMRealizeBrush        },
    { INDEX_DrvDitherColor,         (PFN) OEMDitherColor         },
    { INDEX_DrvCopyBits,            (PFN) OEMCopyBits            },
    { INDEX_DrvBitBlt,              (PFN) OEMBitBlt              },
    { INDEX_DrvStretchBlt,          (PFN) OEMStretchBlt          },
    { INDEX_DrvTextOut,             (PFN) OEMTextOut             },
    { INDEX_DrvStrokePath,          (PFN) OEMStrokePath          },
    { INDEX_DrvFillPath,            (PFN) OEMFillPath            },
    { INDEX_DrvStrokeAndFillPath,   (PFN) OEMStrokeAndFillPath   },
    { INDEX_DrvPaint,               (PFN) OEMPaint               },
    { INDEX_DrvLineTo,              (PFN) OEMLineTo              },
    { INDEX_DrvStartPage,           (PFN) OEMStartPage           },
    { INDEX_DrvSendPage,            (PFN) OEMSendPage            },
    { INDEX_DrvEscape,              (PFN) OEMEscape              },
    { INDEX_DrvStartDoc,            (PFN) OEMStartDoc            },
    { INDEX_DrvEndDoc,              (PFN) OEMEndDoc              },
    { INDEX_DrvNextBand,            (PFN) OEMNextBand            },
    { INDEX_DrvStartBanding,        (PFN) OEMStartBanding        },
    { INDEX_DrvQueryFont,           (PFN) OEMQueryFont           },
    { INDEX_DrvQueryFontTree,       (PFN) OEMQueryFontTree       },
    { INDEX_DrvQueryFontData,       (PFN) OEMQueryFontData       },
    { INDEX_DrvQueryAdvanceWidths,  (PFN) OEMQueryAdvanceWidths  },
    { INDEX_DrvFontManagement,      (PFN) OEMFontManagement      },
    { INDEX_DrvGetGlyphMode,        (PFN) OEMGetGlyphMode        },
    { INDEX_DrvStretchBltROP,       (PFN) OEMStretchBltROP       },
    { INDEX_DrvPlgBlt,              (PFN) OEMPlgBlt              },
    { INDEX_DrvTransparentBlt,      (PFN) OEMTransparentBlt      },
    { INDEX_DrvAlphaBlend,          (PFN) OEMAlphaBlend          },
    { INDEX_DrvGradientFill,        (PFN) OEMGradientFill        },
};







PDEVOEM APIENTRY OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded        // Unidrv's hook table
    )
{
    POEMPDEV    poempdev;
    INT         i, j;
    DWORD       dwDDIIndex;
    PDRVFN      pdrvfn;

    VERBOSE(DLLTEXT("OEMEnablePDEV() entry.\r\n"));

    //
    // Allocate the OEMDev
    //
    poempdev = new OEMPDEV;
    if (NULL == poempdev)
    {
        return NULL;
    }

    //
    // Fill in OEMDEV as you need
    //

    //
    // Fill in OEMDEV
    //

    for (i = 0; i < MAX_DDI_HOOKS; i++)
    {
        //
        // search through Unidrv's hooks and locate the function ptr
        //
        dwDDIIndex = OEMHookFuncs[i].iFunc;
        for (j = pded->c, pdrvfn = pded->pdrvfn; j > 0; j--, pdrvfn++)
        {
            if (dwDDIIndex == pdrvfn->iFunc)
            {
                poempdev->pfnUnidrv[i] = pdrvfn->pfn;
                break;
            }
        }
        if (j == 0)
        {
            //
            // didn't find the Unidrv hook. Should happen only with DrvRealizeBrush
            //
            poempdev->pfnUnidrv[i] = NULL;
        }

    }

    return (POEMPDEV) poempdev;
}


VOID APIENTRY OEMDisablePDEV(
    PDEVOBJ pdevobj
    )
{
    VERBOSE(DLLTEXT("OEMDisablePDEV() entry.\r\n"));


    //
    // Free memory for OEMPDEV and any memory block that hangs off OEMPDEV.
    //
    assert(NULL != pdevobj->pdevOEM);
    delete pdevobj->pdevOEM;
}


BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    )
{
    VERBOSE(DLLTEXT("OEMResetPDEV() entry.\r\n"));


    //
    // If you want to carry over anything from old pdev to new pdev, do it here.
    //

    return TRUE;
}


VOID APIENTRY OEMDisableDriver()
{
    VERBOSE(DLLTEXT("OEMDisableDriver() entry.\r\n"));
}


BOOL APIENTRY OEMEnableDriver(DWORD dwOEMintfVersion, DWORD dwSize, PDRVENABLEDATA pded)
{
    VERBOSE(DLLTEXT("OEMEnableDriver() entry.\r\n"));

    // List DDI functions that are hooked.
    pded->iDriverVersion =  PRINTER_OEMINTF_VERSION;
    pded->c = sizeof(OEMHookFuncs) / sizeof(DRVFN);
    pded->pdrvfn = (DRVFN *) OEMHookFuncs;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\name.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Name.H
//    
//
//  PURPOSE:	Define string literals for interface funcion names.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _NAME_H
#define _NAME_H


/////////////////////////////////////////////////////////
//		String Leterals
/////////////////////////////////////////////////////////


CONST CHAR NAME_CommandCallback[]           = "CommandCallback";
CONST CHAR NAME_Compression[]               = "Compression";
CONST CHAR NAME_DownloadCharGlyph[]         = "DownloadCharGlyph";
CONST CHAR NAME_DownloadFontHeader[]        = "DownloadFontHeader";
CONST CHAR NAME_FilterGraphics[]            = "FilterGraphics";
CONST CHAR NAME_HalftonePattern[]           = "HalftonePattern";
CONST CHAR NAME_ImageProcessing[]           = "ImageProcessing";
CONST CHAR NAME_MemoryUsage[]               = "MemoryUsage";
CONST CHAR NAME_OutputCharStr[]             = "OutputCharStr";
CONST CHAR NAME_SendFontCmd[]               = "SendFontCmd";
CONST CHAR NAME_TextOutAsBitmap[]           = "TextOutAsBitmap";
CONST CHAR NAME_TTDownloadMethod[]          = "TTDownloadMethod";
CONST CHAR NAME_TTYGetInfo[]                = "TTYGetInfo";
CONST CHAR NAME_WritePrinter[]              = "WritePrinter";





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\intrface.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Intrface.cpp
//    
//
//  PURPOSE:  Interface for User Mode COM Customization DLL.
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "oemuni.h"
#include "debug.h"
#include "intrface.h"
#include "name.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>


////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents = 0;     // Count of active components
static long g_cServerLocks = 0;    // Count of locks






////////////////////////////////////////////////////////////////////////////////
//
// IOemUni body
//
IOemUni::~IOemUni()
{
    // Make sure that helper interface is released.
    if(NULL != m_pOEMHelp)
    {
        m_pOEMHelp->Release();
        m_pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == m_cRef);
}


HRESULT __stdcall IOemUni::QueryInterface(const IID& iid, void** ppv)
{    
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE(DLLTEXT("IOemUni::QueryInterface IUnknown.\r\n")); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE(DLLTEXT("IOemUni::QueryInterface IPrintOemUni.\r\n")); 
    }
    else
    {
        *ppv = NULL;
#if DBG && defined(USERMODE_DRIVER)
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        VERBOSE(DLLTEXT("IOemUni::QueryInterface %s not supported.\r\n"), szOutput); 
#endif
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

ULONG __stdcall IOemUni::AddRef()
{
    VERBOSE(DLLTEXT("IOemUni::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemUni::Release() 
{
   VERBOSE(DLLTEXT("IOemUni::Release() entry.\r\n"));
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}


HRESULT __stdcall IOemUni::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemUni::GetInfo(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        WARNING(DLLTEXT("IOemUni::GetInfo() exit pcbNeeded is NULL! ERROR_INVALID_PARAMETER.\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size.
    if(OEMGI_GETPUBLISHERINFO != dwMode)
    {
        *pcbNeeded = sizeof(DWORD);
    }
    else
    {
        *pcbNeeded = sizeof(PUBLISHERINFO);
        return E_FAIL;
    }

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        VERBOSE(DLLTEXT("IOemUni::GetInfo() exit insufficient buffer!\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = OEM_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = OEM_VERSION;
            break;

        case OEMGI_GETPUBLISHERINFO:
            Dump((PPUBLISHERINFO)pBuffer);
            // Fall through to default case.

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            WARNING(DLLTEXT("IOemUni::GetInfo() exit mode not supported.\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IOemUni::GetInfo() exit S_OK, (*pBuffer is %#x).\r\n"), *(PDWORD)pBuffer);

    return S_OK;
}

HRESULT __stdcall IOemUni::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IOemUni::PublishDriverInterface() entry.\r\n"));

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->m_pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** ) &(this->m_pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->m_pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}


HRESULT __stdcall IOemUni::EnableDriver(
    DWORD          dwDriverVersion,
    DWORD          cbSize,
    PDRVENABLEDATA pded)
{
    VERBOSE(DLLTEXT("IOemUni::EnableDriver() entry.\r\n"));

    OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Even if nothing is done, need to return S_OK so 
    // that DisableDriver() will be called, which releases
    // the reference to the Printer Driver's interface.
    // If error occurs, return E_FAIL.
    return S_OK;
}

HRESULT __stdcall IOemUni::DisableDriver(VOID)
{
    VERBOSE(DLLTEXT("IOemUni::DisaleDriver() entry.\r\n"));

    OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->m_pOEMHelp)
    {
        this->m_pOEMHelp->Release();
        this->m_pOEMHelp = NULL;
    }

    return S_OK;
}

HRESULT __stdcall IOemUni::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    VERBOSE(DLLTEXT("IOemUni::DisablePDEV() entry.\r\n"));

    OEMDisablePDEV(pdevobj);

    return S_OK;
};

HRESULT __stdcall IOemUni::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE(DLLTEXT("IOemUni::EnablePDEV() entry.\r\n"));

    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns,  phsurfPatterns,
                             cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);

    return (NULL != *pDevOem ? S_OK : E_FAIL);
}


HRESULT __stdcall IOemUni::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    BOOL    bResult;


    VERBOSE(DLLTEXT("IOemUni::ResetPDEV() entry.\r\n"));


    bResult = OEMResetPDEV(pdevobjOld, pdevobjNew);

    return (bResult ? S_OK : E_FAIL);
}


HRESULT __stdcall IOemUni::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IOemUni:DevMode(%d, %#x) entry.\n"), dwMode, pOemDMParam); 
    return hrOEMDevMode(dwMode, pOemDMParam);
}

HRESULT __stdcall IOemUni::GetImplementedMethod(PSTR pMethodName)
{
    HRESULT Result = S_FALSE;


    VERBOSE(DLLTEXT("IOemUni::GetImplementedMethod() entry.\r\n"));
    VERBOSE(DLLTEXT("        Function:%hs:"),pMethodName);

    // Unidrv only calls GetImplementedMethod for optional
    // methods.  The required methods are assumed to be
    // supported.

    // Return S_OK for supported function (i.e. implemented),
    // and S_FALSE for functions that aren't supported (i.e. not implemented).
    switch (*pMethodName)
    {
        case 'C':
            if (!strcmp(NAME_CommandCallback, pMethodName))
            {
                Result = S_OK;
            }
            else if (!strcmp(NAME_Compression, pMethodName))
            {
                Result = S_FALSE;
            }
            break;

        case 'D':
            if (!strcmp(NAME_DownloadFontHeader, pMethodName))
            {
                Result = S_FALSE;
            }
            else if (!strcmp(NAME_DownloadCharGlyph, pMethodName))
            {
                Result = S_FALSE;
            }
            break;

        case 'F':
            if (!strcmp(NAME_FilterGraphics, pMethodName))
            {
                Result = S_OK;
            }
            break;

        case 'H':
            if (!strcmp(NAME_HalftonePattern, pMethodName))
            {
                Result = S_FALSE;
            }
            break;

        case 'I':
            if (!strcmp(NAME_ImageProcessing, pMethodName))
            {
                Result = S_OK;
            }
            break;

        case 'M':
            if (!strcmp(NAME_MemoryUsage, pMethodName))
            {
                Result = S_FALSE;
            }
            break;

        case 'O':
            if (!strcmp(NAME_OutputCharStr, pMethodName))
            {
                Result = S_FALSE;
            }
            break;

        case 'S':
            if (!strcmp(NAME_SendFontCmd, pMethodName))
            {
                Result = S_FALSE;
            }
            break;

        case 'T':
            if (!strcmp(NAME_TextOutAsBitmap, pMethodName))
            {
                Result = S_FALSE;
            }
            else if (!strcmp(NAME_TTDownloadMethod, pMethodName))
            {
                Result = S_FALSE;
            }
            else if (!strcmp(NAME_TTYGetInfo, pMethodName))
            {
                Result = S_FALSE;
            }
            break;

        case 'W':
            if(!strcmp(NAME_WritePrinter, pMethodName))
            {
                Result = S_FALSE;
            }
            break;
    }

    VERBOSE( Result == S_OK ? TEXT("Supported\r\n") : TEXT("NOT supported\r\n"));

    return Result;
}

HRESULT __stdcall IOemUni::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    VERBOSE(DLLTEXT("IOemUni::CommandCallback() entry.\r\n"));
    VERBOSE(DLLTEXT("        dwCallbackID = %d\r\n"), dwCallbackID);
    VERBOSE(DLLTEXT("        dwCount      = %d\r\n"), dwCount);

    *piResult = 0;

    return S_OK;
}

HRESULT __stdcall IOemUni::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE(DLLTEXT("IOemUni::ImageProcessing() entry.\r\n"));

    return S_OK;
}

HRESULT __stdcall IOemUni::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    DWORD dwResult;
    VERBOSE(DLLTEXT("IOemUni::FilterGraphis() entry.\r\n"));
    m_pOEMHelp->DrvWriteSpoolBuf(pdevobj, pBuf, dwLen, &dwResult);
    
    if (dwResult == dwLen)
        return S_OK;
    else
        return E_FAIL;
}

HRESULT __stdcall IOemUni::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE(DLLTEXT("IOemUni::Compression() entry.\r\n"));

    // When implemented, the return from GetImplementedMethod
    // for this method name must be S_OK.

    return E_NOTIMPL;
}


HRESULT __stdcall IOemUni::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE(DLLTEXT("IOemUni::HalftonePattern() entry.\r\n"));

    // When implemented, the return from GetImplementedMethod
    // for this method name must be S_OK.

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUni::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE(DLLTEXT("IOemUni::MemoryUsage() entry.\r\n"));

    // When implemented, the return from GetImplementedMethod
    // for this method name must be S_OK.

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUni::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE(DLLTEXT("IOemUni::DownloadFontHeader() entry.\r\n"));

    // When implemented, the return from GetImplementedMethod
    // for this method name must be S_OK.

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUni::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE(DLLTEXT("IOemUni::DownloadCharGlyph() entry.\r\n"));

    // When implemented, the return from GetImplementedMethod
    // for this method name must be S_OK.

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUni::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE(DLLTEXT("IOemUni::TTDownloadMethod() entry.\r\n"));

    // When implemented, the return from GetImplementedMethod
    // for this method name must be S_OK.

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUni::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE(DLLTEXT("IOemUni::OutputCharStr() entry.\r\n"));

    // When implemented, the return from GetImplementedMethod
    // for this method name must be S_OK.

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUni::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE(DLLTEXT("IOemUni::SendFontCmd() entry.\r\n"));

    // When implemented, the return from GetImplementedMethod
    // for this method name must be S_OK.

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUni::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemUni::DriverDMS() entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUni::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *NAME_o,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE(DLLTEXT("IOemUni::TextOutAsBitmap() entry.\r\n"));

    // When implemented, the return from GetImplementedMethod
    // for this method name must be S_OK.

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUni::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE(DLLTEXT("IOemUni::TTYGetInfo() entry.\r\n"));

    // When implemented, the return from GetImplementedMethod
    // for this method name must be S_OK.

    return E_NOTIMPL;
}


////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);
   
    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{    
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this); 
    }
    else
    {
        *ppv = NULL;
#if DBG && defined(USERMODE_DRIVER)
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        VERBOSE(DLLTEXT("IOemCF::QueryInterface %s not supported.\r\n"), szOutput); 
#endif
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release() 
{
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv) 
{
    //VERBOSE(DLLTEXT("Class factory:\t\tCreate component."));

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION;
    }

    // Create component.
    IOemUni* pOemCP = new IOemUni;
    if (pOemCP == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Get the requested interface.
    HRESULT hr = pOemCP->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCP->Release();
    return hr;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock) 
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks); 
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK;
}


//
// Registration functions
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    //
    // To avoid leaving OEM DLL still in memory when Unidrv or Pscript drivers 
    // are unloaded, Unidrv and Pscript driver ignore the return value of 
    // DllCanUnloadNow of the OEM DLL, and always call FreeLibrary on the OEMDLL.
    //
    // If OEM DLL spins off a working thread that also uses the OEM DLL, the 
    // thread needs to call LoadLibrary and FreeLibraryAndExitThread, otherwise 
    // it may crash after Unidrv or Pscript calls FreeLibrary.
    //

    VERBOSE(DLLTEXT("DllCanUnloadNow entered.\r\n"));

    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:\tCreate class factory.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _DEBUG_H
#define _DEBUG_H


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);
void Dump(PPROPSHEETUI_INFO pPSUIInfo);
void Dump(POPTITEM pOptItem);
void Dump(POPTTYPE pOptType);
void Dump(POPTPARAM pOptParam, WORD wCount);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif



// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
extern "C" 
{
    #include <WINDDI.H>
}
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRINTOEM.H>


#define COUNTOF(p)  (sizeof(p)/sizeof(*(p)))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\oemuni.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	OEMUNI.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _OEMUNI_H
#define _OEMUNI_H

#include "OEM.H"
#include "DEVMODE.H"


////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define DLLTEXT(s)      TEXT("OEMUNI:  ") TEXT(s)
#define ERRORTEXT(s)    TEXT("ERROR ") DLLTEXT(s)


///////////////////////////////////////////////////////
// Warning: the following enum order must match the 
//          order in OEMHookFuncs[].
///////////////////////////////////////////////////////
typedef enum tag_Hooks {
    UD_DrvRealizeBrush,
    UD_DrvDitherColor,
    UD_DrvCopyBits,
    UD_DrvBitBlt,
    UD_DrvStretchBlt,
    UD_DrvTextOut,
    UD_DrvStrokePath,
    UD_DrvFillPath,
    UD_DrvStrokeAndFillPath,
    UD_DrvPaint,
    UD_DrvLineTo,
    UD_DrvStartPage,
    UD_DrvSendPage,
    UD_DrvEscape,
    UD_DrvStartDoc,
    UD_DrvEndDoc,
    UD_DrvNextBand,
    UD_DrvStartBanding,
    UD_DrvQueryFont,
    UD_DrvQueryFontTree,
    UD_DrvQueryFontData,
    UD_DrvQueryAdvanceWidths,
    UD_DrvFontManagement,
    UD_DrvGetGlyphMode,
    UD_DrvStretchBltROP,
    UD_DrvPlgBlt,
    UD_DrvTransparentBlt,
    UD_DrvAlphaBlend,
    UD_DrvGradientFill,

    MAX_DDI_HOOKS,

} ENUMHOOKS;


typedef struct _OEMPDEV {
    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    // This test DLL hooks out every drawing DDI. So it needs to remember
    // Unidrv's hook function pointer so it call back.
    //
    PFN     pfnUnidrv[MAX_DDI_HOOKS];

    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    DWORD     dwReserved[1];

} OEMPDEV, *POEMPDEV;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OEMUNI.rc
//


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\globals.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Globals.h
//    
//
//  PURPOSE:   Lists of globals declared in Globals.cpp.
//
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _GLOBALS_H
#define _GLOBALS_H


///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
extern HINSTANCE   ghInstance;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\devmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Devmode.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for devmode functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _DEVMODE_H
#define _DEVMODE_H

#include "precomp.h"


////////////////////////////////////////////////////////
//      OEM Devmode Defines
////////////////////////////////////////////////////////




////////////////////////////////////////////////////////
//      OEM Devmode Type Definitions
////////////////////////////////////////////////////////

//
//Can add info to the private devmode bellow here.
//Note :
//		This structure must be prefixed by OEM_DMEXTRAHEADER
//		Your plug-in must implement the IPrintOemUI::DevMode method
//
typedef struct tagOEMDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    DWORD               dwDriverData;
    DWORD               dwAdvancedData;

	//
	//Private DevMode Members
	//

} OEMDEV, *POEMDEV;

typedef const OEMDEV *PCOEMDEV;



/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam);
BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut, DWORD dwSize);
BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode);
void Dump(PCOEMDEV pOEMDevIn);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\globals.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Globals.cpp
//    
//
//  PURPOSE:  File that contains all the globals.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//
#define _GLOBALS_H

#include "precomp.h"
#include "oemui.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
HINSTANCE   ghInstance = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\features.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  2001 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Features.cpp
//    
//
//  PURPOSE:  Implementation wrapper class for WinXP PS Driver Features and Options.
//
//
//
//  PLATFORMS:    Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "debug.h"
#include "oemui.h"
#include "stringutils.h"
#include "features.h"
#include "resource.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      Internal Defines and Macros
////////////////////////////////////////////////////////

#define INITIAL_ENUM_FEATURES_SIZE          1024
#define INITIAL_ENUM_OPTIONS_SIZE           64
#define INITIAL_FEATURE_DISPLAY_NAME_SIZE   64
#define INITIAL_OPTION_DISPLAY_NAME_SIZE    32
#define INITIAL_GET_OPTION_SIZE             64
#define INITIAL_GET_REASON_SIZE             1024

#define DRIVER_FEATURE_PREFIX               '%'
#define IS_DRIVER_FEATURE(f)                (DRIVER_FEATURE_PREFIX == (f)[0])

// Flags that the uDisplayNameID should be returned as 
// MAKEINTRESOURCE() instead of loading the string resource.
#define RETURN_INT_RESOURCE     1

// Macros to test for conditions of KEYWORDMAP entry.
#define IS_MAPPING_INT_RESOURCE(p)  ((p)->dwFlags & RETURN_INT_RESOURCE)

// TAG the identifies feature OPTITEM data stuct.
#define FEATURE_OPTITEM_TAG     'FETR'


////////////////////////////////////////////////////////
//      Type Definitions
////////////////////////////////////////////////////////

// Struct used to identify OPTITEM as 
// feature OPTITEM and to map back from
// an OPTITEM to the feature.
typedef struct _tagFeatureOptitemData
{
    DWORD       dwSize;
    DWORD       dwTag;
    PCSTR       pszFeatureKeyword;
    COptions    *pOptions;

} FEATUREOPTITEMDATA, *PFEATUREOPTITEMDATA;



////////////////////////////////////////////////////////
//      Internal Constants
////////////////////////////////////////////////////////

static KEYWORDMAP gkmFeatureMap[] =
{
    "%AddEuro",                 NULL,                   IDS_ADD_EURO,           OEMCUIP_PRNPROP,    0,
    "%CtrlDAfter",              NULL,                   IDS_CTRLD_AFTER,        OEMCUIP_PRNPROP,    0,
    "%CtrlDBefore",             NULL,                   IDS_CTRLD_BEFORE,       OEMCUIP_PRNPROP,    0,
    //"%CustomPageSize",          NULL,                   IDS_PSCRIPT_CUSTOMSIZE, OEMCUIP_DOCPROP,    0,
    "%GraphicsTrueGray",        NULL,                   IDS_TRUE_GRAY_GRAPH,    OEMCUIP_PRNPROP,    0,
    "%JobTimeout",              NULL,                   IDS_JOBTIMEOUT,         OEMCUIP_PRNPROP,    0,
    "%MaxFontSizeAsBitmap",     NULL,                   IDS_PSMAXBITMAP,        OEMCUIP_PRNPROP,    0,
    "%MetafileSpooling",        NULL,                   IDS_METAFILE_SPOOLING,  OEMCUIP_DOCPROP,    0,
    "%MinFontSizeAsOutline",    NULL,                   IDS_PSMINOUTLINE,       OEMCUIP_PRNPROP,    0,
    "%Mirroring",               NULL,                   IDS_MIRROR,             OEMCUIP_DOCPROP,    0,
    "%Negative",                NULL,                   IDS_NEGATIVE_PRINT,     OEMCUIP_DOCPROP,    0,
    "%Orientation",             TEXT("COMPSTUI.DLL"),   IDS_CPSUI_ORIENTATION,  OEMCUIP_DOCPROP,    RETURN_INT_RESOURCE,
    "%OutputFormat",            NULL,                   IDS_PSOUTPUT_OPTION,    OEMCUIP_DOCPROP,    0,
    "%OutputProtocol",          NULL,                   IDS_PSPROTOCOL,         OEMCUIP_PRNPROP,    0,
    "%OutputPSLevel",           NULL,                   IDS_PSLEVEL,            OEMCUIP_DOCPROP,    0,
    "%PageOrder",               TEXT("COMPSTUI.DLL"),   IDS_CPSUI_PAGEORDER,    OEMCUIP_DOCPROP,    RETURN_INT_RESOURCE,
    "%PagePerSheet",            TEXT("COMPSTUI.DLL"),   IDS_CPSUI_NUP,          OEMCUIP_DOCPROP,    RETURN_INT_RESOURCE,
    "%PSErrorHandler",          NULL,                   IDS_PSERROR_HANDLER,    OEMCUIP_DOCPROP,    0,
    "%PSMemory",                NULL,                   IDS_POSTSCRIPT_VM,      OEMCUIP_PRNPROP,    0,
    "%TextTrueGray",            NULL,                   IDS_TRUE_GRAY_TEXT,     OEMCUIP_PRNPROP,    0,
    "%TTDownloadFormat",        NULL,                   IDS_PSTT_DLFORMAT,      OEMCUIP_DOCPROP,    0,
    "%WaitTimeout",             NULL,                   IDS_WAITTIMEOUT,        OEMCUIP_PRNPROP,    0,
};
static const NUM_FEATURE_MAP    = (sizeof(gkmFeatureMap)/sizeof(gkmFeatureMap[0]));


static KEYWORDMAP gkmOptionMap[] =
{
    "True",             TEXT("COMPSTUI.DLL"),       IDS_CPSUI_TRUE,             0,  RETURN_INT_RESOURCE,
    "False",            TEXT("COMPSTUI.DLL"),       IDS_CPSUI_FALSE,            0,  RETURN_INT_RESOURCE,
    "Portrait",         TEXT("COMPSTUI.DLL"),       IDS_CPSUI_PORTRAIT,         0,  RETURN_INT_RESOURCE,
    "Landscape",        TEXT("COMPSTUI.DLL"),       IDS_CPSUI_LANDSCAPE,        0,  RETURN_INT_RESOURCE,
    "RotatedLandscape", TEXT("COMPSTUI.DLL"),       IDS_CPSUI_ROT_LAND,         0,  RETURN_INT_RESOURCE,
    "Speed",            NULL,                       IDS_PSOPT_SPEED,            0,  RETURN_INT_RESOURCE,
    "Portability",      NULL,                       IDS_PSOPT_PORTABILITY,      0,  0,
    "EPS",              NULL,                       IDS_PSOPT_EPS,              0,  0,
    "Archive",          NULL,                       IDS_PSOPT_ARCHIVE,          0,  0,
    "ASCII",            NULL,                       IDS_PSPROTOCOL_ASCII,       0,  0,
    "BCP",              NULL,                       IDS_PSPROTOCOL_BCP,         0,  0,
    "TBCP",             NULL,                       IDS_PSPROTOCOL_TBCP,        0,  0,
    "Binary",           NULL,                       IDS_PSPROTOCOL_BINARY,      0,  0,
    "FrontToBack",      TEXT("COMPSTUI.DLL"),       IDS_CPSUI_FRONTTOBACK,      0,  RETURN_INT_RESOURCE,
    "BackToFront",      TEXT("COMPSTUI.DLL"),       IDS_CPSUI_BACKTOFRONT,      0,  RETURN_INT_RESOURCE,
    "1",                TEXT("COMPSTUI.DLL"),       IDS_CPSUI_NUP_NORMAL,       0,  RETURN_INT_RESOURCE,
    "2",                TEXT("COMPSTUI.DLL"),       IDS_CPSUI_NUP_TWOUP,        0,  RETURN_INT_RESOURCE,
    "4",                TEXT("COMPSTUI.DLL"),       IDS_CPSUI_NUP_FOURUP,       0,  RETURN_INT_RESOURCE,
    "6",                TEXT("COMPSTUI.DLL"),       IDS_CPSUI_NUP_SIXUP,        0,  RETURN_INT_RESOURCE,
    "9",                TEXT("COMPSTUI.DLL"),       IDS_CPSUI_NUP_NINEUP,       0,  RETURN_INT_RESOURCE,
    "16",               TEXT("COMPSTUI.DLL"),       IDS_CPSUI_NUP_SIXTEENUP,    0,  RETURN_INT_RESOURCE,
    "Booklet",          TEXT("COMPSTUI.DLL"),       IDS_CPSUI_BOOKLET,          0,  RETURN_INT_RESOURCE,
    "Automatic",        NULL,                       IDS_TTDL_DEFAULT,           0,  0,
    "Outline",          NULL,                       IDS_TTDL_TYPE1,             0,  0,
    "Bitmap",           NULL,                       IDS_TTDL_TYPE3,             0,  0,
    "NativeTrueType",   NULL,                       IDS_TTDL_TYPE42,            0,  0,
};
static const NUM_OPTION_MAP     = (sizeof(gkmOptionMap)/sizeof(gkmOptionMap[0]));




////////////////////////////////////////////
//
//  COptions Methods
//

//
//  Private Methods
// 

// Initializes class data members.
void COptions::Init()
{
    m_wOptions      = 0;
    m_cType         = TVOT_COMBOBOX;
    m_pmszRaw       = NULL;
    m_pszFeature    = NULL;
    m_ppszOptions   = NULL;
    m_ptRange.x     = 0;
    m_ptRange.y     = 0;
    m_dwSize        = 0;
    m_pszUnits      = NULL;
    m_hHeap         = NULL;
    m_pInfo         = NULL;
}

void COptions::Clear()
{
    // Free memory associated with data members.
    if(NULL != m_pmszRaw)       HeapFree(m_hHeap, 0, m_pmszRaw);
    if(NULL != m_ppszOptions)   HeapFree(m_hHeap, 0, m_ppszOptions);
    if( (NULL != m_pszUnits) && !IS_INTRESOURCE(m_pszUnits))    HeapFree(m_hHeap, 0, m_pszUnits);

    // Free option info.
    FreeOptionInfo();

    // Initialize data members.
    Init();
}

// Frees memory associated with Option Info array.
void COptions::FreeOptionInfo()
{
    // Validate parameters.
    if( (NULL == m_hHeap)
        ||
        (NULL == m_pInfo)
      )
    {
        return;
    }

    // Free strings in the array.
    for(WORD wIndex = 0; wIndex < m_wOptions; ++wIndex)
    {
        PWSTR   pszDisplay = m_pInfo[wIndex].pszDisplayName;

        if( (NULL != pszDisplay) 
            && 
            !(IS_INTRESOURCE(pszDisplay))
          ) 
        {
            HeapFree(m_hHeap, 0, pszDisplay);
        }
    }

    // Free the array.
    HeapFree(m_hHeap, 0, m_pInfo);
    m_pInfo = NULL;
}

// Will do init for features that need special handling.
HRESULT COptions::GetOptionsForSpecialFeatures(CUIHelper &Helper, POEMUIOBJ poemuiobj)
{
    HRESULT hrResult    = E_NOTIMPL;


    // See if this is a special feature.
    // If it is, then call the special option init for the
    // feature.
    if(!lstrcmpA(m_pszFeature, "%CustomPageSize"))
    {
        // There is no option init for CustomPageSize.
        // The item itself must be handled specially.
        hrResult = S_OK;
    }
    else if( !lstrcmpA(m_pszFeature, "%JobTimeout")
             ||
             !lstrcmpA(m_pszFeature, "%WaitTimeout")
           )
    {
        // JobTimeout and WaitTimeout feature options are string representations 
        // of an integer that represents number of seconds in the range 0 through 
        // 2,147,483,647 (i.e. LONG_MAX).  However, COMPSTUI limits us to
        // WORD size, which has range of 0 to 32,767 (i.e. SHRT_MAX).
        m_cType     = TVOT_UDARROW;
        m_ptRange.x = 0;
        m_ptRange.y = SHRT_MAX;
        hrResult    = GetOptionSelectionShort(Helper, poemuiobj);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("COptions::GetOptionsForSpecialFeatures() failed to get current selection for feature %hs. (hrResult = 0x%x)\r\n"), 
                m_pszFeature,
                hrResult);

            goto Exit;
        }
    }
    else if( !lstrcmpA(m_pszFeature, "%MaxFontSizeAsBitmap")
             ||
             !lstrcmpA(m_pszFeature, "%MinFontSizeAsOutline")
           )
    {
        // MaxFontSizeAsBitmap, and MinFontSizeAsOutline feature options 
        // are string representations of an integer that represents number 
        // of pixels in the range 0 through 32,767 (i.e. SHRT_MAX).
        m_cType     = TVOT_UDARROW;
        m_ptRange.x = 0;
        m_ptRange.y = SHRT_MAX;
        hrResult    = GetOptionSelectionShort(Helper, poemuiobj);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("COptions::GetOptionsForSpecialFeatures() failed to get current selection for feature %hs. (hrResult = 0x%x)\r\n"), 
                m_pszFeature,
                hrResult);

            goto Exit;
        }
    }
    else if( !lstrcmpA(m_pszFeature, "%PSMemory") )
    {
        DWORD   dwType;
        DWORD   dwLevel;
        DWORD   dwNeeded;


        // PSMemory option is string representation of an integer
        // that represents number of seconds in the range 0
        // through 32,767 (i.e. SHRT_MAX).
        // However, the minimum is 172 KB for Level 1 and 249 KB for level 2
        m_cType     = TVOT_UDARROW;
        m_ptRange.y = SHRT_MAX;
        hrResult    = GetOptionSelectionShort(Helper, poemuiobj);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("COptions::GetOptionsForSpecialFeatures() failed to get current selection for feature %hs. (hrResult = 0x%x)\r\n"), 
                m_pszFeature,
                hrResult);

            goto Exit;
        }

        // Get the global attribute for max language level.
        hrResult = Helper.GetGlobalAttribute(poemuiobj, 
                                             0, 
                                             "LanguageLevel", 
                                             &dwType, 
                                             (PBYTE) &dwLevel, 
                                             sizeof(dwLevel), 
                                             &dwNeeded);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("COptions::GetOptionsForSpecialFeatures() failed to get global attribute \"LanguageLevel\". (hrResult = 0x%x)\r\n"), 
                hrResult);

            goto Exit;
        }

        // Set minimum range based on PS Max Language level.
        switch(dwLevel)
        {
            case 1:
                m_ptRange.x     = 172;
                break;

            default:
            case 2:
            case 3:
                m_ptRange.x     = 249;
                break;
        }

        // Get Units string.
        //GetStringResource(m_pszUnits
    }
    else if(!lstrcmpA(m_pszFeature, "%OutputPSLevel"))
    {
        hrResult = GetOptionsForOutputPSLevel(Helper, poemuiobj);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("COptions::GetOptionsForSpecialFeatures() failed to get current selection for feature %hs. (hrResult = 0x%x)\r\n"), 
                m_pszFeature,
                hrResult);

            goto Exit;
        }
    }


Exit:

    return hrResult;
}

// Do init for PS Level options.
HRESULT COptions::GetOptionsForOutputPSLevel(CUIHelper &Helper, POEMUIOBJ poemuiobj)
{
    WORD    wCount      = 0;
    DWORD   dwLevel     = 0;
    DWORD   dwType      = -1;
    DWORD   dwNeeded    = 0;
    HRESULT hrResult    = E_NOTIMPL;


    // PS Level is integers from 1 to "LanguageLevel"
    // global atribute.
    m_cType = TVOT_COMBOBOX;

    // Get the global attribute for max language level.
    hrResult = Helper.GetGlobalAttribute(poemuiobj, 
                                         0, 
                                         "LanguageLevel", 
                                         &dwType, 
                                         (PBYTE) &dwLevel, 
                                         sizeof(dwLevel), 
                                         &dwNeeded);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("COptions::GetOptionsForOutputPSLevel() failed to get global attribute \"LanguageLevel\". (hrResult = 0x%x)\r\n"), 
            hrResult);

        goto Exit;
    }

    //
    // Create Options for PS Level
    //
    
    // Set the number of options to the PS Level supported.
    m_wOptions = (WORD) dwLevel;

    // Allocate keyword list.
    // Allocate memory for pointer to keyword and the keyword itself, so that
    // the memory for the keyword strings will get de-allocated with the keyword list
    // on object destruction, just like regular features for which EnumOptions works.
    // User the size of a pointer (4 bytes on x86, and 8 on IA64) so that
    // it begining of the keyword strings will be DWORD or QUADWORD aligned
    // for x86 and IA64 respectively.  Keyword strings aren't required to
    // be DWORD or QUADWORD aligned, but it is more optimal.  Also, this gives
    // some additional space for the case of %OutputPSLevel keywords, which are
    // in the range of 1 through the max PostScript level supported, and only
    // require 2 CHARs (1 for the digit and one for the NULL terminator).
    m_ppszOptions = (PCSTR *) HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY, m_wOptions * ( sizeof(PSTR) + sizeof(PCSTR *) ) );
    if(NULL == m_ppszOptions)
    {
        ERR(ERRORTEXT("COptions::GetOptionsForOutputPSLevel() failed to allocate option keyword array for PS Level.\r\n"));

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }


    // Allocate option info array.
    m_pInfo = (POPTION_INFO) HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY, m_wOptions * sizeof(OPTION_INFO));
    if(NULL == m_pInfo)
    {
        ERR(ERRORTEXT("COptions::GetOptionsForOutputPSLevel() failed to allocate info array for PS Level.\r\n"));

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // Init the option info.
    for(wCount = 0; wCount < m_wOptions; ++wCount)
    {
        // Init keyword.
        // The memory for both the keyword list and the keyword strings was allocated above.
        m_ppszOptions[wCount] = (PSTR)(m_ppszOptions + m_wOptions) + (sizeof(PSTR) * wCount);
        hrResult = StringCbPrintfA(const_cast<PSTR>(m_ppszOptions[wCount]), sizeof(PSTR), "%d", wCount + 1);
        if(FAILED(hrResult))
        {
            ERR(ERRORTEXT("COptions::GetOptionsForOutputPSLevel() failed to string representation of item %d.\r\n"), 
                          wCount + 1);

            goto Exit;
        }

        // Init option display name.
        m_pInfo[wCount].pszDisplayName = (PWSTR) HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY, 2 * sizeof(WCHAR));
        if(NULL == m_pInfo[wCount].pszDisplayName)
        {
            ERR(ERRORTEXT("COptions::GetOptionsForOutputPSLevel() failed to allocate display string for Level %d.\r\n"), 
                          wCount);

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }
    
        // Init option display name.
        hrResult = StringCchPrintfW(m_pInfo[wCount].pszDisplayName, 2, TEXT("%d"), wCount + 1);
        if(FAILED(hrResult))
        {
            ERR(ERRORTEXT("COptions::GetOptionsForOutputPSLevel() failed to create display name for item %d.\r\n"), 
                          wCount + 1);

            goto Exit;
        }
    }

    //
    // Get Current Selection
    //

    hrResult = GetOptionSelectionIndex(Helper, poemuiobj);


Exit:

    // Don't need to clean up memory allocation on error, since
    // all memory allocated are assigned to data members, which
    // will be cleaned up in the object destructor.

    return hrResult;
}

HRESULT COptions::GetOptionSelectionString(CUIHelper &Helper, POEMUIOBJ poemuiobj, PSTR *ppszSel)
{
    PSTR    pmszFeature     = NULL;
    PSTR    pmszBuf         = NULL;
    WORD    wCount          = 0;
    PCSTR  *ppszList        = NULL;
    DWORD   dwFeatureSize   = 0;
    DWORD   dwNeeded        = 0;
    DWORD   dwSize          = INITIAL_GET_OPTION_SIZE;
    HRESULT hrResult        = S_OK;


    //
    // Make single feature multi-sz.
    //

    // Allocate singe feature multi-sz buffer.
    dwFeatureSize = lstrlenA(m_pszFeature) + 2;
    pmszFeature = (PSTR) HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY, dwFeatureSize);
    if(NULL == pmszFeature)
    {
        ERR(ERRORTEXT("COptions::GetOptionSelectionString() failed to allocate buffer for single feature multi-sz for feature %hs.\r\n"),
                      m_pszFeature);

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // Just need to do a regular string copy, since the buffer is already zero filled.
    hrResult = StringCbCopyA(pmszFeature, dwFeatureSize, m_pszFeature);
    if(FAILED(hrResult))
    {
        ERR(ERRORTEXT("COptions::GetOptionSelectionString() failed to copy feature string %hs.\r\n"), m_pszFeature);
    }

    // Allocated initial buffer of reasonible size.
    pmszBuf = (PSTR) HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY, dwSize);
    if(NULL == pmszBuf)
    {
        ERR(ERRORTEXT("COptions::GetOptionSelectionString() failed to allocate buffer to get current setting for feature %hs.\r\n"),
                      m_pszFeature);

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // Get current option selection.
    hrResult = Helper.GetOptions(poemuiobj, 
                                 0, 
                                 pmszFeature, 
                                 dwFeatureSize,
                                 pmszBuf,
                                 dwSize,
                                 &dwNeeded);
    if( (E_OUTOFMEMORY == hrResult) && (dwSize < dwNeeded) )
    {
        PSTR    pTemp   = NULL;


        // INVARIANT:  initial buffer not large enough.

        // Re-alloc buffer and try again.
        pTemp = (PSTR) HeapReAlloc(m_hHeap, HEAP_ZERO_MEMORY, pmszBuf, dwNeeded);
        if(NULL == pTemp)
        {
            ERR(ERRORTEXT("COptions::GetOptionSelectionString() failed to re-allocate buffer to get current setting for feature %hs.\r\n"),
                          m_pszFeature);

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }
        pmszBuf = pTemp;

        
        // Try to get current option selection again.
        hrResult = Helper.GetOptions(poemuiobj, 
                                     0, 
                                     pmszFeature, 
                                     dwFeatureSize,
                                     pmszBuf,
                                     dwNeeded,
                                     &dwNeeded);
    }

    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("COptions::GetOptionSelectionString() failed to get current setting for feature %hs. (hrResult = 0x%x)\r\n"), 
            m_pszFeature,
            hrResult);

        goto Exit;
    }

    // NOTE: The return string from GetOptions() may return
    //       contain no strings and not return a HRESULT error
    //       when the feature isn't supported in the current document or 
    //       printer sticky mode.
    if('\0' == pmszBuf[0])
    {
        // Feature not supported for this sticky mode.
        goto Exit;
    }

    // Parse the results buffer to see what the current setting is.
    hrResult = MakeStrPtrList(m_hHeap, pmszBuf, &ppszList, &wCount);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("COptions::GetOptionSelectionString() failed to make string list for GetOptions() return for feature %hs. (hrResult = 0x%x)\r\n"), 
            m_pszFeature,
            hrResult);

        goto Exit;
    }

    // Check that we got 2 strings back.
    if(2 != wCount)
    {
        WARNING(DLLTEXT("COptions::GetOptionSelectionString() the GetOption() return string list for \r\n\tfeature %hs is not of size 2.\r\n\tNumber of string is %d\r\n"),
                        m_pszFeature,
                        wCount);

        // Bail if we don't have at least 2 strings.
        if(2 > wCount)
        {
            goto Exit;
        }
    }

    // Return copy of just the GetOption() result.
    *ppszSel = MakeStringCopy(m_hHeap, ppszList[1]);
    if(NULL == *ppszSel)
    {
        ERR(ERRORTEXT("COptions::GetOptionSelectionString() failed to duplicate string GetOptions() return for feature %hs. (hrResult = 0x%x)\r\n"), 
            m_pszFeature,
            hrResult);

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }


Exit:

    // Free local buffers.
    if(NULL != pmszFeature) HeapFree(m_hHeap, 0, pmszFeature);
    if(NULL != pmszBuf)     HeapFree(m_hHeap, 0, pmszBuf);
    if(NULL != ppszList)    HeapFree(m_hHeap, 0, ppszList);

    return hrResult;
}

// Gets current Options selection for LONG value.
HRESULT COptions::GetOptionSelectionLong(CUIHelper &Helper, POEMUIOBJ poemuiobj)
{
    PSTR    pszSel      = NULL;
    HRESULT hrResult    = S_OK;


    // Get option selection string.
    hrResult = GetOptionSelectionString(Helper, poemuiobj, &pszSel);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("COptions::GetOptionSelectionLong() failed to get string for GetOptions() return for feature %hs. (hrResult = 0x%x)\r\n"), 
            m_pszFeature,
            hrResult);

        goto Exit;
    }

    // Convert string option to LONG and uses that as the selection.
    if(NULL != pszSel) m_Sel = atol(pszSel);


Exit:

    // Free local buffers.
    if(NULL != pszSel)  HeapFree(m_hHeap, 0, pszSel);

    return hrResult;
}

// Gets current Options selection for SHORT value.
HRESULT COptions::GetOptionSelectionShort(CUIHelper &Helper, POEMUIOBJ poemuiobj)
{
    PSTR    pszSel      = NULL;
    HRESULT hrResult    = S_OK;


    // Get option selection string.
    hrResult = GetOptionSelectionString(Helper, poemuiobj, &pszSel);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("COptions::GetOptionSelectionLong() failed to get string for GetOptions() return for feature %hs. (hrResult = 0x%x)\r\n"), 
            m_pszFeature,
            hrResult);

        goto Exit;
    }

    // Convert string option to LONG and uses that as the selection.
    if(NULL != pszSel) m_Sel = atoi(pszSel) & 0x00ffff;


Exit:

    // Free local buffers.
    if(NULL != pszSel)  HeapFree(m_hHeap, 0, pszSel);

    return hrResult;
}

// Gets current option selection for feature.
HRESULT COptions::GetOptionSelectionIndex(CUIHelper &Helper, POEMUIOBJ poemuiobj)
{
    PSTR    pszSel      = NULL;
    HRESULT hrResult    = S_OK;


    // Get option selection string.
    hrResult = GetOptionSelectionString(Helper, poemuiobj, &pszSel);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("COptions::GetOptionSelectionIndex() failed to get string for GetOptions() return for feature %hs. (hrResult = 0x%x)\r\n"), 
            m_pszFeature,
            hrResult);

        goto Exit;
    }

    // Find the matching option for the string returned from GetOption.
    m_Sel = FindOption(pszSel, m_wOptions - 1);


Exit:

    // Free local buffers.
    if(NULL != pszSel)  HeapFree(m_hHeap, 0, pszSel);

    return hrResult;
}
 


//
//  Public Methods
// 

// Default constructor
COptions::COptions()
{
    Init();
}

// Destructor
COptions::~COptions()
{
    Clear();
}

// Get the option list for a feature
HRESULT COptions::Acquire(HANDLE hHeap,            
                          CUIHelper &Helper, 
                          POEMUIOBJ poemuiobj,
                          PCSTR pszFeature)
{
    DWORD   dwNeeded    = 0;
    HRESULT hrResult    = S_OK;


    VERBOSE(DLLTEXT("COptions::Acquire(0x%p, Helper, 0x%p, %hs) entered.\r\n"),
            hHeap,
            poemuiobj,
            pszFeature ? pszFeature : "NULL");

    // Don't retreive the Options again if we already got them.
    if( (0 < m_wOptions) 
        && 
        (NULL != m_pszFeature) 
        && 
        !lstrcmpA(m_pszFeature, pszFeature)
      )
    {
        VERBOSE(DLLTEXT("COptions::Acquire() already have options for feature %hs.\r\n"), m_pszFeature);
        VERBOSE(DLLTEXT("COptions::Acquire() returning with HRESULT of S_OK\r\n"));

        return S_OK;
    }

    // Save the heap handle for use later, such as freeing memory at destruction.
    m_hHeap = hHeap;

    // Store Keyword string.
    m_pszFeature = pszFeature;


    //
    // Enumerate Options.
    //


    // Some features require special handling for initializing their options.
    // EnumOpionts isn't implemented for these features.
    // Return of E_NOTIMPL indicates it isn't the feature doesn't
    // need special handling.
    hrResult = GetOptionsForSpecialFeatures(Helper, poemuiobj);
    if( SUCCEEDED(hrResult) 
        || 
        (!SUCCEEDED(hrResult) && (E_NOTIMPL != hrResult) )
      )
    {
        // We either dealt with the special feature or incounter an error
        // trying to deal with the special feature.

        goto Exit;
    }

    // To try to cut down on having to call EnumOptions more than once, 
    // pre-allocate a buffer of reasonable size.
    m_dwSize = INITIAL_ENUM_OPTIONS_SIZE;
    m_pmszRaw = (PSTR) HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY, m_dwSize);
    if(NULL == m_pmszRaw)
    {
        ERR(ERRORTEXT("COptions::Acquire() alloc for options for feature %hs failed.\r\n"), m_pszFeature);

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }


    // Try to get options list with initial buffer.
    hrResult = Helper.EnumOptions(poemuiobj, 0, m_pszFeature, m_pmszRaw, m_dwSize, &dwNeeded);
    if( (E_OUTOFMEMORY == hrResult) && (m_dwSize < dwNeeded))
    {
        PSTR    pTemp;


        // INVARIANT:  options list multi-sz wasn't large enough.

        // Re-allocate the buffer and try again.
        pTemp = (PSTR) HeapReAlloc(m_hHeap, HEAP_ZERO_MEMORY, m_pmszRaw, dwNeeded);
        if(NULL == pTemp)
        {
            ERR(ERRORTEXT("COptions::Acquire() re-alloc for options list for feature %hs failed.\r\n"), m_pszFeature); 

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }
        m_pmszRaw = pTemp;
        m_dwSize = dwNeeded;

        // Try again to get the options list.
        hrResult = Helper.EnumOptions(poemuiobj, 0, m_pszFeature, m_pmszRaw, m_dwSize, &dwNeeded);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("COptions::Acquire() failed to EnumOptions() for feature %hs after re-allocating buffer.\r\n"), m_pszFeature); 

            goto Exit;
        }
    }

    // Make sure we got the option list.
    // Can't do anything more with out it.
    if(!SUCCEEDED(hrResult))
    {
        if(E_NOTIMPL != hrResult) ERR(ERRORTEXT("COptions::Acquire() failed to enumerate options for feature %hs. (hrResult = 0x%x)\r\n"), m_pszFeature, hrResult); 

        goto Exit;
    }

    // INVARIANT:  successfully got option keyword list.

    // Create array of string pointers to the Option names
    // in the multi-sz we got from EnumOptions().
    hrResult = MakeStrPtrList(m_hHeap, m_pmszRaw, &m_ppszOptions, &m_wOptions);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("COptions::Acquire() failed to create pointer list to options. (hrResult = 0x%x)\r\n"), hrResult); 

        goto Exit;
    }

    //
    //  Build Option Information
    //

    // Allocate array to hold feature info
    m_pInfo = (POPTION_INFO) HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY, m_wOptions * sizeof(OPTION_INFO));
    if(NULL == m_pInfo)
    {
        ERR(ERRORTEXT("COptions::Acquire() failed to alloc feature info array.\r\n")); 

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // For each option, build or get useful information, such as display name.
    for(WORD wIndex = 0; wIndex < m_wOptions; ++wIndex)
    {
        POPTION_INFO    pCurrent    = m_pInfo + wIndex;


        // Get or build a keyword mapping entry
        // that maps from keyword to usefully where to get info, such as 
        // display name, icon, option type, for keywords that may not be
        // able to get info for from Helper.
        pCurrent->pMapping = FindKeywordMapping(gkmOptionMap, NUM_OPTION_MAP, m_ppszOptions[wIndex]);

        // Get display names for each of the Options.
        // The function implements a heuristic for detemining the display name,
        // since can't get the display name from the UI Helper for all Options.
        hrResult = DetermineOptionDisplayName(m_hHeap, 
                                              Helper, 
                                              poemuiobj, 
                                              m_pszFeature,
                                              m_ppszOptions[wIndex],
                                              pCurrent->pMapping,
                                              &pCurrent->pszDisplayName);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("COptions::Acquire() failed to get display name for %hs of feature %hs. (hrResult = 0x%x)\r\n"), 
                          m_ppszOptions[wIndex], 
                          m_pszFeature,
                          hrResult); 

            goto Exit;
        }
    }

    //
    // Get current option selection.
    //

    hrResult = GetOptionSelectionIndex(Helper, poemuiobj);


Exit:

    // Clean up if weren't successful.
    if(!SUCCEEDED(hrResult))
    {
        Clear();
    }

    VERBOSE(DLLTEXT("COptions::Acquire() returning with HRESULT of 0x%x\r\n"), hrResult);

    return hrResult;
}

// Return nth options keyword.
PCSTR COptions::GetKeyword(WORD wIndex) const
{
    // Validate parameters.
    if( (wIndex >= m_wOptions)
        ||
        (NULL == m_ppszOptions)
      )
    {
        return NULL;
    }

    return m_ppszOptions[wIndex];
}

// Return nth options display name.
PCWSTR COptions::GetName(WORD wIndex) const
{
    // Validate parameters.
    if( (wIndex >= m_wOptions)
        ||
        (NULL == m_pInfo)
      )
    {
        ERR(ERRORTEXT("COptions::GetName() invalid parameters.\r\n"));

        return NULL;
    }

    if(NULL == m_pInfo[wIndex].pszDisplayName) ERR(ERRORTEXT("COptions::GetName() returning NULL option display name.\r\n"));

    return m_pInfo[wIndex].pszDisplayName;
}

// Find option with matching keyword string.
WORD COptions::FindOption(PCSTR pszOption, WORD wDefault) const
{
    BOOL    bFound  = FALSE;
    WORD    wMatch  = wDefault;


    // Validate parameters.
    if( (NULL == pszOption)
        ||
        (NULL == m_ppszOptions)
      )
    {
        return wDefault;
    }

    // Walk the option keyword looking for a match.
    for(WORD wIndex = 0; !bFound && (wIndex < m_wOptions); ++wIndex)
    {
        bFound = !lstrcmpA(pszOption, m_ppszOptions[wIndex]);
        if(bFound)
        {
            wMatch = wIndex;
        }
    }

    return wMatch;
}

// Initializes OptItem with options for a feature.
HRESULT COptions::InitOptItem(HANDLE hHeap, POPTITEM pOptItem)
{
    WORD    wParams     = 0;
    WORD    wOptions    = 0;
    HRESULT hrResult    = S_OK;


    // Set option selection.
    pOptItem->pSel = m_pSel;

    // Get count of number of options.
    // NOTE: Some feature options have no counts.
    wOptions = GetCount();

    // Different OPTTYPE types require different number of OPTPARAMs.
    switch(m_cType)
    {
        // For up down arrow control, the OPTPARAMs need is 2.
        case TVOT_UDARROW:
            wParams = 2;
            break;

        // For combobox, the OPTPARAMs needed is on per options.
        case TVOT_COMBOBOX:
            wParams = wOptions;
            break;

        // The default is the option count.
        default:
            WARNING(DLLTEXT("COptions::InitOptItem() OPTTYPE type %d num of OPTPARAMs not handled. Default to option count of %d.\r\n"),
                            m_cType,
                            wOptions);
            wParams = wOptions;
            break;
    }

    // Only do OPTTYPEs if we have non-Zero number of OPTPARAMs.
    // Every OPTTYPE has at leas one OPTPARAM.
    if(0 < wParams)
    {
        // Allocate memory for feature options.
        pOptItem->pOptType = CreateOptType(hHeap, wParams);
        if(NULL == pOptItem->pOptType)
        {
            ERR(ERRORTEXT("COptions::InitOptItem() failed to allocate OPTTYPEs for OPTITEM %hs.\r\n"), 
                           m_pszFeature); 

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }

        // Set OPTTYPE.
        pOptItem->pOptType->Type = m_cType;

        // Different OPTTYPE types require different initialization.
        switch(m_cType)
        {
            // For up down arrow control, OPTPARAM[0] is used by the contrl.
            // pOptParam[0]->pData is the Units description string.
            // pOptParam[1].IconID is the min limit.
            // pOptParam[1].lParam is the max limit.
            case TVOT_UDARROW:
                assert(2 == wParams);
                pOptItem->pOptType->pOptParam[0].pData  = m_pszUnits;
                pOptItem->pOptType->pOptParam[1].IconID = m_ptRange.x;
                pOptItem->pOptType->pOptParam[1].lParam = m_ptRange.y;
                break;

            // For combobox, the pOptParam[n].pData is the display name of the option.
            case TVOT_COMBOBOX:
                for(WORD wIndex = 0; wIndex < wParams; ++wIndex)
                {
                    pOptItem->pOptType->pOptParam[wIndex].pData = const_cast<PWSTR>(GetName(wIndex));
                }
                break;

            default:
                ERR(ERRORTEXT("COptions::InitOptItem() OPTTYPE type %d OPTTYPE init not handled.\r\n"),
                              m_cType);
                break;
        }
    }


Exit:

    return hrResult;
}

// Refresh option selection.
HRESULT COptions::RefreshSelection(CUIHelper &Helper, POEMUIOBJ poemuiobj)
{
    HRESULT     hrResult = S_OK;


    // Method for getting option selection is based
    // on OPTTYPE type.
    switch(m_cType)
    {

        case TVOT_UDARROW:
            hrResult = GetOptionSelectionShort(Helper, poemuiobj);
            break;

        case TVOT_COMBOBOX:
            hrResult = GetOptionSelectionIndex(Helper, poemuiobj);
            break;

        default:
            ERR(ERRORTEXT("COptions::RefreshSelection() not handled for type %d OPTTYPE.\r\n"),
                           m_cType);
            break;
    }

    return hrResult;
}



////////////////////////////////////////////
//
//  CFeatures Methods
//

//
//  Private Methods
// 

// Initializes class
void CFeatures::Init()
{
    // Initialize data members.
    m_wFeatures         = 0;
    m_wDocFeatures      = 0;
    m_wPrintFeatures    = 0;
    m_pmszRaw           = NULL;
    m_ppszKeywords      = NULL;
    m_dwSize            = 0;
    m_hHeap             = NULL;
    m_pInfo             = NULL;
}

// Cleans up class and re-initialize it.
void CFeatures::Clear()
{
    // Free memory associated with data members.
    if(NULL != m_pmszRaw)       HeapFree(m_hHeap, 0, m_pmszRaw);
    if(NULL != m_ppszKeywords)  HeapFree(m_hHeap, 0, m_ppszKeywords);

    // Free feature info
    FreeFeatureInfo();

    // Re-initialize
    Init();
}

// Free feature info
void CFeatures::FreeFeatureInfo()
{
    // Validate parameters.
    if( (NULL == m_hHeap)
        ||
        (NULL == m_pInfo)
      )
    {
        return;
    }

    // Free memory associated with feature info.
    for(WORD wIndex = 0; wIndex < m_wFeatures; ++wIndex)
    {
        PWSTR   pszDisplay =  m_pInfo[wIndex].pszDisplayName;


        // Free display name.
        if( (NULL != pszDisplay)
            &&
            !IS_INTRESOURCE(pszDisplay)
          )
        {
            HeapFree(m_hHeap, 0, pszDisplay);
        }
    }

    // Free feature info array.
    // Feature Info array allocated with new so
    // that each of the constructors for COptions 
    // in fhte Feature Info array will be called.
    delete[] m_pInfo;
}

// Turns index for mode to modeless index, which
// is the real index to the feature.
WORD CFeatures::GetModelessIndex(WORD wIndex, DWORD dwMode) const
{
    WORD    wCount = 0;


    switch(dwMode)
    {
        // Number of features, all modes
        case 0:
            wCount = wIndex;
            break;

        // Find the nth feature that matches the mode
        case OEMCUIP_DOCPROP:
        case OEMCUIP_PRNPROP:
            // Walk the feature list looking for nth feature
            // with matching mode.
            for(wCount = 0; wCount < m_wFeatures; ++wCount)
            {
                // Count down to the feature we want.
                // Only count down for matching modes.
                if(dwMode == m_pInfo[wCount].dwMode)
                {
                    if(0 == wIndex)
                    {
                        break;
                    }
                    else
                    {
                        --wIndex;
                    }
                }
            }
            break;
    }

    return wCount;
}


//
//  Public Methods
// 

// Default constructor
CFeatures::CFeatures()
{
    Init();
}

// Destructor
CFeatures::~CFeatures()
{
    // Clean up class.
    Clear();
}

// Gets Core Driver Features, if not already retrieved.
HRESULT CFeatures::Acquire(HANDLE hHeap, 
                           CUIHelper &Helper, 
                           POEMUIOBJ poemuiobj
                          )
{
    WORD    wIndex      = 0;
    DWORD   dwNeeded    = 0;
    HRESULT hrResult    = S_OK;


    VERBOSE(DLLTEXT("CFeatures::Acquire(0x%p, Helper, 0x%p) entered.\r\n"),
            hHeap,
            poemuiobj);

    // Don't retreive the Features again if we already got them.
    if(0 < m_wFeatures)
    {
        VERBOSE(DLLTEXT("CFeatures::Acquire() features already enumerated.\r\n"));
        VERBOSE(DLLTEXT("CFeatures::Acquire() returning S_OK.\r\n"));

        return S_OK;
    }

    // Save the heap handle for use later, such as freeing memory at destruction.
    m_hHeap = hHeap;

    //
    // Enumerate features.
    //

    // To try to cut down on having to call EnumFeatures more than once, 
    // pre-allocate a buffer of reasonable size.
    m_dwSize = INITIAL_ENUM_FEATURES_SIZE;
    m_pmszRaw = (PSTR) HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY, m_dwSize);
    if(NULL == m_pmszRaw)
    {
        ERR(ERRORTEXT("CFeatures::Acquire() alloc for feature list failed.\r\n")); 

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }


    // Try to get feature list with initial buffer.
    hrResult = Helper.EnumFeatures(poemuiobj, 0, m_pmszRaw, m_dwSize, &dwNeeded);
    if( (E_OUTOFMEMORY == hrResult) && (m_dwSize < dwNeeded))
    {
        PSTR    pTemp;


        // INVARIANT:  feature list multi-sz wasn't large enough.


        // Re-allocate the buffer and try again.
        pTemp = (PSTR) HeapReAlloc(m_hHeap, HEAP_ZERO_MEMORY, m_pmszRaw, dwNeeded);
        if(NULL == pTemp)
        {
            ERR(ERRORTEXT("CFeatures::Acquire() re-alloc for feature list failed.\r\n")); 

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }
        m_pmszRaw = pTemp;
        m_dwSize = dwNeeded;

        // Try again to get the feature list.
        hrResult = Helper.EnumFeatures(poemuiobj, 0, m_pmszRaw, m_dwSize, &dwNeeded);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("CFeatures::Acquire() failed to EnumFeatures() after re-allocating buffer.\r\n")); 

            goto Exit;
        }
    }

    // Make sure we got the feature list.
    // Can't do anything more with out it.
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("CFeatures::Acquire() failed to enumerate features. (hrResult = 0x%x)\r\n"), hrResult); 

        goto Exit;
    }

    // INVARIANT:  successfully got feature keyword list.

    // Create array of string pointers to the feature keywords
    // in the multi-sz we got from EnumFreatures().
    hrResult = MakeStrPtrList(m_hHeap, m_pmszRaw, &m_ppszKeywords, &m_wFeatures);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("CFeatures::Acquire() failed to create pointer list to keywords. (hrResult = 0x%x)\r\n"), hrResult); 

        goto Exit;
    }


    //
    //  Build Feature Information
    //


    // Allocate array to hold feature info
    // Use new for allocation so class 
    // constructors/destructors get called.
    m_pInfo = new FEATURE_INFO[m_wFeatures];
    if(NULL == m_pInfo)
    {
        ERR(ERRORTEXT("CFeatures::Acquire() failed to alloc feature info array.\r\n")); 

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // For each feature, build/get feature info....
    for(wIndex = 0; wIndex < m_wFeatures; ++wIndex)
    {
        PFEATURE_INFO   pCurrent    = m_pInfo + wIndex;


        // Get or build a keyword mapping entry
        // that maps from keyword to usefully where to get info, such as 
        // display name, icon, option type, for keywords that may not be
        // able to get info for from Helper.
        pCurrent->pMapping = FindKeywordMapping(gkmFeatureMap, NUM_FEATURE_MAP, m_ppszKeywords[wIndex]);

        // Get display names for each of the featurs.
        // The function implements a heuristic for detemining the display name,
        // since can't get the display name from the UI Helper for all features.
        hrResult = DetermineFeatureDisplayName(m_hHeap, 
                                               Helper, 
                                               poemuiobj, 
                                               m_ppszKeywords[wIndex],
                                               pCurrent->pMapping,
                                               &pCurrent->pszDisplayName);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("CFeatures::Acquire() failed to get display name for feature %hs. (hrResult = 0x%x)\r\n"), 
                          m_ppszKeywords[wIndex], 
                          hrResult); 

            goto Exit;
        }

        // Get options for each feature.
        // NOTE: some features don't have options; the HRESULT will be E_NOTIMPL for these.
        hrResult = pCurrent->Options.Acquire(hHeap,            
                                             Helper, 
                                             poemuiobj,
                                             m_ppszKeywords[wIndex]);
        if(!SUCCEEDED(hrResult) && (E_NOTIMPL != hrResult))
        {
            ERR(ERRORTEXT("CFeatures::Acquire() failed to get options for feature %hs. (hrResult = 0x%x)\r\n"), 
                          m_ppszKeywords[wIndex], 
                          hrResult); 

            goto Exit;
        }

        // Determine if feature is Printer or Document sticky.
        hrResult = DetermineStickiness(Helper, 
                                       poemuiobj, 
                                       m_ppszKeywords[wIndex],
                                       pCurrent->pMapping,
                                       &pCurrent->dwMode);
        // Don't propagate error if failure from unhandled driver feature.
        if( !SUCCEEDED(hrResult)
            &&
            !IS_DRIVER_FEATURE(m_ppszKeywords[wIndex])    
          )
        {
            ERR(ERRORTEXT("CFeatures::Acquire() failed to determine stickiness for feature %hs. (hrResult = 0x%x)\r\n"), 
                          m_ppszKeywords[wIndex], 
                          hrResult); 

            goto Exit;
        }

        // Keep track of mode counts.
        switch(pCurrent->dwMode)
        {
            case OEMCUIP_DOCPROP:
                ++m_wDocFeatures;
                break;

            case OEMCUIP_PRNPROP:
                ++m_wPrintFeatures;
                break;

            default:
                ERR(ERRORTEXT("CFeatures::Acquire() unknown stickiness for feature %hs.\r\n"), 
                              m_ppszKeywords[wIndex]); 
                break;
        }

    }

    // INVARIANT:  successfully build feature list.

    // Make sure that we always return success if we reach this point.
    hrResult = S_OK;


Exit:

    // Clean up if weren't successful.
    if(!SUCCEEDED(hrResult))
    {
        Clear();
    }


    VERBOSE(DLLTEXT("CFeatures::Acquire() returning HRESULT of 0x%x.\r\n"), hrResult);

    return hrResult;
}

// Returns number of features contained in class instance.
WORD CFeatures::GetCount(DWORD dwMode) const 
{
    WORD    wCount = 0;


    switch(dwMode)
    {
        // Number of features, all modes
        case 0:
            wCount = m_wFeatures;
            break;

        case OEMCUIP_DOCPROP:
            wCount = m_wDocFeatures;
            break;

        case OEMCUIP_PRNPROP:
            wCount = m_wPrintFeatures;
            break;

    }

    VERBOSE(DLLTEXT("CFeatures::GetCount() returning %d\r\n"), wCount);

    return wCount;
}

// Returns nth feature's keyword
PCSTR CFeatures::GetKeyword(WORD wIndex, DWORD dwMode) const
{
    // Validate parameters.
    if( (wIndex >= GetCount(dwMode))
        ||
        (NULL == m_ppszKeywords)
      )
    {
        return NULL;
    }

    // Get internal index.
    wIndex = GetModelessIndex(wIndex, dwMode);

    // Return keyword
    return m_ppszKeywords[wIndex];
}

// Return nth feature's Display Name.
PCWSTR CFeatures::GetName(WORD wIndex, DWORD dwMode) const
{
    // Validate parameters.
    if( (wIndex >= GetCount(dwMode))
        ||
        (NULL == m_pInfo)
      )
    {
        return NULL;
    }

    // Get internal index.
    wIndex = GetModelessIndex(wIndex, dwMode);

    // Return display name.
    return m_pInfo[wIndex].pszDisplayName;
}

// Returns pointer to option class for nth feature.
COptions* CFeatures::GetOptions(WORD wIndex, DWORD dwMode) const
{
    // Validate parameters.
    if( (wIndex >= GetCount(dwMode))
        ||
        (NULL == m_pInfo)
      )
    {
        return NULL;
    }

    // Get internal index.
    wIndex = GetModelessIndex(wIndex, dwMode);

    // Return options pointer.
    return &m_pInfo[wIndex].Options;
}

// Formats OPTITEM for specied feature.
HRESULT CFeatures::InitOptItem(HANDLE hHeap, POPTITEM pOptItem, WORD wIndex, DWORD dwMode)
{
    COptions            *pOptions   = NULL;
    HRESULT             hrResult    = S_OK;
    PFEATUREOPTITEMDATA pData       = NULL;


    // Validate parameters.
    if( (wIndex >= GetCount(dwMode))
        ||
        (NULL == m_pInfo)
        ||
        (NULL == pOptItem)
      )
    {
        return E_INVALIDARG;
    }

    // Map mode index to internal index.
    wIndex = GetModelessIndex(wIndex, dwMode);

    // Get name of feature.
    pOptItem->pName = const_cast<PWSTR>(GetName(wIndex));

    // Add feature OPTITEM data to OPTITEM to facilitate saving
    // selection changes.
    pData = (PFEATUREOPTITEMDATA) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(FEATUREOPTITEMDATA));
    if(NULL == pData)
    {
        ERR(ERRORTEXT("CFeatures::InitOptItem() failed to allocated memory for feature OPTITEM data."));

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }
    pData->dwSize               = sizeof(FEATUREOPTITEMDATA);
    pData->dwTag                = FEATURE_OPTITEM_TAG;
    pData->pszFeatureKeyword    = GetKeyword(wIndex);
    pData->pOptions             = GetOptions(wIndex);
    pOptItem->UserData          = (ULONG_PTR) pData;


    // Get pointer to options for this feature.
    // NOTE: some features do not have option list for various reasons.
    pOptions = GetOptions(wIndex);
    if(NULL != pOptions)
    {
        // Initialize COption parts of the OPTITEM 
        hrResult = pOptions->InitOptItem(hHeap, pOptItem);
    }

Exit:

    Dump(pOptItem);

    return hrResult;
}

//////////////////////////////////////////////////
//
//  Regular functions not part of class
//
//////////////////////////////////////////////////


// Maps feature keywords to display names for the features.
HRESULT DetermineFeatureDisplayName(HANDLE hHeap, 
                                    CUIHelper &Helper, 
                                    POEMUIOBJ poemuiobj, 
                                    PCSTR pszKeyword,
                                    const PKEYWORDMAP pMapping,
                                    PWSTR *ppszDisplayName)
{
    DWORD   dwDataType  = -1;
    DWORD   dwSize      = INITIAL_FEATURE_DISPLAY_NAME_SIZE;
    DWORD   dwNeeded    = 0;
    HRESULT hrResult    = S_OK;


    // Validate parameters.
    if( (NULL == hHeap)
        ||
        (NULL == pszKeyword)
        ||
        (NULL == ppszDisplayName)
      )
    {
        ERR(ERRORTEXT("DetermineFeatureDisplayName() invalid arguement.\r\n")); 

        hrResult = E_INVALIDARG;
        goto Exit;
    }

    //
    // Call the Helper function.
    // 

    // Helper will return Display Names for PPD Features, but
    // not for Driver Synthisized features (i.e. features prefixed with %).
    // Do it for Driver Synthisized features, just in case the helper
    // interface changes to support it.

    // Pre-allocate a buffer of reasonable size to try
    // to one have to call GetFeatureAttribute() once.
    *ppszDisplayName = (PWSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize);
    if(NULL == *ppszDisplayName)
    {
        ERR(ERRORTEXT("DetermineFeatureDisplayName() alloc for feature display name failed.\r\n")); 

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // Try to get diplay name for feature from Helper.
    hrResult = Helper.GetFeatureAttribute(poemuiobj, 
                                          0, 
                                          pszKeyword, 
                                          "DisplayName", 
                                          &dwDataType,
                                          (PBYTE) *ppszDisplayName, 
                                          dwSize, 
                                          &dwNeeded);
    if( (E_OUTOFMEMORY == hrResult) && (dwSize < dwNeeded))
    {
        PWSTR   pTemp;


        // INVARIANT: initial buffer wasn't large enough.

        // Re-alloc buffer and try again.
        pTemp = (PWSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, *ppszDisplayName, dwNeeded);
        if(NULL == pTemp)
        {
            ERR(ERRORTEXT("DetermineFeatureDisplayName() re-alloc for feature display name failed.\r\n")); 

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }
        *ppszDisplayName = pTemp;

        // Try to get the display name from Helper, again.
        hrResult = Helper.GetFeatureAttribute(poemuiobj, 
                                              0, 
                                              pszKeyword, 
                                              "DisplayName", 
                                              &dwDataType,
                                              (PBYTE) *ppszDisplayName, 
                                              dwNeeded, 
                                              &dwNeeded);
    }

    if(SUCCEEDED(hrResult))
    {
        // INVARIANT:  Successfully got display name from Helper for feature.
        //             Don't need to do anything more.

        // Check the data type, it should be kADT_UNICODE.
        if(kADT_UNICODE != dwDataType) WARNING(DLLTEXT("DetermineFeatureDisplayName() feature attribute type not kADT_UNICODE. (dwDataType = %d)\r\n"), dwDataType);

        goto Exit;
    }

    // INVARIANT:  Did not get the display name from the Helper.

    // Free memory allocated for call to Helper.
    if(NULL != *ppszDisplayName) 
    {
        HeapFree(hHeap, 0, *ppszDisplayName);
        *ppszDisplayName = NULL;
    }

    // Try alternative methods for getting the display name other 
    // than from the Helper function.
    // If we have a mapping entry, then try to get resource string
    // for the display name.
    // Otherwise, covert the keyword to UNICODE and use that.
    if(NULL != pMapping)
    {
        //
        // Try mapping the keyword to resource string.
        //

        hrResult = GetDisplayNameFromMapping(hHeap, pMapping, ppszDisplayName);
    }
    else
    {
        //
        // Convert the keyword to UNICODE and use that.
        //

        // Convert ANSI keyword to Unicode string for display name.
        // Need to remove the % for Driver Synthisized features.
        // For debug version, add marker that shows that the display name was faked.
        PCSTR   pConvert = IS_DRIVER_FEATURE(pszKeyword) ? pszKeyword + 1 : pszKeyword;
    #if DBG
        CHAR    szTemp[256];
        if(FAILED(StringCbPrintfA(szTemp, sizeof(szTemp), "%s (Keyword)", pConvert)))
        {
            ERR(ERRORTEXT("DetermineFeatureDisplayName() StringCbPrintfA() called failed.\r\n")); 
        }
        pConvert = szTemp;
    #endif
        *ppszDisplayName = MakeUnicodeString(hHeap, pConvert);
        if(NULL == *ppszDisplayName)
        {
            ERR(ERRORTEXT("DetermineFeatureDisplayName() alloc for feature display name failed.\r\n")); 

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }

        // Return success even though we faked a display name.
        hrResult = S_OK;
    }


Exit:

    // If failed, then return no string.
    if(!SUCCEEDED(hrResult))
    {
        if(NULL != *ppszDisplayName)
        {
            HeapFree(hHeap, 0, *ppszDisplayName);
            *ppszDisplayName = NULL;
        }
    }

    return hrResult;
}

// Maps option keywords to display names for the option.
HRESULT DetermineOptionDisplayName(HANDLE hHeap, 
                                   CUIHelper &Helper, 
                                   POEMUIOBJ poemuiobj, 
                                   PCSTR pszFeature,
                                   PCSTR pszOption,
                                   const PKEYWORDMAP pMapping,
                                   PWSTR *ppszDisplayName)
{
    DWORD   dwDataType  = -1;
    DWORD   dwSize      = INITIAL_OPTION_DISPLAY_NAME_SIZE;
    DWORD   dwNeeded    = 0;
    HRESULT hrResult    = S_OK;


    // Validate parameters.
    if( (NULL == hHeap)
        ||
        (NULL == pszFeature)
        ||
        (NULL == pszOption)
        ||
        (NULL == ppszDisplayName)
      )
    {
        ERR(ERRORTEXT("DetermineOptionDisplayName() invalid arguement.\r\n")); 

        hrResult = E_INVALIDARG;
        goto Exit;
    }

    //
    // Call the Helper function.
    // 

    // Helper will return Display Names for PPD Feature Options, but
    // not for Driver Synthisized features options (i.e. features prefixed with %).
    // Do it for all options, just in case the helper interface changes to support it.

    // Pre-allocate a buffer of reasonable size to try
    // to one have to call GetOptionAttribute() once.
    *ppszDisplayName = (PWSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize);
    if(NULL == *ppszDisplayName)
    {
        ERR(ERRORTEXT("DetermineOptionDisplayName() alloc for feature display name failed.\r\n")); 

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // Try to get diplay name for feature from Helper.
    hrResult = Helper.GetOptionAttribute(poemuiobj, 
                                         0, 
                                         pszFeature,
                                         pszOption,
                                         "DisplayName", 
                                         &dwDataType,
                                         (PBYTE) *ppszDisplayName, 
                                         dwSize, 
                                         &dwNeeded);
    if( (E_OUTOFMEMORY == hrResult) && (dwSize < dwNeeded))
    {
        PWSTR   pTemp;


        // INVARIANT: initial buffer wasn't large enough.

        // Re-alloc buffer and try again.
        pTemp = (PWSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, *ppszDisplayName, dwNeeded);
        if(NULL == pTemp)
        {
            ERR(ERRORTEXT("GetOptionAttribute() re-alloc for feature display name failed.\r\n")); 

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }
        *ppszDisplayName = pTemp;

        // Try to get the display name from Helper, again.
        hrResult = Helper.GetOptionAttribute(poemuiobj, 
                                             0, 
                                             pszFeature,
                                             pszOption,
                                             "DisplayName", 
                                             &dwDataType,
                                             (PBYTE) *ppszDisplayName, 
                                             dwNeeded, 
                                             &dwNeeded);
    }

    if(SUCCEEDED(hrResult))
    {
        // INVARIANT:  Successfully got display name from Helper for feature.
        //             Don't need to do anything more.

        // Check the data type, it should be kADT_UNICODE.
        if(kADT_UNICODE != dwDataType) WARNING(DLLTEXT("DetermineOptionDisplayName() feature attribute type not kADT_UNICODE. (dwDataType = %d)\r\n"), dwDataType);

        goto Exit;
    }

    // INVARIANT:  Did not get the display name from the Helper.

    // Free memory allocated for call to Helper.
    if(NULL != *ppszDisplayName) 
    {
        HeapFree(hHeap, 0, *ppszDisplayName);
        *ppszDisplayName = NULL;
    }

    // Try alternative methods for getting the display name other 
    // than from the Helper function.
    // If we have a mapping entry, then try to get resource string
    // for the display name.
    // Otherwise, covert the keyword to UNICODE and use that.
    if(NULL != pMapping)
    {
        //
        // Try mapping the keyword to resource string.
        //

        hrResult = GetDisplayNameFromMapping(hHeap, pMapping, ppszDisplayName);
    }
    else
    {
        //
        // Convert the keyword to UNICODE and use that.
        //

        // Convert ANSI keyword to Unicode string for display name.
        // For debug version, add marker that shows that the display name was faked.
        PCSTR   pConvert    = pszOption;
    #if DBG
        CHAR    szTemp[256];
        if(FAILED(StringCbPrintfA(szTemp, sizeof(szTemp), "%s (Keyword)", pConvert)))
        {
            ERR(ERRORTEXT("DetermineOptionDisplayName() StringCbPrintfA() called failed.\r\n")); 
        }
        pConvert = szTemp;
    #endif
        *ppszDisplayName = MakeUnicodeString(hHeap, pConvert);
        if(NULL == *ppszDisplayName)
        {
            ERR(ERRORTEXT("DetermineOptionDisplayName() alloc for feature display name failed.\r\n")); 

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }

        // Return success even though we faked a display name.
        hrResult = S_OK;
    }


Exit:

    // If failed, then return no string.
    if(!SUCCEEDED(hrResult))
    {
        if(NULL != *ppszDisplayName)
        {
            HeapFree(hHeap, 0, *ppszDisplayName);
            *ppszDisplayName = NULL;
        }
    }

    return hrResult;
}

// Determines sticky mode for the feature.
HRESULT DetermineStickiness(CUIHelper &Helper,
                            POEMUIOBJ poemuiobj, 
                            PCSTR pszKeyword,
                            const PKEYWORDMAP pMapping,
                            PDWORD pdwMode)
{
    CHAR    szGroupType[32]     = {0};
    DWORD   dwType              = 0;
    DWORD   dwNeeded            = 0;
    HRESULT hrResult            = S_OK;


    // Use mapping to see what stickiness of the feature is.
    if(NULL != pMapping)
    {
        *pdwMode = pMapping->dwMode;
        goto Exit;
    }

    // By default make feature Document sticky, if we don't have mapping.
    *pdwMode = OEMCUIP_DOCPROP;

    // Try to use Helper to determine stickiness.
    hrResult = Helper.GetFeatureAttribute(poemuiobj, 
                                          0, 
                                          pszKeyword, 
                                          "OpenGroupType", 
                                          &dwType, 
                                          (PBYTE) szGroupType,
                                          sizeof(szGroupType), 
                                          &dwNeeded);
    if(SUCCEEDED(hrResult))
    {
        // INVARIANT:  found out if feature is an installable option.
        //             Installable options are the only PPD features
        //             that are Printer sticky.

        if(!lstrcmpA(szGroupType, "InstallableOptions"))
        {
            *pdwMode = OEMCUIP_PRNPROP;
        }
        goto Exit;
    }


Exit:

    return hrResult;
}

// Find the mapping entry from the keyword.
PKEYWORDMAP FindKeywordMapping(PKEYWORDMAP pKeywordMap, WORD wMapSize, PCSTR pszKeyword)
{
    BOOL        bFound      = FALSE;
    PKEYWORDMAP pMapping    = NULL;


    // Walk mapping array for matching keyword.
    for(WORD wIndex = 0; !bFound && (wIndex < wMapSize); ++wIndex)
    {
        bFound = !lstrcmpA(pszKeyword, pKeywordMap[wIndex].pszKeyword);
        if(bFound)
        {
            pMapping = pKeywordMap + wIndex;
        }
    }

    return pMapping;
}

// Get display name from mapping entry.
HRESULT GetDisplayNameFromMapping(HANDLE hHeap, PKEYWORDMAP pMapping, PWSTR *ppszDisplayName)
{
    HMODULE hModule     = NULL;
    HRESULT hrResult    = S_OK;


    // Validate parameters.
    if( (NULL == hHeap)
        ||
        (NULL == pMapping)
        ||
        (NULL == ppszDisplayName)
      )
    {
        hrResult = E_INVALIDARG;
        goto Exit;
    }

    // Check for simple case of returning INT resource.
    if( (NULL == pMapping->pwszModule) 
        || 
        IS_MAPPING_INT_RESOURCE(pMapping)
      )
    {
        // Just need to do MAKEINTRESOURCE on the resource ID and return.
        *ppszDisplayName = MAKEINTRESOURCE(pMapping->uDisplayNameID);
        goto Exit;
    }

    // We only need to get the module if we aren't loading the resource from
    // this module (i.e. if module name isn't NULL).
    // Also, as an optimization, we assume that the module has already been loaded, 
    // since the only cases currently are this module, driver ui, and Compstui.dll.
    hModule = GetModuleHandle(pMapping->pwszModule);
    if(NULL == hModule)
    {
        DWORD   dwError = GetLastError();


        ERR(ERRORTEXT("GetDisplayNameFromMapping() for failed to load module %s. (Error %d)\r\n"), 
                      pMapping->pwszModule, 
                      dwError); 

        hrResult = HRESULT_FROM_WIN32(dwError);
        goto Exit;
    }

    // INVARIANT:  have handle to module to load resource from or the
    //             resource is being loaded from this module.

    // Get the string resouce.
    hrResult = GetStringResource(hHeap, hModule, pMapping->uDisplayNameID, ppszDisplayName);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("GetDisplayNameFromMapping() failed to load string. (hrResult = 0x%x)\r\n"), 
                      hrResult); 
        goto Exit;
    }


Exit:

    return hrResult;
}

// Test if an OPTITEM is an OPTITEM for a feature.
// Macro for testing if OPTITEM is feature OPTITEM
BOOL IsFeatureOptitem(POPTITEM pOptItem)
{
    BOOL                bRet    = FALSE;
    PFEATUREOPTITEMDATA pData   = NULL;


    // Make sure pointers are NULL.
    if( (NULL == pOptItem)
        ||
        (NULL == pOptItem->UserData)
       )
    {
        // INVARIANT:  can't be feature OPTITEM, since one of 
        //             the necessary pointer are NULL.

        return FALSE;
    }

    // For convienience, assign to pointer to feature OPTITEM data.
    pData = (PFEATUREOPTITEMDATA)(pOptItem->UserData);

    // Check size and tag.
    bRet = (sizeof(FEATUREOPTITEMDATA) == pData->dwSize) 
           &&
           (FEATURE_OPTITEM_TAG == pData->dwTag); 
        
    return bRet;
}



// Walks array of OPTITEMs saving each feature OPTITEM
// that has changed.
HRESULT SaveFeatureOptItems(HANDLE hHeap, 
                            CUIHelper *pHelper, 
                            POEMUIOBJ poemuiobj,
                            HWND hWnd,
                            POPTITEM pOptItem,
                            WORD wItems)
{
    PSTR        pmszPairs           = NULL;
    WORD        wPairs              = 0;
    WORD        wConflicts          = 0;
    WORD        wReasons            = 0;
    DWORD       dwSize              = 0;
    DWORD       dwResult            = 0;
    PCSTR       *ppszReasons        = NULL;
    PWSTR       pszConfilictFeature = NULL;
    PWSTR       pszConfilictOption  = NULL;
    PWSTR       pszCaption          = NULL;
    PWSTR       pszFormat           = NULL;
    PWSTR       pszMessage          = NULL;
    HRESULT     hrResult            = S_OK;


    // Validate parameters
    if( (NULL == hHeap)
        ||
        (NULL == pHelper)
        ||
        (NULL == pOptItem)
      )
    {
        ERR(ERRORTEXT("SaveFeatureOptItems() called with invalid parameters.\r\n"));

        hrResult = E_INVALIDARG;
        goto Exit;
    }

    // Get feature option pairs to save.
    hrResult = GetChangedFeatureOptions(hHeap, pOptItem, wItems, &pmszPairs, &wPairs, &dwSize);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("SaveFeatureOptItems() failed to get changed feature option pairs. (hrResult = 0x%x)\r\n"),
                       hrResult);

        goto Exit;
    }

    // Don't need to do anything more if no feature options changed.
    if(0 == wPairs)
    {
        VERBOSE(DLLTEXT("SaveFeatureOptItems() no feature options that need to be set.\r\n"));

        goto Exit;
    }

    // Set the change feature options.
    // For the first SetOptions() call, don't have the
    // core driver UI resolve conflicts, so we can
    // prompt user for automatic resolution or let
    // them do the conflict resolving.
    hrResult = pHelper->SetOptions(poemuiobj, 
                                   SETOPTIONS_FLAG_KEEP_CONFLICT, 
                                   pmszPairs, 
                                   dwSize,
                                   &dwResult);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("SaveFeatureOptItems() call to SetOptions() failed. (hrResult = 0x%x, dwResult = %d\r\n"),
                       hrResult,
                       dwResult);

        goto Exit;
    }

    // Check to see if we were able to save changed feature options,
    // or if there is a conflict that needs resolution.
    if(SETOPTIONS_RESULT_CONFLICT_REMAINED == dwResult)
    {
        int         nRet;
        DWORD       dwRet;
        CONFLICT    Conflict;
        PKEYWORDMAP pMapping    = NULL;


        // INVARIANT:  constraint conflict, options weren't saved.

        // Get list of all features that have conflict.
        hrResult = GetFirstConflictingFeature(hHeap, 
                                              pHelper, 
                                              poemuiobj, 
                                              pOptItem, 
                                              wItems, 
                                              &Conflict);
        if(!SUCCEEDED(hrResult))
        {
            goto Exit;
        }

        // Create string pointer list in to multi-sz of first conflict.
        hrResult = MakeStrPtrList(hHeap, Conflict.pmszReasons, &ppszReasons, &wReasons);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("SaveFeatureOptItems() failed to make string list for conflict reasons. (hrResult = 0x%x)\r\n"), 
                           hrResult);

            goto Exit;
        }

        //
        // Get display versions of feature/option conflict reason.
        //

        // Get or build a keyword mapping entry
        // that maps from keyword to usefully where to get info, such as 
        // display name, icon, option type, for keywords that may not be
        // able to get info for from Helper.
        pMapping = FindKeywordMapping(gkmFeatureMap, NUM_FEATURE_MAP, ppszReasons[0]);

        // Get display names for each of the featurs.
        // The function implements a heuristic for detemining the display name,
        // since can't get the display name from the UI Helper for all features.
        hrResult = DetermineFeatureDisplayName(hHeap, 
                                               *pHelper, 
                                               poemuiobj, 
                                               ppszReasons[0],
                                               pMapping,
                                               &pszConfilictFeature);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("SaveFeatureOptItems failed to get display name for feature %hs. (hrResult = 0x%x)\r\n"), 
                          ppszReasons[0], 
                          hrResult); 

            goto Exit;
        }

        // Get or build a keyword mapping entry
        // that maps from keyword to usefully where to get info, such as 
        // display name, icon, option type, for keywords that may not be
        // able to get info for from Helper.
        pMapping = FindKeywordMapping(gkmOptionMap, NUM_OPTION_MAP, ppszReasons[1]);

        // Get option display name.
        hrResult = DetermineOptionDisplayName(hHeap, 
                                              *pHelper, 
                                              poemuiobj, 
                                              ppszReasons[0],
                                              ppszReasons[1],
                                              pMapping,
                                              &pszConfilictOption);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("SaveFeatureOptItems() failed to get display name for %hs of feature %hs. (hrResult = 0x%x)\r\n"), 
                          ppszReasons[1], 
                          ppszReasons[0],
                          hrResult); 

            goto Exit;
        }

        //
        // Prompt user about how to resolve conflict.
        //

        // Get caption name.
        hrResult = GetStringResource(hHeap, ghInstance, IDS_NAME, &pszCaption);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("SaveFeatureOptItems() failed to get caption name. (hrResult = 0x%x)\r\n"),
                          hrResult); 
            goto Exit;
        }

        // Get message body format string.
        hrResult = GetStringResource(hHeap, ghInstance, IDS_CONSTRAINT_CONFLICT, &pszFormat);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("SaveFeatureOptItems() failed to get constraint conflict format. (hrResult = 0x%x)\r\n"),
                          hrResult); 
            goto Exit;
        }


        // Get messsage body.
        PVOID   paArgs[4] = {pszConfilictFeature, 
                             pszConfilictOption,
                             const_cast<PWSTR>(Conflict.pszFeature),
                             Conflict.pszOption
                            };
        dwRet = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                              pszFormat,
                              0,
                              0,
                              (PWSTR) &pszMessage,
                              0,
                              (va_list *) paArgs);
        if(0 == dwRet)
        {
            DWORD   dwError = GetLastError();

            ERR(ERRORTEXT("SaveFeatureOptItems() failed to FormatMessage() for constraint conflict of feature %hs option %hs. (Last Error %d)\r\n"),
                          Conflict.pszFeatureKeyword,
                          Conflict.pszOptionKeyword,
                          dwError);

            hrResult = HRESULT_FROM_WIN32(dwError);
            goto Exit;
        }

        // Display simple message box with prompt.
        nRet = MessageBox(hWnd, pszMessage, pszCaption, MB_YESNO | MB_ICONWARNING);

        // Check to see how user wants to resolve conflict.
        if(IDYES == nRet)
        {
            // Let core driver resolve conflict resolution.
            hrResult = pHelper->SetOptions(poemuiobj, 
                                           SETOPTIONS_FLAG_RESOLVE_CONFLICT, 
                                           pmszPairs, 
                                           dwSize,
                                           &dwResult);

            // Conflict resolution requires refreshing current option
            // selection for each feature, since selection may have
            // changed because of conflict resolution.
            RefreshOptItemSelection(pHelper, poemuiobj, pOptItem, wItems);
        }

        // Return failure if there are still conflictts.
        if(SETOPTIONS_RESULT_CONFLICT_REMAINED == dwResult)
        {
            hrResult = E_FAIL;
        }
    }


Exit:

    // Clean up...

    // cleanup heap allocs.
    if(NULL != pmszPairs)       HeapFree(hHeap, 0, pmszPairs);
    if(NULL != ppszReasons)         HeapFree(hHeap, 0, ppszReasons);
    if(NULL != pszConfilictFeature) HeapFree(hHeap, 0, pszConfilictFeature);
    if(NULL != pszConfilictOption)  HeapFree(hHeap, 0, pszConfilictOption);
    if(NULL != pszCaption)          HeapFree(hHeap, 0, pszCaption);
    if(NULL != pszFormat)           HeapFree(hHeap, 0, pszFormat);
    if(NULL != pszMessage)          LocalFree(pszMessage);

    return hrResult;
}

// Allocates buffer, if needed, and calls IPrintCoreUI2::WhyConsrained
// to get reason for constraint.
HRESULT GetWhyConstrained(HANDLE hHeap, 
                          CUIHelper *pHelper, 
                          POEMUIOBJ poemuiobj,
                          PCSTR pszFeature,
                          PCSTR pszOption,
                          PSTR *ppmszReason,
                          PDWORD pdwSize)
{
    PSTR    pmszReasonList  = *ppmszReason;
    DWORD   dwNeeded        = 0;
    HRESULT hrResult        = S_OK;


    // If buffer wasn't passed in, then allocate one.
    if( (NULL == pmszReasonList) || (0 == *pdwSize) )
    {
        // If no size or size is smaller than default, then change to default
        // size.  We want to try to only allocate and call once.
        if(*pdwSize < INITIAL_GET_REASON_SIZE) 
        {
            *pdwSize = INITIAL_GET_REASON_SIZE;
        }

        // Alloc initial buffer for reason constrained.
        pmszReasonList = (PSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, *pdwSize);
        if(NULL == pmszReasonList)
        {
            ERR(ERRORTEXT("GetWhyConstrained() failed to alloc buffer for constraint reasons for feature %hs and option %hs.\r\n"),
                           pszFeature,
                           pszOption);

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    // Get reason for constraint.
    hrResult = pHelper->WhyConstrained(poemuiobj,
                                       0, 
                                       pszFeature, 
                                       pszOption, 
                                       pmszReasonList, 
                                       *pdwSize, 
                                       &dwNeeded);
    if( (E_OUTOFMEMORY == hrResult) 
        && 
        (*pdwSize < dwNeeded)
      )
    {
        PSTR    pTemp;


        // INVARIANT:  initial buffer not large enough.

        // Re-alloc buffer to needed size.
        pTemp = (PSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, pmszReasonList, dwNeeded);
        if(NULL == pTemp)
        {
            ERR(ERRORTEXT("GetWhyConstrained() failed to re-allocate buffer for constraint reason for feature %hs and option %hs.\r\n"),
                           pszFeature,
                           pszOption);

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }
        pmszReasonList  = pTemp;
        *pdwSize        = dwNeeded;

        // Retry getting constaint reason.
        hrResult = pHelper->WhyConstrained(poemuiobj,
                                           0, 
                                           pszFeature, 
                                           pszOption, 
                                           pmszReasonList, 
                                           *pdwSize, 
                                           &dwNeeded);
    }


Exit:

    // On error, do clean up.
    if(!SUCCEEDED(hrResult))
    {
        // Free reason buffer.
        if(NULL != pmszReasonList) HeapFree(hHeap, 0, pmszReasonList);

        // Return NULL and zero size.
        *ppmszReason    = NULL;
        *pdwSize        = 0;
    }
    else
    {
        *ppmszReason = pmszReasonList;
    }

    return hrResult;
}

// Creates multi-sz list of feature option pairs that have changed.
HRESULT GetChangedFeatureOptions(HANDLE hHeap,
                                 POPTITEM pOptItem, 
                                 WORD wItems, 
                                 PSTR *ppmszPairs, 
                                 PWORD pwPairs,
                                 PDWORD pdwSize)
{
    WORD                wCount      = 0;
    WORD                wChanged    = 0;
    WORD                wPairs      = 0;
    PSTR                pmszPairs   = NULL;
    DWORD               dwNeeded    = 2;
    DWORD               dwOffset    = 0;
    HRESULT             hrResult    = S_OK;
    PFEATUREOPTITEMDATA pData       = NULL;


    // Walk OPTITEM array looking or changed options,
    // and calculating size needed for multi-sz buffer.
    for(wCount = 0; wCount < wItems; ++wCount)
    {
        PSTR    pszOption   = NULL;


        // Just go to next item if this OPTITEM hasn't 
        // changed or isn't a feature OPTITEM.
        if( !(OPTIF_CHANGEONCE & pOptItem[wCount].Flags) 
            ||
            !IsFeatureOptitem(pOptItem + wCount)
          )
        {
            continue;
        }

        // For convienience, assign to pointer to feature OPTITEM data.
        pData = (PFEATUREOPTITEMDATA)(pOptItem[wCount].UserData);

        // Increment options changed and size needed.
        pszOption = GetOptionKeywordFromOptItem(hHeap, pOptItem + wCount);
        if(NULL != pszOption)
        {
            ++wChanged;
            dwNeeded += lstrlenA(pData->pszFeatureKeyword) + lstrlenA(pszOption) + 2;

            // Need to free option keyword string copy
            // allocated in GetOptionKeywordFromOptItem().
            HeapFree(hHeap, 0, pszOption);
        }
    }

    // Don't need to do anything more if no feature options changed.
    if(0 == wChanged)
    {
        goto Exit;
    }

    // Allocate multi-sz buffer.
    pmszPairs = (PSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwNeeded);
    if(NULL == pmszPairs)
    {
        ERR(ERRORTEXT("GetChangedFeatureOptions() failed to allocate multi-sz.\r\n"));

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // Build mult-sz list of feature option pairs
    // that changed.
    for(wCount = 0, wPairs = 0; (wCount < wItems) && (wPairs < wChanged); ++wCount)
    {
        PSTR    pszOption   = NULL;


        // Just go to next item if this OPTITEM hasn't 
        // changed or isn't a feature OPTITEM.
        if( !(OPTIF_CHANGEONCE & pOptItem[wCount].Flags) 
            ||
            !IsFeatureOptitem(pOptItem + wCount)
          )
        {
            continue;
        }

        // For convienience, assign to pointer to feature OPTITEM data.
        pData = (PFEATUREOPTITEMDATA)(pOptItem[wCount].UserData);

        // Add feature option pair.
        pszOption = GetOptionKeywordFromOptItem(hHeap, pOptItem + wCount);
        if(NULL != pszOption)
        {
            if(dwOffset * sizeof(CHAR) < dwNeeded) 
            {
                break;
            }
            hrResult = StringCbCopyA(pmszPairs + dwOffset, dwNeeded - (dwOffset * sizeof(CHAR)), pData->pszFeatureKeyword);
            dwOffset += lstrlenA(pData->pszFeatureKeyword) + 1;
            if(dwOffset * sizeof(CHAR) < dwNeeded)
            {
                break;
            }
            hrResult = StringCbCopyA(pmszPairs + dwOffset, dwNeeded - (dwOffset * sizeof(CHAR)), pszOption);
            dwOffset += lstrlenA(pszOption) + 1;

            // Keep track of number of pairs added, so
            // we are able to exit loop as soon as
            // we added all changed feature options.
            ++wPairs;

            // Need to free option keyword string copy
            // allocated in GetOptionKeywordFromOptItem().
            HeapFree(hHeap, 0, pszOption);
        }
    }


Exit:

    if(SUCCEEDED(hrResult))
    {
        // INVARIANT: either successfully build mutli-sz of changed
        //            feature option pairs, or there are no feature
        //            that options changed.

        // Return pairs and number of pairs.
        *pwPairs    = wPairs;
        *pdwSize    = dwNeeded;
        *ppmszPairs = pmszPairs;
    }
    else
    {
        // INVARINAT:   error.

        // Clean up.
        if(NULL == pmszPairs)    HeapFree(hHeap, 0, pmszPairs);

        // Return NULL and zero count.
        *pwPairs    = 0;
        *pdwSize    = 0;
        *ppmszPairs = NULL;
    }

    return hrResult;
}

// Returns pointer to option keyword for a feature OPTITEM.
PSTR GetOptionKeywordFromOptItem(HANDLE hHeap, POPTITEM pOptItem)
{
    char                szNumber[16]    = {0};
    PSTR                pszOption       = NULL;
    PFEATUREOPTITEMDATA pData           = NULL;


    // Validate parameter.
    if(!IsFeatureOptitem(pOptItem))
    {
        ERR(ERRORTEXT("GetOptionKeywordFromOptItem() invalid parameter.\r\n"));

        goto Exit;
    }

    // For convienience, assign to pointer to feature OPTITEM data.
    pData = (PFEATUREOPTITEMDATA)(pOptItem->UserData);

    // Option selection is based on type of OPTTYPE.
    switch(pOptItem->pOptType->Type)
    {
        // For up down arrow control, selection is just pOptItem->Sel
        // converted to string.
        case TVOT_UDARROW:
            if(FAILED(StringCbPrintfA(szNumber, sizeof(szNumber)/sizeof(szNumber[0]), "%u", pOptItem->Sel)))
            {
                ERR(ERRORTEXT("GetOptionKeywordFromOptItem() failed to convert number to string.\r\n"));
            }
            szNumber[sizeof(szNumber)/sizeof(szNumber[0]) - 1] = '\0';
            pszOption = MakeStringCopy(hHeap, szNumber);
            break;

        // For combobox, pOptItem->Sel is the index in to the
        // option array.
        case TVOT_COMBOBOX:
            pszOption = MakeStringCopy(hHeap, pData->pOptions->GetKeyword((WORD)pOptItem->Sel));
            break;

        // The default is the option count.
        default:
            ERR(ERRORTEXT("GetOptionKeywordFromOptItem() OPTTYPE type %d num of OPTPARAMs not handled.\r\n"),
                            pOptItem->pOptType->Type);

            goto Exit;
            break;
    }


Exit:

    return pszOption;
}

// Returns pointer to option display name for a feature OPTITEM.
PWSTR GetOptionDisplayNameFromOptItem(HANDLE hHeap, POPTITEM pOptItem)
{
    WCHAR               szNumber[16]    = {0};
    PWSTR               pszOption       = NULL;
    PFEATUREOPTITEMDATA pData           = NULL;


    // Validate parameter.
    if(!IsFeatureOptitem(pOptItem))
    {
        ERR(ERRORTEXT("GetOptionDisplayNameFromOptItem() invalid parameter.\r\n"));

        goto Exit;
    }

    // For convienience, assign to pointer to feature OPTITEM data.
    pData = (PFEATUREOPTITEMDATA)(pOptItem->UserData);

    // Option selection is based on type of OPTTYPE.
    switch(pOptItem->pOptType->Type)
    {
        // For up down arrow control, selection is just pOptItem->Sel
        // converted to string.
        case TVOT_UDARROW:
            if(FAILED(StringCbPrintfW(szNumber, sizeof(szNumber)/sizeof(szNumber[0]), L"%u", pOptItem->Sel)))
            {
                ERR(ERRORTEXT("GetOptionDisplayNameFromOptItem() failed to convert number to string.\r\n"));
            }
            szNumber[sizeof(szNumber)/sizeof(szNumber[0]) - 1] = L'\0';
            pszOption = MakeStringCopy(hHeap, szNumber);
            break;

        // For combobox, pOptItem->Sel is the index in to the
        // option array.
        case TVOT_COMBOBOX:
            pszOption = MakeStringCopy(hHeap, pOptItem->pOptType->pOptParam[pOptItem->Sel].pData);
            break;

        // The default is the option count.
        default:
            ERR(ERRORTEXT("GetOptionDisplayNameFromOptItem() OPTTYPE type %d num of OPTPARAMs not handled.\r\n"),
                            pOptItem->pOptType->Type);

            goto Exit;
            break;
    }


Exit:

    return pszOption;
}

// Refreshes option selection for each feature OPTITEM
HRESULT RefreshOptItemSelection(CUIHelper *pHelper, 
                                POEMUIOBJ poemuiobj, 
                                POPTITEM pOptItems, 
                                WORD wItems)
{
    HRESULT             hrResult    = S_OK;
    PFEATUREOPTITEMDATA pData       = NULL;


    // Walk OPTITEM array refreshing feature OPTITEMs.
    for(WORD wCount = 0; wCount < wItems; ++wCount)
    {
        // Just go to next item if this OPTITEM isn't a feature OPTITEM.
        if(!IsFeatureOptitem(pOptItems + wCount))
        {
            continue;
        }

        // For convienience, assign to pointer to feature OPTITEM data.
        pData = (PFEATUREOPTITEMDATA)(pOptItems[wCount].UserData);

        // Refresh COption selection.
        pData->pOptions->RefreshSelection(*pHelper, poemuiobj);

        // Assign COption selection to OPTITEM selection.
        pOptItems[wCount].pSel = pData->pOptions->GetSelection();

    }

    return hrResult;
}

// Creates array of conflict features.
HRESULT GetFirstConflictingFeature(HANDLE hHeap,
                                   CUIHelper *pHelper, 
                                   POEMUIOBJ poemuiobj, 
                                   POPTITEM pOptItem, 
                                   WORD wItems, 
                                   PCONFLICT pConflict)
{
    WORD                wCount      = 0;
    HRESULT             hrResult    = S_OK;
    PFEATUREOPTITEMDATA pData       = NULL;


    // Walk OPTITEM array looking or changed options that are in conflict.
    for(wCount = 0; wCount < wItems; ++wCount)
    {
        // Just go to next item if this OPTITEM hasn't 
        // changed or isn't a feature OPTITEM.
        if( !(OPTIF_CHANGEONCE & pOptItem[wCount].Flags) 
            ||
            !IsFeatureOptitem(pOptItem + wCount)
          )
        {
            continue;
        }

        // For convienience, assign to pointer to feature OPTITEM data.
        pData = (PFEATUREOPTITEMDATA)(pOptItem[wCount].UserData);

        // Init conflict record if this feature is in conflict.
        pConflict->pszOptionKeyword = GetOptionKeywordFromOptItem(hHeap, pOptItem + wCount);
        if(NULL != pConflict->pszOptionKeyword)
        {
            // Get reason for conflict
            // If the feature isn't in conflict,
            // then the pmszReasonList will start 
            // with NULL terminator.
            hrResult = GetWhyConstrained(hHeap,
                                         pHelper,
                                         poemuiobj,
                                         pData->pszFeatureKeyword, 
                                         pConflict->pszOptionKeyword, 
                                         &pConflict->pmszReasons, 
                                         &pConflict->dwReasonsSize);
            if(!SUCCEEDED(hrResult))
            {
                // NOTE: driver features aren't supported by WhyConstrained.
                if((E_INVALIDARG == hrResult) && IS_DRIVER_FEATURE(pData->pszFeatureKeyword))
                {
                    // Need to reset the result in case it is the last
                    // feature OPTITEM.
                    hrResult = S_OK;
                    continue;
                }

                ERR(ERRORTEXT("GetConflictingFeatures() failed to get reason for feature %hs option %hs constraint. (hrResult = 0x%x)\r\n"),
                               pData->pszFeatureKeyword,
                               pConflict->pszOptionKeyword,
                               hrResult);

                goto Exit;
            }

            // Record conflict if feature is in conflict.
            if( (NULL != pConflict->pmszReasons) 
                && 
                (pConflict->pmszReasons[0] != '\0')
              )
            {
                // Save pointer to feature keyword.
                pConflict->pszFeatureKeyword = pData->pszFeatureKeyword;
                pConflict->pszFeature        = pOptItem[wCount].pName;
                pConflict->pszOption         = GetOptionDisplayNameFromOptItem(hHeap, pOptItem + wCount);

                // Found first conflict.
                break;
            }
        }
    }


Exit:

    return hrResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'
#define MAX_LOOP                10



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize      = DEBUG_BUFFER_SIZE;
    DWORD   dwLoop      = 0;
    LPSTR   lpszMsgBuf  = NULL;
    HRESULT hr;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
        {
            return FALSE;
        }

        hr = StringCbVPrintfA(lpszMsgBuf, (dwSize + 1) * sizeof(CHAR), lpszMessage, arglist);

    // Pass the variable parameters to wvsprintf to be formated.
    } while (FAILED(hr) && (STRSAFE_E_INSUFFICIENT_BUFFER == hr) && (++dwLoop < MAX_LOOP) );

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return SUCCEEDED(hr);
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR      lpszMsgBuf;
    HRESULT     hResult;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    hResult = StringCbVPrintfW(lpszMsgBuf, (dwSize + 1) * sizeof(WCHAR), lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return SUCCEEDED(hResult);
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(TEXT("pPublisherInfo:\r\n"));
    if(NULL == pPublisherInfo)
    {
        VERBOSE(TEXT("\tpPublisherInfo is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(TEXT("pOemDMParam:\r\n"));
    if(NULL == pOemDMParam)
    {
        VERBOSE(TEXT("\tpOemDMParam is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}

void Dump(PPROPSHEETUI_INFO pPSUIInfo)
{
    VERBOSE(TEXT("pPSUIInfo:\r\n"));
    if(NULL == pPSUIInfo)
    {
        VERBOSE(TEXT("\tpPSUIInfo is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize          = %d\r\n"), pPSUIInfo->cbSize);
    VERBOSE(TEXT("\tVersion         = %#x\r\n"), pPSUIInfo->Version);
    VERBOSE(TEXT("\tFlags           = %#x\r\n"), pPSUIInfo->Flags);
    VERBOSE(TEXT("\tReason          = %d\r\n"), pPSUIInfo->Reason);
    VERBOSE(TEXT("\thComPropSheet   = %#x\r\n"), pPSUIInfo->hComPropSheet);
    VERBOSE(TEXT("\tpfnComPropSheet = %#x\r\n"), pPSUIInfo->pfnComPropSheet);
    VERBOSE(TEXT("\tlParamInit      = %#x\r\n"), pPSUIInfo->lParamInit);
    VERBOSE(TEXT("\tUserData        = %#x\r\n"), pPSUIInfo->UserData);
    VERBOSE(TEXT("\tResult          = %#x\r\n"), pPSUIInfo->Result);
}

void Dump(POPTITEM pOptItem)
{
    VERBOSE(TEXT("pOptItem:\r\n"));
    if(NULL == pOptItem)
    {
        VERBOSE(TEXT("\tpOptItem is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize          = %d\r\n"),     pOptItem->cbSize);
    VERBOSE(TEXT("\tLevel           = %d\r\n"),     pOptItem->Level);
    VERBOSE(TEXT("\tDlgPageIdx      = %d\r\n"),     pOptItem->DlgPageIdx);
    VERBOSE(TEXT("\tFlags           = 0x%x\r\n"),   pOptItem->Flags);
    VERBOSE(TEXT("\tUserData        = 0x%p\r\n"),   pOptItem->UserData);
    VERBOSE(TEXT("\tpName           = %s\r\n"),     pOptItem->pName ? pOptItem->pName : TEXT("<NULL>"));
    VERBOSE(TEXT("\tpSel            = 0x%p\r\n"),   pOptItem->pSel);
    VERBOSE(TEXT("\tpExtChkBox      = 0x%p\r\n"),   pOptItem->pExtChkBox);
    VERBOSE(TEXT("\tpExtChkBox      = 0x%p\r\n"),   pOptItem->pExtChkBox);
    VERBOSE(TEXT("\tHelpIndex       = 0x%x\r\n"),   pOptItem->HelpIndex);
    VERBOSE(TEXT("\tDMPubID         = 0x%x\r\n"),   pOptItem->DMPubID);
    VERBOSE(TEXT("\tUserItemID      = 0x%x\r\n"),   pOptItem->UserItemID);
    VERBOSE(TEXT("\twReserved       = 0x%x\r\n"),   pOptItem->wReserved);
    VERBOSE(TEXT("\tpOIExt          = 0x%p\r\n"),   pOptItem->pOIExt);

    Dump(pOptItem->pOptType);
}

void Dump(POPTTYPE pOptType)
{
    VERBOSE(TEXT("\tpOptType:\r\n"));
    if(NULL == pOptType)
    {
        VERBOSE(TEXT("\t\tpOptType is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\t\tcbSize    = %d\r\n"),     pOptType->cbSize);
    VERBOSE(TEXT("\t\tType      = 0x%x\r\n"),   pOptType->Type);
    VERBOSE(TEXT("\t\tFlags     = 0x%x\r\n"),   pOptType->Flags);
    VERBOSE(TEXT("\t\tCount     = %d\r\n"),     pOptType->Count);
    VERBOSE(TEXT("\t\tCount     = 0x%x\r\n"),   pOptType->BegCtrlID);
    VERBOSE(TEXT("\t\tStyle     = 0x%x\r\n"),   pOptType->Style);

    Dump(pOptType->pOptParam, pOptType->Count);
}

void Dump(POPTPARAM pOptParam, WORD wCount)
{
    if(NULL == pOptParam)
    {
        VERBOSE(TEXT("\t\tpOptParam is NULL!\r\n"));
        return;
    }

    for(WORD wIndex = 0; wIndex < wCount; ++wIndex)
    {
        VERBOSE(TEXT("\t\tpOptParam[wIndex]:\r\n"));
        VERBOSE(TEXT("\t\t\tcbSize    = %d\r\n"),     pOptParam[wIndex].cbSize);
        VERBOSE(TEXT("\t\t\tFlags     = 0x%x\r\n"),   pOptParam[wIndex].Flags);
        VERBOSE(TEXT("\t\t\tStyle     = 0x%x\r\n"),   pOptParam[wIndex].Style);
        VERBOSE(TEXT("\t\t\tpData     = 0x%p\r\n"),   pOptParam[wIndex].pData);
        VERBOSE(TEXT("\t\t\tIconID    = 0x%p\r\n"),   pOptParam[wIndex].IconID);
        VERBOSE(TEXT("\t\t\tlParam    = 0x%p\r\n"),   pOptParam[wIndex].lParam);
    }
}


PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\features.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  2001 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Features.h
//    
//
//  PURPOSE:	Defines wrapper class for WinXP PS Features and Options.
//
//
//  PLATFORMS:    Windows XP, Windows Server 2003
//
//
#ifndef _FEATURES_H
#define _FEATURES_H

#include "precomp.h"
#include "helper.h"


////////////////////////////////////////////////////////
//      Defines and Macros
////////////////////////////////////////////////////////



////////////////////////////////////////////////////////
//      Type Definitions
////////////////////////////////////////////////////////

// Struct used to map keyword to information
// such as display name and stickiness.
typedef struct _tagKeywordMap
{
    PCSTR   pszKeyword;
    PCWSTR  pwszModule;
    UINT    uDisplayNameID;
    DWORD   dwMode;
    DWORD   dwFlags;

} KEYWORDMAP, *PKEYWORDMAP;


// Struct container for info about
// feature that is in conflict.
typedef struct  _tagConflict
{
    PCSTR   pszFeatureKeyword;
    PCWSTR  pszFeature;
    PSTR    pszOptionKeyword;
    PWSTR   pszOption;
    PSTR    pmszReasons;
    DWORD   dwReasonsSize;

} CONFLICT, *PCONFLICT;



////////////////////////////////////////////////////////
//      Class Definitions
////////////////////////////////////////////////////////

// Class wrapper and container for Core Driver Feature Options.
class COptions
{
    private:

        // Option Infomation
        class OPTION_INFO
        {
            public:
                PKEYWORDMAP pMapping;
                PWSTR       pszDisplayName;

            public:
                OPTION_INFO()
                {
                    pMapping        = NULL;
                    pszDisplayName  = NULL;
                }

                virtual ~OPTION_INFO(){}
        };
        typedef class OPTION_INFO   *POPTION_INFO;

        // Data Members
        WORD            m_wOptions;     // Count of the number of options contained for an instance of the class.
        BYTE            m_cType;        // CPSUI Option Type (i.e. what to set pOptItem->pOptType->Type to).
        PSTR            m_pmszRaw;      // The RAW multi NULL terminated string buffer used for IPrintCoreUI2::EnumOptions().
        PCSTR           m_pszFeature;   // Pointer to the feature for which the enumerate options belong.
        PCSTR          *m_ppszOptions;  // String list pointer that points to begining of each of the strings in multi-SZ pointed to by m_pmszRaw.
        POINT           m_ptRange;      // Option range for features, such as %JobTimeout, that have a range of possible vaules not a small selection list.
        DWORD           m_dwSize;       // Size of m_pmszRaw buffer.
        PWSTR           m_pszUnits;     // String that contains the unit specifier for options, such as %JobTimeout, which need Units (i.e. seconds).
        HANDLE          m_hHeap;        // Heap to do allocations from.
        POPTION_INFO    m_pInfo;        // Array of Info about each option for a feature.

        union {                         // Current selected option for a feature.
            LONG    m_Sel;              // This is what pOptItem->m_pSel or pOptItem->m_Sel
            LPTSTR  m_pSel;             // will be set to.
        };

    public:
        COptions();
        virtual ~COptions();

        // Populate Options list for specified keyword.
        HRESULT COptions::Acquire(HANDLE hHeap, CUIHelper &Helper, POEMUIOBJ poemuiobj, 
                                  PCSTR pszFeature);

        // Returns number of feature options contained in class instance.
        inline WORD GetCount() const {return m_wOptions;}

        // Returns selection.
        inline LPTSTR GetSelection() const {return m_pSel;}

        // Return nth options keyword.
        PCSTR GetKeyword(WORD wIndex) const;

        // Return nth option Display Name.
        PCWSTR GetName(WORD wIndex) const;

        // Find option with matching keyword string.
        WORD FindOption(PCSTR pszOption, WORD wDefault) const;

        // Initializes options portion of OPTITEM.
        HRESULT InitOptItem(HANDLE hHeap, POPTITEM pOptItem);

        // Refresh option selection.
        HRESULT RefreshSelection(CUIHelper &Helper, POEMUIOBJ poemuiobj);

    private:
        void Init();
        void Clear();
        void FreeOptionInfo();
        HRESULT GetOptionsForSpecialFeatures(CUIHelper &Helper, POEMUIOBJ poemuiobj);
        HRESULT GetOptionsForOutputPSLevel(CUIHelper &Helper, POEMUIOBJ poemuiobj);
        HRESULT GetOptionSelectionString(CUIHelper &Helper, POEMUIOBJ poemuiobj, PSTR *ppszSel);
        HRESULT GetOptionSelectionLong(CUIHelper &Helper, POEMUIOBJ poemuiobj);
        HRESULT GetOptionSelectionShort(CUIHelper &Helper, POEMUIOBJ poemuiobj);
        HRESULT GetOptionSelectionIndex(CUIHelper &Helper, POEMUIOBJ poemuiobj);
};


// Class wrapper and container for Cor Driver Features.
class CFeatures
{
    private:

        // Feature Infomation
        class FEATURE_INFO
        {
            public:
                PKEYWORDMAP pMapping;
                PWSTR       pszDisplayName;
                COptions    Options;
                DWORD       dwMode;

            public:
                FEATURE_INFO()
                {
                    pMapping        = NULL;
                    pszDisplayName  = NULL;
                    dwMode          = 0;
                }

                virtual ~FEATURE_INFO() {}
        };
        typedef class FEATURE_INFO  *PFEATURE_INFO;

        WORD            m_wFeatures;        // Count of the number of features.
        WORD            m_wDocFeatures;     // Count of the number of Document sticky features.
        WORD            m_wPrintFeatures;   // Count of the number of Printer sticky features.
        PSTR            m_pmszRaw;          // Buffer for multi-SZ for call to IPrintCoreUI2::EnumFeatures.
        PCSTR          *m_ppszKeywords;     // String list that points to each of the strings in m_pmszRaw.
        DWORD           m_dwSize;           // Size of m_pmszRaw.
        HANDLE          m_hHeap;            // Heap to do allocations from.           
        PFEATURE_INFO   m_pInfo;            // Array of feature information about each of the enumerate features.

    public:
        CFeatures();
        virtual ~CFeatures();

        // Populates the Feature list
        HRESULT Acquire(HANDLE hHeap, CUIHelper &Helper, POEMUIOBJ poemuiobj);

        // Returns number of features contained in class instance.
        WORD GetCount(DWORD dwMode = 0) const;

        // Returns feature keyword.
        PCSTR GetKeyword(WORD wIndex, DWORD dwMode = 0) const;

        // Return feature Display Name.
        PCWSTR GetName(WORD wIndex, DWORD dwMode = 0) const;

        // Returns pointer to option class for nth feature.
        COptions* GetOptions(WORD wIndex, DWORD dwMode = 0) const;

        // Initializes OPTITEM for the feature.
        HRESULT InitOptItem(HANDLE hHeap, POPTITEM pOptItem, WORD wIndex, DWORD dwMode);

    private:
        void Init();
        void Clear();
        void FreeFeatureInfo();
        WORD GetModelessIndex(WORD wIndex, DWORD dwMode) const;
};



////////////////////////////////////////////////////////
//      Prototypes
////////////////////////////////////////////////////////

HRESULT DetermineFeatureDisplayName(HANDLE hHeap, CUIHelper &Helper, POEMUIOBJ poemuiobj, 
                                    PCSTR pszKeyword, const PKEYWORDMAP pMapping, 
                                    PWSTR *ppszDisplayName);
HRESULT DetermineOptionDisplayName(HANDLE hHeap, CUIHelper &Helper, POEMUIOBJ poemuiobj, 
                                   PCSTR pszFeature, PCSTR pszOption, 
                                   const PKEYWORDMAP pMapping, PWSTR *ppszDisplayName);
HRESULT DetermineStickiness(CUIHelper &Helper, POEMUIOBJ poemuiobj, PCSTR pszKeyword,
                            const PKEYWORDMAP pMapping,PDWORD pdwMode);

PKEYWORDMAP FindKeywordMapping(PKEYWORDMAP pKeywordMap, WORD wMapSize, PCSTR pszKeyword);
HRESULT GetDisplayNameFromMapping(HANDLE hHeap, PKEYWORDMAP pMapping, PWSTR *ppszDisplayName);

BOOL IsFeatureOptitem(POPTITEM pOptItem);
HRESULT SaveFeatureOptItems(HANDLE hHeap, CUIHelper *pHelper, POEMUIOBJ poemuiobj, 
                            HWND hWnd, POPTITEM pOptItem, WORD wItems);
HRESULT GetWhyConstrained(HANDLE hHeap, CUIHelper *pHelper, POEMUIOBJ poemuiobj,
                          PCSTR pszFeature, PCSTR pszOption, PSTR *ppmszReason,
                          PDWORD pdwSize);
HRESULT GetChangedFeatureOptions(HANDLE hHeap, POPTITEM pOptItem, WORD wItems, 
                                 PSTR *ppmszPairs, PWORD pdwPairs, PDWORD pdwSize);
PSTR GetOptionKeywordFromOptItem(HANDLE hHeap, POPTITEM pOptItem);
PWSTR GetOptionDisplayNameFromOptItem(HANDLE hHeap, POPTITEM pOptItem);
HRESULT RefreshOptItemSelection(CUIHelper *pHelper, POEMUIOBJ poemuiobj, POPTITEM pOptItems, 
                                WORD wItems);
HRESULT GetFirstConflictingFeature(HANDLE hHeap, CUIHelper *pHelper, POEMUIOBJ poemuiobj, 
                                   POPTITEM pOptItem, WORD wItems, PCONFLICT pConflict);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\devmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Devmode.cpp
//    
//
//  PURPOSE:  Implementation of Devmode functions shared with OEM UI and OEM rendering modules.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oemui.h"
#include "debug.h"
#include "devmode.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam)
{
    POEMDEV pOEMDevIn;
    POEMDEV pOEMDevOut;


    // Verify parameters.
    if( (NULL == pOemDMParam)
        ||
        ( (OEMDM_SIZE != dwMode)
          &&
          (OEMDM_DEFAULT != dwMode)
          &&
          (OEMDM_CONVERT != dwMode)
          &&
          (OEMDM_MERGE != dwMode)
        )
      )
    {
        ERR(ERRORTEXT("DevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOemDMParam = %#lx.\r\n"), dwMode, pOemDMParam);

        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Cast generic (i.e. PVOID) to OEM private devomode pointer type.
    pOEMDevIn = (POEMDEV) pOemDMParam->pOEMDMIn;
    pOEMDevOut = (POEMDEV) pOemDMParam->pOEMDMOut;

    switch(dwMode)
    {
        case OEMDM_SIZE:
            pOemDMParam->cbBufSize = sizeof(OEMDEV);
            break;

        case OEMDM_DEFAULT:
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
            pOEMDevOut->dwDriverData            = 0;
            pOEMDevOut->dwAdvancedData          = 0;
            VERBOSE(DLLTEXT("pOEMDevOut after setting default values:\r\n"));
            Dump(pOEMDevOut);
            break;

        case OEMDM_CONVERT:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut, pOemDMParam->cbBufSize);
            break;

        case OEMDM_MERGE:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut, pOemDMParam->cbBufSize);
            MakeOEMDevmodeValid(pOEMDevOut);
            break;
    }
    Dump(pOemDMParam);

    return S_OK;
}


BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut, DWORD dwSize)
{
    if( (NULL == pOEMDevIn)
        ||
        (NULL == pOEMDevOut)
        ||
        (dwSize < sizeof(OEMDEV))
      )
    {
        ERR(ERRORTEXT("ConvertOEMDevmode() invalid parameters.\r\n"));
        return FALSE;
    }

    // Check OEM Signature, if it doesn't match ours,
    // then just assume DMIn is bad and use defaults.
    if(pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature)
    {
        VERBOSE(DLLTEXT("Converting private OEM Devmode.\r\n"));
        VERBOSE(DLLTEXT("pOEMDevIn:\r\n"));
        Dump(pOEMDevIn);

        // Set the devmode defaults so that anything the isn't copied over will
        // be set to the default value.
        pOEMDevOut->dwDriverData    = 0;
        pOEMDevOut->dwAdvancedData  = 0;

        // Copy the old structure in to the new using which ever size is the smaller.
        // Devmode maybe from newer Devmode (not likely since there is only one), or
        // Devmode maybe a newer Devmode, in which case it maybe larger,
        // but the first part of the structure should be the same.

        // DESIGN ASSUMPTION: the private DEVMODE structure only gets added to;
        // the fields that are in the DEVMODE never change only new fields get added to the end.

        memcpy(pOEMDevOut, pOEMDevIn, __min(dwSize, __min(pOEMDevOut->dmOEMExtra.dwSize, pOEMDevIn->dmOEMExtra.dwSize)));

        // Re-fill in the size and version fields to indicated 
        // that the DEVMODE is the current private DEVMODE version.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
    }
    else
    {
        WARNING(DLLTEXT("Unknown DEVMODE signature, pOEMDMIn ignored.\r\n"));

        // Don't know what the input DEVMODE is, so just use defaults.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
        pOEMDevOut->dwDriverData            = 0;
        pOEMDevOut->dwAdvancedData          = 0;
    }

    return TRUE;
}


BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode)
{
    if(NULL == pOEMDevmode)
    {
        return FALSE;
    }

    // ASSUMPTION: pOEMDevmode is large enough to contain OEMDEV structure.

    // Make sure that dmOEMExtra indicates the current OEMDEV structure.
    pOEMDevmode->dmOEMExtra.dwSize       = sizeof(OEMDEV);
    pOEMDevmode->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
    pOEMDevmode->dmOEMExtra.dwVersion    = OEM_VERSION;

    // Set driver data, if not valid.
    if(pOEMDevmode->dwDriverData > 100)
    {
        pOEMDevmode->dwDriverData = 0;
    }

    // Set Advanced driver data, if not valid.
    if(pOEMDevmode->dwAdvancedData > 100)
    {
        pOEMDevmode->dwAdvancedData = 0;
    }

    return TRUE;
}


void Dump(PCOEMDEV pOEMDevmode)
{
    if( (NULL != pOEMDevmode)
        &&
        (pOEMDevmode->dmOEMExtra.dwSize >= sizeof(OEMDEV))
        &&
        (OEM_SIGNATURE == pOEMDevmode->dmOEMExtra.dwSignature)
      )
    {
        VERBOSE(TEXT("\tdmOEMExtra.dwSize      = %d\r\n"), pOEMDevmode->dmOEMExtra.dwSize);
        VERBOSE(TEXT("\tdmOEMExtra.dwSignature = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwSignature);
        VERBOSE(TEXT("\tdmOEMExtra.dwVersion   = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwVersion);
        VERBOSE(TEXT("\tdwDriverData           = %#x\r\n"), pOEMDevmode->dwDriverData);
        VERBOSE(TEXT("\tdwAdvancedData         = %#x\r\n"), pOEMDevmode->dwAdvancedData);
    }
    else
    {
        ERR(ERRORTEXT("Dump(POEMDEV) unknown private OEM DEVMODE.\r\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oemui.h"
#include "debug.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));
            ghInstance = hInst;
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}


}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\helper.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  2001 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Helper.cpp
//    
//
//  PURPOSE:  Implementation of wrapper class for Driver UI Helper interface.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include <PRCOMOEM.H>
#include "Helper.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>




////////////////////////////////////////////////////////
//      Internal Macros
////////////////////////////////////////////////////////


// Macros for simplifying calling the Driver UI Helper interfaces correctly.

#define CALL_HELPER(MethodName, args)                                           \
    if (IsEqualGUID(&m_iidUIHelper, &IID_IPrintOemDriverUI))                    \
    {                                                                           \
        return static_cast<IPrintOemDriverUI *>(m_pUIHelper)->MethodName args;  \
    }                                                                           \
    else if (IsEqualGUID(&m_iidUIHelper, &IID_IPrintCoreUI2))                   \
    {                                                                           \
        return static_cast<IPrintCoreUI2 *>(m_pUIHelper)->MethodName args;      \
    }                                                                           \
    return E_NOINTERFACE;

#define CALL_HELPER2(MethodName, args)                                      \
    if (IsEqualGUID(&m_iidUIHelper, &IID_IPrintCoreUI2))                    \
    {                                                                       \
        return static_cast<IPrintCoreUI2 *>(m_pUIHelper)->MethodName args;  \
    }                                                                       \
    return E_NOINTERFACE;




/////////////////////////////////////////////////////////////
//
//  CUIHelper Class Methods
//

//
// Private Methods
//

// Clears or initializes data members.
void CUIHelper::Clear()
{
    // Clear stored interface
    m_pUIHelper     = NULL;
    m_iidUIHelper   = GUID_NULL;
}


//
// Public Methods
//

// Default contructor.
CUIHelper::CUIHelper()
{
    // Initialize the data members.
    Clear();
}

// Constructor with assignment.
CUIHelper::CUIHelper(const IID &HelperIID, PVOID pHelper)
{
    // Assign the interface.
    Assign(HelperIID, pHelper);
}

// Destructor
CUIHelper::~CUIHelper()
{
    // Release the interface reference.
    Release();
}

// Stores helper interface in helper entry structure.
void CUIHelper::Assign(const IID &HelperIID, PVOID pHelper)
{
    // If we already have a helper interface, release it. 
    if(IsValid())
    {
        Release();
    }

    // Store helper interface and IID for it.
    m_pUIHelper     = static_cast<IUnknown*>(pHelper);
    m_iidUIHelper   = HelperIID;
}

// Releases the helper interface and 
// our removes the references to it.
ULONG CUIHelper::Release() 
{ 
    ULONG   ulRef   = 0;


    if(IsValid())
    {
        // Release the interface.
        // Since IPrintCoreUI2 inherits from IPrintOemDriverUI,
        // it is safe to cast both types of helper interfaces
        // to IPrintOemDriverUI for purposes of calling a 
        // method implemented in IPrintOemDriverUI.
        // NOTE: can't cast to IUnknown since it just has pure virtual 
        //       calls for AddRef and Release.
        ulRef = static_cast<IPrintOemDriverUI *>(m_pUIHelper)->Release();

        // Clear the data members.
        Clear();
    }

    return ulRef;
}


//
// IPrintOemDriverUI methods
//

//
// Helper function to get driver settings. This function is only supported
// for UI plugins that do not fully replace core driver's standard UI.
//

HRESULT __stdcall CUIHelper::DrvGetDriverSetting(
                    PVOID   pci,
                    PCSTR   Feature,
                    PVOID   pOutput,
                    DWORD   cbSize,
                    PDWORD  pcbNeeded,
                    PDWORD  pdwOptionsReturned
                    )
{
    CALL_HELPER(DrvGetDriverSetting, 
                    (pci, 
                     Feature, 
                     pOutput, 
                     cbSize, 
                     pcbNeeded, 
                     pdwOptionsReturned
                    )
               );
}

//
// Helper function to allow OEM plugins upgrade private registry
// settings. This function is supported for any UI plugins and should be
// called only by OEM's UpgradePrinter.
//

HRESULT __stdcall CUIHelper::DrvUpgradeRegistrySetting(
                    HANDLE   hPrinter,
                    PCSTR    pFeature,
                    PCSTR    pOption
                    )
{
    CALL_HELPER(DrvUpgradeRegistrySetting, 
                    (hPrinter,
                     pFeature,
                     pOption
                    )
               );
}

//
// Helper function to allow OEM plugins to update the driver UI settings.
// This function is only supported for UI plugins that do not fully replace
// core driver's standard UI. It should be called only when the UI is present.
//

HRESULT __stdcall CUIHelper::DrvUpdateUISetting(
                    PVOID    pci,
                    PVOID    pOptItem,
                    DWORD    dwPreviousSelection,
                    DWORD    dwMode
                    )
{
    CALL_HELPER(DrvUpdateUISetting,
                    (pci,
                     pOptItem,
                     dwPreviousSelection,
                     dwMode
                    )
                );
}

//
// IPrintCoreUI2 new methods
//

//
// Following four helper functions are only supported for UI plugins that fully
// replace core driver's standard UI. They should only be called by the UI plugin's
// DocumentPropertySheets, DevicePropertySheets and their property sheet callback
// functions.
//
// Helper function to retrieve driver's current setting as a list of
// feature/option keyword pairs.
//

HRESULT __stdcall CUIHelper::GetOptions(
                       IN  POEMUIOBJ  poemuiobj,
                       IN  DWORD      dwFlags,
                       IN  PCSTR      pmszFeaturesRequested,
                       IN  DWORD      cbIn,
                       OUT PSTR       pmszFeatureOptionBuf,
                       IN  DWORD      cbSize,
                       OUT PDWORD     pcbNeeded)
{
    CALL_HELPER2(GetOptions,
                    (poemuiobj,
                     dwFlags,
                     pmszFeaturesRequested,
                     cbIn,
                     pmszFeatureOptionBuf,
                     cbSize,
                     pcbNeeded
                    )
                );
}

//
// Helper function to change driver's setting using a list of feature/option
// keyword pairs.
//

HRESULT __stdcall CUIHelper::SetOptions(
                       IN  POEMUIOBJ  poemuiobj,
                       IN  DWORD      dwFlags,
                       IN  PCSTR      pmszFeatureOptionBuf,
                       IN  DWORD      cbIn,
                       OUT PDWORD     pdwResult)
{
    CALL_HELPER2(SetOptions,
                    (poemuiobj,
                     dwFlags,
                     pmszFeatureOptionBuf,
                     cbIn,
                     pdwResult
                    )
                );
}

//
// Helper function to retrieve the option(s) of a given feature that are
// constrained in driver's current setting.
//

HRESULT __stdcall CUIHelper::EnumConstrainedOptions(
                                   IN  POEMUIOBJ  poemuiobj,
                                   IN  DWORD      dwFlags,
                                   IN  PCSTR      pszFeatureKeyword,
                                   OUT PSTR       pmszConstrainedOptionList,
                                   IN  DWORD      cbSize,
                                   OUT PDWORD     pcbNeeded)
{
    CALL_HELPER2(EnumConstrainedOptions,
                    (poemuiobj,
                     dwFlags,
                     pszFeatureKeyword,
                     pmszConstrainedOptionList,
                     cbSize,
                     pcbNeeded
                    )
                );
}

//
// Helper function to retrieve a list of feature/option keyword pairs from
// driver's current setting that conflict with the given feature/option pair.
//

HRESULT __stdcall CUIHelper::WhyConstrained(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           IN  PCSTR      pszOptionKeyword,
                           OUT PSTR       pmszReasonList,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded)
{
    CALL_HELPER2(WhyConstrained,
                    (poemuiobj,
                     dwFlags,
                     pszFeatureKeyword,
                     pszOptionKeyword,
                     pmszReasonList,
                     cbSize,
                     pcbNeeded
                    )
                );
}

//
// Following five helper functions are supported for any UI plugins.
//
// Helper function to retrieve global attribute.
//

HRESULT __stdcall CUIHelper::GetGlobalAttribute(
                               IN  POEMUIOBJ  poemuiobj,
                               IN  DWORD      dwFlags,
                               IN  PCSTR      pszAttribute,
                               OUT PDWORD     pdwDataType,
                               OUT PBYTE      pbData,
                               IN  DWORD      cbSize,
                               OUT PDWORD     pcbNeeded)
{
    CALL_HELPER2(GetGlobalAttribute,
                    (poemuiobj,
                     dwFlags,
                     pszAttribute,
                     pdwDataType,
                     pbData,
                     cbSize,
                     pcbNeeded
                    )
                );
}


//
// Helper function to retrieve attribute of a given feature.
//

HRESULT __stdcall CUIHelper::GetFeatureAttribute(
                                IN  POEMUIOBJ  poemuiobj,
                                IN  DWORD      dwFlags,
                                IN  PCSTR      pszFeatureKeyword,
                                IN  PCSTR      pszAttribute,
                                OUT PDWORD     pdwDataType,
                                OUT PBYTE      pbData,
                                IN  DWORD      cbSize,
                                OUT PDWORD     pcbNeeded)
{
    CALL_HELPER2(GetFeatureAttribute,
                    (poemuiobj,
                     dwFlags,
                     pszFeatureKeyword,
                     pszAttribute,
                     pdwDataType,
                     pbData,
                     cbSize,
                     pcbNeeded
                    )
                );
}

//
// Helper function to retrieve attribute of a given feature/option selection.
//

HRESULT __stdcall CUIHelper::GetOptionAttribute(
                               IN  POEMUIOBJ  poemuiobj,
                               IN  DWORD      dwFlags,
                               IN  PCSTR      pszFeatureKeyword,
                               IN  PCSTR      pszOptionKeyword,
                               IN  PCSTR      pszAttribute,
                               OUT PDWORD     pdwDataType,
                               OUT PBYTE      pbData,
                               IN  DWORD      cbSize,
                               OUT PDWORD     pcbNeeded)
{
    CALL_HELPER2(GetOptionAttribute,
                    (poemuiobj,
                     dwFlags,
                     pszFeatureKeyword,
                     pszOptionKeyword,
                     pszAttribute,
                     pdwDataType,
                     pbData,
                     cbSize,
                     pcbNeeded
                    )
                );
}

//
// Helper function to retrieve the list of feature keyword.
//

HRESULT __stdcall CUIHelper::EnumFeatures(
                         IN  POEMUIOBJ  poemuiobj,
                         IN  DWORD      dwFlags,
                         OUT PSTR       pmszFeatureList,
                         IN  DWORD      cbSize,
                         OUT PDWORD     pcbNeeded)
{
    CALL_HELPER2(EnumFeatures,
                    (poemuiobj,
                     dwFlags,
                     pmszFeatureList,
                     cbSize,
                     pcbNeeded
                    )
                );
}

//
// Helper function to retrieve the list of options keyword of a given feature.
//

HRESULT __stdcall CUIHelper::EnumOptions(
                        IN  POEMUIOBJ  poemuiobj,
                        IN  DWORD      dwFlags,
                        IN  PCSTR      pszFeatureKeyword,
                        OUT PSTR       pmszOptionList,
                        IN  DWORD      cbSize,
                        OUT PDWORD     pcbNeeded)
{
    CALL_HELPER2(EnumOptions,
                    (poemuiobj,
                     dwFlags,
                     pszFeatureKeyword,
                     pmszOptionList,
                     cbSize,
                     pcbNeeded
                    )
                );
}

//
// Helper function to query system simulation support
//

HRESULT __stdcall CUIHelper::QuerySimulationSupport(
                                   IN  HANDLE  hPrinter,
                                   IN  DWORD   dwLevel,
                                   OUT PBYTE   pCaps,
                                   IN  DWORD   cbSize,
                                   OUT PDWORD  pcbNeeded)
{
    CALL_HELPER2(QuerySimulationSupport,
                    (hPrinter,
                     dwLevel,
                     pCaps,
                     cbSize,
                     pcbNeeded
                    )
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\intrface.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Intrface.cpp
//    
//
//  PURPOSE:  Implementation of interface for WinXP PScript5 Standard 
//            UI Replacement plug-in.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//


#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "oemui.h"
#include "debug.h"
#include "intrface.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>


////////////////////////////////////////////////////////
//      Internal Constants
////////////////////////////////////////////////////////

//
// List all of the supported Driver UI Helper interface IIDs from the
// latest to the oldest, that's the order we will query for the
// the Driver UI Helper interface to use.
//

const IID *Helper_IIDs[] = 
{
    &IID_IPrintCoreUI2,
    &IID_IPrintOemDriverUI,    
};
const NUM_HELPER_IIDs   = (sizeof(Helper_IIDs)/sizeof(Helper_IIDs[0]));


////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents   = 0 ;     // Count of active components
static long g_cServerLocks  = 0 ;    // Count of locks




////////////////////////////////////////////////////////////////////////////////
//
// IOemUI2 body
//
IOemUI2::IOemUI2() 
{ 
    VERBOSE(DLLTEXT("IOemUI2:IOemUI2() default constructor called.\r\n\r\n")); 

    // Init ref count to 1 on creation, since AddRef() is implied.
    m_cRef              = 1; 

    // The default for UI Hiding is FALSE, since HideStandardUI method
    // will only be called by Driver UIs that support it.
    // Older Driver UIs don't know about this method and won't call us.
    m_bHidingStandardUI = FALSE;

    // Increment component count.
    InterlockedIncrement(&g_cComponents);
}

IOemUI2::~IOemUI2()
{
    VERBOSE(DLLTEXT("IOemUI2:~IOemUI2() destructor called.\r\n\r\n")); 

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == m_cRef);

    // Decrement component count.
    InterlockedDecrement(&g_cComponents);
}

HRESULT __stdcall IOemUI2::QueryInterface(const IID& iid, void** ppv)
{   
    VERBOSE(DLLTEXT("IOemUI2:QueryInterface entry.\r\n\r\n")); 

#if DBG    
    TCHAR szIID[80] = {0};
    StringFromGUID2(iid, szIID, COUNTOF(szIID)); // can not fail!
#endif

    // Determine what object to return, if any.
    if(iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
    }
    else if(iid == IID_IPrintOemUI2)
    {
        *ppv = static_cast<IPrintOemUI2*>(this);
    }
    else if(iid == IID_IPrintOemUI)
    {
        *ppv = static_cast<IPrintOemUI*>(this);
    }
    else
    {
        // Interface not supported.
#if DBG
        VERBOSE(DLLTEXT("IOemUI2::QueryInterface %s not supported.\r\n"), szIID); 
#endif

        *ppv = NULL ;
        return E_NOINTERFACE ;
    }

#if DBG
    VERBOSE(DLLTEXT("IOemUI2::QueryInterface returning pointer to %s.\r\n"), szIID); 
#endif

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemUI2::AddRef()
{
    VERBOSE(DLLTEXT("IOemUI2:AddRef entry.\r\n")); 
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemUI2::Release() 
{
   VERBOSE(DLLTEXT("IOemUI2:Release entry.\r\n")); 
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}

HRESULT __stdcall IOemUI2::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    HRESULT hResult = S_OK;


    VERBOSE(DLLTEXT("IOemUI2:PublishDriverInterface entry.\r\n")); 

    // Core Driver UI shouldn't call us more than once if we were successful.
    // Thus, if m_Helper is already valid, we shouldn't be getting called.
    ASSERT(!m_Helper.IsValid());

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (!m_Helper.IsValid())
    {
        PVOID   pHelper = NULL;


        // Try to get the newest version fo the Helper function
        // that Driver UI supports.
        hResult = E_FAIL;
        for(DWORD dwIndex = 0; !SUCCEEDED(hResult) && (dwIndex < NUM_HELPER_IIDs); ++dwIndex)
        {
            // Query Driver UI for Helper interface.
            hResult = pIUnknown->QueryInterface(*Helper_IIDs[dwIndex], &pHelper);
            if(SUCCEEDED(hResult))
            {
                // INVARIANT: we got a Helper interface.


                // Store Helper interface.
                m_Helper.Assign(*Helper_IIDs[dwIndex], pHelper);
            }
        }
    }

    return hResult;
}

HRESULT __stdcall IOemUI2::GetInfo(
    DWORD  dwMode,
    PVOID  pBuffer,
    DWORD  cbSize,
    PDWORD pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemUI2::GetInfo(%d) entry.\r\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        WARNING(DLLTEXT("IOemUI2::GetInfo() exit pcbNeeded is NULL! ERROR_INVALID_PARAMETER\r\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size and number of bytes written.
    *pcbNeeded = sizeof(DWORD);

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        WARNING(DLLTEXT("IOemUI2::GetInfo() exit insufficient buffer!\r\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = OEM_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = OEM_VERSION;
            break;

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            WARNING(DLLTEXT("IOemUI2::GetInfo() exit mode not supported.\r\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IOemUI2::GetInfo() exit S_OK, (*pBuffer is %#x).\r\r\n"), *(PDWORD)pBuffer);
    return S_OK;
}

HRESULT __stdcall IOemUI2::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IOemUI2:DevMode(%d, %#x) entry.\r\n"), dwMode, pOemDMParam); 

    return hrOEMDevMode(dwMode, pOemDMParam);
}

HRESULT __stdcall IOemUI2::CommonUIProp(
    DWORD  dwMode,
    POEMCUIPPARAM   pOemCUIPParam)
{
    VERBOSE(DLLTEXT("IOemUI2:CommonUIProp entry.\r\n")); 

    return hrOEMPropertyPage(dwMode, pOemCUIPParam);
}


HRESULT __stdcall IOemUI2::DocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI2:DocumentPropertySheets entry.\r\n")); 

    return hrOEMDocumentPropertySheets(pPSUIInfo, 
                                       lParam, 
                                       m_Helper, 
                                       &m_Features, 
                                       m_bHidingStandardUI);
}

HRESULT __stdcall IOemUI2::DevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI2:DevicePropertySheets entry.\r\n")); 

    return hrOEMDevicePropertySheets(pPSUIInfo, 
                                     lParam, 
                                     m_Helper, 
                                     &m_Features, 
                                     m_bHidingStandardUI);
}

HRESULT __stdcall IOemUI2::DeviceCapabilities(
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult)
{
    VERBOSE(DLLTEXT("IOemUI2:DeviceCapabilities entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI2::DevQueryPrintEx(
    POEMUIOBJ               poemuiobj,
    PDEVQUERYPRINT_INFO     pDQPInfo,
    PDEVMODE                pPublicDM,
    PVOID                   pOEMDM)
{
    VERBOSE(DLLTEXT("IOemUI2:DevQueryPrintEx entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI2::UpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo)
{
    VERBOSE(DLLTEXT("IOemUI2:UpgradePrinter entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI2::PrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI2:PrinterEvent entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI2::DriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI2:DriverEvent entry.\r\n"));

    return E_NOTIMPL;
};


HRESULT __stdcall IOemUI2::QueryColorProfile(
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulQueryMode,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData)
{
    VERBOSE(DLLTEXT("IOemUI2:QueryColorProfile entry.\r\n"));
 
    return E_NOTIMPL;
};

HRESULT __stdcall IOemUI2::FontInstallerDlgProc(
        HWND    hWnd,
        UINT    usMsg,
        WPARAM  wParam,
        LPARAM  lParam) 
{
    VERBOSE(DLLTEXT("IOemUI2:FontInstallerDlgProc entry.\r\n"));

    return E_NOTIMPL;
};

HRESULT __stdcall IOemUI2::UpdateExternalFonts(
        HANDLE  hPrinter,
        HANDLE  hHeap,
        PWSTR   pwstrCartridges)
{
    VERBOSE(DLLTEXT("IOemUI2:UpdateExternalFonts entry.\r\n"));

    return E_NOTIMPL;
}

// *********** IPrintOEMUI2 FUNCTIONS ****************

//
// QueryJobAttribtues
// 

HRESULT __stdcall IOemUI2::QueryJobAttributes(
    HANDLE      hPrinter,
    PDEVMODE    pDevmode,
    DWORD       dwLevel,
    LPBYTE      lpAttributeInfo)
{
    TERSE(DLLTEXT("IOemUI2:QueryJobAttributes entry.\r\n"));

    return E_NOTIMPL;
}

//
// Hide Standard UI
//

HRESULT __stdcall IOemUI2::HideStandardUI(
    DWORD       dwMode)
{
    HRESULT hrReturn    = E_NOTIMPL;


    TERSE(DLLTEXT("IOemUI2:HideStandardUI entry.\r\n"));

    switch(dwMode)
    {
        // By returning S_OK for both OEMCUIP_DOCPROP and OEMCUIP_PRNPROP,
        // we will hide the Standard UI for both Document Properties,
        // and Device Properties.
        // To not hide one or both, return E_NOTIMPL instead of S_OK,
        case OEMCUIP_DOCPROP:
        case OEMCUIP_PRNPROP:
            // Flag that we are hiding the Standard UI.
            // This is so we can tell easily between Driver UI
            // that supports HideStandardUI (such as WinXP PS UI),
            // or ones that don't (such as Win2K PS or Unidrv UI).
            m_bHidingStandardUI = TRUE;

            hrReturn = S_OK;
            break;
    }

    return hrReturn;
}

//
// DocumentEvent
//

HRESULT __stdcall IOemUI2::DocumentEvent(
    HANDLE      hPrinter,
    HDC         hdc,
    INT         iEsc,
    ULONG       cbIn,
    PVOID       pbIn,
    ULONG       cbOut,
    PVOID       pbOut,
    PINT        piResult)
{
    return E_NOTIMPL;
}


////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
#if DBG
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        WARNING(DLLTEXT("IOemCF::QueryInterface %s not supported.\r\n"), szOutput); 
#endif

        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemUI2* pOemCB = new IOemUI2 ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }
    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Exported functions
//


// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    //
    // To avoid leaving OEM DLL still in memory when Unidrv or Pscript drivers 
    // are unloaded, Unidrv and Pscript driver ignore the return value of 
    // DllCanUnloadNow of the OEM DLL, and always call FreeLibrary on the OEMDLL.
    //
    // If OEM DLL spins off a working thread that also uses the OEM DLL, the 
    // thread needs to call LoadLibrary and FreeLibraryAndExitThread, otherwise 
    // it may crash after Unidrv or Pscript calls FreeLibrary.
    //

    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:Create class factory.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMUI)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\helper.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  2001 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Helper.h
//    
//
//  PURPOSE:	Defines wrapper class for Driver UI Helper Interface.
//
//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _HELPER_H
#define _HELPER_H

#include "precomp.h"



class CUIHelper
{
    private:
        IUnknown   *m_pUIHelper;         // pointer to Driver UI's Helper interface
        IID        m_iidUIHelper;       // Driver UI's Helper interface IID

    public:
        CUIHelper();
        CUIHelper(const IID &HelperIID, PVOID pHelper);
        virtual ~CUIHelper();

        inline BOOL IsValid() {return NULL != m_pUIHelper;}

        void Assign(const IID &HelperIID, PVOID pHelper);
        ULONG Release();

    //
    // IPrintOemDriverUI methods
    //

    //
    // Helper function to get driver settings. This function is only supported
    // for UI plugins that do not fully replace core driver's standard UI.
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_
                        PVOID   pci,
                        PCSTR   Feature,
                        PVOID   pOutput,
                        DWORD   cbSize,
                        PDWORD  pcbNeeded,
                        PDWORD  pdwOptionsReturned
                        );

    //
    // Helper function to allow OEM plugins upgrade private registry
    // settings. This function is supported for any UI plugins and should be
    // called only by OEM's UpgradePrinter.
    //

    STDMETHOD(DrvUpgradeRegistrySetting) (THIS_
                        HANDLE   hPrinter,
                        PCSTR    pFeature,
                        PCSTR    pOption
                        );

    //
    // Helper function to allow OEM plugins to update the driver UI settings.
    // This function is only supported for UI plugins that do not fully replace
    // core driver's standard UI. It should be called only when the UI is present.
    //

    STDMETHOD(DrvUpdateUISetting) (THIS_
                        PVOID    pci,
                        PVOID    pOptItem,
                        DWORD    dwPreviousSelection,
                        DWORD    dwMode
                        );

    //
    // IPrintCoreUI2 new methods
    //

    //
    // Following four helper functions are only supported for UI plugins that fully
    // replace core driver's standard UI. They should only be called by the UI plugin's
    // DocumentPropertySheets, DevicePropertySheets and their property sheet callback
    // functions.
    //
    // Helper function to retrieve driver's current setting as a list of
    // feature/option keyword pairs.
    //

    STDMETHOD(GetOptions) (THIS_
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pmszFeaturesRequested,
                           IN  DWORD      cbIn,
                           OUT PSTR       pmszFeatureOptionBuf,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded);

    //
    // Helper function to change driver's setting using a list of feature/option
    // keyword pairs.
    //

    STDMETHOD(SetOptions) (THIS_
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pmszFeatureOptionBuf,
                           IN  DWORD      cbIn,
                           OUT PDWORD     pdwResult);

    //
    // Helper function to retrieve the option(s) of a given feature that are
    // constrained in driver's current setting.
    //

    STDMETHOD(EnumConstrainedOptions) (THIS_
                                       IN  POEMUIOBJ  poemuiobj,
                                       IN  DWORD      dwFlags,
                                       IN  PCSTR      pszFeatureKeyword,
                                       OUT PSTR       pmszConstrainedOptionList,
                                       IN  DWORD      cbSize,
                                       OUT PDWORD     pcbNeeded);

    //
    // Helper function to retrieve a list of feature/option keyword pairs from
    // driver's current setting that conflict with the given feature/option pair.
    //

    STDMETHOD(WhyConstrained) (THIS_
                               IN  POEMUIOBJ  poemuiobj,
                               IN  DWORD      dwFlags,
                               IN  PCSTR      pszFeatureKeyword,
                               IN  PCSTR      pszOptionKeyword,
                               OUT PSTR       pmszReasonList,
                               IN  DWORD      cbSize,
                               OUT PDWORD     pcbNeeded);

    //
    // Following five helper functions are supported for any UI plugins.
    //
    // Helper function to retrieve global attribute.
    //

    STDMETHOD(GetGlobalAttribute) (THIS_
                                   IN  POEMUIOBJ  poemuiobj,
                                   IN  DWORD      dwFlags,
                                   IN  PCSTR      pszAttribute,
                                   OUT PDWORD     pdwDataType,
                                   OUT PBYTE      pbData,
                                   IN  DWORD      cbSize,
                                   OUT PDWORD     pcbNeeded);


    //
    // Helper function to retrieve attribute of a given feature.
    //

    STDMETHOD(GetFeatureAttribute) (THIS_
                                    IN  POEMUIOBJ  poemuiobj,
                                    IN  DWORD      dwFlags,
                                    IN  PCSTR      pszFeatureKeyword,
                                    IN  PCSTR      pszAttribute,
                                    OUT PDWORD     pdwDataType,
                                    OUT PBYTE      pbData,
                                    IN  DWORD      cbSize,
                                    OUT PDWORD     pcbNeeded);

    //
    // Helper function to retrieve attribute of a given feature/option selection.
    //

    STDMETHOD(GetOptionAttribute) (THIS_
                                   IN  POEMUIOBJ  poemuiobj,
                                   IN  DWORD      dwFlags,
                                   IN  PCSTR      pszFeatureKeyword,
                                   IN  PCSTR      pszOptionKeyword,
                                   IN  PCSTR      pszAttribute,
                                   OUT PDWORD     pdwDataType,
                                   OUT PBYTE      pbData,
                                   IN  DWORD      cbSize,
                                   OUT PDWORD     pcbNeeded);

    //
    // Helper function to retrieve the list of feature keyword.
    //

    STDMETHOD(EnumFeatures) (THIS_
                             IN  POEMUIOBJ  poemuiobj,
                             IN  DWORD      dwFlags,
                             OUT PSTR       pmszFeatureList,
                             IN  DWORD      cbSize,
                             OUT PDWORD     pcbNeeded);

    //
    // Helper function to retrieve the list of options keyword of a given feature.
    //

    STDMETHOD(EnumOptions) (THIS_
                            IN  POEMUIOBJ  poemuiobj,
                            IN  DWORD      dwFlags,
                            IN  PCSTR      pszFeatureKeyword,
                            OUT PSTR       pmszOptionList,
                            IN  DWORD      cbSize,
                            OUT PDWORD     pcbNeeded);

    //
    // Helper function to query system simulation support
    //

    STDMETHOD(QuerySimulationSupport) (THIS_
                                       IN  HANDLE  hPrinter,
                                       IN  DWORD   dwLevel,
                                       OUT PBYTE   pCaps,
                                       IN  DWORD   cbSize,
                                       OUT PDWORD  pcbNeeded);

    private:
        void Clear();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by OEMUI.rc
//
#define IDS_SECTION                     1
#define IDS_CALIBRATED                  2
#define IDS_NAME                        3
#define IDS_DEVICE_SETTINGS_NAME        4
#define IDS_CONSTRAINT_CONFLICT         5
#define IDS_DEV_SECTION                 6
#define IDS_ADV_SECTION                 10
#define IDD_DEVICE_PROPPAGE             106
#define IDD_DOC_PROPPAGE                107
#define IDS_POSTSCRIPT_VM               400
#define IDS_KBYTES                      401
#define IDS_SECONDS                     402
#define IDS_PSTIMEOUTS                  403
#define IDS_JOBTIMEOUT                  404
#define IDS_WAITTIMEOUT                 405
#define IDS_PRINTER_DEFAULT             406
#define IDS_INSTALLABLE_OPTIONS         407
#define IDS_DOWNLOAD_AS_SOFTFONT        408
#define IDS_USE_DEVFONTS                409
#define IDS_FONTSUB_OPTION              410
#define IDS_FONTSUB_DEFAULT             411
#define IDS_FONTSUB_SLOW                412
#define IDS_FONTSUB_TABLE               413
#define IDS_DEFAULT_TRAY                414
#define IDS_DRAW_ONLY_FROM_SELECTED     415
#define IDS_RESTORE_DEFAULTS            417
#define IDS_PRINTER_FEATURES            418
#define IDS_METAFILE_SPOOLING           419
#define IDS_ENABLED                     420
#define IDS_DISABLED                    421
#define IDS_PSOPTIONS                   422
#define IDS_MIRROR                      423
#define IDS_NEGATIVE_PRINT              424
#define IDS_PAGEINDEP                   425
#define IDS_COMPRESSBMP                 426
#define IDS_CTRLD_BEFORE                427
#define IDS_CTRLD_AFTER                 428
#define IDS_JOB_CONTROL                 429
#define IDS_TEXT_ASGRX                  431
#define IDS_PAGE_PROTECTION             432
#define IDS_CANCEL_CONFLICT             433
#define IDS_IGNORE_CONFLICT             434
#define IDS_RESOLVE_CONFLICT            435
#define IDS_GETDATA_FAILED              436
#define IDS_DRIVERUI_COLORMODE          437
#define IDS_ENVELOPE                    438
#define IDS_ENV_PREFIX                  439
#define IDS_PSPROTOCOL                  440
#define IDS_PSPROTOCOL_ASCII            441
#define IDS_PSPROTOCOL_BCP              442
#define IDS_PSPROTOCOL_TBCP             443
#define IDS_PSPROTOCOL_BINARY           444
#define IDS_TRAY_FORMSOURCE             445
#define IDS_OEMERR_DLGTITLE             446
#define IDS_OEMERR_OPTITEM              447
#define IDS_OEMERR_PROPSHEET            448
#define IDS_CANCEL_CONFLICT_FINAL       449
#define IDS_PSERROR_HANDLER             450
#define IDS_PSMINOUTLINE                451
#define IDS_PSMAXBITMAP                 452
#define IDS_PIXELS                      453
#define IDS_PSOUTPUT_OPTION             454
#define IDS_PSOPT_SPEED                 455
#define IDS_PSOPT_PORTABILITY           456
#define IDS_PSOPT_EPS                   457
#define IDS_PSOPT_ARCHIVE               458
#define IDS_PSTT_DLFORMAT               459
#define IDS_TTDL_DEFAULT                460
#define IDS_TTDL_TYPE1                  461
#define IDS_TTDL_TYPE3                  462
#define IDS_TTDL_TYPE42                 463
#define IDS_PSLEVEL                     471
#define IDS_TRUE_GRAY_TEXT              507
#define IDS_TRUE_GRAY_GRAPH             508
#define IDS_ADD_EURO                    509
#define IDS_PSCRIPT_CUSTOMSIZE          600
#define IDC_CALIBRATE                   1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\oemui.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	OEMUI.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for OEMUI Test Module.
//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _OEMUI_H
#define _OEMUI_H

#include "precomp.h"
#include <PRCOMOEM.H>

#include "oem.h"
#include "devmode.h"
#include "globals.h"
#include "helper.h"
#include "features.h"



////////////////////////////////////////////////////////
//      OEM UI Defines
////////////////////////////////////////////////////////


// OEM Signature and version.
#define PROP_TITLE      L"OEM PS UI Replacement Page"
#define DLLTEXT(s)      TEXT("PSUIREP:  ") TEXT(s)

// OEM UI Misc defines.
#define ERRORTEXT(s)    TEXT("ERROR ") DLLTEXT(s)


// Printer registry keys where OEM data is stored.
#define OEMUI_VALUE             TEXT("OEMUI_VALUE")
#define OEMUI_DEVICE_VALUE      TEXT("OEMUI_DEVICE_VALUE")




////////////////////////////////////////////////////////
//      Prototypes
////////////////////////////////////////////////////////

HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, CUIHelper &Helper, CFeatures *pFeatures,
                                    BOOL bHidingStandardUI);
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, CUIHelper &Helper, CFeatures *pFeatures,
                                  BOOL bHidingStandardUI);

POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems);
POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif



// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <LIMITS.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
#include <WINDDI.H>
#include <WINSPOOL.H>
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRSHT.H>
#include <COMPSTUI.H>
#include <WINDDIUI.H>
#include <PRINTOEM.H>

#define COUNTOF(p)  (sizeof(p)/sizeof(*(p)))



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\stringutils.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  2001 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Features.cpp
//    
//
//  PURPOSE:  Implementation wrapper class for WinXP PS Driver Features and Options.
//
//
//
//  PLATFORMS:    Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "debug.h"
#include "oemui.h"
#include "stringutils.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>





// Create a list of pointers to the strings
// in a multi-sz.
HRESULT MakeStrPtrList(HANDLE hHeap, PCSTR pmszMultiSz, PCSTR **pppszList, PWORD pwCount)
{
    PCSTR   *ppszList   = NULL;
    HRESULT hrResult    = S_OK;


    // Validate parameters
    if( (NULL == hHeap)
        ||
        (NULL == pmszMultiSz)
        ||
        (NULL == pppszList)
        ||
        (NULL == pwCount)
      )
    {
        return E_INVALIDARG;
    }

    // Get the count of strings in the multi-sz.
    *pwCount = mstrcount(pmszMultiSz);
    if(0 == *pwCount)
    {
        WARNING(DLLTEXT("MakeStrPtrList() pmszMultiSz contains no strings.\r\n")); 

        goto Exit;
    }

    // Allocate pointer list.
    *pppszList = (PCSTR *) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, (*pwCount) * sizeof(PCSTR));
    if(NULL == *pppszList)
    {
        ERR(ERRORTEXT("MakeStrPtrList() failed to allote array of PCSTR.\r\n")); 

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }
    ppszList = *pppszList; 

    // Walk multi-sz mapping string pointers.
    for(WORD wIndex = 0; wIndex < *pwCount; ++wIndex)
    {
        ppszList[wIndex] = pmszMultiSz;
        pmszMultiSz += lstrlenA(pmszMultiSz) + 1;
    }


Exit:

    return hrResult;
}


// Determine how many strings are in the multi-sz.
WORD mstrcount(PCSTR pmszMultiSz)
{
    WORD    wCount = 0;


    // NULL string pointers have no strings.
    if(NULL == pmszMultiSz)
    {
        return 0;
    }

    // Walk list of strings counting them.
    while(pmszMultiSz[0] != '\0')
    {
        ++wCount;
        pmszMultiSz += lstrlenA(pmszMultiSz) + 1;
    }

    return wCount;
}

// Allocates and converts ANSI string to Unicode.
PWSTR MakeUnicodeString(HANDLE hHeap, PCSTR pszAnsi)
{
    int     nSize       = 0;
    PWSTR   pszUnicode  = NULL;


    // Validate parameters
    if( (NULL == hHeap)
        ||
        (NULL == pszAnsi)
      )
    {
        return NULL;
    }

    // Get the size needed for UNICODE string.
    nSize = MultiByteToWideChar(CP_ACP, 0, pszAnsi, -1, NULL, 0);
    if(0 != nSize)
    {
        // Allocate unicode string.
        pszUnicode = (PWSTR) HeapAlloc(hHeap, 0, nSize * sizeof(WCHAR));
        if(NULL != pszUnicode)
        {
            // Convert ANSI to Unicode
            nSize = MultiByteToWideChar(CP_ACP, 0, pszAnsi, -1, pszUnicode, nSize);
            if(0 == nSize)
            {
                // INVARIANT:  failed to convert.

                // free buffer and return NULL.
                HeapFree(hHeap, 0, pszUnicode);
                pszUnicode = NULL;
            }
        }
    }

    return pszUnicode;
}

// Allocates and copies source string.
PWSTR MakeStringCopy(HANDLE hHeap, PCWSTR pszSource)
{
    PWSTR   pszCopy = NULL;
    DWORD   dwSize;


    // Validate parameters
    if( (NULL == hHeap)
        ||
        (NULL == pszSource)
      )
    {
        return NULL;
    }

    // Allocate memory for string duplication, and duplicate the string.
    dwSize = (wcslen(pszSource) + 1) * sizeof(WCHAR);
    pszCopy = (PWSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize);
    if(NULL != pszCopy)
    {
        HRESULT hResult;


        hResult = StringCbCopyW(pszCopy, dwSize, pszSource);
        if(FAILED(hResult))
        {
            HeapFree(hHeap, 0, pszCopy);
            pszCopy = NULL;
            SetLastError(hResult);
        }
    }

    return pszCopy;
}

// Allocates and copies source string.
PSTR MakeStringCopy(HANDLE hHeap, PCSTR pszSource)
{
    PSTR    pszCopy = NULL;
    DWORD   dwSize;


    // Validate parameters
    if( (NULL == hHeap)
        ||
        (NULL == pszSource)
      )
    {
        return NULL;
    }

    // Allocate memory for string duplication, and duplicate the string.
    dwSize = (lstrlenA(pszSource) + 1) * sizeof(CHAR);
    pszCopy = (PSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize);
    if(NULL != pszCopy)
    {
        HRESULT hResult;

        hResult = StringCbCopyA(pszCopy, dwSize, pszSource);
        if(FAILED(hResult))
        {
            HeapFree(hHeap, 0, pszCopy);
            pszCopy = NULL;
            SetLastError(hResult);
        }
    }

    return pszCopy;
}

// Frees list of strings.
// NOTE: don't use this for string list made with MakeStrPtrList(), since
//       the strings pointed to be list made with MakeStrPtrList() will 
//       be freed when the multi-sz is freed.
void FreeStringList(HANDLE hHeap, PWSTR *ppszList, WORD wCount)
{
    // Validate parameters.
    if( (NULL == hHeap)
        ||
        (NULL == ppszList)
      )
    {
        return;
    }

    // Free each of the strings in the list.
    for(WORD wIndex = 0; wIndex < wCount; ++wIndex)
    {
        if(NULL != ppszList[wIndex]) HeapFree(hHeap, 0, ppszList[wIndex]);
    }

    // Free list.
    HeapFree(hHeap, 0, ppszList);
}


//  Retrieves pointer to a String resource.
HRESULT GetStringResource(HANDLE hHeap, HMODULE hModule, UINT uResource, PWSTR *ppszString)
{
    int     nResult;
    DWORD   dwSize      = MAX_PATH;
    PWSTR   pszString   = NULL;
    HRESULT hrResult    = S_OK;


    VERBOSE(DLLTEXT("GetStringResource(%#x, %#x, %d) entered.\r\n"), hHeap, hModule, uResource);

    // Validate parameters.
    if( (NULL == hHeap)
        ||
        (NULL == ppszString)
      )
    {
        return E_INVALIDARG;
    }

    // Allocate buffer for string resource from heap; let the driver clean it up.
    pszString = (PWSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize * sizeof(WCHAR));
    if(NULL == pszString)
    {
        ERR(ERRORTEXT("GetStringResource() failed to allocate string buffer!\r\n"));

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // Load string resource; resize after loading so as not to waste memory.
    nResult = LoadString(hModule, uResource, pszString, dwSize);
    if(nResult > 0)
    {
        PWSTR   pszTemp;


        VERBOSE(DLLTEXT("LoadString() returned %d!\r\n"), nResult);
        VERBOSE(DLLTEXT("String load was \"%s\".\r\n"), pszString);

        pszTemp = (PWSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, pszString, (nResult + 1) * sizeof(WCHAR));
        if(NULL != pszTemp)
        {
            pszString = pszTemp;
        }
        else
        {
            WARNING(DLLTEXT("GetStringResource() HeapReAlloc() of string retrieved failed! (Last Error was %d)\r\n"), GetLastError());
        }
    }
    else
    {
        DWORD   dwError = GetLastError();


        ERR(ERRORTEXT("LoadString() returned %d! (Last Error was %d)\r\n"), nResult, GetLastError());
        ERR(ERRORTEXT("GetStringResource() failed to load string resource %d!\r\n"), uResource);

        HeapFree(hHeap, 0, pszString);
        pszString   = NULL;
        hrResult    = HRESULT_FROM_WIN32(dwError);
    }


Exit:

    // Save string pointer to caller.
    // NOTE: string pointer will be NULL on failure.
    *ppszString = pszString;

    return hrResult;
}

//  Retrieves pointer to a String resource.
HRESULT GetStringResource(HANDLE hHeap, HMODULE hModule, UINT uResource, PSTR *ppszString)
{
    int     nResult;
    DWORD   dwSize      = MAX_PATH;
    PSTR    pszString   = NULL;
    HRESULT hrResult    = S_OK;


    VERBOSE(DLLTEXT("GetStringResource(%#x, %#x, %d) entered.\r\n"), hHeap, hModule, uResource);

    // Validate parameters.
    if( (NULL == hHeap)
        ||
        (NULL == ppszString)
      )
    {
        return E_INVALIDARG;
    }

    // Allocate buffer for string resource from heap; let the driver clean it up.
    pszString = (PSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize * sizeof(WCHAR));
    if(NULL == pszString)
    {
        ERR(ERRORTEXT("GetStringResource() failed to allocate string buffer!\r\n"));

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // Load string resource; resize after loading so as not to waste memory.
    nResult = LoadStringA(hModule, uResource, pszString, dwSize);
    if(nResult > 0)
    {
        PSTR   pszTemp;


        VERBOSE(DLLTEXT("LoadString() returned %d!\r\n"), nResult);
        VERBOSE(DLLTEXT("String load was \"%hs\".\r\n"), pszString);

        pszTemp = (PSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, pszString, nResult + 1);
        if(NULL != pszTemp)
        {
            pszString = pszTemp;
        }
        else
        {
            WARNING(DLLTEXT("GetStringResource() HeapReAlloc() of string retrieved failed! (Last Error was %d)\r\n"), GetLastError());
        }
    }
    else
    {
        DWORD   dwError = GetLastError();


        ERR(ERRORTEXT("LoadString() returned %d! (Last Error was %d)\r\n"), nResult, GetLastError());
        ERR(ERRORTEXT("GetStringResource() failed to load string resource %d!\r\n"), uResource);

        HeapFree(hHeap, 0, pszString);
        pszString   = NULL;
        hrResult    = HRESULT_FROM_WIN32(dwError);
    }


Exit:

    // Save string pointer to caller.
    // NOTE: string pointer will be NULL on failure.
    *ppszString = pszString;

    return hrResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\intrface.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Intrface.cpp
//    
//
//  PURPOSE:  Header of interface for PScript4, PScript5, Unidrv4, 
//            Unidrv5 UI plug-ins.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _INTRFACE_H
#define _INTRFACE_H


#include "precomp.h"
#include "helper.h"
#include "features.h"



////////////////////////////////////////////////////////////////////////////////
//
// IOemUI2
//
class IOemUI2: public IPrintOemUI2
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD  dwMode, PVOID  pBuffer, DWORD  cbSize,
                           PDWORD pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_  DWORD  dwMode, POEMDMPARAM pOemDMParam) ;

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // OEMCommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_  
            DWORD  dwMode, 
            POEMCUIPPARAM   pOemCUIPParam
            );

    //
    // OEMDocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );

    //
    // OEMDevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );


    //
    // OEMDevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            );

    //
    // OEMDeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            );

    //
    // OEMUpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            );

    //
    // OEMPrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            );

    //
    // OEMDriverEvent
    //

    STDMETHOD(DriverEvent)(THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            );
 
    //
    // OEMQueryColorProfile
    //

    STDMETHOD( QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData);

    //
    // OEMFontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_ 
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            );
    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
            );

    //
    // IPrintOemUI2 methods
    //

    //
    // QueryJobAttributes
    //

    STDMETHOD(QueryJobAttributes)  (THIS_
            HANDLE      hPrinter,
            PDEVMODE    pDevmode,
            DWORD       dwLevel,
            LPBYTE      lpAttributeInfo
           );

    //
    // Hide Standard UI
    //

    STDMETHOD(HideStandardUI)  (THIS_
            DWORD       dwMode
           );

    //
    // DocumentEvent
    //

    STDMETHOD(DocumentEvent) (THIS_
            HANDLE      hPrinter,
            HDC         hdc,
            INT         iEsc,
            ULONG       cbIn,
            PVOID       pbIn,
            ULONG       cbOut,
            PVOID       pbOut,
            PINT        piResult
           );


    IOemUI2();
    virtual ~IOemUI2();

protected:
    LONG        m_cRef;                 // Reference count
    BOOL        m_bHidingStandardUI;    // Flag indicating if we are hiding the Standard UI.
                                        // NOTE: Not all Driver UI versions support hinding
                                        //       the Standard Driver UI.
    CUIHelper   m_Helper;               // Container for Driver UI Helper interface.
    CFeatures   m_Features;             // Core Driver features and feature options.
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\devmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Devmode.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for devmode functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _DEVMODE_H
#define _DEVMODE_H


////////////////////////////////////////////////////////
//      OEM Devmode Defines
////////////////////////////////////////////////////////




////////////////////////////////////////////////////////
//      OEM Devmode Type Definitions
////////////////////////////////////////////////////////

//
//Can add info to the private devmode bellow here.
//Note :
//		This structure must be prefixed by OEM_DMEXTRAHEADER
//		Your plug-in must implement the IPrintOemUI::DevMode method
//
typedef struct tagOEMDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    DWORD               dwDriverData;
    DWORD               dwAdvancedData;

	//
	//Private DevMode Members
	//

} OEMDEV, *POEMDEV;

typedef const OEMDEV *PCOEMDEV;



/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam);
BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut);
BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode);
void Dump(PCOEMDEV pOEMDevIn);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\devmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Devmode.cpp
//    
//
//  PURPOSE:  Implementation of Devmode functions shared with OEM UI and OEM rendering modules.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oemui.h"
#include "debug.h"
#include "devmode.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>


//
//Performs operation on UI Plugins Private DevMode Members.
//Called via IOemUI::DevMode
//

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam)
{
    POEMDEV pOEMDevIn;
    POEMDEV pOEMDevOut;


    // Verify parameters.
    if( (NULL == pOemDMParam)
        ||
        ( (OEMDM_SIZE != dwMode)
          &&
          (OEMDM_DEFAULT != dwMode)
          &&
          (OEMDM_CONVERT != dwMode)
          &&
          (OEMDM_MERGE != dwMode)
        )
      )
    {
        ERR(ERRORTEXT("DevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOemDMParam = %#lx.\r\n"), dwMode, pOemDMParam);

        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Cast generic (i.e. PVOID) to OEM private devomode pointer type.
    pOEMDevIn = (POEMDEV) pOemDMParam->pOEMDMIn;
    pOEMDevOut = (POEMDEV) pOemDMParam->pOEMDMOut;

    switch(dwMode)
    {
		//
		//The Method should return the size of the memory allocation needed to store the UI plugin Private DEVMODE.
		//
        case OEMDM_SIZE:
            pOemDMParam->cbBufSize = sizeof(OEMDEV);
            break;

		//
		//Should fill the Private DEVMODE with the default values.
		//
        case OEMDM_DEFAULT:
			//
			//OEM_DMEXTRAHEADER Members
			//
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;

			//
			//Private members
			//
            pOEMDevOut->dwDriverData            = 0;
            pOEMDevOut->dwAdvancedData          = 0;

            VERBOSE(DLLTEXT("pOEMDevOut after setting default values:\r\n"));
            Dump(pOEMDevOut);			
            break;
			
		//
		//The method should convert private DEVMODE members to the current version, if necessary.
		//
        case OEMDM_CONVERT:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            break;
		
		//
		//The method should validate the information contained in private DEVMODE members and merge validated values into a private DEVMODE structure containing default values
		//
        case OEMDM_MERGE:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            MakeOEMDevmodeValid(pOEMDevOut);
            break;
    }
    Dump(pOemDMParam);

    return S_OK;
}


BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut)
{
    if( (NULL == pOEMDevIn)
        ||
        (NULL == pOEMDevOut)
      )
    {
        ERR(ERRORTEXT("ConvertOEMDevmode() invalid parameters.\r\n"));
        return FALSE;
    }

    // Check OEM Signature, if it doesn't match ours,
    // then just assume DMIn is bad and use defaults.
    if(pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature)
    {
        VERBOSE(DLLTEXT("Converting private OEM Devmode.\r\n"));
        VERBOSE(DLLTEXT("pOEMDevIn:\r\n"));
        Dump(pOEMDevIn);

        // Set the devmode defaults so that anything the isn't copied over will
        // be set to the default value.
        pOEMDevOut->dwDriverData    = 0;
        pOEMDevOut->dwAdvancedData  = 0;

        // Copy the old structure in to the new using which ever size is the smaller.
        // Devmode maybe from newer Devmode (not likely since there is only one), or
        // Devmode maybe a newer Devmode, in which case it maybe larger,
        // but the first part of the structure should be the same.

        // DESIGN ASSUMPTION: the private DEVMODE structure only gets added to;
        // the fields that are in the DEVMODE never change only new fields get added to the end.

        memcpy(pOEMDevOut, pOEMDevIn, __min(pOEMDevOut->dmOEMExtra.dwSize, pOEMDevIn->dmOEMExtra.dwSize));

        // Re-fill in the size and version fields to indicated 
        // that the DEVMODE is the current private DEVMODE version.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
    }
    else
    {
        WARNING(DLLTEXT("Unknown DEVMODE signature, pOEMDMIn ignored.\r\n"));

        // Don't know what the input DEVMODE is, so just use defaults.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
        pOEMDevOut->dwDriverData            = 0;
        pOEMDevOut->dwAdvancedData          = 0;
    }

    return TRUE;
}


BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode)
{
    if(NULL == pOEMDevmode)
    {
        return FALSE;
    }

    // ASSUMPTION: pOEMDevmode is large enough to contain OEMDEV structure.

    // Make sure that dmOEMExtra indicates the current OEMDEV structure.
    pOEMDevmode->dmOEMExtra.dwSize       = sizeof(OEMDEV);
    pOEMDevmode->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
    pOEMDevmode->dmOEMExtra.dwVersion    = OEM_VERSION;

    // Set driver data, if not valid.
    if(pOEMDevmode->dwDriverData > 100)
    {
        pOEMDevmode->dwDriverData = 0;
    }

    // Set Advanced driver data, if not valid.
    if(pOEMDevmode->dwAdvancedData > 100)
    {
        pOEMDevmode->dwAdvancedData = 0;
    }

    return TRUE;
}


void Dump(PCOEMDEV pOEMDevmode)
{
    if( (NULL != pOEMDevmode)
        &&
        (pOEMDevmode->dmOEMExtra.dwSize >= sizeof(OEMDEV))
        &&
        (OEM_SIGNATURE == pOEMDevmode->dmOEMExtra.dwSignature)
      )
    {
        VERBOSE(TEXT("\tdmOEMExtra.dwSize      = %d\r\n"), pOEMDevmode->dmOEMExtra.dwSize);
        VERBOSE(TEXT("\tdmOEMExtra.dwSignature = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwSignature);
        VERBOSE(TEXT("\tdmOEMExtra.dwVersion   = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwVersion);
        VERBOSE(TEXT("\tdwDriverData           = %#x\r\n"), pOEMDevmode->dwDriverData);
        VERBOSE(TEXT("\tdwAdvancedData         = %#x\r\n"), pOEMDevmode->dwAdvancedData);
    }
    else
    {
        ERR(ERRORTEXT("Dump(POEMDEV) unknown private OEM DEVMODE.\r\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _DEBUG_H
#define _DEBUG_H


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);
void Dump(PPROPSHEETUI_INFO pPSUIInfo);
void Dump(POPTITEM pOptItem);
void Dump(POPTTYPE pOptType);
void Dump(POPTPARAM pOptParam, WORD wCount);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\oemui.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    OEMUI.cpp
//    
//
//  PURPOSE:  Main file for OEM UI test module.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "resource.h"
#include "debug.h"
#include "stringutils.h"
#include "oemui.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      INTERNAL MACROS and DEFINES
////////////////////////////////////////////////////////

typedef struct _tagCBUserData 
{
    HANDLE          hComPropSheet;
    HANDLE          hPropPage;
    POEMUIPSPARAM   pOEMUIParam;
    PFNCOMPROPSHEET pfnComPropSheet;
    CUIHelper       *pHelper;
    POEMUIOBJ       poemuiobj;
    BOOL            bPermission;
    BOOL            bHidingStandardUI;

} CBUSERDATA, *PCBUSERDATA;



////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUIItemCallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam);
LONG APIENTRY OEMDevUICallBack(PCPSUICBPARAM pCallbackParam);
INT_PTR CALLBACK DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems);




////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM device or document property UI.
//
HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    HRESULT hResult = S_OK;


    VERBOSE(DLLTEXT("hrOEMPropertyPage(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (OEMCUIP_DOCPROP != dwMode)
        &&
        (OEMCUIP_PRNPROP != dwMode)        
      )
    {
        ERR(ERRORTEXT("hrOEMPropertyPage() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOEMUIParam = %#lx.\r\n"), dwMode, pOEMUIParam);

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        case OEMCUIP_DOCPROP:
            hResult = hrDocumentPropertyPage(dwMode, pOEMUIParam);
            break;

        case OEMCUIP_PRNPROP:
            hResult = hrPrinterPropertyPage(dwMode, pOEMUIParam);
            break;

        default:
            // Should never reach this!
            ERR(ERRORTEXT("hrOEMPropertyPage() Invalid dwMode, %d"), dwMode);
            SetLastError(ERROR_INVALID_PARAMETER);
            hResult = E_FAIL;
            break;
    }

    return hResult;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM document property UI.
//
static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    HRESULT hrResult = S_OK;


    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM document property UI.
        pOEMUIParam->cOEMOptItems = 1;

        VERBOSE(DLLTEXT("hrDocumentPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
        POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


        VERBOSE(DLLTEXT("hrDocumentPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMDocUIItemCallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // New section.
        pOEMUIParam->pOEMOptItems[0].Level = 1;
        pOEMUIParam->pOEMOptItems[0].Flags = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].Sel = pOEMDev->dwAdvancedData;

        hrResult = GetStringResource(pOEMUIParam->hOEMHeap, 
                                     (HMODULE) pOEMUIParam->hModule, 
                                     IDS_ADV_SECTION, 
                                     &pOEMUIParam->pOEMOptItems[0].pName);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("hrDocumentPropertyPage() failed to get section name. (hrResult = 0x%x)\r\n"),
                          hrResult); 
            goto Exit;
        }

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

        pOEMUIParam->pOEMOptItems[0].pOptType->Type = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam = 100;
    }


Exit:

    return hrResult;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM printer property UI.
//
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    HRESULT hrResult = S_OK;


    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM printer property UI.
        pOEMUIParam->cOEMOptItems = 1;

        VERBOSE(DLLTEXT("hrPrinterPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
        DWORD   dwError;
        DWORD   dwDeviceValue;
        DWORD   dwType;
        DWORD   dwNeeded;


        VERBOSE(DLLTEXT("hrPrinterPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Get device settings value from printer.
        dwError = GetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, &dwType, (PBYTE) &dwDeviceValue,
                                   sizeof(dwDeviceValue), &dwNeeded);
        if( (ERROR_SUCCESS != dwError)
            ||
            (dwDeviceValue > 100)
          )
        {
            // Failed to get the device value or value is invalid, just use the default.
            dwDeviceValue = 0;
        }

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMPrinterUICallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // New section.
        pOEMUIParam->pOEMOptItems[0].Level = 1;
        pOEMUIParam->pOEMOptItems[0].Flags = OPTIF_COLLAPSE;
        hrResult = GetStringResource(pOEMUIParam->hOEMHeap, 
                                     (HMODULE) pOEMUIParam->hModule, 
                                     IDS_DEV_SECTION,
                                     &pOEMUIParam->pOEMOptItems[0].pName);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("hrPrinterPropertyPage() failed to get section name. (hrResult = 0x%x)\r\n"),
                          hrResult); 
            goto Exit;
        }

        pOEMUIParam->pOEMOptItems[0].Sel = dwDeviceValue;

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

        pOEMUIParam->pOEMOptItems[0].pOptType->Type = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam = 100;
    }

Exit:

    return hrResult;
}


////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to Document property sheet.
//
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, 
                                    LPARAM lParam, 
                                    CUIHelper &Helper,
                                    CFeatures *pFeatures,
                                    BOOL bHidingStandardUI)
{
    LONG_PTR    lResult;
    HRESULT     hrResult = S_OK;


    VERBOSE(DLLTEXT("OEMDocumentPropertySheets() entry.\r\n"));

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("OEMDocumentPropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return  E_FAIL;
    }

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                WORD            wFeatures       = 0;
                WORD            wIndex          = 0;
                DWORD           dwSheets        = 0;
                PCBUSERDATA     pUserData       = NULL;
                POEMUIPSPARAM   pOEMUIParam     = (POEMUIPSPARAM) pPSUIInfo->lParamInit;
                BOOL            bPermission     = ((pOEMUIParam->dwFlags & DPS_NOPERMISSION) == 0);
                HANDLE          hHeap           = pOEMUIParam->hOEMHeap;
                POEMDEV         pOEMDev         = (POEMDEV) pOEMUIParam->pOEMDM;
                COMPROPSHEETUI  Sheet;


                // Make sure that we have the Core Driver Features.
                // Only get features if we are hiding the standard
                // document property sheets.
                if(bHidingStandardUI)
                {
                    pFeatures->Acquire(hHeap, Helper, pOEMUIParam->poemuiobj);
                    wFeatures = pFeatures->GetCount(OEMCUIP_DOCPROP);
                }

                // Init property page.
                memset(&Sheet, 0, sizeof(COMPROPSHEETUI));
                Sheet.cbSize            = sizeof(COMPROPSHEETUI);
                Sheet.Flags             = bPermission ? CPSUIF_UPDATE_PERMISSION : 0;
                Sheet.hInstCaller       = ghInstance;
                Sheet.pHelpFile         = NULL;
                Sheet.pfnCallBack       = OEMDocUICallBack;
                Sheet.pDlgPage          = CPSUI_PDLGPAGE_TREEVIEWONLY;
                Sheet.cOptItem          = wFeatures + 1;
                Sheet.IconID            = IDI_CPSUI_PRINTER;
                Sheet.CallerVersion     = 0x100;
                Sheet.OptItemVersion    = 0x100;

                // Get Caller's name.
                hrResult = GetStringResource(hHeap, ghInstance, IDS_NAME, &Sheet.pCallerName);
                if(!SUCCEEDED(hrResult))
                {
                    ERR(ERRORTEXT("hrOEMDocumentPropertySheets() failed to get caller name. (hrResult = 0x%x)\r\n"),
                                  hrResult); 
                    goto Exit;
                }

                // Get section name.
                hrResult = GetStringResource(hHeap, ghInstance, IDS_SECTION, &Sheet.pOptItemName);
                if(!SUCCEEDED(hrResult))
                {
                    ERR(ERRORTEXT("hrOEMDocumentPropertySheets() failed to get section name. (hrResult = 0x%x)\r\n"),
                                  hrResult); 
                    goto Exit;
                }

                // Init user data.
                pUserData = (PCBUSERDATA) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(CBUSERDATA));
                if(NULL == pUserData)
                {
                    ERR(ERRORTEXT("hrOEMDocumentPropertySheets() failed to allocate user data.\r\n")); 

                    hrResult = E_OUTOFMEMORY;
                    goto Exit;
                }
                pUserData->hComPropSheet        = pPSUIInfo->hComPropSheet;
                pUserData->pfnComPropSheet      = pPSUIInfo->pfnComPropSheet;
                pUserData->pOEMUIParam          = pOEMUIParam;
                pUserData->pHelper              = &Helper;
                pUserData->poemuiobj            = pOEMUIParam->poemuiobj;
                pUserData->bPermission          = bPermission;
                pUserData->bHidingStandardUI    = bHidingStandardUI;
                Sheet.UserData                  = (ULONG_PTR) pUserData;

                // Create OptItems for page.
                Sheet.pOptItem = CreateOptItems(hHeap, Sheet.cOptItem);
                if(NULL == Sheet.pOptItem)
                {
                    ERR(ERRORTEXT("hrOEMDocumentPropertySheets() failed to allocate OPTITEMs.\r\n")); 

                    hrResult = E_OUTOFMEMORY;
                    goto Exit;
                }

                // Add Core Driver features.
                for(wIndex = 0; wIndex < wFeatures; ++wIndex)
                {
                    // Initialize level and basic state for feature.
                    Sheet.pOptItem[wIndex].Level   = 1;
                    Sheet.pOptItem[wIndex].Flags   = OPTIF_COLLAPSE;

                    // Get the OPTITEM for this feature.
                    hrResult = pFeatures->InitOptItem(hHeap, 
                                                      Sheet.pOptItem + wIndex, 
                                                      wIndex, 
                                                      OEMCUIP_DOCPROP);
                    if(!SUCCEEDED(hrResult))
                    {
                        ERR(ERRORTEXT("hrOEMDocumentPropertySheets() failed to get OPTITEM for feature %hs.\r\n"),
                                      pFeatures->GetKeyword(wIndex, OEMCUIP_DOCPROP)); 

                        goto Exit;
                    }
                }

                // Initialize Plug-in OptItems
                Sheet.pOptItem[wIndex].Level   = 1;
                Sheet.pOptItem[wIndex].Flags   = OPTIF_COLLAPSE;
                Sheet.pOptItem[wIndex].Sel     = pOEMDev->dwDriverData;

                // get optitem name.
                hrResult = GetStringResource(hHeap, ghInstance, IDS_SECTION, &Sheet.pOptItem[wIndex].pName);
                if(!SUCCEEDED(hrResult))
                {
                    ERR(ERRORTEXT("hrOEMDocumentPropertySheets() failed to get OptItem %d name. (hrResult = 0x%x)\r\n"),
                                  wIndex,
                                  hrResult); 
                    goto Exit;
                }

                Sheet.pOptItem[wIndex].pOptType = CreateOptType(hHeap, 2);

                Sheet.pOptItem[wIndex].pOptType->Type                  = TVOT_UDARROW;
                Sheet.pOptItem[wIndex].pOptType->pOptParam[1].IconID   = 0;
                Sheet.pOptItem[wIndex].pOptType->pOptParam[1].lParam   = 100;


                // Add property sheets.
                lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PCOMPROPSHEETUI, 
                                                     (LPARAM)&Sheet, (LPARAM)&dwSheets);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }


Exit:

    pPSUIInfo->Result = lResult;
    return hrResult;
}


////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to printer property sheet.
//
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, 
                                  LPARAM lParam, 
                                  CUIHelper &Helper,
                                  CFeatures *pFeatures,
                                  BOOL bHidingStandardUI)
{
    LONG_PTR    lResult;
    HRESULT     hrResult = S_OK;


    VERBOSE(DLLTEXT("hrOEMDevicePropertySheets(%#x, %#x) entry\r\n"), pPSUIInfo, lParam);

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("hrOEMDevicePropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    Dump(pPSUIInfo);

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                PROPSHEETPAGE   Page;

                // If hiding standard UI, then
                // need to add Device Settings page, too.
                if(bHidingStandardUI)
                {
                    POEMUIPSPARAM   pOEMUIParam     = (POEMUIPSPARAM) pPSUIInfo->lParamInit;
                    BOOL            bPermission     = ((pOEMUIParam->dwFlags & DPS_NOPERMISSION) == 0);
                    HANDLE          hHeap           = pOEMUIParam->hOEMHeap;
                    POEMDEV         pOEMDev         = (POEMDEV) pOEMUIParam->pOEMDM;
                    WORD            wFeatures       = 0;
                    WORD            wIndex          = 0;
                    DWORD           dwSheets        = 0;
                    DLGPAGE         DlgPage;
                    PCBUSERDATA     pUserData       = NULL;
                    COMPROPSHEETUI  Sheet;


                    // Make sure that we have the Core Driver Features.
                    pFeatures->Acquire(hHeap, Helper, pOEMUIParam->poemuiobj);
                    wFeatures = pFeatures->GetCount(OEMCUIP_PRNPROP);

                    // Init DlgPage struct for Device Settings replacement page.
                    memset(&DlgPage, 0, sizeof(DLGPAGE));
                    DlgPage.cbSize          = sizeof(DLGPAGE);
                    DlgPage.DlgTemplateID   = DP_STD_TREEVIEWPAGE;

                    // Get Device Settings display name.
                    hrResult = GetStringResource(hHeap, ghInstance, IDS_DEVICE_SETTINGS_NAME, &DlgPage.pTabName);
                    if(!SUCCEEDED(hrResult))
                    {
                        ERR(ERRORTEXT("hrOEMDevicePropertySheets() failed to get Device Settings display name. (hrResult = 0x%x)\r\n"),
                                      hrResult); 
                        goto Exit;
                    }

                    // Init Device Settings replacement page.
                    memset(&Sheet, 0, sizeof(COMPROPSHEETUI));
                    Sheet.cbSize            = sizeof(COMPROPSHEETUI);
                    Sheet.Flags             = bPermission ? CPSUIF_UPDATE_PERMISSION : 0;
                    Sheet.hInstCaller       = ghInstance;
                    Sheet.pHelpFile         = NULL;
                    Sheet.pfnCallBack       = OEMDevUICallBack;
                    Sheet.pDlgPage          = &DlgPage; //CPSUI_PDLGPAGE_TREEVIEWONLY; 
                    Sheet.cOptItem          = wFeatures;
                    Sheet.cDlgPage          = 1;
                    Sheet.IconID            = IDI_CPSUI_PRINTER;
                    Sheet.CallerVersion     = 0x100;
                    Sheet.OptItemVersion    = 0x100;

                    // Get Caller's name.
                    hrResult = GetStringResource(hHeap, ghInstance, IDS_NAME, &Sheet.pCallerName);
                    if(!SUCCEEDED(hrResult))
                    {
                        ERR(ERRORTEXT("hrOEMDevicePropertySheets() failed to get caller name. (hrResult = 0x%x)\r\n"),
                                      hrResult); 
                        goto Exit;
                    }

                    // Get section name.
                    hrResult = GetStringResource(hHeap, ghInstance, IDS_SECTION, &Sheet.pOptItemName);
                    if(!SUCCEEDED(hrResult))
                    {
                        ERR(ERRORTEXT("hrOEMDevicePropertySheets() failed to get section name. (hrResult = 0x%x)\r\n"),
                                      hrResult); 
                        goto Exit;
                    }

                    // Allocate and init User data used in our callback for this page.
                    pUserData = (PCBUSERDATA) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(CBUSERDATA));
                    if(NULL == pUserData)
                    {
                        ERR(ERRORTEXT("hrOEMDevicePropertySheets() failed to allocate user data.\r\n")); 

                        hrResult = E_OUTOFMEMORY;
                        goto Exit;
                    }
                    pUserData->hComPropSheet        = pPSUIInfo->hComPropSheet;
                    pUserData->pfnComPropSheet      = pPSUIInfo->pfnComPropSheet;
                    pUserData->pOEMUIParam          = pOEMUIParam;
                    pUserData->pHelper              = &Helper;
                    pUserData->poemuiobj            = pOEMUIParam->poemuiobj;
                    pUserData->bPermission          = bPermission;
                    pUserData->bHidingStandardUI    = bHidingStandardUI;
                    Sheet.UserData                  = (ULONG_PTR) pUserData;

                    // Create OptItems for page.
                    Sheet.pOptItem = CreateOptItems(hHeap, Sheet.cOptItem);
                    if(NULL == Sheet.pOptItem)
                    {
                        ERR(ERRORTEXT("hrOEMDevicePropertySheets() failed to allocate OPTITEMs.\r\n")); 

                        hrResult = E_OUTOFMEMORY;
                        goto Exit;
                    }

                    // Add Core Driver features.
                    for(wIndex = 0; wIndex < wFeatures; ++wIndex)
                    {
                        // Initialize level and basic state for feature.
                        Sheet.pOptItem[wIndex].Level   = 1;
                        Sheet.pOptItem[wIndex].Flags   = OPTIF_COLLAPSE;

                        // Get the OPTITEM for this feature.
                        hrResult = pFeatures->InitOptItem(hHeap, 
                                                          Sheet.pOptItem + wIndex, 
                                                          wIndex, 
                                                          OEMCUIP_PRNPROP);
                        if(!SUCCEEDED(hrResult))
                        {
                            ERR(ERRORTEXT("hrOEMDevicePropertySheets() failed to get OPTITEM for feature %hs.\r\n"),
                                          pFeatures->GetKeyword(wIndex, OEMCUIP_PRNPROP)); 

                            goto Exit;
                        }
                    }

                    // Add property sheets.
                    lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PCOMPROPSHEETUI, 
                                                         (LPARAM)&Sheet, (LPARAM)&dwSheets);
                    if(!SUCCEEDED(lResult))
                    {
                        ERR(ERRORTEXT("hrOEMDevicePropertySheets() failed to add Device Settings replacement page. (lResult = 0x%x)\r\n"),
                                      lResult); 
                        goto Exit;
                    }
                }

                // Init our property page.
                memset(&Page, 0, sizeof(PROPSHEETPAGE));
                Page.dwSize         = sizeof(PROPSHEETPAGE);
                Page.dwFlags        = PSP_DEFAULT;
                Page.hInstance      = ghInstance;
                Page.pszTemplate    = MAKEINTRESOURCE(IDD_DEVICE_PROPPAGE);
                Page.pfnDlgProc     = DevicePropPageProc;

                // Add property sheets.
                lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PROPSHEETPAGE, (LPARAM)&Page, 0);
                if(!SUCCEEDED(lResult))
                {
                    ERR(ERRORTEXT("hrOEMDevicePropertySheets() failed to add our Device Property page. (lResult = 0x%x)\r\n"),
                                  lResult); 
                    goto Exit;
                }

                VERBOSE(DLLTEXT("hrOEMDevicePropertySheets() pfnComPropSheet returned %d.\r\n"), lResult);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }


Exit:

    pPSUIInfo->Result = lResult;
    return hrResult;
}


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM printer property UI.
//
LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMPrinterUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            {
                DWORD   dwDriverValue = pOEMUIParam->pOEMOptItems[0].Sel;

                // Store OptItems state in printer data.
                SetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, REG_DWORD, (PBYTE) &dwDriverValue, sizeof(DWORD));
            }
            break;

        default:
            break;
    }

    return lReturn;
}


////////////////////////////////////////////////////////////////////////////////
//
// Call back for OEM device property UI.
//
INT_PTR CALLBACK DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg)
    {
        case WM_COMMAND:
            switch(HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch(LOWORD(wParam))
                    {
                        case IDC_CALIBRATE:
                            // Just display a message that the printer is calibrated,
                            // since we don't acutally calibrate anything.
                            {
                                TCHAR   szName[MAX_PATH];
                                TCHAR   szCalibrated[MAX_PATH];


                                LoadString(ghInstance, IDS_NAME, szName, sizeof(szName)/sizeof(szName[0]));
                                LoadString(ghInstance, IDS_CALIBRATED, szCalibrated, sizeof(szCalibrated)/sizeof(szCalibrated[0]));
                                MessageBox(hDlg, szCalibrated, szName, MB_OK);
                            }
                            break;
                    }
                    break;

                default:
                    return FALSE;
            }
            return TRUE;

        case WM_NOTIFY:
            {
                switch (((LPNMHDR)lParam)->code)  // type of notification message
                {
                    case PSN_SETACTIVE:
                        break;
    
                    case PSN_KILLACTIVE:
                        break;

                    case PSN_APPLY:
                        break;

                    case PSN_RESET:
                        break;
                }
            }
            break;
    }

    return FALSE;
} 


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM document property UI.
//
LONG APIENTRY OEMDocUIItemCallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUIItemCallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            // Store OptItems state in DEVMODE.
            pOEMDev->dwAdvancedData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

        case CPSUICB_REASON_KILLACTIVE:
            pOEMDev->dwAdvancedData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

        case CPSUICB_REASON_SETACTIVE:
            if(pOEMUIParam->pOEMOptItems[0].Sel != pOEMDev->dwAdvancedData)
            {
                pOEMUIParam->pOEMOptItems[0].Sel    = pOEMDev->dwAdvancedData;
                pOEMUIParam->pOEMOptItems[0].Flags |= OPTIF_CHANGED;
                lReturn                             = CPSUICB_ACTION_OPTIF_CHANGED;
            }
            break;

        default:
            break;
    }

    return lReturn;
}


LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam)
{
    WORD            wItems      = pCallbackParam->cOptItem;
    LONG            lReturn     = CPSUICB_ACTION_NONE;
    POPTITEM        pOptItem    = pCallbackParam->pOptItem;
    PCBUSERDATA     pUserData   = (PCBUSERDATA) pCallbackParam->UserData;
    HANDLE          hHeap       = pUserData->pOEMUIParam->hOEMHeap;
    POEMDEV         pOEMDev     = (POEMDEV) pUserData->pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    //
    // If user has no permission to change anything, then
    // simply return without taking any action.
    //

    if (!pUserData->bPermission && (pCallbackParam->Reason != CPSUICB_REASON_ABOUT))
        return CPSUICB_ACTION_NONE;

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            if(wItems > 0)
            {
                // Save feature options if hidig standard UI.
                if(pUserData->bHidingStandardUI)
                {
                    HRESULT hrResult;


                    // Save feature OPTITEMs.
                    hrResult = SaveFeatureOptItems(hHeap, 
                                                   pUserData->pHelper,
                                                   pUserData->poemuiobj,
                                                   pCallbackParam->hDlg,
                                                   pOptItem,
                                                   wItems);
                    if(!SUCCEEDED(hrResult))
                    {
                        // Return that we didn't save changes.
                        // NOTE: it is up to SaveFeatureOptItems() to display
                        //       any UI for failure.
                        return CPSUICB_ACTION_NO_APPLY_EXIT;
                    }
                }

                // Save OPTITEM that we explicitly added.
                pOEMDev->dwDriverData = pOptItem[wItems - 1].Sel;
                pUserData->pfnComPropSheet(pUserData->hComPropSheet, CPSFUNC_SET_RESULT,
            	                           (LPARAM)pUserData->hPropPage,
               	                           (LPARAM)CPSUI_OK);

            }
            break;

        case CPSUICB_REASON_KILLACTIVE:
            if(wItems > 0)
            {
                // Update OPTITEM that we explicitly added.
                pOEMDev->dwDriverData = pOptItem[wItems - 1].Sel;
            }
            break;

        case CPSUICB_REASON_SETACTIVE:
            if(wItems > 0)
            {
                if(pOptItem[wItems - 1].Sel != pOEMDev->dwDriverData)
                {
                    // Update OPTITEM that we explicitly added.
                    pOptItem[wItems - 1].Sel     = pOEMDev->dwDriverData;
                    pOptItem[wItems - 1].Flags  |= OPTIF_CHANGED;
                }
            }
            lReturn = CPSUICB_ACTION_OPTIF_CHANGED;
            break;

        default:
            break;
    }

    return lReturn;
}

LONG APIENTRY OEMDevUICallBack(PCPSUICBPARAM pCallbackParam)
{
    WORD            wItems      = pCallbackParam->cOptItem;
    LONG            lReturn     = CPSUICB_ACTION_NONE;
    POPTITEM        pOptItem    = pCallbackParam->pOptItem;
    PCBUSERDATA     pUserData   = (PCBUSERDATA) pCallbackParam->UserData;
    HANDLE          hHeap       = pUserData->pOEMUIParam->hOEMHeap;


    VERBOSE(DLLTEXT("OEMDevUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    //
    // If user has no permission to change anything, then
    // simply return without taking any action.
    //

    if (!pUserData->bPermission && (pCallbackParam->Reason != CPSUICB_REASON_ABOUT))
        return CPSUICB_ACTION_NONE;

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            if(wItems > 0)
            {
                // Save feature options if hidig standard UI.
                if(pUserData->bHidingStandardUI)
                {
                    HRESULT hrResult;


                    // Save feature OPTITEMs.
                    hrResult = SaveFeatureOptItems(hHeap, 
                                                   pUserData->pHelper,
                                                   pUserData->poemuiobj,
                                                   pCallbackParam->hDlg,
                                                   pOptItem,
                                                   wItems);
                    if(!SUCCEEDED(hrResult))
                    {
                        // Return that we didn't save changes.
                        // NOTE: it is up to SaveFeatureOptItems() to display
                        //       any UI for failure.
                        return CPSUICB_ACTION_NO_APPLY_EXIT;
                    }
                }

                
                pUserData->pfnComPropSheet(pUserData->hComPropSheet, CPSFUNC_SET_RESULT,
            	                           (LPARAM)pUserData->hPropPage,
               	                           (LPARAM)CPSUI_OK);
            }
            break;

        case CPSUICB_REASON_KILLACTIVE:
            break;

        case CPSUICB_REASON_SETACTIVE:
            break;

        default:
            break;
    }

    return lReturn;
}



////////////////////////////////////////////////////////////////////////////////
//
// Creates and Initializes OptItems.
//
POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems)
{
    POPTITEM    pOptItems = NULL;


    // Allocate memory for OptItems;
    pOptItems = (POPTITEM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTITEM) * dwOptItems);
    if(NULL != pOptItems)
    {
        InitOptItems(pOptItems, dwOptItems);
    }
    else
    {
        ERR(ERRORTEXT("CreateOptItems() failed to allocate memory for OPTITEMs!\r\n"));
    }

    return pOptItems;
}


////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems.
//
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems)
{
    VERBOSE(DLLTEXT("InitOptItems() entry.\r\n"));

    // Zero out memory.
    memset(pOptItems, 0, sizeof(OPTITEM) * dwOptItems);

    // Set each OptItem's size, and Public DM ID.
    for(DWORD dwCount = 0; dwCount < dwOptItems; dwCount++)
    {
        pOptItems[dwCount].cbSize = sizeof(OPTITEM);
        pOptItems[dwCount].DMPubID = DMPUB_NONE;
    }
}


////////////////////////////////////////////////////////////////////////////////
//
// Allocates and initializes OptType for OptItem.
//
POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams)
{
    POPTTYPE    pOptType = NULL;


    VERBOSE(DLLTEXT("CreateOptType() entry.\r\n"));

    // Allocate memory from the heap for the OPTTYPE; the driver will take care of clean up.
    pOptType = (POPTTYPE) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTTYPE));
    if(NULL != pOptType)
    {
        // Initialize OPTTYPE.
        pOptType->cbSize = sizeof(OPTTYPE);
        pOptType->Count = wOptParams;

        // Allocate memory from the heap for the OPTPARAMs for the OPTTYPE.
        pOptType->pOptParam = (POPTPARAM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, wOptParams * sizeof(OPTPARAM));
        if(NULL != pOptType->pOptParam)
        {
            // Initialize the OPTPARAMs.
            for(WORD wCount = 0; wCount < wOptParams; wCount++)
            {
                pOptType->pOptParam[wCount].cbSize = sizeof(OPTPARAM);
            }
        }
        else
        {
            ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTPARAMs!\r\n"));

            // Free allocated memory and return NULL.
            HeapFree(hHeap, 0, pOptType);
            pOptType = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTTYPE!\r\n"));
    }

    return pOptType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oemui.h"
#include "debug.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));
            ghInstance = hInst;
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}


}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\globals.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Globals.cpp
//    
//
//  PURPOSE:  File that contains all the globals.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//
#define _GLOBALS_H

#include "precomp.h"
#include "oemui.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
HINSTANCE   ghInstance = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\globals.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Globals.h
//    
//
//  PURPOSE:   Lists of globals declared in Globals.cpp.
//
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _GLOBALS_H
#define _GLOBALS_H


///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
extern HINSTANCE   ghInstance;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif


// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
#include <WINDDI.H>
#include <WINSPOOL.H>
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRSHT.H>
#include <COMPSTUI.H>
#include <WINDDIUI.H>
#include <PRINTOEM.H>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\stringutils.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  2001 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	StringUtils.h
//    
//
//  PURPOSE:  Header file for string utility routines.
//
//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _STRINGUTILS_H
#define _STRINGUTILS_H

#include "precomp.h"




////////////////////////////////////////////////////////
//      Prototypes
////////////////////////////////////////////////////////

HRESULT MakeStrPtrList(HANDLE hHeap, PCSTR pmszMultiSz, PCSTR **pppszList, PWORD pwCount);
WORD mstrcount(PCSTR pmszMultiSz);
PWSTR MakeUnicodeString(HANDLE hHeap, PCSTR pszAnsi);
PWSTR MakeStringCopy(HANDLE hHeap, PCWSTR pszSource);
PSTR MakeStringCopy(HANDLE hHeap, PCSTR pszSource);
void FreeStringList(HANDLE hHeap, PWSTR *ppszList, WORD wCount);
HRESULT GetStringResource(HANDLE hHeap, HMODULE hModule, UINT uResource, PWSTR *ppszString);
HRESULT GetStringResource(HANDLE hHeap, HMODULE hModule, UINT uResource, PSTR *ppszString);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _DEBUG_H
#define _DEBUG_H


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);
void Dump(PPROPSHEETUI_INFO pPSUIInfo);
void Dump(POPTITEM pOptItem);
void Dump(POPTTYPE pOptType);
void Dump(POPTPARAM pOptParam, WORD wCount);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\devmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Devmode.cpp
//    
//
//  PURPOSE:  Implementation of Devmode functions shared with OEM UI and OEM rendering modules.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oemui.h"
#include "debug.h"
#include "devmode.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>


//
//Performs operation on UI Plugins Private DevMode Members.
//Called via IOemUI::DevMode
//

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam)
{
    POEMDEV pOEMDevIn;
    POEMDEV pOEMDevOut;


    // Verify parameters.
    if( (NULL == pOemDMParam)
        ||
        ( (OEMDM_SIZE != dwMode)
          &&
          (OEMDM_DEFAULT != dwMode)
          &&
          (OEMDM_CONVERT != dwMode)
          &&
          (OEMDM_MERGE != dwMode)
        )
      )
    {
        ERR(ERRORTEXT("DevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOemDMParam = %#lx.\r\n"), dwMode, pOemDMParam);

        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Cast generic (i.e. PVOID) to OEM private devomode pointer type.
    pOEMDevIn = (POEMDEV) pOemDMParam->pOEMDMIn;
    pOEMDevOut = (POEMDEV) pOemDMParam->pOEMDMOut;

    switch(dwMode)
    {
		//
		//The Method should return the size of the memory allocation needed to store the UI plugin Private DEVMODE.
		//
        case OEMDM_SIZE:
            pOemDMParam->cbBufSize = sizeof(OEMDEV);
            break;

		//
		//Should fill the Private DEVMODE with the default values.
		//
        case OEMDM_DEFAULT:
			//
			//OEM_DMEXTRAHEADER Members
			//
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;

			//
			//Private members
			//
            pOEMDevOut->dwDriverData            = 0;
            pOEMDevOut->dwAdvancedData          = 0;

            VERBOSE(DLLTEXT("pOEMDevOut after setting default values:\r\n"));
            Dump(pOEMDevOut);			
            break;
			
		//
		//The method should convert private DEVMODE members to the current version, if necessary.
		//
        case OEMDM_CONVERT:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            break;
		
		//
		//The method should validate the information contained in private DEVMODE members and merge validated values into a private DEVMODE structure containing default values
		//
        case OEMDM_MERGE:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            MakeOEMDevmodeValid(pOEMDevOut);
            break;
    }
    Dump(pOemDMParam);

    return S_OK;
}


BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut)
{
    if( (NULL == pOEMDevIn)
        ||
        (NULL == pOEMDevOut)
      )
    {
        ERR(ERRORTEXT("ConvertOEMDevmode() invalid parameters.\r\n"));
        return FALSE;
    }

    // Check OEM Signature, if it doesn't match ours,
    // then just assume DMIn is bad and use defaults.
    if(pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature)
    {
        VERBOSE(DLLTEXT("Converting private OEM Devmode.\r\n"));
        VERBOSE(DLLTEXT("pOEMDevIn:\r\n"));
        Dump(pOEMDevIn);

        // Set the devmode defaults so that anything the isn't copied over will
        // be set to the default value.
        pOEMDevOut->dwDriverData    = 0;
        pOEMDevOut->dwAdvancedData  = 0;

        // Copy the old structure in to the new using which ever size is the smaller.
        // Devmode maybe from newer Devmode (not likely since there is only one), or
        // Devmode maybe a newer Devmode, in which case it maybe larger,
        // but the first part of the structure should be the same.

        // DESIGN ASSUMPTION: the private DEVMODE structure only gets added to;
        // the fields that are in the DEVMODE never change only new fields get added to the end.

        memcpy(pOEMDevOut, pOEMDevIn, __min(pOEMDevOut->dmOEMExtra.dwSize, pOEMDevIn->dmOEMExtra.dwSize));

        // Re-fill in the size and version fields to indicated 
        // that the DEVMODE is the current private DEVMODE version.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
    }
    else
    {
        WARNING(DLLTEXT("Unknown DEVMODE signature, pOEMDMIn ignored.\r\n"));

        // Don't know what the input DEVMODE is, so just use defaults.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
        pOEMDevOut->dwDriverData            = 0;
        pOEMDevOut->dwAdvancedData          = 0;
    }

    return TRUE;
}


BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode)
{
    if(NULL == pOEMDevmode)
    {
        return FALSE;
    }

    // ASSUMPTION: pOEMDevmode is large enough to contain OEMDEV structure.

    // Make sure that dmOEMExtra indicates the current OEMDEV structure.
    pOEMDevmode->dmOEMExtra.dwSize       = sizeof(OEMDEV);
    pOEMDevmode->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
    pOEMDevmode->dmOEMExtra.dwVersion    = OEM_VERSION;

    // Set driver data, if not valid.
    if(pOEMDevmode->dwDriverData > 100)
    {
        pOEMDevmode->dwDriverData = 0;
    }

    // Set Advanced driver data, if not valid.
    if(pOEMDevmode->dwAdvancedData > 100)
    {
        pOEMDevmode->dwAdvancedData = 0;
    }

    return TRUE;
}


void Dump(PCOEMDEV pOEMDevmode)
{
    if( (NULL != pOEMDevmode)
        &&
        (pOEMDevmode->dmOEMExtra.dwSize >= sizeof(OEMDEV))
        &&
        (OEM_SIGNATURE == pOEMDevmode->dmOEMExtra.dwSignature)
      )
    {
        VERBOSE(TEXT("\tdmOEMExtra.dwSize      = %d\r\n"), pOEMDevmode->dmOEMExtra.dwSize);
        VERBOSE(TEXT("\tdmOEMExtra.dwSignature = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwSignature);
        VERBOSE(TEXT("\tdmOEMExtra.dwVersion   = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwVersion);
        VERBOSE(TEXT("\tdwDriverData           = %#x\r\n"), pOEMDevmode->dwDriverData);
        VERBOSE(TEXT("\tdwAdvancedData         = %#x\r\n"), pOEMDevmode->dwAdvancedData);
    }
    else
    {
        ERR(ERRORTEXT("Dump(POEMDEV) unknown private OEM DEVMODE.\r\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\oemui.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    OEMUI.cpp
//    
//
//  PURPOSE:  Main file for OEM UI test module.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "resource.h"
#include "debug.h"
#include "oemui.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      INTERNAL MACROS and DEFINES
////////////////////////////////////////////////////////

typedef struct _tagCBUserData 
{
    HANDLE          hComPropSheet;
    HANDLE          hPropPage;
    POEMUIPSPARAM   pOEMUIParam;
    PFNCOMPROPSHEET pfnComPropSheet;

} CBUSERDATA, *PCBUSERDATA;


////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);

LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUICallBack2(PCPSUICBPARAM pCallbackParam);
INT_PTR CALLBACK DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);

void SetOEMUiState (HWND hDlg, POEMSHEETDATA pOEMSheetData);
void SetOEMCommonDataIntoOptItem (POEMSHEETDATA pOEMSheetData, PSTR PName, LONG Sel);
void ChangeOpItem (IPrintOemDriverUI *pIPrintOEMDrvUI,  POEMUIOBJ pOEMObj, POPTITEM pOptItem, int iSel);
POPTITEM FindDrvOptItem (POPTITEM pDrvOptItems, DWORD dwItemCount, PSTR pKeyWordName, BYTE dmPubID = DMPUB_NONE);

static POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems);
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems);
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams);
static PTSTR GetStringResource(HANDLE hHeap, HANDLE hModule, UINT uResource);

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM device or document property UI.
// Called via IOemUI::CommonUIProp
//
HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    HRESULT hResult = S_OK;


    VERBOSE(DLLTEXT("hrOEMPropertyPage(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (OEMCUIP_DOCPROP != dwMode)
        &&
        (OEMCUIP_PRNPROP != dwMode)        
      )
    {
        ERR(ERRORTEXT("hrOEMPropertyPage() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOEMUIParam = %#lx.\r\n"), dwMode, pOEMUIParam);

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        case OEMCUIP_DOCPROP:
            hResult = hrDocumentPropertyPage(dwMode, pOEMUIParam);
            break;

        case OEMCUIP_PRNPROP:
            hResult = hrPrinterPropertyPage(dwMode, pOEMUIParam);
            break;

        default:
            // Should never reach this!
            ERR(ERRORTEXT("hrOEMPropertyPage() Invalid dwMode, %d"), dwMode);
            SetLastError(ERROR_INVALID_PARAMETER);
            hResult = E_FAIL;
            break;
    }

    return hResult;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM document property UI.
//
static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM document property UI.
        pOEMUIParam->cOEMOptItems = 1;
        VERBOSE(DLLTEXT("hrDocumentPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
        POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


        VERBOSE(DLLTEXT("hrDocumentPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMDocUICallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // New section.
        pOEMUIParam->pOEMOptItems[0].Level  = 1;
        pOEMUIParam->pOEMOptItems[0].Flags  = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].pName  = GetStringResource(pOEMUIParam->hOEMHeap, pOEMUIParam->hModule, IDS_ADV_SECTION);
        pOEMUIParam->pOEMOptItems[0].Sel    = pOEMDev->dwAdvancedData;

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);
		
		//
		//Setup the Optional Item
		//
        pOEMUIParam->pOEMOptItems[0].pOptType->Type = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam = 100;
    }

    return S_OK;
}



////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM printer property UI.
//
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
	//
	//This is null the first time the interface is called.
	//
    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM printer property UI.
        pOEMUIParam->cOEMOptItems = 1;
        VERBOSE(DLLTEXT("hrPrinterPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
		//
		//This is the second time we are called Now setup the optional items.
		//
        DWORD   dwError;
        DWORD   dwDeviceValue;
        DWORD   dwType;
        DWORD   dwNeeded;

        VERBOSE(DLLTEXT("hrPrinterPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

		//
		//Add OEM Optitem to the Device
		//

        // Get device settings value from printer.
        dwError = GetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, &dwType, (PBYTE) &dwDeviceValue,
                                   sizeof(dwDeviceValue), &dwNeeded);
        if( (ERROR_SUCCESS != dwError)
            ||
            (dwDeviceValue > 100)
          )
        {
            // Failed to get the device value or value is invalid, just use the default.
            dwDeviceValue = 0;
        }

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMPrinterUICallBack;

		
        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.
        // New section.
        pOEMUIParam->pOEMOptItems[0].Level = 1;
        pOEMUIParam->pOEMOptItems[0].Flags = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].pName = GetStringResource(pOEMUIParam->hOEMHeap, pOEMUIParam->hModule, IDS_DEV_SECTION);
        pOEMUIParam->pOEMOptItems[0].Sel = dwDeviceValue;

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

		//
		//Setup the Optional Item
		//
	    pOEMUIParam->pOEMOptItems[0].pOptType->Type = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam = 100;
				
		
    }
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to Document property sheet. Called via IOemUI::DocumentPropertySheets
//
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, 
                                    IPrintOemDriverUI*  pOEMHelp)
{
    LONG_PTR    lResult;


    VERBOSE(DLLTEXT("OEMDocumentPropertySheets() entry.\r\n"));

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("OEMDocumentPropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return  E_FAIL;
    }

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                DWORD           dwSheets    = 0;
                PCBUSERDATA     pUserData;
                POEMUIPSPARAM   pOEMUIParam = (POEMUIPSPARAM) pPSUIInfo->lParamInit;
                HANDLE          hHeap       = pOEMUIParam->hOEMHeap;
                POEMDEV         pOEMDev     = (POEMDEV) pOEMUIParam->pOEMDM;
                COMPROPSHEETUI  Sheet;


                // Init property page.
                memset(&Sheet, 0, sizeof(COMPROPSHEETUI));
                Sheet.cbSize            = sizeof(COMPROPSHEETUI);
                Sheet.Flags             = CPSUIF_UPDATE_PERMISSION;
                Sheet.hInstCaller       = ghInstance;
                Sheet.pCallerName       = GetStringResource(hHeap, ghInstance, IDS_NAME);
                Sheet.pHelpFile         = NULL;
                Sheet.pfnCallBack       = OEMDocUICallBack2;
                Sheet.pDlgPage          = CPSUI_PDLGPAGE_TREEVIEWONLY;
                Sheet.cOptItem          = 1;
                Sheet.IconID            = IDI_CPSUI_PRINTER;
                Sheet.pOptItemName      = GetStringResource(hHeap, ghInstance, IDS_SECTION);
                Sheet.CallerVersion     = 0x100;
                Sheet.OptItemVersion    = 0x100;

                // Init user data.
                pUserData = (PCBUSERDATA) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(CBUSERDATA));
                pUserData->hComPropSheet    = pPSUIInfo->hComPropSheet;
                pUserData->pfnComPropSheet  = pPSUIInfo->pfnComPropSheet;
                pUserData->pOEMUIParam      = pOEMUIParam;
                Sheet.UserData              = (ULONG_PTR) pUserData;

                // Create OptItems for page.
                Sheet.pOptItem = CreateOptItems(hHeap, Sheet.cOptItem);

                // Initialize OptItems
                Sheet.pOptItem[0].Level = 1;
                Sheet.pOptItem[0].Flags = OPTIF_COLLAPSE;
                Sheet.pOptItem[0].pName = GetStringResource(hHeap, ghInstance, IDS_SECTION);
                Sheet.pOptItem[0].Sel   = pOEMDev->dwDriverData;
								
                Sheet.pOptItem[0].pOptType = CreateOptType(hHeap, 2);
				
				//
				//Set the UI prop of this OPTYPE item.
				//
				Sheet.pOptItem[0].pOptType->Type = TVOT_UDARROW;
                Sheet.pOptItem[0].pOptType->pOptParam[1].IconID = 0;
                Sheet.pOptItem[0].pOptType->pOptParam[1].lParam = 100;
                
                // Adds the  property sheets.
                lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PCOMPROPSHEETUI, 
                                                     (LPARAM)&Sheet, (LPARAM)&dwSheets);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }

    pPSUIInfo->Result = lResult;
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to printer property sheet. Called via IOemUI::DevicePropertySheets
//
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, POEMSHEETDATA pOemSheetData)
{
    LONG_PTR    lResult;


    VERBOSE(DLLTEXT("hrOEMDevicePropertySheets(%#x, %#x) entry\r\n"), pPSUIInfo, lParam);

    // Validate parameters.
    if( (NULL == pPSUIInfo)

        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("hrOEMDevicePropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    Dump(pPSUIInfo);


    // Do action.
    switch(pPSUIInfo->Reason)
    {
		
        case PROPSHEETUI_REASON_INIT:
            {
                PROPSHEETPAGE   Page;
				
                // Init property page.
                memset(&Page, 0, sizeof(PROPSHEETPAGE));
                Page.dwSize = sizeof(PROPSHEETPAGE);
                Page.dwFlags = PSP_DEFAULT;
                Page.hInstance = ghInstance;
                Page.pszTemplate = MAKEINTRESOURCE(IDD_DEVICE_PROPPAGE);
                Page.pfnDlgProc = DevicePropPageProc;

				//
				//This is the OEMPlugIN Sheets Shared Data. Use this Pointer to gain access to shared driver data
				//
				pOemSheetData->hComPropSheet = pPSUIInfo->hComPropSheet;
				pOemSheetData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
				Page.lParam = (LPARAM)pOemSheetData;

                // Add property sheets.
                pOemSheetData->hmyPlugin = (HANDLE)(pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PROPSHEETPAGE, (LPARAM)&Page, 0));

                VERBOSE(DLLTEXT("hrOEMDevicePropertySheets() pfnComPropSheet returned %d.\r\n"), pOemSheetData->hmyPlugin);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }

    pPSUIInfo->Result = lResult;
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM printer property UI.
//
LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMPrinterUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            {
                DWORD   dwDriverValue = pOEMUIParam->pOEMOptItems[0].Sel;

				//
                // Store OptItems state in printer data. 
				//
                SetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, REG_DWORD, (PBYTE) &dwDriverValue, sizeof(DWORD));
            }
            break;
		
		//
		//Because the plugin page is changing items in this CPSUI page we need to rinitalise the data on the page.
		//
		case CPSUICB_REASON_SETACTIVE:
			return CPSUICB_ACTION_OPTIF_CHANGED;
			break;

        default:
            break;
    }

    return lReturn;
}



////////////////////////////////////////////////////////////////////////////////
//
// Call back for OEM device property UI.
// 
// This OEM plugin page is using the OPTITEMS in the Device tab to store data. (Installabale Options)
// If you hide these option in the device tab and only access them from your UI you dont have to worry about sync the views.
// If you want the Options in both tabs you need to have a CPSUICALLBACK function defined for the Device tab. (OEMPrinterUICallBack)
// OEMPrinterUICallBack will return CPSUICB_ACTION_OPTIF_CHANGED; to indicate that some of the controls have change. Resulting in CPSUI to refresh the view. 
//
INT_PTR CALLBACK DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
	
	VERBOSE(DLLTEXT("DevicePropPageProc() entry, Reason is %d.\r\n"), uiMsg);

	POEMSHEETDATA	pOEMSheetData	= NULL;
	LONG			lState			= 0;
	DWORD			fDataValid		= 0;
	WORD			dlgControl		= 0;
	PSTR			pControlName	= NULL;
	

	if ( uiMsg != WM_INITDIALOG )
	{	
		//
		//Retrieves Application data storded by the call to SetWindowLongPtr.
		//
		pOEMSheetData = (POEMSHEETDATA)GetWindowLongPtr( hDlg, DWLP_USER);
		

		if (!pOEMSheetData)
		{
			//
			//Failed to get the OEM Prop Page Data Pointer.
			//
			ERR(ERRORTEXT("DevicePropPageProc : GetWindowLongPtr Failed (%d)\r\n"), GetLastError());	
			return FALSE;
		}
	}

    switch (uiMsg)
    {
		case WM_INITDIALOG:
			//
			//PROPSHEETPAGE structure is passed to the dialog box procedure with a WM_INITDIALOG message. 
			//The lParam member is provided to allow you to pass application-specific information to the dialog box procedure
			//
			SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR)((LPPROPSHEETPAGE)lParam)->lParam);
			break;

        case WM_COMMAND:
            switch(HIWORD(wParam))
            {

                case BN_CLICKED:

					//
					//Change the UI to activate the apply button Send the prop dailog a change message.
					//
					PropSheet_Changed(GetParent(hDlg), hDlg);

                    switch(LOWORD(wParam))
                    {

						//
						//USER modified OEM Controls on the plugin page.
						//
						case IDC_CHECK_DUPLPEX:
							dlgControl = IDC_CHECK_DUPLPEX;
							fDataValid = TRUE;
							pControlName = (PSTR)DUPLEXUNIT;
							break;

						case IDC_CHECK_HDRIVE:
							dlgControl = IDC_CHECK_HDRIVE;
							fDataValid = TRUE;
							pControlName = (PSTR)PRINTERHDISK;
							break;

						case IDC_CHECK_ENVFEEDER:
							dlgControl = IDC_CHECK_ENVFEEDER;
							fDataValid = TRUE;
							pControlName = (PSTR)ENVFEEDER;
							break;

						default:
							fDataValid = 0;	
							break;

					}

					//
					//If the Control is valid Get the ctrl state and UPdate the OPTITEM.
					//
					if ( fDataValid )
					{
						lState = (LONG)(SendDlgItemMessage (hDlg, dlgControl, BM_GETSTATE, 0, 0) & 0x0003);
						VERBOSE(DLLTEXT("DevicePropPageProc  :  Clicked dlgControl (%d)\r\n"), lState);
						
						//
						//Saves the Data to the OPTITEMS in the device settings page.
						//
						SetOEMCommonDataIntoOptItem (pOEMSheetData, pControlName, lState);
					}
                    break;

						
                default:
                    return FALSE;
            }
            return TRUE;

		//
		//Dailog is going to paint set up the UI controls to match the relavent OPTITEMS Data.
		//
		case WM_CTLCOLORDLG:
			{
				VERBOSE(DLLTEXT("DevicePropPageProc : WM_CTLCOLORDLG \r\n"));
				SetOEMUiState (hDlg, pOEMSheetData);
			}
			return TRUE;


        case WM_NOTIFY:
            {
                switch (((LPNMHDR)lParam)->code)  // type of notification message
                {
                    case PSN_SETACTIVE:
						return TRUE;
                        break;
    
                    case PSN_KILLACTIVE:
						return TRUE;
                        break;

                    case PSN_APPLY:

						//
						//Calls ComPropSheet 
						//causes the ComPropSheet function to pass a specified result value to all PFNPROPSHEETUI-typed functions associated with a specified page and its parents
						//
						pOEMSheetData->pfnComPropSheet(pOEMSheetData->hComPropSheet, 
													   CPSFUNC_SET_RESULT, 
													   (LPARAM) pOEMSheetData->hmyPlugin, 
													   (LPARAM)CPSUI_OK);
											
						//
						//Accept the apply if the data was invalid and you are checking for this set PSNRET_INVALID | PSNRET_INVALID_NOCHANGEPAGE
						//Disables the APPLY button and saves the Data.
						//
						PropSheet_UnChanged(GetParent(hDlg), hDlg);
						SetWindowLongPtr(hDlg,DWLP_MSGRESULT,PSNRET_NOERROR);
						return TRUE;
                        break;

					//
					// Need To undo the changes
					//
                    case PSN_RESET:
						 break;
                }
            }
            break;
    }

    return FALSE;
} 

////////////////////////////////////////////////////////////////////////////////
//
// Update the OEM page controls to match the Device settings page
//

void SetOEMUiState (HWND hDlg, POEMSHEETDATA pOEMSheetData)
{
	LRESULT			lstate = 0;
	POEMCUIPPARAM	pOEMCUIParam = NULL;
	PUSERDATA		pUserData = NULL;
	POPTITEM		pOptItem = NULL;
	DWORD			cDrvOptItems = 0;

	
	if (pOEMSheetData->pOEMCUIParam)
	{
		pOEMCUIParam = pOEMSheetData->pOEMCUIParam;
		cDrvOptItems = pOEMCUIParam->cDrvOptItems;
	}
	
	//
	//loop down the OPITEMS and retrieve the data that is needed from the control
	//(all Optitesm are ref from DMPubID of the UserData->pKeyWordName)
	//
	for (DWORD i=0; i < cDrvOptItems; i++)
	{
		pOptItem = &(pOEMCUIParam->pDrvOptItems[i]);
		if (pOptItem->UserData)
		{
			pUserData = (PUSERDATA)(pOptItem->UserData);
			if ( pUserData->pKeyWordName )
			{
				//
				//Get the Selection of the OPITEM
				//
				if (pOptItem->Sel)
				{
					lstate = BST_CHECKED;
				}
				else
				{
					lstate = BST_UNCHECKED;
				}

				//
				//Update the Data in OEM Page to mactch the data in the Device Settings TAB.
				//Send a message to the Cntrol to update its State.
				//

				//Set the Duplex Option
				if ( strcmp(pUserData->pKeyWordName, DUPLEXUNIT ) == 0 )
				{
					SendDlgItemMessage (hDlg, IDC_CHECK_DUPLPEX, BM_SETCHECK, lstate, 0);
				}
				
				//Set HardDrive Option
				if ( strcmp (pUserData->pKeyWordName, PRINTERHDISK ) == 0 )
				{
					SendDlgItemMessage (hDlg, IDC_CHECK_HDRIVE, BM_SETCHECK, lstate, 0);
				}
					
				//Set the Env Feeder Option
				if ( strcmp (pUserData->pKeyWordName, ENVFEEDER ) == 0 )
				{
					SendDlgItemMessage (hDlg, IDC_CHECK_ENVFEEDER, BM_SETCHECK, lstate, 0);
				}
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
// Save the OEM change into the correct OPTITEM. 
// The UI data is been stored in the driver supplied OPTITEM
//
void SetOEMCommonDataIntoOptItem (POEMSHEETDATA pOEMSheetData, PSTR PName, LONG Sel)
{

	VERBOSE(DLLTEXT("SetOEMCommonDataIntoOptItem (%S) \r\n"), PName);
	
    POEMCUIPPARAM pOEMCUIParam = pOEMSheetData->pOEMCUIParam;
	POPTITEM pOptItem = NULL;
	
	//
	//Find the OPTITEM that needs to be Updated.
	//
	pOptItem = FindDrvOptItem (pOEMCUIParam->pDrvOptItems, 
							   pOEMCUIParam->cDrvOptItems,
							   PName, 
							   DMPUB_NONE);

	if (pOptItem)
	{
		ChangeOpItem (pOEMSheetData->pOEMHelp, 
					  pOEMCUIParam->poemuiobj, 
					  pOptItem, 
					  Sel);
	}
	else
	{
		ERR(ERRORTEXT("SetOEMCommonDataIntoOptItem Item Not Found OPTITEM(%S) \r\n"), PName);	
	}
}


////////////////////////////////////////////////////////////////////////////////
//
// Help Change the data set in the OPTITEM
//
void ChangeOpItem (IPrintOemDriverUI *pIPrintOEMDrvUI,  POEMUIOBJ pOEMUIObj, POPTITEM pOptItem, int iSel)
{
	HRESULT hRestult = S_OK; 
	
	//
	//Change the Item (Change which OPTPARAM is selected fot the required OPTTYPE)
	//
	pOptItem->Sel = iSel;

	//
	//Set the Flag indicating it is changed 
	//
	pOptItem->Flags |= OPTIF_CHANGED;
	
	//
	//Update the Driver UI. (this updates the UI but it does not cause CPSUI to update the its pages), 
	//Look at OEMPrinterUICallBack to see how CPSUI pages are updated
	//The IPrintOemDriverUI::DrvUpdateUISetting method is provided by the 
	//Unidrv and Pscript5 minidrivers so that user interface plug-ins can 
	//notify the driver of a modified user interface option.
	//
	hRestult = pIPrintOEMDrvUI->DrvUpdateUISetting((PVOID)pOEMUIObj, (PVOID)pOptItem, 0, OEMCUIP_PRNPROP);
	
	if (hRestult != S_OK)
	{
		ERR(ERRORTEXT("ChangeOpItem DrvUpdateUISetting FAILED \r\n") );
	}
	
}


////////////////////////////////////////////////////////////////////////////////
//
// Help Find a OPTITEM from the array based on USERDATA->pKeyWordName or DMPubID 
//
POPTITEM FindDrvOptItem (POPTITEM pDrvOptItems, DWORD dwItemCount, PSTR pKeyWordName, BYTE dmPubID )
{
	VERBOSE(DLLTEXT("FindDrvOptItem Looking (%S) (%d) \r\n"), pKeyWordName, dmPubID);
	
	POPTITEM  pOptItem  = NULL; 
	PUSERDATA pUserData = NULL;

	for (DWORD i=0; i < dwItemCount; i++)
	{
		//
		//OPTITEM has valid data compare these now (Search on DMPubID)
		//
		if (pKeyWordName == NULL)
		{
			if (dmPubID == pDrvOptItems[i].DMPubID)
			{
				pOptItem = &(pDrvOptItems[i]);
				break;
			}
		}
		else
		{
			//
			//(Search a printer freature pKeyWordName)
			//
			//For Common Printer Features the key name is set to a common non localised string
			//Note the these are only ansi strings ie PSTR
			//
			if (pDrvOptItems[i].UserData)
			{
				pUserData = (PUSERDATA)pDrvOptItems[i].UserData;
				if (pUserData->pKeyWordName)
				{
					//
					//OPTITEM has valid data compare these now
					//
					if ( strcmp (pUserData->pKeyWordName, pKeyWordName) == 0)
					{
						pOptItem = &(pDrvOptItems[i]);
						break;
					}
				}
			}
		}
	}

	if (!pOptItem) 
	{
		ERR(ERRORTEXT("FindDrvOptItem OPTITEM NOT Found \r\n") );
	}

	return pOptItem;
}


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM document property UI.
//
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            // Store OptItems state in DEVMODE.
            pOEMDev->dwAdvancedData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

        case CPSUICB_REASON_KILLACTIVE:
            pOEMDev->dwAdvancedData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

		//
		//Refress the Data in the view and tell CPUSI that the data has changed by ret CPSUICB_ACTION_OPTIF_CHANGED
		//
        case CPSUICB_REASON_SETACTIVE:
            if(pOEMUIParam->pOEMOptItems[0].Sel != pOEMDev->dwAdvancedData)
            {
                pOEMUIParam->pOEMOptItems[0].Sel = pOEMDev->dwAdvancedData;
                pOEMUIParam->pOEMOptItems[0].Flags |= OPTIF_CHANGED;
                lReturn = CPSUICB_ACTION_OPTIF_CHANGED;
            }
            break;

        default:
            break;
    }

    return lReturn;
}


LONG APIENTRY OEMDocUICallBack2(PCPSUICBPARAM pCallbackParam)
{
    LONG            lReturn = CPSUICB_ACTION_NONE;
    PCBUSERDATA     pUserData = (PCBUSERDATA) pCallbackParam->UserData;
    POEMDEV         pOEMDev = (POEMDEV) pUserData->pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUICallBack2() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            pOEMDev->dwDriverData = pCallbackParam->pOptItem[0].Sel;
            pUserData->pfnComPropSheet(pUserData->hComPropSheet, CPSFUNC_SET_RESULT,
            	                       (LPARAM)pUserData->hPropPage,
               	                       (LPARAM)CPSUI_OK);
            break;

        case CPSUICB_REASON_KILLACTIVE:
            pOEMDev->dwDriverData = pCallbackParam->pOptItem[0].Sel;
            break;

        case CPSUICB_REASON_SETACTIVE:
            if(pCallbackParam->pOptItem[0].Sel != pOEMDev->dwDriverData)
            {
                pCallbackParam->pOptItem[0].Sel = pOEMDev->dwDriverData;
                pCallbackParam->pOptItem[0].Flags |= OPTIF_CHANGED;
                lReturn = CPSUICB_ACTION_OPTIF_CHANGED;
            }
            break;

        default:
            break;
    }

    return lReturn;
}


////////////////////////////////////////////////////////////////////////////////
//
// Creates and Initializes OptItems.
//
static POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems)
{
    POPTITEM    pOptItems = NULL;


    // Allocate memory for OptItems;
    pOptItems = (POPTITEM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTITEM) * dwOptItems);
    if(NULL != pOptItems)
    {
        InitOptItems(pOptItems, dwOptItems);
    }
    else
    {
        ERR(ERRORTEXT("CreateOptItems() failed to allocate memory for OPTITEMs!\r\n"));
    }

    return pOptItems;
}


////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems.
//
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems)
{
    VERBOSE(DLLTEXT("InitOptItems() entry.\r\n"));

    // Zero out memory.
    memset(pOptItems, 0, sizeof(OPTITEM) * dwOptItems);

    // Set each OptItem's size, and Public DM ID.
    for(DWORD dwCount = 0; dwCount < dwOptItems; dwCount++)
    {
        pOptItems[dwCount].cbSize = sizeof(OPTITEM);
        pOptItems[dwCount].DMPubID = DMPUB_NONE;
    }
}


////////////////////////////////////////////////////////////////////////////////
//
// Allocates and initializes OptType for OptItem.
//
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams)
{
    POPTTYPE    pOptType = NULL;


    VERBOSE(DLLTEXT("CreateOptType() entry.\r\n"));

    // Allocate memory from the heap for the OPTTYPE; the driver will take care of clean up.
    pOptType = (POPTTYPE) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTTYPE));
    if(NULL != pOptType)
    {
        // Initialize OPTTYPE.
        pOptType->cbSize = sizeof(OPTTYPE);
        pOptType->Count = wOptParams;

        // Allocate memory from the heap for the OPTPARAMs for the OPTTYPE.
        pOptType->pOptParam = (POPTPARAM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, wOptParams * sizeof(OPTPARAM));
        if(NULL != pOptType->pOptParam)
        {
            // Initialize the OPTPARAMs.
            for(WORD wCount = 0; wCount < wOptParams; wCount++)
            {
                pOptType->pOptParam[wCount].cbSize = sizeof(OPTPARAM);
            }
        }
        else
        {
            ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTPARAMs!\r\n"));

            // Free allocated memory and return NULL.
            HeapFree(hHeap, 0, pOptType);
            pOptType = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTTYPE!\r\n"));
    }

    return pOptType;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Retrieves pointer to a String resource.
//
static PTSTR GetStringResource(HANDLE hHeap, HANDLE hModule, UINT uResource)
{
    int     nResult;
    DWORD   dwSize = MAX_PATH;
    PTSTR   pszString = NULL;


    VERBOSE(DLLTEXT("GetStringResource(%#x, %#x, %d) entered.\r\n"), hHeap, hModule, uResource);

    // Allocate buffer for string resource from heap; let the driver clean it up.
    pszString = (PTSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize * sizeof(TCHAR));
    if(NULL != pszString)
    {
        // Load string resource; resize after loading so as not to waste memory.
        nResult = LoadString((HMODULE)hModule, uResource, pszString, dwSize);
        if(nResult > 0)
        {
            PTSTR   pszTemp;


            VERBOSE(DLLTEXT("LoadString() returned %d!\r\n"), nResult);
            VERBOSE(DLLTEXT("String load was \"%s\".\r\n"), pszString);

            pszTemp = (PTSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, pszString, (nResult + 1) * sizeof(TCHAR));
            if(NULL != pszTemp)
            {
                pszString = pszTemp;
            }
            else
            {
                ERR(ERRORTEXT("GetStringResource() HeapReAlloc() of string retrieved failed! (Last Error was %d)\r\n"), GetLastError());
            }
        }
        else
        {
            ERR(ERRORTEXT("LoadString() returned %d! (Last Error was %d)\r\n"), nResult, GetLastError());
            ERR(ERRORTEXT("GetStringResource() failed to load string resource %d!\r\n"), uResource);

            pszString = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("GetStringResource() failed to allocate string buffer!\r\n"));
    }

    return pszString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\oemui.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	OEMUI.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for OEMUI Test Module.
//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _OEMUI_H
#define _OEMUI_H

#include <PRCOMOEM.H>

#include "OEM.H"
#include "DEVMODE.H"
#include "globals.h"



////////////////////////////////////////////////////////
//      OEM UI Defines
////////////////////////////////////////////////////////


// OEM Signature and version.
#define PROP_TITLE      L"OEM UI Page"
#define DLLTEXT(s)      __TEXT("UI:  ") __TEXT(s)

// OEM UI Misc defines.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


// Printer registry keys where OEM data is stored.
#define OEMUI_VALUE             TEXT("OEMUI_VALUE")
#define OEMUI_DEVICE_VALUE      TEXT("OEMUI_DEVICE_VALUE")

//
//KeyWordNames for OPTITEMS (These are nonlocalised keywords assocaited with driver features. in the OPTITEMS)
//
const char DUPLEXUNIT[]		= "DuplexUnit";
const char ENVFEEDER[]		= "EnvFeeder";
const char PRINTERHDISK[]	= "PrinterHardDisk";

//
//This structure is used to link the common pages and the OEM plugin page.
//
typedef struct _OEMSHEETDATA {
	
	//
	//Any other OEM Data you may want to store.
	//

	
	//
	//Hold Pointers you may need.
	//
	HANDLE				hComPropSheet;		//Handle to the Prop Sheet Parent Page Used when calling ComPropSheet
	HANDLE				hmyPlugin;			//Handle to the OEM Plugin page. Page Used when calling ComPropSheet
	PFNCOMPROPSHEET		pfnComPropSheet;    //Is the Pointer to ComPropSheet This is needed when APPLY is clicked (CPSFUNC_SET_RESULT)

	POEMCUIPPARAM		pOEMCUIParam;		//Holds links to the DEVMODE and OPTITEMS needed.
	IPrintOemDriverUI*	pOEMHelp;

} OEMSHEETDATA, *POEMSHEETDATA;

////////////////////////////////////////////////////////
//      Prototypes
////////////////////////////////////////////////////////

HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, IPrintOemDriverUI*  pOEMHelp);
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, POEMSHEETDATA pOemSheetData);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\devmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Devmode.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for devmode functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _DEVMODE_H
#define _DEVMODE_H


////////////////////////////////////////////////////////
//      OEM Devmode Defines
////////////////////////////////////////////////////////




////////////////////////////////////////////////////////
//      OEM Devmode Type Definitions
////////////////////////////////////////////////////////

//
//Can add info to the private devmode bellow here.
//Note :
//		This structure must be prefixed by OEM_DMEXTRAHEADER
//		Your plug-in must implement the IPrintOemUI::DevMode method
//
typedef struct tagOEMDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    DWORD               dwDriverData;
    DWORD               dwAdvancedData;

	//
	//Private DevMode Members
	//

} OEMDEV, *POEMDEV;

typedef const OEMDEV *PCOEMDEV;



/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam);
BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut);
BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode);
void Dump(PCOEMDEV pOEMDevIn);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'
#define MAX_LOOP                10



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize      = DEBUG_BUFFER_SIZE;
    DWORD   dwLoop      = 0;
    LPSTR   lpszMsgBuf  = NULL;
    HRESULT hr;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
        {
            return FALSE;
        }

        hr = StringCbVPrintfA(lpszMsgBuf, (dwSize + 1) * sizeof(CHAR), lpszMessage, arglist);

    // Pass the variable parameters to wvsprintf to be formated.
    } while (FAILED(hr) && (STRSAFE_E_INSUFFICIENT_BUFFER == hr) && (++dwLoop < MAX_LOOP) );

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return SUCCEEDED(hr);
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR      lpszMsgBuf;
    HRESULT     hResult;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    hResult = StringCbVPrintfW(lpszMsgBuf, (dwSize + 1) * sizeof(WCHAR), lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return SUCCEEDED(hResult);
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(TEXT("pPublisherInfo:\r\n"));
    if(NULL == pPublisherInfo)
    {
        VERBOSE(TEXT("\tpPublisherInfo is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(TEXT("pOemDMParam:\r\n"));
    if(NULL == pOemDMParam)
    {
        VERBOSE(TEXT("\tpOemDMParam is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}

void Dump(PPROPSHEETUI_INFO pPSUIInfo)
{
    VERBOSE(TEXT("pPSUIInfo:\r\n"));
    if(NULL == pPSUIInfo)
    {
        VERBOSE(TEXT("\tpPSUIInfo is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize          = %d\r\n"), pPSUIInfo->cbSize);
    VERBOSE(TEXT("\tVersion         = %#x\r\n"), pPSUIInfo->Version);
    VERBOSE(TEXT("\tFlags           = %#x\r\n"), pPSUIInfo->Flags);
    VERBOSE(TEXT("\tReason          = %d\r\n"), pPSUIInfo->Reason);
    VERBOSE(TEXT("\thComPropSheet   = %#x\r\n"), pPSUIInfo->hComPropSheet);
    VERBOSE(TEXT("\tpfnComPropSheet = %#x\r\n"), pPSUIInfo->pfnComPropSheet);
    VERBOSE(TEXT("\tlParamInit      = %#x\r\n"), pPSUIInfo->lParamInit);
    VERBOSE(TEXT("\tUserData        = %#x\r\n"), pPSUIInfo->UserData);
    VERBOSE(TEXT("\tResult          = %#x\r\n"), pPSUIInfo->Result);
}

void Dump(POPTITEM pOptItem)
{
    VERBOSE(TEXT("pOptItem:\r\n"));
    if(NULL == pOptItem)
    {
        VERBOSE(TEXT("\tpOptItem is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize          = %d\r\n"),     pOptItem->cbSize);
    VERBOSE(TEXT("\tLevel           = %d\r\n"),     pOptItem->Level);
    VERBOSE(TEXT("\tDlgPageIdx      = %d\r\n"),     pOptItem->DlgPageIdx);
    VERBOSE(TEXT("\tFlags           = 0x%x\r\n"),   pOptItem->Flags);
    VERBOSE(TEXT("\tUserData        = 0x%p\r\n"),   pOptItem->UserData);
    VERBOSE(TEXT("\tpName           = %s\r\n"),     pOptItem->pName ? pOptItem->pName : TEXT("<NULL>"));
    VERBOSE(TEXT("\tpSel            = 0x%p\r\n"),   pOptItem->pSel);
    VERBOSE(TEXT("\tpExtChkBox      = 0x%p\r\n"),   pOptItem->pExtChkBox);
    VERBOSE(TEXT("\tpExtChkBox      = 0x%p\r\n"),   pOptItem->pExtChkBox);
    VERBOSE(TEXT("\tHelpIndex       = 0x%x\r\n"),   pOptItem->HelpIndex);
    VERBOSE(TEXT("\tDMPubID         = 0x%x\r\n"),   pOptItem->DMPubID);
    VERBOSE(TEXT("\tUserItemID      = 0x%x\r\n"),   pOptItem->UserItemID);
    VERBOSE(TEXT("\twReserved       = 0x%x\r\n"),   pOptItem->wReserved);
    VERBOSE(TEXT("\tpOIExt          = 0x%p\r\n"),   pOptItem->pOIExt);

    Dump(pOptItem->pOptType);
}

void Dump(POPTTYPE pOptType)
{
    VERBOSE(TEXT("\tpOptType:\r\n"));
    if(NULL == pOptType)
    {
        VERBOSE(TEXT("\t\tpOptType is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\t\tcbSize    = %d\r\n"),     pOptType->cbSize);
    VERBOSE(TEXT("\t\tType      = 0x%x\r\n"),   pOptType->Type);
    VERBOSE(TEXT("\t\tFlags     = 0x%x\r\n"),   pOptType->Flags);
    VERBOSE(TEXT("\t\tCount     = %d\r\n"),     pOptType->Count);
    VERBOSE(TEXT("\t\tCount     = 0x%x\r\n"),   pOptType->BegCtrlID);
    VERBOSE(TEXT("\t\tStyle     = 0x%x\r\n"),   pOptType->Style);

    Dump(pOptType->pOptParam, pOptType->Count);
}

void Dump(POPTPARAM pOptParam, WORD wCount)
{
    if(NULL == pOptParam)
    {
        VERBOSE(TEXT("\t\tpOptParam is NULL!\r\n"));
        return;
    }

    for(WORD wIndex = 0; wIndex < wCount; ++wIndex)
    {
        VERBOSE(TEXT("\t\tpOptParam[wIndex]:\r\n"));
        VERBOSE(TEXT("\t\t\tcbSize    = %d\r\n"),     pOptParam[wIndex].cbSize);
        VERBOSE(TEXT("\t\t\tFlags     = 0x%x\r\n"),   pOptParam[wIndex].Flags);
        VERBOSE(TEXT("\t\t\tStyle     = 0x%x\r\n"),   pOptParam[wIndex].Style);
        VERBOSE(TEXT("\t\t\tpData     = 0x%p\r\n"),   pOptParam[wIndex].pData);
        VERBOSE(TEXT("\t\t\tIconID    = 0x%p\r\n"),   pOptParam[wIndex].IconID);
        VERBOSE(TEXT("\t\t\tlParam    = 0x%p\r\n"),   pOptParam[wIndex].lParam);
    }
}


PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by oemui.rc
//
#define IDS_SECTION                     1
#define IDS_CALIBRATED                  2
#define IDS_NAME                        3
#define IDS_HELPFILE                    4
#define IDS_DEV_SECTION                 5
#define IDS_ADV_SECTION                 10
#define IDD_DEVICE_PROPPAGE             106
#define IDD_DOC_PROPPAGE                107
#define IDC_CALIBRATE                   1001
#define IDC_RADIO3                      1004
#define IDC_CHECK_DUPLPEX               1008
#define IDC_CHECK_HDRIVE                1009
#define IDC_CHECK_ENVFEEDER             1010

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\intrface.cpp ===
/*++

Copyright (c) 1996-2003  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows 2000, Windows XP, Windows Server 2003

Revision History:

              Created it.

--*/

#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "oemui.h"
#include "debug.h"
#include "intrface.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks



////////////////////////////////////////////////////////////////////////////////
//
// IOemUI body
//
IOemUI::~IOemUI()
{
    // Make sure that helper interface is released.
    if(NULL != m_pOEMHelp)
    {
        m_pOEMHelp->Release();
        m_pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == m_cRef);
}

HRESULT __stdcall IOemUI::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE(DLLTEXT("IOemUI:QueryInterface entry.\r\n\r\n")); 
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE(DLLTEXT("IOemUI:Return pointer to IUnknown.\r\n\r\n")); 
    }
    else if (iid == IID_IPrintOemUI)
    {
        *ppv = static_cast<IPrintOemUI*>(this) ;
        VERBOSE(DLLTEXT("IOemUI:Return pointer to IPrintOemUI.\r\n")); 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE(DLLTEXT("IOemUI:No Interface. Return NULL.\r\n")); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemUI::AddRef()
{
    VERBOSE(DLLTEXT("IOemUI:AddRef entry.\r\n")); 
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemUI::Release() 
{
    VERBOSE(DLLTEXT("IOemUI:Release entry.\r\n")); 
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}

//
//(Implamentation is required) Supplies a pointer to UNIDRIVE /PScript IPrintOemDriverUI
//
HRESULT __stdcall IOemUI::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IOemUI:PublishDriverInterface entry.\r\n")); 

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (m_pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUI, (void** ) &(m_pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            m_pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}

//
//(Implamentation is required) Returns the UI Plugin's identification information
//
HRESULT __stdcall IOemUI::GetInfo(
    DWORD  dwMode,
    PVOID  pBuffer,
    DWORD  cbSize,
    PDWORD pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemUI::GetInfo(%d) entry.\r\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        WARNING(DLLTEXT("IOemUI::GetInfo() exit pcbNeeded is NULL! ERROR_INVALID_PARAMETER\r\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size and number of bytes written.
    *pcbNeeded = sizeof(DWORD);

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        WARNING(DLLTEXT("IOemUI::GetInfo() exit insufficient buffer!\r\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = OEM_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = OEM_VERSION;
            break;

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            WARNING(DLLTEXT("IOemUI::GetInfo() exit mode not supported.\r\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IOemUI::GetInfo() exit S_OK, (*pBuffer is %#x).\r\r\n"), *(PDWORD)pBuffer);
    return S_OK;
}


//
//Performs operation on UI Plugins Private DevMode Members.
//
HRESULT __stdcall IOemUI::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IOemUI:DevMode(%d, %#x) entry.\r\n"), dwMode, pOemDMParam); 

    return hrOEMDevMode(dwMode, pOemDMParam);
}


//
//Allows UI Plugin to Modifiy Existing printer porp sheet and document property sheet page..
//
HRESULT __stdcall IOemUI::CommonUIProp(
    DWORD  dwMode,
    POEMCUIPPARAM   pOemCUIPParam)
{
    VERBOSE(DLLTEXT("IOemUI:CommonUIProp entry.\r\n"));

	//
	//We want to keep this pointer so the we can modifie the data and OPTITEMS from the OEM plugin page.
	//
	m_OemSheetData.pOEMCUIParam = pOemCUIPParam;
	return hrOEMPropertyPage(dwMode, pOemCUIPParam);
}


//
//Adds a New page to the device Documment property sheet.
//

HRESULT __stdcall IOemUI::DocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DocumentPropertySheets entry.\r\n")); 

    return hrOEMDocumentPropertySheets(pPSUIInfo, lParam, m_pOEMHelp);
}

//
//Adds a New page to the device printer property page.
//
HRESULT __stdcall IOemUI::DevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DevicePropertySheets entry.\r\n")); 

	//
	//Store the This pointer in the OEMSHEETDATA
	//
	m_OemSheetData.pOEMHelp = m_pOEMHelp;
    return hrOEMDevicePropertySheets(pPSUIInfo, lParam, &(m_OemSheetData));
}


//
//Allows the UI plugin to spec Customized device capabilaties (TODO)
//
HRESULT __stdcall IOemUI::DeviceCapabilities(
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult)
{
    VERBOSE(DLLTEXT("IOemUI:DeviceCapabilities entry.\r\n"));
	
    return E_NOTIMPL;
}


//
//Allows the UI plugin to help determine if a print Job is printable.
//
HRESULT __stdcall IOemUI::DevQueryPrintEx(
    POEMUIOBJ               poemuiobj,
    PDEVQUERYPRINT_INFO     pDQPInfo,
    PDEVMODE                pPublicDM,
    PVOID                   pOEMDM)
{
    VERBOSE(DLLTEXT("IOemUI:DevQueryPrintEx entry.\r\n"));

    return E_NOTIMPL;
}


//
//Allows the UI Plugin to upgrade its dev options stored in the registry.
//
HRESULT __stdcall IOemUI::UpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo)
{
    VERBOSE(DLLTEXT("IOemUI:UpgradePrinter entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::PrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI:PrinterEvent entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::DriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DriverEvent entry.\r\n"));

    return E_NOTIMPL;
};


#define PROFILE_NAME    L"OEMPROFILE.icm\0"

HRESULT __stdcall IOemUI::QueryColorProfile(
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulQueryMode,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData)
{
    HRESULT Result = E_FAIL;


    VERBOSE(DLLTEXT("IOemUI:QueryColorProfile entry.\r\n"));


    if(QCP_DEVICEPROFILE == ulQueryMode)
    {
        if(NULL == pvProfileData)
        {
            *pcbProfileData = sizeof(PROFILE_NAME);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
            if(*pcbProfileData < sizeof(PROFILE_NAME))
            {
                *pcbProfileData = sizeof(PROFILE_NAME);
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
            }
            else
            {
                Result = StringCbCopy((LPWSTR)pvProfileData, *pcbProfileData, PROFILE_NAME);
                *pcbProfileData = sizeof(PROFILE_NAME);
                *pflProfileData = QCP_PROFILEDISK;

                if(FAILED(Result))
                {
                    SetLastError(Result);
                }
            }
        }
    }

    return Result;
};

HRESULT __stdcall IOemUI::FontInstallerDlgProc(
        HWND    hWnd,
        UINT    usMsg,
        WPARAM  wParam,
        LPARAM  lParam) 
{
    VERBOSE(DLLTEXT("IOemUI:FontInstallerDlgProc entry.\r\n"));

    return E_NOTIMPL;
};

HRESULT __stdcall IOemUI::UpdateExternalFonts(
        HANDLE  hPrinter,
        HANDLE  hHeap,
        PWSTR   pwstrCartridges)
{
    VERBOSE(DLLTEXT("IOemUI:UpdateExternalFonts entry.\r\n"));

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemUI* pOemCB = new IOemUI ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }
    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Exported functions
//


// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    //
    // To avoid leaving OEM DLL still in memory when Unidrv or Pscript drivers 
    // are unloaded, Unidrv and Pscript driver ignore the return value of 
    // DllCanUnloadNow of the OEM DLL, and always call FreeLibrary on the OEMDLL.
    //
    // If OEM DLL spins off a working thread that also uses the OEM DLL, the 
    // thread needs to call LoadLibrary and FreeLibraryAndExitThread, otherwise 
    // it may crash after Unidrv or Pscript calls FreeLibrary.
    //

    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:Create class factory.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMUI)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\intrface.h ===
/*++

Copyright (c) 1996-2003  Microsoft Corporation

Module Name:

     comoem.h

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows 2000, Windows XP, Windows Server 2003

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// IOemUI
//
class IOemUI: public IPrintOemUI
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD  dwMode, PVOID  pBuffer, DWORD  cbSize,
                           PDWORD pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_  DWORD  dwMode, POEMDMPARAM pOemDMParam) ;

    //
    // OEMCommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_  
            DWORD  dwMode, 
            POEMCUIPPARAM   pOemCUIPParam
            );

    //
    // OEMDocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );

    //
    // OEMDevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );


    //
    // OEMDevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            );

    //
    // OEMDeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            );

    //
    // OEMUpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            );

    //
    // OEMPrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            );

    //
    // OEMDriverEvent
    //

    STDMETHOD(DriverEvent)(THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            );
 
    //
    // OEMQueryColorProfile
    //

    STDMETHOD( QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData);

    //
    // OEMFontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_ 
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            );
    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
            );


    IOemUI() 
	{ 
		m_cRef = 1; 
		m_pOEMHelp = NULL; 
		m_OemSheetData.pfnComPropSheet = NULL; 
		m_OemSheetData.pOEMCUIParam=NULL;
		m_OemSheetData.hComPropSheet=INVALID_HANDLE_VALUE;
		m_OemSheetData.hmyPlugin=INVALID_HANDLE_VALUE;
	};

    ~IOemUI();

protected:
    LONG                m_cRef;
    IPrintOemDriverUI*  m_pOEMHelp;

	//
	//Used to link common ui in device settings tab and the OEM plugin tab.
	//
	OEMSHEETDATA		m_OemSheetData;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'
#define MAX_LOOP                10



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize      = DEBUG_BUFFER_SIZE;
    DWORD   dwLoop      = 0;
    LPSTR   lpszMsgBuf  = NULL;
    HRESULT hr;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
        {
            return FALSE;
        }

        hr = StringCbVPrintfA(lpszMsgBuf, (dwSize + 1) * sizeof(CHAR), lpszMessage, arglist);

    // Pass the variable parameters to wvsprintf to be formated.
    } while (FAILED(hr) && (STRSAFE_E_INSUFFICIENT_BUFFER == hr) && (++dwLoop < MAX_LOOP) );

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return SUCCEEDED(hr);
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR      lpszMsgBuf;
    HRESULT     hResult;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    hResult = StringCbVPrintfW(lpszMsgBuf, (dwSize + 1) * sizeof(WCHAR), lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return SUCCEEDED(hResult);
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(TEXT("pPublisherInfo:\r\n"));
    if(NULL == pPublisherInfo)
    {
        VERBOSE(TEXT("\tpPublisherInfo is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(TEXT("pOemDMParam:\r\n"));
    if(NULL == pOemDMParam)
    {
        VERBOSE(TEXT("\tpOemDMParam is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}

void Dump(PPROPSHEETUI_INFO pPSUIInfo)
{
    VERBOSE(TEXT("pPSUIInfo:\r\n"));
    if(NULL == pPSUIInfo)
    {
        VERBOSE(TEXT("\tpPSUIInfo is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize          = %d\r\n"), pPSUIInfo->cbSize);
    VERBOSE(TEXT("\tVersion         = %#x\r\n"), pPSUIInfo->Version);
    VERBOSE(TEXT("\tFlags           = %#x\r\n"), pPSUIInfo->Flags);
    VERBOSE(TEXT("\tReason          = %d\r\n"), pPSUIInfo->Reason);
    VERBOSE(TEXT("\thComPropSheet   = %#x\r\n"), pPSUIInfo->hComPropSheet);
    VERBOSE(TEXT("\tpfnComPropSheet = %#x\r\n"), pPSUIInfo->pfnComPropSheet);
    VERBOSE(TEXT("\tlParamInit      = %#x\r\n"), pPSUIInfo->lParamInit);
    VERBOSE(TEXT("\tUserData        = %#x\r\n"), pPSUIInfo->UserData);
    VERBOSE(TEXT("\tResult          = %#x\r\n"), pPSUIInfo->Result);
}

void Dump(POPTITEM pOptItem)
{
    VERBOSE(TEXT("pOptItem:\r\n"));
    if(NULL == pOptItem)
    {
        VERBOSE(TEXT("\tpOptItem is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize          = %d\r\n"),     pOptItem->cbSize);
    VERBOSE(TEXT("\tLevel           = %d\r\n"),     pOptItem->Level);
    VERBOSE(TEXT("\tDlgPageIdx      = %d\r\n"),     pOptItem->DlgPageIdx);
    VERBOSE(TEXT("\tFlags           = 0x%x\r\n"),   pOptItem->Flags);
    VERBOSE(TEXT("\tUserData        = 0x%p\r\n"),   pOptItem->UserData);
    VERBOSE(TEXT("\tpName           = %s\r\n"),     pOptItem->pName ? pOptItem->pName : TEXT("<NULL>"));
    VERBOSE(TEXT("\tpSel            = 0x%p\r\n"),   pOptItem->pSel);
    VERBOSE(TEXT("\tpExtChkBox      = 0x%p\r\n"),   pOptItem->pExtChkBox);
    VERBOSE(TEXT("\tpExtChkBox      = 0x%p\r\n"),   pOptItem->pExtChkBox);
    VERBOSE(TEXT("\tHelpIndex       = 0x%x\r\n"),   pOptItem->HelpIndex);
    VERBOSE(TEXT("\tDMPubID         = 0x%x\r\n"),   pOptItem->DMPubID);
    VERBOSE(TEXT("\tUserItemID      = 0x%x\r\n"),   pOptItem->UserItemID);
    VERBOSE(TEXT("\twReserved       = 0x%x\r\n"),   pOptItem->wReserved);
    VERBOSE(TEXT("\tpOIExt          = 0x%p\r\n"),   pOptItem->pOIExt);

    Dump(pOptItem->pOptType);
}

void Dump(POPTTYPE pOptType)
{
    VERBOSE(TEXT("\tpOptType:\r\n"));
    if(NULL == pOptType)
    {
        VERBOSE(TEXT("\t\tpOptType is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\t\tcbSize    = %d\r\n"),     pOptType->cbSize);
    VERBOSE(TEXT("\t\tType      = 0x%x\r\n"),   pOptType->Type);
    VERBOSE(TEXT("\t\tFlags     = 0x%x\r\n"),   pOptType->Flags);
    VERBOSE(TEXT("\t\tCount     = %d\r\n"),     pOptType->Count);
    VERBOSE(TEXT("\t\tCount     = 0x%x\r\n"),   pOptType->BegCtrlID);
    VERBOSE(TEXT("\t\tStyle     = 0x%x\r\n"),   pOptType->Style);

    Dump(pOptType->pOptParam, pOptType->Count);
}

void Dump(POPTPARAM pOptParam, WORD wCount)
{
    if(NULL == pOptParam)
    {
        VERBOSE(TEXT("\t\tpOptParam is NULL!\r\n"));
        return;
    }

    for(WORD wIndex = 0; wIndex < wCount; ++wIndex)
    {
        VERBOSE(TEXT("\t\tpOptParam[wIndex]:\r\n"));
        VERBOSE(TEXT("\t\t\tcbSize    = %d\r\n"),     pOptParam[wIndex].cbSize);
        VERBOSE(TEXT("\t\t\tFlags     = 0x%x\r\n"),   pOptParam[wIndex].Flags);
        VERBOSE(TEXT("\t\t\tStyle     = 0x%x\r\n"),   pOptParam[wIndex].Style);
        VERBOSE(TEXT("\t\t\tpData     = 0x%p\r\n"),   pOptParam[wIndex].pData);
        VERBOSE(TEXT("\t\t\tIconID    = 0x%p\r\n"),   pOptParam[wIndex].IconID);
        VERBOSE(TEXT("\t\t\tlParam    = 0x%p\r\n"),   pOptParam[wIndex].lParam);
    }
}


PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\fusutils.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002-2003
 *
 *  TITLE:       fusutils.h
 *
 *  VERSION:     1.0
 *
 *  DATE:        14-Feb-2001
 *
 *  DESCRIPTION: Fusion utilities
 *
 *****************************************************************************/

#ifndef _FUSUTILS_H
#define _FUSUTILS_H



HANDLE GetMyActivationContext();
BOOL CreateMyActivationContext();
HANDLE CreateActivationContextFromResource(HMODULE hModule, LPCTSTR pszResourceName);



#endif // endif _FUSUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\fusutils.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2001 - 2003
 *
 *  TITLE:       fusutils.cpp
 *
 *  VERSION:     1.0
 *
 *  DATE:        14-Feb-2001
 *
 *  DESCRIPTION: Fusion utilities
 *
 *****************************************************************************/
#pragma once

#include "precomp.h"
#include "globals.h"
#include "fusutils.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



#define MAX_LOOP    10


HANDLE GetMyActivationContext()
{
    // Make sure we've created our activation context.
    CreateMyActivationContext();

    // Return the global.
    return ghActCtx;
}


BOOL CreateMyActivationContext()
{
    if(INVALID_HANDLE_VALUE != ghActCtx)
    {
        return TRUE;
    }

    ghActCtx = CreateActivationContextFromResource(ghInstance, MAKEINTRESOURCE(MANIFEST_RESOURCE));

    return (INVALID_HANDLE_VALUE != ghActCtx);
}



HANDLE CreateActivationContextFromResource(HMODULE hModule, LPCTSTR pszResourceName)
{
    DWORD   dwSize          = MAX_PATH;
    DWORD   dwUsed          = 0;
    DWORD   dwLoop;
    PTSTR   pszModuleName   = NULL;
    ACTCTX  act;
    HANDLE  hActCtx         = INVALID_HANDLE_VALUE;

    
    // Get the name for the module that contains the manifest resource
    // to create the Activation Context from.
    dwLoop = 0;
    do 
    {
        // May need to allocate or re-alloc buffer for module name.
        if(NULL != pszModuleName)
        {
            // Need to re-alloc bigger buffer.

            // First, delete old buffer.
            delete[] pszModuleName;

            // Second, increase buffer alloc size.
            dwSize <<= 1;
        }
        pszModuleName = new TCHAR[dwSize];
        if(NULL == pszModuleName)
        {
            goto Exit;
        }

        // Try to get the module name.
        dwUsed = GetModuleFileName(hModule, pszModuleName, dwSize);

        // Check to see if it failed.
        if(0 == dwUsed)
        {
            goto Exit;
        }

        // If dwUsed is equla to dwSize or larger,
        // the buffer passed in wasn't big enough.
    } while ( (dwUsed >= dwSize) && (++dwLoop < MAX_LOOP) );

    // Now let's try to create an activation context
    // from manifest resource.
    ::ZeroMemory(&act, sizeof(act));
    act.cbSize          = sizeof(act);
    act.dwFlags         = ACTCTX_FLAG_RESOURCE_NAME_VALID;
    act.lpResourceName  = pszResourceName;
    act.lpSource        = pszModuleName;

    hActCtx = CreateActCtx(&act);


Exit:

    //
    //  Clean up.
    //

    if(NULL != pszModuleName)
    {
        delete[] pszModuleName;
    }

    return hActCtx;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oemui.h"
#include "fusutils.h"
#include "debug.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));

            // Store the module handle in case we need it later.
            ghInstance = hInst;

            // NOTE: We don't create an Activation Context on module load,
            //       but on need of an Avtivation Context; the first time
            //       GetMyActivationContext() or CreateMyActivationContext() is called.
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));

            // Release the Activation Context if we created one somewhere
            // by calling GetMyActivationContext() or CreateMyActivationContext();
            if(INVALID_HANDLE_VALUE != ghActCtx)
            {
                ReleaseActCtx(ghActCtx);
                ghActCtx = INVALID_HANDLE_VALUE;
            }
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}


}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\globals.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Globals.h
//    
//
//  PURPOSE:   Lists of globals declared in Globals.cpp.
//
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _GLOBALS_H
#define _GLOBALS_H


///////////////////////////////////////
//          Globals
///////////////////////////////////////

extern HINSTANCE   ghInstance;  // Module's Instance handle from DLLEntry of process.
extern HANDLE      ghActCtx;    // Module's Activation Context from DLLEntry of process.



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by OEMUI.rc
//
#define IDS_SECTION                     1
#define IDS_CALIBRATED                  2
#define IDS_NAME                        3
#define IDS_DEV_SECTION                 4
#define IDS_DEVICE_SECTION              4
#define IDS_ADV_SECTION                 10
#define IDD_DEVICE_PROPPAGE             106
#define IDD_DOC_PROPPAGE                107
#define IDC_CALIBRATE                   1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\globals.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Globals.cpp
//    
//
//  PURPOSE:  File that contains all the globals.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//
#define _GLOBALS_H

#include "precomp.h"
#include "oemui.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



///////////////////////////////////////
//          Globals
///////////////////////////////////////


// Module's Instance handle from DLLEntry of process.
HINSTANCE   ghInstance  = NULL; 

// Module's Activation Context from DLLEntry of process.
HANDLE      ghActCtx    = INVALID_HANDLE_VALUE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\intrface.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Intrface.cpp
//    
//
//  PURPOSE:  Implementation of interface for PScript4, PScript5, Unidrv4, 
//            Unidrv5 UI plug-ins.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//


#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "oemui.h"
#include "debug.h"
#include "intrface.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>


////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks



////////////////////////////////////////////////////////////////////////////////
//
// IOemUI body
//
IOemUI::~IOemUI()
{
    // Make sure that helper interface is released.
    if(NULL != m_pOEMHelp)
    {
        m_pOEMHelp->Release();
        m_pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == m_cRef);
}

HRESULT __stdcall IOemUI::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE(DLLTEXT("IOemUI:QueryInterface entry.\r\n\r\n")); 
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE(DLLTEXT("IOemUI:Return pointer to IUnknown.\r\n\r\n")); 
    }
    else if (iid == IID_IPrintOemUI)
    {
        *ppv = static_cast<IPrintOemUI*>(this) ;
        VERBOSE(DLLTEXT("IOemUI:Return pointer to IPrintOemUI.\r\n")); 
    }
    else
    {
#if DBG
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        VERBOSE(DLLTEXT("IOemUI::QueryInterface %s not supported.\r\n"), szOutput); 
#endif

        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemUI::AddRef()
{
    VERBOSE(DLLTEXT("IOemUI:AddRef entry.\r\n")); 
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemUI::Release() 
{
    VERBOSE(DLLTEXT("IOemUI:Release entry.\r\n")); 
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}

HRESULT __stdcall IOemUI::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IOemUI:PublishDriverInterface entry.\r\n")); 

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (m_pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUI, (void** ) &(m_pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            m_pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}

HRESULT __stdcall IOemUI::GetInfo(
    DWORD  dwMode,
    PVOID  pBuffer,
    DWORD  cbSize,
    PDWORD pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemUI::GetInfo(%d) entry.\r\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        WARNING(DLLTEXT("IOemUI::GetInfo() exit pcbNeeded is NULL! ERROR_INVALID_PARAMETER\r\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size and number of bytes written.
    *pcbNeeded = sizeof(DWORD);

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        WARNING(DLLTEXT("IOemUI::GetInfo() exit insufficient buffer!\r\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = OEM_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = OEM_VERSION;
            break;

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            WARNING(DLLTEXT("IOemUI::GetInfo() exit mode not supported.\r\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IOemUI::GetInfo() exit S_OK, (*pBuffer is %#x).\r\r\n"), *(PDWORD)pBuffer);
    return S_OK;
}

HRESULT __stdcall IOemUI::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IOemUI:DevMode(%d, %#x) entry.\r\n"), dwMode, pOemDMParam); 

    return hrOEMDevMode(dwMode, pOemDMParam);
}

HRESULT __stdcall IOemUI::CommonUIProp(
    DWORD  dwMode,
    POEMCUIPPARAM   pOemCUIPParam)
{
    VERBOSE(DLLTEXT("IOemUI:CommonUIProp entry.\r\n")); 

    return hrOEMPropertyPage(dwMode, pOemCUIPParam);
}


HRESULT __stdcall IOemUI::DocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DocumentPropertySheets entry.\r\n")); 

    return hrOEMDocumentPropertySheets(pPSUIInfo, lParam, m_pOEMHelp);
}

HRESULT __stdcall IOemUI::DevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DevicePropertySheets entry.\r\n")); 

    return hrOEMDevicePropertySheets(pPSUIInfo, lParam);
}

HRESULT __stdcall IOemUI::DeviceCapabilities(
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult)
{
    VERBOSE(DLLTEXT("IOemUI:DeviceCapabilities entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::DevQueryPrintEx(
    POEMUIOBJ               poemuiobj,
    PDEVQUERYPRINT_INFO     pDQPInfo,
    PDEVMODE                pPublicDM,
    PVOID                   pOEMDM)
{
    VERBOSE(DLLTEXT("IOemUI:DevQueryPrintEx entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::UpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo)
{
    VERBOSE(DLLTEXT("IOemUI:UpgradePrinter entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::PrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI:PrinterEvent entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::DriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DriverEvent entry.\r\n"));

    return E_NOTIMPL;
};


#define PROFILE_NAME    L"OEMPROFILE.icm\0"

HRESULT __stdcall IOemUI::QueryColorProfile(
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulQueryMode,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData)
{
    HRESULT Result = E_FAIL;


    VERBOSE(DLLTEXT("IOemUI:QueryColorProfile entry.\r\n"));


    if(QCP_DEVICEPROFILE == ulQueryMode)
    {
        if(NULL == pvProfileData)
        {
            *pcbProfileData = sizeof(PROFILE_NAME);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
            if(*pcbProfileData < sizeof(PROFILE_NAME))
            {
                *pcbProfileData = sizeof(PROFILE_NAME);
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
            }
            else
            {
                Result = StringCbCopy((LPWSTR)pvProfileData, *pcbProfileData, PROFILE_NAME);
                *pcbProfileData = sizeof(PROFILE_NAME);
                *pflProfileData = QCP_PROFILEDISK;

                if(FAILED(Result))
                {
                    SetLastError(Result);
                }
            }
        }
    }

    return Result;
};

HRESULT __stdcall IOemUI::FontInstallerDlgProc(
        HWND    hWnd,
        UINT    usMsg,
        WPARAM  wParam,
        LPARAM  lParam) 
{
    VERBOSE(DLLTEXT("IOemUI:FontInstallerDlgProc entry.\r\n"));

    return E_NOTIMPL;
};

HRESULT __stdcall IOemUI::UpdateExternalFonts(
        HANDLE  hPrinter,
        HANDLE  hHeap,
        PWSTR   pwstrCartridges)
{
    VERBOSE(DLLTEXT("IOemUI:UpdateExternalFonts entry.\r\n"));

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
#if DBG && defined(USERMODE_DRIVER)
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        WARNING(DLLTEXT("IOemCF::QueryInterface %s not supported.\r\n"), szOutput); 
#endif

        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemUI* pOemCB = new IOemUI ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }
    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Exported functions
//


// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    //
    // To avoid leaving OEM DLL still in memory when Unidrv or Pscript drivers 
    // are unloaded, Unidrv and Pscript driver ignore the return value of 
    // DllCanUnloadNow of the OEM DLL, and always call FreeLibrary on the OEMDLL.
    //
    // If OEM DLL spins off a working thread that also uses the OEM DLL, the 
    // thread needs to call LoadLibrary and FreeLibraryAndExitThread, otherwise 
    // it may crash after Unidrv or Pscript calls FreeLibrary.
    //

    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:Create class factory.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMUI)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\oemui.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	OEMUI.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for OEMUI Test Module.
//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//

#ifndef _OEMUI_H
#define _OEMUI_H

#include <PRCOMOEM.H>

#include "OEM.H"
#include "DEVMODE.H"
#include "globals.h"


////////////////////////////////////////////////////////
//      OEM UI Defines
////////////////////////////////////////////////////////


// OEM Signature and version.
#define PROP_TITLE      L"OEM UI Page"
#define DLLTEXT(s)      __TEXT("UI:  ") __TEXT(s)

// OEM UI Misc defines.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


// Printer registry keys where OEM data is stored.
#define OEMUI_VALUE             TEXT("OEMUI_VALUE")
#define OEMUI_DEVICE_VALUE      TEXT("OEMUI_DEVICE_VALUE")



////////////////////////////////////////////////////////
//      Prototypes
////////////////////////////////////////////////////////

HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, IPrintOemDriverUI*  pOEMHelp);
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\intrface.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Intrface.h
//    
//
//  PURPOSE:  Header of interface for PScript5 and Unidrv5 UI plug-in.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//



////////////////////////////////////////////////////////////////////////////////
//
// IOemUI
//
class IOemUI: public IPrintOemUI
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD  dwMode, PVOID  pBuffer, DWORD  cbSize,
                           PDWORD pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_  DWORD  dwMode, POEMDMPARAM pOemDMParam) ;

    //
    // OEMCommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_  
            DWORD  dwMode, 
            POEMCUIPPARAM   pOemCUIPParam
            );

    //
    // OEMDocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );

    //
    // OEMDevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );


    //
    // OEMDevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            );

    //
    // OEMDeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            );

    //
    // OEMUpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            );

    //
    // OEMPrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            );

    //
    // OEMDriverEvent
    //

    STDMETHOD(DriverEvent)(THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            );
 
    //
    // OEMQueryColorProfile
    //

    STDMETHOD( QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData);

    //
    // OEMFontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_ 
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            );
    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
            );


    IOemUI() { m_cRef = 1; m_pOEMHelp = NULL; };
    ~IOemUI();

protected:
    LONG                m_cRef;
    IPrintOemDriverUI*  m_pOEMHelp;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\common\devmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Devmode.cpp
//    
//
//  PURPOSE:  Implementation of Devmode functions shared with OEM UI and OEM rendering modules.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//

#include "debug.h"
#include "devmode.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam)
{
    HRESULT hResult     = S_OK;
    POEMDEV pOEMDevIn   = NULL;
    POEMDEV pOEMDevOut  = NULL;


    // Verify parameters.
    if( (NULL == pOemDMParam)
        ||
        ( (OEMDM_SIZE != dwMode)
          &&
          (OEMDM_DEFAULT != dwMode)
          &&
          (OEMDM_CONVERT != dwMode)
          &&
          (OEMDM_MERGE != dwMode)
        )
      )
    {
        ERR(ERRORTEXT("DevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOemDMParam = %#lx.\r\n"), dwMode, pOemDMParam);

        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Cast generic (i.e. PVOID) to OEM private devomode pointer type.
    pOEMDevIn = (POEMDEV) pOemDMParam->pOEMDMIn;
    pOEMDevOut = (POEMDEV) pOemDMParam->pOEMDMOut;

    switch(dwMode)
    {
        case OEMDM_SIZE:
            pOemDMParam->cbBufSize = sizeof(OEMDEV);
            break;

        case OEMDM_DEFAULT:
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
            pOEMDevOut->bEnabled                = WATER_MARK_DEFAULT_ENABLED;
            pOEMDevOut->dfRotate                = WATER_MARK_DEFAULT_ROTATION;
            pOEMDevOut->dwFontSize              = WATER_MARK_DEFAULT_FONTSIZE;
            pOEMDevOut->crTextColor             = WATER_MARK_DEFAULT_COLOR;
            hResult = StringCbCopyW(pOEMDevOut->szWaterMark, sizeof(pOEMDevOut->szWaterMark), WATER_MARK_DEFAULT_TEXT);
            VERBOSE(DLLTEXT("pOEMDevOut after setting default values:\r\n"));
            Dump(pOEMDevOut);
            break;

        case OEMDM_CONVERT:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            break;

        case OEMDM_MERGE:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            MakeOEMDevmodeValid(pOEMDevOut);
            break;
    }
    Dump(pOemDMParam);

    return hResult;
}


BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut)
{
    HRESULT hCopy = S_OK;


    if( (NULL == pOEMDevIn)
        ||
        (NULL == pOEMDevOut)
      )
    {
        ERR(ERRORTEXT("ConvertOEMDevmode() invalid parameters.\r\n"));
        return FALSE;
    }

    // Check OEM Signature, if it doesn't match ours,
    // then just assume DMIn is bad and use defaults.
    if(pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature)
    {
        VERBOSE(DLLTEXT("Converting private OEM Devmode.\r\n"));
        VERBOSE(DLLTEXT("pOEMDevIn:\r\n"));
        Dump(pOEMDevIn);

        // Set the devmode defaults so that anything the isn't copied over will
        // be set to the default value.
        pOEMDevOut->bEnabled                = WATER_MARK_DEFAULT_ENABLED;
        pOEMDevOut->dfRotate                = WATER_MARK_DEFAULT_ROTATION;
        pOEMDevOut->dwFontSize              = WATER_MARK_DEFAULT_FONTSIZE;
        pOEMDevOut->crTextColor             = WATER_MARK_DEFAULT_COLOR;
        hCopy = StringCbCopyW(pOEMDevOut->szWaterMark, sizeof(pOEMDevOut->szWaterMark), WATER_MARK_DEFAULT_TEXT);

        // Copy the old structure in to the new using which ever size is the smaller.
        // Devmode maybe from newer Devmode (not likely since there is only one), or
        // Devmode maybe a newer Devmode, in which case it maybe larger,
        // but the first part of the structure should be the same.

        // DESIGN ASSUMPTION: the private DEVMODE structure only gets added to;
        // the fields that are in the DEVMODE never change only new fields get added to the end.

        memcpy(pOEMDevOut, pOEMDevIn, __min(pOEMDevOut->dmOEMExtra.dwSize, pOEMDevIn->dmOEMExtra.dwSize));

        // Re-fill in the size and version fields to indicated 
        // that the DEVMODE is the current private DEVMODE version.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
    }
    else
    {
        WARNING(DLLTEXT("Unknown DEVMODE signature, pOEMDMIn ignored.\r\n"));

        // Don't know what the input DEVMODE is, so just use defaults.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
        pOEMDevOut->bEnabled                = WATER_MARK_DEFAULT_ENABLED;
        pOEMDevOut->dfRotate                = WATER_MARK_DEFAULT_ROTATION;
        pOEMDevOut->dwFontSize              = WATER_MARK_DEFAULT_FONTSIZE;
        pOEMDevOut->crTextColor             = WATER_MARK_DEFAULT_COLOR;
        hCopy = StringCbCopyW(pOEMDevOut->szWaterMark, sizeof(pOEMDevOut->szWaterMark), WATER_MARK_DEFAULT_TEXT);
    }

    return SUCCEEDED(hCopy);
}


BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode)
{
    if(NULL == pOEMDevmode)
    {
        return FALSE;
    }

    // ASSUMPTION: pOEMDevmode is large enough to contain OEMDEV structure.

    // Make sure that dmOEMExtra indicates the current OEMDEV structure.
    pOEMDevmode->dmOEMExtra.dwSize       = sizeof(OEMDEV);
    pOEMDevmode->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
    pOEMDevmode->dmOEMExtra.dwVersion    = OEM_VERSION;

    // bEnable should be either TRUE or FALSE.
    if( (TRUE != pOEMDevmode->bEnabled)
        &&
        (FALSE != pOEMDevmode->bEnabled)
      )
    {
        pOEMDevmode->bEnabled = WATER_MARK_DEFAULT_ENABLED;
    }

    // dfRotate should be between 0 and 360 inclusive.
    if( (0 > pOEMDevmode->dfRotate) 
        ||
        (360 < pOEMDevmode->dfRotate) 
      )
    {
        pOEMDevmode->dfRotate = WATER_MARK_DEFAULT_ROTATION;
    }

    // dwFontSize should be 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, or 72.
    if(!IsValidFontSize(pOEMDevmode->dwFontSize))
    {
        pOEMDevmode->dwFontSize = WATER_MARK_DEFAULT_FONTSIZE;
    }

    // The high byte of the hi word should be zero.
    if(0 != HIBYTE(HIWORD(pOEMDevmode->crTextColor)))
    {
        pOEMDevmode->crTextColor = WATER_MARK_DEFAULT_COLOR;
    }

    // Make sure that water mark string is terminated.
    pOEMDevmode->szWaterMark[WATER_MARK_TEXT_SIZE - 1] = L'\0';

    return TRUE;
}


BOOL IsValidFontSize(DWORD dwFontSize)
{
    BOOL    bValid = FALSE;


    switch(dwFontSize)
    {
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 14:
        case 16:
        case 18:
        case 20:
        case 22:
        case 24:
        case 26:
        case 28:
        case 36:
        case 48:
        case 72:
            bValid = TRUE;
            break;

        default:
            ERR(ERRORTEXT("IsValidFontSize() found invalid font size %d\r\n"), dwFontSize);
            break;
    }

    return bValid;
}


void Dump(PCOEMDEV pOEMDevmode)
{
    if( (NULL != pOEMDevmode)
        &&
        (pOEMDevmode->dmOEMExtra.dwSize >= sizeof(OEMDEV))
        &&
        (OEM_SIGNATURE == pOEMDevmode->dmOEMExtra.dwSignature)
      )
    {
        VERBOSE(TEXT("\tdmOEMExtra.dwSize      = %d\r\n"), pOEMDevmode->dmOEMExtra.dwSize);
        VERBOSE(TEXT("\tdmOEMExtra.dwSignature = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwSignature);
        VERBOSE(TEXT("\tdmOEMExtra.dwVersion   = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwVersion);
        VERBOSE(TEXT("\tbEnabled               = %#x\r\n"), pOEMDevmode->bEnabled);
        VERBOSE(TEXT("\tdfRotate               = %2.2f\r\n"), pOEMDevmode->dfRotate);
        VERBOSE(TEXT("\tdwFontSize             = %d\r\n"), pOEMDevmode->dwFontSize);
        VERBOSE(TEXT("\tcrTextColor            = RGB(%d, %d, %d)\r\n"), 
                 GetRValue(pOEMDevmode->crTextColor), 
                 GetGValue(pOEMDevmode->crTextColor),
                 GetBValue(pOEMDevmode->crTextColor));
        VERBOSE(TEXT("\tszWaterMark            = \"%ls\"\r\n"), pOEMDevmode->szWaterMark);
    }
    else
    {
        ERR(ERRORTEXT("Dump(POEMDEV) unknown private OEM DEVMODE.\r\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\common\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'
#define MAX_LOOP                10



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize      = DEBUG_BUFFER_SIZE;
    DWORD   dwLoop      = 0;
    LPSTR   lpszMsgBuf  = NULL;
    HRESULT hr;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
        {
            return FALSE;
        }

        hr = StringCbVPrintfA(lpszMsgBuf, (dwSize + 1) * sizeof(CHAR), lpszMessage, arglist);

    // Pass the variable parameters to wvsprintf to be formated.
    } while (FAILED(hr) && (STRSAFE_E_INSUFFICIENT_BUFFER == hr) && (++dwLoop < MAX_LOOP) );

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return SUCCEEDED(hr);
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR      lpszMsgBuf;
    HRESULT     hResult;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    hResult = StringCbVPrintfW(lpszMsgBuf, (dwSize + 1) * sizeof(WCHAR), lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return SUCCEEDED(hResult);
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(TEXT("pPublisherInfo:\r\n"));
    if(NULL == pPublisherInfo)
    {
        VERBOSE(TEXT("\tpPublisherInfo is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(TEXT("pOemDMParam:\r\n"));
    if(NULL == pOemDMParam)
    {
        VERBOSE(TEXT("\tpOemDMParam is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}

void Dump(PPROPSHEETUI_INFO pPSUIInfo)
{
    VERBOSE(TEXT("pPSUIInfo:\r\n"));
    if(NULL == pPSUIInfo)
    {
        VERBOSE(TEXT("\tpPSUIInfo is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize          = %d\r\n"), pPSUIInfo->cbSize);
    VERBOSE(TEXT("\tVersion         = %#x\r\n"), pPSUIInfo->Version);
    VERBOSE(TEXT("\tFlags           = %#x\r\n"), pPSUIInfo->Flags);
    VERBOSE(TEXT("\tReason          = %d\r\n"), pPSUIInfo->Reason);
    VERBOSE(TEXT("\thComPropSheet   = %#x\r\n"), pPSUIInfo->hComPropSheet);
    VERBOSE(TEXT("\tpfnComPropSheet = %#x\r\n"), pPSUIInfo->pfnComPropSheet);
    VERBOSE(TEXT("\tlParamInit      = %#x\r\n"), pPSUIInfo->lParamInit);
    VERBOSE(TEXT("\tUserData        = %#x\r\n"), pPSUIInfo->UserData);
    VERBOSE(TEXT("\tResult          = %#x\r\n"), pPSUIInfo->Result);
}

void Dump(POPTITEM pOptItem)
{
    VERBOSE(TEXT("pOptItem:\r\n"));
    if(NULL == pOptItem)
    {
        VERBOSE(TEXT("\tpOptItem is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize          = %d\r\n"),     pOptItem->cbSize);
    VERBOSE(TEXT("\tLevel           = %d\r\n"),     pOptItem->Level);
    VERBOSE(TEXT("\tDlgPageIdx      = %d\r\n"),     pOptItem->DlgPageIdx);
    VERBOSE(TEXT("\tFlags           = 0x%x\r\n"),   pOptItem->Flags);
    VERBOSE(TEXT("\tUserData        = 0x%p\r\n"),   pOptItem->UserData);
    VERBOSE(TEXT("\tpName           = %s\r\n"),     pOptItem->pName ? pOptItem->pName : TEXT("<NULL>"));
    VERBOSE(TEXT("\tpSel            = 0x%p\r\n"),   pOptItem->pSel);
    VERBOSE(TEXT("\tpExtChkBox      = 0x%p\r\n"),   pOptItem->pExtChkBox);
    VERBOSE(TEXT("\tpExtChkBox      = 0x%p\r\n"),   pOptItem->pExtChkBox);
    VERBOSE(TEXT("\tHelpIndex       = 0x%x\r\n"),   pOptItem->HelpIndex);
    VERBOSE(TEXT("\tDMPubID         = 0x%x\r\n"),   pOptItem->DMPubID);
    VERBOSE(TEXT("\tUserItemID      = 0x%x\r\n"),   pOptItem->UserItemID);
    VERBOSE(TEXT("\twReserved       = 0x%x\r\n"),   pOptItem->wReserved);
    VERBOSE(TEXT("\tpOIExt          = 0x%p\r\n"),   pOptItem->pOIExt);

    Dump(pOptItem->pOptType);
}

void Dump(POPTTYPE pOptType)
{
    VERBOSE(TEXT("\tpOptType:\r\n"));
    if(NULL == pOptType)
    {
        VERBOSE(TEXT("\t\tpOptType is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\t\tcbSize    = %d\r\n"),     pOptType->cbSize);
    VERBOSE(TEXT("\t\tType      = 0x%x\r\n"),   pOptType->Type);
    VERBOSE(TEXT("\t\tFlags     = 0x%x\r\n"),   pOptType->Flags);
    VERBOSE(TEXT("\t\tCount     = %d\r\n"),     pOptType->Count);
    VERBOSE(TEXT("\t\tCount     = 0x%x\r\n"),   pOptType->BegCtrlID);
    VERBOSE(TEXT("\t\tStyle     = 0x%x\r\n"),   pOptType->Style);

    Dump(pOptType->pOptParam, pOptType->Count);
}

void Dump(POPTPARAM pOptParam, WORD wCount)
{
    if(NULL == pOptParam)
    {
        VERBOSE(TEXT("\t\tpOptParam is NULL!\r\n"));
        return;
    }

    for(WORD wIndex = 0; wIndex < wCount; ++wIndex)
    {
        VERBOSE(TEXT("\t\tpOptParam[wIndex]:\r\n"));
        VERBOSE(TEXT("\t\t\tcbSize    = %d\r\n"),     pOptParam[wIndex].cbSize);
        VERBOSE(TEXT("\t\t\tFlags     = 0x%x\r\n"),   pOptParam[wIndex].Flags);
        VERBOSE(TEXT("\t\t\tStyle     = 0x%x\r\n"),   pOptParam[wIndex].Style);
        VERBOSE(TEXT("\t\t\tpData     = 0x%p\r\n"),   pOptParam[wIndex].pData);
        VERBOSE(TEXT("\t\t\tIconID    = 0x%p\r\n"),   pOptParam[wIndex].IconID);
        VERBOSE(TEXT("\t\t\tlParam    = 0x%p\r\n"),   pOptParam[wIndex].lParam);
    }
}


PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\oemui.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    OEMUI.cpp
//    
//
//  PURPOSE:  Main file for OEM UI test module.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "resource.h"
#include "debug.h"
#include "fusutils.h"
#include "oemui.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      INTERNAL MACROS and DEFINES
////////////////////////////////////////////////////////

typedef struct _tagCBUserData 
{
    HANDLE          hComPropSheet;
    HANDLE          hPropPage;
    POEMUIPSPARAM   pOEMUIParam;
    PFNCOMPROPSHEET pfnComPropSheet;

} CBUSERDATA, *PCBUSERDATA;



////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUICallBack2(PCPSUICBPARAM pCallbackParam);
INT_PTR CALLBACK DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
static POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems);
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems);
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams);
static PTSTR GetStringResource(HANDLE hHeap, HANDLE hModule, UINT uResource);



////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM device or document property UI.
//
HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    HRESULT hResult = S_OK;


    VERBOSE(DLLTEXT("hrOEMPropertyPage(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (OEMCUIP_DOCPROP != dwMode)
        &&
        (OEMCUIP_PRNPROP != dwMode)        
      )
    {
        ERR(ERRORTEXT("hrOEMPropertyPage() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOEMUIParam = %#lx.\r\n"), dwMode, pOEMUIParam);

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        case OEMCUIP_DOCPROP:
            hResult = hrDocumentPropertyPage(dwMode, pOEMUIParam);
            break;

        case OEMCUIP_PRNPROP:
            hResult = hrPrinterPropertyPage(dwMode, pOEMUIParam);
            break;

        default:
            // Should never reach this!
            ERR(ERRORTEXT("hrOEMPropertyPage() Invalid dwMode, %d"), dwMode);
            SetLastError(ERROR_INVALID_PARAMETER);
            hResult = E_FAIL;
            break;
    }

    return hResult;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM document property UI.
//
static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM document property UI.
        pOEMUIParam->cOEMOptItems = 1;

        VERBOSE(DLLTEXT("hrDocumentPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
        POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


        VERBOSE(DLLTEXT("hrDocumentPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMDocUICallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // New section.
        pOEMUIParam->pOEMOptItems[0].Level  = 1;
        pOEMUIParam->pOEMOptItems[0].Flags  = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].pName  = GetStringResource(pOEMUIParam->hOEMHeap, pOEMUIParam->hModule, IDS_ADV_SECTION);
        pOEMUIParam->pOEMOptItems[0].Sel    = pOEMDev->dwAdvancedData;

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

        pOEMUIParam->pOEMOptItems[0].pOptType->Type                 = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID  = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam  = 100;
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM printer property UI.
//
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM printer property UI.
        pOEMUIParam->cOEMOptItems = 1;

        VERBOSE(DLLTEXT("hrPrinterPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
        DWORD   dwError;
        DWORD   dwDeviceValue;
        DWORD   dwType;
        DWORD   dwNeeded;


        VERBOSE(DLLTEXT("hrPrinterPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Get device settings value from printer.
        dwError = GetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, &dwType, (PBYTE) &dwDeviceValue,
                                   sizeof(dwDeviceValue), &dwNeeded);
        if( (ERROR_SUCCESS != dwError)
            ||
            (dwDeviceValue > 100)
          )
        {
            // Failed to get the device value or value is invalid, just use the default.
            dwDeviceValue = 0;
        }

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMPrinterUICallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // New section.
        pOEMUIParam->pOEMOptItems[0].Level  = 1;
        pOEMUIParam->pOEMOptItems[0].Flags  = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].pName  = GetStringResource(pOEMUIParam->hOEMHeap, pOEMUIParam->hModule, IDS_DEV_SECTION);
        pOEMUIParam->pOEMOptItems[0].Sel    = dwDeviceValue;

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

        pOEMUIParam->pOEMOptItems[0].pOptType->Type                 = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID  = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam  = 100;
    }

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to Document property sheet.
//
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, 
                                    IPrintOemDriverUI*  pOEMHelp)
{
    LONG_PTR    lResult;


    VERBOSE(DLLTEXT("OEMDocumentPropertySheets() entry.\r\n"));

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("OEMDocumentPropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return  E_FAIL;
    }

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                DWORD           dwSheets        = 0;
                PCBUSERDATA     pUserData;
                POEMUIPSPARAM   pOEMUIParam     = (POEMUIPSPARAM) pPSUIInfo->lParamInit;
                HANDLE          hHeap           = pOEMUIParam->hOEMHeap;
                POEMDEV         pOEMDev         = (POEMDEV) pOEMUIParam->pOEMDM;
                COMPROPSHEETUI  Sheet;


                // Init property page.
                memset(&Sheet, 0, sizeof(COMPROPSHEETUI));
                Sheet.cbSize            = sizeof(COMPROPSHEETUI);
                Sheet.Flags             = CPSUIF_UPDATE_PERMISSION;
                Sheet.hInstCaller       = ghInstance;
                Sheet.pCallerName       = GetStringResource(hHeap, ghInstance, IDS_NAME);
                Sheet.pHelpFile         = NULL;
                Sheet.pfnCallBack       = OEMDocUICallBack2;
                Sheet.pDlgPage          = CPSUI_PDLGPAGE_TREEVIEWONLY;
                Sheet.cOptItem          = 1;
                Sheet.IconID            = IDI_CPSUI_PRINTER;
                Sheet.pOptItemName      = GetStringResource(hHeap, ghInstance, IDS_SECTION);
                Sheet.CallerVersion     = 0x100;
                Sheet.OptItemVersion    = 0x100;

                // Init user data.
                pUserData = (PCBUSERDATA) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(CBUSERDATA));
                pUserData->hComPropSheet    = pPSUIInfo->hComPropSheet;
                pUserData->pfnComPropSheet  = pPSUIInfo->pfnComPropSheet;
                pUserData->pOEMUIParam      = pOEMUIParam;
                Sheet.UserData              = (ULONG_PTR) pUserData;

                // Create OptItems for page.
                Sheet.pOptItem = CreateOptItems(hHeap, Sheet.cOptItem);

                // Initialize OptItems
                Sheet.pOptItem[0].Level     = 1;
                Sheet.pOptItem[0].Flags     = OPTIF_COLLAPSE;
                Sheet.pOptItem[0].pName     = GetStringResource(hHeap, ghInstance, IDS_SECTION);
                Sheet.pOptItem[0].Sel       = pOEMDev->dwDriverData;

                Sheet.pOptItem[0].pOptType = CreateOptType(hHeap, 2);

                Sheet.pOptItem[0].pOptType->Type                    = TVOT_UDARROW;
                Sheet.pOptItem[0].pOptType->pOptParam[1].IconID     = 0;
                Sheet.pOptItem[0].pOptType->pOptParam[1].lParam     = 100;

                // NOTE: Don't need to do anything with Activation Contexts
                //       to get Themed UI, since Compstui will create this 
                //       page using it's Activation Context which specifies
                //       comctl v6.

                // Add property sheets.
                lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PCOMPROPSHEETUI, 
                                                     (LPARAM)&Sheet, (LPARAM)&dwSheets);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }

    pPSUIInfo->Result = lResult;
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to printer property sheet.
//
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam)
{
    LONG_PTR    lResult;


    VERBOSE(DLLTEXT("hrOEMDevicePropertySheets(%#x, %#x) entry\r\n"), pPSUIInfo, lParam);

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("hrOEMDevicePropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    Dump(pPSUIInfo);

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                HANDLE          hActCtx;
                PROPSHEETPAGE   Page;

                // Init property page.
                memset(&Page, 0, sizeof(PROPSHEETPAGE));
                Page.dwSize         = sizeof(PROPSHEETPAGE);
                Page.dwFlags        = PSP_DEFAULT;
                Page.hInstance      = ghInstance;
                Page.pszTemplate    = MAKEINTRESOURCE(IDD_DEVICE_PROPPAGE);
                Page.pfnDlgProc     = DevicePropPageProc;
                Page.hActCtx        = GetMyActivationContext();

                // Set the flag to indicate that our PROPSHEETPAGE
                // has an Activation Context.
                // The Activation Context indicates with version of
                // comctl for Compstui to create our PROPSHEETPAGE
                // with. To get Themed UI we need to specify comctl v6.
                if( (NULL != Page.hActCtx) && (INVALID_HANDLE_VALUE != Page.hActCtx))
                {
                    Page.dwFlags |= PSP_USEFUSIONCONTEXT;
                }

                // Add property sheets.
                lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PROPSHEETPAGE, (LPARAM)&Page, 0);

                // NOTE: The Activation Context is released when the DLL is unloaded 
                //       during DLL_PROCESS_DETACH.

                VERBOSE(DLLTEXT("hrOEMDevicePropertySheets() pfnComPropSheet returned %d.\r\n"), lResult);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }

    pPSUIInfo->Result = lResult;
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM printer property UI.
//
LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMPrinterUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            {
                DWORD   dwDriverValue = pOEMUIParam->pOEMOptItems[0].Sel;

                // Store OptItems state in printer data.
                SetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, REG_DWORD, (PBYTE) &dwDriverValue, sizeof(DWORD));
            }
            break;

        default:
            break;
    }

    return lReturn;
}


////////////////////////////////////////////////////////////////////////////////
//
// Call back for OEM device property UI.
//
INT_PTR CALLBACK DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg)
    {
        case WM_COMMAND:
            switch(HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch(LOWORD(wParam))
                    {
                        case IDC_CALIBRATE:
                            // Just display a message that the printer is calibrated,
                            // since we don't acutally calibrate anything.
                            {
                                TCHAR   szName[MAX_PATH];
                                TCHAR   szCalibrated[MAX_PATH];


                                LoadString(ghInstance, IDS_NAME, szName, sizeof(szName)/sizeof(szName[0]));
                                LoadString(ghInstance, IDS_CALIBRATED, szCalibrated, sizeof(szCalibrated)/sizeof(szCalibrated[0]));
                                MessageBox(hDlg, szCalibrated, szName, MB_OK);
                            }
                            break;
                    }
                    break;

                default:
                    return FALSE;
            }
            return TRUE;

        case WM_NOTIFY:
            {
                switch (((LPNMHDR)lParam)->code)  // type of notification message
                {
                    case PSN_SETACTIVE:
                        break;
    
                    case PSN_KILLACTIVE:
                        break;

                    case PSN_APPLY:
                        break;

                    case PSN_RESET:
                        break;
                }
            }
            break;
    }

    return FALSE;
} 


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM document property UI.
//
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            // Store OptItems state in DEVMODE.
            pOEMDev->dwAdvancedData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

        case CPSUICB_REASON_KILLACTIVE:
            pOEMDev->dwAdvancedData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

        case CPSUICB_REASON_SETACTIVE:
            if(pOEMUIParam->pOEMOptItems[0].Sel != pOEMDev->dwAdvancedData)
            {
                pOEMUIParam->pOEMOptItems[0].Sel    = pOEMDev->dwAdvancedData;
                pOEMUIParam->pOEMOptItems[0].Flags |= OPTIF_CHANGED;
                lReturn                             = CPSUICB_ACTION_OPTIF_CHANGED;
            }
            break;

        default:
            break;
    }

    return lReturn;
}


LONG APIENTRY OEMDocUICallBack2(PCPSUICBPARAM pCallbackParam)
{
    LONG            lReturn = CPSUICB_ACTION_NONE;
    PCBUSERDATA     pUserData = (PCBUSERDATA) pCallbackParam->UserData;
    POEMDEV         pOEMDev = (POEMDEV) pUserData->pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUICallBack2() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            pOEMDev->dwDriverData = pCallbackParam->pOptItem[0].Sel;
            pUserData->pfnComPropSheet(pUserData->hComPropSheet, CPSFUNC_SET_RESULT,
            	                       (LPARAM)pUserData->hPropPage,
               	                       (LPARAM)CPSUI_OK);
            break;

        case CPSUICB_REASON_KILLACTIVE:
            pOEMDev->dwDriverData = pCallbackParam->pOptItem[0].Sel;
            break;

        case CPSUICB_REASON_SETACTIVE:
            if(pCallbackParam->pOptItem[0].Sel != pOEMDev->dwDriverData)
            {
                pCallbackParam->pOptItem[0].Sel     = pOEMDev->dwDriverData;
                pCallbackParam->pOptItem[0].Flags  |= OPTIF_CHANGED;
                lReturn                             = CPSUICB_ACTION_OPTIF_CHANGED;
            }
            break;

        default:
            break;
    }

    return lReturn;
}


////////////////////////////////////////////////////////////////////////////////
//
// Creates and Initializes OptItems.
//
static POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems)
{
    POPTITEM    pOptItems = NULL;


    // Allocate memory for OptItems;
    pOptItems = (POPTITEM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTITEM) * dwOptItems);
    if(NULL != pOptItems)
    {
        InitOptItems(pOptItems, dwOptItems);
    }
    else
    {
        ERR(ERRORTEXT("CreateOptItems() failed to allocate memory for OPTITEMs!\r\n"));
    }

    return pOptItems;
}


////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems.
//
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems)
{
    VERBOSE(DLLTEXT("InitOptItems() entry.\r\n"));

    // Zero out memory.
    memset(pOptItems, 0, sizeof(OPTITEM) * dwOptItems);

    // Set each OptItem's size, and Public DM ID.
    for(DWORD dwCount = 0; dwCount < dwOptItems; dwCount++)
    {
        pOptItems[dwCount].cbSize   = sizeof(OPTITEM);
        pOptItems[dwCount].DMPubID  = DMPUB_NONE;
    }
}


////////////////////////////////////////////////////////////////////////////////
//
// Allocates and initializes OptType for OptItem.
//
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams)
{
    POPTTYPE    pOptType = NULL;


    VERBOSE(DLLTEXT("CreateOptType() entry.\r\n"));

    // Allocate memory from the heap for the OPTTYPE; the driver will take care of clean up.
    pOptType = (POPTTYPE) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTTYPE));
    if(NULL != pOptType)
    {
        // Initialize OPTTYPE.
        pOptType->cbSize    = sizeof(OPTTYPE);
        pOptType->Count     = wOptParams;

        // Allocate memory from the heap for the OPTPARAMs for the OPTTYPE.
        pOptType->pOptParam = (POPTPARAM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, wOptParams * sizeof(OPTPARAM));
        if(NULL != pOptType->pOptParam)
        {
            // Initialize the OPTPARAMs.
            for(WORD wCount = 0; wCount < wOptParams; wCount++)
            {
                pOptType->pOptParam[wCount].cbSize = sizeof(OPTPARAM);
            }
        }
        else
        {
            ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTPARAMs!\r\n"));

            // Free allocated memory and return NULL.
            HeapFree(hHeap, 0, pOptType);
            pOptType = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTTYPE!\r\n"));
    }

    return pOptType;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Retrieves pointer to a String resource.
//
static PTSTR GetStringResource(HANDLE hHeap, HANDLE hModule, UINT uResource)
{
    int     nResult;
    DWORD   dwSize = MAX_PATH;
    PTSTR   pszString = NULL;


    VERBOSE(DLLTEXT("GetStringResource(%#x, %#x, %d) entered.\r\n"), hHeap, hModule, uResource);

    // Allocate buffer for string resource from heap; let the driver clean it up.
    pszString = (PTSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize * sizeof(TCHAR));
    if(NULL != pszString)
    {
        // Load string resource; resize after loading so as not to waste memory.
        nResult = LoadString((HMODULE)hModule, uResource, pszString, dwSize);
        if(nResult > 0)
        {
            PTSTR   pszTemp;


            VERBOSE(DLLTEXT("LoadString() returned %d!\r\n"), nResult);
            VERBOSE(DLLTEXT("String load was \"%s\".\r\n"), pszString);

            pszTemp = (PTSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, pszString, (nResult + 1) * sizeof(TCHAR));
            if(NULL != pszTemp)
            {
                pszString = pszTemp;
            }
            else
            {
                ERR(ERRORTEXT("GetStringResource() HeapReAlloc() of string retrieved failed! (Last Error was %d)\r\n"), GetLastError());
            }
        }
        else
        {
            ERR(ERRORTEXT("LoadString() returned %d! (Last Error was %d)\r\n"), nResult, GetLastError());
            ERR(ERRORTEXT("GetStringResource() failed to load string resource %d!\r\n"), uResource);

            pszString = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("GetStringResource() failed to allocate string buffer!\r\n"));
    }

    return pszString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\common\devmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Devmode.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for devmode functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _DEVMODE_H
#define _DEVMODE_H


////////////////////////////////////////////////////////
//      OEM Devmode Defines
////////////////////////////////////////////////////////

#define WATER_MARK_TEXT_SIZE            128
#define WATER_MARK_DEFAULT_ENABLED      TRUE
#define WATER_MARK_DEFAULT_ROTATION     30
#define WATER_MARK_DEFAULT_FONTSIZE     28
#define WATER_MARK_DEFAULT_COLOR        RGB(230, 230, 230)
#define WATER_MARK_DEFAULT_TEXT         L"WaterMark"



////////////////////////////////////////////////////////
//      OEM Devmode Type Definitions
////////////////////////////////////////////////////////

typedef struct tagOEMDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    BOOL                bEnabled;
    DOUBLE              dfRotate;
    DWORD               dwFontSize;
    COLORREF            crTextColor;
    WCHAR               szWaterMark[WATER_MARK_TEXT_SIZE];

} OEMDEV, *POEMDEV;

typedef const OEMDEV *PCOEMDEV;



/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam);
BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut);
BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode);
BOOL IsValidFontSize(DWORD dwFontSize);
void Dump(PCOEMDEV pOEMDevIn);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif

// Isolation define for using ComCtrl v6.
#ifndef ISOLATION_AWARE_ENABLED
    #define ISOLATION_AWARE_ENABLED
#endif


// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
#include <WINDDI.H>
#include <WINSPOOL.H>
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRSHT.H>
#include "COMPSTUI.H"
#include <WINDDIUI.H>
#include <PRINTOEM.H>
#include <COMMCTRL.H>


#define COUNTOF(p)  (sizeof(p)/sizeof(*(p)))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\common\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _DEBUG_H
#define _DEBUG_H

#include <COMPSTUI.H>


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);
void Dump(PPROPSHEETUI_INFO pPSUIInfo);
void Dump(POPTITEM pOptItem);
void Dump(POPTTYPE pOptType);
void Dump(POPTPARAM pOptParam, WORD wCount);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\common\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997- 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\command.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:  Command.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for OEM Command function(s).
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _COMMAND_H
#define _COMMAND_H




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT PSCommand(PDEVOBJ, DWORD, PVOID, DWORD, IPrintOemDriverPS*, PDWORD pdwReturn);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\fdebug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	fDebug.cpp
//    
//
//  PURPOSE:  Place holder for including debug functions.
//
//
//	Functions:
//
//		FormatLastError()
//      DebugMessage()
//      DebugMsg()
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"

#include <DEBUG.CPP>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\command.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	command.cpp
//    
//
//  PURPOSE:  Source module for OEM customized Command(s).
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include <PRCOMOEM.H>
#include "wmarkps.h"
#include "debug.h"
#include "command.h"
#include "resource.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>




/////////////////////////////////////////////////////////
//		Internal Macros & Defines
/////////////////////////////////////////////////////////

// Macros to convert from Windows RGB to PostScript RGB
#define GetPS2Color(dw)     ((dw) / 255.0)
#define GetPS2RValue(cr)    (GetPS2Color(GetRValue(cr)))
#define GetPS2GValue(cr)    (GetPS2Color(GetGValue(cr)))
#define GetPS2BValue(cr)    (GetPS2Color(GetBValue(cr)))


// Initial buffer size
#define INITIAL_BUFFER_SIZE     16


// String format defines characters
#define FORMAT_DELIM            '!'
#define FORMAT_STRING_ANSI      's'
#define FORMAT_STRING_UNICODE   'S'
#define FORMAT_CHAR             '%'


// Loop limiter.
#define MAX_LOOP    10


/////////////////////////////////////////////////////////
//		Internal ProtoTypes
/////////////////////////////////////////////////////////

static PSTR GetPostScriptResource(HMODULE hModule, LPCTSTR pszResource, PDWORD pdwSize);
static PSTR CreateWaterMarkProlog(HMODULE hModule, PDWORD pdwSize, LPWSTR pszWaterMark, 
                                  DWORD dwFontSize, LPSTR pszColor, LPSTR pszAngle);
static PSTR DoWaterMarkProlog(HMODULE hModule, POEMDEV pOemDevmode, PDWORD pdwSize);
static DWORD FormatResource(LPSTR pszResource, LPSTR *ppszProlog, ...);
static DWORD CharSize(DWORD dwValue, DWORD dwBase = 10);



////////////////////////////////////////////////////////////////////////////////////
//    The PSCRIPT driver calls this OEM function at specific points during output
//    generation. This gives the OEM DLL an opportunity to insert code fragments
//    at specific injection points in the driver's code. It should use
//    DrvWriteSpoolBuf for generating any output it requires.

HRESULT PSCommand(PDEVOBJ pdevobj, DWORD dwIndex, PVOID pData, DWORD cbSize, 
                  IPrintOemDriverPS* pOEMHelp, PDWORD pdwReturn)
{
    BOOL    bFreeProcedure      = FALSE;
    PSTR    pProcedure          = NULL;
    DWORD   dwLen               = 0;
    DWORD   dwSize              = 0;
    HRESULT hResult             = E_FAIL;


    VERBOSE(DLLTEXT("Entering OEMCommand...\r\n"));

    switch (dwIndex)
    {
        case PSINJECT_BEGINPROLOG:
            {
                POEMDEV pOemDevmode = (POEMDEV) pdevobj->pOEMDM;


                VERBOSE(DLLTEXT("OEMCommand PSINJECT_BEGINPROLOG\r\n"));

                // Only do Water Mark PS prolog injection if Water Mark is enabled.
                if(pOemDevmode->bEnabled)
                {
                    pProcedure = DoWaterMarkProlog((HMODULE) pdevobj->hOEM, pOemDevmode, &dwSize);
                    bFreeProcedure = (NULL != pProcedure);
                }
            }
            break;

        case PSINJECT_BEGINPAGESETUP:
            {
                POEMDEV pOemDevmode = (POEMDEV) pdevobj->pOEMDM;


                VERBOSE(DLLTEXT("OEMCommand PSINJECT_BEGINPAGESETUP\r\n"));

                // Only do Water Mark PS page injection if Water Mark is enabled.
                if(pOemDevmode->bEnabled)
                {
                    pProcedure = GetPostScriptResource((HMODULE) pdevobj->hOEM, MAKEINTRESOURCE(IDR_WATERMARK_DRAW), &dwSize);
                }
            }
            break;

        default:
            VERBOSE(DLLTEXT("PSCommand Default, command index %d...\r\n"), dwIndex);
            *pdwReturn = ERROR_NOT_SUPPORTED;
            return E_NOTIMPL;
    }

    if(NULL != pProcedure)
    {
        // Write PostScript to spool file.
        dwLen = strlen(pProcedure);
        hResult = pOEMHelp->DrvWriteSpoolBuf(pdevobj, pProcedure, dwLen, &dwSize);

        // Dump DrvWriteSpoolBuf parameters.
        VERBOSE(DLLTEXT("dwLen  = %d\r\n"), dwLen);
        VERBOSE(DLLTEXT("dwSize = %d\r\n"), dwSize);
        //VERBOSE(DLLTEXT("pProcedure is:\r\n\t%hs\r\n"), pProcedure);

        // Set return values.
        if(SUCCEEDED(hResult) && (dwLen == dwSize))
        {
            *pdwReturn = ERROR_SUCCESS;
        }
        else
        {
            // Try to return meaningful
            // error value.
            *pdwReturn = GetLastError();
            if(ERROR_SUCCESS == *pdwReturn)
            {
                *pdwReturn = ERROR_WRITE_FAULT;
            }

            // Make sure we return failure
            // if the write didn't succeded.
            if(SUCCEEDED(hResult))
            {
                hResult = HRESULT_FROM_WIN32(*pdwReturn);
            }
        }

        if(bFreeProcedure)
        {
            // INVARIANT: pProcedure was created with 'new' and needs to be freed.
            delete[] pProcedure;
        }
    }
    else
    {
        // pProcedure will be NULL if water mark isn't enabled.
        *pdwReturn = ERROR_NOT_SUPPORTED;
        hResult = E_NOTIMPL;
    }

    // dwLen should always equal dwSize.
    ASSERTMSG(dwLen == dwSize, DLLTEXT("number of bytes wrote should equal number of bytes written!"));

    return hResult;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Retrieves pointer to a PostScript resource.
//
static PSTR GetPostScriptResource(HMODULE hModule, LPCTSTR pszResource, PDWORD pdwSize)
{
    PSTR    pszPostScript   = NULL;
    HRSRC   hFind           = NULL;
    HGLOBAL hResource       = NULL;


    VERBOSE(DLLTEXT("GetPostScriptResource() entered.\r\n"));

    // pszResource and pdwSize Parameters should not be NULL.
    assert(NULL != pszResource);
    assert(NULL != pdwSize);

    // Load PostScript resource.
    hFind = FindResource(hModule, pszResource, MAKEINTRESOURCE(RC_PSCRIPT));
    //hFind = FindResource(hModule, pszResource, TEXT("PSCRIPT"));    
    if(NULL != hFind)
    {
        hResource = LoadResource(hModule, hFind);
        if(NULL != hResource)
        {
            pszPostScript = (PSTR) LockResource(hResource);
            *pdwSize = SizeofResource(hModule, hFind);
        }
        else
        {
            ERR(DLLTEXT("ERROR:  Failed to load PSCRIPT resource %#x!\r\n"), hFind);
        }
    }
    else
    {
        ERR(DLLTEXT("ERROR:  Failed to find PSCRIPT resource %#x!\r\n"), pszResource);
    }

    // Should have found the PScript resource.
    assert(NULL != pszPostScript);

    VERBOSE(DLLTEXT("GetPostScriptResource() returned %#x.\r\n"), pszPostScript);

    return pszPostScript;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Formats Water Mark prolog with parameter.
//
static PSTR CreateWaterMarkProlog(HMODULE hModule, PDWORD pdwSize, LPWSTR pszWaterMark, 
                                  DWORD dwFontSize, LPSTR pszColor, LPSTR pszAngle)
{
    PSTR    pszProlog   = NULL;
    PSTR    pszResource = NULL;


    // Parameters that are pointers should not be NULL!
    assert(NULL != pdwSize);
    assert(NULL != pszWaterMark);
    assert(NULL != pszColor);
    assert(NULL != pszAngle);

    // Dump parameters.
    VERBOSE(DLLTEXT("CreateWaterMarkProlog() paramters:\r\n"));
    VERBOSE(_TEXT("\tpszWaterMark = \"%ls\"\r\n"), pszWaterMark);
    VERBOSE(_TEXT("\tdwFontSize   = %d\r\n"), dwFontSize);
    VERBOSE(_TEXT("\tpszColor     = \"%hs\"\r\n"), pszColor);
    VERBOSE(_TEXT("\tpszAngle     = \"%hs\"\r\n"), pszAngle);

    // Get Water Mark prolog resource.
    pszResource = GetPostScriptResource(hModule, MAKEINTRESOURCE(IDR_WATERMARK_PROLOGUE), pdwSize);
    assert(NULL != pszResource);

    VERBOSE(DLLTEXT("CreateWaterMarkProlog(): pszResource is %hs\r\n"), pszResource != NULL ? pszResource : "<NULL>" );

    // Allocate and format the Water Mark Prolog with the correct values.
    if(NULL != pszResource)
    {
        *pdwSize = FormatResource(pszResource, &pszProlog, pszWaterMark, dwFontSize, pszColor, pszAngle);
    }

    // Returned values should not be NULL.
    assert(0 != *pdwSize);
    assert(NULL != pszProlog);

    VERBOSE(_TEXT("\t*pdwSize     = %d\r\n"), *pdwSize);

    return pszProlog;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Does the pre-formating of parameters before calling the routine 
//  that creates the prolog.
//
static PSTR DoWaterMarkProlog(HMODULE hModule, POEMDEV pOemDevmode, PDWORD pdwSize)
{
    PSTR    pszProlog = NULL;


    // Parameters should not be NULL.
    assert(NULL != hModule);
    assert(NULL != pOemDevmode);
    assert(NULL != pdwSize);

    // Only do prolog if Water Mark is enabled.
    if(pOemDevmode->bEnabled)
    {
        CHAR    szColor[INITIAL_BUFFER_SIZE] = "\0";
        DWORD   dwAngleSize = INITIAL_BUFFER_SIZE;
        LPSTR   pszAngle = NULL;

        // Format angle as a string.
        do
        {
            if(NULL != pszAngle)
            {
                delete[] pszAngle;
                dwAngleSize *= 2;
            }
            pszAngle = new CHAR[dwAngleSize];

        } while( (NULL != pszAngle) 
                 &&
                 (dwAngleSize < 1024)
                 && 
                 (FAILED(StringCbPrintfA(pszAngle, dwAngleSize, "%.1f", pOemDevmode->dfRotate)) ) 
               );

        // pszAngle should only be NULL if we run out of memory.
        assert(NULL != pszAngle);

        VERBOSE(DLLTEXT("DoWaterMarkProlog(): pszAngle is %hs\r\n"), pszAngle != NULL ? pszAngle : "<NULL>" );

        if(NULL != pszAngle)
        {
            // Format text color as string.
            if(FAILED(StringCbPrintfA(szColor, sizeof(szColor), 
                                      "%1.2f %1.2f %1.2f", 
                                      GetPS2RValue(pOemDevmode->crTextColor),
                                      GetPS2GValue(pOemDevmode->crTextColor), 
                                      GetPS2BValue(pOemDevmode->crTextColor))))
            {
                ERR(ERRORTEXT("DoWaterMarkProlog() failed to create PostScript color string for water mark."));
            }

            VERBOSE(DLLTEXT("DoWaterMarkProlog(): szColor is %hs\r\n"), szColor);

            // Create Water Mark prolog.
            pszProlog = CreateWaterMarkProlog(hModule, pdwSize, pOemDevmode->szWaterMark, 
                                              pOemDevmode->dwFontSize, szColor, pszAngle);

            VERBOSE(DLLTEXT("DoWaterMarkProlog(): pszProlog is %hs\r\n"), pszProlog != NULL ? pszProlog : "<NULL>" );

            // Angle string is no longer needed.
            delete[] pszAngle;
        }
    }

    return pszProlog;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Formats Resource.
//
static DWORD FormatResource(LPSTR pszResource, LPSTR *ppszBuffer, ...)
{
    DWORD   dwSize  = strlen(pszResource) + MAX_PATH;
    DWORD   dwLoop  = 0;
    va_list vaList;
    HRESULT hResult = E_FAIL;


    va_start(vaList, ppszBuffer);

    // *ppszBuffer should be NULL when passed in.
    *ppszBuffer = NULL;

    // Allocate and format the string.
    do {

        if(NULL != *ppszBuffer)
        {
            delete[] *ppszBuffer;
        }
        *ppszBuffer = new CHAR[dwSize];
        if(NULL == *ppszBuffer)
        {
            goto Cleanup;
        }

        hResult = StringCbVPrintfA(*ppszBuffer, dwSize, pszResource, vaList);

        if(STRSAFE_E_INSUFFICIENT_BUFFER == hResult)
        {
            dwSize *= 2;
        }

    } while ( FAILED(hResult) && (dwLoop++ < MAX_LOOP));

Cleanup:

    // Check to see if we hit error.
    if(FAILED(hResult))
    {
        if(NULL != *ppszBuffer)
        {
            delete[] *ppszBuffer;
            *ppszBuffer = NULL;
        }
    }

    va_end(vaList);

    return lstrlenA(*ppszBuffer);
}


DWORD CharSize(DWORD dwValue, DWORD dwBase)
{
    DWORD dwSize = 1;


    // Make sure taht base is more than 2.
    if(dwBase < 2)
    {
        return dwSize;
    }

    // Loop until dwValue is less than dwBase, 
    // dividing by dwBase each time.
    while(dwValue >= dwBase)
    {
        dwValue /= dwBase;
        ++dwSize;
    }

    return dwSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\fdevmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	fDevmode.cpp
//    
//
//  PURPOSE:  Place holder file for devmode functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "wmarkps.h"
#include <DEVMODE.CPP>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "wmarkps.h"
#include "debug.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//

// DllMain isn't called/used for kernel mode version.
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}



}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\intrface.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Intrface.H
//    
//
//  PURPOSE:	Define COM interface for User Mode Printer Customization DLL.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _INTERFACE_H
#define _INTERFACE_H




////////////////////////////////////////////////////////////////////////////////
//
//  IWaterMarkPS
//
//  Interface for PostScript OEM sample rendering module
//
class IWaterMarkPS : public IPrintOemPS
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);


    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);
    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommand - PSCRIPT only, return E_NOTIMPL on Unidrv
    //

    STDMETHOD(Command) (THIS_ PDEVOBJ     pdevobj,
                              DWORD       dwIndex,
                              PVOID       pData,
                              DWORD       cbSize,
                              OUT DWORD   *pdwResult);

    //

    IWaterMarkPS() { m_cRef = 1; m_pOEMHelp = NULL; };
    ~IWaterMarkPS();

protected:
    LONG                m_cRef;
    IPrintOemDriverPS*  m_pOEMHelp;
};





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif


// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
extern "C" 
{
    #include <WINDDI.H>
}
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRINTOEM.H>


#define COUNTOF(p)  (sizeof(p)/sizeof(*(p)))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WMarkPS.rc
//
#define IDR_WATERMARK_PROLOGUE          1
#define IDR_WATERMARK_DRAW              2
#define RC_PSCRIPT                      0x5053

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\intrface.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Intrface.cpp
//    
//
//  PURPOSE:  Interface for User Mode COM Customization DLL.
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "wmarkps.h"
#include "debug.h"
#include "command.h"
#include "intrface.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>




////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents = 0;     // Count of active components
static long g_cServerLocks = 0;    // Count of locks






////////////////////////////////////////////////////////////////////////////////
//
// IWaterMarkPS body
//
IWaterMarkPS::~IWaterMarkPS()
{
    // Make sure that helper interface is released.
    if(NULL != m_pOEMHelp)
    {
        m_pOEMHelp->Release();
        m_pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == m_cRef);
}


HRESULT __stdcall IWaterMarkPS::QueryInterface(const IID& iid, void** ppv)
{    
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE(DLLTEXT("IWaterMarkPS::QueryInterface IUnknown.\r\n")); 
    }
    else if (iid == IID_IPrintOemPS)
    {
        *ppv = static_cast<IPrintOemPS*>(this);
        VERBOSE(DLLTEXT("IWaterMarkPS::QueryInterface IPrintOemPs.\r\n")); 
    }
    else
    {
#if DBG && defined(USERMODE_DRIVER)
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        VERBOSE(DLLTEXT("IWaterMarkPS::QueryInterface %s not supported.\r\n"), szOutput); 
#endif
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

ULONG __stdcall IWaterMarkPS::AddRef()
{
    VERBOSE(DLLTEXT("IWaterMarkPS::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IWaterMarkPS::Release() 
{
    VERBOSE(DLLTEXT("IWaterMarkPS::Release() entry.\r\n"));
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}


HRESULT __stdcall IWaterMarkPS::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE(DLLTEXT("IWaterMarkPS::GetInfo(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        VERBOSE(DLLTEXT("IWaterMarkPS::GetInfo() exit pcbNeeded is NULL! ERROR_INVALID_PARAMETER\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size.
    if(OEMGI_GETPUBLISHERINFO != dwMode)
    {
        *pcbNeeded = sizeof(DWORD);
    }
    else
    {
        *pcbNeeded = sizeof(PUBLISHERINFO);
        return E_FAIL;
    }

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        WARNING(DLLTEXT("IWaterMarkPS::GetInfo() exit insufficient buffer!\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = OEM_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = OEM_VERSION;
            break;

        case OEMGI_GETPUBLISHERINFO:
            Dump((PPUBLISHERINFO)pBuffer);
            // Fall through to default case.

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            WARNING(DLLTEXT("IWaterMarkPS::GetInfo() exit mode not supported.\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IWaterMarkPS::GetInfo() exit S_OK, (*pBuffer is %#x).\r\n"), *(PDWORD)pBuffer);

    return S_OK;
}

HRESULT __stdcall IWaterMarkPS::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IWaterMarkPS::PublishDriverInterface() entry.\r\n"));

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->m_pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverPS, (void** ) &(this->m_pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->m_pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}


HRESULT __stdcall IWaterMarkPS::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    VERBOSE(DLLTEXT("IWaterMarkPS::EnableDriver() entry.\r\n"));

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    // If error occurs, return E_FAIL.
    return S_OK;
}

HRESULT __stdcall IWaterMarkPS::DisableDriver(VOID)
{
    VERBOSE(DLLTEXT("IWaterMarkPS::DisaleDriver() entry.\r\n"));

    // Release reference to Printer Driver's interface.
    if (this->m_pOEMHelp)
    {
        this->m_pOEMHelp->Release();
        this->m_pOEMHelp = NULL;
    }

    return S_OK;
}

HRESULT __stdcall IWaterMarkPS::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    VERBOSE(DLLTEXT("IWaterMarkPS::DisablePDEV() entry.\r\n"));

    return E_NOTIMPL;
};

HRESULT __stdcall IWaterMarkPS::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE(DLLTEXT("IWaterMarkPS::EnablePDEV() entry.\r\n"));

    return E_NOTIMPL;
}


HRESULT __stdcall IWaterMarkPS::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    VERBOSE(DLLTEXT("IWaterMarkPS::ResetPDEV() entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IWaterMarkPS::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IWaterMarkPS:DevMode(%d, %#x) entry.\n"), dwMode, pOemDMParam); 
    return hrOEMDevMode(dwMode, pOemDMParam);
}

HRESULT __stdcall IWaterMarkPS::Command(
    PDEVOBJ     pdevobj,
    DWORD       dwIndex,
    PVOID       pData,
    DWORD       cbSize,
    OUT DWORD   *pdwResult)
{
    HRESULT hResult = E_NOTIMPL;


    VERBOSE(DLLTEXT("IWaterMarkPS::Command() entry.\r\n"));
    hResult = PSCommand(pdevobj, dwIndex, pData, cbSize, m_pOEMHelp, pdwResult);

    return hResult;
}


////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);
   
    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{    
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this); 
    }
    else
    {
#if DBG && defined(USERMODE_DRIVER)
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        VERBOSE(DLLTEXT("IOemCF::QueryInterface %s not supported.\r\n"), szOutput); 
#endif
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release() 
{
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv) 
{
    //VERBOSE(DLLTEXT("Class factory:\t\tCreate component."));

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION;
    }

    // Create component.
    IWaterMarkPS* pOemCP = new IWaterMarkPS;
    if (pOemCP == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Get the requested interface.
    HRESULT hr = pOemCP->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCP->Release();
    return hr;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock) 
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks); 
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK;
}


//
// Registration functions
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    //
    // To avoid leaving OEM DLL still in memory when Unidrv or Pscript drivers 
    // are unloaded, Unidrv and Pscript driver ignore the return value of 
    // DllCanUnloadNow of the OEM DLL, and always call FreeLibrary on the OEMDLL.
    //
    // If OEM DLL spins off a working thread that also uses the OEM DLL, the 
    // thread needs to call LoadLibrary and FreeLibraryAndExitThread, otherwise 
    // it may crash after Unidrv or Pscript calls FreeLibrary.
    //

    VERBOSE(DLLTEXT("DllCanUnloadNow entered.\r\n"));

    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:\tCreate class factory.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\globals.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Globals.h
//    
//
//  PURPOSE:   Lists of globals declared in Globals.cpp.
//
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _GLOBALS_H
#define _GLOBALS_H


///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
extern HINSTANCE   ghInstance;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\wmarkps.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	WMarkPS.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _WMARKPS_H
#define _WMARKPS_H

#include <OEM.H>
#include <DEVMODE.H>


////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define DLLTEXT(s)      TEXT("WMARKPS:  ") TEXT(s)
#define ERRORTEXT(s)    TEXT("ERROR ") DLLTEXT(s)



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\fdebug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	fDebug.cpp
//    
//
//  PURPOSE:  Place holder file for debug functions.
//
//
//	Functions:
//
//		FormatLastError()
//      DebugMessage()
//      DebugMsg()
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include <DEBUG.CPP>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "wmarkui.h"
#include "debug.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));
            ghInstance = hInst;
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}


}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\fdevmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	fDevmode.cpp
//    
//
//  PURPOSE:  Place holder file for devmode functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "wmarkui.h"
#include <DEVMODE.CPP>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\globals.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Globals.cpp
//    
//
//  PURPOSE:  File that contains all the globals.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//
#define _GLOBALS_H

#include "precomp.h"
#include "wmarkui.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
HINSTANCE   ghInstance = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\intrface.cpp ===
/*++

Copyright (c) 1996-2003  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows 2000, Windows XP, Windows Server 2003

Revision History:

              Created it.

--*/

#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "wmarkui.h"
#include "debug.h"
#include "intrface.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks



////////////////////////////////////////////////////////////////////////////////
//
// IWaterMarkUI body
//
HRESULT __stdcall IWaterMarkUI::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE(DLLTEXT("IWaterMarkUI:QueryInterface entry.\r\n\r\n")); 
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE(DLLTEXT("IWaterMarkUI:Return pointer to IUnknown.\r\n\r\n")); 
    }
    else if (iid == IID_IPrintOemUI)
    {
        *ppv = static_cast<IPrintOemUI*>(this) ;
        VERBOSE(DLLTEXT("IWaterMarkUI:Return pointer to IPrintOemUI.\r\n")); 
    }
    else
    {
#if DBG
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        VERBOSE(DLLTEXT("IWaterMarkUI::QueryInterface %s not supported.\r\n"), szOutput); 
#endif
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IWaterMarkUI::AddRef()
{
    VERBOSE(DLLTEXT("IWaterMarkUI:AddRef entry.\r\n")); 
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IWaterMarkUI::Release() 
{
    VERBOSE(DLLTEXT("IWaterMarkUI:Release entry.\r\n")); 
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}

HRESULT __stdcall IWaterMarkUI::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:PublishDriverInterface entry.\r\n")); 

    // Don't use the DriverInterface, so don't store it.

    return S_OK;
}

HRESULT __stdcall IWaterMarkUI::GetInfo(
    DWORD  dwMode,
    PVOID  pBuffer,
    DWORD  cbSize,
    PDWORD pcbNeeded)
{
    VERBOSE(DLLTEXT("IWaterMarkUI::GetInfo(%d) entry.\r\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        VERBOSE(DLLTEXT("IWaterMarkUI::GetInfo() exit pcbNeeded is NULL!\r\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size and number of bytes written.
    *pcbNeeded = sizeof(DWORD);

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        WARNING(DLLTEXT("IWaterMarkUI::GetInfo() exit insufficient buffer!\r\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = OEM_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = OEM_VERSION;
            break;

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            WARNING(DLLTEXT("IWaterMarkUI::GetInfo() exit mode not supported.\r\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IWaterMarkUI::GetInfo() exit S_OK, (*pBuffer is %#x).\r\r\n"), *(PDWORD)pBuffer);
    return S_OK;
}

HRESULT __stdcall IWaterMarkUI::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IWaterMarkUI:DevMode(%d, %#x) entry.\r\n"), dwMode, pOemDMParam); 

    return hrOEMDevMode(dwMode, pOemDMParam);
}

HRESULT __stdcall IWaterMarkUI::CommonUIProp(
    DWORD  dwMode,
    POEMCUIPPARAM   pOemCUIPParam)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:CommonUIProp entry.\r\n")); 

    return hrOEMPropertyPage(dwMode, pOemCUIPParam);
}


HRESULT __stdcall IWaterMarkUI::DocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:DocumentPropertySheets entry.\r\n")); 

    return E_NOTIMPL;
}

HRESULT __stdcall IWaterMarkUI::DevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:DevicePropertySheets entry.\r\n")); 

    return E_NOTIMPL;
}

HRESULT __stdcall IWaterMarkUI::DeviceCapabilities(
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:DeviceCapabilities entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IWaterMarkUI::DevQueryPrintEx(
    POEMUIOBJ               poemuiobj,
    PDEVQUERYPRINT_INFO     pDQPInfo,
    PDEVMODE                pPublicDM,
    PVOID                   pOEMDM)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:DevQueryPrintEx entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IWaterMarkUI::UpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:UpgradePrinter entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IWaterMarkUI::PrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:PrinterEvent entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IWaterMarkUI::DriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:DriverEvent entry.\r\n"));

    return E_NOTIMPL;
};


HRESULT __stdcall IWaterMarkUI::QueryColorProfile(
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulQueryMode,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData)
{ 
    VERBOSE(DLLTEXT("IWaterMarkUI:QueryColorProfile entry.\r\n"));

    return E_NOTIMPL;
};

HRESULT __stdcall IWaterMarkUI::FontInstallerDlgProc(
        HWND    hWnd,
        UINT    usMsg,
        WPARAM  wParam,
        LPARAM  lParam) 
{
    VERBOSE(DLLTEXT("IWaterMarkUI:FontInstallerDlgProc entry.\r\n"));

    return E_NOTIMPL;
};

HRESULT __stdcall IWaterMarkUI::UpdateExternalFonts(
        HANDLE  hPrinter,
        HANDLE  hHeap,
        PWSTR   pwstrCartridges)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:UpdateExternalFonts entry.\r\n"));

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
#if DBG
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        WARNING(DLLTEXT("IOemCF::QueryInterface %s not supported.\r\n"), szOutput); 
#endif
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
   ASSERT( 0 != m_cRef);
   ULONG cRef = InterlockedDecrement(&m_cRef);
   if (0 == cRef)
   {
      delete this;
        
   }
   return cRef;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IWaterMarkUI* pOemCB = new IWaterMarkUI ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }
    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Exported functions
//


// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    //
    // To avoid leaving OEM DLL still in memory when Unidrv or Pscript drivers 
    // are unloaded, Unidrv and Pscript driver ignore the return value of 
    // DllCanUnloadNow of the OEM DLL, and always call FreeLibrary on the OEMDLL.
    //
    // If OEM DLL spins off a working thread that also uses the OEM DLL, the 
    // thread needs to call LoadLibrary and FreeLibraryAndExitThread, otherwise 
    // it may crash after Unidrv or Pscript calls FreeLibrary.
    //

    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:Create class factory.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMUI)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wmarkui.rc
//
#define IDS_WATERMARK                   1
#define IDS_TEXT                        2
#define IDS_FONTSIZE                    3
#define IDS_ANGLE                       4
#define IDS_COLOR                       5
#define IDS_GRAY                        6
#define IDS_RED                         7
#define IDS_GREEN                       8
#define IDS_BLUE                        9

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\intrface.h ===
/*++

Copyright (c) 1996-2003  Microsoft Corporation

Module Name:

     comoem.h

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows 2000, Windows XP, Windows Server 2003

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// IWaterMarkUI
//
class IWaterMarkUI: public IPrintOemUI
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD  dwMode, PVOID  pBuffer, DWORD  cbSize,
                           PDWORD pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_  DWORD  dwMode, POEMDMPARAM pOemDMParam) ;

    //
    // OEMCommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_  
            DWORD  dwMode, 
            POEMCUIPPARAM   pOemCUIPParam
            );

    //
    // OEMDocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );

    //
    // OEMDevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );


    //
    // OEMDevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            );

    //
    // OEMDeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            );

    //
    // OEMUpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            );

    //
    // OEMPrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            );

    //
    // OEMDriverEvent
    //

    STDMETHOD(DriverEvent)(THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            );
 
    //
    // OEMQueryColorProfile
    //

    STDMETHOD( QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData);

    //
    // OEMFontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_ 
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            );
    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
            );


    IWaterMarkUI() { m_cRef = 1; };
    ~IWaterMarkUI() { };

protected:
    LONG                m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\wmarkui.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    WMarkUI.cpp
//    
//
//  PURPOSE:  Main file for OEM UI test module.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP, Windows Server 2003
//
//

#include "precomp.h"
#include "resource.h"
#include "debug.h"
#include "wmarkui.h"

// StrSafe.h needs to be included last
// to disallow bad string functions.
#include <STRSAFE.H>



////////////////////////////////////////////////////////
//      INTERNAL MACROS and DEFINES
////////////////////////////////////////////////////////



////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

LONG APIENTRY OEMUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems);
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams);
static DWORD FontSizeToIndex(DWORD dwFontSize);
static DWORD FontIndexToSize(DWORD dwIndex);
static DWORD TextColorToIndex(COLORREF crTextColor);
static COLORREF IndexToTextColor(DWORD dwIndex);
static PTSTR GetStringResource(HANDLE hHeap, HMODULE hModule, UINT uResource);



////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM device or document property UI.
//
HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    HRESULT hResult = S_OK;


    VERBOSE(DLLTEXT("hrOEMPropertyPage(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (OEMCUIP_DOCPROP != dwMode)
        &&
        (OEMCUIP_PRNPROP != dwMode)        
      )
    {
        ERR(ERRORTEXT("hrOEMPropertyPage() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOEMUIParam = %#lx.\r\n"), dwMode, pOEMUIParam);

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        case OEMCUIP_DOCPROP:
            hResult = hrDocumentPropertyPage(dwMode, pOEMUIParam);
            break;

        case OEMCUIP_PRNPROP:
            // Don't have any Printer Proptery UI.
            hResult = E_NOTIMPL;
            break;

        default:
            // Should never reach this!
            ERR(ERRORTEXT("hrOEMPropertyPage() Invalid dwMode, %d"), dwMode);
            SetLastError(ERROR_INVALID_PARAMETER);
            hResult = E_FAIL;
            break;
    }

    return hResult;
}

////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM device or document property UI.
//
LONG APIENTRY OEMUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            // Store OptItems state in DEVMODE.
            pOEMDev->bEnabled = !pOEMUIParam->pOEMOptItems[0].Sel;
            if(FAILED(StringCbCopyW(pOEMDev->szWaterMark, sizeof(pOEMDev->szWaterMark), (LPWSTR)pOEMUIParam->pOEMOptItems[1].pSel)))
            {
                ERR(ERRORTEXT("OEMUICallBack() failed to copy water mark text %s\r\n"), pOEMDev->szWaterMark);
            }
            pOEMDev->dwFontSize = FontIndexToSize(pOEMUIParam->pOEMOptItems[2].Sel);
            pOEMDev->dfRotate = (DOUBLE) pOEMUIParam->pOEMOptItems[3].Sel;
            pOEMDev->crTextColor = IndexToTextColor(pOEMUIParam->pOEMOptItems[4].Sel);
            break;

        default:
            break;
    }

    return lReturn;
}


////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM document property UI.
//
static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM document property UI.
        pOEMUIParam->cOEMOptItems = 5;

        VERBOSE(DLLTEXT("hrDocumentPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else if(dwMode == OEMCUIP_DOCPROP)
    {
        POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


        VERBOSE(DLLTEXT("hrDocumentPropertyPage() fill out items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMUICallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // Water Mark Section Name.
        pOEMUIParam->pOEMOptItems[0].Level = 1;
        pOEMUIParam->pOEMOptItems[0].Flags = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].pName = GetStringResource(pOEMUIParam->hOEMHeap, ghInstance, IDS_WATERMARK);
        pOEMUIParam->pOEMOptItems[0].Sel = pOEMDev->bEnabled ? 0 : 1;

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

        pOEMUIParam->pOEMOptItems[0].pOptType->Type = TVOT_COMBOBOX;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[0].pData = L"Enabled";
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[0].IconID = IDI_CPSUI_ON;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].pData = L"Disabled";
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID = IDI_CPSUI_OFF;


        // WaterMark Text.
        pOEMUIParam->pOEMOptItems[1].Level = 2;
        pOEMUIParam->pOEMOptItems[1].Flags = 0;
        pOEMUIParam->pOEMOptItems[1].pName = GetStringResource(pOEMUIParam->hOEMHeap, ghInstance, IDS_TEXT);
        pOEMUIParam->pOEMOptItems[1].pSel = (LPTSTR) HeapAlloc(pOEMUIParam->hOEMHeap, HEAP_ZERO_MEMORY, MAX_PATH * sizeof(WCHAR));
        if(FAILED(StringCbCopyW((LPWSTR)pOEMUIParam->pOEMOptItems[1].pSel, MAX_PATH * sizeof(WCHAR), pOEMDev->szWaterMark)))
        {
            ERR(ERRORTEXT("hrDocumentPropertyPage() failed to copy water mark text %s\r\n"), pOEMDev->szWaterMark);
        }

        pOEMUIParam->pOEMOptItems[1].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

        pOEMUIParam->pOEMOptItems[1].pOptType->Type = TVOT_EDITBOX;
        pOEMUIParam->pOEMOptItems[1].pOptType->pOptParam[1].IconID = sizeof(((POEMDEV)NULL)->szWaterMark)/sizeof(WCHAR);


        // WaterMark Font Size.
        pOEMUIParam->pOEMOptItems[2].Level = 2;
        pOEMUIParam->pOEMOptItems[2].Flags = 0;
        pOEMUIParam->pOEMOptItems[2].pName = GetStringResource(pOEMUIParam->hOEMHeap, ghInstance, IDS_FONTSIZE);
        pOEMUIParam->pOEMOptItems[2].Sel = FontSizeToIndex(pOEMDev->dwFontSize);

        pOEMUIParam->pOEMOptItems[2].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 16);

        pOEMUIParam->pOEMOptItems[2].pOptType->Type = TVOT_COMBOBOX;
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[0].pData = L"8";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[1].pData = L"9";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[2].pData = L"10";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[3].pData = L"11";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[4].pData = L"12";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[5].pData = L"14";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[6].pData = L"16";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[7].pData = L"18";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[8].pData = L"20";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[9].pData = L"22";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[10].pData = L"24";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[11].pData = L"26";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[12].pData = L"28";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[13].pData = L"36";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[14].pData = L"48";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[15].pData = L"72";


        // WaterMark Angle.
        pOEMUIParam->pOEMOptItems[3].Level = 2;
        pOEMUIParam->pOEMOptItems[3].Flags = 0;
        pOEMUIParam->pOEMOptItems[3].pName = GetStringResource(pOEMUIParam->hOEMHeap, ghInstance, IDS_ANGLE);
        pOEMUIParam->pOEMOptItems[3].Sel = (LONG) pOEMDev->dfRotate;

        pOEMUIParam->pOEMOptItems[3].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

        pOEMUIParam->pOEMOptItems[3].pOptType->Type = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[3].pOptType->pOptParam[1].IconID = 0;
        pOEMUIParam->pOEMOptItems[3].pOptType->pOptParam[1].lParam = 360;


        // WaterMark Color.
        pOEMUIParam->pOEMOptItems[4].Level = 2;
        pOEMUIParam->pOEMOptItems[4].Flags = 0;
        pOEMUIParam->pOEMOptItems[4].pName = GetStringResource(pOEMUIParam->hOEMHeap, ghInstance, IDS_COLOR);
        pOEMUIParam->pOEMOptItems[4].Sel = TextColorToIndex(pOEMDev->crTextColor);

        pOEMUIParam->pOEMOptItems[4].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 4);

        pOEMUIParam->pOEMOptItems[4].pOptType->Type = TVOT_COMBOBOX;
        pOEMUIParam->pOEMOptItems[4].pOptType->pOptParam[0].pData = GetStringResource(pOEMUIParam->hOEMHeap, ghInstance, IDS_GRAY);
        pOEMUIParam->pOEMOptItems[4].pOptType->pOptParam[1].pData = GetStringResource(pOEMUIParam->hOEMHeap, ghInstance, IDS_RED);
        pOEMUIParam->pOEMOptItems[4].pOptType->pOptParam[2].pData = GetStringResource(pOEMUIParam->hOEMHeap, ghInstance, IDS_GREEN);
        pOEMUIParam->pOEMOptItems[4].pOptType->pOptParam[3].pData = GetStringResource(pOEMUIParam->hOEMHeap, ghInstance, IDS_BLUE);
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems.
//
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems)
{
    VERBOSE(DLLTEXT("InitOptItems() entry.\r\n"));

    // Zero out memory.
    memset(pOptItems, 0, sizeof(OPTITEM) * dwOptItems);

    // Set each OptItem's size, and Public DM ID.
    for(DWORD dwCount = 0; dwCount < dwOptItems; dwCount++)
    {
        pOptItems[dwCount].cbSize = sizeof(OPTITEM);
        pOptItems[dwCount].DMPubID = DMPUB_NONE;
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// Allocates and initializes OptType for OptItem.
//
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams)
{
    POPTTYPE    pOptType = NULL;


    VERBOSE(DLLTEXT("CreateOptType() entry.\r\n"));

    // Allocate memory from the heap for the OPTTYPE; the driver will take care of clean up.
    pOptType = (POPTTYPE) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTTYPE));
    if(NULL != pOptType)
    {
        // Initialize OPTTYPE.
        pOptType->cbSize = sizeof(OPTTYPE);
        pOptType->Count = wOptParams;

        // Allocate memory from the heap for the OPTPARAMs for the OPTTYPE.
        pOptType->pOptParam = (POPTPARAM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, wOptParams * sizeof(OPTPARAM));
        if(NULL != pOptType->pOptParam)
        {
            // Initialize the OPTPARAMs.
            for(WORD wCount = 0; wCount < wOptParams; wCount++)
            {
                pOptType->pOptParam[wCount].cbSize = sizeof(OPTPARAM);
            }
        }
        else
        {
            ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTPARAMs!\r\n"));

            // Free allocated memory and return NULL.
            HeapFree(hHeap, 0, pOptType);
            pOptType = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTTYPE!\r\n"));
    }

    return pOptType;
}

////////////////////////////////////////////////////////////////////////////////
//
// Converts Font point size to index in combo box.
//
static DWORD FontSizeToIndex(DWORD dwFontSize)
{
    DWORD   dwIndex;


    switch(dwFontSize)
    {
        case 8:
            dwIndex = 0;
            break;

        case 9:
            dwIndex = 1;
            break;

        case 10:
            dwIndex = 2;
            break;

        case 11:
            dwIndex = 3;
            break;

        case 12:
            dwIndex = 4;
            break;

        case 14:
            dwIndex = 5;
            break;

        case 16:
            dwIndex = 6;
            break;

        case 18:
            dwIndex = 7;
            break;

        case 20:
            dwIndex = 8;
            break;

        case 22:
            dwIndex = 9;
            break;

        case 24:
            dwIndex = 10;
            break;

        case 26:
            dwIndex = 11;
            break;

        default:
        case 28:
            dwIndex = 12;
            break;

        case 36:
            dwIndex = 13;
            break;

        case 48:
            dwIndex = 14;
            break;

        case 72:
            dwIndex = 15;
            break;
    }


    return dwIndex;
}


////////////////////////////////////////////////////////////////////////////////
//
// Converts Font combo box index to font point size.
//
static DWORD FontIndexToSize(DWORD dwIndex)
{
    DWORD   dwFontSize;


    switch(dwIndex)
    {
        case 0:
            dwFontSize = 8;
            break;

        case 1:
            dwFontSize = 9;
            break;

        case 2:
            dwFontSize = 10;
            break;

        case 3:
            dwFontSize = 11;
            break;

        case 4:
            dwFontSize = 12;
            break;

        case 5:
            dwFontSize = 14;
            break;

        case 6:
            dwFontSize = 16;
            break;

        case 7:
            dwFontSize = 18;
            break;

        case 8:
            dwFontSize = 20;
            break;

        case 9:
            dwFontSize = 22;
            break;

        case 10:
            dwFontSize = 24;
            break;

        case 11:
            dwFontSize = 26;
            break;

        case 12:
            dwFontSize = 28;
            break;

        case 13:
            dwFontSize = 36;
            break;

        case 14:
            dwFontSize = 48;
            break;

        case 15:
            dwFontSize = 72;
            break;
    }

    return dwFontSize;
}


////////////////////////////////////////////////////////////////////////////////
//
// Converts text color to combo box index.
//
static DWORD TextColorToIndex(COLORREF crTextColor)
{
    DWORD   dwIndex;


    // The color is what ever color is dominate.  If none are, then it is gray.
    if( (GetRValue(crTextColor) > GetGValue(crTextColor))
        &&
        (GetGValue(crTextColor) >= GetBValue(crTextColor))
      )
    {
        // Set index to red.
        dwIndex = 1;
    }
    else if( (GetRValue(crTextColor) < GetGValue(crTextColor))
             &&
             (GetGValue(crTextColor) > GetBValue(crTextColor))
            )
    {
        // Set index to green.
        dwIndex = 2;
    }
    else if( (GetRValue(crTextColor) <= GetGValue(crTextColor))
             &&
             (GetGValue(crTextColor) < GetBValue(crTextColor))
            )
    {
        // Set index to blue.
        dwIndex = 3;
    }
    else
    {
        // Set index to gray.
        dwIndex = 0;
    }

    return dwIndex;
}

////////////////////////////////////////////////////////////////////////////////
//
// Converts text combo box index to text color.
//
static COLORREF IndexToTextColor(DWORD dwIndex)
{
    COLORREF    crTextColor;

    // Map index to desired text color.
    // We just support 4 colors in the UI: Red, Green, Blue, and gray.
    // The rendering module is capable of using any color for the Water Mark Text.
    switch(dwIndex)
    {
        case 1:
            // Color is red.
            crTextColor = RGB(255, 216, 216);
            break;

        case 2:
            // Color is green.
            crTextColor = RGB(216, 255, 216);
            break;

        case 3:
            // Color is blue.
            crTextColor = RGB(216, 216, 255);
            break;

        default:
        case 0:
            // Color is gray.
            crTextColor = WATER_MARK_DEFAULT_COLOR;
            break;
    }

    return crTextColor;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Retrieves pointer to a String resource.
//
static PTSTR GetStringResource(HANDLE hHeap, HMODULE hModule, UINT uResource)
{
    int     nResult;
    DWORD   dwSize = MAX_PATH;
    PTSTR   pszString = NULL;


    VERBOSE(DLLTEXT("GetStringResource() entered.\r\n"));

    // Allocate buffer for string resource from heap; let the driver clean it up.
    pszString = (PTSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize * sizeof(TCHAR));
    if(NULL != pszString)
    {
        PTSTR   pTemp;

        // Load string resource; resize after loading so as not to waste memory.
        nResult = LoadString(hModule, uResource, pszString, dwSize);
        pTemp = (PTSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, pszString, (nResult + 1) * sizeof(TCHAR));
        if(NULL != pTemp)
        {
            pszString = pTemp;
        }
    }
    else
    {
        ERR(ERRORTEXT("GetStringResource() failed to allocate string buffer!\r\n"));
    }

    return pszString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif



// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
#include <WINDDI.H>
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRSHT.H>
#include <COMPSTUI.H>
#include "WINDDIUI.H"
#include <PRINTOEM.H>

// Define from ntdef.h in Win2K SDK.
// NT 4 may not have this defined
// in the public headers.
#ifndef NOP_FUNCTION
  #if (_MSC_VER >= 1210)
    #define NOP_FUNCTION __noop
  #else
    #define NOP_FUNCTION (void)0
  #endif
#endif

#define COUNTOF(p)  (sizeof(p)/sizeof(*(p)))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\wmarkui.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	WMarkUI.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for WaterMark UI.
//
//  PLATFORMS:
//    Windows 2000, Windows XP, Windows Server 2003
//
//
#ifndef _WMARKUI_H
#define _WMARKUI_H

#include <OEM.H>
#include <DEVMODE.H>
#include "globals.h"


////////////////////////////////////////////////////////
//      OEM UI Defines
////////////////////////////////////////////////////////


// OEM Signature and version.
#define PROP_TITLE      L"WaterMark UI Page"
#define DLLTEXT(s)      TEXT("WMARKUI:  ") TEXT(s)

// OEM UI Misc defines.
#define ERRORTEXT(s)    TEXT("ERROR ") DLLTEXT(s)


////////////////////////////////////////////////////////
//      Prototypes
////////////////////////////////////////////////////////

HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\dm.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dm.c

Abstract:

    Devmode related functions used by the driver UI.

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/05/97 -davidx-
        Rewrote it to support OEM plugins among other things.

    07/17/96 -amandan-
        Created it.

--*/


#include "precomp.h"



//
// This is the devmode version 320 (DM_SPECVERSION)
//

#define DM_SPECVERSION320   0x0320
#define DM_SPECVERSION400   0x0400
#define DM_SPECVERSION401   0x0401
#define DM_SPECVER_BASE     DM_SPECVERSION320

#define CCHDEVICENAME320   32
#define CCHFORMNAME320     32

typedef struct _DEVMODE320 {

    WCHAR   dmDeviceName[CCHDEVICENAME320];
    WORD    dmSpecVersion;
    WORD    dmDriverVersion;
    WORD    dmSize;
    WORD    dmDriverExtra;
    DWORD   dmFields;
    short   dmOrientation;
    short   dmPaperSize;
    short   dmPaperLength;
    short   dmPaperWidth;
    short   dmScale;
    short   dmCopies;
    short   dmDefaultSource;
    short   dmPrintQuality;
    short   dmColor;
    short   dmDuplex;
    short   dmYResolution;
    short   dmTTOption;
    short   dmCollate;
    WCHAR   dmFormName[CCHFORMNAME320];
    WORD    dmLogPixels;
    DWORD   dmBitsPerPel;
    DWORD   dmPelsWidth;
    DWORD   dmPelsHeight;
    DWORD   dmDisplayFlags;
    DWORD   dmDisplayFrequency;

} DEVMODE320, *PDEVMODE320;

typedef struct _DMEXTRA400 {

    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmICCManufacturer;
    DWORD  dmICCModel;

} DMEXTRA400;

typedef struct _DMEXTRA401 {

    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;

} DMEXTRA401;

#define DM_SIZE320  sizeof(DEVMODE320)
#define DM_SIZE400  (DM_SIZE320 + sizeof(DMEXTRA400))
#define DM_SIZE401  (DM_SIZE400 + sizeof(DMEXTRA401))


VOID
VPatchPublicDevmodeVersion(
    IN OUT PDEVMODE pdm
    )

/*++

Routine Description:

    Patch dmSpecVersion field of the input devmode
    based on its dmSize information

Arguments:

    pdm - Specifies a devmode to be version-checked

Return Value:

    NONE

--*/

{
    ASSERT(pdm != NULL);

    //
    // Check against known devmode sizes
    //

    switch (pdm->dmSize)
    {
    case DM_SIZE320:
        pdm->dmSpecVersion = DM_SPECVERSION320;
        break;

    case DM_SIZE400:
        pdm->dmSpecVersion = DM_SPECVERSION400;
        break;

    case DM_SIZE401:
        pdm->dmSpecVersion = DM_SPECVERSION401;
        break;
    }
}



VOID
VSimpleConvertDevmode(
    IN PDEVMODE     pdmIn,
    IN OUT PDEVMODE pdmOut
    )

/*++

Routine Description:

    Simple-minded devmode conversion function.

Arguments:

    pdmIn - Points to an input devmode
    pdmOut - Points to an initialized and valid output devmode

Return Value:

    NONE

Notes:

    This function only relies on values of these 4 fields in pdmOut:
      dmSpecVersion
      dmDriverVersion
      dmSize
      dmDriverExtra

    All other fields in pdmOut are ignored and zero-filled before
    any memory copy occurs.

--*/

{
    WORD    wSpecVersion, wDriverVersion;
    WORD    wSize, wDriverExtra;

    ASSERT(pdmIn != NULL && pdmOut != NULL);

    //
    // Copy public devmode fields
    //

    wSpecVersion = pdmOut->dmSpecVersion;
    wDriverVersion = pdmOut->dmDriverVersion;
    wSize = pdmOut->dmSize;
    wDriverExtra = pdmOut->dmDriverExtra;

    ZeroMemory(pdmOut, wSize+wDriverExtra);
    CopyMemory(pdmOut, pdmIn, min(wSize, pdmIn->dmSize));

    pdmOut->dmSpecVersion = wSpecVersion;
    pdmOut->dmDriverVersion = wDriverVersion;
    pdmOut->dmSize = wSize;
    pdmOut->dmDriverExtra = wDriverExtra;

    //
    // Copy private devmode fields
    //

    CopyMemory((PBYTE) pdmOut + pdmOut->dmSize,
               (PBYTE) pdmIn + pdmIn->dmSize,
               min(wDriverExtra, pdmIn->dmDriverExtra));

    VPatchPublicDevmodeVersion(pdmOut);
}


/*++

Routine Name:

    VSmartConvertDevmode

Routine Description:

    Smart devmode conversion function for CDM_CONVERT. It strictly obeys
    the pdmOut's devmode framework (public, fixed-size core private, each
    plugin devmode), and do the best to convert data from pdmIn into that
    framework. It guarantees that pdmIn's data from a certain section only
    goes into the same section in pdmOut, i.e. pdmIn's core private devmode
    data won't overrun into pdmOut's plugin devmode section.

    Compared with VSimpleConvertDevmode, this function doesn't change the
    size of any private devmode section in the original pdmOut. This includes
    the sizes of: fixed-size core private devmode and each individual OEM
    plugin devmode.

Arguments:

    pdmIn - Points to an input devmode
    pdmOut - Points to an initialized and valid output devmode

Return Value:

    NONE

Note:

   These size/version fields are preserved in pdmOut:

   dmSpecVersion
   dmDriverVersion
   dmSize
   dmDriverExtra
   wSize
   wOEMExtra
   wVer
   each individual OEM plugin's OEM_DMEXTRAHEADER
      dwSize
      dwSignature
      dwVersion

--*/
VOID
VSmartConvertDevmode(
    IN PDEVMODE     pdmIn,
    IN OUT PDEVMODE pdmOut
    )
{
    PDRIVEREXTRA  pdmPrivIn, pdmPrivOut;
    WORD    wSpecVersion, wDriverVersion;
    WORD    wSize, wDriverExtra;
    WORD    wCoreFixIn, wOEMExtraIn;
    WORD    wCoreFixOut, wOEMExtraOut, wVerOut;
    BOOL    bMSdm500In = FALSE, bMSdm500Out = FALSE;

    ASSERT(pdmIn != NULL && pdmOut != NULL);

    //
    // First let's determine the version of pdmIn/pdmOut.
    //
    pdmPrivIn = (PDRIVEREXTRA)GET_DRIVER_PRIVATE_DEVMODE(pdmIn);
    pdmPrivOut = (PDRIVEREXTRA)GET_DRIVER_PRIVATE_DEVMODE(pdmOut);

    if (pdmIn->dmDriverVersion >= gDriverDMInfo.dmDriverVersion500 &&
        pdmIn->dmDriverExtra >= gDriverDMInfo.dmDriverExtra500 &&
        pdmPrivIn->dwSignature == gdwDriverDMSignature)
    {
        wCoreFixIn = pdmPrivIn->wSize;
        wOEMExtraIn = pdmPrivIn->wOEMExtra;

        if ((wCoreFixIn >= gDriverDMInfo.dmDriverExtra500) &&
            ((wCoreFixIn + wOEMExtraIn) <= pdmIn->dmDriverExtra))
        {
            bMSdm500In = TRUE;
        }
    }

    if (pdmOut->dmDriverVersion >= gDriverDMInfo.dmDriverVersion500 &&
        pdmOut->dmDriverExtra >= gDriverDMInfo.dmDriverExtra500 &&
        pdmPrivOut->dwSignature == gdwDriverDMSignature)
    {
        wCoreFixOut = pdmPrivOut->wSize;
        wOEMExtraOut = pdmPrivOut->wOEMExtra;

        if ((wCoreFixOut >= gDriverDMInfo.dmDriverExtra500) &&
            ((wCoreFixOut + wOEMExtraOut) <= pdmOut->dmDriverExtra))
        {
            wVerOut = pdmPrivOut->wVer;
            bMSdm500Out = TRUE;
        }
    }

    if (!bMSdm500In || !bMSdm500Out)
    {
        //
        // For unknown devmode or MS pre-v5 devmode, there is no
        // complexity caused by plugin devmodes, so we will just
        // call the simple convert function.
        //
        VSimpleConvertDevmode(pdmIn, pdmOut);
        return;
    }

    //
    // Copy public devmode fields
    //
    wSpecVersion = pdmOut->dmSpecVersion;
    wDriverVersion = pdmOut->dmDriverVersion;
    wSize = pdmOut->dmSize;
    wDriverExtra = pdmOut->dmDriverExtra;

    ZeroMemory(pdmOut, wSize);
    CopyMemory(pdmOut, pdmIn, min(wSize, pdmIn->dmSize));

    pdmOut->dmSpecVersion = wSpecVersion;
    pdmOut->dmDriverVersion = wDriverVersion;
    pdmOut->dmSize = wSize;
    pdmOut->dmDriverExtra = wDriverExtra;

    VPatchPublicDevmodeVersion(pdmOut);

    //
    // Copy private devmode fields section by section
    //
    // 1. First copy the fixed-size core section
    //
    ZeroMemory(pdmPrivOut, wCoreFixOut);
    CopyMemory(pdmPrivOut, pdmPrivIn, min(wCoreFixIn, wCoreFixOut));

    //
    // Restore the size/version fields in core private devmode of pdmOut
    //
    pdmPrivOut->wSize = wCoreFixOut;
    pdmPrivOut->wOEMExtra = wOEMExtraOut;
    pdmPrivOut->wVer = wVerOut;

    //
    // 2. Then copy any OEM plugin devmodes
    //
    // If pdmOut has no plugin devmodes, then we have no room to copy pdmIn's.
    //
    // If pdmIn has no plugin devmode, then we have nothing to copy, so we will
    // just leave pdmOut's unchanged.
    //
    // So we only have work to do if both pdmIn and pdmOut have plugin devmodes.
    //
    if (wOEMExtraIn > 0 && wOEMExtraOut > 0)
    {
        POEM_DMEXTRAHEADER  pOemDMIn, pOemDMOut;

        pOemDMIn = (POEM_DMEXTRAHEADER) ((PBYTE)pdmPrivIn + wCoreFixIn);
        pOemDMOut = (POEM_DMEXTRAHEADER) ((PBYTE)pdmPrivOut + wCoreFixOut);

        //
        // Make sure both in and out plugin devmodes blocks are valid before
        // we do the conversion. Otherwise, we will leave pdmOut plugin devmodes
        // unchanged.
        //
        if (bIsValidPluginDevmodes(pOemDMIn, (LONG)wOEMExtraIn) &&
            bIsValidPluginDevmodes(pOemDMOut, (LONG)wOEMExtraOut))
        {
            LONG  cbInSize = (LONG)wOEMExtraIn;
            LONG  cbOutSize = (LONG)wOEMExtraOut;

            while (cbInSize > 0 && cbOutSize > 0)
            {
                OEM_DMEXTRAHEADER  OemDMHdrIn, OemDMHdrOut;

                //
                // Copy headers into local buffers
                //
                CopyMemory(&OemDMHdrIn, pOemDMIn, sizeof(OEM_DMEXTRAHEADER));
                CopyMemory(&OemDMHdrOut, pOemDMOut, sizeof(OEM_DMEXTRAHEADER));

                if (OemDMHdrIn.dwSize > sizeof(OEM_DMEXTRAHEADER) &&
                    OemDMHdrOut.dwSize > sizeof(OEM_DMEXTRAHEADER))
                {
                    //
                    // Zero-fill, then copy over the plugin devmode portion after
                    // the header structure. Notice that the header structure in
                    // pOemDMOut is unchanged.
                    //
                    ZeroMemory((PBYTE)pOemDMOut + sizeof(OEM_DMEXTRAHEADER),
                               OemDMHdrOut.dwSize - sizeof(OEM_DMEXTRAHEADER));

                    CopyMemory((PBYTE)pOemDMOut + sizeof(OEM_DMEXTRAHEADER),
                               (PBYTE)pOemDMIn + sizeof(OEM_DMEXTRAHEADER),
                               min(OemDMHdrOut.dwSize - sizeof(OEM_DMEXTRAHEADER),
                                   OemDMHdrIn.dwSize - sizeof(OEM_DMEXTRAHEADER)));
                }

                cbInSize -= OemDMHdrIn.dwSize;
                pOemDMIn = (POEM_DMEXTRAHEADER) ((PBYTE)pOemDMIn + OemDMHdrIn.dwSize);

                cbOutSize -= OemDMHdrOut.dwSize;
                pOemDMOut = (POEM_DMEXTRAHEADER) ((PBYTE)pOemDMOut + OemDMHdrOut.dwSize);
            }
        }
    }
}



BOOL
BConvertDevmodeOut(
    IN  PDEVMODE pdmSrc,
    IN  PDEVMODE pdmIn,
    OUT PDEVMODE pdmOut
    )

/*++

Routine Description:

    This function copy a source devmode to an output devmode buffer.
    It should be called by the driver just before the driver returns
    to the caller of DrvDocumentPropertySheets.

Arguments:

    pdmSrc - pointer to current version of src DEVMODE
    pdmIn - pointer to input devmode passed in by the app
    pdmOut - pointer to output buffer passed in by the app

Return Value:

    TRUE for success
    FALSE for failure.

Note:

    pdmOut is only the output buffer allocated by the application. It
    doesn't necessarily contain any valid devmode content, so we should
    not look at any of its fields.

--*/

{
    if (pdmOut == NULL)
    {
        RIP(("Output buffer is NULL.\n"));
        return FALSE;
    }

    //
    // Without an input devmode, we'll have to assume the output
    // devmode is big enough to hold our current devmode.
    //

    if (pdmIn == NULL)
    {
        CopyMemory(pdmOut, pdmSrc, pdmSrc->dmSize + pdmSrc->dmDriverExtra);
        return TRUE;
    }

    //
    // If an input devmode is provided, we make sure we don't copy
    // anything larger than the input devmode to the output devmode buffer.
    // So the private devmode size dmDriverExtra of pdmOut can only shrink
    // (when Src private devmode size is smaller), but it will never grow.
    //
    // This is really dumb because we may end up chopping off tail end of
    // public and private devmode fields. But it's neccesary to work with
    // ill-behaving apps out there.
    //

    if (pdmIn->dmSize < pdmSrc->dmSize)
    {
        pdmOut->dmSpecVersion = pdmIn->dmSpecVersion;
        pdmOut->dmSize        = pdmIn->dmSize;
    }
    else
    {
        pdmOut->dmSpecVersion = pdmSrc->dmSpecVersion;
        pdmOut->dmSize        = pdmSrc->dmSize;
    }

    if (pdmIn->dmDriverExtra < pdmSrc->dmDriverExtra)
    {
        pdmOut->dmDriverVersion = pdmIn->dmDriverVersion;
        pdmOut->dmDriverExtra   = pdmIn->dmDriverExtra;
    }
    else
    {
        pdmOut->dmDriverVersion = pdmSrc->dmDriverVersion;
        pdmOut->dmDriverExtra   = pdmSrc->dmDriverExtra;
    }

    VSimpleConvertDevmode(pdmSrc, pdmOut);
    return TRUE;
}



BOOL
DrvConvertDevMode(
    LPTSTR      pPrinterName,
    PDEVMODE    pdmIn,
    PDEVMODE    pdmOut,
    PLONG       pcbNeeded,
    DWORD       fMode
    )

/*++

Routine Description:

    This function convert the devmode from previous version.

Arguments:

    pPrinterName - pointer to printer name
    pdmIn - input devmode
    pdmOut - output devmode
    pcbNeeded - size of output buffer on input
                size of output devmode on output
    fMode - specifies functions to perform

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    PCOMMONINFO pci;
    DWORD       dwSize, dwError;

    VERBOSE(("DrvConvertDevMode: fMode = 0x%x\n", fMode));

    //
    // Sanity check: make sure pcbNeeded parameter is not NULL
    //

    if (pcbNeeded == NULL)
    {
        RIP(("pcbNeeded is NULL.\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    switch (fMode)
    {
    case CDM_CONVERT:

        //
        // Convert input devmode to output devmode
        // Note: OEM plugins are not involved here because
        // they can only convert input devmode to current
        // version, not between any versions.
        //

        if (pdmIn == NULL || pdmOut == NULL ||
            *pcbNeeded < pdmOut->dmSize + pdmOut->dmDriverExtra)
        {
            break;
        }

        VSmartConvertDevmode(pdmIn, pdmOut);
        *pcbNeeded = pdmOut->dmSize + pdmOut->dmDriverExtra;
        return TRUE;

    case CDM_CONVERT351:

        //
        // Convert input devmode to 3.51 version devmode
        // First check if the caller provided buffer is large enough
        //

        dwSize = DM_SIZE320 + gDriverDMInfo.dmDriverExtra351;

        if (*pcbNeeded < (LONG) dwSize || pdmOut == NULL)
        {
            *pcbNeeded = dwSize;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        //
        // Do the conversion from input devmode to 3.51 devmode
        //

        pdmOut->dmSpecVersion = DM_SPECVERSION320;
        pdmOut->dmSize = DM_SIZE320;
        pdmOut->dmDriverVersion = gDriverDMInfo.dmDriverVersion351;
        pdmOut->dmDriverExtra = gDriverDMInfo.dmDriverExtra351;

        VSimpleConvertDevmode(pdmIn, pdmOut);
        *pcbNeeded = dwSize;
        return TRUE;

    case CDM_DRIVER_DEFAULT:

        //
        // Get the driver default devmode.
        // We need to open a handle to the printer
        // and then load basic driver information.
        //

        dwError = ERROR_GEN_FAILURE;

        pci = PLoadCommonInfo(NULL,
                              pPrinterName,
                              FLAG_OPENPRINTER_NORMAL|FLAG_OPEN_CONDITIONAL);

        if (pci && BCalcTotalOEMDMSize(pci->hPrinter, pci->pOemPlugins, &dwSize))
        {
            dwSize += sizeof(DEVMODE) + gDriverDMInfo.dmDriverExtra;

            //
            // Check if the output buffer is big enough
            //

            if (*pcbNeeded < (LONG) dwSize || pdmOut == NULL)
                dwError = ERROR_INSUFFICIENT_BUFFER;
            else if (BFillCommonInfoDevmode(pci, NULL, NULL))
            {
                //
                // Get the driver default devmode and
                // copy it to the output buffer
                //

                CopyMemory(pdmOut, pci->pdm, dwSize);
                dwError = NO_ERROR;
            }

            *pcbNeeded = dwSize;
        }

        VFreeCommonInfo(pci);
        SetLastError(dwError);
        return (dwError == NO_ERROR);

    default:

        ERR(("Invalid fMode in DrvConvertDevMode: %d\n", fMode));
        break;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\docprop.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    docprop.c

Abstract:

    This file handles the DrvDocumentProperties and
    DrvDocumentPropertySheets spooler API

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/13/97 -davidx-
        Implement OEM plugin support.

    02/13/97 -davidx-
        Working only with options array internally.

    02/10/97 -davidx-
        Consistent handling of common printer info.

    02/04/97 -davidx-
        Reorganize driver UI to separate ps and uni DLLs.

    07/17/96 -amandan-
        Created it.

--*/

#include "precomp.h"

//
// Local and external function declarations
//

LONG LSimpleDocumentProperties( PDOCUMENTPROPERTYHEADER);
CPSUICALLBACK cpcbDocumentPropertyCallback(PCPSUICBPARAM);
BOOL BGetPageOrderFlag(PCOMMONINFO);
VOID VUpdateEmfFeatureItems(PUIDATA, BOOL);
VOID VUpdateBookletOption(PUIDATA , POPTITEM);

LONG
DrvDocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )

/*++

Routine Description:

    This function is called to add the Document Property Page to the specified
    property sheets and/or to update the document properties.

    If pPSUIInfo is NULL, it performs the operation specified by the fMode flag of
    DOCUMENTPROPERTYHEADER.  Specifically, if flMode is zero or pDPHdr->pdmOut
    is NULL, return the size of DEVMODE.

    If pPSUInfo is not NULL: pPSUIInf->Reason

    REASON_INIT- fills PCOMPROPSHEETUI with document UI items
                 calls compstui to add the page.

    REASON_GET_INFO_HEADER - fills out PROPSHEETUI_INFO.

    REASON_SET_RESULT - saves devmode settings and copy the devmode into output buffer.

    REASON_DESTROY - Cleans up.

Arguments:

    pSUIInfo - pointer to PPROPSHEETUI_INFO
    lParam - varies depending on the reason this function is called


Return Value:

    > 0 success <= 0 for failure

--*/

{
    PDOCUMENTPROPERTYHEADER pDPHdr;
    PCOMPROPSHEETUI         pCompstui;
    PUIDATA                 pUiData;
    PDLGPAGE                pDlgPage;
    LONG                    lRet;
    BOOL                    bResult=FALSE;

    //
    // Validate input parameters
    //

    if (! (pDPHdr = (PDOCUMENTPROPERTYHEADER) (pPSUIInfo ? pPSUIInfo->lParamInit : lParam)))
    {
        RIP(("DrvDocumentPropertySheets: invalid parameters\n"));
        return -1;
    }

    //
    // pPSUIInfo = NULL, the caller is spooler so just handle the simple case,
    // no display is necessary.
    //

    if (pPSUIInfo == NULL)
        return LSimpleDocumentProperties(pDPHdr);

    //
    // Create a UIDATA structure if necessary
    //

    if (pPSUIInfo->Reason == PROPSHEETUI_REASON_INIT)
    {
        pUiData = PFillUiData(pDPHdr->hPrinter,
                              pDPHdr->pszPrinterName,
                              pDPHdr->pdmIn,
                              MODE_DOCUMENT_STICKY);
    }
    else
        pUiData = (PUIDATA) pPSUIInfo->UserData;

    //
    // Validate pUiData
    //

    if (pUiData == NULL)
    {
        ERR(("UIDATA is NULL\n"));
        return -1;
    }

    ASSERT(VALIDUIDATA(pUiData));

    //
    // Handle various cases for which this function might be called
    //

    switch (pPSUIInfo->Reason)
    {
    case PROPSHEETUI_REASON_INIT:

        //
        // Allocate memory and partially fill out various data
        // structures required to call common UI routine.
        //

        pDlgPage = (pDPHdr->fMode & DM_ADVANCED) ?
                        CPSUI_PDLGPAGE_ADVDOCPROP :
                        CPSUI_PDLGPAGE_DOCPROP;

        pUiData->bPermission = ((pDPHdr->fMode & DM_NOPERMISSION) == 0);

        #ifdef PSCRIPT

        FOREACH_OEMPLUGIN_LOOP((&(pUiData->ci)))

            if (HAS_COM_INTERFACE(pOemEntry))
            {
                HRESULT hr;

                hr = HComOEMHideStandardUI(pOemEntry,
                                           OEMCUIP_DOCPROP);

                //
                // In the case when multiple plugins are chained, it doesn't
                // make sense for one plugin to hide standard UI when another
                // one still wants to use the standard UI. So as long as one
                // plugin returns S_OK here, we will hide the standard UI.
                //

                if (bResult = SUCCEEDED(hr))
                    break;
            }

        END_OEMPLUGIN_LOOP

        #endif // PSCRIPT

        if (bResult)
        {
            //
            // Set the flag to indicate plugin is hiding our standard
            // document property sheet UI.
            //

            pUiData->dwHideFlags |= HIDEFLAG_HIDE_STD_DOCPROP;

            pUiData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
            pUiData->hComPropSheet = pPSUIInfo->hComPropSheet;

            if (BAddOemPluginPages(pUiData, pDPHdr->fMode))
            {
                pPSUIInfo->UserData = (ULONG_PTR) pUiData;
                pPSUIInfo->Result = CPSUI_CANCEL;
                lRet = 1;
                break;
            }
        }
        else if (pCompstui = PPrepareDataForCommonUI(pUiData, pDlgPage))
        {
            #ifdef UNIDRV

                VMakeMacroSelections(pUiData, NULL);

            #endif

            pCompstui->pfnCallBack = cpcbDocumentPropertyCallback;
            pUiData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
            pUiData->hComPropSheet = pPSUIInfo->hComPropSheet;
            pUiData->pCompstui = pCompstui;

            //
            // Indicate which items are constrained
            //

            VPropShowConstraints(pUiData, MODE_DOCANDPRINTER_STICKY);

            //
            // Call common UI library to add our pages
            //

            if (pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                         CPSFUNC_ADD_PCOMPROPSHEETUI,
                                         (LPARAM) pCompstui,
                                         (LPARAM) &lRet) &&
                BAddOemPluginPages(pUiData, pDPHdr->fMode))
            {
                pPSUIInfo->UserData = (ULONG_PTR) pUiData;
                pPSUIInfo->Result = CPSUI_CANCEL;
                lRet = 1;
                break;
            }
        }

        //
        // Clean up in the case of error
        //

        ERR(("Failed to initialize property sheets\n"));
        VFreeUiData(pUiData);
        return  -1;

    case PROPSHEETUI_REASON_GET_INFO_HEADER:
        {
            PPROPSHEETUI_INFO_HEADER pPSUIHdr;
            DWORD                    dwIcon;

            pPSUIHdr = (PPROPSHEETUI_INFO_HEADER) lParam;
            pPSUIHdr->Flags = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
            pPSUIHdr->pTitle = pUiData->ci.pPrinterName;
            pPSUIHdr->hInst = ghInstance;

            //
            // Use the Icon specified in the binary data as
            // the printer icon.
            //

            dwIcon = pUiData->ci.pUIInfo->loPrinterIcon;

            if (dwIcon && (pPSUIHdr->IconID = HLoadIconFromResourceDLL(&pUiData->ci, dwIcon)))
                pPSUIHdr->Flags |= PSUIHDRF_USEHICON;
            else
                pPSUIHdr->IconID = _DwGetPrinterIconID();
        }

        lRet = 1;
        break;

    case PROPSHEETUI_REASON_SET_RESULT:

        //
        // Copy the new devmode back into the output buffer provided by the caller
        // Always return the smaller of current and input devmode
        //

        {
            PSETRESULT_INFO pSRInfo = (PSETRESULT_INFO) lParam;

            if ((pSRInfo->Result == CPSUI_OK) &&
                (pDPHdr->pdmOut != NULL) &&
                (pDPHdr->fMode & (DM_COPY | DM_UPDATE)))
            {
                PCOMMONINFO pci = (PCOMMONINFO)pUiData;

                //
                // CPSUICB_REASON_APPLYNOW may not have been called. If so, we need
                // to perform tasks that are usually done by CPSUICB_REASON_APPLYNOW
                // case in our callback function cpcbDocumentPropertyCallback.
                //

                if (!(pci->dwFlags & FLAG_APPLYNOW_CALLED))
                {
                    OPTSELECT OldCombinedOptions[MAX_COMBINED_OPTIONS];

                    //
                    // Save a copy the pre-resolve option array
                    //

                    CopyMemory(OldCombinedOptions,
                               pci->pCombinedOptions,
                               MAX_COMBINED_OPTIONS * sizeof(OPTSELECT));

                    //
                    // Call the parsers to resolve any remaining conflicts.
                    //

                    ResolveUIConflicts(pci->pRawData,
                                       pci->pCombinedOptions,
                                       MAX_COMBINED_OPTIONS,
                                       MODE_DOCANDPRINTER_STICKY);

                    //
                    // Update the OPTITEM list to match the updated options array
                    //

                    VUpdateOptItemList(pUiData, OldCombinedOptions, pci->pCombinedOptions);

                    //
                    // Transfer information from options array to public devmode fields
                    //

                    VOptionsToDevmodeFields(&pUiData->ci, FALSE);

                    //
                    // Separate the doc-sticky options from the combined array
                    // and save it back to the private devmode aOptions array
                    //

                    SeparateOptionArray(
                            pci->pRawData,
                            pci->pCombinedOptions,
                            PGetDevmodeOptionsArray(pci->pdm),
                            MAX_PRINTER_OPTIONS,
                            MODE_DOCUMENT_STICKY);
                }

                BConvertDevmodeOut(pci->pdm,
                                   pDPHdr->pdmIn,
                                   pDPHdr->pdmOut);
            }

            pPSUIInfo->Result = pSRInfo->Result;
        }

        lRet = 1;
        break;

    case PROPSHEETUI_REASON_DESTROY:

        //
        // Clean up
        //

        VFreeUiData(pUiData);
        lRet = 1;

        break;

    default:

        ERR(("Unknown reason in DrvDocumentPropertySheets\n"));
        return -1;
    }

    return lRet;
}



LONG
LSimpleDocumentProperties(
    IN  OUT PDOCUMENTPROPERTYHEADER pDPHdr
    )

/*++

Routine Description:

    Handle simple "Document Properties" where we don't need to display
    a dialog and therefore don't have to have common UI library involved
    Mainly, devmode handling - update, merge, copy etc.

Arguments:

    pDPHdr - Points to a DOCUMENTPROPERTYHEADER structure

Return Value:

    > 0 if successful, <= 0 otherwise

--*/

{
    PCOMMONINFO     pci;
    DWORD           dwSize;
    PPRINTER_INFO_2 pPrinterInfo2;

    //
    // Load common printer info
    //

    pci = PLoadCommonInfo(pDPHdr->hPrinter, pDPHdr->pszPrinterName, 0);

    if (!pci || !BCalcTotalOEMDMSize(pci->hPrinter, pci->pOemPlugins, &dwSize))
    {
        VFreeCommonInfo(pci);
        return -1;
    }

    //
    // Check if the caller is interested in the size only
    //

    pDPHdr->cbOut = sizeof(DEVMODE) + gDriverDMInfo.dmDriverExtra + dwSize;

    if (pDPHdr->fMode == 0 || pDPHdr->pdmOut == NULL)
    {
        VFreeCommonInfo(pci);
        return pDPHdr->cbOut;
    }

    //
    // Merge the input devmode with the driver and system default devmodes
    //

    if (! (pPrinterInfo2 = MyGetPrinter(pci->hPrinter, 2)) ||
        ! BFillCommonInfoDevmode(pci, pPrinterInfo2->pDevMode, pDPHdr->pdmIn))
    {
        MemFree(pPrinterInfo2);
        VFreeCommonInfo(pci);
        return -1;
    }

    MemFree(pPrinterInfo2);

    //
    // Copy the devmode back into the output buffer provided by the caller
    // Always return the smaller of current and input devmode
    //

    if (pDPHdr->fMode & (DM_COPY | DM_UPDATE))
        (VOID) BConvertDevmodeOut(pci->pdm, pDPHdr->pdmIn, pDPHdr->pdmOut);

    //
    // Clean up before returning to caller
    //

    VFreeCommonInfo(pci);
    return 1;
}



VOID
VRestoreDefaultFeatureSelection(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Restore the printer feature selections to their default state

Arguments:

    pUiData - Points to our UIDATA structure

Return Value:

    NONE

--*/

{
    POPTSELECT  pOptionsArray;
    PFEATURE    pFeature;
    POPTITEM    pOptItem;
    DWORD       dwCount, dwFeatureIndex, dwDefault;
    PUIINFO     pUIInfo;

    //
    // Go through each printer feature item and check to see if
    // its current selection matches the default value
    //

    pUIInfo = pUiData->ci.pUIInfo;
    pOptionsArray = pUiData->ci.pCombinedOptions;
    pOptItem = pUiData->pFeatureItems;
    dwCount = pUiData->dwFeatureItem;

    for ( ; dwCount--; pOptItem++)
    {
        pFeature = (PFEATURE) GETUSERDATAITEM(pOptItem->UserData);
        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);
        dwDefault = pFeature->dwDefaultOptIndex;

        //
        // If the current selection doesn't match the default,
        // restore it to the default value.
        //

        if (pOptionsArray[dwFeatureIndex].ubCurOptIndex != dwDefault)
        {
            pOptionsArray[dwFeatureIndex].ubCurOptIndex = (BYTE) dwDefault;
            pOptItem->Flags |= OPTIF_CHANGED;
            pOptItem->Sel = (dwDefault == OPTION_INDEX_ANY) ? 0 : dwDefault;
        }
    }

    //
    // Update the display and indicate which items are constrained
    //

    VPropShowConstraints(pUiData, MODE_DOCANDPRINTER_STICKY);
}



VOID
VOptionsToDevmodeFields(
    IN OUT PCOMMONINFO  pci,
    IN BOOL             bUpdateFormFields
    )

/*++

Routine Description:

     Convert options in pUiData->pOptionsArray into public devmode fields

Arguments:

     pci - Points to basic printer info
     bUpdateFormFields - Whether or not to convert paper size option into devmode

Return Value:

     None

--*/
{
    PFEATURE    pFeature;
    POPTION     pOption;
    DWORD       dwGID, dwFeatureIndex, dwOptionIndex;
    PUIINFO     pUIInfo;
    PDEVMODE    pdm;

    //
    // Go through all predefine IDs and propage the option selection
    // into appropriate devmode fields
    //

    pUIInfo = pci->pUIInfo;
    pdm = pci->pdm;

    for (dwGID=0 ; dwGID < MAX_GID ; dwGID++)
    {
        //
        // Get the feature to get the options, and get the index
        // into the option array
        //

        if ((pFeature = GET_PREDEFINED_FEATURE(pUIInfo, dwGID)) == NULL)
            continue;

        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);
        dwOptionIndex = pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex;

        //
        // Get the pointer to the option array for the feature
        //

        if ((pOption = PGetIndexedOption(pUIInfo, pFeature, dwOptionIndex)) == NULL)
            continue;

        switch(dwGID)
        {
        case GID_RESOLUTION:
        {
            PRESOLUTION pRes = (PRESOLUTION)pOption;

            //
            // Get to the option selected
            //

            pdm->dmFields |= (DM_PRINTQUALITY|DM_YRESOLUTION);
            pdm->dmPrintQuality = GETQUALITY_X(pRes);
            pdm->dmYResolution = GETQUALITY_Y(pRes);

        }
            break;

        case GID_DUPLEX:

            //
            // Get to the option selected
            //

            pdm->dmFields |= DM_DUPLEX;
            pdm->dmDuplex = (SHORT) ((PDUPLEX) pOption)->dwDuplexID;
            break;

        case GID_INPUTSLOT:

            //
            // Get to the option selected
            //

            pdm->dmFields |= DM_DEFAULTSOURCE;
            pdm->dmDefaultSource = (SHORT) ((PINPUTSLOT) pOption)->dwPaperSourceID;
            break;

        case GID_MEDIATYPE:

            //
            // Get to the option selected
            //

            pdm->dmFields |= DM_MEDIATYPE;
            pdm->dmMediaType = (SHORT) ((PMEDIATYPE) pOption)->dwMediaTypeID;
            break;

        case GID_ORIENTATION:

            if (((PORIENTATION) pOption)->dwRotationAngle == ROTATE_NONE)
                pdm->dmOrientation = DMORIENT_PORTRAIT;
            else
                pdm->dmOrientation = DMORIENT_LANDSCAPE;

            pdm->dmFields |= DM_ORIENTATION;
            break;

            //
            // Fix #2822: VOptionsToDevmodeFields should be called after calling
            // VFixOptionsArrayWithDevmode and ResolveUIConflicts, which could
            // change option array to be out of sync with devmode.
            //

        case GID_COLLATE:

            pdm->dmFields |= DM_COLLATE;
            pdm->dmCollate = (SHORT) ((PCOLLATE) pOption)->dwCollateID;
            break;

        case GID_PAGESIZE:
            {
                PPAGESIZE  pPageSize = (PPAGESIZE)pOption;
                WCHAR      awchBuf[CCHPAPERNAME];

                //
                // Ignore the custom page size option. We don't add custom page size option to the
                // form database, see BAddOrUpgradePrinterForms(). Also see BQueryPrintForm() for
                // special handling of custom page size for DDI DevQueryPrintEx().
                //

                if (pPageSize->dwPaperSizeID == DMPAPER_USER ||
                    pPageSize->dwPaperSizeID == DMPAPER_CUSTOMSIZE)
                {
                    VERBOSE(("VOptionsToDevmodeFields: %d ignored\n", pPageSize->dwPaperSizeID));
                    break;
                }

                //
                // bUpdateFormFields should be FALSE if we don't want to overwrite devmode form
                // fields with our option array's page size setting. One case of this is when
                // user hits the doc-setting UI's OK buttion, at that time we need to propagate
                // our internal devmode to app's output devmode. See cpcbDocumentPropertyCallback().
                // That's because in option array we could have already mapped devmode's form request
                // to a paper size the printer supports (example: devmode requets Legal, we map
                // it to the printer's form OEM_Legal). So we don't want to overwrite output devmode
                // form fields with our internal option.
                //

                if (!bUpdateFormFields)
                    break;

                if (!LOAD_STRING_PAGESIZE_NAME(pci, pPageSize, awchBuf, CCHPAPERNAME))
                {
                    ERR(("VOptionsToDevmodeFields: cannot get paper name\n"));
                    break;
                }

                pdm->dmFields &= ~(DM_PAPERWIDTH|DM_PAPERLENGTH|DM_PAPERSIZE);
                pdm->dmFields |= DM_FORMNAME;

                CopyString(pdm->dmFormName, awchBuf, CCHFORMNAME);

                if (!BValidateDevmodeFormFields(
                        pci->hPrinter,
                        pdm,
                        NULL,
                        pci->pSplForms,
                        pci->dwSplForms))
                {
                    VDefaultDevmodeFormFields(pUIInfo, pdm, IsMetricCountry());
                }
            }

            break;
        }
    }
}



CPSUICALLBACK
cpcbDocumentPropertyCallback(
    IN  OUT PCPSUICBPARAM pCallbackParam
    )

/*++

Routine Description:

    Callback function provided to common UI DLL for handling
    document properties dialog.

Arguments:

    pCallbackParam - Pointer to CPSUICBPARAM structure

Return Value:

    CPSUICB_ACTION_NONE - no action needed
    CPSUICB_ACTION_OPTIF_CHANGED - items changed and should be refreshed

--*/

{
    PUIDATA     pUiData;
    POPTITEM    pCurItem, pOptItem;
    LONG        lRet;
    PFEATURE    pFeature;

    pUiData = (PUIDATA) pCallbackParam->UserData;
    ASSERT(pUiData != NULL);

    pUiData->hDlg = pCallbackParam->hDlg;
    pCurItem = pCallbackParam->pCurItem;
    lRet = CPSUICB_ACTION_NONE;

    //
    // If user has no permission to change anything, then
    // simply return without taking any action.
    //

    if (!HASPERMISSION(pUiData) && (pCallbackParam->Reason != CPSUICB_REASON_ABOUT))
        return lRet;

    switch (pCallbackParam->Reason)
    {
    case CPSUICB_REASON_SEL_CHANGED:
    case CPSUICB_REASON_ECB_CHANGED:

        if (! IS_DRIVER_OPTITEM(pUiData, pCurItem))
            break;

        //
        // Everytime the user make any changes, we update the
        // pOptionsArray.  These settings are not saved to the devmode
        // until the user hit OK.
        //
        // VUnpackDocumentPropertiesItems saves the settings to pUiData->pOptionsArray
        // and update the private devmode flags if applicable.
        // ICheckConstraintsDlg check if the user has selected a constrained option
        //

        VUnpackDocumentPropertiesItems(pUiData, pCurItem, 1);

        #ifdef UNIDRV

        VSyncColorInformation(pUiData, pCurItem);

        //
        // Quality Macro support
        //

        if (GETUSERDATAITEM(pCurItem->UserData) == QUALITY_SETTINGS_ITEM ||
            GETUSERDATAITEM(pCurItem->UserData) == COLOR_ITEM ||
            GETUSERDATAITEM(pCurItem->UserData) == MEDIATYPE_ITEM ||
            ((pFeature = PGetFeatureFromItem(pUiData->ci.pUIInfo, pCurItem, NULL))&&
             pFeature->dwFlags & FEATURE_FLAG_UPDATESNAPSHOT))
        {
            VMakeMacroSelections(pUiData, pCurItem);

            //
            // Needs to update the constraints since Macro selection might have
            // changed the constraints
            //

            VPropShowConstraints(pUiData, MODE_DOCANDPRINTER_STICKY);
            VUpdateMacroSelection(pUiData, pCurItem);

        }
        else
        {
            //
            // Check whether the current selection invalidates the macros
            // and update QUALITY_SETTINGS_ITEM.

            VUpdateMacroSelection(pUiData, pCurItem);
        }

        #endif   // UNIDRV

        #ifdef PSCRIPT

        if (GETUSERDATAITEM(pCurItem->UserData) == REVPRINT_ITEM)
        {
            VSyncRevPrintAndOutputOrder(pUiData, pCurItem);
        }

        #endif // PSCRIPT

        if (GETUSERDATAITEM(pCurItem->UserData) == METASPOOL_ITEM ||
            GETUSERDATAITEM(pCurItem->UserData) == NUP_ITEM ||
            GETUSERDATAITEM(pCurItem->UserData) == REVPRINT_ITEM ||
            GETUSERDATAITEM(pCurItem->UserData) == COPIES_COLLATE_ITEM ||
            ((pFeature = PGetFeatureFromItem(pUiData->ci.pUIInfo, pCurItem, NULL)) &&
             pFeature->dwFeatureID == GID_OUTPUTBIN))
        {
            VUpdateEmfFeatureItems(pUiData, GETUSERDATAITEM(pCurItem->UserData) != METASPOOL_ITEM);
        }

        #ifdef UNIDRV

        VSyncColorInformation(pUiData, pCurItem);

        #endif

        #ifdef PSCRIPT

        //
        // If the user has selected custom page size,
        // bring up the custom page size dialog now.
        //

        if (GETUSERDATAITEM(pCurItem->UserData) == FORMNAME_ITEM &&
            pCurItem->pExtPush != NULL)
        {
            if (pUiData->pwPapers[pCurItem->Sel] == DMPAPER_CUSTOMSIZE)
            {
                (VOID) BDisplayPSCustomPageSizeDialog(pUiData);
                pCurItem->Flags &= ~(OPTIF_EXT_HIDE | OPTIF_EXT_DISABLED);
            }
            else
                pCurItem->Flags |= (OPTIF_EXT_HIDE | OPTIF_EXT_DISABLED);

            pCurItem->Flags |= OPTIF_CHANGED;
        }

        #endif // PSCRIPT

        //
        // Update the display and indicate which items are constrained.
        //

        VPropShowConstraints(pUiData, MODE_DOCANDPRINTER_STICKY);

        lRet = CPSUICB_ACTION_REINIT_ITEMS;


        break;

    case CPSUICB_REASON_ITEMS_REVERTED:

        //
        // Unpack document properties treeview items
        //

        VUnpackDocumentPropertiesItems(pUiData,
                                       pUiData->pDrvOptItem,
                                       pUiData->dwDrvOptItem);

        //
        // Update the display and indicate which items are constrained
        //

        VPropShowConstraints(pUiData, MODE_DOCANDPRINTER_STICKY);

        lRet = CPSUICB_ACTION_OPTIF_CHANGED;
        break;

    case CPSUICB_REASON_EXTPUSH:

        #ifdef PSCRIPT

        if (GETUSERDATAITEM(pCurItem->UserData) == FORMNAME_ITEM)
        {
            //
            // Push button to bring up PostScript custom page size dialog
            //

            (VOID) BDisplayPSCustomPageSizeDialog(pUiData);
        }

        #endif // PSCRIPT

        if (pCurItem == pUiData->pFeatureHdrItem)
        {
            //
            // Push button for restoring all generic feature selections
            // to their default values
            //

            VRestoreDefaultFeatureSelection(pUiData);
            lRet = CPSUICB_ACTION_REINIT_ITEMS;
        }
        break;


    case CPSUICB_REASON_ABOUT:

        DialogBoxParam(ghInstance,
                       MAKEINTRESOURCE(IDD_ABOUT),
                       pUiData->hDlg,
                       _AboutDlgProc,
                       (LPARAM) pUiData);
        break;


    case CPSUICB_REASON_APPLYNOW:

        pUiData->ci.dwFlags |= FLAG_APPLYNOW_CALLED;

        //
        // Check if there are still any unresolved constraints left?
        // BOptItemSelectionsChanged returns TRUE or FALSE depending on
        // whether the user has made any changes to the options
        //

        if (((pUiData->ci.dwFlags & FLAG_PLUGIN_CHANGED_OPTITEM) ||
             BOptItemSelectionsChanged(pUiData->pDrvOptItem, pUiData->dwDrvOptItem)) &&
            ICheckConstraintsDlg(pUiData,
                                 pUiData->pDrvOptItem,
                                 pUiData->dwDrvOptItem,
                                 TRUE) == CONFLICT_CANCEL)
        {
            //
            // Conflicts found and user clicked CANCEL to
            // go back to the dialog without dismissing it.
            //

            lRet = CPSUICB_ACTION_NO_APPLY_EXIT;
            break;
        }

        //
        // Transfer information from options array to public devmode fields
        //

        VOptionsToDevmodeFields(&pUiData->ci, FALSE);

        //
        // Separate the doc-sticky options from the combined array
        // and save it back to the private devmode aOptions array
        //

        SeparateOptionArray(
                pUiData->ci.pRawData,
                pUiData->ci.pCombinedOptions,
                PGetDevmodeOptionsArray(pUiData->ci.pdm),
                MAX_PRINTER_OPTIONS,
                MODE_DOCUMENT_STICKY);

        pCallbackParam->Result = CPSUI_OK;
        lRet = CPSUICB_ACTION_ITEMS_APPLIED ;
        break;
    }

    return LInvokeOemPluginCallbacks(pUiData, pCallbackParam, lRet);
}



BOOL
BPackItemFormName(
    IN OUT PUIDATA  pUiData
    )
/*++

Routine Description:

    Pack Paper size options.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    //
    // Extended push button for bringing up PostScript custom page size dialog
    //

    PFEATURE    pFeature;

    static EXTPUSH ExtPush =
    {
        sizeof(EXTPUSH),
        EPF_NO_DOT_DOT_DOT,
        (PWSTR) IDS_EDIT_CUSTOMSIZE,
        NULL,
        0,
        0,
    };

    if (!(pFeature = GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_PAGESIZE)) ||
        pFeature->Options.dwCount < MIN_OPTIONS_ALLOWED ||
        pFeature->dwFlags & FEATURE_FLAG_NOUI)
        return TRUE;

    if (pUiData->pOptItem)
    {
        DWORD       dwFormNames, dwIndex, dwSel, dwPageSizeIndex, dwOption;
        PWSTR       pFormNames;
        POPTPARAM   pOptParam;
        PUIINFO     pUIInfo = pUiData->ci.pUIInfo;
        PFEATURE    pPageSizeFeature;
        BOOL        bSupported;

        dwFormNames = pUiData->dwFormNames;
        pFormNames = pUiData->pFormNames;

        //
        // Figure out the currently selected paper size option index
        //

        dwSel = DwFindFormNameIndex(pUiData, pUiData->ci.pdm->dmFormName, &bSupported);

        //
        // If the form is not supported on the printer, it could be the case
        // where the printer doesn't support a form with the same name, but
        // the printer can still support the requested form using exact or
        // closest paper size match.
        //
        // See function VFixOptionsArrayWithDevmode() and ChangeOptionsViaID().
        //

        if (!bSupported &&
            (pPageSizeFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGESIZE)))
        {
            WCHAR      awchBuf[CCHPAPERNAME];
            PPAGESIZE  pPageSize;

            //
            // If we can't find a name match in the first DwFindFormNameIndex call,
            // the option array should already have the correct option index value
            // parser has decided to use to support the form. So now we only need
            // to load the option's display name and search in the form name list
            // again to get the paper size UI list index.
            //

            dwPageSizeIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pPageSizeFeature);

            dwOption = pUiData->ci.pCombinedOptions[dwPageSizeIndex].ubCurOptIndex;

            if ((pPageSize = (PPAGESIZE)PGetIndexedOption(pUIInfo, pPageSizeFeature, dwOption)) &&
                LOAD_STRING_PAGESIZE_NAME(&(pUiData->ci), pPageSize, awchBuf, CCHPAPERNAME))
            {
                dwSel = DwFindFormNameIndex(pUiData, awchBuf, NULL);
            }
        }

        //
        // Fill out OPTITEM, OPTTYPE, and OPTPARAM structures
        //

        FILLOPTITEM(pUiData->pOptItem,
                    pUiData->pOptType,
                    ULongToPtr(IDS_CPSUI_FORMNAME),
                    ULongToPtr(dwSel),
                    TVITEM_LEVEL1,
                    DMPUB_FORMNAME,
                    FORMNAME_ITEM,
                    HELP_INDEX_FORMNAME);

        pUiData->pOptType->Style = OTS_LBCB_SORT;

        pOptParam = PFillOutOptType(pUiData->pOptType,
                                    TVOT_LISTBOX,
                                    dwFormNames,
                                    pUiData->ci.hHeap);

        if (pOptParam == NULL)
            return FALSE;

        for (dwIndex=0; dwIndex < dwFormNames; dwIndex++)
        {
            pOptParam->cbSize = sizeof(OPTPARAM);
            pOptParam->pData = pFormNames;

            if (pUiData->pwPapers[dwIndex] == DMPAPER_CUSTOMSIZE)
                pOptParam->IconID = IDI_CUSTOM_PAGESIZE;
            else if (pOptParam->IconID = HLoadFormIconResource(pUiData, dwIndex))
                pOptParam->Flags |= OPTPF_ICONID_AS_HICON;
            else
                pOptParam->IconID = DwGuessFormIconID(pFormNames);

            pOptParam++;
            pFormNames += CCHPAPERNAME;
        }

        //
        // Special case for PostScript custom page size
        //

        #ifdef PSCRIPT

        {
            PPPDDATA pPpdData;

            pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pUiData->ci.pRawData);

            ASSERT(pPpdData != NULL);

            if (SUPPORT_CUSTOMSIZE(pUIInfo) &&
                SUPPORT_FULL_CUSTOMSIZE_FEATURES(pUIInfo, pPpdData))
            {
                pUiData->pOptItem->Flags |= (OPTIF_EXT_IS_EXTPUSH|OPTIF_CALLBACK);
                pUiData->pOptItem->pExtPush = &ExtPush;

                //
                // If PostScript custom page size is selected,
                // select the last item of form name list.
                //

                if (pUiData->ci.pdm->dmPaperSize == DMPAPER_CUSTOMSIZE)
                {
                    pUiData->pOptItem->Sel = pUiData->dwFormNames - 1;
                    pUiData->pOptItem->Flags &= ~(OPTIF_EXT_HIDE | OPTIF_EXT_DISABLED);
                }
                else
                    pUiData->pOptItem->Flags |= (OPTIF_EXT_HIDE | OPTIF_EXT_DISABLED);
            }
        }

        #endif // PSCRIPT

        #ifdef UNIDRV

        //
        // Supports OEM help file. If helpfile and helpindex are defined,
        // we will use the help id specified by the GPD.  According to GPD spec,
        // zero loHelpFileName means no help file name specified.
        //

        if (pUIInfo->loHelpFileName &&
            pFeature->iHelpIndex != UNUSED_ITEM)
        {
            POIEXT pOIExt = HEAPALLOC(pUiData->ci.hHeap, sizeof(OIEXT));

            if (pOIExt)
            {
                pOIExt->cbSize = sizeof(OIEXT);
                pOIExt->Flags = 0;
                pOIExt->hInstCaller = NULL;
                pOIExt->pHelpFile = OFFSET_TO_POINTER(pUIInfo->pubResourceData,
                                                      pUIInfo->loHelpFileName);
                pUiData->pOptItem->pOIExt = pOIExt;
                pUiData->pOptItem->HelpIndex = pFeature->iHelpIndex;
                pUiData->pOptItem->Flags |= OPTIF_HAS_POIEXT;
            }
        }

        #endif // UNIDRV

        //
        // Set the Keyword name for pOptItem->UserData
        //

        SETUSERDATA_KEYWORDNAME(pUiData->ci, pUiData->pOptItem, pFeature);

        pUiData->pOptItem++;
        pUiData->pOptType++;
    }

    pUiData->dwOptItem++;
    pUiData->dwOptType++;
    return TRUE;
}



BOOL
BPackItemInputSlot(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack paper source option.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    POPTTYPE    pOptType;
    PFEATURE    pFeature;
    PINPUTSLOT  pInputSlot;

    pFeature = GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_INPUTSLOT);
    pOptType = pUiData->pOptType;

    if (! BPackItemPrinterFeature(
                pUiData,
                pFeature,
                TVITEM_LEVEL1,
                DMPUB_DEFSOURCE,
                (ULONG_PTR)INPUTSLOT_ITEM,
                HELP_INDEX_INPUT_SLOT))
    {
        return FALSE;
    }

    //
    // NOTE: if the first input slot has dwPaperSourceID == DMBIN_FORMSOURCE,
    // then we'll change its display name to "Automatically Select".
    //

    if (pOptType != NULL && pOptType != pUiData->pOptType)
    {
        ASSERT(pFeature != NULL);

        pInputSlot = PGetIndexedOption(pUiData->ci.pUIInfo, pFeature, 0);
        ASSERT(pInputSlot != NULL);

        if (pInputSlot->dwPaperSourceID == DMBIN_FORMSOURCE)
            pOptType->pOptParam[0].pData = (PWSTR) IDS_TRAY_FORMSOURCE;
    }

    return TRUE;
}


BOOL
BPackItemMediaType(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack media type option.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    return BPackItemPrinterFeature(
                pUiData,
                GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_MEDIATYPE),
                TVITEM_LEVEL1,
                DMPUB_MEDIATYPE,
                (ULONG_PTR)MEDIATYPE_ITEM,
                HELP_INDEX_MEDIA_TYPE);
}



static CONST WORD CopiesCollateItemInfo[] =
{
    IDS_CPSUI_COPIES, TVITEM_LEVEL1, DMPUB_COPIES_COLLATE,
    COPIES_COLLATE_ITEM, HELP_INDEX_COPIES_COLLATE,
    2, TVOT_UDARROW,
    0, IDI_CPSUI_COPY,
    0, MIN_COPIES,
    ITEM_INFO_SIGNATURE
};


BOOL
BPackItemCopiesCollate(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack copies and collate option.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    POPTITEM    pOptItem = pUiData->pOptItem;
    PEXTCHKBOX  pExtCheckbox;
    PFEATURE    pFeature;
    SHORT       sCopies, sMaxCopies;

    if ((pFeature = GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_COLLATE)) &&
        pFeature->dwFlags & FEATURE_FLAG_NOUI)
        return TRUE;

    if (pUiData->bEMFSpooling)
    {
        sCopies = pUiData->ci.pdm->dmCopies;
        sMaxCopies =  max(MAX_COPIES, (SHORT)pUiData->ci.pUIInfo->dwMaxCopies);
    }
    else
    {
        sCopies = pUiData->ci.pdm->dmCopies > (SHORT)pUiData->ci.pUIInfo->dwMaxCopies ?
                  (SHORT)pUiData->ci.pUIInfo->dwMaxCopies : pUiData->ci.pdm->dmCopies;
        sMaxCopies = (SHORT)pUiData->ci.pUIInfo->dwMaxCopies;

    }
    if (! BPackUDArrowItemTemplate(
                pUiData,
                CopiesCollateItemInfo,
                sCopies,
                sMaxCopies,
                pFeature))
    {
        return FALSE;
    }

    if (pOptItem && DRIVER_SUPPORTS_COLLATE(((PCOMMONINFO)&pUiData->ci)))
    {
        pExtCheckbox = HEAPALLOC(pUiData->ci.hHeap, sizeof(EXTCHKBOX));

        if (pExtCheckbox == NULL)
        {
            ERR(("Memory allocation failed\n"));
            return FALSE;
        }

        pExtCheckbox->cbSize = sizeof(EXTCHKBOX);
        pExtCheckbox->pTitle = (PWSTR) IDS_CPSUI_COLLATE;
        pExtCheckbox->pCheckedName = (PWSTR) IDS_CPSUI_COLLATED;
        pExtCheckbox->IconID = IDI_CPSUI_COLLATE;
        pExtCheckbox->Flags = ECBF_CHECKNAME_ONLY_ENABLED;
        pExtCheckbox->pSeparator = (PWSTR)IDS_CPSUI_SLASH_SEP;

        pOptItem->pExtChkBox = pExtCheckbox;

        if ((pUiData->ci.pdm->dmFields & DM_COLLATE) &&
            (pUiData->ci.pdm->dmCollate == DMCOLLATE_TRUE))
        {
            pOptItem->Flags |= OPTIF_ECB_CHECKED;
        }
    }

    return TRUE;
}



BOOL
BPackItemResolution(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack resolution option.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    return BPackItemPrinterFeature(
                pUiData,
                GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_RESOLUTION),
                TVITEM_LEVEL1,
                DMPUB_PRINTQUALITY,
                (ULONG_PTR)RESOLUTION_ITEM,
                HELP_INDEX_RESOLUTION);
}



static CONST WORD ColorItemInfo[] =
{
    IDS_CPSUI_COLOR, TVITEM_LEVEL1, DMPUB_COLOR,
    COLOR_ITEM, HELP_INDEX_COLOR,
    2, TVOT_2STATES,
    IDS_CPSUI_MONOCHROME, IDI_CPSUI_MONO,
    IDS_CPSUI_COLOR, IDI_CPSUI_COLOR,
    ITEM_INFO_SIGNATURE
};

//
// ICM stuff is not available on NT4
//

#ifndef WINNT_40

static CONST WORD ICMMethodItemInfo[] =
{
    IDS_ICMMETHOD, TVITEM_LEVEL1,

    #ifdef WINNT_40
    DMPUB_NONE,
    #else
    DMPUB_ICMMETHOD,
    #endif

    ICMMETHOD_ITEM, HELP_INDEX_ICMMETHOD,
    #ifdef PSCRIPT
    4, TVOT_LISTBOX,
    #else
    3, TVOT_LISTBOX,
    #endif
    IDS_ICMMETHOD_NONE, IDI_ICMMETHOD_NONE,
    IDS_ICMMETHOD_SYSTEM, IDI_ICMMETHOD_SYSTEM,
    IDS_ICMMETHOD_DRIVER, IDI_ICMMETHOD_DRIVER,
    #ifdef PSCRIPT
    IDS_ICMMETHOD_DEVICE, IDI_ICMMETHOD_DEVICE,
    #endif
    ITEM_INFO_SIGNATURE
};

static CONST WORD ICMIntentItemInfo[] =
{
    IDS_ICMINTENT, TVITEM_LEVEL1,

    #ifdef WINNT_40
    DMPUB_NONE,
    #else
    DMPUB_ICMINTENT,
    #endif

    ICMINTENT_ITEM, HELP_INDEX_ICMINTENT,
    4, TVOT_LISTBOX,
    IDS_ICMINTENT_SATURATE, IDI_ICMINTENT_SATURATE,
    IDS_ICMINTENT_CONTRAST, IDI_ICMINTENT_CONTRAST,
    IDS_ICMINTENT_COLORIMETRIC, IDI_ICMINTENT_COLORIMETRIC,
    IDS_ICMINTENT_ABS_COLORIMETRIC, IDI_ICMINTENT_ABS_COLORIMETRIC,
    ITEM_INFO_SIGNATURE
};

#endif // !WINNT_40


BOOL
BPackItemColor(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack color mode option.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    PDEVMODE    pdm;
    INT         dwColorSel, dwICMMethodSel, dwICMIntentSel;

    //
    // For Adobe driver, they want to preserve the color information
    // even for b/w printers. So we always give user this choice.
    //

    #ifndef ADOBE

    if (! IS_COLOR_DEVICE(pUiData->ci.pUIInfo))
        return TRUE;

    #endif  // !ADOBE

    //
    // DCR - Some ICM methods and intents may need to be disabled
    // on some non-PostScript printers.
    //

    pdm = pUiData->ci.pdm;
    dwColorSel = dwICMMethodSel = dwICMIntentSel = 0;

    if ((pdm->dmFields & DM_COLOR) && (pdm->dmColor == DMCOLOR_COLOR))
        dwColorSel = 1;

    if (! BPackOptItemTemplate(pUiData, ColorItemInfo, dwColorSel, NULL))
        return FALSE;

    //
    // ICM stuff is not available on NT4
    //

    #ifndef WINNT_40

    if (pdm->dmFields & DM_ICMMETHOD)
    {
        switch (pdm->dmICMMethod)
        {
        case DMICMMETHOD_SYSTEM:
            dwICMMethodSel = 1;
            break;

        case DMICMMETHOD_DRIVER:
            dwICMMethodSel = 2;
            break;

        #ifdef PSCRIPT
        case DMICMMETHOD_DEVICE:
            dwICMMethodSel = 3;
            break;
        #endif

        case DMICMMETHOD_NONE:
        default:
            dwICMMethodSel = 0;
            break;
        }
    }

    if (pdm->dmFields & DM_ICMINTENT)
    {
        switch (pdm->dmICMIntent)
        {
        case DMICM_COLORIMETRIC:
            dwICMIntentSel = 2;
            break;

        case DMICM_ABS_COLORIMETRIC:
            dwICMIntentSel = 3;
            break;

        case DMICM_SATURATE:
            dwICMIntentSel = 0;
            break;

        case DMICM_CONTRAST:
        default:
            dwICMIntentSel = 1;
            break;


        }
    }

    if (! BPackOptItemTemplate(pUiData, ICMMethodItemInfo, dwICMMethodSel, NULL) ||
        ! BPackOptItemTemplate(pUiData, ICMIntentItemInfo, dwICMIntentSel, NULL))
    {
        return FALSE;
    }

    #endif // !WINNT_40

    return TRUE;
}



BOOL
BPackItemDuplex(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack duplexing option.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    POPTITEM    pOptItem = pUiData->pOptItem;
    PCOMMONINFO pci      = &pUiData->ci;
    PFEATURE    pFeature = GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_DUPLEX);
    BOOL        bRet;


    //
    // Don't display the duplex feature if duplex is constrained by an
    // installable feature such as duplex unit not installed
    //


    if (!SUPPORTS_DUPLEX(pci) ||
        (pFeature && pFeature->Options.dwCount < MIN_OPTIONS_ALLOWED))
        return TRUE;

    bRet = BPackItemPrinterFeature(
                pUiData,
                pFeature,
                TVITEM_LEVEL1,
                DMPUB_DUPLEX,
                (ULONG_PTR)DUPLEX_ITEM,
                HELP_INDEX_DUPLEX);

    #ifdef WINNT_40

    //
    // Use standard names for duplex options. Otherwise, the duplex option
    // names from the PPD/GPD file may be too long to fit into the space
    // on the friendly (Page Setup) tab.
    //
    // On NT5, this kluge is inside compstui.
    //

    if (bRet && pFeature && pOptItem)
    {
        DWORD   dwIndex;
        INT     StrRsrcId;
        PDUPLEX pDuplex;

        for (dwIndex=0; dwIndex < pOptItem->pOptType->Count; dwIndex++)
        {
            pDuplex = (PDUPLEX) PGetIndexedOption(pUiData->ci.pUIInfo, pFeature, dwIndex);
            ASSERT(pDuplex != NULL);

            switch (pDuplex->dwDuplexID)
            {
            case DMDUP_HORIZONTAL:
                StrRsrcId = IDS_CPSUI_SHORT_SIDE;
                break;

            case DMDUP_VERTICAL:
                StrRsrcId = IDS_CPSUI_LONG_SIDE;
                break;

            default:
                StrRsrcId = IDS_CPSUI_NONE;
                break;
            }

            pOptItem->pOptType->pOptParam[dwIndex].pData = (PWSTR) StrRsrcId;
        }
    }

    #endif // WINNT_40

    return bRet;
}



static CONST WORD TTOptionItemInfo[] =
{
    IDS_CPSUI_TTOPTION, TVITEM_LEVEL1, DMPUB_TTOPTION,
    TTOPTION_ITEM, HELP_INDEX_TTOPTION,
    2, TVOT_2STATES,
    IDS_CPSUI_TT_SUBDEV, IDI_CPSUI_TT_SUBDEV,
    IDS_CPSUI_TT_DOWNLOADSOFT, IDI_CPSUI_TT_DOWNLOADSOFT,
    ITEM_INFO_SIGNATURE
};


BOOL
BPackItemTTOptions(
    IN OUT PUIDATA  pUiData
    )
/*++

Routine Description:

    Pack TT options

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    DWORD dwSel;


    //
    // If device fonts have been disabled or doesn't support
    // font substitution , then don't
    // show font substitution option
    //

    if (pUiData->ci.pPrinterData->dwFlags & PFLAGS_IGNORE_DEVFONT ||
        pUiData->ci.pUIInfo->dwFontSubCount == 0 )
    {
        pUiData->ci.pdm->dmTTOption = DMTT_DOWNLOAD;
        return TRUE;
    }

    dwSel = (pUiData->ci.pdm->dmTTOption == DMTT_SUBDEV) ? 0 : 1;
    return BPackOptItemTemplate(pUiData, TTOptionItemInfo, dwSel, NULL);
}



static CONST WORD ItemInfoMFSpool[] =
{
    IDS_METAFILE_SPOOLING, TVITEM_LEVEL1, DMPUB_NONE,
    METASPOOL_ITEM, HELP_INDEX_METAFILE_SPOOLING,
    2, TVOT_2STATES,
    IDS_ENABLED, IDI_CPSUI_ON,
    IDS_DISABLED, IDI_CPSUI_OFF,
    ITEM_INFO_SIGNATURE
};

static CONST WORD ItemInfoNupOption[] =
{
    IDS_NUPOPTION, TVITEM_LEVEL1, NUP_DMPUB,
    NUP_ITEM, HELP_INDEX_NUPOPTION,
    7, TVOT_LISTBOX,
    IDS_ONE_UP, IDI_ONE_UP,
    IDS_TWO_UP, IDI_TWO_UP,
    IDS_FOUR_UP, IDI_FOUR_UP,
    IDS_SIX_UP, IDI_SIX_UP,
    IDS_NINE_UP, IDI_NINE_UP,
    IDS_SIXTEEN_UP, IDI_SIXTEEN_UP,
    IDS_BOOKLET , IDI_BOOKLET,
    ITEM_INFO_SIGNATURE
};

static CONST WORD ItemInfoRevPrint[] =
{
    IDS_PAGEORDER, TVITEM_LEVEL1, PAGEORDER_DMPUB,
    REVPRINT_ITEM, HELP_INDEX_REVPRINT,
    2, TVOT_2STATES,
    IDS_PAGEORDER_NORMAL,  IDI_PAGEORDER_NORMAL,
    IDS_PAGEORDER_REVERSE, IDI_PAGEORDER_REVERSE,
    ITEM_INFO_SIGNATURE
};

BOOL
BPackItemEmfFeatures(
    PUIDATA pUiData
    )

/*++

Routine Description:

    Pack EMF related feature items:
        EMF spooling on/off
        N-up
        reverse-order printing

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    PDRIVEREXTRA    pdmExtra = pUiData->ci.pdmPrivate;
    BOOL            bNupOption, bReversePrint;
    PCOMMONINFO     pci = &pUiData->ci;
    DWORD           dwSel;
    POPTITEM        pOptItem;

    //
    // Check if the spooler can do N-up and reverse-order printing
    // for the current printer
    //

    VGetSpoolerEmfCaps(pci->hPrinter, &bNupOption, &bReversePrint, 0, NULL);

    //
    // On Win2K and above, don't show the EMF spooling option in driver UI
    // if spooler cannot do EMF.
    // pUiData->bEMFSpooling is initialized at PFillUidata
    // 1. Determine if Reverse Print is possible
    // 2. Spooler can do EMF.
    //
    // On NT4, since spooler doesn't support the EMF capability query, we
    // have to keep the old NT4 driver behavior of always showing the EMF
    // spooling option in driver UI.
    //

    #ifndef WINNT_40
    if (pUiData->bEMFSpooling)
    {
    #endif

        dwSel = ISSET_MFSPOOL_FLAG(pdmExtra) ? 0 : 1;

        if (!BPackOptItemTemplate(pUiData, ItemInfoMFSpool, dwSel, NULL))
            return FALSE;

    #ifndef WINNT_40
    }
    #endif

    #ifdef PSCRIPT
        bNupOption = TRUE;
    #endif

    //
    // Pack N-up option item if necessary
    //

    if (bNupOption)
    {
        switch (NUPOPTION(pdmExtra))
        {
        case TWO_UP:
            dwSel = 1;
            break;

        case FOUR_UP:
            dwSel = 2;
            break;

        case SIX_UP:
            dwSel = 3;
            break;

        case NINE_UP:
            dwSel = 4;
            break;

        case SIXTEEN_UP:
            dwSel = 5;
            break;

        case BOOKLET_UP:
            dwSel = 6;
            break;

        case ONE_UP:
        default:
            dwSel = 0;
            break;
        }

        pOptItem = pUiData->pOptItem;

        if (!BPackOptItemTemplate(pUiData, ItemInfoNupOption, dwSel, NULL))
            return FALSE;


        //
        // Hide booklet option if duplex is constrained by an
        // installable feature such as duplex unit not installed or EMF is not
        // available.
        //

        if ( pOptItem &&
             (!pUiData->bEMFSpooling || !SUPPORTS_DUPLEX(pci)))
        {
            pOptItem->pOptType->pOptParam[BOOKLET_UP].Flags |= OPTPF_HIDE;

            if (NUPOPTION(pdmExtra) == BOOKLET_UP)
                pOptItem->Sel = 1;
        }
    }
    else
    {
        NUPOPTION(pdmExtra) = ONE_UP;
    }

    //
    // Pack Reverse-order printing option item if necessary
    //

    if (bReversePrint)
    {
        dwSel = REVPRINTOPTION(pdmExtra) ? 1 : 0;

        if (!BPackOptItemTemplate(pUiData, ItemInfoRevPrint, dwSel, NULL))
            return FALSE;
    }
    else
    {
        REVPRINTOPTION(pdmExtra) = FALSE;
    }

    if (pUiData->bEMFSpooling && pUiData->pOptItem)
        VUpdateEmfFeatureItems(pUiData, FALSE);

    return TRUE;
}



BOOL
BPackDocumentPropertyItems(
    IN  OUT PUIDATA pUiData
    )

/*++

Routine Description:

    Pack document property information into treeview items.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/
{
    return BPackItemFormName(pUiData)       &&
           BPackItemInputSlot(pUiData)      &&
           _BPackOrientationItem(pUiData)   &&
           BPackItemCopiesCollate(pUiData)  &&
           BPackItemResolution(pUiData)     &&
           BPackItemColor(pUiData)          &&
           _BPackItemScale(pUiData)         &&
           BPackItemDuplex(pUiData)         &&
           BPackItemMediaType(pUiData)      &&
           BPackItemTTOptions(pUiData)      &&
           BPackItemEmfFeatures(pUiData)    &&
           _BPackDocumentOptions(pUiData)   &&
           BPackItemGenericOptions(pUiData) &&
           BPackOemPluginItems(pUiData);
}



VOID
VUnpackDocumentPropertiesItems(
    PUIDATA     pUiData,
    POPTITEM    pOptItem,
    DWORD       dwOptItem
    )

/*++

Routine Description:

    Extract devmode information from an OPTITEM
    Stored it back into devmode.

Arguments:

    pUiData - Pointer to our UIDATA structure
    pOptItem - Pointer to an array of OPTITEMs
    dwOptItem - Number of OPTITEMs

Return Value:

    Printer feature index corresponding to the last item unpacked

--*/

{
    PUIINFO         pUIInfo = pUiData->ci.pUIInfo;
    PDEVMODE        pdm = pUiData->ci.pdm;
    PDRIVEREXTRA    pdmExtra = pUiData->ci.pdmPrivate;

    for ( ; dwOptItem > 0; dwOptItem--, pOptItem++)
    {
        //
        // Header items always have pOptType == NULL, see
        // VPackOptItemGroupHeader
        //

        if (pOptItem->pOptType == NULL)
            continue;

        //
        // To fix bug #90923, we should only allow hidden items to be processed when we are within
        // the UI helper function call BUpdateUISettingForOEM issued by OEM plguin.
        //
        // We don't do this for other cases because there are already UI plugins that hide our
        // standard items and show their own. For example, CNBJUI.DLL hides our ICMMETHOD_ITEM
        // and ICMINTENT_ITEM. It uses its own as replacement items. If we change the behavior here,
        // we could break those plugins when we process the hidden items and overwrite the devmode
        // plugin has already set based on user selection of their replacement items.
        //

        if (!(pUiData->ci.dwFlags & FLAG_WITHIN_PLUGINCALL) && (pOptItem->Flags & OPTIF_HIDE))
            continue;

        if (ISPRINTERFEATUREITEM(pOptItem->UserData))
        {
            //
            // Generic document-sticky printer features
            //

            VUpdateOptionsArrayWithSelection(pUiData, pOptItem);
        }
        else
        {
            //
            // Common items in public devmode
            //

            switch (GETUSERDATAITEM(pOptItem->UserData))
            {
            case ORIENTATION_ITEM:

                //
                // Orientation is a special case:
                //  for pscript, it's handled via _VUnpackDocumentOptions
                //  for unidrv, it's handled as a generic feature
                //

                #ifdef PSCRIPT

                break;

                #endif

            case DUPLEX_ITEM:
                VUpdateOptionsArrayWithSelection(pUiData, pOptItem);
                VUpdateBookletOption(pUiData, pOptItem);
                break;


            case RESOLUTION_ITEM:
            case INPUTSLOT_ITEM:
            case MEDIATYPE_ITEM:
            case COLORMODE_ITEM:
            case HALFTONING_ITEM:

                VUpdateOptionsArrayWithSelection(pUiData, pOptItem);
                break;

            case SCALE_ITEM:

                pdm->dmScale = (SHORT) pOptItem->Sel;
                break;

            case COPIES_COLLATE_ITEM:

                pdm->dmCopies = (SHORT) pOptItem->Sel;

                if (pOptItem->pExtChkBox)
                {
                    pdm->dmFields |= DM_COLLATE;
                    pdm->dmCollate = (pOptItem->Flags & OPTIF_ECB_CHECKED) ?
                                        DMCOLLATE_TRUE :
                                        DMCOLLATE_FALSE;

                    //
                    // Update Collate feature option index
                    //

                    ChangeOptionsViaID(
                           pUiData->ci.pInfoHeader,
                           pUiData->ci.pCombinedOptions,
                           GID_COLLATE,
                           pdm);
                }
                break;

            case COLOR_ITEM:

                pdm->dmFields |= DM_COLOR;
                pdm->dmColor = (pOptItem->Sel == 1) ?
                                    DMCOLOR_COLOR :
                                    DMCOLOR_MONOCHROME;
                break;

            case METASPOOL_ITEM:

                if (pOptItem->Sel == 0)
                {
                    SET_MFSPOOL_FLAG(pdmExtra);
                }
                else
                {
                    CLEAR_MFSPOOL_FLAG(pdmExtra);
                }
                break;

            case NUP_ITEM:

                switch (pOptItem->Sel)
                {
                case 1:
                    NUPOPTION(pdmExtra) = TWO_UP;
                    break;

                case 2:
                    NUPOPTION(pdmExtra) = FOUR_UP;
                    break;

                case 3:
                    NUPOPTION(pdmExtra) = SIX_UP;
                    break;

                case 4:
                    NUPOPTION(pdmExtra) = NINE_UP;
                    break;

                case 5:
                    NUPOPTION(pdmExtra) = SIXTEEN_UP;
                    break;

                case 6:
                    NUPOPTION(pdmExtra) = BOOKLET_UP;
                    VUpdateBookletOption(pUiData, pOptItem);
                    break;

                case 0:
                default:
                    NUPOPTION(pdmExtra) = ONE_UP;
                    break;
                }
                break;

            case REVPRINT_ITEM:

                REVPRINTOPTION(pdmExtra) = (pOptItem->Sel != 0);
                break;

            //
            // ICM stuff is not available on NT4
            //

            #ifndef WINNT_40

            case ICMMETHOD_ITEM:

                pdm->dmFields |= DM_ICMMETHOD;

                switch (pOptItem->Sel)
                {
                case 0:
                    pdm->dmICMMethod = DMICMMETHOD_NONE;
                    break;

                case 1:
                    pdm->dmICMMethod = DMICMMETHOD_SYSTEM;
                    break;

                case 2:
                    pdm->dmICMMethod = DMICMMETHOD_DRIVER;
                    break;

                #ifdef PSCRIPT
                case 3:
                    pdm->dmICMMethod = DMICMMETHOD_DEVICE;
                    break;
                #endif
                }
                break;

            case ICMINTENT_ITEM:

                pdm->dmFields |= DM_ICMINTENT;

                switch (pOptItem->Sel)
                {
                case 0:
                    pdm->dmICMIntent = DMICM_SATURATE;
                    break;

                case 1:
                    pdm->dmICMIntent = DMICM_CONTRAST;
                    break;

                case 2:
                    pdm->dmICMIntent = DMICM_COLORIMETRIC;
                    break;

                case 3:
                    pdm->dmICMIntent = DMICM_ABS_COLORIMETRIC;
                    break;
                }
                break;

            #endif // !WINNT_40

            case TTOPTION_ITEM:

                pdm->dmFields |= DM_TTOPTION;

                if (pOptItem->Sel == 0)
                    pdm->dmTTOption = DMTT_SUBDEV;
                else
                    pdm->dmTTOption = DMTT_DOWNLOAD;
                break;

            case FORMNAME_ITEM:

                pdm->dmFields &= ~(DM_PAPERLENGTH|DM_PAPERWIDTH);
                pdm->dmFields |= DM_PAPERSIZE;
                pdm->dmPaperSize = pUiData->pwPapers[pOptItem->Sel];

                if (pdm->dmPaperSize == DMPAPER_CUSTOMSIZE)
                    pdm->dmFields &= ~DM_FORMNAME;
                else
                    pdm->dmFields |= DM_FORMNAME;

                CopyString(pdm->dmFormName,
                           pOptItem->pOptType->pOptParam[pOptItem->Sel].pData,
                           CCHFORMNAME);

                //
                // Update PageSize feature option index
                //

                {
                    INT dwIndex;

                    if (PGetFeatureFromItem(pUiData->ci.pUIInfo, pOptItem, &dwIndex))
                    {
                        pUiData->ci.pCombinedOptions[dwIndex].ubCurOptIndex =
                            (BYTE) pUiData->pwPaperFeatures[pOptItem->Sel];
                    }
                }

                break;
            }

            //
            // Give drivers a chance to process their private items
            //

            _VUnpackDocumentOptions(pOptItem, pdm);
        }
    }
}



VOID
VUpdateEmfFeatureItems(
    PUIDATA pUiData,
    BOOL    bUpdateMFSpoolItem
    )

/*++

Routine Description:

    Handle the inter-dependency between EMF spooling, N-up, and
    reverse-printing items.

Arguments:

    pUiData - Points to UIDATA structure
    bUpdateMFSpoolItem - Whether to update EMF spooling or the other two items

Return Value:

    NONE

--*/

{
    POPTITEM        pMFSpoolItem, pNupItem, pRevPrintItem, pCopiesCollateItem;

    pMFSpoolItem = PFindOptItemWithUserData(pUiData, METASPOOL_ITEM);
    pNupItem = PFindOptItemWithUserData(pUiData, NUP_ITEM);
    pRevPrintItem = PFindOptItemWithUserData(pUiData, REVPRINT_ITEM);
    pCopiesCollateItem = PFindOptItemWithUserData(pUiData, COPIES_COLLATE_ITEM);

    if (pMFSpoolItem == NULL)
        return;

    if (bUpdateMFSpoolItem)
    {

        //
        // Force EMF spooling to be on if:
        //  N-up option is not ONE_UP (Unidrv only), or
        //  reverse-order printing is enabled or
        //  collate is not supported by the device or
        //  copies count is > than max count support by device
        //

        #ifdef UNIDRV

        if (pNupItem && pNupItem->Sel != 0)
            pMFSpoolItem->Sel = 0;

        #endif // UNIDRV

        if (pNupItem && pNupItem->Sel == BOOKLET_UP)
            pMFSpoolItem->Sel = 0;

        if (pRevPrintItem)
        {
            //
            // Turn on EMF if the user selects "Normal" and
            // the bin is "Reversed" OR user selects "Reversed"
            // and the bin is "Normal"
            //

            BOOL    bReversed = BGetPageOrderFlag(&pUiData->ci);
            if ( pRevPrintItem->Sel == 0 && bReversed ||
                 pRevPrintItem->Sel != 0 && !bReversed )
                pMFSpoolItem->Sel = 0;
        }

        if (pCopiesCollateItem)
        {
            if (((pCopiesCollateItem->Flags & OPTIF_ECB_CHECKED) &&
                 !PRINTER_SUPPORTS_COLLATE(((PCOMMONINFO)&pUiData->ci))) ||
                (pCopiesCollateItem->Sel > (LONG)pUiData->ci.pUIInfo->dwMaxCopies))
            {
                pMFSpoolItem->Sel = 0;
            }
        }

        pMFSpoolItem->Flags |= OPTIF_CHANGED;
        VUnpackDocumentPropertiesItems(pUiData, pMFSpoolItem, 1);
    }
    else
    {
        //
        // If EMF spooling is turned off, force:
        //  N-up option to be ONE_UP (Unidrv only), and
        //  collate to be off if the device doesn't support collation
        //  copies set to the max count handle by the device
        //

        if (pMFSpoolItem->Sel != 0)
        {
            #ifdef UNIDRV
            if (pNupItem)
            {
                pNupItem->Sel = 0;
                pNupItem->Flags |= OPTIF_CHANGED;
                VUnpackDocumentPropertiesItems(pUiData, pNupItem, 1);
            }
            #endif // UNIDRV

            if (pNupItem && pNupItem->Sel == BOOKLET_UP)
            {
                pNupItem->Sel = 0;
                pNupItem->Flags |= OPTIF_CHANGED;
                VUnpackDocumentPropertiesItems(pUiData, pNupItem, 1);
            }


            if (pCopiesCollateItem)
            {
                if ((pCopiesCollateItem->Flags & OPTIF_ECB_CHECKED) &&
                    !PRINTER_SUPPORTS_COLLATE(((PCOMMONINFO)&pUiData->ci)))
                {
                    pCopiesCollateItem->Flags &=~OPTIF_ECB_CHECKED;
                }

                if (pCopiesCollateItem->Sel > (LONG)pUiData->ci.pUIInfo->dwMaxCopies)
                    pCopiesCollateItem->Sel = (LONG)pUiData->ci.pUIInfo->dwMaxCopies;

                pCopiesCollateItem->Flags |= OPTIF_CHANGED;
                VUnpackDocumentPropertiesItems(pUiData, pCopiesCollateItem, 1);

            }

            //
            // EMF is OFF. Need to make the "Page Order" option consistent
            // with the current output bin. If bin is "Reversed" and user selects
            // "Normal", change it to "Reverse". If bin is "Normal" and user selects
            // "Reverse", change it to "Normal"
            //

            if (pRevPrintItem)
            {
                BOOL    bReversed = BGetPageOrderFlag(&pUiData->ci);
                if (pRevPrintItem->Sel == 0 && bReversed )
                    pRevPrintItem->Sel = 1;
                else if ( pRevPrintItem->Sel != 0 && !bReversed )
                    pRevPrintItem->Sel = 0;

                pRevPrintItem->Flags |= OPTIF_CHANGED;
                VUnpackDocumentPropertiesItems(pUiData, pRevPrintItem, 1);
            }
        }
    }
}


BOOL
BGetPageOrderFlag(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Get the page order flag for the specified output bin

Arguments:

    pci - Pointer to PCOMMONINFO

Return Value:

    TRUE if output bin is reverse. otherwise, FALSE

--*/

{
    PUIINFO    pUIInfo = pci->pUIInfo;
    PFEATURE   pFeature;
    POUTPUTBIN pOutputBin;
    DWORD      dwFeatureIndex, dwOptionIndex;
    BOOL       bRet = FALSE;

    #ifdef PSCRIPT

    {
        PPPDDATA   pPpdData;
        POPTION    pOption;
        PCSTR      pstrKeywordName;

        //
        // For PostScript driver, PPD could have "*OpenUI *OutputOrder", which enables user to
        // select "Normal" or "Reverse" output order. This should have higher priority than
        // current output bin's output order or what *DefaultOutputOrder specifies.
        //

        pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pci->pRawData);

        ASSERT(pPpdData != NULL);

        if (pPpdData->dwOutputOrderIndex != INVALID_FEATURE_INDEX)
        {
            //
            // "OutputOrder" feature is available. Check it's current option selection.
            //

            pFeature = PGetIndexedFeature(pUIInfo, pPpdData->dwOutputOrderIndex);

            ASSERT(pFeature != NULL);

            dwOptionIndex = pci->pCombinedOptions[pPpdData->dwOutputOrderIndex].ubCurOptIndex;

            if ((pOption = PGetIndexedOption(pUIInfo, pFeature, dwOptionIndex)) &&
                (pstrKeywordName = OFFSET_TO_POINTER(pUIInfo->pubResourceData, pOption->loKeywordName)))
            {
                //
                // Valid *OutputOrder option keywords are "Reverse" or "Normal".
                //

                if (strcmp(pstrKeywordName, "Reverse") == EQUAL_STRING)
                    return TRUE;
                else if (strcmp(pstrKeywordName, "Normal") == EQUAL_STRING)
                    return FALSE;
            }

            //
            // If we are here, the PPD must have wrong information in *OpenUI *OutputOrder.
            // We just ignore "OutputOrder" feature and continue.
            //
        }
    }

    #endif // PSCRIPT

    //
    // If the output bin order is NORMAL or there is no output bin
    // feature defined, then the page order is the user's selection.
    //

    if ((pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_OUTPUTBIN)))
    {
        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);
        dwOptionIndex = pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex;
        pOutputBin = (POUTPUTBIN)PGetIndexedOption(pUIInfo,
                                                   pFeature,
                                                   dwOptionIndex);

        if (pOutputBin &&
            pOutputBin->bOutputOrderReversed)
        {

            if (NOT_UNUSED_ITEM(pOutputBin->bOutputOrderReversed))
                bRet = TRUE;
            else
                bRet = pUIInfo->dwFlags & FLAG_REVERSE_PRINT;
        }
    }
    else if (pUIInfo->dwFlags & FLAG_REVERSE_PRINT)
       bRet = TRUE;

    return bRet;

}

DWORD
DwGetDrvCopies(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Get the printer copy count capability.  Also take into account the
    collating option.

Arguments:

    pci - Pointer to PCOMMONINFO

Return Value:

    The number of copies the printer can do, with collating taken into consideration


--*/

{
    DWORD dwRet;

    if ((pci->pdm->dmFields & DM_COLLATE) &&
        pci->pdm->dmCollate == DMCOLLATE_TRUE &&
        !PRINTER_SUPPORTS_COLLATE(pci))
        dwRet = 1;
    else
        dwRet = min(pci->pUIInfo->dwMaxCopies, (DWORD)pci->pdm->dmCopies);

    return dwRet;

}


BOOL
DrvQueryJobAttributes(
    HANDLE      hPrinter,
    PDEVMODE    pDevMode,
    DWORD       dwLevel,
    LPBYTE      lpAttributeInfo
    )

/*++

Routine Description:

    Negotiate EMF printing features (such as N-up and reverse-order printing)
    with the spooler

Arguments:

    hPrinter - Handle to the current printer
    pDevMode - Pointer to input devmode
    dwLevel - Specifies the structure level for lpAttributeInfo
    lpAttributeInfo - Output buffer for returning EMF printing features

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    #if !defined(WINNT_40)

    PCOMMONINFO         pci;
    PATTRIBUTE_INFO_1   pAttrInfo1;
    DWORD               dwVal;
    BOOL                bAppDoNup, bResult = FALSE;

    //
    // We can only handle AttributeInfo level 1
    //

    if ( dwLevel != 1 && dwLevel != 2  && dwLevel != 3)
    {
        ERR(("Invalid level for DrvQueryJobAttributes: %d\n", dwLevel));
        SetLastError(ERROR_INVALID_PARAMETER);
        return bResult;
    }

    //
    // Load basic printer information
    //

    if (! (pci = PLoadCommonInfo(hPrinter, NULL, 0)) ||
        ! BFillCommonInfoPrinterData(pci)  ||
        ! BFillCommonInfoDevmode(pci, NULL, pDevMode) ||
        ! BCombineCommonInfoOptionsArray(pci))
    {
        VFreeCommonInfo(pci);
        return bResult;
    }

    VFixOptionsArrayWithDevmode(pci);

    (VOID) ResolveUIConflicts(pci->pRawData,
                              pci->pCombinedOptions,
                              MAX_COMBINED_OPTIONS,
                              MODE_DOCUMENT_STICKY);

    VOptionsToDevmodeFields(pci, TRUE);

    if (! BUpdateUIInfo(pci))
    {
        VFreeCommonInfo(pci);
        return bResult;
    }

    pAttrInfo1 = (PATTRIBUTE_INFO_1) lpAttributeInfo;

    bAppDoNup = ( (pci->pdm->dmFields & DM_NUP) &&
                  (pci->pdm->dmNup == DMNUP_ONEUP) );

    if (bAppDoNup)
    {
        dwVal = 1;
    }
    else
    {
        switch (NUPOPTION(pci->pdmPrivate))
        {
        case TWO_UP:
            dwVal = 2;
            break;

        case FOUR_UP:
            dwVal = 4;
            break;

        case SIX_UP:
            dwVal = 6;
            break;

        case NINE_UP:
            dwVal = 9;
            break;

        case SIXTEEN_UP:
            dwVal = 16;
            break;

        case BOOKLET_UP:
            dwVal = 2;
            break;

        case ONE_UP:
        default:
            dwVal = 1;
            break;
        }
    }
    pAttrInfo1->dwDrvNumberOfPagesPerSide = pAttrInfo1->dwJobNumberOfPagesPerSide = dwVal;
    pAttrInfo1->dwNupBorderFlags = BORDER_PRINT;

    pAttrInfo1->dwJobPageOrderFlags =
        REVPRINTOPTION(pci->pdmPrivate) ? REVERSE_PRINT : NORMAL_PRINT;
    pAttrInfo1->dwDrvPageOrderFlags = BGetPageOrderFlag(pci) ? REVERSE_PRINT : NORMAL_PRINT;

    //
    // Check for booklet
    //

    if ((NUPOPTION(pci->pdmPrivate) == BOOKLET_UP) && !bAppDoNup)
    {
        pAttrInfo1->dwJobNumberOfPagesPerSide = 2;
        pAttrInfo1->dwDrvNumberOfPagesPerSide = 1;
        pAttrInfo1->dwDrvPageOrderFlags |= BOOKLET_PRINT;
    }

    pAttrInfo1->dwJobNumberOfCopies = pci->pdm->dmCopies;
    pAttrInfo1->dwDrvNumberOfCopies = DwGetDrvCopies(pci);

    #ifdef UNIDRV

    //
    // Unidrv doesn't support N-up option.
    //

    pAttrInfo1->dwDrvNumberOfPagesPerSide = 1;

    #endif

    //
    // Unidrv assumes that automatic switching to monochrome
    // mode on a color printer is allowed unless disabled in GPD
    //

    if (dwLevel == 3)
    {
    #ifdef UNIDRV

        SHORT dmPrintQuality, dmYResolution;

        if (pci->pUIInfo->bChangeColorModeOnDoc &&
            (pci->pdm->dmFields & DM_COLOR) &&
            (pci->pdm->dmColor == DMCOLOR_COLOR) &&
            BOkToChangeColorToMono(pci, pci->pdm, &dmPrintQuality, &dmYResolution) &&
            GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_COLORMODE))
        {
            ((PATTRIBUTE_INFO_3)pAttrInfo1)->dwColorOptimization = COLOR_OPTIMIZATION;
            ((PATTRIBUTE_INFO_3)pAttrInfo1)->dmPrintQuality = dmPrintQuality;
            ((PATTRIBUTE_INFO_3)pAttrInfo1)->dmYResolution = dmYResolution;

        }
        else
    #endif
            ((PATTRIBUTE_INFO_3)pAttrInfo1)->dwColorOptimization = NO_COLOR_OPTIMIZATION;
    }

    bResult = TRUE;

    FOREACH_OEMPLUGIN_LOOP(pci)

        if (HAS_COM_INTERFACE(pOemEntry))
        {
            HRESULT hr;

            hr = HComOEMQueryJobAttributes(
                                pOemEntry,
                                hPrinter,
                                pDevMode,
                                dwLevel,
                                lpAttributeInfo);

            if (hr == E_NOTIMPL || hr == E_NOINTERFACE)
                continue;

            bResult = SUCCEEDED(hr);

        }

    END_OEMPLUGIN_LOOP

    VFreeCommonInfo(pci);
    return bResult;

    #else // WINNT_40

    return FALSE;

    #endif // WINNT_40
}

VOID
VUpdateBookletOption(
    PUIDATA     pUiData,
    POPTITEM    pCurItem
    )

/*++

Routine Description:

    Handle the dependencies between duplex, nup and booklet options

Arguments:

    pUiData - UIDATA
    pCurItem - OPTITEM to currently selected item

Return Value:

    None

--*/

{
    PDRIVEREXTRA  pdmExtra = pUiData->ci.pdmPrivate;
    DWORD         dwFeatureIndex, dwOptionIndex, dwCount;
    PDUPLEX       pDuplexOption = NULL;
    POPTITEM      pDuplexItem, pNupItem;
    PFEATURE      pDuplexFeature = NULL;

    pDuplexItem = pNupItem = NULL;

    //
    // 1. Booklet is enabled - turn duplex on
    // 3. Duplex is simplex, disable booklet, set to 1 up.
    //

    pDuplexFeature = GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_DUPLEX);
    pNupItem = PFindOptItemWithUserData(pUiData, NUP_ITEM);
    pDuplexItem = PFindOptItemWithUserData(pUiData, DUPLEX_ITEM);

    if (pDuplexFeature && pDuplexItem)
    {
        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUiData->ci.pUIInfo, pDuplexFeature);
        dwOptionIndex = pUiData->ci.pCombinedOptions[dwFeatureIndex].ubCurOptIndex;
        pDuplexOption = PGetIndexedOption(pUiData->ci.pUIInfo, pDuplexFeature, dwOptionIndex);
    }

    if ((GETUSERDATAITEM(pCurItem->UserData) == NUP_ITEM) &&
         pCurItem->Sel == BOOKLET_UP)
    {
        if (pDuplexOption && pDuplexOption->dwDuplexID == DMDUP_SIMPLEX)
        {
            pDuplexOption = PGetIndexedOption(pUiData->ci.pUIInfo, pDuplexFeature, 0);

            for (dwCount = 0 ; dwCount < pDuplexFeature->Options.dwCount; dwCount++)
            {
                if (pDuplexOption->dwDuplexID != DMDUP_SIMPLEX)
                {
                    pDuplexItem->Sel = dwCount;
                    pDuplexItem->Flags |= OPTIF_CHANGED;
                    VUpdateOptionsArrayWithSelection(pUiData, pDuplexItem);
                    break;
                }
                pDuplexOption++;
            }

        }
    }
    else if ((GETUSERDATAITEM(pCurItem->UserData) == DUPLEX_ITEM) &&
             pDuplexOption)
    {
        if (pDuplexOption->dwDuplexID == DMDUP_SIMPLEX &&
            pNupItem &&
            pNupItem->Sel == BOOKLET_UP)
        {
            pNupItem->Sel = TWO_UP;
            pNupItem->Flags |= OPTIF_CHANGED;
            NUPOPTION(pdmExtra) = TWO_UP;
        }
    }
}


#ifdef UNIDRV

VOID
VSyncColorInformation(
    PUIDATA     pUiData,
    POPTITEM    pCurItem
    )

/*++

Routine Description:

Arguments:


Return Value:


--*/

{
    POPTITEM    pOptItem;
    PFEATURE    pFeature;

    //
    // This is a hack to work around the fact that Unidrv has
    // two color options, color appearance and color mode option,
    // need to update the other once one is changed
    //

    pOptItem = (GETUSERDATAITEM(pCurItem->UserData) == COLOR_ITEM) ?
                    PFindOptItemWithUserData(pUiData, COLORMODE_ITEM) :
                    (GETUSERDATAITEM(pCurItem->UserData) == COLORMODE_ITEM) ?
                        PFindOptItemWithUserData(pUiData, COLOR_ITEM) : NULL;

    if ((pOptItem != NULL) &&
        (pFeature = GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_COLORMODE)))
    {
        DWORD    dwFeature = GET_INDEX_FROM_FEATURE(pUiData->ci.pUIInfo, pFeature);

        //
        // Find either color appearance or color mode option
        //

        if (GETUSERDATAITEM(pCurItem->UserData) == COLOR_ITEM)
        {
            ChangeOptionsViaID(
                    pUiData->ci.pInfoHeader,
                    pUiData->ci.pCombinedOptions,
                    GID_COLORMODE,
                    pUiData->ci.pdm);

            pOptItem->Sel = pUiData->ci.pCombinedOptions[dwFeature].ubCurOptIndex;
            pOptItem->Flags |= OPTIF_CHANGED;
        }
        else // COLORMODE_ITEM
        {
            POPTION pColorMode;
            PCOLORMODEEX pColorModeEx;

            pColorMode = PGetIndexedOption(
                                    pUiData->ci.pUIInfo,
                                    pFeature,
                                    pCurItem->Sel);

            if (pColorMode)
            {
                pColorModeEx = OFFSET_TO_POINTER(
                                    pUiData->ci.pInfoHeader,
                                    pColorMode->loRenderOffset);

                if (pColorModeEx)
                {
                    pOptItem->Sel = pColorModeEx->bColor ? 1: 0;

                    VUnpackDocumentPropertiesItems(pUiData, pOptItem, 1);

                    pOptItem->Flags |= OPTIF_CHANGED;
                }
                else
                {
                    ERR(("pColorModeEx is NULL\n"));
                }
            }
            else
            {
                ERR(("pColorMode is NULL\n"));
            }
        }
    }
}

DWORD
DwGetItemFromGID(
    PFEATURE    pFeature
    )

/*++

Routine Description:

Arguments:


Return Value:


--*/

{
    DWORD   dwItem = 0;

    switch (pFeature->dwFeatureID)
    {
    case GID_PAGESIZE:
        dwItem = FORMNAME_ITEM;
        break;

    case GID_DUPLEX:
        dwItem =  DUPLEX_ITEM;
        break;

    case GID_RESOLUTION:
        dwItem = RESOLUTION_ITEM;
        break;

    case GID_MEDIATYPE:
        dwItem = MEDIATYPE_ITEM;
        break;

    case GID_INPUTSLOT:
        dwItem = INPUTSLOT_ITEM;
        break;

    case GID_COLORMODE:
        dwItem = COLORMODE_ITEM;
        break;

    case GID_ORIENTATION:
        dwItem = ORIENTATION_ITEM;
        break;

    case GID_PAGEPROTECTION:
        dwItem = PAGE_PROTECT_ITEM;
        break;

    case GID_COLLATE:
        dwItem = COPIES_COLLATE_ITEM;
        break;

    case GID_HALFTONING:
        dwItem =  HALFTONING_ITEM;
        break;

    default:
        dwItem = UNKNOWN_ITEM;
        break;
    }

    return dwItem;
}


PLISTNODE
PGetMacroList(
    PUIDATA     pUiData,
    POPTITEM    pMacroItem,
    PGPDDRIVERINFO pDriverInfo
    )

/*++

Routine Description:

Arguments:


Return Value:


--*/

{

    PUIINFO         pUIInfo = pUiData->ci.pUIInfo;
    PLISTNODE       pListNode = NULL;
    LISTINDEX       liIndex;

    if (pMacroItem)
    {
        switch(pMacroItem->Sel)
        {
            case QS_BEST:
                liIndex = pUIInfo->liBestQualitySettings;
                break;

            case QS_DRAFT:
                liIndex = pUIInfo->liDraftQualitySettings;
                break;

            case QS_BETTER:
                liIndex = pUIInfo->liBetterQualitySettings;
                break;
        }

        pListNode = LISTNODEPTR(pDriverInfo, liIndex);

    }

    return pListNode;

}

VOID
VUpdateQualitySettingOptions(
    PUIINFO     pUIInfo,
    POPTITEM    pQualityItem
    )

/*++

Routine Description:

Arguments:


Return Value:


--*/
{
    POPTPARAM pParam;
    LISTINDEX liList;
    DWORD     i;

    pParam = pQualityItem->pOptType->pOptParam;

    for (i = QS_BEST; i < QS_BEST + MAX_QUALITY_SETTINGS; i++)
    {
        switch(i)
        {
            case QS_BEST:
                liList = pUIInfo->liBestQualitySettings;
                break;

            case QS_BETTER:
                liList = pUIInfo->liBetterQualitySettings;
                break;

            case QS_DRAFT:
                liList = pUIInfo->liDraftQualitySettings;
                break;

        }

        if (liList == END_OF_LIST)
        {
            pParam->Flags |= OPTPF_DISABLED;
            pParam->dwReserved[0] = TRUE;

        }
        else
        {
            pParam->Flags &= ~OPTPF_DISABLED;
            pParam->dwReserved[0] = FALSE;

        }
        pParam++;
    }
    pQualityItem->Flags |= OPTIF_CHANGED;
}


VOID
VMakeMacroSelections(
    PUIDATA     pUiData,
    POPTITEM    pCurItem
    )

/*++

Routine Description:

Arguments:


Return Value:


--*/
{
    DWORD       dwFeatureID, dwOptionID, dwItem, i;
    PUIINFO     pUIInfo;
    POPTITEM    pMacroItem, pOptItem;
    PFEATURE    pFeature;
    PLISTNODE   pListNode;
    PGPDDRIVERINFO  pDriverInfo;
    BOOL        bMatchFound = FALSE;

    //
    // Mark options array with the change to either
    // Macro selection, media type, color
    //
    // Update binary data
    // Make selection
    //

    if (pUiData->ci.pdmPrivate->dwFlags & DXF_CUSTOM_QUALITY)
        return;


    if (pCurItem)
        VUnpackDocumentPropertiesItems(pUiData, pCurItem, 1);

    pMacroItem = PFindOptItemWithUserData(pUiData, QUALITY_SETTINGS_ITEM);

    //
    // BUpdateUIInfo calls UpdateBinaryData to get new snapshot
    // for latest optionarray
    //

    if (pMacroItem == NULL || !BUpdateUIInfo(&pUiData->ci) )
        return;

    pUIInfo = pUiData->ci.pUIInfo;

    pDriverInfo = OFFSET_TO_POINTER(pUiData->ci.pInfoHeader,
                                    pUiData->ci.pInfoHeader->loDriverOffset);

    //
    // Update the macro selection to reflect the current default
    //

    if (pCurItem && GETUSERDATAITEM(pCurItem->UserData) != QUALITY_SETTINGS_ITEM)
    {
        ASSERT(pUIInfo->defaultQuality != END_OF_LIST);

        if (pUIInfo->defaultQuality == END_OF_LIST)
            return;

        pMacroItem->Sel = pUIInfo->defaultQuality;
        VUnpackDocumentPropertiesItems(pUiData, pMacroItem, 1);
        pMacroItem->Flags |= OPTIF_CHANGED;

    }

    //
    // Determine which item to gray out based on the
    // liBestQualitySettings, liBetterQualitySettings, liDraftQualitySettings
    //

    VUpdateQualitySettingOptions(pUIInfo, pMacroItem);

    pListNode = PGetMacroList(pUiData, pMacroItem, pDriverInfo);

    //
    // Make the selction of Feature.Option
    //

    while (pListNode)
    {
        //
        // Search thru our list of OPTITEM for the matching
        // Feature
        //

        pOptItem = pUiData->pDrvOptItem;
        dwFeatureID = ((PQUALNAME)(&pListNode->dwData))->wFeatureID;
        dwOptionID  = ((PQUALNAME)(&pListNode->dwData))->wOptionID;

        pFeature =  (PFEATURE)((PBYTE)pUIInfo->pInfoHeader + pUIInfo->loFeatureList) + dwFeatureID;
        dwItem = DwGetItemFromGID(pFeature);

        for (i = 0; i < pUiData->dwDrvOptItem; i++)
        {
            if (ISPRINTERFEATUREITEM(pOptItem->UserData))
            {
                PFEATURE pPrinterFeature = (PFEATURE)GETUSERDATAITEM(pOptItem->UserData);

                if (GET_INDEX_FROM_FEATURE(pUIInfo, pPrinterFeature) == dwFeatureID)
                    bMatchFound = TRUE;
            }
            else
            {
                if (dwItem != UNKNOWN_ITEM &&
                    dwItem == GETUSERDATAITEM(pOptItem->UserData))
                    bMatchFound = TRUE;
            }

            if (bMatchFound)
            {
                pOptItem->Sel = dwOptionID;
                pOptItem->Flags |= OPTIF_CHANGED;
                VUnpackDocumentPropertiesItems(pUiData, pOptItem, 1);
                bMatchFound = FALSE;
                break;
            }

            pOptItem++;
        }

        pListNode = LISTNODEPTR(pDriverInfo, pListNode->dwNextItem);
    }

}

VOID
VUpdateMacroSelection(
    PUIDATA     pUiData,
    POPTITEM    pCurItem
    )

/*++

Routine Description:

Arguments:


Return Value:


--*/

{

    DWORD           dwFeatureIndex;
    PFEATURE        pFeature = NULL;
    PLISTNODE       pListNode;
    POPTITEM        pMacroItem;
    PGPDDRIVERINFO  pDriverInfo;

    pMacroItem = PFindOptItemWithUserData(pUiData, QUALITY_SETTINGS_ITEM);

    if (pMacroItem == NULL)
        return;

    pDriverInfo = OFFSET_TO_POINTER(pUiData->ci.pInfoHeader,
                                    pUiData->ci.pInfoHeader->loDriverOffset);

    if (!(pFeature = PGetFeatureFromItem(pUiData->ci.pUIInfo, pCurItem, &dwFeatureIndex)))
        return;

    ASSERT(pDriverInfo);

    pListNode = PGetMacroList(pUiData, pMacroItem, pDriverInfo);

    while (pListNode)
    {
        if ( ((PQUALNAME)(&pListNode->dwData))->wFeatureID == (WORD)dwFeatureIndex)
        {
            pMacroItem->Flags |= OPTIF_ECB_CHECKED;
            _VUnpackDocumentOptions(pMacroItem, pUiData->ci.pdm);
            break;
        }

        pListNode = LISTNODEPTR(pDriverInfo, pListNode->dwNextItem);
    }
}

#endif //UNIDRV
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\commonui.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    commonui.c

Abstract:

    This file contains all the functions related to preparing data for
    CPSUI.  This includes packing data items for printer property sheets and
    document property sheets.

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/13/97 -davidx-
        Common function to handle well-known and generic printer features.

    02/10/97 -davidx-
        Consistent handling of common printer info.

    02/04/97 -davidx-
        Reorganize driver UI to separate ps and uni DLLs.

    09/12/96 -amandan-
        Created it.

--*/

#include "precomp.h"


PCOMPROPSHEETUI
PPrepareDataForCommonUI(
    IN OUT PUIDATA  pUiData,
    IN PDLGPAGE     pDlgPage
    )

/*++

Routine Description:

    Allocate memory and partially fill out the data structures required
    to call common UI routine. Once all information in pUiData are
    initialized properly, it calls PackDocumentPropertyItems() or
    PackPrinterPropertyItems() to pack the option items.

Arguments:

    pUiData - Pointer to our UIDATA structure
    pDlgPage - Pointer to dialog pages

Return Value:

    Pointer to a COMPROPSHEETUI structure, NULL if there is an error

--*/

{
    PCOMPROPSHEETUI pCompstui;
    DWORD           dwCount, dwIcon, dwOptItemCount, dwSize;
    PCOMMONINFO     pci = (PCOMMONINFO) pUiData;
    HANDLE          hHeap = pUiData->ci.hHeap;
    BOOL            (*pfnPackItemProc)(PUIDATA);
    POPTITEM        pOptItem;
    PBYTE           pUserData;

    //
    // Enumerate form names supported on the printer
    //

    dwCount = DwEnumPaperSizes(pci, NULL, NULL, NULL, NULL, UNUSED_PARAM);

    if (dwCount != GDI_ERROR && dwCount != 0)
    {
        pUiData->dwFormNames = dwCount;

        pUiData->pFormNames = HEAPALLOC(hHeap, dwCount * sizeof(WCHAR) * CCHPAPERNAME);
        pUiData->pwPapers = HEAPALLOC(hHeap, dwCount * sizeof(WORD));
        pUiData->pwPaperFeatures = HEAPALLOC(hHeap, dwCount * sizeof(WORD));
    }

    if (!pUiData->pFormNames || !pUiData->pwPapers || !pUiData->pwPaperFeatures)
        return NULL;

    (VOID) DwEnumPaperSizes(
                    pci,
                    pUiData->pFormNames,
                    pUiData->pwPapers,
                    NULL,
                    pUiData->pwPaperFeatures,
                    UNUSED_PARAM);

    #ifdef PSCRIPT

    //
    // We don't need to keep information about spooler forms
    // after this point. So dispose of it to free up memory.
    //

    MemFree(pUiData->ci.pSplForms);
    pUiData->ci.pSplForms = NULL;
    pUiData->ci.dwSplForms = 0;

    #endif

    //
    // Enumerate input bin names supported on the printer
    //

    dwCount = DwEnumBinNames(pci, NULL);

    if (dwCount != GDI_ERROR)
    {
        pUiData->dwBinNames = dwCount;
        pUiData->pBinNames = HEAPALLOC(hHeap, dwCount * sizeof(WCHAR) * CCHBINNAME);
    }

    if (! pUiData->pBinNames)
        return NULL;

    //
    // Don't need to check return here
    //

    DwEnumBinNames(pci, pUiData->pBinNames);

    //
    // Allocate memory to hold various data structures
    //

    if (! (pCompstui = HEAPALLOC(hHeap, sizeof(COMPROPSHEETUI))))
        return NULL;

    memset(pCompstui, 0, sizeof(COMPROPSHEETUI));

    //
    // Initialize COMPROPSHEETUI structure
    //

    pCompstui->cbSize = sizeof(COMPROPSHEETUI);
    pCompstui->UserData = (ULONG_PTR) pUiData;
    pCompstui->pDlgPage = pDlgPage;
    pCompstui->cDlgPage = 0;

    pCompstui->hInstCaller = ghInstance;
    pCompstui->pCallerName = _PwstrGetCallerName();
    pCompstui->pOptItemName = pUiData->ci.pDriverInfo3->pName;
    pCompstui->CallerVersion = gwDriverVersion;
    pCompstui->OptItemVersion = 0;

    dwIcon = pUiData->ci.pUIInfo->loPrinterIcon;

    if (dwIcon && (pCompstui->IconID = HLoadIconFromResourceDLL(&pUiData->ci, dwIcon)))
        pCompstui->Flags |= CPSUIF_ICONID_AS_HICON;
    else
        pCompstui->IconID = _DwGetPrinterIconID();

    if (HASPERMISSION(pUiData))
        pCompstui->Flags |= CPSUIF_UPDATE_PERMISSION;

    pCompstui->Flags |= CPSUIF_ABOUT_CALLBACK;


    pCompstui->pHelpFile = pUiData->ci.pDriverInfo3->pHelpFile;

    //
    // Call either PackDocumentPropertyItems or PackPrinterPropertyItems
    // to get the number of items and types.
    //

    pfnPackItemProc = (pUiData->iMode == MODE_DOCUMENT_STICKY) ?
                            BPackDocumentPropertyItems :
                            BPackPrinterPropertyItems;

    pUiData->dwOptItem = 0;
    pUiData->pOptItem = NULL;
    pUiData->dwOptType = 0;
    pUiData->pOptType = NULL;

    if (! pfnPackItemProc(pUiData))
    {
        ERR(("Error while packing OPTITEM's\n"));
        return NULL;
    }

    //
    // Allocate memory to hold OPTITEMs and OPTTYPEs
    //

    ASSERT(pUiData->dwOptItem > 0);
    VERBOSE(("Number of  OPTTYPE's: %d\n", pUiData->dwOptType));
    VERBOSE(("Number of OPTITEM's: %d\n", pUiData->dwOptItem));

    pUiData->pOptItem = HEAPALLOC(hHeap, sizeof(OPTITEM) * pUiData->dwOptItem);
    pUiData->pOptType = HEAPALLOC(hHeap, sizeof(OPTTYPE) * pUiData->dwOptType);
    pUserData = HEAPALLOC(hHeap, sizeof(USERDATA)* pUiData->dwOptItem);

    if (!pUiData->pOptItem || !pUiData->pOptType || !pUserData)
        return NULL;

    //
    // Initializes OPTITEM.USERDATA
    //

    pOptItem = pUiData->pOptItem;
    dwOptItemCount = pUiData->dwOptItem;
    dwSize = sizeof(USERDATA);

    while (dwOptItemCount--)
    {

        pOptItem->UserData = (ULONG_PTR)pUserData;

        SETUSERDATA_SIZE(pOptItem, dwSize);

        pUserData += sizeof(USERDATA);
        pOptItem++;

    }

    pUiData->pDrvOptItem = pUiData->pOptItem;
    pCompstui->pOptItem = pUiData->pDrvOptItem;
    pCompstui->cOptItem = (WORD) pUiData->dwOptItem;

    pUiData->dwOptItem = pUiData->dwOptType = 0;

    //
    // Call either PackDocumentPropertyItems or PackPrinterPropertyItems
    // to build the OPTITEMs list
    //

    if (! pfnPackItemProc(pUiData))
    {
        ERR(("Error while packing OPTITEM's\n"));
        return NULL;
    }

    return pCompstui;
}



VOID
VPackOptItemGroupHeader(
    IN OUT PUIDATA  pUiData,
    IN DWORD        dwTitleId,
    IN DWORD        dwIconId,
    IN DWORD        dwHelpIndex
    )

/*++

Routine Description:

    Fill out a OPTITEM to be used as a header for a group of items

Arguments:

    pUiData - Points to UIDATA structure
    dwTitleId - String resource ID for the item title
    dwIconId - Icon resource ID
    dwHelpIndex - Help index

Return Value:

    NONE

--*/

{
    if (pUiData->pOptItem)
    {
        pUiData->pOptItem->cbSize = sizeof(OPTITEM);
        pUiData->pOptItem->pOptType = NULL;
        pUiData->pOptItem->pName = (PWSTR)ULongToPtr(dwTitleId);
        pUiData->pOptItem->Level = TVITEM_LEVEL1;
        pUiData->pOptItem->DMPubID = DMPUB_NONE;
        pUiData->pOptItem->Sel = dwIconId;
        //pUiData->pOptItem->UserData = 0;
        pUiData->pOptItem->HelpIndex = dwHelpIndex;
        pUiData->pOptItem++;
    }

    pUiData->dwOptItem++;
}



BOOL
BPackOptItemTemplate(
    IN OUT PUIDATA  pUiData,
    IN CONST WORD   pwItemInfo[],
    IN DWORD        dwSelection,
    IN PFEATURE     pFeature
    )

/*++

Routine Description:

    Fill out an OPTITEM and an OPTTYPE structure using a template

Arguments:

    pUiData - Points to UIDATA structure
    pwItemInfo - Pointer to item template
    dwSelection - Current item selection
    pFeature - Pointer to FEATURE

Return Value:

    TRUE if successful, FALSE otherwise

Note:

    The item template is a variable size WORD array:
        0: String resource ID of the item title
        1: Item level in the tree view (TVITEM_LEVELx)
        2: Public devmode field ID (DMPUB_xxx)
        3: User data
        4: Help index
        5: Number of OPTPARAMs for this item
        6: Item type (TVOT_xxx)
        Three words for each OPTPARAM:
            Size of OPTPARAM
            String resource ID for parameter data
            Icon resource ID
        Last word must be ITEM_INFO_SIGNATURE

    Both OPTITEM and OPTTYPE structures are assumed to be zero-initialized.

--*/

{
    POPTITEM pOptItem;
    POPTPARAM pOptParam;
    WORD wOptParam;
    POPTTYPE pOptType = pUiData->pOptType;


    if ((pOptItem = pUiData->pOptItem) != NULL)
    {
        FILLOPTITEM(pOptItem,
                    pUiData->pOptType,
                    ULongToPtr(pwItemInfo[0]),
                    ULongToPtr(dwSelection),
                    (BYTE) pwItemInfo[1],
                    (BYTE) pwItemInfo[2],
                    pwItemInfo[3],
                    pwItemInfo[4]
                    );

        wOptParam = pwItemInfo[5];
        pOptParam = PFillOutOptType(pUiData->pOptType,
                                    pwItemInfo[6],
                                    wOptParam,
                                    pUiData->ci.hHeap);

        if (pOptParam == NULL)
            return FALSE;

        pwItemInfo += 7;
        while (wOptParam--)
        {
            pOptParam->cbSize = sizeof(OPTPARAM);
            pOptParam->pData = (PWSTR) *pwItemInfo++;
            pOptParam->IconID = *pwItemInfo++;
            pOptParam++;
        }

        ASSERT(*pwItemInfo == ITEM_INFO_SIGNATURE);

        if (pFeature)
        {
            SETUSERDATA_KEYWORDNAME(pUiData->ci, pOptItem, pFeature);

            #ifdef UNIDRV

            if (pUiData->ci.pUIInfo->loHelpFileName &&
                pFeature->iHelpIndex != UNUSED_ITEM )
            {
                //
                // Allocate memory for OIEXT
                //

                POIEXT  pOIExt = HEAPALLOC(pUiData->ci.hHeap, sizeof(OIEXT));

                if (pOIExt)
                {
                    pOIExt->cbSize = sizeof(OIEXT);
                    pOIExt->Flags = 0;
                    pOIExt->hInstCaller = NULL;
                    pOIExt->pHelpFile = OFFSET_TO_POINTER(pUiData->ci.pUIInfo->pubResourceData,
                                                          pUiData->ci.pUIInfo->loHelpFileName);
                    pOptItem->pOIExt = pOIExt;
                    pOptItem->HelpIndex = pFeature->iHelpIndex;
                    pOptItem->Flags |= OPTIF_HAS_POIEXT;
                }

            }
            #endif // UNIDRV
        }
        pUiData->pOptItem++;
        pUiData->pOptType++;
    }

    pUiData->dwOptItem++;
    pUiData->dwOptType++;

    return TRUE;
}



BOOL
BPackUDArrowItemTemplate(
    IN OUT PUIDATA  pUiData,
    IN CONST WORD   pwItemInfo[],
    IN DWORD        dwSelection,
    IN DWORD        dwMaxVal,
    IN PFEATURE     pFeature
    )

/*++

Routine Description:

    Pack an updown arrow item using the specified template

Arguments:

    pUiData, pwItemInfo, dwSelection - same as for BPackOptItemTemplate
    dwMaxVal - maximum value for the updown arrow item

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    POPTTYPE pOptType = pUiData->pOptType;

    if (! BPackOptItemTemplate(pUiData, pwItemInfo, dwSelection, pFeature))
        return FALSE;

    if (pOptType)
        pOptType->pOptParam[1].lParam = dwMaxVal;

    return TRUE;
}



POPTPARAM
PFillOutOptType(
    OUT POPTTYPE    pOptType,
    IN  DWORD       dwType,
    IN  DWORD       dwParams,
    IN  HANDLE      hHeap
    )

/*++

Routine Description:

    Fill out an OPTTYPE structure

Arguments:

    pOpttype - Pointer to OPTTYPE structure to be filled out
    wType - Value for OPTTYPE.Type field
    wParams - Number of OPTPARAM's
    hHeap - Handle to a heap from which to allocate

Return Value:

    Pointer to OPTPARAM array if successful, NULL otherwise

--*/

{
    POPTPARAM pOptParam;

    pOptType->cbSize = sizeof(OPTTYPE);
    pOptType->Count = (WORD) dwParams;
    pOptType->Type = (BYTE) dwType;

    pOptParam = HEAPALLOC(hHeap, sizeof(OPTPARAM) * dwParams);

    if (pOptParam != NULL)
        pOptType->pOptParam = pOptParam;
    else
        ERR(("Memory allocation failed\n"));

    return pOptParam;
}


BOOL
BShouldDisplayGenericFeature(
    IN PFEATURE     pFeature,
    IN BOOL         bPrinterSticky
    )

/*++

Routine Description:

    Determine whether a printer feature should be displayed
    as a generic feature

Arguments:

    pFeature - Points to a FEATURE structure
    pPrinterSticky - Whether the feature is printer-sticky or doc-sticky

Return Value:

    TRUE if the feature should be displayed as a generic feature
    FALSE if it should not be

--*/

{
    //
    // Check if the feature is specified marked as non-displayable
    // and make sure the feature type is appropriate
    //

    if ((pFeature->dwFlags & FEATURE_FLAG_NOUI) ||
        (bPrinterSticky &&
         pFeature->dwFeatureType != FEATURETYPE_PRINTERPROPERTY) ||
        (!bPrinterSticky &&
         pFeature->dwFeatureType != FEATURETYPE_DOCPROPERTY &&
         pFeature->dwFeatureType != FEATURETYPE_JOBPROPERTY))
    {
        return FALSE;
    }

    //
    // Exclude those features which are explicitly handled
    // and also those which don't have any options
    //

    return (pFeature->Options.dwCount >= MIN_OPTIONS_ALLOWED) &&
           (pFeature->dwFeatureID == GID_UNKNOWN ||
            pFeature->dwFeatureID == GID_OUTPUTBIN ||
            pFeature->dwFeatureID == GID_MEMOPTION);
}



DWORD
DwCountDisplayableGenericFeature(
    IN PUIDATA      pUiData,
    BOOL            bPrinterSticky
    )

/*++

Routine Description:

    Count the number of features which can be displayed
    as generic features

Arguments:

    pUiData - Points to UIDATA structure
    pPrinterSticky - Whether the feature is printer-sticky or doc-sticky

Return Value:

    Number of features which can be displayed as generic features

--*/

{
    PFEATURE pFeature;
    DWORD    dwFeature, dwCount = 0;

    pFeature = PGetIndexedFeature(pUiData->ci.pUIInfo, 0);
    dwFeature = pUiData->ci.pRawData->dwDocumentFeatures +
                pUiData->ci.pRawData->dwPrinterFeatures;

    if (pFeature && dwFeature)
    {
        for ( ; dwFeature--; pFeature++)
        {
            if (BShouldDisplayGenericFeature(pFeature, bPrinterSticky))
                dwCount++;
        }
    }

    return dwCount;
}



DWORD
DwGuessOptionIconID(
    PUIINFO     pUIInfo,
    PFEATURE    pFeature,
    POPTION     pOption
    )

/*++

Routine Description:

    Try to make an intelligent guess as to what icon
    to use for a generic printer feature option

Arguments:

    pUIInfo - Points to UIINFO structure
    pFeature - Points to the feature in question
    pOption - Points to the option in question

Return Value:

    Icon resource ID appropriate for the feature option

--*/

{
    DWORD   dwIconID, iRes;

    switch (pFeature->dwFeatureID)
    {
    case GID_RESOLUTION:

        iRes = max(((PRESOLUTION) pOption)->iXdpi, ((PRESOLUTION) pOption)->iYdpi);

        if (iRes <= 150)
            dwIconID = IDI_CPSUI_RES_DRAFT;
        else if (iRes <= 300)
            dwIconID = IDI_CPSUI_RES_LOW;
        else if (iRes <= 600)
            dwIconID = IDI_CPSUI_RES_MEDIUM;
        else if (iRes <= 900)
            dwIconID = IDI_CPSUI_RES_HIGH;
        else
            dwIconID = IDI_CPSUI_RES_PRESENTATION;

        break;

    case GID_DUPLEX:

        switch (((PDUPLEX) pOption)->dwDuplexID)
        {
        case DMDUP_VERTICAL:
            dwIconID = IDI_CPSUI_DUPLEX_VERT;
            break;

        case DMDUP_HORIZONTAL:
            dwIconID = IDI_CPSUI_DUPLEX_HORZ;
            break;

        default:
            dwIconID = IDI_CPSUI_DUPLEX_NONE;
            break;
        }
        break;

    case GID_ORIENTATION:

        switch (((PORIENTATION) pOption)->dwRotationAngle)
        {
        case ROTATE_270:
            dwIconID = IDI_CPSUI_LANDSCAPE;
            break;

        case ROTATE_90:
            dwIconID = IDI_CPSUI_ROT_LAND;
            break;

        default:
            dwIconID = IDI_CPSUI_PORTRAIT;
            break;
        }
        break;

    case GID_INPUTSLOT:
        dwIconID = IDI_CPSUI_PAPER_TRAY;
        break;

    case GID_PAGEPROTECTION:
        dwIconID = IDI_CPSUI_PAGE_PROTECT;
        break;

    default:
        dwIconID = IDI_CPSUI_GENERIC_OPTION;
        break;
    }

    return dwIconID;
}



BOOL
BPackItemPrinterFeature(
    PUIDATA     pUiData,
    PFEATURE    pFeature,
    DWORD       dwLevel,
    DWORD       dwPub,
    ULONG_PTR    dwUserData,
    DWORD       dwHelpIndex
    )

/*++

Routine Description:

    Pack a single printer feature item

Arguments:

    pUiData - Points to UIDATA structure
    pFeature - Points to the printer feature to be packed
    dwLevel - Treeview item level
    dwPub - DMPUB_ identifier
    dwUserData - User data to be associated with the item
    dwHelpIndex - Help index to be associated with the item

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD       dwCount, dwIndex;
    DWORD       dwFeature, dwSel;
    POPTION     pOption;
    POPTTYPE    pOptTypeHack;
    POPTPARAM   pOptParam;
    PCOMMONINFO pci;

    if (pFeature == NULL ||
        (pFeature->dwFlags & FEATURE_FLAG_NOUI) ||
        (dwCount = pFeature->Options.dwCount) < MIN_OPTIONS_ALLOWED)
        return TRUE;

    //
    // HACK: for Orientation and Duplex feature
    //  They must be of type TVOT_2STATES or TVOT_3STATES.
    //  If not, compstui will get confused.
    //

    if (dwPub == DMPUB_ORIENTATION || dwPub == DMPUB_DUPLEX)
    {
        if (dwCount != 2 && dwCount != 3)
        {
            WARNING(("Unexpected number of Orientation/Duplex options\n"));
            return TRUE;
        }

        pOptTypeHack = pUiData->pOptType;
    }
    else
        pOptTypeHack = NULL;

    pUiData->dwOptItem++;
    pUiData->dwOptType++;

    if (pUiData->pOptItem == NULL)
        return TRUE;

    //
    // Find out the current selection first
    // DCR: needs to support PICKMANY
    //

    pci = (PCOMMONINFO) pUiData;
    dwFeature = GET_INDEX_FROM_FEATURE(pci->pUIInfo, pFeature);
    dwSel = pci->pCombinedOptions[dwFeature].ubCurOptIndex;

    if (dwSel >= dwCount)
        dwSel = 0;

    //
    // If we are in this function, we must have already successfully
    // called function PFillUiData(), where the pci->hHeap is created.
    //

    ASSERT(pci->hHeap != NULL);

    //
    // Fill in the OPTITEM structure
    //

    FILLOPTITEM(pUiData->pOptItem,
                pUiData->pOptType,
                PGetReadOnlyDisplayName(pci, pFeature->loDisplayName),
                ULongToPtr(dwSel),
                dwLevel,
                dwPub,
                dwUserData,
                dwHelpIndex);

    #ifdef UNIDRV
    //
    // Supports OEM help file. If  helpfile and helpindex are defined,
    // we will use the help id specified by the GPD.  According to GPD spec,
    // zero loHelpFileName means no help file name specified.
    //

    if (pci->pUIInfo->loHelpFileName &&
        pFeature->iHelpIndex != UNUSED_ITEM )
    {
        //
        // Allocate memory for OIEXT
        //

        POIEXT  pOIExt = HEAPALLOC(pci->hHeap, sizeof(OIEXT));

        if (pOIExt)
        {
            pOIExt->cbSize = sizeof(OIEXT);
            pOIExt->Flags = 0;
            pOIExt->hInstCaller = NULL;
            pOIExt->pHelpFile = OFFSET_TO_POINTER(pci->pUIInfo->pubResourceData,
                                                  pci->pUIInfo->loHelpFileName);
            pUiData->pOptItem->pOIExt = pOIExt;
            pUiData->pOptItem->HelpIndex = pFeature->iHelpIndex;
            pUiData->pOptItem->Flags |= OPTIF_HAS_POIEXT;
        }

    }
    #endif // UNIDRV

    pOptParam = PFillOutOptType(pUiData->pOptType, TVOT_LISTBOX, dwCount, pci->hHeap);

    if (pOptParam == NULL)
        return FALSE;

    if (pOptTypeHack)
        pOptTypeHack->Type = (dwCount == 2) ? TVOT_2STATES : TVOT_3STATES;

    //
    // Get the list of options for this features
    //

    for (dwIndex=0; dwIndex < dwCount; dwIndex++, pOptParam++)
    {
        //
        // Fill in the options name
        //

        pOption = PGetIndexedOption(pci->pUIInfo, pFeature, dwIndex);
        ASSERT(pOption != NULL);

        pOptParam->cbSize = sizeof(OPTPARAM);
        pOptParam->pData = GET_OPTION_DISPLAY_NAME(pci, pOption);

        //
        // Try to figure out the appropriate icon to use
        //  If the icon comes from the resource DLL, we need to load
        //  it ourselves and give compstui an HICON. Otherwise,
        //  we try to figure out the appropriate icon resource ID.
        //

        if (pOption->loResourceIcon &&
            (pOptParam->IconID = HLoadIconFromResourceDLL(pci, pOption->loResourceIcon)))
        {
            pOptParam->Flags |= OPTPF_ICONID_AS_HICON;
        }
        else
            pOptParam->IconID = DwGuessOptionIconID(pci->pUIInfo, pFeature, pOption);
    }

    //
    // Set the Keyword name for pOptItem->UserData
    //

    SETUSERDATA_KEYWORDNAME(pUiData->ci, pUiData->pOptItem, pFeature);

    pUiData->pOptItem++;
    pUiData->pOptType++;
    return TRUE;
}



BOOL
BPackItemGenericOptions(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack generic printer features items (doc-sticky or printer-sticky)

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    //
    // Extended push button for restoring to default feature selections
    //

    static EXTPUSH  ExtPush =
    {
        sizeof(EXTPUSH),
        EPF_NO_DOT_DOT_DOT,
        (PWSTR) IDS_RESTORE_DEFAULTS,
        NULL,
        0,
        0,
    };

    POPTITEM    pOptItem;
    DWORD       dwHelpIndex, dwIconId;
    PFEATURE    pFeatures;
    DWORD       dwFeatures;
    BOOL        bPrinterSticky;

    //
    // If there are no generic features to display, simply return success
    //

    bPrinterSticky = (pUiData->iMode == MODE_PRINTER_STICKY);

    if (DwCountDisplayableGenericFeature(pUiData, bPrinterSticky) == 0)
        return TRUE;

    //
    // Add the group header item
    //

    pOptItem = pUiData->pOptItem;

    if (bPrinterSticky)
    {
        VPackOptItemGroupHeader(
                pUiData,
                IDS_INSTALLABLE_OPTIONS,
                IDI_CPSUI_INSTALLABLE_OPTION,
                HELP_INDEX_INSTALLABLE_OPTIONS);
    }
    else
    {
        VPackOptItemGroupHeader(
                pUiData,
                IDS_PRINTER_FEATURES,
                IDI_CPSUI_PRINTER_FEATURE,
                HELP_INDEX_PRINTER_FEATURES);
    }

    if (pOptItem != NULL && !bPrinterSticky)
    {
        //
        // "Restore Defaults" button
        //

        pUiData->pFeatureHdrItem = pOptItem;
        pOptItem->Flags |= (OPTIF_EXT_IS_EXTPUSH|OPTIF_CALLBACK);
        pOptItem->pExtPush = &ExtPush;
    }

    pOptItem = pUiData->pOptItem;

    //
    // Figure out the correct help index and icon ID
    // depending on whether we're dealing with printer-sticky
    // features or document-sticky printer features
    //

    if (bPrinterSticky)
    {
        dwHelpIndex = HELP_INDEX_INSTALLABLE_OPTIONS;
        dwIconId = IDI_CPSUI_INSTALLABLE_OPTION;
    }
    else
    {
        dwHelpIndex = HELP_INDEX_PRINTER_FEATURES;
        dwIconId = IDI_CPSUI_PRINTER_FEATURE;
    }

    //
    // Go through each printer feature
    //

    pFeatures = PGetIndexedFeature(pUiData->ci.pUIInfo, 0);
    dwFeatures = pUiData->ci.pRawData->dwDocumentFeatures +
                 pUiData->ci.pRawData->dwPrinterFeatures;

    ASSERT(pFeatures != NULL);

    for ( ; dwFeatures--; pFeatures++)
    {
        //
        // Don't do anything if it's the feature has no options OR
        // If it's not a generic feature.
        //

        if (BShouldDisplayGenericFeature(pFeatures, bPrinterSticky) &&
            !BPackItemPrinterFeature(pUiData,
                                     pFeatures,
                                     TVITEM_LEVEL2,
                                     DMPUB_NONE,
                                     (ULONG_PTR) pFeatures,
                                     dwHelpIndex))
        {
            return FALSE;
        }
    }

    if (pOptItem != NULL)
    {
        pUiData->pFeatureItems = pOptItem;
        pUiData->dwFeatureItem = (DWORD)(pUiData->pOptItem - pOptItem);
    }

    return TRUE;
}



PFEATURE
PGetFeatureFromItem(
    IN      PUIINFO  pUIInfo,
    IN OUT  POPTITEM pOptItem,
    OUT     PDWORD   pdwFeatureIndex
    )

/*++

Routine Description:

    Get the feature index for a given pOptItem

Arguments:

    pUIInfo - pointer to UIINFO
    pOptItem - pointer to item to look for feature id
    pdwFeatureIndex - pointer to contain the value of returned index

Return Value:

    Pointer to FEATURE structure associated with the item
    NULL if no such feature exists.

--*/

{
    PFEATURE pFeature = NULL;

    //
    // Get the dwFeature, which is the index into pOptionsArray
    //

    if (ISPRINTERFEATUREITEM(pOptItem->UserData))
    {
        //
        // Note: Generic Features contains pointer to feature (pFeature)
        // in pOptItem->UserData
        //

        pFeature = (PFEATURE) GETUSERDATAITEM(pOptItem->UserData);
    }
    else
    {
        DWORD   dwFeatureId;

        switch (GETUSERDATAITEM(pOptItem->UserData))
        {
        case FORMNAME_ITEM:
            dwFeatureId = GID_PAGESIZE;
            break;

        case DUPLEX_ITEM:
            dwFeatureId = GID_DUPLEX;
            break;

        case RESOLUTION_ITEM:
            dwFeatureId = GID_RESOLUTION;
            break;

        case MEDIATYPE_ITEM:
            dwFeatureId = GID_MEDIATYPE;
            break;

        case INPUTSLOT_ITEM:
            dwFeatureId = GID_INPUTSLOT;
            break;

        case FORM_TRAY_ITEM:
            dwFeatureId = GID_INPUTSLOT;
            break;

        case COLORMODE_ITEM:
            dwFeatureId = GID_COLORMODE;
            break;

        case ORIENTATION_ITEM:
            dwFeatureId = GID_ORIENTATION;
            break;

        case PAGE_PROTECT_ITEM:
            dwFeatureId = GID_PAGEPROTECTION;
            break;

        case COPIES_COLLATE_ITEM:
            dwFeatureId = GID_COLLATE;
            break;

        case HALFTONING_ITEM:
            dwFeatureId = GID_HALFTONING;
            break;

        default:
            dwFeatureId = GID_UNKNOWN;
            break;
        }

        if (dwFeatureId != GID_UNKNOWN)
            pFeature = GET_PREDEFINED_FEATURE(pUIInfo, dwFeatureId);
    }

    if (pFeature && pdwFeatureIndex)
        *pdwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);

    return pFeature;
}



VOID
VUpdateOptionsArrayWithSelection(
    IN OUT PUIDATA  pUiData,
    IN POPTITEM     pOptItem
    )

/*++

Routine Description:

    Update the options array with the current selection

Arguments:

    pUiData - Points to UIDATA structure
    pOptItem - Specifies the item whose selection has changed

Return Value:

    NONE

--*/

{
    PFEATURE pFeature;
    DWORD    dwFeatureIndex;

    //
    // Get the feature associated with the current item
    //

    pFeature = PGetFeatureFromItem(pUiData->ci.pUIInfo, pOptItem, &dwFeatureIndex);
    if (pFeature == NULL)
        return;

    if (pOptItem->Sel < 0 || pOptItem->Sel >= (LONG) pFeature->Options.dwCount)
    {
        RIP(("Invalid selection for the current item\n"));
        return;
    }

    ZeroMemory(pUiData->abEnabledOptions, sizeof(pUiData->abEnabledOptions));
    pUiData->abEnabledOptions[pOptItem->Sel] = TRUE;

    ReconstructOptionArray(pUiData->ci.pRawData,
                           pUiData->ci.pCombinedOptions,
                           MAX_COMBINED_OPTIONS,
                           dwFeatureIndex,
                           pUiData->abEnabledOptions);
}



VOID
VMarkSelectionConstrained(
    IN OUT POPTITEM pOptItem,
    IN DWORD        dwIndex,
    IN BOOL         bEnable
    )

/*++

Routine Description:

    Indicate whether a selection is constrained or not

Arguments:

    pOptItem - Pointer to the OPTITEM in question
    pOptParam - Specifies the index of the OPTPARAM in question
    bEnable - Whether the selection is constrained or not
              Enable means not constrained!

Return Value:

    NONE

Note:

    bEnable is the returned value from EnumEnabledOptions,

    bEnable is FALSE if the option is contrained by some
    other feature, selections.

    bEnable is TRUE if the options is not constrained
    by other feature, selections.

--*/

{
    POPTPARAM pOptParam;

    //
    // This function only work on certain types of OPTTYPE
    //

    ASSERT(pOptItem->pOptType->Type == TVOT_2STATES ||
           pOptItem->pOptType->Type == TVOT_3STATES ||
           pOptItem->pOptType->Type == TVOT_LISTBOX ||
           pOptItem->pOptType->Type == TVOT_COMBOBOX);

    pOptParam = pOptItem->pOptType->pOptParam + dwIndex;

    //
    // Set the constrained flag or clear it depending on the latest
    // check with EnumEnabledOptions
    //

    if (!bEnable && ! (pOptParam->Flags & CONSTRAINED_FLAG))
    {
        pOptParam->Flags |= CONSTRAINED_FLAG;
        pOptItem->Flags |= OPTIF_CHANGED;
    }
    else if (bEnable && (pOptParam->Flags & CONSTRAINED_FLAG))
    {
        pOptParam->Flags &= ~CONSTRAINED_FLAG;
        pOptItem->Flags |= OPTIF_CHANGED;
    }

    pOptParam->lParam = (LONG) bEnable;
}



VOID
VPropShowConstraints(
    IN PUIDATA  pUiData,
    IN INT      iMode
    )

/*++

Routine Description:

    Indicate which items are constrained.
    General rule - Any features that has a coresponding an applicable GID or a
    Generic Feature Item, check for constrained.  Ignore all others
    because it's not applicable.

Arguments:

    pUiData - Pointer to our UIDATA structure
    iMode   - MODE_DOCANDPRINTER_STICKY, MODE_PRINTER_STICKY
Return Value:

    NONE
--*/

{
    POPTITEM    pOptItem;
    DWORD       dwOptItem;
    DWORD       dwFeature, dwOption, dwNumOptions, dwIndex;

    #ifdef PSCRIPT

    if (iMode != MODE_PRINTER_STICKY)
    {
        VSyncRevPrintAndOutputOrder(pUiData, NULL);
    }

    #endif // PSCRIPT

    //
    // Go through all the features in the treeview
    //

    pOptItem = pUiData->pDrvOptItem;
    dwOptItem = pUiData->dwDrvOptItem;

    for ( ; dwOptItem--; pOptItem++)
    {

        if (! ISCONSTRAINABLEITEM(pOptItem->UserData) ||
          ! PGetFeatureFromItem(pUiData->ci.pUIInfo, pOptItem, &dwFeature))
        {
            continue;
        }

        //
        // Call the parser to get which options to be disable, or contrained
        // for this feature , so need to gray it out.
        //

        ZeroMemory(pUiData->abEnabledOptions, sizeof(pUiData->abEnabledOptions));

        if (! EnumEnabledOptions(pUiData->ci.pRawData,
                                 pUiData->ci.pCombinedOptions,
                                 dwFeature,
                                 pUiData->abEnabledOptions,
                                 iMode))
        {
            VERBOSE(("EnumEnabledOptions failed\n"));
        }

        //
        // Loop through all options and mark the constraint
        //

        dwNumOptions = pOptItem->pOptType->Count;

        if (GETUSERDATAITEM(pOptItem->UserData) == FORMNAME_ITEM)
        {
            for (dwIndex = 0; dwIndex < dwNumOptions; dwIndex++)
            {
                dwOption = pUiData->pwPaperFeatures[dwIndex];

                if (dwOption == OPTION_INDEX_ANY)
                    continue;

                VMarkSelectionConstrained(pOptItem,
                                          dwIndex,
                                          pUiData->abEnabledOptions[dwOption]);
            }
        }
        else if (GETUSERDATAITEM(pOptItem->UserData) == FORM_TRAY_ITEM)
        {
            if (pOptItem == pUiData->pFormTrayItems)
            {
                POPTITEM pTrayItem;
                PBOOL    pbEnable;

                //
                // Update form-to-tray assignment table items
                //

                pbEnable = pUiData->abEnabledOptions;
                pTrayItem = pUiData->pFormTrayItems;
                dwIndex = pUiData->dwFormTrayItem;

                for ( ; dwIndex--; pTrayItem++, pbEnable++)
                {
                    if (pTrayItem->Flags & OPTIF_HIDE)
                        continue;

                    if (*pbEnable && (pTrayItem->Flags & OPTIF_DISABLED))
                    {
                        pTrayItem->Flags &= ~OPTIF_DISABLED;
                        pTrayItem->Flags |= OPTIF_CHANGED;
                    }
                    else if (!*pbEnable && !(pTrayItem->Flags & OPTIF_DISABLED))
                    {
                        pTrayItem->Flags |= (OPTIF_DISABLED|OPTIF_CHANGED);
                        pTrayItem->Sel = -1;
                    }
                }
            }
        }
        else
        {
            for (dwOption=0; dwOption < dwNumOptions; dwOption++)
            {
                VMarkSelectionConstrained(pOptItem,
                                          dwOption,
                                          pUiData->abEnabledOptions[dwOption]);
            }
        }
    }
}



INT_PTR CALLBACK
BConflictsDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for handle "Conflicts" dialog

Arguments:

    hDlg - Handle to dialog window
    uMsg - Message
    wParam, lParam - Parameters

Return Value:

    TRUE or FALSE depending on whether message is processed

--*/

{
    PDLGPARAM       pDlgParam;
    POPTITEM        pOptItem;
    PFEATURE        pFeature;
    POPTION         pOption;
    DWORD           dwFeature, dwOption;
    PCWSTR          pDisplayName;
    WCHAR           awchBuf[MAX_DISPLAY_NAME];
    PCOMMONINFO     pci;
    CONFLICTPAIR    ConflictPair;


    switch (uMsg)
    {
    case WM_INITDIALOG:

        pDlgParam = (PDLGPARAM) lParam;
        ASSERT(pDlgParam != NULL);

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pDlgParam);

        pci = (PCOMMONINFO) pDlgParam->pUiData;
        pOptItem = pDlgParam->pOptItem;

        if (GETUSERDATAITEM(pOptItem->UserData) == FORMNAME_ITEM)
            dwOption = pDlgParam->pUiData->pwPaperFeatures[pOptItem->Sel];
        else
            dwOption = pOptItem->Sel;

        //
        // Get the feature id for the current feature and selection
        //

        if (! PGetFeatureFromItem(pci->pUIInfo, pOptItem, &dwFeature))
            return FALSE;

        //
        // Get the first conflicting feature, option for the current pair
        //

        if (! EnumNewPickOneUIConflict(pci->pRawData,
                                       pci->pCombinedOptions,
                                       dwFeature,
                                       dwOption,
                                       &ConflictPair))
        {
            ERR(("No conflict found?\n"));
            return FALSE;
        }

        pFeature = PGetIndexedFeature(pci->pUIInfo, ConflictPair.dwFeatureIndex1);
        pOption = PGetIndexedOption(pci->pUIInfo, pFeature, ConflictPair.dwOptionIndex1);

        //
        // Display the current feature selection
        // Get feature name first
        //

        if (pDisplayName = PGetReadOnlyDisplayName(pci, pFeature->loDisplayName))
        {
            StringCchCopyW(awchBuf, CCHOF(awchBuf), pDisplayName);
            StringCchCatW(awchBuf, CCHOF(awchBuf), TEXT(" : "));
        }

        //
        // Kludgy fix for form - We show the form enumerated by
        // form database and map these logical forms to our supported physical
        // papersize.  So we have to notify the user with the logical form
        // selected and not the mapped physical form returned by EnumConflict
        //

        if (pFeature->dwFeatureID == GID_PAGESIZE)
            pDisplayName = pOptItem->pOptType->pOptParam[pOptItem->Sel].pData;
        else if (pOption)
            pDisplayName = GET_OPTION_DISPLAY_NAME(pci, pOption);
        else
            pDisplayName = NULL;

        if (pDisplayName)
            StringCchCatW(awchBuf, CCHOF(awchBuf), pDisplayName);

        SetDlgItemText(hDlg, IDC_FEATURE1, awchBuf);

        pFeature = PGetIndexedFeature(pci->pUIInfo, ConflictPair.dwFeatureIndex2);
        pOption = PGetIndexedOption(pci->pUIInfo, pFeature, ConflictPair.dwOptionIndex2);

        //
        // Display the current feature selection
        // Get feature name first
        //

        if (pDisplayName = PGetReadOnlyDisplayName(pci, pFeature->loDisplayName))
        {
            StringCchCopyW(awchBuf, CCHOF(awchBuf), pDisplayName);
            StringCchCatW(awchBuf, CCHOF(awchBuf), TEXT(" : "));
        }


        if (pFeature->dwFeatureID == GID_PAGESIZE)
            pDisplayName = pOptItem->pOptType->pOptParam[pOptItem->Sel].pData;
        else if (pOption)
            pDisplayName = GET_OPTION_DISPLAY_NAME(pci, pOption);
        else
            pDisplayName = NULL;

        if (pDisplayName)
            StringCchCatW(awchBuf, CCHOF(awchBuf), pDisplayName);

        SetDlgItemText(hDlg, IDC_FEATURE2, awchBuf);


        if (pDlgParam->bFinal)
        {
            //
            // If user is trying to exit the dialog
            //

            ShowWindow(GetDlgItem(hDlg, IDC_IGNORE), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_CANCEL), SW_HIDE);
            CheckRadioButton(hDlg, IDC_RESOLVE, IDC_CANCEL_FINAL, IDC_RESOLVE);
            pDlgParam->dwResult = CONFLICT_RESOLVE;

        }
        else
        {
            //
            // Hide the Resolve button
            //

            ShowWindow(GetDlgItem(hDlg, IDC_RESOLVE), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_CANCEL_FINAL), SW_HIDE);
            CheckRadioButton(hDlg, IDC_IGNORE, IDC_CANCEL, IDC_IGNORE);
            pDlgParam->dwResult = CONFLICT_IGNORE;

        }

        ShowWindow(hDlg, SW_SHOW);
        return TRUE;

    case WM_COMMAND:

        pDlgParam = (PDLGPARAM)GetWindowLongPtr(hDlg, DWLP_USER);

        switch (LOWORD(wParam))
        {
        case IDC_CANCEL:
        case IDC_CANCEL_FINAL:
            pDlgParam->dwResult = CONFLICT_CANCEL;
            break;

        case IDC_IGNORE:
            pDlgParam->dwResult = CONFLICT_IGNORE;
            break;

        case IDC_RESOLVE:
            pDlgParam->dwResult = CONFLICT_RESOLVE;
            break;

        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, LOWORD(wParam));
            return TRUE;
        }
    }

    return FALSE;
}



VOID
VUpdateOptItemList(
    IN OUT  PUIDATA     pUiData,
    IN      POPTSELECT  pOldCombinedOptions,
    IN      POPTSELECT  pNewCombinedOptions
    )

/*++

Routine Description:

    Ssync up OPTITEM list with the updated options array.

Arguments:

    pUiData - Pointer to our UIDATA structure
    pOldCombinedOptions - A copy of the pre-resolved options array,
    this should cut down the updating costs, only updated if it's changed
    pNewCombinedOptions - the current options array

Return Value:

    None

--*/

{
    DWORD       i, dwFeatures, dwDrvOptItem;
    PFEATURE    pFeature;
    PUIINFO     pUIInfo = pUiData->ci.pUIInfo;
    PCSTR       pKeywordName, pFeatureKeywordName;
    POPTITEM    pOptItem;

    if (pUiData->dwDrvOptItem == 0)
    {
        //
        // nothing to update
        //

        return;
    }

    dwFeatures = pUiData->ci.pRawData->dwDocumentFeatures +
                 pUiData->ci.pRawData->dwPrinterFeatures;

    for (i = 0; i < dwFeatures; i++)
    {
        if (pOldCombinedOptions[i].ubCurOptIndex != pNewCombinedOptions[i].ubCurOptIndex)
        {
            dwDrvOptItem = pUiData->dwDrvOptItem;
            pOptItem = pUiData->pDrvOptItem;

            pFeature = PGetIndexedFeature(pUIInfo, i);

            ASSERT(pFeature);

            while( dwDrvOptItem--)
            {
                pKeywordName = GETUSERDATAKEYWORDNAME(pOptItem->UserData);
                pFeatureKeywordName = OFFSET_TO_POINTER(pUIInfo->pubResourceData,
                                                        pFeature->loKeywordName);

                ASSERT(pFeatureKeywordName);

                if (pKeywordName && pFeatureKeywordName &&
                    (strcmp(pFeatureKeywordName, pKeywordName) == EQUAL_STRING))
                    break;

                pOptItem++;
            }

            pOptItem->Sel = pNewCombinedOptions[i].ubCurOptIndex;
            pOptItem->Flags |= OPTIF_CHANGED;


            //
            // This is necessary to ssync up the colormode changes with the color information
            //

            #ifdef UNIDRV
            if (GETUSERDATAITEM(pOptItem->UserData) == COLORMODE_ITEM)
                VSyncColorInformation(pUiData, pOptItem);
            #endif
        }
    }

    VPropShowConstraints(pUiData,
                         (pUiData->iMode == MODE_PRINTER_STICKY) ? pUiData->iMode : MODE_DOCANDPRINTER_STICKY);
}


INT
ICheckConstraintsDlg(
    IN OUT  PUIDATA     pUiData,
    IN OUT  POPTITEM    pOptItem,
    IN      DWORD       dwOptItem,
    IN      BOOL        bFinal
    )

/*++

Routine Description:

    Check if the user chose any constrained selection

Arguments:

    pUiData - Pointer to our UIDATA structure
    pOptItem - Pointer to an array of OPTITEMs
    dwOptItem - Number of items to be checked
    bFinal - Whether this is called when user tries to exit the dialog

Return Value:

    CONFLICT_NONE - no conflicts
    CONFLICT_RESOLVE - click RESOLVE to automatically resolve conflicts
    CONFLICT_CANCEL - click CANCEL to back out of changes
    CONFLICT_IGNORE - click IGNORE to ignore conflicts

--*/

{
    DLGPARAM    DlgParam;
    OPTSELECT   OldCombinedOptions[MAX_COMBINED_OPTIONS];


    DlgParam.pfnComPropSheet = pUiData->pfnComPropSheet;
    DlgParam.hComPropSheet = pUiData->hComPropSheet;
    DlgParam.pUiData = pUiData;
    DlgParam.bFinal = bFinal;
    DlgParam.dwResult = CONFLICT_NONE;

    for ( ; dwOptItem--; pOptItem++)
    {
        //
        // If the item is not constrainable, skip it.
        //

        if (! ISCONSTRAINABLEITEM(pOptItem->UserData))
            continue;

        //
        // If user has clicked IGNORE before, then don't bother
        // checking anymore until he tries to exit the dialog.
        //

        //if (pUiData->bIgnoreConflict && !bFinal)
        //    break;

        //
        // If there is a conflict, then display a warning message
        //

        if (IS_CONSTRAINED(pOptItem, pOptItem->Sel))
        {
            DlgParam.pOptItem = pOptItem;
            DlgParam.dwResult = CONFLICT_NONE;

            DialogBoxParam(ghInstance,
                        MAKEINTRESOURCE(IDD_CONFLICTS),
                        pUiData->hDlg,
                        BConflictsDlgProc,
                        (LPARAM) &DlgParam);

            //
            // Automatically resolve conflicts. We're being very
            // simple-minded here, i.e. picking the first selection
            // that's not constrained.
            //

            if (DlgParam.dwResult == CONFLICT_RESOLVE)
            {

                ASSERT((bFinal == TRUE));

                //
                // Save a copy the pre-resolve optionarray
                //

                CopyMemory(OldCombinedOptions,
                           pUiData->ci.pCombinedOptions,
                           MAX_COMBINED_OPTIONS * sizeof(OPTSELECT));

                //
                // Call the parsers to resolve the conflicts
                //
                // Note: If we're inside DrvDocumentPropertySheets,
                // we'll call the parser to resolve conflicts between
                // all printer features. Since all printer-sticky
                // features have higher priority than all doc-sticky
                // features, only doc-sticky option selections should
                // be affected.
                //

                ResolveUIConflicts(pUiData->ci.pRawData,
                                   pUiData->ci.pCombinedOptions,
                                   MAX_COMBINED_OPTIONS,
                                   (pUiData->iMode == MODE_PRINTER_STICKY) ?
                                        pUiData->iMode :
                                        MODE_DOCANDPRINTER_STICKY);

                //
                // Update the OPTITEM list to match the updated options array
                //

                VUpdateOptItemList(pUiData, OldCombinedOptions, pUiData->ci.pCombinedOptions);

            }
            else if (DlgParam.dwResult == CONFLICT_IGNORE)
            {
                //
                // Ignore any future conflicts until the
                // user tries to close the property sheet.
                //

                pUiData->bIgnoreConflict = TRUE;
            }

            break;
        }
    }

    return DlgParam.dwResult;
}



BOOL
BOptItemSelectionsChanged(
    IN POPTITEM pItems,
    IN DWORD    dwItems
    )

/*++

Routine Description:

    Check if any of the OPTITEM's was changed by the user

Arguments:

    pItems - Pointer to an array of OPTITEM's
    dwItems - Number of OPTITEM's

Return Value:

    TRUE if anything was changed, FALSE otherwise

--*/

{
    for ( ; dwItems--; pItems++)
    {
        if (pItems->Flags & OPTIF_CHANGEONCE)
            return TRUE;
    }

    return FALSE;
}



POPTITEM
PFindOptItem(
    IN PUIDATA  pUiData,
    IN DWORD    dwItemId
    )

/*++

Routine Description:

    Find an OPTITEM with the specified identifier

Arguments:

    pUiData - Points to UIDATA structure
    dwItemId - Specifies the interested item identifier

Return Value:

    Pointer to OPTITEM with the specified id,
    NULL if no such item is found

--*/

{
    POPTITEM    pOptItem = pUiData->pDrvOptItem;
    DWORD       dwOptItem = pUiData->dwDrvOptItem;

    for ( ; dwOptItem--; pOptItem++)
    {
        if (GETUSERDATAITEM(pOptItem->UserData) == dwItemId)
            return pOptItem;
    }

    return NULL;
}



INT
IDisplayErrorMessageBox(
    HWND    hwndParent,
    UINT    uType,
    INT     iTitleStrId,
    INT     iFormatStrId,
    ...
    )

/*++

Routine Description:

    Display an error message box

Arguments:

    hwndParent - Handle to the parent window
    uType - Type of message box to display
        if 0, the default value is MB_OK | MB_ICONERROR
    iTitleStrId - String resource ID for the message box title
    iFormatStrId - String resource ID for the message itself.
        This string can contain printf format specifications.
    ... - Optional arguments.

Return Value:

    Return value from MessageBox() call.

--*/

#define MAX_MBTITLE_LEN     128
#define MAX_MBFORMAT_LEN    512
#define MAX_MBMESSAGE_LEN   1024

{
    PWSTR   pwstrTitle, pwstrFormat, pwstrMessage;
    INT     iResult;
    va_list ap;

    pwstrTitle = pwstrFormat = pwstrMessage = NULL;

    if ((pwstrTitle = MemAllocZ(sizeof(WCHAR) * MAX_MBTITLE_LEN)) &&
        (pwstrFormat = MemAllocZ(sizeof(WCHAR) * MAX_MBFORMAT_LEN)) &&
        (pwstrMessage = MemAllocZ(sizeof(WCHAR) * MAX_MBMESSAGE_LEN)))
    {
        //
        // Load message box title and format string resources
        //

        LoadString(ghInstance, iTitleStrId, pwstrTitle, MAX_MBTITLE_LEN);
        LoadString(ghInstance, iFormatStrId, pwstrFormat, MAX_MBFORMAT_LEN);

        //
        // Compose the message string
        //

        va_start(ap, iFormatStrId);
        StringCchVPrintfW(pwstrMessage, MAX_MBMESSAGE_LEN, pwstrFormat, ap);
        va_end(ap);

        //
        // Display the message box
        //

        if (uType == 0)
            uType = MB_OK | MB_ICONERROR;

        iResult = MessageBox(hwndParent, pwstrMessage, pwstrTitle, uType);
    }
    else
    {
        MessageBeep(MB_ICONERROR);
        iResult = 0;
    }

    MemFree(pwstrTitle);
    MemFree(pwstrFormat);
    MemFree(pwstrMessage);
    return iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\devcaps.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    devcaps.c

Abstract:

    This file handles the DrvDeviceCapabilities spooler API.

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/13/97 -davidx-
        Implement OEM plugin support.

    02/10/97 -davidx-
        Consistent handling of common printer info.

    02/04/97 -davidx-
        Reorganize driver UI to separate ps and uni DLLs.

    07/17/96 -amandan-
        Created it.

--*/

#include "precomp.h"



DWORD
DwDeviceCapabilities(
    HANDLE      hPrinter,
    PWSTR       pDeviceName,
    WORD        wCapability,
    PVOID       pOutput,
    LONG        cchBufSize,
    PDEVMODE    pdmSrc
    )

/*++

Routine Description:

    This function support the querrying of device capabilities
    It gets the binary data (UIINFO) from the parser and return
    the requested capability to the caller.

Arguments:

    hPrinter    handle to printer object
    pDeviceName pointer to device name
    wCapability specifies the requested capability
    pOutput     pointer to output buffer
    cchBufSize  Size of output buffer in number of characters
    pdmSrc      pointer to input devmode


Return Value:
    The capabilities supported and relevant information in pOutput

--*/

{
    DWORD                       dwOld,dwDrv,dwRet = GDI_ERROR;
    PDEVMODE                    pdm;
    PCOMMONINFO                 pci;
    FORM_TRAY_TABLE             pFormTrayTable;
    PFN_OEMDeviceCapabilities   pfnOEMDeviceCapabilities;
    BOOL                        bEMFSpooling, bNup;

    #if defined(ADOBE) && defined(PSCRIPT)
    PDEVMODE                    pdmPrinter = NULL;
    PPRINTER_INFO_2             pPrinterInfo2 = NULL;
    #endif // ADOBE && PSCRIPT


    //
    // Load basic printer info
    // Process devmode information: driver default + input devmode
    // Fix up options array with public devmode information
    // Get an updated printer description data instance
    //

    #if defined(ADOBE) && defined(PSCRIPT)

    if (!(pci = PLoadCommonInfo(hPrinter, pDeviceName, 0)))
    {
        goto devcaps_exit;
    }

    //
    // Fix bug #25547: PS custom paper size problem with Word.
    // Word is calling DeviceCapabilities with pdmSrc=NULL. The fix
    // is limited to the cases of PS driver and NULL pdmSrc in order
    // to minimize possible app-compat problems.
    //

    if (pdmSrc == NULL)
    {
        if (!(pPrinterInfo2 = MyGetPrinter(pci->hPrinter, 2)))
        {
            goto devcaps_exit;
        }

        pdmPrinter = pPrinterInfo2->pDevMode;
    }

    if (
        #ifndef WINNT_40
        ! ( (wCapability != DC_PRINTERMEM &&
             wCapability != DC_DUPLEX &&
             wCapability != DC_COLLATE &&
             wCapability != DC_STAPLE)||
            (BFillCommonInfoPrinterData(pci)) ) ||
        #endif

        ! BFillCommonInfoDevmode(pci, (pdmSrc == NULL) ? pdmPrinter : NULL, pdmSrc) ||
        ! BCombineCommonInfoOptionsArray(pci))
    {
        goto devcaps_exit;
    }

    #else

    if (! (pci = PLoadCommonInfo(hPrinter, pDeviceName, 0)) ||

        #ifndef WINNT_40
        ! ( (wCapability != DC_PRINTERMEM &&
             wCapability != DC_DUPLEX &&
             wCapability != DC_COLLATE &&
             wCapability != DC_STAPLE)||
            (BFillCommonInfoPrinterData(pci)) ) ||
        #endif

        ! BFillCommonInfoDevmode(pci, NULL, pdmSrc) ||
        ! BCombineCommonInfoOptionsArray(pci))
    {
        goto devcaps_exit;
    }

    #endif // ADOBE && PSCRIPT

    VFixOptionsArrayWithDevmode(pci);

    (VOID) ResolveUIConflicts(pci->pRawData,
                              pci->pCombinedOptions,
                              MAX_COMBINED_OPTIONS,
                              MODE_DOCUMENT_STICKY);

    VOptionsToDevmodeFields(pci, TRUE);

    if (! BUpdateUIInfo(pci))
        goto devcaps_exit;

    pdm = pci->pdm;

    //
    // Get spooler EMF cap so that we can report COLLATE and COPIES correctly
    //

    VGetSpoolerEmfCaps(pci->hPrinter, &bNup, &bEMFSpooling, 0, NULL);

    switch (wCapability)
    {
    case DC_VERSION:

        dwRet = pdm->dmSpecVersion;
        break;

    case DC_DRIVER:

        dwRet = pdm->dmDriverVersion;
        break;

    case DC_SIZE:

        dwRet = pdm->dmSize;
        break;

    case DC_EXTRA:

        dwRet = pdm->dmDriverExtra;
        break;

    case DC_FIELDS:

        dwRet = pdm->dmFields;
        break;

    case DC_FILEDEPENDENCIES:

        if (pOutput != NULL)
            *((PWSTR) pOutput) = NUL;
        dwRet = 0;
        break;

    case DC_COPIES:

        if (bEMFSpooling && ISSET_MFSPOOL_FLAG(pci->pdmPrivate))
            dwRet = max(MAX_COPIES, (SHORT)pci->pUIInfo->dwMaxCopies);
        else
            dwRet = pci->pUIInfo->dwMaxCopies;

        break;

    case DC_DUPLEX:

        dwRet = SUPPORTS_DUPLEX(pci) ? 1: 0;
        break;

    case DC_TRUETYPE:

        if (! (pdm->dmFields & DM_TTOPTION))
            dwRet = 0;
        else
            dwRet = _DwGetFontCap(pci->pUIInfo);
        break;

    case DC_ORIENTATION:

        dwRet = _DwGetOrientationAngle(pci->pUIInfo, pdm);
        break;

    case DC_PAPERNAMES:

        dwRet = DwEnumPaperSizes(pci, pOutput, NULL, NULL, NULL, cchBufSize);
        break;

    case DC_PAPERS:

        dwRet = DwEnumPaperSizes(pci, NULL, pOutput, NULL, NULL, cchBufSize);
        break;

    case DC_PAPERSIZE:

        dwRet = DwEnumPaperSizes(pci, NULL, NULL, pOutput, NULL, cchBufSize);
        break;

    case DC_MINEXTENT:
    case DC_MAXEXTENT:

        dwRet = DwCalcMinMaxExtent(pci, pOutput, wCapability);
        break;

    case DC_BINNAMES:

        dwRet = DwEnumBinNames(pci, pOutput);
        break;

    case DC_BINS:

        dwRet = DwEnumBins(pci, pOutput);
        break;

    case DC_ENUMRESOLUTIONS:

        dwRet = DwEnumResolutions( pci, pOutput);
        break;

    case DC_COLLATE:

        if (bEMFSpooling && ISSET_MFSPOOL_FLAG(pci->pdmPrivate))
            dwRet = DRIVER_SUPPORTS_COLLATE(pci);
        else
            dwRet = PRINTER_SUPPORTS_COLLATE(pci);

        break;

    //
    // Following device capabilities are not available on NT4
    //

    #ifndef WINNT_40

    case DC_COLORDEVICE:

        dwRet = IS_COLOR_DEVICE(pci->pUIInfo) ? 1 : 0;
        break;

    case DC_NUP:

        dwRet = DwEnumNupOptions(pci, pOutput);
        break;

    case DC_PERSONALITY:

        dwRet = _DwEnumPersonalities(pci, pOutput);
        break;

    case DC_PRINTRATE:

        if ((dwRet = pci->pUIInfo->dwPrintRate) == 0)
            dwRet = GDI_ERROR;

        break;

    case DC_PRINTRATEUNIT:

        if ((dwRet = pci->pUIInfo->dwPrintRateUnit) == 0)
            dwRet = GDI_ERROR;
        break;

    case DC_PRINTRATEPPM:

        if ((dwRet = pci->pUIInfo->dwPrintRatePPM) == 0)
            dwRet = GDI_ERROR;
        break;

    case DC_PRINTERMEM:

        dwRet = DwGetAvailablePrinterMem(pci);
        break;

    case DC_MEDIAREADY:

        //
        // Get current form-tray assignment table
        //

        if (pFormTrayTable = PGetFormTrayTable(pci->hPrinter, NULL))
        {
            PWSTR   pwstr;

            //
            // Get list of currently assigned forms.
            // Notice that DwEnumMediaReady returns currently
            // form names in place of the original form-tray table.
            //

            dwRet = DwEnumMediaReady(pFormTrayTable, NULL);

            if (dwRet > 0 && pOutput != NULL)
            {
                DWORD dwCount;

                pwstr = pFormTrayTable;

                dwCount = 0;
                while (*pwstr)
                {
                    if ((cchBufSize == UNUSED_PARAM) ||
                        (cchBufSize >= CCHPAPERNAME))
                    {
                        CopyString(pOutput, pwstr, CCHPAPERNAME);
                        pOutput = (PWSTR) pOutput + CCHPAPERNAME;
                        pwstr += wcslen(pwstr) + 1;

                        if (cchBufSize != UNUSED_PARAM)
                        {
                            cchBufSize -= CCHPAPERNAME;
                        }

                        dwCount++;
                    }
                    else
                    {
                        //
                        // Output buffer is not big enough to hold more form names,
                        // so we will just return the number of forms we have filled
                        // into the output buffer so far.
                        //
                        break;
                    }
                }

                dwRet = dwCount;
            }

            MemFree(pFormTrayTable);
        }
        else
        {
            PCWSTR pwstrDefault = IsMetricCountry() ? A4_FORMNAME : LETTER_FORMNAME;
            dwRet = 1;

            if (pOutput)
            {
                if ((cchBufSize == UNUSED_PARAM) ||
                    (cchBufSize >= CCHPAPERNAME))
                {
                    CopyString(pOutput, pwstrDefault, CCHPAPERNAME);
                }
                else
                {
                    //
                    // Output buffer is not big enough to hold CCHPAPERNAME WCHARs.
                    //
                    dwRet = 0;
                }
            }
        }
        break;

    case DC_STAPLE:

        dwRet = _BSupportStapling(pci);
        break;

    case DC_MEDIATYPENAMES:

        dwRet = DwEnumMediaTypes(pci, pOutput, NULL);
        break;

    case DC_MEDIATYPES:

        dwRet = DwEnumMediaTypes(pci, NULL, pOutput);
        break;

    #endif // !WINNT_40

    default:

        SetLastError(ERROR_NOT_SUPPORTED);
        break;
    }

    //
    // Call OEMDeviceCapabilities entrypoint for each plugin.
    // If dwRet is GDI_ERROR at this point, it means the system driver
    // doesn't support the requested device capability or an error
    // prevented the system driver from handling it.
    //

    dwDrv = dwRet;

    FOREACH_OEMPLUGIN_LOOP(pci)


        dwOld = dwRet;

        if (HAS_COM_INTERFACE(pOemEntry))
        {
            if (HComOEMDeviceCapabilities(
                                pOemEntry,
                                &pci->oemuiobj,
                                hPrinter,
                                pDeviceName,
                                wCapability,
                                pOutput,
                                pdm,
                                pOemEntry->pOEMDM,
                                dwOld,
                                &dwRet) == E_NOTIMPL)
                continue;

        }
        else
        {
            if (pfnOEMDeviceCapabilities = GET_OEM_ENTRYPOINT(pOemEntry, OEMDeviceCapabilities))
            {

                dwRet = pfnOEMDeviceCapabilities(
                                &pci->oemuiobj,
                                hPrinter,
                                pDeviceName,
                                wCapability,
                                pOutput,
                                pdm,
                                pOemEntry->pOEMDM,
                                dwOld);
           }
        }

        if (dwRet == GDI_ERROR && dwOld != GDI_ERROR)
        {
            ERR(("OEMDeviceCapabilities failed for '%ws': %d\n",
                 CURRENT_OEM_MODULE_NAME(pOemEntry),
                 GetLastError()));
        }


    END_OEMPLUGIN_LOOP

    //
    // The flaw of this API is there is no size associated with the input buffer.
    // We have to assume that the app is doing the right thing and allocate enough
    // buffer to hold our values.  However, the values can change if the OEM plugins
    // choose to change the value.  We have no way of determine that.
    // To err on the safe side, we will always ask the app to allocate the larger
    // of the two values (Unidrv and OEM). When asked the second time to fill out
    // the buffer, OEM can return the correct values.
    //

    if ((pOutput == NULL &&  dwRet != GDI_ERROR &&
         dwDrv !=GDI_ERROR && dwRet < dwDrv) &&
        (wCapability == DC_PAPERNAMES || wCapability == DC_PAPERS   ||
         wCapability == DC_PAPERSIZE  || wCapability == DC_BINNAMES ||
         wCapability == DC_BINS ||

         #ifndef WINNT_40
         wCapability == DC_NUP  || wCapability == DC_PERSONALITY    ||
         wCapability == DC_MEDIAREADY || wCapability == DC_MEDIATYPENAMES ||
         wCapability == DC_MEDIATYPES ||
         #endif

         wCapability == DC_ENUMRESOLUTIONS) )
    {
        //
        // The size returned by OEM is smaller than what Unidrv needs, so modifies it
        //

        if (dwRet == 0)
            dwRet = GDI_ERROR;
        else
            dwRet = dwDrv;

    }

devcaps_exit:

    if (dwRet == GDI_ERROR)
        TERSE(("DrvDeviceCapabilities(%d) failed: %d\n", wCapability, GetLastError()));

    #if defined(ADOBE) && defined(PSCRIPT)
    if (!pPrinterInfo2)
        MemFree(pPrinterInfo2);
    #endif // ADOBE && PSCRIPT

    VFreeCommonInfo(pci);
    return dwRet;
}


DWORD
DrvSplDeviceCaps(
    HANDLE      hPrinter,
    PWSTR       pDeviceName,
    WORD        wCapability,
    PVOID       pOutput,
    DWORD       cchBufSize,
    PDEVMODE    pdmSrc
    )

/*++

Routine Description:

    This function support the querrying of device capabilities
    It gets the binary data (UIINFO) from the parser and return
    the requested capability to the caller.

Arguments:

    hPrinter    handle to printer object
    pDeviceName pointer to device name
    wCapability specifies the requested capability
    pOutput     pointer to output buffer
    cchBufSize  output buffer size in count of chars
    pdmSrc      pointer to input devmode


Return Value:
    The capabilities supported and relevant information in pOutput

--*/

{

    switch (wCapability) {

    case DC_PAPERNAMES:
    #ifndef WINNT_40
    case DC_MEDIAREADY:
    #endif
        return (DwDeviceCapabilities(hPrinter,
                                     pDeviceName,
                                     wCapability,
                                     pOutput,
                                     (LONG)cchBufSize,
                                     pdmSrc));

    default:
        return GDI_ERROR;
    }
}


DWORD
DrvDeviceCapabilities(
    HANDLE      hPrinter,
    PWSTR       pDeviceName,
    WORD        wCapability,
    PVOID       pOutput,
    PDEVMODE    pdmSrc
    )

/*++

Routine Description:

    This function support the querrying of device capabilities
    It gets the binary data (UIINFO) from the parser and return
    the requested capability to the caller.

Arguments:

    hPrinter    handle to printer object
    pDeviceName pointer to device name
    wCapability specifies the requested capability
    pOutput     pointer to output buffer
    pdmSrc      pointer to input devmode


Return Value:
    The capabilities supported and relevant information in pOutput

--*/

{
    return (DwDeviceCapabilities(hPrinter,
                                 pDeviceName,
                                 wCapability,
                                 pOutput,
                                 UNUSED_PARAM,
                                 pdmSrc));

}
DWORD
DwEnumPaperSizes(
    PCOMMONINFO pci,
    PWSTR       pPaperNames,
    PWORD       pPapers,
    PPOINT      pPaperSizes,
    PWORD       pPaperFeatures,
    LONG        cchPaperNamesBufSize
    )

/*++

Routine Description:

    This function retrieves a list of supported paper sizes

Arguments:

    pci - Points to basic printer information
    pForms - List of spooler forms
    dwForms - Number of spooler forms
    pPaperNames - Buffer for returning supported paper size names
    pPapers - Buffer for returning supported paper size indices
    pPaperSizes - Buffer for returning supported paper size dimensions
    pPaperFeatures - Buffer for returning supported paper size option indices
    cchPaperNamesBufSize - Size of buffer holding paper names in characters

Return Value:

    Number of paper sizes supported, GDI_ERROR if there is an error.

--*/

{
    PFORM_INFO_1    pForms;
    DWORD           dwCount, dwIndex, dwOptionIndex = 0;

    #ifdef UNIDRV
    PFEATURE        pFeature;
    PPAGESIZE       pPageSize;
    PPAGESIZEEX     pPageSizeEx;
    #endif


    //
    // Get the list of spooler forms if we haven't done so already
    //

    if (pci->pSplForms == NULL)
        pci->pSplForms = MyEnumForms(pci->hPrinter, 1, &pci->dwSplForms);

    if (pci->pSplForms == NULL)
    {
        ERR(("No spooler forms.\n"));
        return GDI_ERROR;
    }

    //
    // Go through each form in the forms database
    //

    dwCount = 0;
    pForms = pci->pSplForms;

    #ifdef UNIDRV
    pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGESIZE);
    #endif

    for (dwIndex=0; dwIndex < pci->dwSplForms; dwIndex++, pForms++)
    {
        //
        // If the form is supported on the printer, then
        // increment the paper size count and collect
        // requested information
        //

        if (! BFormSupportedOnPrinter(pci, pForms, &dwOptionIndex))
            continue;

        dwCount++;

        //
        // Return the size of the form in 0.1mm units.
        // The unit used in FORM_INFO_1 is 0.001mm.
        // Fill pPaperSizes with the form info supported by the printer
        //

        if (pPaperSizes)
        {
            pPaperSizes->x = pForms->Size.cx / DEVMODE_PAPER_UNIT;
            pPaperSizes->y = pForms->Size.cy / DEVMODE_PAPER_UNIT;

            #ifdef UNIDRV
            if (pFeature &&
                (pPageSize = PGetIndexedOption(pci->pUIInfo, pFeature, dwOptionIndex)) &&
                (pPageSizeEx = OFFSET_TO_POINTER(pci->pInfoHeader, pPageSize->GenericOption.loRenderOffset)) &&
                (pPageSizeEx->bRotateSize))
            {
               LONG lTemp;

               lTemp = pPaperSizes->x;
               pPaperSizes->x = pPaperSizes->y;
               pPaperSizes->y = lTemp;
            }
            #endif // UNIDRV

            pPaperSizes++;
        }

        //
        // Return the formname.
        //

        if (pPaperNames)
        {
            if (cchPaperNamesBufSize == UNUSED_PARAM)
            {
                CopyString(pPaperNames, pForms->pName, CCHPAPERNAME);
                pPaperNames += CCHPAPERNAME;
            }
            else if (cchPaperNamesBufSize >= CCHPAPERNAME)
            {
                CopyString(pPaperNames, pForms->pName, CCHPAPERNAME);
                pPaperNames += CCHPAPERNAME;
                cchPaperNamesBufSize -= CCHPAPERNAME;
            }
            else
            {
                dwCount--;
                break;
            }
        }

        //
        // Return one-based index of the form.
        //

        if (pPapers)
            *pPapers++ = (WORD) (dwIndex + DMPAPER_FIRST);

        //
        // Return page size feature index
        //

        if (pPaperFeatures)
            *pPaperFeatures++ = (WORD) dwOptionIndex;
    }

    #ifdef PSCRIPT

    {
        PPPDDATA    pPpdData;
        PPAGESIZE   pPageSize;

        pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pci->pRawData);

        ASSERT(pPpdData != NULL);

        if (SUPPORT_FULL_CUSTOMSIZE_FEATURES(pci->pUIInfo, pPpdData) &&
            (pPageSize = PGetCustomPageSizeOption(pci->pUIInfo)))
        {
            ASSERT(pPageSize->dwPaperSizeID == DMPAPER_CUSTOMSIZE);
            dwCount++;

            if (pPaperSizes)
            {
                pPaperSizes->x = pci->pdmPrivate->csdata.dwX / DEVMODE_PAPER_UNIT;
                pPaperSizes->y = pci->pdmPrivate->csdata.dwY / DEVMODE_PAPER_UNIT;
                pPaperSizes++;
            }

            if (pPaperNames)
            {
                if (cchPaperNamesBufSize == UNUSED_PARAM)
                {
                    LOAD_STRING_PAGESIZE_NAME(pci, pPageSize, pPaperNames, CCHPAPERNAME);
                    pPaperNames += CCHPAPERNAME;
                }
                else if (cchPaperNamesBufSize >= CCHPAPERNAME)
                {
                    LOAD_STRING_PAGESIZE_NAME(pci, pPageSize, pPaperNames, CCHPAPERNAME);
                    pPaperNames += CCHPAPERNAME;
                    cchPaperNamesBufSize -= CCHPAPERNAME;
                }
                else
                    dwCount--;
            }

            if (pPapers)
                *pPapers++ = DMPAPER_CUSTOMSIZE;

            if (pPaperFeatures)
                *pPaperFeatures++ = (WORD) pci->pUIInfo->dwCustomSizeOptIndex;
        }
    }

    #endif // PSCRIPT

    return dwCount;
}



DWORD
DwCalcMinMaxExtent(
    PCOMMONINFO pci,
    PPOINT      pptOutput,
    WORD        wCapability
    )

/*++

Routine Description:

    This function retrieves the min and max paper size.

Arguments:

    pci - Points to basic printer information
    wCapability - What the caller is interested in:
        DC_MAXEXTENT or DC_MINEXTENT

Return Value:

    Number of paper sizes supported, GDI_ERROR if there is an error.

--*/

{
    PFORM_INFO_1    pForms;
    DWORD           dwCount, dwLoopCnt, dwOptionIndex;
    LONG            lMinX, lMinY, lMaxX, lMaxY, lcx, lcy;

    #ifdef UNIDRV
    PFEATURE        pFeature;
    PPAGESIZE       pPageSize;
    PPAGESIZEEX     pPageSizeEx;
    #endif

    //
    // Get the list of spooler forms if we haven't done so already
    //

    if (pci->pSplForms == NULL)
        pci->pSplForms = MyEnumForms(pci->hPrinter, 1, &pci->dwSplForms);

    if (pci->pSplForms == NULL)
    {
        ERR(("No spooler forms.\n"));
        return GDI_ERROR;
    }

    //
    // Go through each form in the forms database
    //

    lMinX = lMinY = MAX_LONG;
    lMaxX = lMaxY = 0;

    dwCount = 0;
    pForms = pci->pSplForms;
    dwLoopCnt = pci->dwSplForms;

    #ifdef UNIDRV
    pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGESIZE);
    #endif

    for ( ; dwLoopCnt--; pForms++)
    {
        //
        // If the form is supported on the printer, then
        // increment the paper size count and collect
        // requested information
        //

        if (! BFormSupportedOnPrinter(pci, pForms, &dwOptionIndex))
            continue;

        dwCount++;

        lcx = pForms->Size.cx;
        lcy = pForms->Size.cy;

        #ifdef UNIDRV

        //
        // Need to swap x, y as we do in DwEnumPaperSizes() if bRotateSize is True.
        //

        if (pFeature &&
            (pPageSize = PGetIndexedOption(pci->pUIInfo, pFeature, dwOptionIndex)) &&
            (pPageSizeEx = OFFSET_TO_POINTER(pci->pInfoHeader, pPageSize->GenericOption.loRenderOffset)) &&
            (pPageSizeEx->bRotateSize))
        {
           LONG lTemp;

           lTemp = lcx;
           lcx = lcy;
           lcy = lTemp;
        }

        #endif // UNIDRV

        if (lMinX > lcx)
            lMinX = lcx;

        if (lMinY > lcy)
            lMinY = lcy;

        if (lMaxX < lcx)
            lMaxX = lcx;

        if (lMaxY < lcy)
            lMaxY = lcy;
    }

    #ifdef PSCRIPT

    //
    // If the printer supports custom page size, we should
    // take that into consideration as well.
    //

    if (SUPPORT_CUSTOMSIZE(pci->pUIInfo))
    {
        PPPDDATA pPpdData;

        pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pci->pRawData);

        ASSERT(pPpdData != NULL);

        if (lMinX > MINCUSTOMPARAM_WIDTH(pPpdData))
            lMinX = MINCUSTOMPARAM_WIDTH(pPpdData);

        if (lMinY > MINCUSTOMPARAM_HEIGHT(pPpdData))
            lMinY = MINCUSTOMPARAM_HEIGHT(pPpdData);

        if (lMaxX < MAXCUSTOMPARAM_WIDTH(pPpdData))
            lMaxX = MAXCUSTOMPARAM_WIDTH(pPpdData);

        if (lMaxY < MAXCUSTOMPARAM_HEIGHT(pPpdData))
            lMaxY = MAXCUSTOMPARAM_HEIGHT(pPpdData);
    }

    #endif // PSCRIPT

    //
    // Convert from micron to 0.1mm
    //

    lMinX /= DEVMODE_PAPER_UNIT;
    lMinY /= DEVMODE_PAPER_UNIT;
    lMaxX /= DEVMODE_PAPER_UNIT;
    lMaxY /= DEVMODE_PAPER_UNIT;

    //
    // Return the result as a POINTS structure
    //

    if (wCapability == DC_MINEXTENT)
    {
        lMinX = min(lMinX, 0x7fff);
        lMinY = min(lMinY, 0x7fff);

        return MAKELONG(lMinX, lMinY);
    }
    else
    {
        lMaxX = min(lMaxX, 0x7fff);
        lMaxY = min(lMaxY, 0x7fff);

        return MAKELONG(lMaxX, lMaxY);
    }
}



DWORD
DwEnumBinNames(
    PCOMMONINFO pci,
    PWSTR       pBinNames
    )

/*++

Routine Description:

    This function retrieves a list of supported paper bins

Arguments:

    pci - Points to basic printer information
    pBinNames - Buffer for returning paper bin names.
        It can be NULL if the caller is only interested
        the number of paper bins supported.

Return Value:

    Number of paper bins supported.

--*/

{
    PFEATURE    pFeature;
    PINPUTSLOT  pInputSlot;
    DWORD       dwIndex, dwCount = 0;

    //
    // Go through the list of input slots supported by the printer
    //

    pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_INPUTSLOT);

    if ((pFeature != NULL) &&
        (dwCount = pFeature->Options.dwCount) > 0 &&
        (pBinNames != NULL))
    {
        for (dwIndex=0; dwIndex < dwCount; dwIndex++)
        {
            pInputSlot = PGetIndexedOption(pci->pUIInfo, pFeature, dwIndex);
            ASSERT(pInputSlot != NULL);

            //
            // If the first tray is "*UseFormTrayTable", change its
            // display name here to be consistent.
            //

            if (dwIndex == 0 && pInputSlot->dwPaperSourceID == DMBIN_FORMSOURCE)
            {
                LoadString(ghInstance, IDS_TRAY_FORMSOURCE, pBinNames, CCHBINNAME);
            }
            else
            {
                LOAD_STRING_OPTION_NAME(pci, pInputSlot, pBinNames, CCHBINNAME);
            }

            pBinNames += CCHBINNAME;
        }
    }

    return dwCount;
}



DWORD
DwEnumBins(
    PCOMMONINFO pci,
    PWORD       pBins
    )

/*++

Routine Description:

    This function retrieves the number of supported paper bins

Arguments:

    pci - Points to basic printer information
    pBins - Output buffer for returning paper bin indices.
        It can be NULL if the caller is only interested
        the number of paper bins supported.

Return Value:

    Number of paper bins supported.

--*/

{
    PFEATURE    pFeature;
    PINPUTSLOT  pInputSlot;
    DWORD       dwIndex, dwCount = 0;

    //
    // Go through the list of input slots supported by the printer
    //

    pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_INPUTSLOT);

    if ((pFeature != NULL) &&
        (dwCount = pFeature->Options.dwCount) > 0 &&
        (pBins != NULL))
    {
        for (dwIndex=0; dwIndex < dwCount; dwIndex++)
        {
            pInputSlot = PGetIndexedOption(pci->pUIInfo, pFeature, dwIndex);
            ASSERT(pInputSlot != NULL);

            *pBins++ = (WORD)pInputSlot->dwPaperSourceID;
        }
    }

    return dwCount;
}



DWORD
DwEnumResolutions(
    PCOMMONINFO pci,
    PLONG       pResolutions
    )
/*++

Routine Description:

    This function retrieves a list of supported resolutions.

Arguments:

    pci - Points to basic printer information
    pResolutions - Returns information about supported resolutions.
        Two numbers are returned for each resolution option:
        one for horizontal and the other for vertical.
        Note that this can be NULL if the caller is only interested
        in the number of resolutions supported.

Return Value:

    Number of resolutions supported.

--*/

{
    DWORD       dwCount, dwIndex;
    PFEATURE    pFeature;
    PRESOLUTION pResOption;

    //
    // Go throught the list of resolutions supported by the printer
    //

    pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_RESOLUTION);

    if (pFeature && pFeature->Options.dwCount > 0)
    {
        //
        // Enumerate all options of the resolution feature
        //

        dwCount = pFeature->Options.dwCount;

        for (dwIndex=0; dwIndex < dwCount; dwIndex++)
        {
            pResOption = PGetIndexedOption(pci->pUIInfo, pFeature, dwIndex);
            ASSERT(pResOption != NULL);

            if (pResolutions != NULL)
            {
                *pResolutions++ = pResOption->iXdpi;
                *pResolutions++ = pResOption->iYdpi;
            }
        }
    }
    else
    {
        //
        // If no resolution option is available,
        // return at least one default resolution
        //

        dwCount = 1;

        if (pResolutions != NULL)
        {
            pResolutions[0] =
            pResolutions[1] = _DwGetDefaultResolution();
        }
    }

    return dwCount;
}



DWORD
DwGetAvailablePrinterMem(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Find out how much memory is available in the printer

Arguments:

    pci - Points to base printer information

Return Value:

    Amount of memory available in the printer (in KBytes)

--*/

{
    DWORD   dwFreeMem;

    ASSERT(pci->pPrinterData && pci->pCombinedOptions);

    //
    // For PSCRIPT, the amount of free memory is stored in
    // PRINTERDATA.dwFreeMem field.
    //

    #ifdef PSCRIPT

    dwFreeMem = pci->pPrinterData->dwFreeMem;

    #endif

    //
    // For UNIDRV, we need to find out the currently selected
    // option for GID_MEMOPTION feature.
    //

    #ifdef UNIDRV

    {
        PFEATURE    pFeature;
        PMEMOPTION  pMemOption;
        DWORD       dwIndex;

        if (! (pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_MEMOPTION)))
            return GDI_ERROR;

        dwIndex = GET_INDEX_FROM_FEATURE(pci->pUIInfo, pFeature);
        dwIndex = pci->pCombinedOptions[dwIndex].ubCurOptIndex;

        if (! (pMemOption = PGetIndexedOption(pci->pUIInfo, pFeature, dwIndex)))
            return GDI_ERROR;

        dwFreeMem = pMemOption->dwInstalledMem;
    }

    #endif

    return dwFreeMem / KBYTES;
}



DWORD
DwEnumMediaReady(
    FORM_TRAY_TABLE pFormTrayTable,
    PDWORD          pdwResultSize
    )

/*++

Routine Description:

    Find the list of forms currently available in the printer

Arguments:

    pFormTrayTable - Points to current form-tray assignment table
    pdwResultSize - Return the size of the resulting MULTI_SZ (in bytes)

Return Value:

    Number of forms currently available

Note:

    List of supported form names are returned in place of
    the original form-tray assignment table.

    Format for form-tray assignment table is:
        tray-name form-name
        ...
        NUL

    Returned form names are in the form of:
        form-name
        ...
        NUL

    Duplicate form names are filtered out.

--*/

{
    PWSTR   pwstrOutput, pwstrNext, pwstr;
    DWORD   dwCount, dwIndex, dwLen;

    dwCount = 0;
    pwstrNext = pwstrOutput = pFormTrayTable;

    //
    // Enumerate through each entry of form-tray assignment table
    //

    while (*pwstrNext)
    {
        //
        // skip tray name field
        //

        pwstrNext += wcslen(pwstrNext) + 1;

        //
        // make sure the form name is not a duplicate
        //

        pwstr = pFormTrayTable;

        for (dwIndex=0; dwIndex < dwCount; dwIndex++)
        {
            if (_wcsicmp(pwstr, pwstrNext) == EQUAL_STRING)
                break;

            pwstr += wcslen(pwstr) + 1;
        }

        dwLen = wcslen(pwstrNext) + 1;

        if (dwIndex == dwCount)
        {
            //
            // if the form name is not a duplicate, nor Not Available, count it
            //

            if (*pwstrNext != NUL && *pwstrNext != L'0' && dwLen > 1)
            {
                MoveMemory(pwstrOutput, pwstrNext, dwLen * sizeof(WCHAR));
                pwstrOutput += dwLen;
                dwCount++;
            }
        }

        //
        // go past the form name field
        //

        pwstrNext += dwLen;
    }

    *pwstrOutput++ = NUL;

    if (pdwResultSize != NULL)
        *pdwResultSize = (DWORD)(pwstrOutput - pFormTrayTable) * sizeof(WCHAR);

    return dwCount;
}



DWORD
DwEnumNupOptions(
    PCOMMONINFO pci,
    PDWORD      pdwOutput
    )

/*++

Routine Description:

    Enumerate the list of supported printer description languages

Arguments:

    pci - Points to common printer info
    pdwOutput - Points to output buffer

Return Value:

    Number of N-up options supported
    GDI_ERROR if there is an error

--*/

{
    static CONST DWORD adwNupOptions[] = { 1, 2, 4, 6, 9, 16 };

    if (pdwOutput)
        CopyMemory(pdwOutput, adwNupOptions, sizeof(adwNupOptions));

    return sizeof(adwNupOptions) / sizeof(DWORD);
}



DWORD
DwEnumMediaTypes(
    IN  PCOMMONINFO pci,
    OUT PTSTR       pMediaTypeNames,
    OUT PDWORD      pMediaTypes
    )

/*++

Routine Description:

    Retrieves the display names and indices of supported media types

Arguments:

    pci - points to common printer information
    pMediaTypeNames - output buffer for returning supported media type names
    pMediaTypes - output buffer for returning supported media type indices

    (Both pMediaTypeNames and pMediaTypes will be NULL if caller if only
    asking for the number of supported media types.)

Return Value:

    Number of media types supported.

--*/

{
    PFEATURE    pFeature;
    DWORD       dwIndex, dwCount;

    //
    // This function is used to support both DC_MEDIATYPENAMES and DC_MEDIATYPES.
    // pMediaTypeNames or pMediaTypes should not both be non-NULL.
    //

    ASSERT(pMediaTypeNames == NULL || pMediaTypes == NULL);

    //
    // Go through the list of media types supported by the printer
    //

    pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_MEDIATYPE);

    if (pFeature == NULL)
    {
        //
        // Media type feature is not supported by the printer.
        //

        return 0;
    }

    if (pMediaTypeNames == NULL && pMediaTypes == NULL)
    {
        //
        // caller is only asking for the number of supported media types
        //

        return pFeature->Options.dwCount;
    }

    dwCount = 0;

    for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++)
    {
        PMEDIATYPE  pMediaType;

        pMediaType = PGetIndexedOption(pci->pUIInfo, pFeature, dwIndex);
        ASSERT(pMediaType != NULL);

        if (pMediaTypeNames)
        {
            if (LOAD_STRING_OPTION_NAME(pci, pMediaType, pMediaTypeNames, CCHMEDIATYPENAME))
            {
                dwCount++;
                pMediaTypeNames += CCHMEDIATYPENAME;
            }
            else
            {
                ERR(("LOAD_STRING_OPTION_NAME failed for MediaType option %d\n", dwIndex));
            }
        }
        else if (pMediaTypes)
        {
            *pMediaTypes++ = pMediaType->dwMediaTypeID;
            dwCount++;
        }
    }

    return dwCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\driverui.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    driverui.h

Abstract:

    Header file for driverui.c

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/09/97 -davidx-
        Consistent handling of common printer info (COMMONINFO)

    02/04/97 -davidx-
        Reorganize driver UI to separate ps and uni DLLs.

    07/17/96 -amandan-
        Created it.

--*/

#ifndef _DRIVERUI_H_
#define _DRIVERUI_H_

//
// Global critical section used when accessing shared data
//

// extern CRITICAL_SECTION gCriticalSection;

// #define ENTER_CRITICAL_SECTION() EnterCriticalSection(&gCriticalSection)
// #define LEAVE_CRITICAL_SECTION() LeaveCriticalSection(&gCriticalSection)

//
// Allocate zero-filled memory from a heap
//

#define HEAPALLOC(hheap,size)   HeapAlloc(hheap, HEAP_ZERO_MEMORY, size)
#define HEAPREALLOC(hheap, pOrig, size) HeapReAlloc(hheap, HEAP_ZERO_MEMORY, pOrig, size)

//
// Various hardcoded limits
//

#define CCHBINNAME              24      // max length for bin names
#define CCHPAPERNAME            64      // max length for form names
#define CCHMEDIATYPENAME        64      // max length for mediatype names
#define CCHLANGNAME             32      // max length for language strings
#define MIN_OPTIONS_ALLOWED     2
#define UNUSED_PARAM            0xFFFFFFFF

//
// PostScript and UniDriver driver private devmode
//

#ifdef  PSCRIPT
#define PDRIVEREXTRA    PPSDRVEXTRA
#endif

#ifdef  UNIDRV
#define PDRIVEREXTRA    PUNIDRVEXTRA
typedef struct _WINRESDATA WINRESDATA;
#endif

#define PGetDevmodeOptionsArray(pdm) \
        (((PDRIVEREXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdm))->aOptions)

#define GETUSERDATASIZE(UserData) \
    ( ((PUSERDATA)(UserData))->dwSize )

#define GETUSERDATAITEM(UserData) \
    ( ((PUSERDATA)(UserData))->dwItemID )

#define GETUSERDATAKEYWORDNAME(UserData) \
    ( ((PUSERDATA)(UserData))->pKeyWordName )

#define SETUSERDATAID(pOptItem, dwID) \
    ( ((PUSERDATA)((pOptItem)->UserData))->dwItemID = dwID)

#define SETUSERDATA_SIZE(pOptItem, dwSize) \
    ( ((PUSERDATA)((pOptItem)->UserData))->dwSize = dwSize)

#define SETUSERDATA_KEYWORDNAME(ci, pOptItem, pFeature) \
     ((PUSERDATA)((pOptItem)->UserData))->pKeyWordName = \
            OFFSET_TO_POINTER(ci.pUIInfo->pubResourceData, pFeature->loKeywordName)


//
// Common data structure which is needed whether UI comes up or not
//

typedef struct _COMMONINFO {

    OEMUIOBJ        oemuiobj;           // support info for OEM plugins
    PVOID           pvStartSign;        // signature
    PTSTR           pPrinterName;       // current printer name
    HANDLE          hPrinter;           // handle to current printer
    DWORD           dwFlags;            // miscellaneous flag bits
    PDRIVER_INFO_3  pDriverInfo3;       // driver info level 3
    PRAWBINARYDATA  pRawData;           // raw printer description data
    PINFOHEADER     pInfoHeader;        // current printer description data instance
    PUIINFO         pUIInfo;            // UIINFO structure inside above instance
    POEM_PLUGINS    pOemPlugins;        // OEM plugin information
    PDEVMODE        pdm;                // devmode information
    PDRIVEREXTRA    pdmPrivate;         // driver private devmode fields
    PPRINTERDATA    pPrinterData;       // printer-sticky property data
    POPTSELECT      pCombinedOptions;   // combined options array
    PFORM_INFO_1    pSplForms;          // spooler forms
    DWORD           dwSplForms;         // number of spooler forms
    HANDLE          hHeap;              // heap used to display UI

    #ifdef UNIDRV

    WINRESDATA      *pWinResData;

    #endif

} COMMONINFO, *PCOMMONINFO;

//
// Flag constants for COMMONINFO.dwFlags field
//

#define FLAG_OPENPRINTER_NORMAL     0x0001
#define FLAG_OPEN_CONDITIONAL       0x0002
#define FLAG_OPENPRINTER_ADMIN      0x0004
#define FLAG_INIT_PRINTER           0x0008
#define FLAG_ALLOCATE_UIDATA        0x0010
#define FLAG_PROCESS_INIFILE        0x0020
#define FLAG_REFRESH_PARSED_DATA    0x0040
#define FLAG_WITHIN_PLUGINCALL      0x0080
#define FLAG_APPLYNOW_CALLED        0x0100
#define FLAG_PLUGIN_CHANGED_OPTITEM 0x0200
#define FLAG_USER_CHANGED_FREEMEM   0x0400
#define FLAG_PROPSHEET_SESSION      0x0800
#define FLAG_UPGRADE_PRINTER        0x1000

#define IS_WITHIN_PROPSHEET_SESSION(pci) ((pci)->dwFlags & FLAG_PROPSHEET_SESSION)

//
// Special entry point for getting around EnumForm bug in spooler
//

DWORD
DrvSplDeviceCaps(
    HANDLE      hPrinter,
    PWSTR       pDeviceName,
    WORD        wCapability,
    PVOID       pOutput,
    DWORD       dwOutputSize,
    PDEVMODE    pdmSrc
    );


//
// Load basic information needed by the driver UI
//

PCOMMONINFO
PLoadCommonInfo(
    IN HANDLE       hPrinter,
    IN PTSTR        ptstrPrinterName,
    IN DWORD        dwFlags
    );

//
// Release common information used by the driver UI
//

VOID
VFreeCommonInfo(
    IN PCOMMONINFO  pci
    );

//
// Populate the devmode fields in the COMMONINFO structure
//

BOOL
BFillCommonInfoDevmode(
    IN OUT PCOMMONINFO  pci,
    IN PDEVMODE         pdmPrinter,
    IN PDEVMODE         pdmInput
    );

//
// Populate the printer-sticky property data field
//

BOOL
BFillCommonInfoPrinterData(
    IN OUT PCOMMONINFO  pci
    );

//
// Combined document-sticky feature selections and printer-sticky
// feature selection into a single options array
//

BOOL
BCombineCommonInfoOptionsArray(
    IN OUT PCOMMONINFO  pci
    );

//
// Get an updated printer description data instance
// using the combined options array
//

BOOL
BUpdateUIInfo(
    IN OUT PCOMMONINFO  pci
    );

//
// Fix up combined options array with information from public devmode fields
//

VOID
VFixOptionsArrayWithDevmode(
    IN OUT PCOMMONINFO  pci
    );

//
// Convert option array setting into public devmode fields
//

VOID
VOptionsToDevmodeFields(
    IN OUT PCOMMONINFO  pci,
    IN BOOL             bUpdateFormFields
    );

#ifndef WINNT_40
//
// Notify DS of update
//
VOID
VNotifyDSOfUpdate(
    IN  HANDLE  hPrinter
    );
#endif

//
// Get a read-only copy of a display name:
//  1)  if the display name is in the binary printer description data,
//      then we simply return a pointer to that data.
//  2)  otherwise, the display name is in the resource DLL.
//      we allocate memory out of the driver's heap and
//      load the string.
//
// Caller should NOT free the returned pointer. The memory
// will go away when the binary printer description data is unloaded
// or when the driver's heap is destroyed.
//
// Since PSCRIPT currently doesn't have any resource DLL,
// we define this as a macro to save a function call.
//

#ifdef PSCRIPT

#define PGetReadOnlyDisplayName(pci, loOffset) \
        OFFSET_TO_POINTER((pci)->pUIInfo->pubResourceData, (loOffset))

#else

PWSTR
PGetReadOnlyDisplayName(
    PCOMMONINFO pci,
    PTRREF      loOffset
    );

#endif

//
// This macro is defined as a convenience to get a read-only
// copy of the display name for an option.
//

#define GET_OPTION_DISPLAY_NAME(pci, pOption) \
        PGetReadOnlyDisplayName(pci, ((POPTION) (pOption))->loDisplayName)

//
// This function is similar to PGetReadOnlyDisplayName
// but the caller must provide the buffer for loading the string.
//

BOOL
BLoadDisplayNameString(
    PCOMMONINFO pci,
    PTRREF      loOffset,
    PWSTR       pwstrBuf,
    INT         iMaxChars
    );

BOOL
BLoadPageSizeNameString(
    PCOMMONINFO pci,
    PTRREF      loOffset,
    PWSTR       pwstrBuf,
    INT         iMaxChars,
    INT         iStdID
    );


//
// Convenience macro for loading the display name of an option
// into a caller-provided buffer.
//

#define LOAD_STRING_OPTION_NAME(pci, pOption, pwch, maxsize) \
        BLoadDisplayNameString(pci, ((POPTION) (pOption))->loDisplayName, pwch, maxsize)

#define LOAD_STRING_PAGESIZE_NAME(pci, pPageSize, pwch, maxsize) \
        BLoadPageSizeNameString(pci, (pPageSize)->GenericOption.loDisplayName, pwch, maxsize, (pPageSize)->dwPaperSizeID)


//
// Load icon resource from the resource DLL
//

ULONG_PTR
HLoadIconFromResourceDLL(
    PCOMMONINFO pci,
    DWORD       dwIconID
    );

//
// Data structure which is used only when UI is displayed
// IMPORTANT: The first field must be a COMMONINFO structure.
//

typedef struct _UIDATA {

    COMMONINFO      ci;
    INT             iMode;
    HWND            hDlg;
    BOOL            bPermission;
    BOOL            bIgnoreConflict;
    BOOL            bEMFSpooling;
    PFNCOMPROPSHEET pfnComPropSheet;
    HANDLE          hComPropSheet;
    PCOMPROPSHEETUI pCompstui;

    //
    // These fields are valid only when a dialog is presented
    //

    DWORD           dwFormNames;
    PWSTR           pFormNames;
    PWORD           pwPapers;
    PWORD           pwPaperFeatures;
    DWORD           dwBinNames;
    PWSTR           pBinNames;

    //
    // Used for helper functions
    //

    BOOL            abEnabledOptions[MAX_PRINTER_OPTIONS];

    //
    // Fields for keeping track of various option items
    //

    DWORD           dwDrvOptItem;
    POPTITEM        pDrvOptItem;

    DWORD           dwFormTrayItem;
    POPTITEM        pFormTrayItems;

    DWORD           dwTTFontItem;
    POPTITEM        pTTFontItems;

    DWORD           dwFeatureItem;
    POPTITEM        pFeatureItems;
    POPTITEM        pFeatureHdrItem;

    //
    // These fields are used for packing option items
    //

    DWORD           dwOptItem;
    POPTITEM        pOptItem;
    DWORD           dwOptType;
    POPTTYPE        pOptType;

    //
    // UniDriver specific fields
    //

    #ifdef UNIDRV

    //
    // Font Cart Table
    //

    DWORD           dwFontCart;
    POPTITEM        pFontCart;

    //
    // Device halftone setup info
    //

    PDEVHTINFO      pDevHTInfo;

    #endif // UNIDRV

    DWORD           dwHideFlags;
    PVOID           pvEndSign;

} UIDATA, *PUIDATA;

//
// Flag constants for UIDATA.dwHideFlags field
//

#define HIDEFLAG_HIDE_STD_DOCPROP     0x0001
#define HIDEFLAG_HIDE_STD_PRNPROP     0x0002

#define IS_HIDING_STD_UI(pUiData) \
    ((((pUiData)->iMode == MODE_DOCUMENT_STICKY) &&           \
      ((pUiData)->dwHideFlags & HIDEFLAG_HIDE_STD_DOCPROP)) ||  \
     (((pUiData)->iMode == MODE_PRINTER_STICKY) &&            \
      ((pUiData)->dwHideFlags & HIDEFLAG_HIDE_STD_PRNPROP)))

#define VALIDUIDATA(pUiData)    ((pUiData) && \
                                 (pUiData) == (pUiData)->ci.pvStartSign && \
                                 (pUiData) == (pUiData)->pvEndSign)

#define HASPERMISSION(pUiData)  ((pUiData)->bPermission)

//
// This function is called by DrvDocumentPropertySheets and
// DrvPrinterPropertySheets. It allocates and initializes
// a UIDATA structure that's used to display property pages.
//

PUIDATA
PFillUiData(
    IN HANDLE       hPrinter,
    IN PTSTR        pPrinterName,
    IN PDEVMODE     pdmInput,
    IN INT          iMode
    );

//
// Dispose of a UIDATA structure -
// Just disposed of the embedded COMMONINFO structure
//

#define VFreeUiData(pUiData)    VFreeCommonInfo((PCOMMONINFO) (pUiData))

//
// Data structure used to pass parameters to "Conflicts" dialog
//

typedef struct _DLGPARAM {

    PFNCOMPROPSHEET pfnComPropSheet;
    HANDLE          hComPropSheet;
    PUIDATA         pUiData;
    BOOL            bFinal;
    POPTITEM        pOptItem;
    DWORD           dwResult;

} DLGPARAM, *PDLGPARAM;

#define CONFLICT_NONE       IDOK
#define CONFLICT_RESOLVE    IDC_RESOLVE
#define CONFLICT_CANCEL     IDC_CANCEL
#define CONFLICT_IGNORE     IDC_IGNORE

//
// Functions used to implement DeviceCapabilities:
//  calculate minimum or maximum paper size extent
//  get list of supported paper size names, indices, and dimensions
//  get list of supported paper bin names and indices
//  get list of supported resolutions
//

DWORD
DwCalcMinMaxExtent(
    IN  PCOMMONINFO pci,
    OUT PPOINT      pptOutput,
    IN  WORD        wCapability
    );

DWORD
DwEnumPaperSizes(
    IN OUT PCOMMONINFO  pci,
    OUT PWSTR           pPaperNames,
    OUT PWORD           pPapers,
    OUT PPOINT          pPaperSizes,
    IN  PWORD           pPaperFeatures,
    IN  LONG            cchPaperNamesBufSize
    );

DWORD
DwEnumBinNames(
    IN  PCOMMONINFO pci,
    OUT PWSTR       pBinNames
    );

DWORD
DwEnumBins(
    IN  PCOMMONINFO pci,
    OUT PWORD       pBins
    );

DWORD
DwEnumResolutions(
    IN  PCOMMONINFO pci,
    OUT PLONG       pResolutions
    );

DWORD
DwEnumNupOptions(
    PCOMMONINFO     pci,
    PDWORD          pdwOutput
    );

DWORD
DwGetAvailablePrinterMem(
    IN PCOMMONINFO  pci
    );

DWORD
DwEnumMediaReady(
    IN OUT FORM_TRAY_TABLE  pFormTrayTable,
    OUT PDWORD              pdwResultSize
    );

#ifndef WINNT_40

//
// DC_MEDIATYPENAMES and DC_MEDIATYPES are added in Whistler.
// We need to do following so the driver can also be built with
// Win2K SDK/DDK.
//

#ifndef DC_MEDIATYPENAMES
#define DC_MEDIATYPENAMES       34
#endif

#ifndef DC_MEDIATYPES
#define DC_MEDIATYPES           35
#endif

#endif // !WINNT_40

DWORD
DwEnumMediaTypes(
    IN  PCOMMONINFO pci,
    OUT PTSTR       pMediaTypeNames,
    OUT PDWORD      pMediaTypes
    );

//
// Functions for dealing with forms
//

BOOL
BFormSupportedOnPrinter(
    IN PCOMMONINFO  pci,
    IN PFORM_INFO_1 pFormInfo,
    OUT PDWORD      pdwOptionIndex
    );

BOOL
BPackItemFormTrayTable(
    IN OUT PUIDATA  pUiData
    );

BOOL
BUnpackItemFormTrayTable(
    IN OUT PUIDATA  pUiData
    );

VOID
VSetupFormTrayAssignments(
    IN PUIDATA  pUiData
    );

DWORD
DwFindFormNameIndex(
    IN  PUIDATA pUiData,
    IN  PWSTR   pFormName,
    OUT PBOOL   pbSupported
    );

ULONG_PTR
HLoadFormIconResource(
    PUIDATA pUiData,
    DWORD   dwIndex
    );

DWORD
DwGuessFormIconID(
    PWSTR   pFormName
    );

//
// Functions prototypes for commonui related items.
//

PCOMPROPSHEETUI
PPrepareDataForCommonUI(
    IN OUT PUIDATA  pUiData,
    IN PDLGPAGE     pDlgPage
    );

BOOL
BPackPrinterPropertyItems(
    IN OUT PUIDATA  pUiData
    );

BOOL
BPackDocumentPropertyItems(
    IN OUT PUIDATA  pUiData
    );

VOID
VPackOptItemGroupHeader(
    IN OUT PUIDATA  pUiData,
    IN DWORD        dwTitleId,
    IN DWORD        dwIconId,
    IN DWORD        dwHelpIndex
    );

BOOL
BPackOptItemTemplate(
    IN OUT PUIDATA  pUiData,
    IN CONST WORD   pwItemInfo[],
    IN DWORD        dwSelection,
    IN PFEATURE     pFeature
    );

#define ITEM_INFO_SIGNATURE 0xCAFE

BOOL
BPackUDArrowItemTemplate(
    IN OUT PUIDATA  pUiData,
    IN CONST WORD   pwItemInfo[],
    IN DWORD        dwSelection,
    IN DWORD        dwMaxVal,
    IN PFEATURE     pFeature
    );

POPTPARAM
PFillOutOptType(
    OUT POPTTYPE    pOptType,
    IN  DWORD       dwType,
    IN  DWORD       dwParams,
    IN  HANDLE      hHeap
    );

PFEATURE
PGetFeatureFromItem(
    IN      PUIINFO  pUIInfo,
    IN OUT  POPTITEM pOptItem,
    OUT     PDWORD   pdwFeatureIndex
    );

BOOL
BPackItemGenericOptions(
    IN OUT PUIDATA  pUiData
    );

BOOL
BPackItemPrinterFeature(
    IN OUT PUIDATA  pUiData,
    IN PFEATURE     pFeature,
    IN DWORD        dwLevel,
    IN DWORD        dwPub,
    IN ULONG_PTR    dwUserData,
    IN DWORD        dwHelpIndex
    );

DWORD
DwCountDisplayableGenericFeature(
    IN PUIDATA      pUiData,
    BOOL            bPrinterSticky
    );

BOOL
BShouldDisplayGenericFeature(
    IN PFEATURE     pFeature,
    IN BOOL         bPrinterSticky
    );

BOOL
BOptItemSelectionsChanged(
    IN OUT  POPTITEM pItems,
    IN     DWORD     dwItems
    );

POPTITEM
PFindOptItem(
    IN PUIDATA  pUiData,
    IN DWORD    dwItemId
    );

BOOL
BPackItemFontSubstTable(
    IN PUIDATA  pUiData
    );

BOOL
BUnpackItemFontSubstTable(
    IN PUIDATA  pUiData
    );

PTSTR
PtstrDuplicateStringFromHeap(
    IN PTSTR    ptstrSrc,
    IN HANDLE   hHeap
    );

VOID
VUpdateOptionsArrayWithSelection(
    IN OUT PUIDATA  pUiData,
    IN POPTITEM     pOptItem
    );

VOID
VUnpackDocumentPropertiesItems(
    IN  OUT PUIDATA     pUiData,
    IN  OUT POPTITEM    pOptItem,
    IN  DWORD           dwCound);

BOOL
BGetPageOrderFlag(
    IN PCOMMONINFO  pci
    );

VOID
VPropShowConstraints(
    IN PUIDATA  pUiData,
    IN INT      iMode
    );

INT
ICheckConstraintsDlg(
    IN OUT  PUIDATA     pUiData,
    IN OUT  POPTITEM    pOptItem,
    IN     DWORD        dwOptItem,
    IN      BOOL        bFinal
    );

#define CONSTRAINED_FLAG            OPTPF_OVERLAY_WARNING_ICON
#define IS_CONSTRAINED(pitem, sel) ((pitem)->pOptType->pOptParam[sel].Flags & CONSTRAINED_FLAG)

//
// This function copy a source devmode to an output devmode buffer.
// It should be called by the driver just before the driver returns
// to the caller of DrvDocumentPropertySheets.
//

BOOL
BConvertDevmodeOut(
    IN  PDEVMODE pdmSrc,
    IN  PDEVMODE pdmIn,
    OUT PDEVMODE pdmOut
    );

//
// Find the OPTITEM with UserData's pKeywordName matching given keyword name
//

POPTITEM
PFindOptItemWithKeyword(
    IN  PUIDATA pUiData,
    IN  PCSTR   pKeywordName
    );

//
// Find the OPTITEM containing the specified UserData value
//

POPTITEM
PFindOptItemWithUserData(
    IN  PUIDATA pUiData,
    IN  DWORD   UserData
    );

//
// Sync up OPTITEM list with the updated options array
//

VOID
VUpdateOptItemList(
    IN OUT  PUIDATA     pUiData,
    IN      POPTSELECT  pOldCombinedOptions,
    IN      POPTSELECT  pNewCombinedOptions
    );

//
// Display an error message box
//

INT
IDisplayErrorMessageBox(
    HWND    hwndParent,
    UINT    uType,
    INT     iTitleStrId,
    INT     iFormatStrId,
    ...
    );

BOOL
BPrepareForLoadingResource(
    PCOMMONINFO pci,
    BOOL        bNeedHeap
    );


//
// Fill out an OPTITEM structure
//

#define FILLOPTITEM(poptitem,popttype,name,sel,level,dmpub,userdata,help)   \
        (poptitem)->cbSize = sizeof(OPTITEM);                               \
        (poptitem)->Flags |= OPTIF_CALLBACK;                                \
        (poptitem)->pOptType = (popttype);                                  \
        (poptitem)->pName = (PWSTR) (name);                                 \
        (poptitem)->pSel = (PVOID) (sel);                                   \
        (poptitem)->Level = (BYTE) (level);                                 \
        (poptitem)->DMPubID = (BYTE) (dmpub);                               \
        SETUSERDATAID(poptitem, userdata);                                  \
        (poptitem)->HelpIndex = (help)

//
// Tree view item level
//

#define TVITEM_LEVEL1           1
#define TVITEM_LEVEL2           2
#define TVITEM_LEVEL3           3

enum {
    UNKNOWN_ITEM,

    FONT_SUBST_ITEM,
    FONTSLOT_ITEM,
    PRINTER_VM_ITEM,
    HALFTONE_SETUP_ITEM,
    IGNORE_DEVFONT_ITEM,
    PSPROTOCOL_ITEM,
    JOB_TIMEOUT_ITEM,
    WAIT_TIMEOUT_ITEM,

    COPIES_COLLATE_ITEM,
    SCALE_ITEM,
    COLOR_ITEM,
    ICMMETHOD_ITEM,
    ICMINTENT_ITEM,
    TTOPTION_ITEM,
    METASPOOL_ITEM,
    NUP_ITEM,
    REVPRINT_ITEM,
    MIRROR_ITEM,
    NEGATIVE_ITEM,
    COMPRESSBMP_ITEM,
    CTRLD_BEFORE_ITEM,
    CTRLD_AFTER_ITEM,
    TEXT_ASGRX_ITEM,
    PAGE_PROTECT_ITEM,
    PSOUTPUT_OPTION_ITEM,
    PSTT_DLFORMAT_ITEM,
    PSLEVEL_ITEM,
    PSERROR_HANDLER_ITEM,
    PSMINOUTLINE_ITEM,
    PSMAXBITMAP_ITEM,
    PSHALFTONE_FREQ_ITEM,
    PSHALFTONE_ANGLE_ITEM,
    QUALITY_SETTINGS_ITEM,
    SOFTFONT_SETTINGS_ITEM,

    TRUE_GRAY_TEXT_ITEM,
    TRUE_GRAY_GRAPH_ITEM,

    ADD_EURO_ITEM,

    //
    // !!! Only items whose UserData value is larger than
    // CONSTRAINABLE_ITEM can have constraints.
    //

    CONSTRAINABLE_ITEM = 0x8000,
    ORIENTATION_ITEM = CONSTRAINABLE_ITEM,
    DUPLEX_ITEM,
    RESOLUTION_ITEM,
    INPUTSLOT_ITEM,
    FORMNAME_ITEM,
    MEDIATYPE_ITEM,
    COLORMODE_ITEM,
    HALFTONING_ITEM,
    FORM_TRAY_ITEM,
};

//
// Interpretation of OPTITEM.UserData: If it's less than 0x10000
// then it's one of the constants defined above. Otherwise, it's
// a pointer to a FEATURE object.
//

#define DRIVERUI_MAX_ITEM               0x10000

#define ISPRINTERFEATUREITEM(userData)  (GETUSERDATAITEM(userData) >= DRIVERUI_MAX_ITEM)
#define ISCONSTRAINABLEITEM(userData)   (GETUSERDATAITEM(userData) >= CONSTRAINABLE_ITEM)
#define ISFORMTRAYITEM(userData)        (GETUSERDATAITEM(userData) == FORM_TRAY_ITEM)
#define ISFONTSUBSTITEM(userData)       (GETUSERDATAITEM(userData) == FONT_SUBST_ITEM)

//
// Determine whether certain features are supported on the printer
//

#ifdef UNIDRV
#define SUPPORTS_DUPLEX(pci) \
        ((!_BFeatureDisabled(pci, 0xFFFFFFFF, GID_DUPLEX)) && \
        (GET_PREDEFINED_FEATURE((pci)->pUIInfo, GID_DUPLEX) != NULL))
#else
#define SUPPORTS_DUPLEX(pci) \
        ((_BSupportFeature(pci, GID_DUPLEX, NULL)) && \
        (GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_DUPLEX) != NULL))
#endif // UNIDRV

#define SUPPORTS_PAGE_PROTECT(pUIInfo) \
        (GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGEPROTECTION) != NULL)

#ifdef UNIDRV
#define PRINTER_SUPPORTS_COLLATE(pci) \
        ((!_BFeatureDisabled(pci, 0xFFFFFFFF, GID_COLLATE)) && \
        (GET_PREDEFINED_FEATURE((pci)->pUIInfo, GID_COLLATE) != NULL))
#else
#define PRINTER_SUPPORTS_COLLATE(pci) \
        ((_BSupportFeature(pci, GID_COLLATE, NULL)) && \
        (GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_COLLATE) != NULL))
#endif // UNIDRV

#ifdef WINNT_40
#define DRIVER_SUPPORTS_COLLATE(pci)    PRINTER_SUPPORTS_COLLATE(pci)
#else
#define DRIVER_SUPPORTS_COLLATE(pci)    TRUE
#endif


//
// Data structure containing information about cached driver files
//

typedef struct _CACHEDFILE {

    HANDLE  hRemoteFile;        // open handle to remote file on the server
    PWSTR   pRemoteDir;         // remote directory on the server
    PWSTR   pLocalDir;          // local directory
    PWSTR   pFilename;          // name of the cached file

} CACHEDFILE, *PCACHEDFILE;

//
// Functions for copying files over during point and print
//

BOOL _BPrepareToCopyCachedFile(HANDLE, PCACHEDFILE, PWSTR);
BOOL _BCopyCachedFile(PCOMMONINFO, PCACHEDFILE);
VOID _VDisposeCachedFileInfo(PCACHEDFILE);

//
// Driver specific functions (implemented in ps and uni subdirectories)
//

DWORD _DwEnumPersonalities(PCOMMONINFO, PWSTR);
DWORD _DwGetOrientationAngle(PUIINFO, PDEVMODE);
BOOL _BPackDocumentOptions(PUIDATA);
VOID _VUnpackDocumentOptions(POPTITEM, PDEVMODE);
BOOL _BPackPrinterOptions(PUIDATA);
BOOL _BPackOrientationItem(PUIDATA);
INT _IListDevFontNames(HDC, PWSTR, INT);
INT_PTR CALLBACK _AboutDlgProc(HWND, UINT, WPARAM, LPARAM);
#define FREE_DEFAULT_FONTSUB_TABLE(pTTSubstTable) MemFree(pTTSubstTable)

#ifdef PSCRIPT

#define _PwstrGetCallerName()               ((PWSTR) IDS_POSTSCRIPT)
#define _DwGetFontCap(pUIInfo)              (DCTT_DOWNLOAD | DCTT_SUBDEV)
#define _DwGetDefaultResolution()           DEFAULT_RESOLUTION
#define _DwGetPrinterIconID()               IDI_CPSUI_POSTSCRIPT
#define _BUnpackPrinterOptions(pUiData)     TRUE

BOOL _BSupportStapling(PCOMMONINFO);
VOID _VUnpackDriverPrnPropItem(PUIDATA, POPTITEM);
BOOL _BPackItemScale(PUIDATA);
BOOL _BPackFontSubstItems(PUIDATA);
BOOL _BSupportFeature(PCOMMONINFO, DWORD, PFEATURE);
BOOL BDisplayPSCustomPageSizeDialog(PUIDATA);
BOOL BUpdateModelNtfFilename(PCOMMONINFO);
VOID VSyncRevPrintAndOutputOrder(PUIDATA, POPTITEM);

#ifdef WINNT_40
BOOL BUpdateVMErrorMessageID(PCOMMONINFO);
#endif // WINNT_40

#define ISSET_MFSPOOL_FLAG(pdmExtra)    ((pdmExtra)->dwFlags & PSDEVMODE_METAFILE_SPOOL)
#define SET_MFSPOOL_FLAG(pdmExtra)      ((pdmExtra)->dwFlags |= PSDEVMODE_METAFILE_SPOOL)
#define CLEAR_MFSPOOL_FLAG(pdmExtra)    ((pdmExtra)->dwFlags &= ~PSDEVMODE_METAFILE_SPOOL)
#define NUPOPTION(pdmExtra)             ((pdmExtra)->iLayout)
#define REVPRINTOPTION(pdmExtra)        ((pdmExtra)->bReversePrint)
#define GET_DEFAULT_FONTSUB_TABLE(pci, pUIInfo) PtstrGetDefaultTTSubstTable(pUIInfo)
#define NOT_UNUSED_ITEM(bOrderReversed)  TRUE
#define ILOADSTRING(pci, id, wchbuf, size)  0

#endif // PSCRIPT

#ifdef UNIDRV

#define _PwstrGetCallerName()               ((PWSTR) IDS_UNIDRV)
#define _DwGetDefaultResolution()           300
#define _BPackItemScale(pUiData)            TRUE
#define _BPackFontSubstItems(pUiData)       BPackItemFontSubstTable(pUiData)
#define _DwGetPrinterIconID()               IDI_CPSUI_PRINTER2
#define BValidateDevmodeCustomPageSizeFields(pRawData, pUIInfo, pdm, prclImageArea) FALSE
#define _VUnpackDriverPrnPropItem(pUiData, pOptItem)

DWORD _DwGetFontCap(PUIINFO);
BOOL _BUnpackPrinterOptions(PUIDATA);
BOOL _BSupportStapling(PCOMMONINFO);
BOOL _BFeatureDisabled(PCOMMONINFO, DWORD, WORD);
VOID VSyncColorInformation(PUIDATA, POPTITEM);
VOID VMakeMacroSelections(PUIDATA, POPTITEM);
VOID VUpdateMacroSelection(PUIDATA, POPTITEM);
PTSTR PtstrUniGetDefaultTTSubstTable(PCOMMONINFO, PUIINFO);
BOOL BOkToChangeColorToMono(PCOMMONINFO, PDEVMODE, SHORT * , SHORT *);

#define ISSET_MFSPOOL_FLAG(pdmExtra)    (((pdmExtra)->dwFlags & DXF_NOEMFSPOOL) == 0)
#define SET_MFSPOOL_FLAG(pdmExtra)      ((pdmExtra)->dwFlags &= ~DXF_NOEMFSPOOL)
#define CLEAR_MFSPOOL_FLAG(pdmExtra)    ((pdmExtra)->dwFlags |= DXF_NOEMFSPOOL)
#define NUPOPTION(pdmExtra)             ((pdmExtra)->iLayout)
#define REVPRINTOPTION(pdmExtra)        ((pdmExtra)->bReversePrint)

#define GET_DEFAULT_FONTSUB_TABLE(pci, pUIInfo) PtstrUniGetDefaultTTSubstTable(pci, pUIInfo)
#define NOT_UNUSED_ITEM(bOrderReversed)  (bOrderReversed != UNUSED_ITEM)
#define ILOADSTRING(pci, id, wchbuf, size) \
    ILoadStringW(((pci)->pWinResData), id, wchbuf, size)

#endif // UNIDRV

#endif  //!_DRIVERUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\driverui.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    driverui.c

Abstract:

    This file contains utility functions for the UI and the
    interface to the parser.

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/09/97 -davidx-
        Rewrote it to consistently handle common printer info
        and to clean up parser interface code.

    02/04/97 -davidx-
        Reorganize driver UI to separate ps and uni DLLs.

    07/17/96 -amandan-
        Created it.

--*/

#include "precomp.h"

HANDLE HCreateHeapForCI();


PCOMMONINFO
PLoadCommonInfo(
    HANDLE      hPrinter,
    PTSTR       pPrinterName,
    DWORD       dwFlags
    )

/*++

Routine Description:

    Load basic information needed by the driver UI such as:
        printer driver info level 2
        load raw printer description data
        printer description data instance based on default settings
        get information about OEM plugins
        load OEM UI modules

Arguments:

    hPrinter - Handle to the current printer
    pPrinterName - Points to the current printer name
    dwFlags - One of the following combinations:
        0
        FLAG_ALLOCATE_UIDATA
        FLAG_OPENPRINTER_NORMAL [ | FLAG_OPEN_CONDITIONAL ]
        FLAG_OPENPRINTER_ADMIN [ | FLAG_INIT_PRINTER ]
        FLAG_OPENPRINTER_ADMIN [ | FLAG_PROCESS_INIFILE ]

Return Value:

    Pointer to an allocated COMMONINFO structure if successful
    NULL if there is an error

--*/

{
    static PRINTER_DEFAULTS PrinterDefaults = { NULL, NULL, PRINTER_ALL_ACCESS };
    PCOMMONINFO pci;
    DWORD       dwSize;

    //
    // Allocate memory for a COMMONINFO structure
    //

    dwSize = (dwFlags & FLAG_ALLOCATE_UIDATA) ?  sizeof(UIDATA) : sizeof(COMMONINFO);

    if (! (pci = MemAllocZ(dwSize)) ||
        ! (pci->pPrinterName = DuplicateString(pPrinterName ? pPrinterName : TEXT("NULL"))))
    {
        ERR(("Memory allocation failed\n"));
        VFreeCommonInfo(pci);
        return NULL;
    }

    pci->pvStartSign = pci;
    pci->dwFlags = dwFlags;

    //
    // Check if we should open a handle to the current printer
    //

    if (dwFlags & (FLAG_OPENPRINTER_NORMAL | FLAG_OPENPRINTER_ADMIN))
    {
        ASSERT(hPrinter == NULL && pPrinterName != NULL);

        //
        // Open a printer handle with the specified access right
        //

        if (! OpenPrinter(pPrinterName,
                          &hPrinter,
                          (dwFlags & FLAG_OPENPRINTER_ADMIN) ? &PrinterDefaults : NULL))
        {
            ERR(("OpenPrinter failed for '%ws': %d\n", pPrinterName, GetLastError()));
            VFreeCommonInfo(pci);
            return NULL;
        }

        pci->hPrinter = hPrinter;
    }
    else
    {
        ASSERT(hPrinter != NULL);
        pci->hPrinter = hPrinter;
    }

    //
    // If the caller requires that the printer to be initialized,
    // check to make sure it is. If not, return error.
    //

    if (dwFlags & FLAG_OPEN_CONDITIONAL)
    {
        PPRINTER_INFO_2 pPrinterInfo2;
        DWORD           dwInitData;

        //
        // NOTE: We're really like to use level 4 here. But due to bug in the
        // spooler, GetPrinter level 4 doesn't work for printer connections.
        //

        dwInitData = gwDriverVersion;

        #ifdef WINNT_40
            //
            // Hack around spooler bug where DrvConvertDevmode is called before
            // DrvPrinterEvent.Initialzed is called.
            //
            if (!BGetPrinterDataDWord(hPrinter, REGVAL_PRINTER_INITED, &dwInitData))
                DrvPrinterEvent(pPrinterName, PRINTER_EVENT_INITIALIZE, 0, 0);
        #endif

        if ((pPrinterInfo2 = MyGetPrinter(hPrinter, 2)) == NULL ||
            (pPrinterInfo2->pServerName == NULL) &&
            !BGetPrinterDataDWord(hPrinter, REGVAL_PRINTER_INITED, &dwInitData))
        {
            dwInitData = 0;
        }

        MemFree(pPrinterInfo2);

        if (dwInitData != gwDriverVersion)
        {
            TERSE(("Printer not fully initialized yet: %d\n", GetLastError()));
            VFreeCommonInfo(pci);
            return NULL;
        }
    }

    //
    // Get information about the printer driver
    //

    if ((pci->pDriverInfo3 = MyGetPrinterDriver(hPrinter, NULL, 3)) == NULL)
    {
        ERR(("Cannot get printer driver info: %d\n", GetLastError()));
        VFreeCommonInfo(pci);
        return NULL;
    }

    //
    // If FLAG_INIT_PRINTER is set, we should initialize the printer here.
    //

    if (dwFlags & (FLAG_INIT_PRINTER | FLAG_PROCESS_INIFILE))
    {
        //
        // Parse OEM plugin configuration file and
        // save the resulting info into registry
        //

        if (!BProcessPrinterIniFile(hPrinter, pci->pDriverInfo3, NULL,
                                    (dwFlags & FLAG_UPGRADE_PRINTER) ? FLAG_INIPROCESS_UPGRADE : 0))
        {
            VERBOSE(("BProcessPrinterIniFile failed\n"));
        }

        //
        // If printer was successfully initialized and caller is not asking to process
        // ini file only, save a flag in the registry to indicate the fact.
        //

        if (dwFlags & FLAG_INIT_PRINTER)
        {
            (VOID) BSetPrinterDataDWord(hPrinter, REGVAL_PRINTER_INITED, gwDriverVersion);
        }
    }

    //
    // fix 317359. In case some part of the driver has changed refresh the .bpd
    // to update driver-language-specific strings in the .bpd. "Manual Feed" is
    // written by the parser and therefore the .bpd depends on the language the
    // parser was localized for. Checking the language would have to be done every time
    // something is printed, therefore we just delete the .bpd, then the it gets reparsed
    // always has the same language as the driver.
    //
    #ifdef PSCRIPT
    if (dwFlags & FLAG_REFRESH_PARSED_DATA)
    {
        DeleteRawBinaryData(pci->pDriverInfo3->pDataFile);
    }
    #endif

    //
    // Load raw binary printer description data, and
    // Get a printer description data instance using the default settings
    //
    // Notice that this is done inside a critical section (because
    // GPD parsers has lots of globals).
    //

//    ENTER_CRITICAL_SECTION();

    pci->pRawData = LoadRawBinaryData(pci->pDriverInfo3->pDataFile);

    if (pci->pRawData)
        pci->pInfoHeader = InitBinaryData(pci->pRawData, NULL, NULL);

    if (pci->pInfoHeader)
        pci->pUIInfo = OFFSET_TO_POINTER(pci->pInfoHeader, pci->pInfoHeader->loUIInfoOffset);

//    LEAVE_CRITICAL_SECTION();

    if (!pci->pRawData || !pci->pInfoHeader || !pci->pUIInfo)
    {
        ERR(("Cannot load printer description data: %d\n", GetLastError()));
        VFreeCommonInfo(pci);
        return NULL;
    }

    //
    // Get information about OEM plugins and load them
    //

    if (! (pci->pOemPlugins = PGetOemPluginInfo(hPrinter,
                                                pci->pDriverInfo3->pConfigFile,
                                                pci->pDriverInfo3)) ||
        ! BLoadOEMPluginModules(pci->pOemPlugins))
    {
        ERR(("Cannot load OEM plugins: %d\n", GetLastError()));
        VFreeCommonInfo(pci);
        return NULL;
    }

    pci->oemuiobj.cbSize = sizeof(OEMUIOBJ);
    pci->oemuiobj.pOemUIProcs = (POEMUIPROCS) &OemUIHelperFuncs;
    pci->pOemPlugins->pdriverobj = &pci->oemuiobj;
    return pci;
}



VOID
VFreeCommonInfo(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Release common information used by the driver UI

Arguments:

    pci - Common driver information to be released

Return Value:

    NONE

--*/

{
    if (pci == NULL)
        return;

    //
    // Unload OEM UI modules and free OEM plugin info
    //

    if (pci->pOemPlugins)
        VFreeOemPluginInfo(pci->pOemPlugins);

    //
    // Unload raw binary printer description data
    // and/or any printer description data instance
    //

    if (pci->pInfoHeader)
        FreeBinaryData(pci->pInfoHeader);

    if (pci->pRawData)
        UnloadRawBinaryData(pci->pRawData);

    //
    // Close the printer handle if it was opened by us
    //

    if ((pci->dwFlags & (FLAG_OPENPRINTER_NORMAL|FLAG_OPENPRINTER_ADMIN)) &&
        (pci->hPrinter != NULL))
    {
        ClosePrinter(pci->hPrinter);
    }

    #ifdef UNIDRV
    if (pci->pWinResData)
    {
        VWinResClose(pci->pWinResData);
        MemFree(pci->pWinResData);
    }
    #endif

    if (pci->hHeap)
        HeapDestroy(pci->hHeap);

    MemFree(pci->pSplForms);
    MemFree(pci->pCombinedOptions);
    MemFree(pci->pPrinterData);
    MemFree(pci->pPrinterName);
    MemFree(pci->pDriverInfo3);
    MemFree(pci->pdm);
    MemFree(pci);
}



BOOL
BFillCommonInfoDevmode(
    PCOMMONINFO pci,
    PDEVMODE    pdmPrinter,
    PDEVMODE    pdmInput
    )

/*++

Routine Description:

    Populate the devmode fields in the COMMONINFO structure.
        start out with the driver default devmode, and
        merge it with the printer default devmode, and
        merge it with the input devmode

Arguments:

    pci - Points to a COMMONINFO structure
    pdmPrinter - Points to printer default devmode
    pdmInput - Points to input devmode

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    pdmPrinter and/or pdmInput can be NULL.

--*/

{
    //
    // Start with driver default devmode
    //

    ASSERT(pci->pdm == NULL);

    pci->pdm = PGetDefaultDevmodeWithOemPlugins(
                            pci->pPrinterName,
                            pci->pUIInfo,
                            pci->pRawData,
                            IsMetricCountry(),
                            pci->pOemPlugins,
                            pci->hPrinter);

    //
    // Merge with printer default and input devmode
    //

    if (! pci->pdm ||
        ! BValidateAndMergeDevmodeWithOemPlugins(
                        pci->pdm,
                        pci->pUIInfo,
                        pci->pRawData,
                        pdmPrinter,
                        pci->pOemPlugins,
                        pci->hPrinter) ||
        ! BValidateAndMergeDevmodeWithOemPlugins(
                        pci->pdm,
                        pci->pUIInfo,
                        pci->pRawData,
                        pdmInput,
                        pci->pOemPlugins,
                        pci->hPrinter))
    {
        ERR(("Cannot process devmode information: %d\n", GetLastError()));
        return FALSE;
    }

    pci->pdmPrivate = (PDRIVEREXTRA) GET_DRIVER_PRIVATE_DEVMODE(pci->pdm);
    return TRUE;
}



BOOL
BFillCommonInfoPrinterData(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Populate the printer-sticky property data field

Arguments:

    pci - Points to basic printer info

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    ASSERT(pci->pPrinterData == NULL);

    if (pci->pPrinterData = MemAllocZ(sizeof(PRINTERDATA)))
        return BGetPrinterProperties(pci->hPrinter, pci->pRawData, pci->pPrinterData);

    ERR(("Memory allocation failed\n"));
    return FALSE;
}



BOOL
BCombineCommonInfoOptionsArray(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Combined document-sticky feature selections and printer-sticky
    feature selection into a single options array

Arguments:

    pci - Points to basic printer info

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    POPTSELECT  pDocOptions, pPrinterOptions;

    #ifdef UNIDRV

    OPTSELECT   DocOptions[MAX_PRINTER_OPTIONS];
    OPTSELECT   PrinterOptions[MAX_PRINTER_OPTIONS];

    #endif

    //
    // Allocate enough memory for the combined options array
    //

    pci->pCombinedOptions = MemAllocZ(sizeof(OPTSELECT) * MAX_COMBINED_OPTIONS);

    if (pci->pCombinedOptions == NULL)
    {
        ERR(("Memory allocation failed\n"));
        return FALSE;
    }

    pDocOptions = pci->pdm ? PGetDevmodeOptionsArray(pci->pdm) : NULL;
    pPrinterOptions = pci->pPrinterData ? pci->pPrinterData->aOptions : NULL;

    #ifdef UNIDRV

    //
    // GPD parser doesn't follow the current parser interface spec.
    // It AVs if either doc- or printer-sticky options array is NULL.
    // So we have to call it first to get appropriate default options first.
    //

    if (pDocOptions == NULL)
    {
        if (! InitDefaultOptions(pci->pRawData,
                                 DocOptions,
                                 MAX_PRINTER_OPTIONS,
                                 MODE_DOCUMENT_STICKY))
        {
            return FALSE;
        }

        pDocOptions = DocOptions;
    }

    if (pPrinterOptions == NULL)
    {
        if (! InitDefaultOptions(pci->pRawData,
                                 PrinterOptions,
                                 MAX_PRINTER_OPTIONS,
                                 MODE_PRINTER_STICKY))
        {
            return FALSE;
        }

        pPrinterOptions = PrinterOptions;
    }

    #endif // UNIDRV

    return CombineOptionArray(pci->pRawData,
                              pci->pCombinedOptions,
                              MAX_COMBINED_OPTIONS,
                              pDocOptions,
                              pPrinterOptions);
}


VOID
VFixOptionsArrayWithPaperSizeID(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Fix up combined options array with paper size information from public devmode fields

Arguments:

    pci - Points to basic printer info

Return Value:

    NONE

--*/

{

    PFEATURE pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGESIZE);
    BOOL     abEnabledOptions[MAX_PRINTER_OPTIONS];
    PDWORD   pdwPaperIndex = (PDWORD)abEnabledOptions;
    DWORD    dwCount, dwOptionIndex, i;
    WCHAR    awchBuf[CCHPAPERNAME];


    if (pFeature == NULL)
        return;

    dwCount = MapToDeviceOptIndex(pci->pInfoHeader,
                                  GID_PAGESIZE,
                                  pci->pdm->dmPaperWidth * DEVMODE_PAPER_UNIT,
                                  pci->pdm->dmPaperLength * DEVMODE_PAPER_UNIT,
                                  pdwPaperIndex);
    if (dwCount == 0 )
        return;

    if (dwCount > 1 )
    {
        PPAGESIZE pPageSize;

        for (i = 0; i < dwCount; i++)
        {
            if (pPageSize = (PPAGESIZE)PGetIndexedOption(pci->pUIInfo, pFeature, pdwPaperIndex[i]))
            {
                if ((LOAD_STRING_PAGESIZE_NAME(pci, pPageSize, awchBuf, CCHPAPERNAME)) &&
                    (_wcsicmp(pci->pdm->dmFormName, awchBuf) == EQUAL_STRING) )
                {
                    dwOptionIndex = pdwPaperIndex[i];
                    break;
                }
            }
        }

        if (i >= dwCount)
            dwOptionIndex = pdwPaperIndex[0];

    }
    else
        dwOptionIndex = pdwPaperIndex[0];

    ZeroMemory(abEnabledOptions, sizeof(abEnabledOptions));
    abEnabledOptions[dwOptionIndex] = TRUE;
    ReconstructOptionArray(pci->pRawData,
                           pci->pCombinedOptions,
                           MAX_COMBINED_OPTIONS,
                           GET_INDEX_FROM_FEATURE(pci->pUIInfo, pFeature),
                           abEnabledOptions);

}



VOID
VFixOptionsArrayWithDevmode(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Fix up combined options array with information from public devmode fields

Arguments:

    pci - Points to basic printer info

Return Value:

    NONE

--*/

{
    //
    // Mapping table from public devmode fields to GID indices
    // We assume that GID_COLORMODE corresponds to DM_COLR
    //

    static CONST struct _DMFIELDS_GID_MAPPING {
        DWORD   dwGid;
        DWORD   dwMask;
    } DMFieldsGIDMapping[] = {
        { GID_RESOLUTION,   DM_PRINTQUALITY|DM_YRESOLUTION },
        { GID_PAGESIZE,     DM_FORMNAME|DM_PAPERSIZE|DM_PAPERWIDTH|DM_PAPERLENGTH },
        { GID_DUPLEX,       DM_DUPLEX },
        { GID_INPUTSLOT,    DM_DEFAULTSOURCE },
        { GID_MEDIATYPE,    DM_MEDIATYPE },
        { GID_ORIENTATION,  DM_ORIENTATION },
        { GID_COLLATE,      DM_COLLATE },
        { GID_COLORMODE,    DM_COLOR },
    };

    INT     iIndex;
    BOOL    bConflict;

    //
    // Validate form-related devmode fields
    //

    if (pci->pSplForms == NULL)
        pci->pSplForms = MyEnumForms(pci->hPrinter, 1, &pci->dwSplForms);

    if (! BValidateDevmodeCustomPageSizeFields(
                pci->pRawData,
                pci->pUIInfo,
                pci->pdm,
                NULL) &&
        ! BValidateDevmodeFormFields(
                pci->hPrinter,
                pci->pdm,
                NULL,
                pci->pSplForms,
                pci->dwSplForms))
    {
        VDefaultDevmodeFormFields(pci->pUIInfo, pci->pdm, IsMetricCountry());
    }

    //
    // Fix up options array with information from public devmode fields
    //

    iIndex = sizeof(DMFieldsGIDMapping) / sizeof(struct _DMFIELDS_GID_MAPPING);

    while (iIndex-- > 0)
    {
        if (pci->pdm->dmFields & DMFieldsGIDMapping[iIndex].dwMask)
        {
           #if UNIDRV
                if (DMFieldsGIDMapping[iIndex].dwGid == GID_PAGESIZE)
                {
                    VFixOptionsArrayWithPaperSizeID(pci);
                }
                else
            #endif
                {
                    (VOID) ChangeOptionsViaID(pci->pInfoHeader,
                                            pci->pCombinedOptions,
                                            DMFieldsGIDMapping[iIndex].dwGid,
                                            pci->pdm);
                }
        }
    }
}



BOOL
BUpdateUIInfo(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Get an updated printer description data instance using the combined options array

Arguments:

    pci - Points to basic printer info

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PINFOHEADER pInfoHeader;

    //
    // Get an updated instance of printer description data
    //

    pInfoHeader = UpdateBinaryData(pci->pRawData,
                                   pci->pInfoHeader,
                                   pci->pCombinedOptions);


    if (pInfoHeader == NULL)
    {
        ERR(("UpdateBinaryData failed\n"));
        return FALSE;
    }

    //
    // Reset various points in COMMONINFO structure
    //

    pci->pInfoHeader = pInfoHeader;
    pci->pUIInfo = OFFSET_TO_POINTER(pInfoHeader, pInfoHeader->loUIInfoOffset);
    ASSERT(pci->pUIInfo != NULL);

    return (pci->pUIInfo != NULL);
}



BOOL
BPrepareForLoadingResource(
    PCOMMONINFO pci,
    BOOL        bNeedHeap
    )

/*++

Routine Description:

    Make sure a heap is created and the resource DLL has been loaded

Arguments:

    pci - Points to basic printer info
    bNeedHeap - Whether memory heap is necessary

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    BOOL bResult = FALSE;

    //
    // Create the memory heap if necessary
    //

    if (  bNeedHeap &&
        ! pci->hHeap &&
        ! (pci->hHeap = HCreateHeapForCI()))
    {
        return bResult;
    }

    #ifdef UNIDRV

    if (pci->pWinResData)
    {
        bResult = TRUE;
    }
    else
    {
        if ((pci->pWinResData = MemAllocZ(sizeof(WINRESDATA))) &&
            (BInitWinResData(pci->pWinResData,
                             pci->pDriverInfo3->pDriverPath,
                             pci->pUIInfo)))
            bResult = TRUE;
    }

    #endif

    return bResult;
}



#ifndef PSCRIPT

PWSTR
PGetReadOnlyDisplayName(
    PCOMMONINFO pci,
    PTRREF      loOffset
    )

/*++

Routine Description:

    Get a read-only copy of a display name:
    1)  if the display name is in the binary printer description data,
        then we simply return a pointer to that data.
    2)  otherwise, the display name is in the resource DLL.
        we allocate memory out of the driver's heap and
        load the string.

    Caller should NOT free the returned pointer. The memory
    will go away when the binary printer description data is unloaded
    or when the driver's heap is destroyed.

Arguments:

    pci - Points to basic printer info
    loOffset - Display name string offset

Return Value:

    Pointer to the requested display name string
    NULL if there is an error

--*/

{
    if (loOffset & GET_RESOURCE_FROM_DLL)
    {
        //
        // loOffset specifies a string resource ID
        // in the resource DLL
        //

        WCHAR   wchbuf[MAX_DISPLAY_NAME];
        INT     iLength;
        PWSTR   pwstr;
        HANDLE  hResDll;
        DWORD   dwResID = loOffset & ~GET_RESOURCE_FROM_DLL;

        //
        // First ensure the resource DLL has been loaded
        // and a heap has already been created
        //

        if (! BPrepareForLoadingResource(pci, TRUE))
            return NULL;

        //
        // Load string resource into a temporary buffer
        // and allocate enough memory to hold the string
        //

        iLength = ILOADSTRING(pci, dwResID, wchbuf, MAX_DISPLAY_NAME);

        pwstr = HEAPALLOC(pci->hHeap, (iLength+1) * sizeof(WCHAR));

        if (pwstr == NULL)
        {
            ERR(("Memory allocation failed\n"));
            return NULL;
        }

        //
        // Copy the string to allocated memory and
        // return a pointer to it.
        //

        CopyMemory(pwstr, wchbuf, iLength*sizeof(WCHAR));
        return pwstr;
    }
    else
    {
        //
        // loOffset is a byte offset from the beginning of
        // the resource data block
        //

        return OFFSET_TO_POINTER(pci->pUIInfo->pubResourceData, loOffset);
    }
}

#endif // !PSCRIPT



BOOL
BLoadDisplayNameString(
    PCOMMONINFO pci,
    PTRREF      loOffset,
    PWSTR       pwstrBuf,
    INT         iMaxChars
    )

/*++

Routine Description:

    This function is similar to PGetReadOnlyDisplayName
    but the caller must provide the buffer for loading the string.

Arguments:

    pci - Points to basic printer info
    loOffset - Display name string offset
    pwstrBuf - Points to buffer for storing loaded display name string
    iMaxChars - Size of output buffer in characters

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    ASSERT(pwstrBuf && iMaxChars > 0);
    pwstrBuf[0] = NUL;

    if (loOffset & GET_RESOURCE_FROM_DLL)
    {
        //
        // loOffset specifies a string resource ID
        // in the resource DLL
        //

        INT     iLength;
        HANDLE  hResDll;
        DWORD   dwResID = loOffset & ~GET_RESOURCE_FROM_DLL;

        //
        // First ensure the resource DLL has been loaded
        //

        if (! BPrepareForLoadingResource(pci, FALSE))
            return FALSE;

        //
        // Load string resource into the output buffer
        // and allocate enough memory to hold the string
        //

        iLength = ILOADSTRING(pci, dwResID, pwstrBuf, (WORD)iMaxChars);

        return (iLength > 0);
    }
    else
    {
        //
        // loOffset is a byte offset from the beginning of
        // the resource data block
        //

        PWSTR   pwstr;

        pwstr = OFFSET_TO_POINTER(pci->pUIInfo->pubResourceData, loOffset);

        if (pwstr == NULL)
            return FALSE;

        CopyString(pwstrBuf, pwstr, iMaxChars);
        return TRUE;
    }
}

BOOL
BLoadPageSizeNameString(
    PCOMMONINFO pci,
    PTRREF      loOffset,
    PWSTR       pwstrBuf,
    INT         iMaxChars,
    INT         iStdId
    )

/*++

Routine Description:

    This function is similar to PGetReadOnlyDisplayName
    but the caller must provide the buffer for loading the string.

Arguments:

    pci - Points to basic printer info
    loOffset - Display name string offset
    pwstrBuf - Points to buffer for storing loaded display name string
    iMaxChars - Size of output buffer in characters
    iStdId - Predefined standard ID for page size, e.g. DMPAPER_XXX

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{

    ASSERT(pwstrBuf && iMaxChars > 0);
    pwstrBuf[0] = NUL;

    if (loOffset == USE_SYSTEM_NAME)
    {
        PFORM_INFO_1 pForm;
        INT          iIndex = iStdId - DMPAPER_FIRST;

        //
        // iIndex is zero based.
        //

        if (pci->pSplForms == NULL ||
            (INT)pci->dwSplForms <= iIndex)
        {
            WARNING(("BLoadPageSizeName, use std name, pSplForms is NULL \n"));
            return FALSE;
        }

        pForm = pci->pSplForms + iIndex;
        CopyString(pwstrBuf, pForm->pName, iMaxChars);
        return (TRUE);

    }
    else
        return (BLoadDisplayNameString(pci, loOffset, pwstrBuf, iMaxChars));
}


ULONG_PTR
HLoadIconFromResourceDLL(
    PCOMMONINFO pci,
    DWORD       dwIconID
    )

/*++

Routine Description:

    Load icon resource from the resource DLL

Arguments:

    pci - Points to common printer info
    dwIconID - Specifies ID of the icon to be loaded

Return Value:

    Handle to the specified icon resource
    0 if the specified icon cannot be loaded

--*/

{
    #ifdef UNIDRV

    //
    // First ensure the resource DLL has been loaded
    //
    PQUALNAMEEX pQualifiedID;
    HANDLE      hModule;
    HICON       hIcon;

    if (!BPrepareForLoadingResource(pci, FALSE))
        return 0;

    pQualifiedID = (PQUALNAMEEX)&dwIconID;

    if (hModule = HGetModuleHandle(pci->pWinResData, pQualifiedID))
    {
        hIcon = LoadIcon(hModule, MAKEINTRESOURCE(pQualifiedID->wResourceID));

        if (hIcon == NULL)
        {
            ERR(("LoadIcon failed: %d\n", GetLastError()));
        }

        return (ULONG_PTR)hIcon;
    }

    #endif

    return 0;
}



PUIDATA
PFillUiData(
    HANDLE      hPrinter,
    PTSTR       pPrinterName,
    PDEVMODE    pdmInput,
    INT         iMode
    )
/*++

Routine Description:

    This function is called by DrvDocumentPropertySheets and
    DrvPrinterPropertySheets. It allocates and initializes
    a UIDATA structure that's used to display property pages.

Arguments:

    hPrinter - Handle to the current printer
    pPrinterName - Name of the current printer
    pdmInput - Input devmode
    iMode - Identify the caller:
        MODE_DOCUMENT_STICKY - called from DrvDocumentPropertySheets
        MODE_PRINTER_STICY - called from DrvPrinterPropertySheets

Return Value:

    Pointer to a UIDATA structure, NULL if there is an error

--*/

{
    PUIDATA     pUiData;
    PCOMMONINFO pci;
    BOOL        bNupOption;
    PFEATURE    pFeature;
    DWORD       dwFeatureIndex, dwOptionIndexOld, dwOptionIndexNew;
    BOOL        bUpdateFormField;

    //
    // Allocate UIDATA structure and load common information
    //

    pUiData = (PUIDATA) PLoadCommonInfo(hPrinter, pPrinterName, FLAG_ALLOCATE_UIDATA);

    if (pUiData == NULL)
        goto fill_uidata_err;

    pUiData->pvEndSign = pUiData;
    pUiData->iMode = iMode;
    pci = &pUiData->ci;

    //
    // Create a memory heap
    //

    if ((pci->hHeap = HCreateHeapForCI()) == NULL)
        goto fill_uidata_err;

    //
    // Get printer-sticky property data
    //

    if (! BFillCommonInfoPrinterData(pci))
        goto fill_uidata_err;

    //
    // If called from DrvDocumentPropertySheets, then process
    // devmode information: driver default + printer default + input devmode
    //

    if (iMode == MODE_DOCUMENT_STICKY)
    {
        PPRINTER_INFO_2 pPrinterInfo2;

        if (! (pPrinterInfo2 = MyGetPrinter(hPrinter, 2)) ||
            ! BFillCommonInfoDevmode(pci, pPrinterInfo2->pDevMode, pdmInput))
        {
            MemFree(pPrinterInfo2);
            goto fill_uidata_err;
        }

        MemFree(pPrinterInfo2);
    }

    //
    // Merge doc-sticky and printer-sticky option selections
    //

    if (! BCombineCommonInfoOptionsArray(pci))
        goto fill_uidata_err;

    //
    // If called from DrvDocumentPropertySheets,
    // fix up combined options with public devmode information
    //

    if (iMode == MODE_DOCUMENT_STICKY)
    {
        VFixOptionsArrayWithDevmode(pci);

        //
        // Remember the paper size option parser picked to support the devmode form
        //

        if ((pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGESIZE)) == NULL)
        {
            ASSERT(FALSE);
            goto fill_uidata_err;
        }

        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pci->pUIInfo, pFeature);
        dwOptionIndexOld = pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex;
    }

    VGetSpoolerEmfCaps(pci->hPrinter, &bNupOption, &pUiData->bEMFSpooling, 0, NULL);

    //
    // Resolve any conflicts between printer feature selections,
    // and get an updated printer description data instance
    // using the combined options array.
    //

    (VOID) ResolveUIConflicts(pci->pRawData,
                              pci->pCombinedOptions,
                              MAX_COMBINED_OPTIONS,
                              iMode == MODE_PRINTER_STICKY ?
                                  iMode :
                                  MODE_DOCANDPRINTER_STICKY);

    if (iMode == MODE_DOCUMENT_STICKY)
    {
        dwOptionIndexNew = pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex;

        bUpdateFormField = FALSE;

        if (dwOptionIndexNew != dwOptionIndexOld)
        {
            //
            // Constraint resolving has changed page size selection, so we need
            // to update devmode's form fields.
            //

            bUpdateFormField = TRUE;
        }
        else
        {
            FORM_INFO_1  *pForm = NULL;

            //
            // Unless the form requested by devmode is not supported on the printer,
            // we still want to show the original form name in upcoming doc-setting UI.
            // For example, if input devmode requested "Legal", parser maps it to option
            // "OEM Legal", but both "Legal" and "OEM Legal" will be shown as supported
            // forms on the printer, then we should still show "Legal" instead of "OEM Legal"
            // in UI's PageSize list. However, if input devmode requestd "8.5 x 12", which
            // won't be shown as a supportd form and it's mapped to "OEM Legal", then we should
            // show "OEM Legal".
            //

            //
            // pdm->dmFormName won't have a valid form name for custom page size (see
            // BValidateDevmodeFormFields()). VOptionsToDevmodeFields() knows to handle that.
            //

            if ((pci->pdm->dmFields & DM_FORMNAME) &&
                (pForm = MyGetForm(pci->hPrinter, pci->pdm->dmFormName, 1)) &&
                !BFormSupportedOnPrinter(pci, pForm, &dwOptionIndexNew))
            {
                bUpdateFormField = TRUE;
            }

            MemFree(pForm);
        }

        VOptionsToDevmodeFields(pci, bUpdateFormField);
    }

    if (BUpdateUIInfo(pci))
    {
        //
        // Set the flag to indicate we are within the property sheet session. This flag will
        // be used by new helper function interface to determine whether the helper function
        // is available or not.
        //

        pci->dwFlags |= FLAG_PROPSHEET_SESSION;

        return pUiData;
    }


fill_uidata_err:

    ERR(("PFillUiData failed: %d\n", GetLastError()));
    VFreeUiData(pUiData);
    return NULL;
}



PTSTR
PtstrDuplicateStringFromHeap(
    IN PTSTR    ptstrSrc,
    IN HANDLE   hHeap
    )

/*++

Routine Description:

    Duplicate a Unicode string

Arguments:

    pwstrUnicodeString - Pointer to the input Unicode string
    hHeap - Handle to a heap from which to allocate memory

Return Value:

    Pointer to the resulting Unicode string
    NULL if there is an error

--*/

{
    PTSTR   ptstrDest;
    INT     iSize;

    if (ptstrSrc == NULL)
        return NULL;

    iSize = SIZE_OF_STRING(ptstrSrc);

    if (ptstrDest = HEAPALLOC(hHeap, iSize))
        CopyMemory(ptstrDest, ptstrSrc, iSize);
    else
        ERR(("Couldn't duplicate string: %ws\n", ptstrSrc));

    return ptstrDest;
}



POPTITEM
PFindOptItemWithKeyword(
    IN  PUIDATA pUiData,
    IN  PCSTR   pKeywordName
    )

/*++

Routine Description:

    Find the OPTITEM with UserData's pKeywordName matching given keyword name

Arguments:

    pUiData - Points to UIDATA structure
    pKeywordName - Specifies the keyword name needs to be matched

Return Value:

    Pointer to the specified OPTITEM, NULL if no such item is found

--*/

{
    DWORD       dwCount;
    POPTITEM    pOptItem;

    ASSERT(VALIDUIDATA(pUiData));

    pOptItem = pUiData->pDrvOptItem;
    dwCount = pUiData->dwDrvOptItem;

    while (dwCount--)
    {
        if (((PUSERDATA)pOptItem->UserData)->pKeyWordName != NULL &&
            strcmp(((PUSERDATA)pOptItem->UserData)->pKeyWordName, pKeywordName) == EQUAL_STRING)
            return pOptItem;

        pOptItem++;
    }

    return NULL;
}




POPTITEM
PFindOptItemWithUserData(
    IN  PUIDATA pUiData,
    IN  DWORD   UserData
    )

/*++

Routine Description:

    Find the OPTITEM containing the specified UserData value

Arguments:

    pUiData - Points to UIDATA structure
    UserData - Specifies the interested UserData value

Return Value:

    Pointer to the specified OPTITEM, NULL if no such item is found

--*/

{
    DWORD       dwCount;
    POPTITEM    pOptItem;

    ASSERT(VALIDUIDATA(pUiData));

    pOptItem = pUiData->pDrvOptItem;
    dwCount = pUiData->dwDrvOptItem;

    while (dwCount--)
    {
        if (GETUSERDATAITEM(pOptItem->UserData) == UserData)
            return pOptItem;

        pOptItem++;
    }

    return NULL;
}

#ifndef WINNT_40

VOID
VNotifyDSOfUpdate(
    IN  HANDLE  hPrinter
    )

/*++

Routine Description:

    Call SetPrinter to notify the DS of the update of driver attribute

Arguments:

    hPrinter - Handle to the current printer

Return Value:

    NONE

--*/
{

    PRINTER_INFO_7  PrinterInfo7;

    ZeroMemory(&PrinterInfo7, sizeof(PrinterInfo7));
    PrinterInfo7.dwAction = DSPRINT_UPDATE;

    //
    // Comments from spooler DS developer:
    //
    // In the beginning, SetPrinter did not fail with ERROR_IO_PENDING.
    // Then it was modified and would occasionally fail with this error.
    // Finally, for performance reasons, it was modified again and now
    // almost always fails with this error (there are situations where
    // it will succeed).
    //

    if (!SetPrinter(hPrinter, 7, (PBYTE) &PrinterInfo7, 0) &&
        (GetLastError() != ERROR_IO_PENDING))
    {
        WARNING(("Couldn't publish printer info into DS\n"));
    }

}
#endif


HANDLE HCreateHeapForCI()
{
    HANDLE hHeap;

    if(!(hHeap = HeapCreate(0, 8192, 0)))
    {
        ERR(("CreateHeap failed: %d\n", GetLastError()));
    }

    return hHeap;
}


#ifndef WINNT_40
BOOL
DrvQueryColorProfile(
    HANDLE      hPrinter,
    PDEVMODEW   pdmSrc,
    ULONG       ulQueryMode,
    VOID       *pvProfileData,
    ULONG      *pcbProfileData,
    FLONG      *pflProfileData
    )

/*++

Routine Description:

   Call the OEM to let them determine the default color profile.

Arguments:

    hPrinter - Handle to printer
    pdmSrc - Input devmode
    ulQueryMode - query mode
    pvProfileData - Buffer for profile data
    pcbProfileData - Size of profile data buffer
    pflProfileData - other profile info

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    PFN_OEMQueryColorProfile pfnQueryColorProfile;
    PCOMMONINFO              pci;
    BOOL                     bRc = FALSE;


    if (! (pci = PLoadCommonInfo(hPrinter, NULL, 0)) ||
        ! BFillCommonInfoDevmode(pci, NULL, pdmSrc) ||
        ! BCombineCommonInfoOptionsArray(pci))
    {
        WARNING(("Could not get PCI in DrvQueryColorProfile\n"));
        VFreeCommonInfo(pci);
        return FALSE;
    }

    VFixOptionsArrayWithDevmode(pci);

    (VOID) ResolveUIConflicts(pci->pRawData,
                              pci->pCombinedOptions,
                              MAX_COMBINED_OPTIONS,
                              MODE_DOCUMENT_STICKY);

    VOptionsToDevmodeFields(pci, TRUE);

    if (! BUpdateUIInfo(pci))
    {
        VFreeCommonInfo(pci);
        return FALSE;
    }

    //
    // If OEM plugin returns a profile, give it back, otherwise return FALSE
    //

    FOREACH_OEMPLUGIN_LOOP(pci)

        if (HAS_COM_INTERFACE(pOemEntry))
        {
            HRESULT hr;

            hr = HComOEMQUeryColorProfile(pOemEntry,
                                    hPrinter,
                                    &pci->oemuiobj,
                                    pci->pdm,
                                    pOemEntry->pOEMDM,
                                    ulQueryMode,
                                    pvProfileData,
                                    pcbProfileData,
                                    pflProfileData
                                    );

            if (hr == E_NOTIMPL)
                continue;

            bRc = SUCCEEDED(hr);
        }
        else
        {
            pfnQueryColorProfile = GET_OEM_ENTRYPOINT(pOemEntry, OEMQueryColorProfile);

            if (pfnQueryColorProfile)
            {
                bRc = (*pfnQueryColorProfile)(hPrinter,
                                    &pci->oemuiobj,
                                    pci->pdm,
                                    pOemEntry->pOEMDM,
                                    ulQueryMode,
                                    pvProfileData,
                                    pcbProfileData,
                                    pflProfileData
                                    );
            }
        }

        if (bRc)
            break;

    END_OEMPLUGIN_LOOP

    VFreeCommonInfo(pci);

    return bRc;
}

#else // ifndef WINNT_40
BOOL
DrvQueryColorProfile(
    HANDLE      hPrinter,
    PDEVMODEW   pdmSrc,
    ULONG       ulQueryMode,
    VOID       *pvProfileData,
    ULONG      *pcbProfileData,
    FLONG      *pflProfileData
    )

/*++

Routine Description:

   Call the OEM to let them determine the default color profile.

Arguments:

    hPrinter - Handle to printer
    pdmSrc - Input devmode
    ulQueryMode - query mode
    pvProfileData - Buffer for profile data
    pcbProfileData - Size of profile data buffer
    pflProfileData - other profile info

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    return TRUE;
}
#endif // WINNT_40
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\fontsub.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    fontsub.c

Abstract:

    Function for handling TrueType font substitution dialog

[Environment:]

    Win32 subsystem, PostScript driver UI

[Notes:]

Revision History:

    02/10/97 -davidx-
        Consistent handling of common printer info.

    09/18/96 - amandan-
        Modified for common binary data and UI

    08/29/95 -davidx-
        Created it.

--*/

#include "precomp.h"


VOID
VSetupTrueTypeFontMappings(
    IN PUIDATA  pUiData
    )

/*++

Routine Description:

    Initialize the font substitution items with the settings from
    current font substitution table.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    NONE

--*/

{
    POPTITEM    pOptItem;
    POPTPARAM   pOptParam;
    DWORD       dwOptItem;
    PWSTR       pTTSubstTable;

    //
    // Get the current font substitution table
    //

    if ((pTTSubstTable = PGetTTSubstTable(pUiData->ci.hPrinter, NULL)) == NULL &&
        (pTTSubstTable = GET_DEFAULT_FONTSUB_TABLE(&pUiData->ci, pUiData->ci.pUIInfo)) == NULL)
    {
        WARNING(("Font substitution table is not available\n"));
        return;
    }

    //
    // For each TrueType font, check if there is a device font mapped to it.
    // If there is, find the index of the device font in the selection list.
    //

    pOptItem = pUiData->pTTFontItems;
    dwOptItem = pUiData->dwTTFontItem;

    while (dwOptItem--) 
    {
        DWORD   dwOptParam, dwIndex;
        LPCTSTR pDevFontName;

        ASSERT(ISFONTSUBSTITEM(pOptItem->UserData));

        pOptItem->Sel = 0;
        pDevFontName = PtstrSearchTTSubstTable(pTTSubstTable, pOptItem->pName);

        //
        // Check if we found a match
        //

        if (pDevFontName != NULL && *pDevFontName != NUL)
        {

            //
            // Get the total substitution font list
            //
            
            dwOptParam = pOptItem->pOptType->Count;
            pOptParam = pOptItem->pOptType->pOptParam;

            //
            // Skip the first device font name in the list
            // which should always be "Download as Soft Font".
            //

            for (dwIndex=1; dwIndex < dwOptParam; dwIndex++) 
            {
                if (_wcsicmp(pDevFontName, pOptParam[dwIndex].pData) == EQUAL_STRING)
                {
                    pOptItem->Sel = dwIndex;
                    break;
                }
            }
        }

        pOptItem++;
    }

    //
    // Remember to free the memory occupied by the substitution
    // table after we're done with it.
    //

    FREE_DEFAULT_FONTSUB_TABLE(pTTSubstTable);
}



int __cdecl
ICompareOptParam(
    const void *p1,
    const void *p2
    )

{
    return _wcsicmp(((POPTPARAM) p1)->pData, ((POPTPARAM) p2)->pData);
}


POPTTYPE
PFillDevFontOptType(
    IN PUIDATA  pUiData
    )

/*++

Routine Description:

    Initialize an OPTTYPE structure to hold information
    about the list of device fonts supported by a printer

Arguments:

    pUiData - Pointer to UIDATA structure

Return Value:

    Pointer to an OPTTYPE structure
    NULL if there is an error

--*/

{
    POPTTYPE    pOptType;
    POPTPARAM   pOptParam;
    HDC         hdc;
    DWORD       dwCount, dwIndex;
    INT         iSize;
    PWSTR       pwstrFontNames, pwstr;

    //
    // Get the list of printer device font names
    //

    dwCount = 0;

    if ((hdc = CreateIC(NULL, pUiData->ci.pPrinterName, NULL, NULL)) &&
        (iSize = _IListDevFontNames(hdc, NULL, 0)) > 0 &&
        (pwstrFontNames = HEAPALLOC(pUiData->ci.hHeap, iSize)) &&
        (iSize == _IListDevFontNames(hdc, pwstrFontNames, iSize)))
    {
        //
        // Count the number of device font names
        //

        for (pwstr=pwstrFontNames; *pwstr; pwstr += wcslen(pwstr)+1)
            dwCount++;
    }
    else
    {
        ERR(("Couldn't enumerate printer device fonts\n"));
    }

    if (hdc)
        DeleteDC(hdc);

    //
    // Generate an OPTTYPE structure for device font list
    //

    pOptType = HEAPALLOC(pUiData->ci.hHeap, sizeof(OPTTYPE));
    pOptParam = HEAPALLOC(pUiData->ci.hHeap, sizeof(OPTPARAM) * (dwCount+1));

    if (pOptType == NULL || pOptParam == NULL)
    {
        ERR(("Memory allocation failed\n"));
        return NULL;
    }

    pOptType->cbSize = sizeof(OPTTYPE);
    pOptType->Count = (WORD) (dwCount+1);
    pOptType->Type = TVOT_LISTBOX;
    pOptType->pOptParam = pOptParam;

    //
    // Initialize OPTPARAM structures.
    // The first item is always "Download as Soft Font".
    //

    for (dwIndex=0; dwIndex <= dwCount; dwIndex++)
        pOptParam[dwIndex].cbSize = sizeof(OPTPARAM);

    pOptParam->pData = (PWSTR) IDS_DOWNLOAD_AS_SOFTFONT;
    pOptParam++;

    // hack to get around a compiler bug

    dwCount++;
    dwCount--;

    for (dwIndex=0, pwstr=pwstrFontNames; dwIndex < dwCount; dwIndex++)
    {
        pOptParam[dwIndex].pData = pwstr;
        pwstr += wcslen(pwstr) + 1;
    }

    //
    // Sort device font names into alphabetical order;
    // Hide any duplicate device font names as well.
    //

    qsort(pOptParam, dwCount, sizeof(OPTPARAM), ICompareOptParam);

    for (dwIndex=1; dwIndex < dwCount; dwIndex++)
    {
        if (_wcsicmp(pOptParam[dwIndex].pData, pOptParam[dwIndex-1].pData) == EQUAL_STRING)
            pOptParam[dwIndex].Flags |= OPTPF_HIDE;
    }

    return pOptType;
}



//
// Data structures and functions for enumerating printer device fonts
//

typedef struct _ENUMTTFONT {

    DWORD       dwCount;
    POPTITEM    pOptItem;
    POPTTYPE    pOptType;
    HANDLE      hHeap;
    WCHAR       awchLastFontName[LF_FACESIZE];

} ENUMTTFONT, *PENUMTTFONT;

INT CALLBACK
EnumTTFontProc(
    ENUMLOGFONT    *pelf,
    NEWTEXTMETRIC  *pntm,
    INT             FontType,
    LPARAM          lParam
    )

{
    PENUMTTFONT pEnumData;
    PTSTR       pFontName;
    PTSTR       pFamilyName;

    //
    // We only care about the TrueType fonts.
    //

    if (! (FontType & TRUETYPE_FONTTYPE))
        return 1;

    pEnumData = (PENUMTTFONT) lParam;
    pFamilyName = pelf->elfLogFont.lfFaceName;

    if (_tcscmp(pFamilyName, pEnumData->awchLastFontName) == EQUAL_STRING)
        return 1;

    CopyString(pEnumData->awchLastFontName, pFamilyName, LF_FACESIZE);
    pEnumData->dwCount++;

    if (pEnumData->pOptItem)
    {
        pFontName = PtstrDuplicateStringFromHeap(pFamilyName, pEnumData->hHeap);

        if (pFontName == NULL)
            return 0;
        
        FILLOPTITEM(pEnumData->pOptItem,
                    pEnumData->pOptType,
                    pFontName,
                    0,
                    TVITEM_LEVEL2,
                    DMPUB_NONE,
                    FONT_SUBST_ITEM,
                    HELP_INDEX_TTTODEV);

        pEnumData->pOptItem++;
    }

    return 1;
}


int __cdecl
ICompareOptItem(
    const void *p1,
    const void *p2
    )

{
    return _wcsicmp(((POPTITEM) p1)->pName, ((POPTITEM) p2)->pName);
}


BOOL
BPackItemFontSubstTable(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack Font Substitution options

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    ENUMTTFONT  EnumData;
    POPTITEM    pOptItem;
    HDC         hdc;
    INT         iResult;

    //
    // If the printer doesn't support font-substitution,
    // then simply return success here.
    //

    if (pUiData->ci.pUIInfo->dwFontSubCount == 0)
        return TRUE;

    //
    // Create a screen IC
    //

    if ((hdc = CreateIC(TEXT("DISPLAY"), NULL, NULL, NULL)) == NULL)
    {
        ERR(("Cannot create screen IC\n"));
        return FALSE;
    }

    //
    // Font substitution table
    //     TrueType font <-> Device font
    //     ....
    //
    // Group Header for Font Substitution Table
    //

    pOptItem = pUiData->pOptItem;

    VPackOptItemGroupHeader(
            pUiData,
            IDS_FONTSUB_TABLE,
            IDI_CPSUI_FONTSUB,
            HELP_INDEX_FONTSUB_TABLE);

    ZeroMemory(&EnumData, sizeof(EnumData));
    EnumData.hHeap = pUiData->ci.hHeap;

    if (pOptItem == NULL)
    {
        //
        // Count the number of TrueType fonts
        //

        iResult = EnumFontFamilies(hdc,
                                   NULL,
                                   (FONTENUMPROC) EnumTTFontProc,
                                   (LPARAM) &EnumData);
    }
    else
    {
        //
        // Collapse the group header
        //

        pOptItem->Flags |= OPTIF_COLLAPSE;

        pUiData->pTTFontItems = pUiData->pOptItem;
        EnumData.pOptItem = pUiData->pOptItem;

        //
        // Get the list of printer device fonts
        //

        EnumData.pOptType = PFillDevFontOptType(pUiData);

        if (EnumData.pOptType == NULL)
        {
            ERR(("PFillDevFontOptType failed\n"));
            iResult = 0;
        }
        else
        {
            //
            // Enumerate the list of TrueType fonts
            //

            iResult = EnumFontFamilies(hdc,
                                       NULL,
                                       (FONTENUMPROC) EnumTTFontProc,
                                       (LPARAM) &EnumData);

            if (iResult == 0 || EnumData.dwCount != pUiData->dwTTFontItem)
            {
                ERR(("Inconsistent number of TrueType fonts\n"));
                iResult = 0;
            }
            else
            {
                //
                // Sort the TrueType font items alphabetically
                //

                qsort(pUiData->pTTFontItems,
                      pUiData->dwTTFontItem,
                      sizeof(OPTITEM),
                      ICompareOptItem);
            }
        }
    }

    DeleteDC(hdc);

    if (iResult == 0)
    {
        ERR(("Failed to enumerate TrueType fonts\n"));
        return FALSE;
    }

    pUiData->dwTTFontItem = EnumData.dwCount;
    pUiData->dwOptItem += pUiData->dwTTFontItem;

    if (pUiData->pOptItem)
    {
        pUiData->pOptItem += pUiData->dwTTFontItem;
        VSetupTrueTypeFontMappings(pUiData);
    }

    return TRUE;
}



DWORD
DwCollectTrueTypeMappings(
    IN POPTITEM pOptItem,
    IN DWORD    dwOptItem,
    OUT PWSTR   pwstrTable
    )

/*++

Routine Description:

    Assemble TrueType to device font mappings into a table

Arguments:

    pOptItem - Pointer to an array of OPTITEMs
    cOptItem - Number of OPTITEMs
    pwstrTable - Pointer to memory buffer for storing the table.
        NULL if we're only interested in table size.

Return Value:

    Size of the table bytes, 0 if there is an error.

--*/

{
    DWORD       dwChars = 0;
    INT         iLength;
    POPTPARAM   pOptParam;

    while (dwOptItem--) 
    {
        ASSERT(ISFONTSUBSTITEM(pOptItem->UserData));

        if (pOptItem->Sel > 0) 
        {
            iLength = wcslen(pOptItem->pName) + 1;
            dwChars += iLength;
    
            if (pwstrTable != NULL) 
            {
                CopyMemory(pwstrTable, pOptItem->pName, iLength*sizeof(WCHAR));
                pwstrTable += iLength;
            }

            pOptParam = pOptItem->pOptType->pOptParam + pOptItem->Sel;

            iLength = wcslen(pOptParam->pData) + 1;
            dwChars += iLength;

            if (pwstrTable != NULL) 
            {
                CopyMemory(pwstrTable, pOptParam->pData, iLength*sizeof(WCHAR));
                pwstrTable += iLength;
            }
        }
        
        pOptItem++;
    }

    //
    // Append a NUL character at the end of the table
    //

    dwChars++;

    if (pwstrTable != NULL)
        *pwstrTable = NUL;

    //
    // Return the table size in bytes
    //

    return dwChars * sizeof(WCHAR);
}



BOOL
BUnpackItemFontSubstTable(
    IN PUIDATA  pUiData
    )

/*++

Routine Description:

    Extract substitution table from treeview items

Arguments:

    pUiData - Pointer to UIDATA structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    DWORD       dwTableSize;
    PWSTR       pwstrTable = NULL;
    POPTITEM    pOptItem = pUiData->pTTFontItems;
    DWORD       dwOptItem = pUiData->dwTTFontItem;

    //
    // Check if any changes were made to font-substitution items
    //

    if (! BOptItemSelectionsChanged(pOptItem, dwOptItem))
        return TRUE;

    //
    // Figure out how much memory we need to save the font substitution table
    // Assemble the font substitution table
    // Save the TrueType font substitution table to registry
    //

    if ((dwTableSize = DwCollectTrueTypeMappings(pOptItem, dwOptItem, NULL)) == 0 ||
        (pwstrTable = MemAlloc(dwTableSize)) == NULL ||
        (dwTableSize != DwCollectTrueTypeMappings(pOptItem, dwOptItem, pwstrTable)) ||
        !BSaveTTSubstTable(pUiData->ci.hPrinter, pwstrTable, dwTableSize))
    {
        ERR(("Couldn't save font substitution table\n"));
        MemFree(pwstrTable);
        return FALSE;
    }

    MemFree(pwstrTable);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\intfui.cxx ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    intfui.cpp

Abstract:

    Interface implementation of Windows NT driver UI OEM plugins

Environment:

    Windows NT driver UI

Revision History:


--*/

#define INITGUID
#include "precomp.h"

//
// List all of the supported OEM UI plugin interface IIDs from the
// latest to the oldest, that's the order our driver will QI OEM
// plugin for its supported interface.
//
// DON"T remove the last NULL terminator.
//

static const GUID *PrintOemUI_IIDs[] = {
    &IID_IPrintOemUI2,
    &IID_IPrintOemUI,
    NULL
};

#define CALL_INTERFACE(pOemEntry, MethodName, args) \
    if (IsEqualGUID(&(pOemEntry)->iidIntfOem, &IID_IPrintOemUI)) \
    { \
        return ((IPrintOemUI *)(pOemEntry)->pIntfOem)->MethodName args; \
    } \
    else if (IsEqualGUID(&(pOemEntry)->iidIntfOem, &IID_IPrintOemUI2)) \
    { \
        return ((IPrintOemUI2 *)(pOemEntry)->pIntfOem)->MethodName args; \
    } \
    return E_NOINTERFACE;

#define CALL_INTERFACE2(pOemEntry, MethodName, args) \
    if (IsEqualGUID(&(pOemEntry)->iidIntfOem, &IID_IPrintOemUI2)) \
    { \
        return ((IPrintOemUI2 *)(pOemEntry)->pIntfOem)->MethodName args; \
    } \
    return E_NOINTERFACE;

#ifdef PSCRIPT

#define VERIFY_OEMUIOBJ(poemuiobj) \
    if (!poemuiobj || (((PCOMMONINFO)poemuiobj)->pvStartSign != poemuiobj)) \
        return E_INVALIDARG;

#define VERIFY_UIDATA(poemuiobj) \
    if (!VALIDUIDATA((PUIDATA)poemuiobj)) \
        return E_INVALIDARG;

#endif // PSCRIPT

//
// Core driver helper function interfaces
//

//
// The first driver UI herlper interface has version number 1. Any new
// helper interface version number is 1 plus the previous version number.
// So we need to increase MAX_UI_HELPER_INTF_VER by 1 every time we introduce
// a new UI plugin helper interface.
//

#ifdef PSCRIPT

#define MAX_UI_HELPER_INTF_VER     2

#else

#define MAX_UI_HELPER_INTF_VER     1

#endif // PSCRIPT

//
// CPrintOemDriverUI is the object containing the UI helper functions
//

class CPrintOemDriverUI : public IPrintOemDriverUI
{
    //
    // IUnknown implementation
    //

    virtual STDMETHODIMP QueryInterface(const IID& iid, void** ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    //
    // Interface IPrintOemDriverUI implementation
    //

    virtual STDMETHODIMP DrvGetDriverSetting( PVOID   pci,
                                              PCSTR   pFeature,
                                              PVOID   pOutput,
                                              DWORD   cbSize,
                                              PDWORD  pcbNeeded,
                                              PDWORD  pdwOptionsReturned);

    virtual STDMETHODIMP DrvUpgradeRegistrySetting( HANDLE hPrinter,
                                                    PCSTR   pFeature,
                                                    PCSTR   pOption);


    virtual STDMETHODIMP DrvUpdateUISetting ( PVOID    pci,
                                              PVOID    pOptItem,
                                              DWORD    dwPreviousSelection,
                                              DWORD    dwMode);

public:

    //
    // Constructor
    //

    CPrintOemDriverUI() : m_cRef(0) {}

private:

    long m_cRef;
};


STDMETHODIMP CPrintOemDriverUI::QueryInterface(const IID& iid, void** ppv)
{
    if (iid == IID_IUnknown || iid == IID_IPrintOemDriverUI)
    {
        *ppv = static_cast<IPrintOemDriverUI *>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CPrintOemDriverUI::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CPrintOemDriverUI::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CPrintOemDriverUI::DrvGetDriverSetting(PVOID    pci,
                                                    PCSTR    pFeature,
                                                    PVOID    pOutput,
                                                    DWORD    cbSize,
                                                    PDWORD   pcbNeeded,
                                                    PDWORD   pdwOptionsReturned)
{
    if (BGetDriverSettingForOEM((PCOMMONINFO)pci,
                                pFeature,
                                pOutput,
                                cbSize,
                                pcbNeeded,
                                pdwOptionsReturned))
        return S_OK;

    return E_FAIL;
}

STDMETHODIMP  CPrintOemDriverUI::DrvUpgradeRegistrySetting(HANDLE hPrinter,
                                                           PCSTR  pFeature,
                                                           PCSTR  pOption)
{
    if (BUpgradeRegistrySettingForOEM(hPrinter,
                                     pFeature,
                                     pOption))
        return S_OK;

    return E_FAIL;
}

STDMETHODIMP CPrintOemDriverUI::DrvUpdateUISetting(PVOID pci,
                                                   PVOID pOptItem,
                                                   DWORD dwPreviousSelection,
                                                   DWORD dwMode)
{
    if (BUpdateUISettingForOEM((PCOMMONINFO)pci,
                                pOptItem,
                                dwPreviousSelection,
                                dwMode))
        return S_OK;

    return E_FAIL;
}

#ifdef PSCRIPT

//
// CPrintCoreUI2 is the object containing the new UI helper functions
//

class CPrintCoreUI2 : public IPrintCoreUI2
{
    //
    // IUnknown implementation
    //

    virtual STDMETHODIMP QueryInterface(const IID& iid, void** ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    //
    // IPrintOemDriverUI methods implementation
    //

    virtual STDMETHODIMP DrvGetDriverSetting(PVOID   pci,
                                             PCSTR   pFeature,
                                             PVOID   pOutput,
                                             DWORD   cbSize,
                                             PDWORD  pcbNeeded,
                                             PDWORD  pdwOptionsReturned);

    virtual STDMETHODIMP DrvUpgradeRegistrySetting(HANDLE  hPrinter,
                                                   PCSTR   pFeature,
                                                   PCSTR   pOption);


    virtual STDMETHODIMP DrvUpdateUISetting(PVOID  pci,
                                            PVOID  pOptItem,
                                            DWORD  dwPreviousSelection,
                                            DWORD  dwMode);
    //
    // IPrintCoreUI2 methods implementation
    //

    virtual STDMETHODIMP GetOptions(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pmszFeaturesRequested,
                           IN  DWORD      cbIn,
                           OUT PSTR       pmszFeatureOptionBuf,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded);

    virtual STDMETHODIMP SetOptions(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pmszFeatureOptionBuf,
                           IN  DWORD      cbIn,
                           OUT PDWORD     pdwResult);

    virtual STDMETHODIMP EnumConstrainedOptions(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           OUT PSTR       pmszConstrainedOptionList,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded);

    virtual STDMETHODIMP WhyConstrained(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           IN  PCSTR      pszOptionKeyword,
                           OUT PSTR       pmszReasonList,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded);

    virtual STDMETHODIMP GetGlobalAttribute(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszAttribute,
                           OUT PDWORD     pdwDataType,
                           OUT PBYTE      pbData,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded);

    virtual STDMETHODIMP GetFeatureAttribute(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           IN  PCSTR      pszAttribute,
                           OUT PDWORD     pdwDataType,
                           OUT PBYTE      pbData,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded);

    virtual STDMETHODIMP GetOptionAttribute(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           IN  PCSTR      pszOptionKeyword,
                           IN  PCSTR      pszAttribute,
                           OUT PDWORD     pdwDataType,
                           OUT PBYTE      pbData,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded);

    virtual STDMETHODIMP EnumFeatures(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           OUT PSTR       pmszFeatureList,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded);

    virtual STDMETHODIMP EnumOptions(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           OUT PSTR       pmszOptionList,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded);

    virtual STDMETHODIMP QuerySimulationSupport(
                           IN  HANDLE  hPrinter,
                           IN  DWORD   dwLevel,
                           OUT PBYTE   pCaps,
                           IN  DWORD   cbSize,
                           OUT PDWORD  pcbNeeded);

public:

    //
    // Constructor
    //

    CPrintCoreUI2() : m_cRef(0) {}

private:

    long m_cRef;
};


STDMETHODIMP CPrintCoreUI2::QueryInterface(const IID& iid, void** ppv)
{
    if (iid == IID_IUnknown || iid == IID_IPrintCoreUI2)
    {
        *ppv = static_cast<IPrintCoreUI2 *>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CPrintCoreUI2::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CPrintCoreUI2::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


STDMETHODIMP CPrintCoreUI2::DrvGetDriverSetting(PVOID   pci,
                                                PCSTR   pFeature,
                                                PVOID   pOutput,
                                                DWORD   cbSize,
                                                PDWORD  pcbNeeded,
                                                PDWORD  pdwOptionsReturned)
{
    VERIFY_OEMUIOBJ((POEMUIOBJ)pci)

    //
    // This function is only supported for UI plugins that DON'T fully replace
    // core driver's standard UI. It should only be called by the UI plugin's
    // DocumentPropertySheets, DevicePropertySheets and their property sheet
    // callback functions.
    //

    if (!IS_WITHIN_PROPSHEET_SESSION((PCOMMONINFO)pci))
    {
        ERR(("DrvGetDriverSetting called outside of property sheet session. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    VERIFY_UIDATA((POEMUIOBJ)pci)

    if (IS_HIDING_STD_UI((PUIDATA)pci))
    {
        ERR(("DrvGetDriverSetting called by full UI replacing plugin. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    if (BGetDriverSettingForOEM((PCOMMONINFO)pci,
                                pFeature,
                                pOutput,
                                cbSize,
                                pcbNeeded,
                                pdwOptionsReturned))
    {
        return S_OK;
    }

    return E_FAIL;
}


STDMETHODIMP CPrintCoreUI2::DrvUpgradeRegistrySetting(HANDLE hPrinter,
                                                      PCSTR  pFeature,
                                                      PCSTR  pOption)
{
    if (BUpgradeRegistrySettingForOEM(hPrinter,
                                     pFeature,
                                     pOption))
    {
        return S_OK;
    }

    return E_FAIL;
}


STDMETHODIMP CPrintCoreUI2::DrvUpdateUISetting(PVOID pci,
                                               PVOID pOptItem,
                                               DWORD dwPreviousSelection,
                                               DWORD dwMode)
{
    VERIFY_OEMUIOBJ((POEMUIOBJ)pci)

    //
    // This function is only supported for UI plugins that DON'T fully replace
    // core driver's standard UI. It should only be called by the UI plugin's
    // DocumentPropertySheets, DevicePropertySheets and their property sheet
    // callback functions.
    //

    if (!IS_WITHIN_PROPSHEET_SESSION((PCOMMONINFO)pci))
    {
        ERR(("DrvUpdateUISetting called outside of property sheet session. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    VERIFY_UIDATA((POEMUIOBJ)pci)

    if (IS_HIDING_STD_UI((PUIDATA)pci))
    {
        ERR(("DrvUpdateUISetting called by full UI replacing plugin. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    if (BUpdateUISettingForOEM((PCOMMONINFO)pci,
                                pOptItem,
                                dwPreviousSelection,
                                dwMode))
    {
        return S_OK;
    }

    return E_FAIL;
}

/*++

Routine Name:

    GetOptions

Routine Description:

    get current driver settings for PPD features and driver synthesized features

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the get operation
    pmszFeaturesRequested - MULTI_SZ ASCII string containing feature keyword names
    cbin - size in bytes of the pmszFeaturesRequested string
    pmszFeatureOptionBuf - pointer to output data buffer to store feature settings
    cbSize - size in bytes of pmszFeatureOptionBuf buffer
    pcbNeeded - buffer size in bytes needed to output the feature settings

Return Value:

    E_NOTIMPL       if called when not supported
    E_INVALIDARG    if poemuiobj is invalid, or see HGetOptions

    S_OK
    E_OUTOFMEMORY
    E_FAIL          see HGetOptions

Last Error:

    None

--*/
STDMETHODIMP CPrintCoreUI2::GetOptions(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pmszFeaturesRequested,
                           IN  DWORD      cbIn,
                           OUT PSTR       pmszFeatureOptionBuf,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded)
{
    PCOMMONINFO  pci;

    VERIFY_OEMUIOBJ(poemuiobj)

    //
    // This function is only supported for UI plugins that fully replace
    // core driver's standard UI. It should only be called by the UI plugin's
    // DocumentPropertySheets, DevicePropertySheets and their property sheet
    // callback functions.
    //

    pci = (PCOMMONINFO)poemuiobj;

    if (!IS_WITHIN_PROPSHEET_SESSION(pci))
    {
        ERR(("GetOptions called outside of property sheet session. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    VERIFY_UIDATA(poemuiobj)

    if (!IS_HIDING_STD_UI((PUIDATA)pci))
    {
        ERR(("GetOptions called by non-full UI replacing plugin. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    #ifdef PSCRIPT

    return HGetOptions(pci->hPrinter,
                       pci->pInfoHeader,
                       pci->pCombinedOptions,
                       pci->pdm,
                       pci->pPrinterData,
                       dwFlags,
                       pmszFeaturesRequested,
                       cbIn,
                       pmszFeatureOptionBuf,
                       cbSize,
                       pcbNeeded,
                       ((PUIDATA)pci)->iMode == MODE_PRINTER_STICKY ? TRUE : FALSE);

    #else

    return E_NOTIMPL;

    #endif // PSCRIPT
}

/*++

Routine Name:

    SetOptions

Routine Description:

    set new driver settings for PPD features and driver synthesized features

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the set operation. This should be one of following:

                  SETOPTIONS_FLAG_RESOLVE_CONFLICT
                  SETOPTIONS_FLAG_KEEP_CONFLICT

    pmszFeatureOptionBuf - MULTI_SZ ASCII string containing new settings'
                           feature/option keyword pairs
    cbin - size in bytes of the pmszFeatureOptionBuf string
    pdwResult - pointer to the DWORD that will store the result of set operation.
                The result will be one of following:

                  SETOPTIONS_RESULT_NO_CONFLICT
                  SETOPTIONS_RESULT_CONFLICT_RESOLVED
                  SETOPTIONS_RESULT_CONFLICT_REMAINED

Return Value:

    S_OK            if the set operation succeeds
    E_NOTIMPL       if called when not supported
    E_INVALIDARG    if poemuiobj is invalid, or see HSetOptions
    E_FAIL          see HSetOptions

Last Error:

    None

--*/
STDMETHODIMP CPrintCoreUI2::SetOptions(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pmszFeatureOptionBuf,
                           IN  DWORD      cbIn,
                           OUT PDWORD     pdwResult)
{
    VERIFY_OEMUIOBJ(poemuiobj)

    //
    // This function is only supported for UI plugins that fully replace
    // core driver's standard UI. It should only be called by the UI plugin's
    // DocumentPropertySheets, DevicePropertySheets and their property sheet
    // callback functions.
    //

    if (!IS_WITHIN_PROPSHEET_SESSION((PCOMMONINFO)poemuiobj))
    {
        ERR(("SetOptions called outside of property sheet session. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    VERIFY_UIDATA(poemuiobj)

    if (!IS_HIDING_STD_UI((PUIDATA)poemuiobj))
    {
        ERR(("SetOptions called by non-full UI replacing plugin. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    #ifdef PSCRIPT

    return HSetOptions(poemuiobj,
                       dwFlags,
                       pmszFeatureOptionBuf,
                       cbIn,
                       pdwResult);

    #else

    return E_NOTIMPL;

    #endif // PSCRIPT
}

/*++

Routine Name:

    EnumConstrainedOptions

Routine Description:

    enumerate the constrained option keyword name list in the specified feature

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the enumeration operation
    pszFeatureKeyword - feature keyword name
    pmszConstrainedOptionList - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    E_NOTIMPL       if called when not supported
    E_INVALIDARG    if poemuiobj is invalid, or see HEnumConstrainedOptions

    S_OK
    E_OUTOFMEMORY
    E_FAIL          see HEnumConstrainedOptions

Last Error:

    None

--*/
STDMETHODIMP CPrintCoreUI2::EnumConstrainedOptions(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           OUT PSTR       pmszConstrainedOptionList,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded)
{
    VERIFY_OEMUIOBJ(poemuiobj)

    //
    // This function is only supported for UI plugins that fully replace
    // core driver's standard UI. It should only be called by the UI plugin's
    // DocumentPropertySheets, DevicePropertySheets and their property sheet
    // callback functions.
    //

    if (!IS_WITHIN_PROPSHEET_SESSION((PCOMMONINFO)poemuiobj))
    {
        ERR(("EnumConstrainedOptions called outside of property sheet session. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    VERIFY_UIDATA(poemuiobj)

    if (!IS_HIDING_STD_UI((PUIDATA)poemuiobj))
    {
        ERR(("EnumConstrainedOptions called by non-full UI replacing plugin. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    #ifdef PSCRIPT

    return HEnumConstrainedOptions(poemuiobj,
                                   dwFlags,
                                   pszFeatureKeyword,
                                   pmszConstrainedOptionList,
                                   cbSize,
                                   pcbNeeded);

    #else

    return E_NOTIMPL;

    #endif // PSCRIPT
}

/*++

Routine Name:

    WhyConstrained

Routine Description:

    get feature/option keyword pair that constrains the given
    feature/option pair

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for this operation
    pszFeatureKeyword - feature keyword name
    pszOptionKeyword - option keyword name
    pmszReasonList - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    E_NOTIMPL       if called when not supported
    E_INVALIDARG    if poemuiobj is invalid, or see HWhyConstrained

    S_OK
    E_OUTOFMEMORY   see HWhyConstrained

Last Error:

    None

--*/
STDMETHODIMP CPrintCoreUI2::WhyConstrained(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           IN  PCSTR      pszOptionKeyword,
                           OUT PSTR       pmszReasonList,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded)
{
    VERIFY_OEMUIOBJ(poemuiobj)

    //
    // This function is only supported for UI plugins that fully replace
    // core driver's standard UI. It should only be called by the UI plugin's
    // DocumentPropertySheets, DevicePropertySheets and their property sheet
    // callback functions.
    //

    if (!IS_WITHIN_PROPSHEET_SESSION((PCOMMONINFO)poemuiobj))
    {
        ERR(("WhyConstrained called outside of property sheet session. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    VERIFY_UIDATA(poemuiobj)

    if (!IS_HIDING_STD_UI((PUIDATA)poemuiobj))
    {
        ERR(("WhyConstrained called by non-full UI replacing plugin. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    #ifdef PSCRIPT

    return HWhyConstrained(poemuiobj,
                           dwFlags,
                           pszFeatureKeyword,
                           pszOptionKeyword,
                           pmszReasonList,
                           cbSize,
                           pcbNeeded);

    #else

    return E_NOTIMPL;

    #endif // PSCRIPT
}

/*++

Routine Name:

    GetGlobalAttribute

Routine Description:

    get PPD global attribute

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the attribute get operation
    pszAttribute - name of the global attribute
    pdwDataType - pointer to DWORD to store output data type
    pbData - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    E_INVALIDARG    if poemuiobj is invalid, or see HGetGlobalAttribute

    S_OK
    E_OUTOFMEMORY   see HGetGlobalAttribute

Last Error:

    None

--*/
STDMETHODIMP CPrintCoreUI2::GetGlobalAttribute(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszAttribute,
                           OUT PDWORD     pdwDataType,
                           OUT PBYTE      pbData,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded)
{
    VERIFY_OEMUIOBJ(poemuiobj)

    #ifdef PSCRIPT

    return HGetGlobalAttribute(((PCOMMONINFO)poemuiobj)->pInfoHeader,
                               dwFlags,
                               pszAttribute,
                               pdwDataType,
                               pbData,
                               cbSize,
                               pcbNeeded);

    #else

    return E_NOTIMPL;

    #endif // PSCRIPT
}

/*++

Routine Name:

    GetFeatureAttribute

Routine Description:

    get PPD feature attribute

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the attribute get operation
    pszFeatureKeyword - PPD feature keyword name
    pszAttribute - name of the feature attribute
    pdwDataType - pointer to DWORD to store output data type
    pbData - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    E_INVALIDARG    if poemuiobj is invalid, or see HGetFeatureAttribute

    S_OK
    E_OUTOFMEMORY   see HGetFeatureAttribute

Last Error:

    None

--*/
STDMETHODIMP CPrintCoreUI2::GetFeatureAttribute(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           IN  PCSTR      pszAttribute,
                           OUT PDWORD     pdwDataType,
                           OUT PBYTE      pbData,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded)
{
    VERIFY_OEMUIOBJ(poemuiobj)

    #ifdef PSCRIPT

    return HGetFeatureAttribute(((PCOMMONINFO)poemuiobj)->pInfoHeader,
                                dwFlags,
                                pszFeatureKeyword,
                                pszAttribute,
                                pdwDataType,
                                pbData,
                                cbSize,
                                pcbNeeded);

    #else

    return E_NOTIMPL;

    #endif // PSCRIPT
}

/*++

Routine Name:

    GetOptionAttribute

Routine Description:

    get option attribute of a PPD feature

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the attribute get operation
    pszFeatureKeyword - PPD feature keyword name
    pszOptionKeyword - option keyword name of the PPD feature
    pszAttribute - name of the feature attribute
    pdwDataType - pointer to DWORD to store output data type
    pbData - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    E_INVALIDARG    if poemuiobj is invalid, or see HGetOptionAttribute

    S_OK
    E_OUTOFMEMORY   see HGetOptionAttribute

Last Error:

    None

--*/
STDMETHODIMP CPrintCoreUI2::GetOptionAttribute(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           IN  PCSTR      pszOptionKeyword,
                           IN  PCSTR      pszAttribute,
                           OUT PDWORD     pdwDataType,
                           OUT PBYTE      pbData,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded)
{
    VERIFY_OEMUIOBJ(poemuiobj)

    #ifdef PSCRIPT

    return HGetOptionAttribute(((PCOMMONINFO)poemuiobj)->pInfoHeader,
                               dwFlags,
                               pszFeatureKeyword,
                               pszOptionKeyword,
                               pszAttribute,
                               pdwDataType,
                               pbData,
                               cbSize,
                               pcbNeeded);

    #else

    return E_NOTIMPL;

    #endif // PSCRIPT
}

/*++

Routine Name:

    EnumFeatures

Routine Description:

    enumerate PPD feature and supported driver feature keyword name list

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the enumeration operation
    pmszFeatureList - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    E_INVALIDARG    if peomuiobj is invalid

    S_OK
    E_OUTOFMEMORY
    E_FAIL          see HEnumFeaturesOrOptions

Last Error:

    None

--*/
STDMETHODIMP CPrintCoreUI2::EnumFeatures(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           OUT PSTR       pmszFeatureList,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded)
{
    VERIFY_OEMUIOBJ(poemuiobj)

    #ifdef PSCRIPT

    return HEnumFeaturesOrOptions(((PCOMMONINFO)poemuiobj)->hPrinter,
                                  ((PCOMMONINFO)poemuiobj)->pInfoHeader,
                                  dwFlags,
                                  NULL,
                                  pmszFeatureList,
                                  cbSize,
                                  pcbNeeded);

    #else

    return E_NOTIMPL;

    #endif // PSCRIPT
}

/*++

Routine Name:

    EnumOptions

Routine Description:

    enumerate option keyword name list of the specified feature

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the enumeration operation
    pszFeatureKeyword - feature keyword name
    pmszOptionList - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    E_INVALIDARG    if poemuiobj is invalid, or feature keyword name is invalid

    S_OK
    E_OUTOFMEMORY
    E_NOTIMPL
    E_FAIL          see HEnumFeaturesOrOptions

Last Error:

--*/
STDMETHODIMP CPrintCoreUI2::EnumOptions(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           OUT PSTR       pmszOptionList,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded)
{
    VERIFY_OEMUIOBJ(poemuiobj)

    if (pszFeatureKeyword == NULL)
    {
        return E_INVALIDARG;
    }

    #ifdef PSCRIPT

    return HEnumFeaturesOrOptions(((PCOMMONINFO)poemuiobj)->hPrinter,
                                  ((PCOMMONINFO)poemuiobj)->pInfoHeader,
                                  dwFlags,
                                  pszFeatureKeyword,
                                  pmszOptionList,
                                  cbSize,
                                  pcbNeeded);

    #else

    return E_NOTIMPL;

    #endif // PSCRIPT
}

/*++

Routine Name:

    QuerySimulationSupport

Routine Description:

    get the spooler simulation capability info structure

Arguments:

    hPrinter - printer handle
    dwLevel - interested level of spooler simulation capability info structure
    pCaps - pointer to output buffer
    cbSize - size in bytes of output buffer
    pcbNeeded - buffer size in bytes needed to store the interested info structure

Return Value:

    E_NOTIMPL   if called on NT4, or see HQuerySimulationSupport

    S_OK
    E_OUTOFMEMORY
    E_NOTIMPL
    E_FAIL      see HQuerySimulationSupport

Last Error:

    None

--*/
STDMETHODIMP CPrintCoreUI2::QuerySimulationSupport(
                           IN  HANDLE  hPrinter,
                           IN  DWORD   dwLevel,
                           OUT PBYTE   pCaps,
                           IN  DWORD   cbSize,
                           OUT PDWORD  pcbNeeded)
{
    #ifndef WINNT_40

    return HQuerySimulationSupport(hPrinter,
                                   dwLevel,
                                   pCaps,
                                   cbSize,
                                   pcbNeeded);

    #else

    return E_NOTIMPL;

    #endif // !WINNT_40
}

#endif // PSCRIPT

//
// Creation function
//

extern "C" IUnknown* DriverCreateInstance(INT iHelperIntfVer)
{
    IUnknown *pI = NULL;

    switch (iHelperIntfVer)
    {
        case 1:
            pI = static_cast<IPrintOemDriverUI *>(new CPrintOemDriverUI);
            break;

        #ifdef PSCRIPT

        case 2:
            pI = static_cast<IPrintCoreUI2 *>(new CPrintCoreUI2);
            break;

        #endif // PSCRIPT

        default:
            ERR(("Unrecognized helper interface version: %d\n", iHelperIntfVer));
            break;
    }

    if (pI != NULL)
        pI->AddRef();

    return pI;
}

//
// Get OEM plugin interface and publish driver helper interface
//

extern "C" BOOL BGetOemInterface(POEM_PLUGIN_ENTRY pOemEntry)
{
    IUnknown  *pIDriverHelper = NULL;
    HRESULT   hr;
    INT       iHelperVer;

    //
    // QI to retrieve the latest interface OEM plugin supports
    //

    if (!BQILatestOemInterface(pOemEntry->hInstance,
                               CLSID_OEMUI,
                               PrintOemUI_IIDs,
                               &(pOemEntry->pIntfOem),
                               &(pOemEntry->iidIntfOem)))
    {
        ERR(("BQILatestOemInterface failed\n"));
        return FALSE;
    }

    //
    // If QI succeeded, pOemEntry->pIntfOem will have the OEM plugin
    // interface pointer with ref count 1.
    //

    //
    // Now publish driver's helper function interface (from latest to oldest).
    //

    for (iHelperVer = MAX_UI_HELPER_INTF_VER; iHelperVer > 0; iHelperVer--)
    {
        if ((pIDriverHelper = DriverCreateInstance(iHelperVer)) == NULL)
        {
            ERR(("DriverCreateInstance failed for version %d\n", iHelperVer));
            goto fail_cleanup;
        }

        //
        // As long as we define new OEM UI plugin interface by inheriting old ones,
        // we can always cast pIntfOem into pointer of the oldest plugin interface
        // (the base class) and call PublishDriverInterface method.
        //
        // Otherwise, this code needs to be modified when new interface is added.
        //

        hr = ((IPrintOemUI *)(pOemEntry->pIntfOem))->PublishDriverInterface(pIDriverHelper);

        //
        // OEM plugin should do QI in their PublishDriverInterface, so we need to release
        // our ref count of pIDriverHelper.
        //

        pIDriverHelper->Release();

        if (SUCCEEDED(hr))
        {
            VERBOSE(("PublishDriverInterface succeeded for version %d\n", iHelperVer));
            break;
        }
    }

    if (iHelperVer == 0)
    {
        ERR(("PublishDriverInterface failed\n"));
        goto fail_cleanup;
    }

    return TRUE;

    fail_cleanup:

    //
    // If failed, we need to release the ref count we hold on pOemEntry->pIntfOem,
    // and set pIntfOem to NULL to indicate no COM interface is available.
    //

    ((IUnknown *)(pOemEntry->pIntfOem))->Release();
    pOemEntry->pIntfOem = NULL;

    return FALSE;
}


extern "C" ULONG ReleaseOemInterface(POEM_PLUGIN_ENTRY    pOemEntry)
{
#ifdef WINNT_40

    if (IsEqualGUID(&pOemEntry->iidIntfOem, &IID_IPrintOemUI))
    {
        return ((IPrintOemUI *)(pOemEntry)->pIntfOem)->Release();
    }

#else

    CALL_INTERFACE(pOemEntry, Release,
                      ());
#endif

    return 0;
}


extern "C" HRESULT HComOEMGetInfo(POEM_PLUGIN_ENTRY    pOemEntry,
                                  DWORD                dwMode,
                                  PVOID                pBuffer,
                                  DWORD                cbSize,
                                  PDWORD               pcbNeeded)
{

    CALL_INTERFACE(pOemEntry, GetInfo,
                   (dwMode,
                    pBuffer,
                    cbSize,
                    pcbNeeded));
}

extern "C" HRESULT HComOEMDevMode(POEM_PLUGIN_ENTRY    pOemEntry,
                                  DWORD                dwMode,
                                  POEMDMPARAM          pOemDMParam)
{
    CALL_INTERFACE(pOemEntry, DevMode,
                   (dwMode,
                   pOemDMParam));
}

extern "C" HRESULT HComOEMCommonUIProp(POEM_PLUGIN_ENTRY   pOemEntry,
                                       DWORD               dwMode,
                                       POEMCUIPPARAM       pOemCUIPParam)
{

    CALL_INTERFACE(pOemEntry, CommonUIProp,
                    (dwMode, pOemCUIPParam));
}

extern "C" HRESULT HComOEMDocumentPropertySheets(POEM_PLUGIN_ENTRY pOemEntry,
                                                 PPROPSHEETUI_INFO pPSUIInfo,
                                                 LPARAM            lParam)
{

    CALL_INTERFACE(pOemEntry, DocumentPropertySheets,
                    (pPSUIInfo,
                     lParam));
}

extern "C" HRESULT HComOEMDevicePropertySheets(POEM_PLUGIN_ENTRY pOemEntry,
                                               PPROPSHEETUI_INFO pPSUIInfo,
                                               LPARAM            lParam)
{

    CALL_INTERFACE(pOemEntry,DevicePropertySheets,
                    (pPSUIInfo,
                     lParam));
}

extern "C" HRESULT HComOEMDevQueryPrintEx(POEM_PLUGIN_ENTRY    pOemEntry,
                                          POEMUIOBJ            poemuiobj,
                                          PDEVQUERYPRINT_INFO  pDQPInfo,
                                          PDEVMODE             pPublicDM,
                                          PVOID                pOEMDM)
{

    CALL_INTERFACE(pOemEntry, DevQueryPrintEx,
                    (poemuiobj,
                     pDQPInfo,
                     pPublicDM,
                     pOEMDM));

}

extern "C" HRESULT HComOEMDeviceCapabilities(POEM_PLUGIN_ENTRY    pOemEntry,
                                             POEMUIOBJ   poemuiobj,
                                             HANDLE      hPrinter,
                                             PWSTR       pDeviceName,
                                             WORD        wCapability,
                                             PVOID       pOutput,
                                             PDEVMODE    pPublicDM,
                                             PVOID       pOEMDM,
                                             DWORD       dwOld,
                                             DWORD       *pdwResult)
{

    CALL_INTERFACE(pOemEntry, DeviceCapabilities,
                    (poemuiobj,
                     hPrinter,
                     pDeviceName,
                     wCapability,
                     pOutput,
                     pPublicDM,
                     pOEMDM,
                     dwOld,
                     pdwResult));
}

extern "C" HRESULT HComOEMUpgradePrinter(POEM_PLUGIN_ENTRY    pOemEntry,
                                         DWORD                dwLevel,
                                         PBYTE                pDriverUpgradeInfo)
{
    CALL_INTERFACE(pOemEntry, UpgradePrinter,
                   (dwLevel,
                   pDriverUpgradeInfo));
}

extern "C" HRESULT HComOEMPrinterEvent(POEM_PLUGIN_ENTRY   pOemEntry,
                                       PWSTR              pPrinterName,
                                       INT                iDriverEvent,
                                       DWORD              dwFlags,
                                       LPARAM             lParam)
{

    CALL_INTERFACE(pOemEntry, PrinterEvent,
                   (pPrinterName,
                    iDriverEvent,
                    dwFlags,
                    lParam));
}

extern "C" HRESULT HComOEMDriverEvent(POEM_PLUGIN_ENTRY   pOemEntry,
                                      DWORD               dwDriverEvent,
                                      DWORD               dwLevel,
                                      LPBYTE              pDriverInfo,
                                      LPARAM              lParam)
{

    CALL_INTERFACE(pOemEntry, DriverEvent,
                   (dwDriverEvent,
                    dwLevel,
                    pDriverInfo,
                    lParam));
}

extern "C" HRESULT HComOEMQUeryColorProfile(POEM_PLUGIN_ENTRY  pOemEntry,
                                            HANDLE             hPrinter,
                                            POEMUIOBJ          poemuiobj,
                                            PDEVMODE           pPublicDM,
                                            PVOID              pOEMDM,
                                            ULONG              ulQueryMode,
                                            VOID               *pvProfileData,
                                            ULONG              *pcbProfileData,
                                            FLONG              *pflProfileData)

{
    CALL_INTERFACE(pOemEntry,QueryColorProfile,
                   (hPrinter,
                    poemuiobj,
                    pPublicDM,
                    pOEMDM,
                    ulQueryMode,
                    pvProfileData,
                    pcbProfileData,
                    pflProfileData));
}

extern "C" HRESULT HComOEMFontInstallerDlgProc(POEM_PLUGIN_ENTRY   pOemEntry,
                                               HWND                hWnd,
                                               UINT                usMsg,
                                               WPARAM              wParam,
                                               LPARAM              lParam)
{

    CALL_INTERFACE(pOemEntry, FontInstallerDlgProc,
                   (hWnd,
                    usMsg,
                    wParam,
                    lParam));
}

extern "C" HRESULT HComOEMUpdateExternalFonts(POEM_PLUGIN_ENTRY   pOemEntry,
                                              HANDLE  hPrinter,
                                              HANDLE  hHeap,
                                              PWSTR   pwstrCartridges)
{

    CALL_INTERFACE(pOemEntry, UpdateExternalFonts,
                   (hPrinter,
                    hHeap,
                    pwstrCartridges));
}

extern "C" HRESULT HComOEMQueryJobAttributes(POEM_PLUGIN_ENTRY   pOemEntry,
                                            HANDLE      hPrinter,
                                            PDEVMODE    pDevMode,
                                            DWORD       dwLevel,
                                            LPBYTE      lpAttributeInfo)
{

    CALL_INTERFACE2(pOemEntry, QueryJobAttributes,
                   (hPrinter,
                    pDevMode,
                    dwLevel,
                    lpAttributeInfo));
}

extern "C" HRESULT HComOEMHideStandardUI(POEM_PLUGIN_ENTRY   pOemEntry,
                                         DWORD               dwMode)
{

    CALL_INTERFACE2(pOemEntry, HideStandardUI,
                   (dwMode));
}

extern "C" HRESULT HComOEMDocumentEvent(POEM_PLUGIN_ENTRY  pOemEntry,
                                        HANDLE   hPrinter,
                                        HDC      hdc,
                                        INT      iEsc,
                                        ULONG    cbIn,
                                        PVOID    pbIn,
                                        ULONG    cbOut,
                                        PVOID    pbOut,
                                        PINT     piResult)
{
    CALL_INTERFACE2(pOemEntry, DocumentEvent,
                    (hPrinter,
                     hdc,
                     iEsc,
                     cbIn,
                     pbIn,
                     cbOut,
                     pbOut,
                     piResult));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\initdll.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    intidll.c

Abstract:

    This file handles the DLLInitialize spooler API

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    07/17/96 -amandan-
        Created it.

--*/


#include "precomp.h"

//
// Global instance handle and critical section
//

HINSTANCE ghInstance;
// CRITICAL_SECTION gCriticalSection;


BOOL WINAPI
DllMain(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    This function is called when the system loads/unloads the DriverUI module.
    At DLL_PROCESS_ATTACH, InitializeCriticalSection is called to initialize
    the critical section objects.
    At DLL_PROCESS_DETACH, DeleteCriticalSection is called to release the
    critical section objects.

Arguments:

    hModule     handle to DLL module
    ulReason    reason for the call
    pContext    pointer to context (not used by us)


Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:

        ghInstance = hModule;
        // InitializeCriticalSection(&gCriticalSection);
        break;

    case DLL_PROCESS_DETACH:

        // DeleteCriticalSection(&gCriticalSection);
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\oemui.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oemui.h

Abstract:

    Header file to support OEM plugin UI

Environment:

    Windows NT printer drivers

Revision History:

    02/13/97 -davidx-
        Created it.

--*/

#ifndef _OEMUI_H_
#define _OEMUI_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Macros used to loop through each OEM plugin
//

#define FOREACH_OEMPLUGIN_LOOP(pci) \
        { \
            DWORD _oemCount = (pci)->pOemPlugins->dwCount; \
            POEM_PLUGIN_ENTRY pOemEntry = (pci)->pOemPlugins->aPlugins; \
            for ( ; _oemCount--; pOemEntry++) \
            { \
                if (pOemEntry->hInstance == NULL) continue;

#define END_OEMPLUGIN_LOOP \
            } \
        }

//
// Call OEM plugin UI modules to let them add their OPTITEMs
//

BOOL
BPackOemPluginItems(
    PUIDATA pUiData
    );

//
// Call OEM plugin module's callback function
//

LONG
LInvokeOemPluginCallbacks(
    PUIDATA         pUiData,
    PCPSUICBPARAM   pCallbackParam,
    LONG            lRet
    );

//
// Call OEM plugin UI modules to let them add their own property sheet pages
//

BOOL
BAddOemPluginPages(
    PUIDATA pUiData,
    DWORD   dwFlags
    );

//
// Figure whether a particular item is belongs to the driver
// (instead of to one of the OEM plugin UI modules)
//

#define IS_DRIVER_OPTITEM(pUiData, pOptItem) \
        ((DWORD) ((pOptItem) - (pUiData)->pDrvOptItem) < (pUiData)->dwDrvOptItem)


//
// Provide OEM plugins access to driver private settings
//

BOOL
APIENTRY
BGetDriverSettingForOEM(
    PCOMMONINFO pci,
    PCSTR       pFeatureKeyword,
    PVOID       pOutput,
    DWORD       cbSize,
    PDWORD      pcbNeeded,
    PDWORD      pdwOptionsReturned
    );

BOOL
BUpdateUISettingForOEM(
    PCOMMONINFO pci,
    PVOID       pOptItem,
    DWORD       dwPreviousSelection,
    DWORD       dwMode
    );


BOOL
BUpgradeRegistrySettingForOEM(
    HANDLE      hPrinter,
    PCSTR       pFeatureKeyword,
    PCSTR       pOptionKeyword
    );


extern const OEMUIPROCS OemUIHelperFuncs;

HRESULT
HDriver_CoCreateInstance(
    IN REFCLSID     rclsid,
    IN LPUNKNOWN    pUnknownOuter,
    IN DWORD        dwClsContext,
    IN REFIID       riid,
    IN LPVOID      *ppv,
    IN HANDLE       hInstance
    );

//
// The following helper functions are only available to UI plugins
//

#ifdef PSCRIPT

#ifndef WINNT_40

HRESULT
HQuerySimulationSupport(
    IN  HANDLE  hPrinter,
    IN  DWORD   dwLevel,
    OUT PBYTE   pCaps,
    IN  DWORD   cbSize,
    OUT PDWORD  pcbNeeded
    );

#endif // !WINNT_40

HRESULT
HEnumConstrainedOptions(
    IN  POEMUIOBJ  poemuiobj,
    IN  DWORD      dwFlags,
    IN  PCSTR      pszFeatureKeyword,
    OUT PSTR       pmszConstrainedOptionList,
    IN  DWORD      cbSize,
    OUT PDWORD     pcbNeeded
    );

HRESULT
HWhyConstrained(
    IN  POEMUIOBJ  poemuiobj,
    IN  DWORD      dwFlags,
    IN  PCSTR      pszFeatureKeyword,
    IN  PCSTR      pszOptionKeyword,
    OUT PSTR       pmszReasonList,
    IN  DWORD      cbSize,
    OUT PDWORD     pcbNeeded
    );

HRESULT
HSetOptions(
    IN  POEMUIOBJ  poemuiobj,
    IN  DWORD      dwFlags,
    IN  PCSTR      pmszFeatureOptionBuf,
    IN  DWORD      cbIn,
    OUT PDWORD     pdwResult
    );

#endif // PSCRIPT

#ifdef __cplusplus
}
#endif

#endif  // !_OEMUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\forms.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    forms.c

Abstract:

    Functions for dealing with paper and forms.

[Environment:]

    Win32 subsystem, PostScript driver

Revision History:

    02/10/97 -davidx-
        Consistent handling of common printer info.

    07/24/96 -amandan-
        Modified for common binary data and common UI module

    07/25/95 -davidx-
        Created it.

--*/

#include "precomp.h"


BOOL
BFormSupportedOnPrinter(
    IN PCOMMONINFO  pci,
    IN PFORM_INFO_1 pForm,
    OUT PDWORD      pdwOptionIndex
    )

/*++

Routine Description:

    Determine whether a form is supported on a printer

Arguments:
    pci - Points to basic printer information
    pForm - Pointer to information about the form in question
    pdwOptionIndex - Returns the paper size option index corresponding
        to the specified form if the form is supported.

Return Value:

    TRUE if the requested form is supported on the printer.
    FALSE otherwise.

--*/

{
    PRAWBINARYDATA  pRawData;
    PUIINFO         pUIInfo;
    PFEATURE        pFeature;
    DWORD           dwIndex;
    CHAR            chBuf[CCHPAPERNAME];
    WCHAR           wchBuf[CCHPAPERNAME];

    //
    // For a user-defined form, we only care about paper dimension.
    // Let the parser handle this case.
    //

    if (! (pForm->Flags & (FORM_BUILTIN|FORM_PRINTER)))
    {
        *pdwOptionIndex = MapToDeviceOptIndex(
                                pci->pInfoHeader,
                                GID_PAGESIZE,
                                pForm->Size.cx,
                                pForm->Size.cy,
                                NULL);

        return (*pdwOptionIndex != OPTION_INDEX_ANY);
    }

    //
    // For predefined or driver-defined form, we need exact name and size match
    //

    chBuf[0] = NUL;
    *pdwOptionIndex = OPTION_INDEX_ANY;

    if (! (pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGESIZE)))
        return FALSE;

    for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++)
    {
        PPAGESIZE   pPageSize;
        PWSTR       pwstr;
        PSTR        pstr;
        BOOL        bNameMatch;
        LONG        x, y;

        pPageSize = PGetIndexedOption(pci->pUIInfo, pFeature, dwIndex);
        ASSERT(pPageSize != NULL);

        //
        // check if the size matches
        //

        x = MASTER_UNIT_TO_MICRON(pPageSize->szPaperSize.cx,
                                  pci->pUIInfo->ptMasterUnits.x);

        y = MASTER_UNIT_TO_MICRON(pPageSize->szPaperSize.cy,
                                  pci->pUIInfo->ptMasterUnits.y);

        if (abs(x - pForm->Size.cx) > 1000 ||
            abs(y - pForm->Size.cy) > 1000)
        {
            continue;
        }

        //
        // check if the name matches
        //

        LOAD_STRING_PAGESIZE_NAME(pci, pPageSize, wchBuf, CCHPAPERNAME);
        bNameMatch = (_tcsicmp(wchBuf, pForm->pName) == EQUAL_STRING);


        if (!bNameMatch && (pForm->Flags & FORM_BUILTIN))
        {
            PSTR    pstrKeyword;

            //
            // special klugy for predefined form:
            // if display name doesn't match, try to match the keyword string
            //

            if (chBuf[0] == NUL)
            {
                WideCharToMultiByte(1252, 0, pForm->pName, -1, chBuf, CCHPAPERNAME, NULL, NULL);
                chBuf[CCHPAPERNAME-1] = NUL;
            }
            pstrKeyword = OFFSET_TO_POINTER(pci->pUIInfo->pubResourceData, pPageSize->GenericOption.loKeywordName);

            ASSERT(pstrKeyword != NULL);

            bNameMatch = (_stricmp(chBuf, pstrKeyword) == EQUAL_STRING);
        }


        if (bNameMatch)
        {
             *pdwOptionIndex = dwIndex;
             return TRUE;
        }
    }

    return FALSE;
}



DWORD
DwGuessFormIconID(
    PWSTR   pFormName
    )

/*++

Routine Description:

    Figure out the icon ID corresponding to the named form

Arguments:

    pFormName - Pointer to the form name string

Return Value:

    Icon ID corresponding to the specified form name

Note:

    This is very klugy but I guess it's better than using the same icon
    for all forms. We try to differentiate envelopes from normal forms.
    We assume a form name refers an envelope if it contains word Envelope or Env.

--*/

#define MAXENVLEN 32

{
    static WCHAR wchPrefix[MAXENVLEN], wchEnvelope[MAXENVLEN];
    static INT   iPrefixLen = 0, iEnvelopeLen = 0;

    if (iPrefixLen <= 0 || iEnvelopeLen <= 0)
    {
        iPrefixLen = LoadString(ghInstance, IDS_ENV_PREFIX, wchPrefix, MAXENVLEN);
        iEnvelopeLen = LoadString(ghInstance, IDS_ENVELOPE, wchEnvelope, MAXENVLEN);
    }

    if (iPrefixLen <= 0 || iEnvelopeLen <= 0)
        return IDI_CPSUI_STD_FORM;

    while (*pFormName)
    {
        //
        // Do we have a word matching our description?
        //

        if (_wcsnicmp(pFormName, wchPrefix, iPrefixLen) == EQUAL_STRING &&
            (pFormName[iPrefixLen] == L' ' ||
             pFormName[iPrefixLen] == NUL ||
             _wcsnicmp(pFormName, wchEnvelope, iEnvelopeLen) == EQUAL_STRING))
        {
            return IDI_CPSUI_ENVELOPE;
        }

        //
        // Move on to the next word
        //

        while (*pFormName && *pFormName != L' ')
            pFormName++;

        while (*pFormName && *pFormName == L' ')
            pFormName++;
    }

    return IDI_CPSUI_STD_FORM;
}



ULONG_PTR
HLoadFormIconResource(
    PUIDATA pUiData,
    DWORD   dwIndex
    )

/*++

Routine Description:

    Load the icon resource corresponding to the specified form

Arguments:

    pUiData - Points to UIDATA structure
    dwIndex - Specifies the form index. It's used to index into
         pUiData->pwPaperFeatures to get the page size option index.

Return Value:

    Icon resource handle corresponding to the specified form (casted as DWORD)
    0 if the specified icon resource cannot be loaded

--*/

{
    PFEATURE    pFeature;
    POPTION     pOption;

    dwIndex = pUiData->pwPaperFeatures[dwIndex];

    if ((pFeature = GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_PAGESIZE)) &&
        (pOption = PGetIndexedOption(pUiData->ci.pUIInfo, pFeature, dwIndex)) &&
        (pOption->loResourceIcon != 0))
    {
        return HLoadIconFromResourceDLL(&pUiData->ci, pOption->loResourceIcon);
    }

    return 0;
}



POPTTYPE
BFillFormNameOptType(
    IN PUIDATA  pUiData
    )

/*++

Routine Description:

    Initialize an OPTTYPE structure to hold information
    about the list of forms supported by a printer

Arguments:

    pUiData - Pointer to UIDATA structure

Return Value:

    Pointer to an OPTTYPE structure, NULL if there is an error

--*/

{
    POPTTYPE    pOptType;
    POPTPARAM   pOptParam;
    DWORD       dwFormName, dwIndex;
    PWSTR       pFormName;
    PUIINFO     pUIInfo = pUiData->ci.pUIInfo;

    dwFormName = pUiData->dwFormNames;

    //
    // Allocate memory to hold OPTTYPE and OPTPARAM structures
    //

    pOptType = HEAPALLOC(pUiData->ci.hHeap, sizeof(OPTTYPE));
    pOptParam = HEAPALLOC(pUiData->ci.hHeap, sizeof(OPTPARAM) * dwFormName);

    if (!pOptType || !pOptParam)
    {
        ERR(("Memory allocation failed\n"));
        return NULL;
    }

    //
    // Initialize OPTTYPE structure
    //

    pOptType->cbSize = sizeof(OPTTYPE);
    pOptType->Count = (WORD) dwFormName;
    pOptType->Type = TVOT_LISTBOX;
    pOptType->pOptParam = pOptParam;
    pOptType->Style = OTS_LBCB_SORT | OTS_LBCB_INCL_ITEM_NONE;

    //
    // Enumerate the list of supported form names
    //

    pFormName = pUiData->pFormNames;

    for (dwIndex=0; dwIndex < dwFormName; dwIndex++, pOptParam++)
    {
        pOptParam->cbSize = sizeof(OPTPARAM);
        pOptParam->pData = pFormName;

        if (pOptParam->IconID = HLoadFormIconResource(pUiData, dwIndex))
            pOptParam->Flags |= OPTPF_ICONID_AS_HICON;
        else
            pOptParam->IconID = DwGuessFormIconID(pFormName);

        pFormName += CCHPAPERNAME;
    }

    return pOptType;
}



POPTTYPE
PAdjustFormNameOptType(
    IN PUIDATA  pUiData,
    IN POPTTYPE pOptType,
    IN DWORD    dwTraySelection
    )

/*++

Routine Description:

    Adjust the list of forms for each tray
    Check each form for support on printer tray

    Given a tray selected, go through all the forms selection
    and determines which one conflicts with the current tray selection

Arguments:

    pUiData - Pointer to our UIDATA structure
    pOptType - Pointer to OPTTYPE
    dwTraySelection - Tray index

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    POPTPARAM   pOptParam;
    DWORD       dwOptParam, dwFormIndex;
    DWORD       dwTrayFeatureIndex, dwFormFeatureIndex;
    PFEATURE    pTrayFeature, pFormFeature;
    PUIINFO     pUIInfo = pUiData->ci.pUIInfo;

    dwOptParam = pOptType->Count;

    //
    // Find the pointers to InputSlot and PageSize features
    //

    pTrayFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_INPUTSLOT);
    pFormFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGESIZE);

    if (!pTrayFeature || !pFormFeature)
        return pOptType;

    dwTrayFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pTrayFeature);
    dwFormFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFormFeature);

    //
    // Make a copy of the array of formname OPTPARAMs
    //

    if (dwTraySelection != 0)
    {
        POPTTYPE pNewType;

        pNewType = HEAPALLOC(pUiData->ci.hHeap, sizeof(OPTTYPE));
        pOptParam = HEAPALLOC(pUiData->ci.hHeap, sizeof(OPTPARAM) * dwOptParam);

        if (!pNewType || !pOptParam)
        {
            ERR(("Memory allocation failed\n"));
            return NULL;
        }

        CopyMemory(pNewType, pOptType, sizeof(OPTTYPE));
        CopyMemory(pOptParam, pOptType->pOptParam, sizeof(OPTPARAM) * dwOptParam);

        pNewType->pOptParam = pOptParam;
        pOptType = pNewType;
    }
    else
        pOptParam = pOptType->pOptParam;

    //
    // Go through each formname
    // Check whether the current form tray feature, index
    // conflicts with another form tray feature,index
    //

    for (dwFormIndex=0; dwFormIndex < dwOptParam; dwFormIndex++)
    {
        DWORD dwFormSelection = pUiData->pwPaperFeatures[dwFormIndex];

        #ifdef PSCRIPT

        //
        // Hide only the option "PostScript Custom Page Size" itself. For other
        // forms that are supported via PostScript Custom Page Size, we still
        // want to show them, same as Unidrv does.
        //

        if (pUiData->pwPapers[dwFormIndex] == DMPAPER_CUSTOMSIZE)
        {
            pOptParam[dwFormIndex].Flags |= (OPTPF_HIDE | CONSTRAINED_FLAG);
            continue;
        }

        #endif // PSCRIPT

        //
        // If the form conflicts with the tray, then don't display it.
        //

        if (dwFormSelection != OPTION_INDEX_ANY &&
            CheckFeatureOptionConflict(pUiData->ci.pRawData,
                                       dwTrayFeatureIndex,
                                       dwTraySelection,
                                       dwFormFeatureIndex,
                                       dwFormSelection))
        {
            pOptParam[dwFormIndex].Flags |= (OPTPF_HIDE | CONSTRAINED_FLAG);
        }
        else
        {
            pOptParam[dwFormIndex].Flags &= ~(OPTPF_HIDE | CONSTRAINED_FLAG);
        }
    }

    return pOptType;
}



BOOL
BPackItemFormTrayTable(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack form-to-tray assignment information into treeview item
    structures so that we can call common UI library.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    POPTITEM    pOptItem;
    POPTTYPE    pOptType;
    DWORD       dwIndex, dwTrays;
    PWSTR       pTrayName;

    dwTrays = pUiData->dwBinNames;

    if (dwTrays == 0)
    {
        WARNING(("No paper bin available\n"));
        return TRUE;
    }

    //
    // Form-to-tray assignment table
    //     Tray <-> Form
    //     ...

    VPackOptItemGroupHeader(
            pUiData,
            IDS_CPSUI_FORMTRAYASSIGN,
            IDI_CPSUI_FORMTRAYASSIGN,
            HELP_INDEX_FORMTRAYASSIGN);

    pUiData->dwFormTrayItem = dwTrays;
    pUiData->dwOptItem += dwTrays;

    if (pUiData->pOptItem == NULL)
        return TRUE;

    pUiData->pFormTrayItems = pUiData->pOptItem;

    //
    // Generate the list of form names
    // Each OPTITEM(Tray) has a OPTTYPE.
    //

    pOptType = BFillFormNameOptType(pUiData);

    if (pOptType == NULL)
    {
        ERR(("BFillFormNameOptType failed\n"));
        return FALSE;
    }

    //
    // Create an OPTITEM for each tray
    //

    pTrayName = pUiData->pBinNames ;
    pOptItem = pUiData->pOptItem;

    for (dwIndex=0; dwIndex < dwTrays; dwIndex++)
    {
        //
        // The tray items cannot share OPTTYPE and OPTPARAMs because
        // each tray can contain a different list of forms.
        //

        pOptType = PAdjustFormNameOptType(pUiData, pOptType, dwIndex);

        if (pOptType == NULL)
        {
            ERR(("PAdjustFormNameOptParam failed\n"));
            return FALSE;
        }

        FILLOPTITEM(pOptItem,
                    pOptType,
                    pTrayName,
                    0,
                    TVITEM_LEVEL2,
                    DMPUB_NONE,
                    FORM_TRAY_ITEM,
                    HELP_INDEX_TRAY_ITEM);

        //
        // NOTE: hide the first tray if it's AutoSelect
        //

        if (dwIndex == 0)
        {
            PFEATURE    pFeature;
            PINPUTSLOT  pInputSlot;

            if ((pFeature = GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_INPUTSLOT)) &&
                (pInputSlot = PGetIndexedOption(pUiData->ci.pUIInfo, pFeature, 0)) &&
                (pInputSlot->dwPaperSourceID == DMBIN_FORMSOURCE))
            {
                pOptItem->Flags |= (OPTIF_HIDE|OPTIF_DISABLED);
            }
        }

        pOptItem++;
        pTrayName += CCHBINNAME;
    }

    pUiData->pOptItem = pOptItem;
    return TRUE;
}



VOID
VSetupFormTrayAssignments(
    IN PUIDATA  pUiData
    )

/*++

Routine Description:

    Update the current selection of tray items based on
    the specified form-to-tray assignment table

Arguments:

    pUiData - Pointer to our UIDATA structure

Return Value:

    NONE

Note:

    We assume the form-tray items are in their default states
    when this function is called.

--*/

{
    POPTITEM        pOptItem;
    POPTPARAM       pOptParam;
    FORM_TRAY_TABLE pFormTrayTable;
    FINDFORMTRAY    FindData;
    DWORD           dwTrayStartIndex, dwTrayIndex, dwFormIndex, dwTrays, dwOptParam;
    PCOMMONINFO     pci;
    PFEATURE        pFeature;
    PINPUTSLOT      pInputSlot;
    PPAGESIZE       pPageSize;

    if ((dwTrays = pUiData->dwFormTrayItem) == 0)
        return;

    pci = &pUiData->ci;

    pOptItem = pUiData->pFormTrayItems;
    pOptParam = pOptItem->pOptType->pOptParam;
    dwOptParam = pOptItem->pOptType->Count;

    //
    // Initialize the current selection for every tray to be
    //  "Not Available"
    //

    for (dwTrayIndex=0; dwTrayIndex < dwTrays; dwTrayIndex++)
        pOptItem[dwTrayIndex].Sel = -1;

    pFormTrayTable = PGetFormTrayTable(pUiData->ci.hPrinter, NULL);

    //
    // If the form-to-tray assignment information doesn't exist,
    // set up the default assignments
    //

    if (pFormTrayTable == NULL)
    {
        PWSTR  pwstrDefaultForm = NULL;
        WCHAR  awchBuf[CCHPAPERNAME];
        BOOL   bMetric = IsMetricCountry();

        //
        // Get the default formname (Letter or A4) and
        // convert it formname to a seleciton index.
        //

        if (bMetric && (pci->pUIInfo->dwFlags & FLAG_A4_SIZE_EXISTS))
        {
            pwstrDefaultForm = A4_FORMNAME;
        }
        else if (!bMetric && (pci->pUIInfo->dwFlags & FLAG_LETTER_SIZE_EXISTS))
        {
            pwstrDefaultForm = LETTER_FORMNAME;
        }
        else
        {
            if ((pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGESIZE)) &&
                (pPageSize = PGetIndexedOption(pci->pUIInfo, pFeature, pFeature->dwDefaultOptIndex)) &&
                LOAD_STRING_PAGESIZE_NAME(pci, pPageSize, awchBuf, CCHPAPERNAME))
            {
                pwstrDefaultForm = &(awchBuf[0]);
            }
        }

        //
        // If we can't find the default form name, we have to use the first option as the default.
        //

        dwFormIndex = pwstrDefaultForm ? DwFindFormNameIndex(pUiData, pwstrDefaultForm, NULL) : 0 ;

        ASSERT(dwFormIndex < dwOptParam);

        //
        // Set the default formname for each enabled tray
        //

        for (dwTrayIndex=0; dwTrayIndex < dwTrays; dwTrayIndex++)
        {
            if (! (pOptItem[dwTrayIndex].Flags & OPTIF_DISABLED) &&
                ! IS_CONSTRAINED(&pOptItem[dwTrayIndex], dwFormIndex))
            {
                pOptItem[dwTrayIndex].Sel = dwFormIndex;
            }
        }

        //
        // Save the default form-to-tray assignment table to registry.
        //

        if (HASPERMISSION(pUiData))
            BUnpackItemFormTrayTable(pUiData);

        return;
    }

    //
    // We are here means that the form to tray assignment does exits.
    // Iterate thru the form-to-tray assignment table one entry at
    // a time and update the current selection of tray items.
    //

    RESET_FINDFORMTRAY(pFormTrayTable, &FindData);

    //
    // If we have synthersized the first "AutoSelect" tray, we should skip it
    // in following searching through the form to tray assignment table.
    //
    // (refer to the logic in previous function BPackItemFormTrayTable)
    //

    dwTrayStartIndex = 0;

    if ((pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_INPUTSLOT)) &&
        (pInputSlot = PGetIndexedOption(pci->pUIInfo, pFeature, 0)) &&
        (pInputSlot->dwPaperSourceID == DMBIN_FORMSOURCE))
    {
        dwTrayStartIndex = 1;
    }

    while (BSearchFormTrayTable(pFormTrayTable, NULL, NULL, &FindData))
    {
        //
        // Get the next entry in the form-to-tray assignment table
        //

        for (dwTrayIndex = dwTrayStartIndex; dwTrayIndex < dwTrays; dwTrayIndex++)
        {
            //
            // found matching tray?
            //

            if (_wcsicmp(FindData.ptstrTrayName, pOptItem[dwTrayIndex].pName) == EQUAL_STRING)
            {
                //
                // If the specified tray name is supported, then check
                // if the associated form name is supported.
                //

                for (dwFormIndex=0; dwFormIndex < dwOptParam; dwFormIndex++)
                {
                    if (_wcsicmp(FindData.ptstrFormName,
                                 pOptParam[dwFormIndex].pData) == EQUAL_STRING)
                    {
                        break;
                    }
                }

                if (dwFormIndex == dwOptParam)
                {
                    WARNING(("Unknown form name: %ws\n", FindData.ptstrFormName));
                }
                else if ((pOptItem[dwTrayIndex].Flags & OPTIF_DISABLED) ||
                         IS_CONSTRAINED(&pOptItem[dwTrayIndex], dwFormIndex))
                {
                    WARNING(("Conflicting form-tray assignment\n"));
                }
                else
                {
                    //
                    // If the associated form name is supported,
                    // then remember the form index.
                    //

                    pOptItem[dwTrayIndex].Sel = dwFormIndex;
                }

                break;
            }
        }

        if (dwTrayIndex == dwTrays)
            WARNING(("Unknown tray name: %ws\n", FindData.ptstrTrayName));
    }

    MemFree(pFormTrayTable);
}



DWORD
DwCollectFormTrayAssignments(
    IN PUIDATA  pUiData,
    OUT PWSTR   pwstrTable
    )

/*++

Routine Description:

    Collect the form-to-tray assignment information and save it to registry.

Arguments:

    pUiData - Pointer to our UIDATA structure
    pwstrTable - Pointer to memory buffer for storing the table
        NULL if the caller is only interested in the table size

Return Value:

    Size of the table bytes, 0 if there is an error.

--*/

{
    DWORD       dwChars = 0;
    INT         iLength;
    DWORD       dwIndex;
    POPTPARAM   pOptParam;
    DWORD       dwOptItem = pUiData->dwFormTrayItem;
    POPTITEM    pOptItem = pUiData->pFormTrayItems;

    for (dwIndex=0; dwIndex < dwOptItem; dwIndex++, pOptItem++)
    {
        ASSERT(ISFORMTRAYITEM(pOptItem->UserData));

        if ((pOptItem->Flags & OPTIF_DISABLED))
            continue;

        //
        // Get the Tray name
        //

        iLength = wcslen(pOptItem->pName) + 1;
        dwChars += iLength;

        if (pwstrTable != NULL)
        {
            CopyMemory(pwstrTable, pOptItem->pName, iLength * sizeof(WCHAR));
            pwstrTable += iLength;
        }

        //
        // Form name
        //

        if (pOptItem->Sel < 0 )
        {
            dwChars++;
            if (pwstrTable != NULL)
                *pwstrTable++ = NUL;

            continue;
        }

        pOptParam = pOptItem->pOptType->pOptParam + pOptItem->Sel;
        iLength = wcslen(pOptParam->pData) + 1;
        dwChars += iLength;

        if (pwstrTable != NULL)
        {
            CopyMemory(pwstrTable, pOptParam->pData, iLength * sizeof(WCHAR));
            pwstrTable += iLength;
        }
    }

    //
    // Append a NUL character at the end of the table
    //

    dwChars++;

    if (pwstrTable != NULL)
        *pwstrTable = NUL;

    //
    // Return the table size in bytes
    //

    return dwChars * sizeof(WCHAR);
}



BOOL
BUnpackItemFormTrayTable(
    IN PUIDATA  pUiData
    )

/*++

Routine Description:

    Extract form-to-tray assignment information from treeview items

Arguments:

    pUiData - Pointer to UIDATA structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    PWSTR   pwstrTable = NULL;
    DWORD   dwTableSize;

    //
    // Figure out how much memory we need to store the form-to-tray assignment table
    // Assemble the form-to-tray assignment table
    // Save the form-to-tray assignment table to registry
    //

    if ((dwTableSize = DwCollectFormTrayAssignments(pUiData, NULL)) == 0 ||
        (pwstrTable = MemAlloc(dwTableSize)) == NULL ||
        (dwTableSize != DwCollectFormTrayAssignments(pUiData, pwstrTable)) ||
        !BSaveFormTrayTable(pUiData->ci.hPrinter, pwstrTable, dwTableSize))
    {
        ERR(("Couldn't save form-to-tray assignment table\n"));
        MemFree(pwstrTable);
        return FALSE;
    }

    #ifndef WINNT_40

    //
    // Publish list of available forms in the directory service
    //

    VNotifyDSOfUpdate(pUiData->ci.hPrinter);

   #endif // !WINNT_40

    MemFree(pwstrTable);
    return TRUE;
}



DWORD
DwFindFormNameIndex(
    IN  PUIDATA  pUiData,
    IN  PWSTR    pFormName,
    OUT PBOOL    pbSupported
    )

/*++

Routine Description:

    Given a formname, find its index in the list of supported forms

Arguments:

    pUiData - Pointer to our UIDATA structure
    pFormName - Formname in question
    pbSupported - Whether or not the form is suppported

Return Value:

    Index of the specified formname in the list.

--*/

{
    DWORD       dwIndex;
    PWSTR       pName;
    FORM_INFO_1 *pForm;
    PFEATURE    pFeature;
    PPAGESIZE   pPageSize;
    WCHAR       awchBuf[CCHPAPERNAME];
    PCOMMONINFO pci;

    if (pbSupported)
        *pbSupported = TRUE;

    if (IS_EMPTY_STRING(pFormName))
        return 0;

    //
    // Check if the name appears in the list
    //

    pName = pUiData->pFormNames;

    for (dwIndex=0; dwIndex < pUiData->dwFormNames; dwIndex++)
    {
        if (_wcsicmp(pFormName, pName) == EQUAL_STRING)
            return dwIndex;

        pName += CCHPAPERNAME;
    }

    //
    // If the name is not in the list, try to match
    // the form to a printer page size
    //

    pci = (PCOMMONINFO) pUiData;

    if ((pForm = MyGetForm(pci->hPrinter, pFormName, 1)) &&
        BFormSupportedOnPrinter(pci, pForm, &dwIndex) &&
        (pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGESIZE)) &&
        (pPageSize = PGetIndexedOption(pci->pUIInfo, pFeature, dwIndex)) &&
        LOAD_STRING_PAGESIZE_NAME(pci, pPageSize, awchBuf, CCHPAPERNAME))
    {
        pName = pUiData->pFormNames;

        for (dwIndex = 0; dwIndex < pUiData->dwFormNames; dwIndex++)
        {
            if (_wcsicmp(awchBuf, pName) == EQUAL_STRING)
            {
                MemFree(pForm);
                return dwIndex;
            }

            pName += CCHPAPERNAME;
        }
    }

    MemFree(pForm);

    //
    // The specified form is not supported on the printer.
    // Select the first available form.
    //

    if (pbSupported)
        *pbSupported = FALSE;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\prnevent.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prnevent.c

Abstract:

    This file handles the DrvPrinterEvent spooler API.

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    08/30/00 -fengy-
        Added DrvDocumentEvent support.

    02/13/97 -davidx-
        Implement OEM plugin support.

    02/06/97 -davidx-
        Rewrote it to use common data management functions.

    02/04/97 -davidx-
        Reorganize driver UI to separate ps and uni DLLs.

    07/17/96 -amandan-
        Modified for common UI and shared binary data

    05/20/96 -davidx-
        Created it.

--*/


#include "precomp.h"

//
// DOCUMENTEVENT_QUERYFILTER is introduced in Whistler.
// We need to define it if it's not defined (on Win2K)
// so our code can be built with Win2K DDK.
//

#ifndef DOCUMENTEVENT_QUERYFILTER

#define DOCUMENTEVENT_QUERYFILTER  14

#endif

//
// Private APIs exported by the spooler for printer drivers and port monitors.
// These must be kept in sync with winsplp.h.
//

typedef HANDLE (*LPREVERTTOPRINTERSELF)(VOID);
typedef BOOL (*LPIMPERSONATEPRINTERCLIENT)(HANDLE);

//
// Forward and external function declarations
//

BOOL BInitOrUpgradePrinterProperties(PCOMMONINFO);
VOID DeleteFontIntallerFile(HANDLE);

PTSTR
GetBinaryFileName(
    PTSTR   ptstrDataFileName
    )
/*++

Routine Description:

    This function generates a binary file name from the data file name.

Arguments:

    ptstrDataFileName   specifies the data file name

Return Value:

    TRUE for success and FALSE for failure

Note:

--*/

{

    INT iLen;
    PTSTR   ptstrFileName, ptstrExtension;
    PTSTR   ptstrBinaryExt, ptstrFileExt;

    ptstrFileName = ptstrExtension = NULL;

#ifdef UNIDRV

    ptstrBinaryExt = BUD_FILENAME_EXT;
    ptstrFileExt = GPD_FILENAME_EXT;

#else

    ptstrBinaryExt = BPD_FILENAME_EXT;
    ptstrFileExt = PPD_FILENAME_EXT;

#endif

    iLen = _tcslen(ptstrDataFileName);

    if ((ptstrExtension = _tcsrchr(ptstrDataFileName, TEXT('.'))) == NULL ||
        _tcsicmp(ptstrExtension, ptstrFileExt) != EQUAL_STRING)
    {
        ptstrExtension = ptstrDataFileName + iLen;
        iLen += _tcslen(ptstrBinaryExt);
    }

    if (ptstrFileName = MemAlloc((iLen + 1) * sizeof(TCHAR)))
    {
        StringCchCopyW(ptstrFileName, iLen + 1, ptstrDataFileName);

        //
        // The first if-block ensures that (ptstrExtension - ptstrDataFileName) is
        // non-negative, and (iLen + 1) is greater than (ptstrExtension - ptstrDataFileName).
        //
        StringCchCopyW(ptstrFileName + (ptstrExtension - ptstrDataFileName),
                       (iLen + 1) - (ptstrExtension - ptstrDataFileName),
                       ptstrBinaryExt);
    }

    return ptstrFileName;
}

BOOL
DrvDriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam
    )
/*++

Routine Description:

    This function handles the DrvDriverEvent spooler API

Arguments:

    dwDriverEvent       specifies the event
    dwLevel             level of DRIVER_INFO_*
    pDriverInfo         pointer to DRIVER_INFO_*
    lParam              event specific parameters.

Return Value:

    TRUE for success and FALSE for failure

Note:

--*/

{
    BOOL           bResult = TRUE;

#ifndef WINNT_40

    PDRIVER_INFO_3 pDriverInfo3 = (PDRIVER_INFO_3)pDriverInfo;
    PTSTR          ptstrFileName;

    if ((dwLevel != 3) || (pDriverInfo3 == NULL) || (pDriverInfo3->pDataFile == NULL))
        return FALSE;

    switch (dwDriverEvent)
    {
    case DRIVER_EVENT_INITIALIZE:
        break;

    case DRIVER_EVENT_DELETE:

        //
        // Need to delete the binary data generated by the parsers
        //

        ptstrFileName = GetBinaryFileName(pDriverInfo3->pDataFile);

        if (ptstrFileName)
        {
            DeleteFile(ptstrFileName);
            MemFree(ptstrFileName);
        }
    }

    //
    // Call the OEM to handle DrvDriverEvent
    //

    {
        PFN_OEMDriverEvent  pfnOEMDriverEvent;
        POEM_PLUGINS        pOemPlugins;
        POEM_PLUGIN_ENTRY   pOemEntry;
        DWORD               dwOemCount;

        if (! (pOemPlugins = PGetOemPluginInfo(NULL, pDriverInfo3->pConfigFile, pDriverInfo3)) ||
            ! BLoadOEMPluginModules(pOemPlugins))
        {
            ERR(("DrvDriverEvent, Cannot load OEM plugins: %d\n", GetLastError()));
            if (pOemPlugins)
            {
                VFreeOemPluginInfo(pOemPlugins);
            }

            return FALSE;
        }

        dwOemCount = pOemPlugins->dwCount;
        pOemEntry =  pOemPlugins->aPlugins;

        //
        // call OEMDriverEvent entrypoint for each plugin
        //

        for (; dwOemCount--; pOemEntry++)
        {
            if (pOemEntry->hInstance == NULL)
                continue;

            if (HAS_COM_INTERFACE(pOemEntry))
            {
                HRESULT hr;

                hr = HComOEMDriverEvent(pOemEntry,
                                        dwDriverEvent,
                                        dwLevel,
                                        pDriverInfo,
                                        lParam);

                if (hr == E_NOTIMPL)
                    continue;

                bResult = SUCCEEDED(hr);

            }
            else
            {
                if ((pfnOEMDriverEvent = GET_OEM_ENTRYPOINT(pOemEntry, OEMDriverEvent)) &&
                    !pfnOEMDriverEvent(dwDriverEvent, dwLevel, pDriverInfo, lParam))
                {
                    ERR(("OEMDriverEvent failed for '%ws': %d\n",
                        CURRENT_OEM_MODULE_NAME(pOemEntry),
                        GetLastError()));

                    bResult = FALSE;
                }
            }
        }

        if (pOemPlugins)
            VFreeOemPluginInfo(pOemPlugins);
    }

#endif  // WINNT_40

    return bResult;
}


/*++

Routine Name:

    DrvDocumentEvent

Routine Description:

    Handle certain events associated with printing a document.

    Although our core driver doesn't do anything for any events,
    this function allows OEM plugins to add their event handling.

Arguments:

    hPrinter - printer handle
    hdc - device contect handle
    iEsc - escape code identifying the event to be handled
    cbIn - size in bytes of the array pointed to by pbIn
    pbIn - pointer to a ULONG array, whose usage depends on iEsc
    cbOut - only used as cbOutput parameter for ExtEscape
    pbOut - pointer to an output buffer, whose usage depends on iEsc

Return Value:

    DOCUMENTEVENT_FAILURE - iEsc event is supported but a failure occurred
    DOCUMENTEVENT_SUCCESS - iEsc event is handled successfully
    DOCUMENTEVENT_UNSUPPORTED - iEsc event is not supported

Last Error:

    None

--*/
INT
DrvDocumentEvent(
    HANDLE  hPrinter,
    HDC     hdc,
    int     iEsc,
    ULONG   cbIn,

    #ifdef WINNT_40
    PULONG  pbIn,
    #else
    PVOID   pbIn,
    #endif

    ULONG   cbOut,

    #ifdef WINNT_40
    PULONG  pbOut
    #else
    PVOID   pbOut
    #endif
    )
{
    POEM_PLUGINS   pOemPlugins = NULL;
    PDRIVER_INFO_3 pDriverInfo3 = NULL;
    INT            iReturn;

    if ((pDriverInfo3 = MyGetPrinterDriver(hPrinter, NULL, 3)) == NULL)
    {
       ERR(("Cannot get printer driver info: %d\n", GetLastError()));
        iReturn = DOCUMENTEVENT_FAILURE;
        goto docevent_exit;
    }

    if (!(pOemPlugins = PGetOemPluginInfo(hPrinter,
                                          pDriverInfo3->pConfigFile,
                                          pDriverInfo3)) ||
        !BLoadOEMPluginModules(pOemPlugins))
    {
        ERR(("Cannot get OEM plugin info: %d\n", GetLastError()));
        iReturn = DOCUMENTEVENT_FAILURE;
        goto docevent_exit;
    }

    if (pOemPlugins->dwCount)
    {
        POEM_PLUGIN_ENTRY pOemEntry = pOemPlugins->aPlugins;
        DWORD cOemCount = pOemPlugins->dwCount;
        INT   iResult;
        BOOL  bOEMDocEventOK = FALSE;

        for ( ; cOemCount--; pOemEntry++)
        {
            HRESULT hr;

            if (pOemEntry->hInstance == NULL ||
                !HAS_COM_INTERFACE(pOemEntry))
            {
                continue;
            }

            hr = HComOEMDocumentEvent(pOemEntry,
                                      hPrinter,
                                      hdc,
                                      iEsc,
                                      cbIn,
                                      (PVOID)pbIn,
                                      cbOut,
                                      (PVOID)pbOut,
                                      &iResult);

            if (SUCCEEDED(hr))
            {
                bOEMDocEventOK = TRUE;

                #ifndef WINNT_40

                //
                // DOCUMENTEVENT_QUERYFILTER is introduced in Whistler.
                //

                if (iEsc == DOCUMENTEVENT_QUERYFILTER)
                {
                    //
                    // At most one plugin is allowed to handle the event
                    // DOCUMENTEVENT_QUERYFILTER, and the filter it specifies
                    // will be used by spooler.
                    //
                    // For all other events, we will call every plugin so
                    // each will have the chance to perform its tasks.
                    //

                    break;
                }

                #endif // !WINNT_40
            }
        }

        if (bOEMDocEventOK)
        {
            //
            // At least one plugin handled the event successfully, so
            // use the return value specified by the plugin(s).
            //

            iReturn = iResult;
        }
        else
        {
            //
            // None of the plugins handled the event successfully.
            //

            iReturn = DOCUMENTEVENT_UNSUPPORTED;
        }
    }
    else
    {
        //
        // There is no plugin.
        //

        iReturn = DOCUMENTEVENT_UNSUPPORTED;
    }

    docevent_exit:

    if (pDriverInfo3)
    {
        MemFree(pDriverInfo3);
    }

    if (pOemPlugins)
    {
        VFreeOemPluginInfo(pOemPlugins);
    }

    //
    // If there is no plugin, or none of the plugins handles DocumentEvent
    // successfully, we return DOCUMENTEVENT_UNSUPPORTED since our driver
    // doesn't do anything for DrvDocumentEvent. When spooler sees this
    // return value for DOCUMENTEVENT_CREATEDCPRE, it will decide not to
    // make any more event calls to the driver.
    //
    // If the event is handled successfully by the plugins, we will return
    // the return value specified by the plugin(s).
    //

    return iReturn;
}


BOOL
DrvPrinterEvent(
    LPWSTR  pPrinterName,
    INT     DriverEvent,
    DWORD   Flags,
    LPARAM  lParam
    )
/*++

Routine Description:

    This function handles the DrvPrinterEvent spooler API

Arguments:

    pPrinterName        name of device
    DriverEvent         specifies the event
    Flags               bits flag
    lParam              event specific parameters.

Return Value:

    TRUE for success and FALSE for failure

Note:

--*/

{
    LPREVERTTOPRINTERSELF       pRevertToPrinterSelf;
    LPIMPERSONATEPRINTERCLIENT  pImpersonatePrinterClient;
    HINSTANCE                   hSpoolss = NULL;
    HANDLE                      hToken = NULL;
    PCOMMONINFO                 pci = NULL;
    HANDLE                      hPrinter = NULL;
    BOOL                        bResult = TRUE;
    CACHEDFILE                  CachedFile;

    VERBOSE(("Entering DrvPrinterEvent: %d ...\n", DriverEvent));

    switch (DriverEvent)
    {
    case PRINTER_EVENT_CACHE_REFRESH:

        //
        // Open a handle to the printer connection
        //

        if (! OpenPrinter(pPrinterName, &hPrinter, NULL))
        {
            ERR(("OpenPrinter '%ws' failed: %d\n", pPrinterName, GetLastError()));
            hPrinter = NULL;
            break;
        }

        //
        // Prepare to copy cached driver files from the server, if any
        //

        #ifdef PSCRIPT
        _BPrepareToCopyCachedFile(hPrinter, &CachedFile, REGVAL_NTFFILENAME);
        #else
        _BPrepareToCopyCachedFile(hPrinter, &CachedFile, REGVAL_FONTFILENAME);
        #endif

        //
        // Load spoolss.dll and get address of functions:
        //  RevertToPrinterSelf - switch to spooler's security context
        //  ImpersonatePrinterClient - switch to current user's security context
        //

        if (! (hSpoolss = LoadLibrary(TEXT("spoolss.dll"))) ||
            ! (pRevertToPrinterSelf = (LPREVERTTOPRINTERSELF)
                    GetProcAddress(hSpoolss, "RevertToPrinterSelf")) ||
            ! (pImpersonatePrinterClient = (LPIMPERSONATEPRINTERCLIENT)
                    GetProcAddress(hSpoolss, "ImpersonatePrinterClient")))
        {
            ERR(("Couldn't load spoolss.dll: %d\n", GetLastError()));

            if (hSpoolss != NULL)
                FreeLibrary(hSpoolss);

            _VDisposeCachedFileInfo(&CachedFile);

            break;
        }

        //
        // Switch to spooler security context so that we can create
        // binary printer description data file in the driver directory
        //
        // When we call to load raw printer description data, the parser
        // will check its cache. If no binary data file exists or existing
        // binary data file is out of date, the parser will regenerate
        // an up-to-date binary data file.
        //

        hToken = pRevertToPrinterSelf();
        pci = PLoadCommonInfo(hPrinter, pPrinterName, 0);


        //
        // Copy cached driver file from the server
        //

        _BCopyCachedFile(pci, &CachedFile);
        _VDisposeCachedFileInfo(&CachedFile);

        if (hToken)
        {
            if (!(bResult = pImpersonatePrinterClient(hToken)))
            {
                ERR(("PrinterEvent-ImpersonatePrinterClient failed: %d\n", GetLastError()));
            }
        }

        FreeLibrary(hSpoolss);
        break;

    case PRINTER_EVENT_INITIALIZE:

        //
        // Open a printer with administrator privilege, and
        // process OEM plugin configuration information
        //

        pci = PLoadCommonInfo(NULL, pPrinterName, FLAG_OPENPRINTER_ADMIN|FLAG_INIT_PRINTER);

        if (pci == NULL)
            break;

        //
        // Initialize default printer-sticky properties in registry
        // Add printer forms to the spooler's forms database
        //

        (VOID) BInitOrUpgradePrinterProperties(pci);

        #ifndef WINNT_40

        VNotifyDSOfUpdate(pci->hPrinter);

        #endif // !WINNT_40


        break;

    case PRINTER_EVENT_ADD_CONNECTION:

        //
        // Fix the bug where when NT5 client connects to NT4 server, the server registry
        // doesn't have the REGVAL_INIDATA entry. Calling PLoadCommonInfo with
        // FLAG_PROCESS_INIFILE will write REGVAL_INIDATA to NT4 registry.
        //

        pci = PLoadCommonInfo(NULL, pPrinterName, FLAG_OPENPRINTER_NORMAL|FLAG_PROCESS_INIFILE);
        break;

    #ifdef UNIDRV

    case PRINTER_EVENT_DELETE:
    case PRINTER_EVENT_DELETE_CONNECTION:

        //
        // Delete font installer file
        //

        //
        // Open a handle to the printer
        //

        if (! OpenPrinter(pPrinterName, &hPrinter, NULL))
        {
            ERR(("OpenPrinter '%ws' failed: %d\n", pPrinterName, GetLastError()));
            hPrinter = NULL;
            break;
        }

        pci = PLoadCommonInfo(NULL, pPrinterName, FLAG_OPENPRINTER_NORMAL);

        DeleteFontIntallerFile(hPrinter);

        break;

    #endif

    default:

        pci = PLoadCommonInfo(NULL, pPrinterName, FLAG_OPENPRINTER_NORMAL);
        break;
    }

    if (pci != NULL)
    {
        if (bResult)
        {
            PFN_OEMPrinterEvent pfnOEMPrinterEvent;

            //
            // call OEMPrinterEvent entrypoint for each plugin
            //

            FOREACH_OEMPLUGIN_LOOP(pci)

                if (HAS_COM_INTERFACE(pOemEntry))
                {
                    HRESULT hr;

                    hr = HComOEMPrinterEvent(pOemEntry,
                                            pPrinterName,
                                            DriverEvent,
                                            Flags,
                                            lParam);

                    if (hr == E_NOTIMPL)
                        continue;

                    bResult = SUCCEEDED(hr);

                }
                else
                {
                    if ((pfnOEMPrinterEvent = GET_OEM_ENTRYPOINT(pOemEntry, OEMPrinterEvent)) &&
                        !pfnOEMPrinterEvent(pPrinterName, DriverEvent, Flags, lParam))
                    {
                        ERR(("OEMPrinterEvent failed for '%ws': %d\n",
                            CURRENT_OEM_MODULE_NAME(pOemEntry),
                            GetLastError()));

                        bResult = FALSE;
                    }
                }

           END_OEMPLUGIN_LOOP
        }
        VFreeCommonInfo(pci);
    }
    else
        bResult = FALSE;

    if (hPrinter != NULL)
        ClosePrinter(hPrinter);

    return (bResult);
}


BOOL
BInitOrUpgradePrinterData(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Initialize the driver's printer-sticky property data
    or upgrade it to current version if it already exists

Arguments:

    pci - Points to basic printer info

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD   dwSize;
    BOOL    bResult = TRUE;

    //
    // If the printer property data already exists in the registry
    // and it's at least as big as the current PRINTERDATA, then
    // we assume it's ok and there is no need to upgrade it.
    //

    if (!BGetPrinterDataDWord(pci->hPrinter, REGVAL_PRINTER_DATA_SIZE, &dwSize) ||
        dwSize < sizeof(PRINTERDATA))
    {
        //
        // Otherwise, upgrade the existing printer property data in the registry
        // or save a copy of the default printer property data to registry.
        //

        bResult = BFillCommonInfoPrinterData(pci) &&
                  BSavePrinterProperties(pci->hPrinter, pci->pRawData,
                                         pci->pPrinterData, sizeof(PRINTERDATA));
    }

    return bResult;
}



BOOL
BAddOrUpgradePrinterForms(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Add printer specific forms to the spooler's forms database

Arguments:

    pci - Points to basic printer info

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PPAGESIZE       pPageSize;
    FORM_INFO_1     FormInfo1;
    DWORD           dwIndex, dwChecksum32, dwForm;
    PFEATURE        pFeature;
    WCHAR           awchBuf[CCHPAPERNAME];

    //
    // If forms has already been added and printer description
    // data hasn't changed, we don't need to do anything
    //

    if (BGetPrinterDataDWord(pci->hPrinter, REGVAL_FORMS_ADDED, &dwChecksum32) &&
        dwChecksum32 == pci->pRawData->dwChecksum32)
    {
        return TRUE;
    }

    if (pci->pSplForms == NULL)
        pci->pSplForms = MyEnumForms(pci->hPrinter, 1, &pci->dwSplForms);

    //
    //  Get pointer to PageSize feature
    //

    if ((pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGESIZE)) == NULL)
    {
        WARNING(("No paper size supported\n"));
        return FALSE;
    }

    ZeroMemory(&FormInfo1, sizeof(FormInfo1));
    FormInfo1.Flags = FORM_PRINTER;
    FormInfo1.pName = awchBuf;

    //
    // Go through each printer form
    //

    for (dwIndex=0; dwIndex < pFeature->Options.dwCount; dwIndex++)
    {
        pPageSize = PGetIndexedOption(pci->pUIInfo, pFeature, dwIndex);
        ASSERT(pPageSize != NULL);

        //
        // Ignore the custom page size option
        //

        if (pPageSize->dwPaperSizeID == DMPAPER_USER ||
            pPageSize->dwPaperSizeID == DMPAPER_CUSTOMSIZE)
        {
            continue;
        }

        if (pPageSize->szPaperSize.cx <= 0 ||
            pPageSize->szPaperSize.cy <= 0)
        {
            ERR(("Paper size is too small\n"));
            continue;
        }

        if (! LOAD_STRING_PAGESIZE_NAME(pci, pPageSize, awchBuf, CCHPAPERNAME))
        {
            ERR(("Cannot get paper name\n"));
            continue;
        }

        //
        // Check if the paper name is already in the forms database.
        // If it's already in the database as a
        //

        for (dwForm=0; dwForm < pci->dwSplForms; dwForm++)
        {
            if (pci->pSplForms[dwForm].Flags == FORM_USER &&
                wcscmp(pci->pSplForms[dwForm].pName, awchBuf) == EQUAL_STRING)
            {
                VERBOSE(("Delete user/driver rdefined form: %ws\n", awchBuf));
                DeleteForm(pci->hPrinter, awchBuf);
            }
        }

        //
        // Page size:
        //  remember that FORM_INFO_1 uses micron units while
        //  PAGESIZE.szPaperSize are in Master units.
        //

        FormInfo1.Size.cx = MASTER_UNIT_TO_MICRON(pPageSize->szPaperSize.cx,
                                                  pci->pUIInfo->ptMasterUnits.x);

        FormInfo1.Size.cy = MASTER_UNIT_TO_MICRON(pPageSize->szPaperSize.cy,
                                                  pci->pUIInfo->ptMasterUnits.y);

        //
        // Imageable area:
        //  for driver-defined forms, all margins should be set to 0.
        //

        FormInfo1.ImageableArea.left =
        FormInfo1.ImageableArea.top = 0;
        FormInfo1.ImageableArea.right = FormInfo1.Size.cx;
        FormInfo1.ImageableArea.bottom = FormInfo1.Size.cy;

        //
        // We'll try to add the form first. If that fails,
        // we assume the form is already there and try to
        // update the form with the new info.
        //

        (VOID) AddForm(pci->hPrinter, 1, (PBYTE) &FormInfo1);
    }

    (VOID) BSetPrinterDataDWord(pci->hPrinter,
                                REGVAL_FORMS_ADDED,
                                pci->pRawData->dwChecksum32);

    return TRUE;
}



BOOL
BInitOrUpgradePrinterProperties(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Initialize or upgrade printer property information in the registry

Arguments:

    pci - Points to basic printer info

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    BOOL    bResult;

    //
    // Handle PRINTERDATA structure in registry
    //

    bResult = BInitOrUpgradePrinterData(pci);

    //
    // Handle driver-defined forms in the spooler's database
    //

    if (! BAddOrUpgradePrinterForms(pci))
        bResult = FALSE;

    #ifdef PSCRIPT

    //
    // pscript specific initializations
    //

    // Save model-specific NTF filename in registry for NT4 compatibility

    if (! BUpdateModelNtfFilename(pci))
        bResult = FALSE;

    #ifdef WINNT_40

    // Also save the current user locale too.

    if (! BUpdateVMErrorMessageID(pci))
        bResult = FALSE;

    #endif // WINNT_40

    #endif // PSCRIPT

    return bResult;
}



PWSTR
PGetFileDirectory(
    PWSTR   pServerName
    )

/*++

Routine Description:

    Get the name of the directory used by the font downloader
    to store NTF information about downloaded fonts

Arguments:

    pServerName - Name of the print server

Return Value:

    Pointer to the directory used for storing NTF information
    about downloaded fonts, NULL if there is an error

--*/

{
    PWSTR           p = NULL, pDir = NULL;
    DWORD           cbNeeded = 0, cbSize = 0;
    static WCHAR    wszDir[] = FONTDIR;

    //
    // Get the printer driver directory path
    //

    if (GetPrinterDriverDirectory(pServerName, NULL, 1, NULL, 0, &cbNeeded) ||
        GetLastError() != ERROR_INSUFFICIENT_BUFFER ||
        (pDir = MemAlloc(cbSize = (cbNeeded + sizeof(wszDir)))) == NULL ||
        !GetPrinterDriverDirectory(pServerName, NULL, 1, (PBYTE) pDir, cbNeeded, &cbNeeded))
    {
        ERR(("GetPrinterDriverDirectory failed: %d\n", GetLastError()));
        MemFree(pDir);
        return NULL;
    }

    //
    // Replace the last component of the directory path (which should be w32...)
    // with \psfont\
    //

    if (p = wcsrchr(pDir, TEXT(PATH_SEPARATOR)))
        StringCchCopyW(p, cbSize / sizeof(WCHAR) - (p - pDir),  wszDir);
    else
    {
        WARNING(("Driver directory is not fully-qualified: %ws\n", pDir));
        StringCchCatW(pDir, cbSize / sizeof(WCHAR), wszDir);
    }

    return pDir;
}



PWSTR
PConcatFilename(
    PWSTR   pDir,
    PWSTR   pFilename
    )

{
    PWSTR   pBasename;
    DWORD   cbSize = 0;

    //
    // Strip any directory prefix from the input filename
    //

    if (pBasename = wcsrchr(pFilename, TEXT(PATH_SEPARATOR)))
        pBasename++;
    else
        pBasename = pFilename;

    //
    // Concatenate the input directory with the base filename
    //

    if (!(pFilename = MemAlloc(cbSize = (SIZE_OF_STRING(pDir) + SIZE_OF_STRING(pBasename)))))
    {
        ERR(("Memory allocation failed\n"));
        return NULL;
    }

    StringCchCopyW(pFilename, cbSize / sizeof(WCHAR), pDir);
    StringCchCatW(pFilename, cbSize / sizeof(WCHAR), pBasename);

    return pFilename;
}



BOOL
_BPrepareToCopyCachedFile(
    HANDLE      hPrinter,
    PCACHEDFILE pCachedFile,
    PWSTR       pRegKey
    )

/*++

Routine Description:

    Prepare to copy files from the server during a printer-connection
    cache refresh event

Arguments:

    hPrinter - Handle to the printer connection
    pCachedFile - Buffer to store information about cached file

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    We assume this function is called from within the spooler process
    and with current user's security context. Specifically, we must
    be able to access the server's print$ share at this point.

--*/

{
    PPRINTER_INFO_2 pPrinterInfo2 = NULL;
    PWSTR           pRemoteFilename;
    DWORD           dwSize;

    ZeroMemory(pCachedFile, sizeof(CACHEDFILE));
    pCachedFile->hRemoteFile = INVALID_HANDLE_VALUE;

    //
    // Find out the name of the file to copy
    //
#if !defined(PSCRIPT)
    pCachedFile->pFilename = PtstrGetPrinterDataString(hPrinter, pRegKey, &dwSize);
#else
    return TRUE;
#endif

    if (pCachedFile->pFilename == NULL || *pCachedFile->pFilename == NUL)
        return TRUE;

    //
    // Get the remote NTF filename on the server
    //
    // NOTE: We're really like to use level 4 here. But due to bug in the
    // spooler, GetPrinter level 4 doesn't work for printer connections.
    //

    if (! (pPrinterInfo2 = MyGetPrinter(hPrinter, 2)) ||
        ! pPrinterInfo2->pServerName ||
        ! (pCachedFile->pRemoteDir = PGetFileDirectory(pPrinterInfo2->pServerName)) ||
        ! (pCachedFile->pLocalDir = PGetFileDirectory(NULL)) ||
        ! (pRemoteFilename = PConcatFilename(pCachedFile->pRemoteDir, pCachedFile->pFilename)))
    {
        goto exit_prepare_copyfile;
    }

    pCachedFile->hRemoteFile = CreateFile(pRemoteFilename,
                                          GENERIC_READ,
                                          FILE_SHARE_READ,
                                          NULL,
                                          OPEN_EXISTING,
                                          FILE_FLAG_SEQUENTIAL_SCAN | SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS,
                                          NULL);

    MemFree(pRemoteFilename);

exit_prepare_copyfile:

    MemFree(pPrinterInfo2);

    if (pCachedFile->hRemoteFile == INVALID_HANDLE_VALUE)
    {
        ERR(("Couldn't open remote NTF/FontInfo file: %d\n", GetLastError()));
        _VDisposeCachedFileInfo(pCachedFile);
    }

    return (pCachedFile->hRemoteFile != INVALID_HANDLE_VALUE);
}



BOOL
_BCopyCachedFile(
    PCOMMONINFO pci,
    PCACHEDFILE pCachedFile
    )

/*++

Routine Description:

    Copy files from the server during printer-connection cache refresh event

Arguments:

    pci - Points to basic printer information
    pCachedFile - Points to information about cached file

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    We assume this function is called from within the spooler process
    and with system's security context. Specifically, we must
    be able to write into local machines' printer driver directory.

--*/

#define BUFFER_SIZE  4096

{
    HANDLE  hLocalFile;
    PWSTR   pLocalFilename = NULL;
    PVOID   pBuffer = NULL;
    BOOL    bResult = FALSE;
    DWORD   dwCount;

    //
    // We don't have any file to copy
    //

    if (pCachedFile->hRemoteFile == INVALID_HANDLE_VALUE)
        return TRUE;

    //
    // Get the name for the local copy of the NTF file
    // and allocate temporary buffer
    //

    ASSERT(BUFFER_SIZE >= MAX_PATH * sizeof(WCHAR));

    if (! (pLocalFilename = PConcatFilename(pCachedFile->pLocalDir, pCachedFile->pFilename)) ||
        ! (pBuffer = MemAlloc(BUFFER_SIZE)))
    {
        goto exit_copyfile;
    }

    // Make sure the local directory is created

    (VOID) CreateDirectory(pCachedFile->pLocalDir, NULL);

    for (dwCount=0; dwCount < 2; dwCount++)
    {
        hLocalFile = CreateFile(pLocalFilename,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_FLAG_SEQUENTIAL_SCAN | SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS,
                                NULL);

        if (hLocalFile != INVALID_HANDLE_VALUE)
            break;

        if (dwCount == 0)
        {
            //
            // If this is our first try, then attempt to move
            // the existing file to a temporary file and set
            // it to be delete-on-reboot.
            //

            #ifdef PSCRIPT
            if (! GetTempFileName(pCachedFile->pLocalDir, L"NTF", 0, pBuffer) ||
            #else
            if (! GetTempFileName(pCachedFile->pLocalDir, L"FON", 0, pBuffer) ||
            #endif
                ! MoveFileEx(pLocalFilename, pBuffer, MOVEFILE_REPLACE_EXISTING) ||
                ! MoveFileEx(pBuffer, NULL, MOVEFILE_DELAY_UNTIL_REBOOT))
            {
                break;
            }
        }
    }

    if (hLocalFile != INVALID_HANDLE_VALUE)
    {
        while (ReadFile(pCachedFile->hRemoteFile, pBuffer, BUFFER_SIZE, &dwCount, NULL))
        {
            //
            // Have we reached end-of-file?
            //

            if (dwCount == 0)
            {
                bResult = TRUE;
                break;
            }

            if (! WriteFile(hLocalFile, pBuffer, dwCount, &dwCount, NULL))
                break;
        }

        CloseHandle(hLocalFile);

        //
        // If file copying failed, be sure to delete the temporary file
        //

        if (! bResult)
            DeleteFile(pLocalFilename);
    }

exit_copyfile:

    MemFree(pLocalFilename);
    MemFree(pBuffer);

    if (! bResult)
        ERR(("Couldn't copy remote NTF/FontInfo file: %d\n", GetLastError()));

    return bResult;
}



VOID
_VDisposeCachedFileInfo(
    PCACHEDFILE pCachedFile
    )

/*++

Routine Description:

    Clean up after copying files from the server
    during printer-connection cache refresh

Arguments:

    pCachedFile - Points to information about cached file

Return Value:

    NONE

--*/

{
    if (pCachedFile->hRemoteFile != INVALID_HANDLE_VALUE)
        CloseHandle(pCachedFile->hRemoteFile);

    MemFree(pCachedFile->pFilename);
    MemFree(pCachedFile->pRemoteDir);
    MemFree(pCachedFile->pLocalDir);

    ZeroMemory(pCachedFile, sizeof(CACHEDFILE));
    pCachedFile->hRemoteFile = INVALID_HANDLE_VALUE;
}




#ifdef UNIDRV

VOID
DeleteFontIntallerFile(
    HANDLE hPrinter
    )

/*++

Routine Description:

    Delete font installer file when printer is deleted

Arguments:

    hPrinter - Handle to printer

Return Value:

    NONE

--*/

{
    PWSTR pFilename = NULL;
    PWSTR pLocalDir = NULL;
    PWSTR pLocalFilename = NULL;

    pFilename = PtstrGetPrinterDataString(hPrinter, REGVAL_FONTFILENAME, NULL);

    if (!pFilename)
        return;

    if (!*pFilename)
        goto exit_deletefile;

    if (!(pLocalDir = PGetFileDirectory(NULL)))
        goto exit_deletefile;

    if (!(pLocalFilename = PConcatFilename(pLocalDir, pFilename)))
        goto exit_deletefile;

    DeleteFile(pLocalFilename);

exit_deletefile:

    MemFree(pFilename);
    MemFree(pLocalDir);
    MemFree(pLocalFilename);

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\oemui.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oemui.c

Abstract:

    Support for OEM plugin UI modules

Environment:

        Windows NT printer driver

Revision History:

        02/13/97 -davidx-
                Created it.

--*/

#include "precomp.h"

//
// User mode helper functions for OEM plugins
//

const OEMUIPROCS OemUIHelperFuncs = {
    (PFN_DrvGetDriverSetting) BGetDriverSettingForOEM,
    (PFN_DrvUpdateUISetting)  BUpdateUISettingForOEM,
};



BOOL
BPackOemPluginItems(
    PUIDATA pUiData
    )

/*++

Routine Description:

    Call OEM plugin UI modules to let them add their OPTITEMs

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PCOMMONINFO         pci;
    PFN_OEMCommonUIProp pfnOEMCommonUIProp;
    POEMCUIPPARAM       pOemCUIPParam;
    POPTITEM            pOptItem;
    DWORD               dwOptItem;

    //
    // Check if we're being called for the first time.
    // We assume all OEM plugin items are always packed at the end.
    //

    if (pUiData->pOptItem == NULL)
        pUiData->dwDrvOptItem = pUiData->dwOptItem;
    else if (pUiData->dwDrvOptItem != pUiData->dwOptItem)
    {
        RIP(("Inconsistent OPTITEM count for driver items\n"));
        return FALSE;
    }

    //
    // Quick exit for no OEM plugin case
    //

    pci = (PCOMMONINFO) pUiData;

    if (pci->pOemPlugins->dwCount == 0)
        return TRUE;

    pOptItem = pUiData->pOptItem;

    FOREACH_OEMPLUGIN_LOOP(pci)

        if (!HAS_COM_INTERFACE(pOemEntry) &&
            !(pfnOEMCommonUIProp = GET_OEM_ENTRYPOINT(pOemEntry, OEMCommonUIProp)))
                continue;

        //
        // Compose the input parameter for calling OEMCommonUI
        //

        pOemCUIPParam = pOemEntry->pParam;

        if (pOemCUIPParam == NULL)
        {
            //
            // Allocate memory for an OEMUI_PARAM structure
            // during the first pass
            //

            if (pOptItem != NULL)
                continue;

            if (! (pOemCUIPParam = HEAPALLOC(pci->hHeap, sizeof(OEMCUIPPARAM))))
            {
                ERR(("Memory allocation failed\n"));
                return FALSE;
            }

            pOemEntry->pParam = pOemCUIPParam;
            pOemCUIPParam->cbSize = sizeof(OEMCUIPPARAM);
            pOemCUIPParam->poemuiobj = pci->pOemPlugins->pdriverobj;
            pOemCUIPParam->hPrinter = pci->hPrinter;
            pOemCUIPParam->pPrinterName = pci->pPrinterName;
            pOemCUIPParam->hModule = pOemEntry->hInstance;
            pOemCUIPParam->hOEMHeap = pci->hHeap;
            pOemCUIPParam->pPublicDM = pci->pdm;
            pOemCUIPParam->pOEMDM = pOemEntry->pOEMDM;
        }

        pOemCUIPParam->pDrvOptItems = pUiData->pDrvOptItem;
        pOemCUIPParam->cDrvOptItems = pUiData->dwDrvOptItem;
        pOemCUIPParam->pOEMOptItems = pOptItem;
        dwOptItem = pOemCUIPParam->cOEMOptItems;

        //
        // Actually call OEMCommonUI entrypoint
        //

        if (HAS_COM_INTERFACE(pOemEntry))
        {
            HRESULT hr;

            hr = HComOEMCommonUIProp(
                    pOemEntry,
                    (pUiData->iMode == MODE_DOCUMENT_STICKY) ? OEMCUIP_DOCPROP : OEMCUIP_PRNPROP,
                    pOemCUIPParam);

            if (hr == E_NOTIMPL)
            {
                HeapFree(pci->hHeap, 0, pOemCUIPParam);
                pOemEntry->pParam = NULL;
                continue;
            }

            if (FAILED(hr))
            {
                ERR(("OEMCommonUI failed for '%ws': %d\n",
                    CURRENT_OEM_MODULE_NAME(pOemEntry),
                    GetLastError()));

                //
                // OEM failure during the first pass is recoverable:
                // we'll simply ignore OEM plugin items
                //

                if (pOptItem == NULL)
                {
                    HeapFree(pci->hHeap, 0, pOemCUIPParam);
                    pOemEntry->pParam = NULL;
                    continue;
                }
                return FALSE;
            }
        }
        else
        {
            if (!pfnOEMCommonUIProp(
                    (pUiData->iMode == MODE_DOCUMENT_STICKY) ? OEMCUIP_DOCPROP : OEMCUIP_PRNPROP,
                    pOemCUIPParam))
            {
                ERR(("OEMCommonUI failed for '%ws': %d\n",
                    CURRENT_OEM_MODULE_NAME(pOemEntry),
                    GetLastError()));
    #if 0
                (VOID) IDisplayErrorMessageBox(
                                NULL,
                                0,
                                IDS_OEMERR_DLGTITLE,
                                IDS_OEMERR_OPTITEM,
                                CURRENT_OEM_MODULE_NAME(pOemEntry));
    #endif
                //
                // OEM failure during the first pass is recoverable:
                // we'll simply ignore OEM plugin items
                //

                if (pOptItem == NULL)
                {
                    HeapFree(pci->hHeap, 0, pOemCUIPParam);
                    pOemEntry->pParam = NULL;
                    continue;
                }

                return FALSE;
            }
        }

        if (pOptItem != NULL)
        {
            //
            // second pass - ensure the number of items is consistent
            //

            if (dwOptItem != pOemCUIPParam->cOEMOptItems)
            {
                RIP(("Inconsistent OPTITEM count reported by OEM plugin: %ws\n",
                     CURRENT_OEM_MODULE_NAME(pOemEntry),
                     GetLastError()));

                return FALSE;
            }

            pOptItem += pOemCUIPParam->cOEMOptItems;
            pUiData->pOptItem += pOemCUIPParam->cOEMOptItems;
        }

        pUiData->dwOptItem += pOemCUIPParam->cOEMOptItems;

    END_OEMPLUGIN_LOOP

    return TRUE;
}



LONG
LInvokeOemPluginCallbacks(
    PUIDATA         pUiData,
    PCPSUICBPARAM   pCallbackParam,
    LONG            lRet
    )

/*++

Routine Description:

    Call OEM plugin module's callback function

Arguments:

    pUiData - Points to UIDATA structure
    pCallbackParam - Points to callback parameter from compstui
    lRet - Return value after the driver has processed the callback

Return Value:

    Return value for compstui

--*/

{
    PCOMMONINFO     pci = (PCOMMONINFO) pUiData;
    POEMCUIPPARAM   pOemCUIPParam;
    LONG            lNewResult;

    //
    // Quick exit for no OEM plugin case
    //

    if (pci->pOemPlugins->dwCount == 0)
        return lRet;

    //
    // Go through each OEM plugin UI module
    //

    FOREACH_OEMPLUGIN_LOOP(pci)

        //
        // Stop when anyone says don't exit
        //

        if (lRet == CPSUICB_ACTION_NO_APPLY_EXIT)
        {
            ASSERT(pCallbackParam->Reason == CPSUICB_REASON_APPLYNOW);
            break;
        }

        //
        // Get the address of OEM callback function and call it
        //

        pOemCUIPParam = pOemEntry->pParam;

        if (pOemCUIPParam == NULL || pOemCUIPParam->OEMCUIPCallback == NULL)
            continue;

        lNewResult = pOemCUIPParam->OEMCUIPCallback(pCallbackParam, pOemCUIPParam);

        //
        // Merge the new result with the existing result
        //

        switch (lNewResult)
        {
        case CPSUICB_ACTION_ITEMS_APPLIED:
        case CPSUICB_ACTION_NO_APPLY_EXIT:

            ASSERT(pCallbackParam->Reason == CPSUICB_REASON_APPLYNOW);
            lRet = lNewResult;
            break;

        case CPSUICB_ACTION_REINIT_ITEMS:

            ASSERT(pCallbackParam->Reason != CPSUICB_REASON_APPLYNOW);
            lRet = lNewResult;
            break;

        case CPSUICB_ACTION_OPTIF_CHANGED:

            ASSERT(pCallbackParam->Reason != CPSUICB_REASON_APPLYNOW);
            if (lRet == CPSUICB_ACTION_NONE)
                lRet = lNewResult;
            break;

        case CPSUICB_ACTION_NONE:
            break;

        default:

            RIP(("Invalid return value from OEM callback: '%ws'\n",
                 CURRENT_OEM_MODULE_NAME(pOemEntry),
                 GetLastError()));
            break;
        }

    END_OEMPLUGIN_LOOP

    return lRet;
}


LRESULT
OEMDocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )
{
    HRESULT hr;

    POEM_PLUGIN_ENTRY pOemEntry;

    pOemEntry = ((POEMUIPSPARAM)(pPSUIInfo->lParamInit))->pOemEntry;

    hr = HComOEMDocumentPropertySheets(pOemEntry,
                                       pPSUIInfo,
                                       lParam);

    if (SUCCEEDED(hr))
        return 1;

    return -1;
}

LRESULT
OEMDevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )
{
    HRESULT hr;

    POEM_PLUGIN_ENTRY pOemEntry;

    pOemEntry = ((POEMUIPSPARAM)(pPSUIInfo->lParamInit))->pOemEntry;

    hr = HComOEMDevicePropertySheets(pOemEntry,
                                     pPSUIInfo,
                                     lParam);

    if (SUCCEEDED(hr))
        return 1;

    return -1;
}


BOOL
BAddOemPluginPages(
    PUIDATA pUiData,
    DWORD   dwFlags
    )

/*++

Routine Description:

    Call OEM plugin UI modules to let them add their own property sheet pages

Arguments:

    pUiData - Points to UIDATA structure
    dwFlags - Flags from DOCUMENTPROPERTYHEADER or DEVICEPROPERTYHEADER

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PCOMMONINFO     pci = (PCOMMONINFO) pUiData;
    FARPROC         pfnOEMPropertySheets;
    POEMUIPSPARAM   pOemUIPSParam;

    //
    // Quick exit for no OEM plugin case
    //

    if (pci->pOemPlugins->dwCount == 0)
        return TRUE;

    //
    // Add the property sheet for each OEM plugin UI module
    //

    FOREACH_OEMPLUGIN_LOOP(pci)

        //
        // get the address of appropriate OEM entrypoint
        //


        if (HAS_COM_INTERFACE(pOemEntry))
        {
            if (pUiData->iMode == MODE_DOCUMENT_STICKY)
                pfnOEMPropertySheets = (FARPROC)OEMDocumentPropertySheets;
            else
                pfnOEMPropertySheets = (FARPROC)OEMDevicePropertySheets;
        }
        else
        {
            if (pUiData->iMode == MODE_DOCUMENT_STICKY)
            {
                pfnOEMPropertySheets = (FARPROC)
                    GET_OEM_ENTRYPOINT(pOemEntry, OEMDocumentPropertySheets);
            }
            else
            {
                pfnOEMPropertySheets = (FARPROC)
                    GET_OEM_ENTRYPOINT(pOemEntry, OEMDevicePropertySheets);
            }

            if (pfnOEMPropertySheets == NULL)
                continue;
        }

        //
        // Collect input parameters to be passed to OEM plugin
        //

        if ((pOemUIPSParam = HEAPALLOC(pci->hHeap, sizeof(OEMUIPSPARAM))) == NULL)
        {
            ERR(("Memory allocation failed\n"));
            return FALSE;
        }

        pOemUIPSParam->cbSize = sizeof(OEMUIPSPARAM);
        pOemUIPSParam->poemuiobj = pci->pOemPlugins->pdriverobj;
        pOemUIPSParam->hPrinter = pci->hPrinter;
        pOemUIPSParam->pPrinterName = pci->pPrinterName;
        pOemUIPSParam->hModule = pOemEntry->hInstance;
        pOemUIPSParam->hOEMHeap = pci->hHeap;
        pOemUIPSParam->pPublicDM = pci->pdm;
        pOemUIPSParam->pOEMDM = pOemEntry->pOEMDM;
        pOemUIPSParam->dwFlags = dwFlags;
        pOemUIPSParam->pOemEntry = pOemEntry;

        //
        // call compstui to add the OEM plugin property sheets
        //

        if (pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                     CPSFUNC_ADD_PFNPROPSHEETUI,
                                     (LPARAM) pfnOEMPropertySheets,
                                     (LPARAM) pOemUIPSParam) <= 0)
        {
            VERBOSE(("Couldn't add property sheet pages for '%ws'\n",
                     CURRENT_OEM_MODULE_NAME(pOemEntry),
                     GetLastError()));
        }

    END_OEMPLUGIN_LOOP

    return TRUE;
}



BOOL
APIENTRY
BGetDriverSettingForOEM(
    PCOMMONINFO pci,
    PCSTR       pFeatureKeyword,
    PVOID       pOutput,
    DWORD       cbSize,
    PDWORD      pcbNeeded,
    PDWORD      pdwOptionsReturned
    )

/*++

Routine Description:

    Provide OEM plugins access to driver private settings

Arguments:

    pci - Points to basic printer information
    pFeatureKeyword - Specifies the keyword the caller is interested in
    pOutput - Points to output buffer
    cbSize - Size of output buffer
    pcbNeeded - Returns the expected size of output buffer
    pdwOptionsReturned - Returns the number of options selected

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    ULONG_PTR dwIndex;
    BOOL      bResult;

    ASSERT(pci->pvStartSign == pci);

    if ((pci == NULL) || (pci->pvStartSign != pci))
    {
        WARNING(("BGetDriverSettingForOEM: invalid pci"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // This is not very portable: If the pointer value for pFeatureKeyword
    // is less than 0x10000, we assume that the pointer value actually
    // specifies a predefined index.
    //

    //
    // Following ASSERT is removed for Win64
    //
    // ASSERT(sizeof(pFeatureKeyword) == sizeof(DWORD));
    //

    dwIndex = (ULONG_PTR)pFeatureKeyword;

    if (dwIndex >= OEMGDS_MIN_DOCSTICKY && dwIndex < OEMGDS_MIN_PRINTERSTICKY)
    {
        if (pci->pdm == NULL)
            goto setting_not_available;

        bResult = BGetDevmodeSettingForOEM(
                        pci->pdm,
                        (DWORD)dwIndex,
                        pOutput,
                        cbSize,
                        pcbNeeded);

        if (bResult)
            *pdwOptionsReturned = 1;
    }
    else if (dwIndex >= OEMGDS_MIN_PRINTERSTICKY && dwIndex < OEMGDS_MAX)
    {
        if (pci->pPrinterData == NULL)
            goto setting_not_available;

        bResult = BGetPrinterDataSettingForOEM(
                        pci->pPrinterData,
                        (DWORD)dwIndex,
                        pOutput,
                        cbSize,
                        pcbNeeded);

        if (bResult)
            *pdwOptionsReturned = 1;
    }
    else
    {
        if (pci->pCombinedOptions == NULL)
            goto setting_not_available;

        bResult = BGetGenericOptionSettingForOEM(
                        pci->pUIInfo,
                        pci->pCombinedOptions,
                        pFeatureKeyword,
                        pOutput,
                        cbSize,
                        pcbNeeded,
                        pdwOptionsReturned);
    }

    return bResult;

setting_not_available:

    WARNING(("Requested driver setting not available: %d\n", pFeatureKeyword));
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}


BOOL
BUpdateUISettingForOEM(
    PCOMMONINFO pci,
    PVOID       pOptItem,
    DWORD       dwPreviousSelection,
    DWORD       dwMode
    )

/*++

Routine Description:

    Update the UI settings in optionsarray for OEM.

Arguments:

    pci - Points to basic printer information
    pOptItem - Points to the current OPTITEM

Return Value:

    TRUE if successful, FALSE if there is an error such as conflict and
    user wants to cancel.

--*/

{
    POPTITEM    pCurItem = pOptItem;
    PUIDATA     pUiData = (PUIDATA)pci;

    ASSERT(pci->pvStartSign == pci);

    if ((pci == NULL) || (pci->pvStartSign != pci))
    {
        WARNING(("BUpdateUISettingForOEM: invalid pci"));
        return FALSE;
    }

    if (ICheckConstraintsDlg(pUiData, pCurItem, 1, FALSE) == CONFLICT_CANCEL)
    {
        //
        // If there is a conflict and the user clicked
        // CANCEL to restore the original selection.
        // CONFLICT_CANCEL, restore the old setting
        //

        return FALSE;
    }

    if (dwMode == OEMCUIP_DOCPROP)
    {
        //
        // We use FLAG_WITHIN_PLUGINCALL to indicate we are within the UI helper
        // function call issued by OEM plugin. This is needed to fix bug #90923.
        //

        pUiData->ci.dwFlags |= FLAG_WITHIN_PLUGINCALL;
        VUnpackDocumentPropertiesItems(pUiData, pCurItem, 1);
        pUiData->ci.dwFlags &= ~FLAG_WITHIN_PLUGINCALL;

        VPropShowConstraints(pUiData, MODE_DOCANDPRINTER_STICKY);
    }
    else
    {
        VUpdateOptionsArrayWithSelection(pUiData, pCurItem);
        VPropShowConstraints(pUiData, MODE_PRINTER_STICKY);
    }

    //
    // Record the fact that one of our OPTITEM selection has been changed by plugin's
    // call of helper function DrvUpdateUISetting. This is necessary so that at the
    // APPLYNOW time we know constraints could exist even though user hasn't touched
    // any of our OPTITEMs.
    //

    pUiData->ci.dwFlags |= FLAG_PLUGIN_CHANGED_OPTITEM;

    return TRUE;
}

BOOL
BUpgradeRegistrySettingForOEM(
    HANDLE      hPrinter,
    PCSTR       pFeatureKeyword,
    PCSTR       pOptionKeyword
    )

/*++

Routine Description:

    Set the Feature.Option request to our options array. OEM will only
    call this function at OEMUpgradeDriver to upgrade their registry setttings
    into our optionsarray saved in our PRINTERDATA

Arguments:

    hPrinter - Handle of the Printer
    pFeatureKeyword - Specifies the keyword the caller is interested in
    pOptionKeyword - Specifies the keyword the caller is interested in

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{

    PFEATURE    pFeature;
    POPTION     pOption;
    DWORD       dwFeatureCount, i, j;
    BOOL        bFeatureFound, bOptionFound, bResult = FALSE;
    PCSTR       pKeywordName;
    POPTSELECT      pOptionsArray = NULL;
    PDRIVER_INFO_3  pDriverInfo3 = NULL;
    PRAWBINARYDATA  pRawData = NULL;
    PINFOHEADER     pInfoHeader = NULL;
    PUIINFO         pUIInfo = NULL;
    PPRINTERDATA    pPrinterData = NULL;
    OPTSELECT       DocOptions[MAX_PRINTER_OPTIONS];

    //
    // Get information about the printer driver
    //

    bResult = bFeatureFound = bOptionFound = FALSE;

    if ((pDriverInfo3 = MyGetPrinterDriver(hPrinter, NULL, 3)) == NULL)
    {
        ERR(("Cannot get printer driver info: %d\n", GetLastError()));
        goto upgrade_registry_exit;
    }

//    ENTER_CRITICAL_SECTION();

    pRawData = LoadRawBinaryData(pDriverInfo3->pDataFile);

//    LEAVE_CRITICAL_SECTION();

    if (pRawData == NULL)
        goto upgrade_registry_exit;

    if (!(pPrinterData = MemAllocZ(sizeof(PRINTERDATA)))  ||
        !( BGetPrinterProperties(hPrinter, pRawData, pPrinterData)))
    {

        ERR(("Cannot get printer data info: %d\n", GetLastError()));
        goto upgrade_registry_exit;
    }

    //
    // Allocate memory for combined optionsarray
    //

    if (!(pOptionsArray = MemAllocZ(MAX_COMBINED_OPTIONS * sizeof (OPTSELECT))))
        goto upgrade_registry_exit;

    if (! InitDefaultOptions(pRawData,
                             DocOptions,
                             MAX_PRINTER_OPTIONS,
                             MODE_DOCUMENT_STICKY))
    {
        goto upgrade_registry_exit;
    }

    //
    // Combine doc sticky options with printer sticky items
    //

    CombineOptionArray(pRawData, pOptionsArray, MAX_COMBINED_OPTIONS, DocOptions, pPrinterData->aOptions);

    //
    // Get an updated instance of printer description data
    //

    pInfoHeader = InitBinaryData(pRawData,
                                 NULL,
                                 pOptionsArray);

    if (pInfoHeader == NULL)
    {
        ERR(("InitBinaryData failed\n"));
        goto upgrade_registry_exit;
    }

    if (!(pUIInfo = OFFSET_TO_POINTER(pInfoHeader, pInfoHeader->loUIInfoOffset)))
        goto upgrade_registry_exit;

    //
    // Look for feature.option index
    //

    pFeature = PGetIndexedFeature(pUIInfo, 0);
    dwFeatureCount = pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures;

    if (pFeature && dwFeatureCount)
    {
        for (i = 0; i < dwFeatureCount; i++)
        {
            pKeywordName = OFFSET_TO_POINTER(pUIInfo->pubResourceData, pFeature->loKeywordName);
            if (strcmp(pKeywordName, pFeatureKeyword) == EQUAL_STRING)
            {
                bFeatureFound = TRUE;
                break;
            }
            pFeature++;
        }
    }

    if (bFeatureFound)
    {
        pOption = PGetIndexedOption(pUIInfo, pFeature, 0);

        for (j = 0; j < pFeature->Options.dwCount; j++)
        {
            pKeywordName = OFFSET_TO_POINTER(pUIInfo->pubResourceData, pOption->loKeywordName);
            if (strcmp(pKeywordName, pOptionKeyword) == EQUAL_STRING)
            {
                bOptionFound = TRUE;
                break;
            }
            pOption++;
        }
    }

    if (bFeatureFound && bOptionFound)
    {
        pOptionsArray[i].ubCurOptIndex = (BYTE)j;

        //
        // Resolve conflicts
        //

        if (!ResolveUIConflicts( pRawData,
                                 pOptionsArray,
                                 MAX_COMBINED_OPTIONS,
                                 MODE_DOCANDPRINTER_STICKY))
        {
            VERBOSE(("Resolved conflicting printer feature selections.\n"));
        }


        SeparateOptionArray(pRawData,
                            pOptionsArray,
                            pPrinterData->aOptions,
                            MAX_PRINTER_OPTIONS,
                            MODE_PRINTER_STICKY
                           );

        if (!BSavePrinterProperties(hPrinter, pRawData, pPrinterData, sizeof(PRINTERDATA)))
        {
            ERR(("BSavePrinterProperties failed\n"));
            bResult = FALSE;
        }
        else
            bResult = TRUE;
    }

upgrade_registry_exit:

    if (pInfoHeader)
        FreeBinaryData(pInfoHeader);

    if (pRawData)
        UnloadRawBinaryData(pRawData);

    if (pPrinterData)
        MemFree(pPrinterData);

    if (pDriverInfo3)
        MemFree(pDriverInfo3);

    if (pOptionsArray)
        MemFree(pOptionsArray);

    return bResult;
}

#ifdef PSCRIPT

#ifndef WINNT_40


/*++

Routine Name:

    HQuerySimulationSupport

Routine Description:

    In the case of UI replacement, we allows IHV to query for print processor simulation
    support so they can provide simulated features on their UI.

    We won't enforce hooking out QueryJobAttribute w/o UI replacement here. We will do it
    at DrvQueryJobAttributes.

Arguments:

    hPrinter - printer handle
    dwLevel - interested level of spooler simulation capability info structure
    pCaps - pointer to output buffer
    cbSize - size in bytes of output buffer
    pcbNeeded - buffer size in bytes needed to store the interested info structure

Return Value:

    S_OK            if succeeded
    E_OUTOFMEMORY   if output buffer is not big enough
    E_NOTIMPL       if the interested level is not supported
    E_FAIL          if encountered other internal error

Last Error:

    None

--*/
HRESULT
HQuerySimulationSupport(
    IN  HANDLE  hPrinter,
    IN  DWORD   dwLevel,
    OUT PBYTE   pCaps,
    IN  DWORD   cbSize,
    OUT PDWORD  pcbNeeded
    )
{
    PRINTPROCESSOR_CAPS_1 SplCaps;
    PSIMULATE_CAPS_1      pSimCaps;
    DWORD cbNeeded;

    //
    // currently only Level 1 is supported
    //

    if (dwLevel != 1)
    {
        return E_NOTIMPL;
    }

    cbNeeded = sizeof(SIMULATE_CAPS_1);

    if (pcbNeeded)
    {
        *pcbNeeded = cbNeeded;
    }

    if (!pCaps || cbSize < cbNeeded)
    {
        return E_OUTOFMEMORY;
    }

    //
    // Since VGetSpoolerEmfCaps doesn't return error code, we
    // are using the dwLevel field to detect if the call succeeds.
    // If succeeds, dwLevel should be set as 1.
    //

    SplCaps.dwLevel = 0;

    VGetSpoolerEmfCaps(hPrinter,
                       NULL,
                       NULL,
                       sizeof(PRINTPROCESSOR_CAPS_1),
                       &SplCaps
                       );

    if (SplCaps.dwLevel != 1)
    {
        ERR(("VGetSpoolerEmfCaps failed\n"));
        return E_FAIL;
    }

    //
    // BUGBUG, we should get a new PRINTPROCESSOR_CAPS level to include all
    // these information instead of filling it out here. Need
    // new PRINTPROCESSOR_CAPS
    //

    pSimCaps = (PSIMULATE_CAPS_1)pCaps;

    pSimCaps->dwLevel = 1;
    pSimCaps->dwPageOrderFlags = SplCaps.dwPageOrderFlags;
    pSimCaps->dwNumberOfCopies = SplCaps.dwNumberOfCopies;
    pSimCaps->dwNupOptions = SplCaps.dwNupOptions;

    //
    // PRINTPROCESSOR_CAPS_1 is designed without an explicit field for
    // collate simulation. So before its CAPS_2 is introduced, we have
    // to assume that if reverse printing is supported, then collate
    // simulation is also supported.
    //

    if (SplCaps.dwPageOrderFlags & REVERSE_PRINT)
    {
        pSimCaps->dwCollate = 1;
    }
    else
    {
        pSimCaps->dwCollate = 0;
    }

    return S_OK;
}

#endif // !WINNT_40


/*++

Routine Name:

    HEnumConstrainedOptions

Routine Description:

    enumerate the constrained option keyword name list in the specified feature

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the enumeration operation
    pszFeatureKeyword - feature keyword name
    pmszConstrainedOptionList - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    S_OK            if succeeds
    E_OUTOFMEMORY   if output data buffer size is not big enough
    E_INVALIDARG    if feature keyword name is not recognized, or the feature's
                    stickiness doesn't match current sticky-mode
    E_FAIL          if other internal failures are encountered

Last Error:

    None

--*/
HRESULT
HEnumConstrainedOptions(
    IN  POEMUIOBJ  poemuiobj,
    IN  DWORD      dwFlags,
    IN  PCSTR      pszFeatureKeyword,
    OUT PSTR       pmszConstrainedOptionList,
    IN  DWORD      cbSize,
    OUT PDWORD     pcbNeeded
    )
{
    PCOMMONINFO pci = (PCOMMONINFO)poemuiobj;
    PUIDATA     pUiData;
    PFEATURE    pFeature;
    POPTION     pOption;
    DWORD       dwFeatureIndex, dwIndex;
    PBOOL       pabEnabledOptions = NULL;
    PSTR        pCurrentOut;
    DWORD       cbNeeded;
    INT         cbRemain;
    HRESULT     hr;

    pUiData = (PUIDATA)pci;

    if (!pszFeatureKeyword ||
        (pFeature = PGetNamedFeature(pci->pUIInfo, pszFeatureKeyword, &dwFeatureIndex)) == NULL)
    {
        WARNING(("HEnumConstrainedOptions: invalid feature\n"));

        //
        // Even though we could return right here, we still use goto to maintain single exit point.
        //

        hr = E_INVALIDARG;
        goto exit;
    }

    //
    // pUiData->iMode can have 2 modes: MODE_DOCUMENT_STICKY and MODE_PRINTER_STICKY. See PFillUiData().
    // In MODE_DOCUMENT_STICKY mode, we only support doc-sticky features.
    // In MODE_PRINTER_STICKY mode, we only support printer-sticky features.
    //
    // This is because in function PFillUiData(), it only fills devmode in MODE_DOCUMENT_STICKY mode.
    // Then in BCombineCommonInfoOptionsArray(), if devmode option array is not available, the PPD parser
    // will use OPTION_INDEX_ANY for any doc-sticky features.
    //

    if ((pUiData->iMode == MODE_DOCUMENT_STICKY && pFeature->dwFeatureType == FEATURETYPE_PRINTERPROPERTY) ||
        (pUiData->iMode == MODE_PRINTER_STICKY && pFeature->dwFeatureType != FEATURETYPE_PRINTERPROPERTY))
    {
        VERBOSE(("HEnumConstrainedOptions: mismatch iMode=%d, dwFeatureType=%d\n",
                pUiData->iMode, pFeature->dwFeatureType)) ;

        hr = E_INVALIDARG;
        goto exit;
    }

    if (pFeature->Options.dwCount)
    {
        if ((pabEnabledOptions = MemAllocZ(pFeature->Options.dwCount * sizeof(BOOL))) == NULL)
        {
            ERR(("HEnumConstrainedOptions: memory alloc failed\n"));
            hr = E_FAIL;
            goto exit;
        }

        //
        // Get the feature's enabled option list.
        //
        // See VPropShowConstraints() in docprop.c and prnprop.c for using different
        // modes to call EnumEnabledOptions().
        //

        if (pUiData->iMode == MODE_DOCUMENT_STICKY)
        {
            EnumEnabledOptions(pci->pRawData, pci->pCombinedOptions, dwFeatureIndex,
                               pabEnabledOptions, MODE_DOCANDPRINTER_STICKY);
        }
        else
        {
            EnumEnabledOptions(pci->pRawData, pci->pCombinedOptions, dwFeatureIndex,
                               pabEnabledOptions, MODE_PRINTER_STICKY);
        }
    }
    else
    {
        RIP(("HEnumConstrainedOptions: feature %s has no options\n", pszFeatureKeyword));

        //
        // continue so we will output the empty string with only the NUL character
        //
    }

    pCurrentOut = pmszConstrainedOptionList;
    cbNeeded = 0;
    cbRemain = (INT)cbSize;

    pOption = OFFSET_TO_POINTER(pci->pInfoHeader, pFeature->Options.loOffset);

    ASSERT(pOption || pFeature->Options.dwCount == 0);

    if (pOption == NULL && pFeature->Options.dwCount != 0)
    {
        hr = E_FAIL;
        goto exit;
    }

    for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++)
    {
        if (!pabEnabledOptions[dwIndex])
        {
            DWORD  dwNameSize;
            PSTR   pszKeywordName;

            pszKeywordName = OFFSET_TO_POINTER(pci->pUIInfo->pubResourceData, pOption->loKeywordName);

            ASSERT(pszKeywordName);

            if (pszKeywordName == NULL)
            {
                hr = E_FAIL;
                goto exit;
            }

            //
            // count in the NUL character between constrained option keywords
            //

            dwNameSize = strlen(pszKeywordName) + 1;

            if (pCurrentOut && cbRemain >= (INT)dwNameSize)
            {
                CopyMemory(pCurrentOut, pszKeywordName, dwNameSize);
                pCurrentOut += dwNameSize;
            }

            cbRemain -= dwNameSize;
            cbNeeded += dwNameSize;
        }

        pOption = (POPTION)((PBYTE)pOption + pFeature->dwOptionSize);
    }

    //
    // remember the last NUL terminator for the MULTI_SZ output string
    //

    cbNeeded++;

    if (pcbNeeded)
    {
        *pcbNeeded = cbNeeded;
    }

    if (!pCurrentOut || cbRemain < 1)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    *pCurrentOut = NUL;

    //
    // Succeeded
    //

    hr = S_OK;

    exit:

    MemFree(pabEnabledOptions);
    return hr;
}


/*++

Routine Name:

    HWhyConstrained

Routine Description:

    get feature/option keyword pair that constrains the given
    feature/option pair

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for this operation
    pszFeatureKeyword - feature keyword name
    pszOptionKeyword - option keyword name
    pmszReasonList - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    S_OK            if succeeds
    E_OUTOFMEMORY   if output data buffer size is not big enough
    E_INVALIDARG    if the feature keyword name or option keyword name
                    is not recognized, or the feature's stickiness
                    doesn't match current sticky-mode

Last Error:

    None

--*/
HRESULT
HWhyConstrained(
    IN  POEMUIOBJ  poemuiobj,
    IN  DWORD      dwFlags,
    IN  PCSTR      pszFeatureKeyword,
    IN  PCSTR      pszOptionKeyword,
    OUT PSTR       pmszReasonList,
    IN  DWORD      cbSize,
    OUT PDWORD     pcbNeeded
    )
{
    PCOMMONINFO   pci = (PCOMMONINFO)poemuiobj;
    PUIDATA       pUiData;
    PFEATURE      pFeature;
    POPTION       pOption;
    DWORD         dwFeatureIndex, dwOptionIndex;
    CONFLICTPAIR  ConflictPair;
    BOOL          bConflictFound;
    PSTR          pszConfFeatureName = NULL, pszConfOptionName = NULL;
    CHAR          emptyString[1] = {0};
    DWORD         cbConfFeatureKeySize = 0, cbConfOptionKeySize = 0;
    DWORD         cbNeeded = 0;

    pUiData = (PUIDATA)pci;

    if (!pszFeatureKeyword ||
        (pFeature = PGetNamedFeature(pci->pUIInfo, pszFeatureKeyword, &dwFeatureIndex)) == NULL)
    {
        WARNING(("HWhyConstrained: invalid feature\n"));
        return E_INVALIDARG;
    }

    if (!pszOptionKeyword ||
        (pOption = PGetNamedOption(pci->pUIInfo, pFeature, pszOptionKeyword, &dwOptionIndex)) == NULL)
    {
        WARNING(("HWhyConstrained: invalid option\n"));
        return E_INVALIDARG;
    }

    //
    // See comments in HEnumConstrainedOptions() for following stickiness mode check.
    //

    if ((pUiData->iMode == MODE_DOCUMENT_STICKY && pFeature->dwFeatureType == FEATURETYPE_PRINTERPROPERTY) ||
        (pUiData->iMode == MODE_PRINTER_STICKY && pFeature->dwFeatureType != FEATURETYPE_PRINTERPROPERTY))
    {
        VERBOSE(("HWhyConstrained: mismatch iMode=%d, dwFeatureType=%d\n",pUiData->iMode, pFeature->dwFeatureType));
        return E_INVALIDARG;
    }

    //
    // Get the feature/option pair that constrains the feature/option pair client is querying for.
    //

    bConflictFound = EnumNewPickOneUIConflict(pci->pRawData,
                                              pci->pCombinedOptions,
                                              dwFeatureIndex,
                                              dwOptionIndex,
                                              &ConflictPair);

    if (bConflictFound)
    {
        PFEATURE  pConfFeature;
        POPTION   pConfOption;
        DWORD     dwConfFeatureIndex, dwConfOptionIndex;

        //
        // ConflictPair has the feature with higher priority as dwFeatureIndex1.
        //

        if (dwFeatureIndex == ConflictPair.dwFeatureIndex1)
        {
            dwConfFeatureIndex = ConflictPair.dwFeatureIndex2;
            dwConfOptionIndex = ConflictPair.dwOptionIndex2;
        }
        else
        {
            dwConfFeatureIndex = ConflictPair.dwFeatureIndex1;
            dwConfOptionIndex = ConflictPair.dwOptionIndex1;
        }

        pConfFeature = PGetIndexedFeature(pci->pUIInfo, dwConfFeatureIndex);
        ASSERT(pConfFeature);

        pConfOption = PGetIndexedOption(pci->pUIInfo, pConfFeature, dwConfOptionIndex);

        //
        // We don't expect pConfOption to be NULL here. Use the ASSERT to catch cases we missed.
        //

        ASSERT(pConfOption);

        pszConfFeatureName = OFFSET_TO_POINTER(pci->pUIInfo->pubResourceData, pConfFeature->loKeywordName);
        ASSERT(pszConfFeatureName);

        if (pConfOption)
        {
            pszConfOptionName = OFFSET_TO_POINTER(pci->pUIInfo->pubResourceData, pConfOption->loKeywordName);
            ASSERT(pszConfOptionName);
        }
        else
        {
            pszConfOptionName = &(emptyString[0]);
        }

        //
        // count in the 2 NUL characters: one after feature name, one after option name.
        //

        cbConfFeatureKeySize = strlen(pszConfFeatureName) + 1;
        cbConfOptionKeySize = strlen(pszConfOptionName) + 1;
    }

    //
    // count in the last NUL characters at the end.
    //

    cbNeeded = cbConfFeatureKeySize + cbConfOptionKeySize + 1;

    if (pcbNeeded)
    {
        *pcbNeeded = cbNeeded;
    }

    if (!pmszReasonList || cbSize < cbNeeded)
    {
        return E_OUTOFMEMORY;
    }

    if (bConflictFound)
    {
        ASSERT(pszConfFeatureName && pszConfOptionName);

        CopyMemory(pmszReasonList, pszConfFeatureName, cbConfFeatureKeySize);
        pmszReasonList += cbConfFeatureKeySize;

        CopyMemory(pmszReasonList, pszConfOptionName, cbConfOptionKeySize);
        pmszReasonList += cbConfOptionKeySize;
    }

    //
    // Now the NUL at the end to finish the MULTI_SZ output string.
    //

    *pmszReasonList = NUL;

    return S_OK;
}

#endif // PSCRIPT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\prnprop.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prnprop.c

Abstract:

    This file handles the PrinterProperties and
    DrvDevicePropertySheets spooler API

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/13/97 -davidx-
        Implement OEM plugin support.

    02/10/97 -davidx-
        Consistent handling of common printer info.

    02/04/97 -davidx-
        Reorganize driver UI to separate ps and uni DLLs.

    07/17/96 -amandan-
        Created it.

--*/


#include "precomp.h"

//
// Local functions prototypes
//

CPSUICALLBACK cpcbPrinterPropertyCallback(PCPSUICBPARAM);
LONG LPrnPropApplyNow(PUIDATA, PCPSUICBPARAM, BOOL);
LONG LPrnPropSelChange(PUIDATA, PCPSUICBPARAM);


LONG
DrvDevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )

/*++

Routine Description:

    This function adds the Device Property Page to the
    property sheets.

    This function performs the following operations:

        REASON_INIT- fills PCOMPROPSHEETUI with printer UI items
                    calls compstui to add the page.

        REASON_GET_INFO_HEADER - fills out PROPSHEETUI_INFO.

        REASON_SET_RESULT - saves printerdata settings in registry buffer.

        REASON_DESTROY - Cleans up.

Arguments:

    pSUIInfo - pointer to PPROPSHEETUI_INFO
    lParam - varies depending on the reason this function is called

Return Value:

    > 0 success <= 0 for failure

--*/

{
    PDEVICEPROPERTYHEADER   pDPHdr;
    PCOMPROPSHEETUI         pCompstui;
    PUIDATA                 pUiData;
    LONG                    lResult, lRet;
    BOOL                    bResult = FALSE;

    //
    // Validate input parameters
    //

    if (!pPSUIInfo || !(pDPHdr = (PDEVICEPROPERTYHEADER) pPSUIInfo->lParamInit))
    {
        RIP(("DrvDevicePropertySheet: invalid parameter\n"));
        return -1;
    }

    //
    // Create a UIDATA structure if necessary
    //

    if (pPSUIInfo->Reason == PROPSHEETUI_REASON_INIT)
    {
        pUiData = PFillUiData(pDPHdr->hPrinter,
                              pDPHdr->pszPrinterName,
                              NULL,
                              MODE_PRINTER_STICKY);
    }
    else
        pUiData = (PUIDATA)pPSUIInfo->UserData;

    //
    // Validate pUiData
    //

    if (pUiData == NULL)
    {
        ERR(("UIDATA is NULL\n"));
        return -1;
    }

    ASSERT(VALIDUIDATA(pUiData));

    //
    // Handle various cases for which this function might be called
    //

    switch (pPSUIInfo->Reason)
    {
    case PROPSHEETUI_REASON_INIT:

        //
        // Allocate memory and partially fill out various data
        // structures required to call common UI routine.
        //

        pUiData->bPermission = ((pDPHdr->Flags & DPS_NOPERMISSION) == 0);

        #ifdef PSCRIPT

        FOREACH_OEMPLUGIN_LOOP((&(pUiData->ci)))

            if (HAS_COM_INTERFACE(pOemEntry))
            {
                HRESULT hr;

                hr = HComOEMHideStandardUI(pOemEntry,
                                           OEMCUIP_PRNPROP);

                //
                // In the case when multiple plugins are chained, it doesn't
                // make sense for one plugin to hide standard UI when another
                // one still wants to use the standard UI. So as long as one
                // plugin returns S_OK here, we will hide the standard UI.
                //

                if (bResult = SUCCEEDED(hr))
                    break;
            }

        END_OEMPLUGIN_LOOP

        #endif // PSCRIPT

        if (bResult)
        {
            //
            // Set the flag to indicate plugin is hiding our standard
            // device property sheet UI.
            //

            pUiData->dwHideFlags |= HIDEFLAG_HIDE_STD_PRNPROP;

            pUiData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
            pUiData->hComPropSheet = pPSUIInfo->hComPropSheet;

            if (BAddOemPluginPages(pUiData, pDPHdr->Flags))
            {
                pPSUIInfo->UserData = (ULONG_PTR) pUiData;
                pPSUIInfo->Result = CPSUI_CANCEL;
                lRet = 1;
                break;
            }
        }
        else if (pCompstui = PPrepareDataForCommonUI(pUiData, CPSUI_PDLGPAGE_PRINTERPROP))
        {
            pCompstui->pfnCallBack = cpcbPrinterPropertyCallback;
            pUiData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
            pUiData->hComPropSheet = pPSUIInfo->hComPropSheet;
            pUiData->pCompstui = pCompstui;

            //
            // Show which items are constrained
            //

            VPropShowConstraints(pUiData, MODE_PRINTER_STICKY);

            //
            // Update the current selection of tray items based on
            // the form-to-tray assignment table.
            //

            VSetupFormTrayAssignments(pUiData);

            //
            // Call common UI library to add our pages
            //

            if (pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                         CPSFUNC_ADD_PCOMPROPSHEETUI,
                                         (LPARAM) pCompstui,
                                         (LPARAM) &lResult) &&
                BAddOemPluginPages(pUiData, pDPHdr->Flags))
            {
                pPSUIInfo->UserData = (ULONG_PTR) pUiData;
                pPSUIInfo->Result = CPSUI_CANCEL;

                lRet = 1;
                break;
            }
        }

        //
        // Clean up in the case of error
        //

        ERR(("Failed to initialize property sheets\n"));
        VFreeUiData(pUiData);
        return -1;


    case PROPSHEETUI_REASON_GET_INFO_HEADER:
        {
            PPROPSHEETUI_INFO_HEADER pPSUIHdr;
            DWORD                    dwIcon;

            pPSUIHdr = (PPROPSHEETUI_INFO_HEADER) lParam;
            pPSUIHdr->Flags = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
            pPSUIHdr->pTitle = pUiData->ci.pPrinterName;
            pPSUIHdr->hInst = ghInstance;

            //
            // Use the Icon specified in the binary data as
            // the printer icon.
            //

            dwIcon = pUiData->ci.pUIInfo->loPrinterIcon;

            if (dwIcon && (pPSUIHdr->IconID = HLoadIconFromResourceDLL(&pUiData->ci, dwIcon)))
                pPSUIHdr->Flags |= PSUIHDRF_USEHICON;
            else
                pPSUIHdr->IconID = _DwGetPrinterIconID();
        }
        lRet = 1;
        break;

    case PROPSHEETUI_REASON_SET_RESULT:

        {
            PSETRESULT_INFO pSRInfo = (PSETRESULT_INFO) lParam;
            PCOMMONINFO pci = (PCOMMONINFO)pUiData;

            //
            // CPSUICB_REASON_APPLYNOW may not have been called. If so, we need
            // to perform tasks that are usually done by CPSUICB_REASON_APPLYNOW
            // case in our callback function cpcbPrinterPropertyCallback.
            //

            if ((pSRInfo->Result == CPSUI_OK) &&
                !(pci->dwFlags & FLAG_APPLYNOW_CALLED))
            {
                OPTSELECT OldCombinedOptions[MAX_COMBINED_OPTIONS];

                //
                // Save a copy the pre-resolve option array
                //

                CopyMemory(OldCombinedOptions,
                           pci->pCombinedOptions,
                           MAX_COMBINED_OPTIONS * sizeof(OPTSELECT));

                //
                // Call the parsers to resolve any remaining conflicts.
                //

                ResolveUIConflicts(pci->pRawData,
                                   pci->pCombinedOptions,
                                   MAX_COMBINED_OPTIONS,
                                   MODE_PRINTER_STICKY);

                //
                // Update the OPTITEM list to match the updated options array
                //

                VUpdateOptItemList(pUiData, OldCombinedOptions, pci->pCombinedOptions);

                (VOID)LPrnPropApplyNow(pUiData, NULL, TRUE);
            }

            pPSUIInfo->Result = pSRInfo->Result;
        }

        lRet = 1;
        break;

    case PROPSHEETUI_REASON_DESTROY:

        //
        // Clean up
        //

        VFreeUiData(pUiData);
        lRet = 1;

        break;

    default:

        return -1;
    }

    return lRet;
}



CPSUICALLBACK
cpcbPrinterPropertyCallback(
    IN  PCPSUICBPARAM pCallbackParam
    )

/*++

Routine Description:

    Callback function provided to common UI DLL for handling
    printer properties dialog.

Arguments:

    pCallbackParam - Pointer to CPSUICBPARAM structure

Return Value:

    CPSUICB_ACTION_NONE - no action needed
    CPSUICB_ACTION_OPTIF_CHANGED - items changed and should be refreshed

--*/

{
    PUIDATA pUiData = (PUIDATA) pCallbackParam->UserData;
    LONG    lRet = CPSUICB_ACTION_NONE;

    ASSERT(VALIDUIDATA(pUiData));
    pUiData->hDlg = pCallbackParam->hDlg;

    //
    // If user has no permission to change anything, then
    // simply return without taking any action.
    //

    if (!HASPERMISSION(pUiData) && (pCallbackParam->Reason != CPSUICB_REASON_ABOUT))
        return CPSUICB_ACTION_NONE;

    switch (pCallbackParam->Reason)
    {
    case CPSUICB_REASON_SEL_CHANGED:
    case CPSUICB_REASON_ECB_CHANGED:

        lRet = LPrnPropSelChange(pUiData, pCallbackParam);
        break;

    case CPSUICB_REASON_ITEMS_REVERTED:

        {
            POPTITEM    pOptItem;
            DWORD       dwOptItem;

            //
            // This callback reason is used when user changed items
            // and decided to revert changes from the parent item in
            // the treeview.  The callback funciton is called after
            // all revertable items are reverted to its original.
            // Only deal with installable feature at this point
            //

            dwOptItem = pUiData->dwFeatureItem;
            pOptItem = pUiData->pFeatureItems;

            for ( ; dwOptItem--; pOptItem++)
                VUpdateOptionsArrayWithSelection(pUiData, pOptItem);

            //
            // Show which items are constrained
            //

            VPropShowConstraints(pUiData, MODE_PRINTER_STICKY);
        }

        lRet = CPSUICB_ACTION_REINIT_ITEMS;
        break;

    case CPSUICB_REASON_APPLYNOW:

        pUiData->ci.dwFlags |= FLAG_APPLYNOW_CALLED;

        lRet = LPrnPropApplyNow(pUiData, pCallbackParam, FALSE);
        break;


    case CPSUICB_REASON_ABOUT:

        DialogBoxParam(ghInstance,
                       MAKEINTRESOURCE(IDD_ABOUT),
                       pUiData->hDlg,
                       _AboutDlgProc,
                       (LPARAM) pUiData);
        break;

    #ifdef UNIDRV

    case CPSUICB_REASON_PUSHBUTTON:

        //
        // Call the font installer
        //

        if (GETUSERDATAITEM(pCallbackParam->pCurItem->UserData) == SOFTFONT_SETTINGS_ITEM)
        {
            BOOL bUseOurDlgProc = TRUE;
            OEMFONTINSTPARAM fip;
            PFN_OEMFontInstallerDlgProc pDlgProc = NULL;

            memset(&fip, 0, sizeof(OEMFONTINSTPARAM));
            fip.cbSize = sizeof(OEMFONTINSTPARAM);
            fip.hPrinter = pUiData->ci.hPrinter;
            fip.hModule = ghInstance;
            fip.hHeap = pUiData->ci.hHeap;
            if (HASPERMISSION(pUiData))
                fip.dwFlags = FG_CANCHANGE;


            FOREACH_OEMPLUGIN_LOOP(&pUiData->ci)

                if (HAS_COM_INTERFACE(pOemEntry))
                {

                    if (HComOEMFontInstallerDlgProc(pOemEntry,
                                                    NULL,
                                                    0,
                                                    0,
                                                    (LPARAM)&fip) != E_NOTIMPL)
                   {
                        HComOEMFontInstallerDlgProc(pOemEntry,
                                                    pUiData->hDlg,
                                                    0,
                                                    0,
                                                    (LPARAM)&fip);
                        bUseOurDlgProc = FALSE;
                        break;
                    }
                }
                else
                {
                    pDlgProc = GET_OEM_ENTRYPOINT(pOemEntry, OEMFontInstallerDlgProc);

                    if (pDlgProc)
                    {
                        (pDlgProc)(pUiData->hDlg, 0, 0, (LPARAM)&fip);
                        bUseOurDlgProc = FALSE;
                        break;
                    }
                }

            END_OEMPLUGIN_LOOP

            if (bUseOurDlgProc)
            {
                DialogBoxParam(ghInstance,
                               MAKEINTRESOURCE(FONTINST),
                               pUiData->hDlg,
                               FontInstProc,
                               (LPARAM)(&fip));
            }
        }

        break;

    #endif // UNIDRV

    default:

        lRet = CPSUICB_ACTION_NONE;
        break;
    }

    return LInvokeOemPluginCallbacks(pUiData, pCallbackParam, lRet);
}



LONG
LPrnPropSelChange(
    IN  PUIDATA       pUiData,
    IN  PCPSUICBPARAM pCallbackParam
    )
/*++

Routine Description:

    Handle the case where user changes the current selection of an item

Arguments:

    pUiData - Pointer to our UIDATA structure
    pCallbackParam - Callback parameter passed to us by common UI

Return Value:

    CPSUICB_ACTION_NONE - no action needed
    CPSUICB_ACTION_OPTIF_CHANGED - items changed and should be refreshed

--*/

{
    POPTITEM    pCurItem = pCallbackParam->pCurItem;
    PFEATURE    pFeature;

    if (! IS_DRIVER_OPTITEM(pUiData, pCurItem))
        return CPSUICB_ACTION_NONE;

    if (ISPRINTERFEATUREITEM(pCurItem->UserData))
    {
        //
        // Deal with generic printer features only here
        // All generic features have pFeature stored in UserData
        //

        pFeature = (PFEATURE) GETUSERDATAITEM(pCurItem->UserData);


        //
        // Update the pOptionsArray with the new selection
        //

        VUpdateOptionsArrayWithSelection(pUiData, pCurItem);

        //
        // PostScript specific hack to manually associate *InstalledMemory
        // printer feature with "Available PostScript Memory" option.
        //

        #ifdef PSCRIPT

        if (pFeature->dwFeatureID == GID_MEMOPTION)
        {
            POPTITEM    pVMOptItem;
            PMEMOPTION  pMemOption;

            if ((pVMOptItem = PFindOptItem(pUiData, PRINTER_VM_ITEM)) &&
                (pMemOption = PGetIndexedOption(pUiData->ci.pUIInfo, pFeature, pCurItem->Sel)))
            {
                PPRINTERDATA pPrinterData = pUiData->ci.pPrinterData;

                pVMOptItem->Flags |= OPTIF_CHANGED;
                pVMOptItem->Sel = pMemOption->dwFreeMem / KBYTES;

                pPrinterData->dwFreeMem = pMemOption->dwFreeMem;
                pUiData->ci.dwFlags &= ~FLAG_USER_CHANGED_FREEMEM;
            }
        }

        #endif // PSCRIPT

        //
        // Update the display and show which items are constrained
        //

        VPropShowConstraints(pUiData, MODE_PRINTER_STICKY);
        return CPSUICB_ACTION_REINIT_ITEMS;
    }

    #ifdef PSCRIPT

    if (GETUSERDATAITEM(pCurItem->UserData) == PRINTER_VM_ITEM)
    {
        //
        // remember the fact that current value of "Available PostScript Memory" is entered by user
        //

        pUiData->ci.dwFlags |= FLAG_USER_CHANGED_FREEMEM;
    }

    #endif // PSCRIPT

    return CPSUICB_ACTION_NONE;
}



VOID
VUnpackPrinterPropertiesItems(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Unpack printer properties treeview items

Arguments:

    pUiData - Pointer to our UIDATA structure

Return Value:

    NONE

Note:

    Only save the settings from driver built-in features, the
    generic features selection are saved in PrnPropSelChange directly
    to pUiData->pOptionsArray (in addition to formtray assignemtn and
    printer vm)

--*/

{
    PPRINTERDATA pPrinterData = pUiData->ci.pPrinterData;
    POPTITEM     pOptItem = pUiData->pDrvOptItem;
    DWORD        dwOptItem = pUiData->dwDrvOptItem;

    for ( ; dwOptItem > 0; dwOptItem--, pOptItem++)
    {
        switch (GETUSERDATAITEM(pOptItem->UserData))
        {
        case JOB_TIMEOUT_ITEM:

            pPrinterData->dwJobTimeout = pOptItem->Sel;
            break;

        case WAIT_TIMEOUT_ITEM:

            pPrinterData->dwWaitTimeout = pOptItem->Sel;
            break;

        case IGNORE_DEVFONT_ITEM:

            if (pOptItem->Sel == 0)
                pPrinterData->dwFlags &= ~PFLAGS_IGNORE_DEVFONT;
            else
                pPrinterData->dwFlags |= PFLAGS_IGNORE_DEVFONT;
            break;

        case PAGE_PROTECT_ITEM:
        {
            VUpdateOptionsArrayWithSelection(pUiData, pOptItem);

        }
            break;

        default:

            _VUnpackDriverPrnPropItem(pUiData, pOptItem);
            break;
        }
    }
}



LONG
LPrnPropApplyNow(
    PUIDATA         pUiData,
    PCPSUICBPARAM   pCallbackParam,
    BOOL            bFromSetResult
    )

/*++

Routine Description:

    Handle the case where user clicks OK to exit the dialog
    Need to save the printer sticky options in pUiData->pOptionsArray
    to printerdata.aOptions

Arguments:

    pUiData - Pointer to our UIDATA structure
    pCallbackParam - Callback parameter passed to us by common UI
    bFromSetResult - TRUE if called from PROPSHEETUI_REASON_SET_RESULT, FALSE otherwise.

Return Value:

    CPSUICB_ACTION_NONE - dismiss the dialog
    CPSUICB_ACTION_NO_APPLY_EXIT - don't dismiss the dialog

--*/

{
    PCOMMONINFO     pci;
    BOOL            bResult = TRUE;

    if (!bFromSetResult)
    {
        ASSERT(pCallbackParam);

        //
        // Check if there are still any unresolved constraints left?
        //

        if (((pUiData->ci.dwFlags & FLAG_PLUGIN_CHANGED_OPTITEM) ||
             BOptItemSelectionsChanged(pUiData->pDrvOptItem, pUiData->dwDrvOptItem)) &&
            ICheckConstraintsDlg(pUiData,
                                 pUiData->pFeatureItems,
                                 pUiData->dwFeatureItem,
                                 TRUE) == CONFLICT_CANCEL)
        {
            //
            // Conflicts found and user clicked CANCEL to
            // go back to the dialog without dismissing it.
            //

            return CPSUICB_ACTION_NO_APPLY_EXIT;
        }
    }

    //
    // Unpack printer properties treeview items
    //

    VUnpackPrinterPropertiesItems(pUiData);

    //
    // Save form-to-tray assignment table
    // Save font substitution table
    // Save any driver-specific properties
    //

    if (! BUnpackItemFormTrayTable(pUiData))
    {
        ERR(("BUnpackItemFormTrayTable failed\n"));
        bResult = FALSE;
    }

    if (! BUnpackItemFontSubstTable(pUiData))
    {
        ERR(("BUnpackItemFontSubstTable failed\n"));
        bResult = FALSE;
    }

    if (! _BUnpackPrinterOptions(pUiData))
    {
        ERR(("_BUnpackPrinterOptions failed\n"));
        bResult = FALSE;
    }

    //
    // Separate the printer sticky options from the combined option array
    // and save it to printerdata.aOptions
    //

    pci = (PCOMMONINFO) pUiData;

    SeparateOptionArray(
            pci->pRawData,
            pci->pCombinedOptions,
            pci->pPrinterData->aOptions,
            MAX_PRINTER_OPTIONS,
            MODE_PRINTER_STICKY);

    if (!BSavePrinterProperties(pci->hPrinter, pci->pRawData,
                                pci->pPrinterData, sizeof(PRINTERDATA)))
    {
        ERR(("BSavePrinterProperties failed\n"));
        bResult = FALSE;
    }

    #ifndef WINNT_40

    VNotifyDSOfUpdate(pci->hPrinter);

    #endif // !WINNT_40

    if (!bFromSetResult)
    {
        //
        // DCR: Should we display an error message if there is
        // an error while saving the printer-sticky properties?
        //

        pCallbackParam->Result = CPSUI_OK;
        return CPSUICB_ACTION_ITEMS_APPLIED;
    }
    else
    {
        return 1;
    }
}



BOOL
BPackPrinterPropertyItems(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack printer property information into treeview items.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    return
        BPackItemFormTrayTable(pUiData)     &&
        _BPackFontSubstItems(pUiData)       &&
        _BPackPrinterOptions(pUiData)       &&
        BPackItemGenericOptions(pUiData)    &&
        BPackOemPluginItems(pUiData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\quryprnt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    quryprnt.c

Abstract:

    This file handles the DrvQueryPrintEx spooler API

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/13/97 -davidx-
        Implement OEM plugin support.

    02/08/97 -davidx-
        Rewrote it to use common data management functions.

    02/04/97 -davidx-
        Reorganize driver UI to separate ps and uni DLLs.

    07/17/96 -amandan-
        Created it.

--*/

#include "precomp.h"


//
// Forward declaration of local functions
//

BOOL BFormatDQPMessage(PDEVQUERYPRINT_INFO, INT, ...);
BOOL BQueryPrintDevmode(PDEVQUERYPRINT_INFO, PCOMMONINFO);
BOOL BQueryPrintForm(PDEVQUERYPRINT_INFO, PCOMMONINFO);


BOOL
DevQueryPrintEx(
    PDEVQUERYPRINT_INFO pDQPInfo
    )

/*++

Routine Description:

    This function checks whether the job can be printed with
    DEVMODE passed in.  This function will use the following
    criterias to determine whether the job is printable:
    - get basic printer information
    - verify input devmode
    - verify resolution is supported
    - verify there is no conflicts between printer feature selections
    - verify form-to-tray assignment

Arguments:

    pDQPInfo - Points to a DEVQUERYPRINT_INFO structure

Return Value:

    TRUE if the job can be printed with the given DEVMODE, otherwise FALSE

--*/

{
    PCOMMONINFO pci;
    BOOL        bResult;

    if (pDQPInfo == NULL || pDQPInfo->hPrinter == NULL)
        return BFormatDQPMessage(pDQPInfo, IDS_DQPERR_PARAM);

    if (pDQPInfo->pDevMode == NULL)
        return TRUE;

    if ((pci = PLoadCommonInfo(pDQPInfo->hPrinter, NULL, 0)) == NULL)
        return BFormatDQPMessage(pDQPInfo, IDS_DQPERR_COMMONINFO);

    bResult = BQueryPrintDevmode(pDQPInfo, pci) &&
              BQueryPrintForm(pDQPInfo, pci);

    if (bResult)
    {
        PFN_OEMDevQueryPrintEx pfnOEMDevQueryPrintEx;

        //
        // call OEMDevQueryPrintEx entrypoint for each plugin,
        // or until one of them returns FALSE.
        //

        FOREACH_OEMPLUGIN_LOOP(pci)

            if (HAS_COM_INTERFACE(pOemEntry))
            {
                HRESULT hr;

                hr = HComOEMDevQueryPrintEx(pOemEntry,
                                            &pci->oemuiobj,
                                            pDQPInfo,
                                            pci->pdm,
                                            pOemEntry->pOEMDM);
                if (hr == E_NOTIMPL)
                    continue;

                if (!(bResult = SUCCEEDED(hr)))
                    break;

            }
            else
            {
                if ((pfnOEMDevQueryPrintEx = GET_OEM_ENTRYPOINT(pOemEntry, OEMDevQueryPrintEx)) &&
                    !pfnOEMDevQueryPrintEx(&pci->oemuiobj, pDQPInfo, pci->pdm, pOemEntry->pOEMDM))
                {
                    ERR(("OEMDevQueryPrintEx failed for '%ws': %d\n",
                        CURRENT_OEM_MODULE_NAME(pOemEntry),
                        GetLastError()));

                    bResult = FALSE;
                    break;
                }
            }

        END_OEMPLUGIN_LOOP
    }

    VFreeCommonInfo(pci);
    return bResult;
}



BOOL
BFormatDQPMessage(
    PDEVQUERYPRINT_INFO pDQPInfo,
    INT                 iMsgResId,
    ...
    )

/*++

Routine Description:

    Format DevQueryPrintEx error message

Arguments:

    pDQPInfo - Points to a DEVQUERYPRINT_INFO structure
    iMsgResId - Error message format specifier (string resource ID)

Return Value:

    FALSE

--*/

#define MAX_FORMAT_STRING   256
#define MAX_DQP_MESSAGE     512

{
    TCHAR   awchFormat[MAX_FORMAT_STRING];
    TCHAR   awchMessage[MAX_DQP_MESSAGE];
    INT     iLength = 0;
    va_list arglist;

    //
    // Load the format specifier string resource
    // and use swprintf to format the error message
    //

    va_start(arglist, iMsgResId);

    if (! LoadString(ghInstance, iMsgResId, awchFormat, MAX_FORMAT_STRING))
        awchFormat[0] = NUL;

    if (SUCCEEDED(StringCchVPrintfW(awchMessage,
                                    CCHOF(awchMessage),
                                    awchFormat,
                                    arglist)))
    {
        iLength = wcslen(awchMessage);
    }

    if (iLength <= 0)
    {
        StringCchCopyW(awchMessage, CCHOF(awchMessage), L"Error");
        iLength = wcslen(awchMessage);
    }

    va_end(arglist);

    //
    // Copy the error message string to DQPInfo
    //

    iLength += 1;
    pDQPInfo->cchNeeded = iLength;

    if (iLength > (INT) pDQPInfo->cchErrorStr)
        iLength = pDQPInfo->cchErrorStr;

    if (pDQPInfo->pszErrorStr && iLength)
        CopyString(pDQPInfo->pszErrorStr, awchMessage, iLength);

    return FALSE;
}



BOOL
BQueryPrintDevmode(
    PDEVQUERYPRINT_INFO pDQPInfo,
    PCOMMONINFO         pci
    )

/*++

Routine Description:

    Validate devmode information

Arguments:

    pDQPInfo - Points to a DEVQUERYPRINT_INFO structure
    pci - Points to basic printer info

Return Value:

    TRUE if successful, FALSE if the job should be held

--*/

{
    INT       iRealizedRes, iResX, iResY;
    PFEATURE  pFeature;
    DWORD     dwFeatureIndex, dwOptionIndexOld, dwOptionIndexNew;
    BOOL      bUpdateFormField;

    //
    // Validate input devmode
    // Get printer-sticky properties
    // Merge doc- and printer-sticky printer feature selections
    // Fix up combined options array with public devmode info
    //

    if (! BFillCommonInfoDevmode(pci, NULL, pDQPInfo->pDevMode))
        return BFormatDQPMessage(pDQPInfo, IDS_DQPERR_DEVMODE);

    if (! BFillCommonInfoPrinterData(pci))
        return BFormatDQPMessage(pDQPInfo, IDS_DQPERR_PRINTERDATA);

    if (! BCombineCommonInfoOptionsArray(pci))
        return BFormatDQPMessage(pDQPInfo, IDS_DQPERR_MEMORY);

    VFixOptionsArrayWithDevmode(pci);

    //
    // Remember the paper size option parser picked to support the devmode form
    //

    if ((pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGESIZE)) == NULL)
    {
        ASSERT(FALSE);
        return BFormatDQPMessage(pDQPInfo, IDS_DQPERR_DEVMODE);
    }

    dwFeatureIndex = GET_INDEX_FROM_FEATURE(pci->pUIInfo, pFeature);
    dwOptionIndexOld = pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex;

    if (! ResolveUIConflicts(
                pci->pRawData,
                pci->pCombinedOptions,
                MAX_COMBINED_OPTIONS,
                MODE_DOCANDPRINTER_STICKY|DONT_RESOLVE_CONFLICT))
    {
        return BFormatDQPMessage(pDQPInfo, IDS_DQPERR_OPTSELECT);
    }

    dwOptionIndexNew = pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex;

    bUpdateFormField = FALSE;

    if (dwOptionIndexNew != dwOptionIndexOld)
    {
        //
        // Constraint resolving has changed page size selection, so we need
        // to update devmode's form fields.
        //

        bUpdateFormField = TRUE;
    }
    else
    {
        FORM_INFO_1  *pForm = NULL;

        //
        // Unless the form requested by devmode is not supported on the printer,
        // we still want to show the original form name in upcoming doc-setting UI.
        // For example, if input devmode requested "Legal", parser maps it to option
        // "OEM Legal", but both "Legal" and "OEM Legal" will be shown as supported
        // forms on the printer, then we should still show "Legal" instead of "OEM Legal"
        // in UI's PageSize list. However, if input devmode requestd "8.5 x 12", which
        // won't be shown as a supportd form and it's mapped to "OEM Legal", then we should
        // show "OEM Legal".
        //

        //
        // pdm->dmFormName won't have a valid form name for custom page size (see
        // BValidateDevmodeFormFields()). VOptionsToDevmodeFields() knows to handle that.
        //

        if ((pci->pdm->dmFields & DM_FORMNAME) &&
            (pForm = MyGetForm(pci->hPrinter, pci->pdm->dmFormName, 1)) &&
            !BFormSupportedOnPrinter(pci, pForm, &dwOptionIndexNew))
        {
            bUpdateFormField = TRUE;
        }

        MemFree(pForm);
    }

    VOptionsToDevmodeFields(pci, bUpdateFormField);

    if (! BUpdateUIInfo(pci))
        return BFormatDQPMessage(pDQPInfo, IDS_DQPERR_COMMONINFO);

    //
    // Check if the requested resolution is supported
    //

    iRealizedRes = max(pci->pdm->dmPrintQuality, pci->pdm->dmYResolution);
    iResX = iResY = 0;

    //
    // Kludze, there are some cases where apps set dmPrintQuality/dmYResolution
    // to be one of the DMRES values. We skip the checking for resolution
    // since Unidrv/Pscript will map them to one of the valid resolution options
    // at print time
    //

    if (pDQPInfo->pDevMode->dmFields & DM_PRINTQUALITY)
    {
        iResX = pDQPInfo->pDevMode->dmPrintQuality;

        if (iResX <= DMRES_DRAFT)
            return TRUE;
    }

    if (pDQPInfo->pDevMode->dmFields & DM_YRESOLUTION)
    {
        iResY = pDQPInfo->pDevMode->dmYResolution;

        if (iResY <= DMRES_DRAFT)
            return TRUE;
    }

    if (max(iResX, iResY) != iRealizedRes)
        return BFormatDQPMessage(pDQPInfo, IDS_DQPERR_RESOLUTION);

    return TRUE;
}



BOOL
BQueryPrintForm(
    PDEVQUERYPRINT_INFO pDQPInfo,
    PCOMMONINFO         pci
    )

/*++

Routine Description:

    Check if the requested form and/or tray is available

Arguments:

    pDQPInfo - Points to a DEVQUERYPRINT_INFO structure
    pci - Points to basic printer info

Return Value:

    TRUE if successful, FALSE if the job should be held

--*/

{
    PUIINFO         pUIInfo;
    PFEATURE        pFeature;
    PPAGESIZE       pPageSize;
    PWSTR           pwstrTrayName;
    FORM_TRAY_TABLE pFormTrayTable;
    FINDFORMTRAY    FindData;
    WCHAR           awchTrayName[CCHBINNAME];
    DWORD           dwFeatureIndex, dwOptionIndex;
    BOOL            bResult = FALSE;

    //
    // Skip it if form name is not specified
    //

    if ((pci->pdm->dmFields & DM_FORMNAME) == 0 ||
        pci->pdm->dmFormName[0] == NUL)
    {
        return TRUE;
    }

    pUIInfo = pci->pUIInfo;

    if ((pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGESIZE)) == NULL)
    {
        ASSERT(FALSE);
        return TRUE;
    }

    dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);
    dwOptionIndex = pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex;

    if ((pPageSize = PGetIndexedOption(pUIInfo, pFeature, dwOptionIndex)) == NULL)
    {
        ASSERT(FALSE);
        return TRUE;
    }

    //
    // For custom page size option, we have left the devmode form fields unchanged.
    // See function VOptionToDevmodeFields().
    //

    //
    // We've only shown user forms supported by custom page size in Form-to-Tray table.
    //

    if (pPageSize->dwPaperSizeID == DMPAPER_USER ||
        pPageSize->dwPaperSizeID == DMPAPER_CUSTOMSIZE)
    {
        FORM_INFO_1  *pForm;

        //
        // We already verified the dmFormName field at the beginning.
        //

        if (pForm = MyGetForm(pci->hPrinter, pci->pdm->dmFormName, 1))
        {
            //
            // Built-in and printer forms supported by custom page size option won't show
            // up in either PageSize list or Form-to-Tray assignment table. So we only
            // continue to check the From-to-Tray assignment table for user forms supported
            // by custom page size option. See function BFormSupportedOnPrinter().
            //

            if (pForm->Flags != FORM_USER)
            {
                MemFree(pForm);
                return TRUE;
            }

            MemFree(pForm);
        }
    }

    //
    // Get the specified tray name, if any
    //

    pwstrTrayName = NULL;

    if (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_INPUTSLOT))
    {
        PINPUTSLOT  pInputSlot;

        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);
        dwOptionIndex = pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex;

        if ((pInputSlot = PGetIndexedOption(pUIInfo, pFeature, dwOptionIndex)) &&
            (pInputSlot->dwPaperSourceID != DMBIN_FORMSOURCE) &&
            LOAD_STRING_OPTION_NAME(pci, pInputSlot, awchTrayName, CCHBINNAME))
        {
            pwstrTrayName = awchTrayName;
        }
    }

    //
    // Find out if the requested form/tray pair is
    // listed in the form-to-tray assignment table.
    //

    if (pFormTrayTable = PGetFormTrayTable(pci->hPrinter, NULL))
    {
        RESET_FINDFORMTRAY(pFormTrayTable, &FindData);

        bResult = BSearchFormTrayTable(pFormTrayTable,
                                       pwstrTrayName,
                                       pci->pdm->dmFormName,
                                       &FindData);
        MemFree(pFormTrayTable);
    }

    if (! bResult)
    {
        if (pwstrTrayName != NULL)
        {
            return BFormatDQPMessage(pDQPInfo,
                                     IDS_DQPERR_FORMTRAY,
                                     pci->pdm->dmFormName,
                                     pwstrTrayName);
        }
        else
        {
            return BFormatDQPMessage(pDQPInfo,
                                     IDS_DQPERR_FORMTRAY_ANY,
                                     pci->pdm->dmFormName);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\uires.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation
//

//
// DMPUB IDs
//

#ifdef WINNT_40
#define NUP_DMPUB                     DMPUB_NONE
#define PAGEORDER_DMPUB               DMPUB_NONE
#else
#define NUP_DMPUB                     DMPUB_NUP
#define PAGEORDER_DMPUB               DMPUB_PAGEORDER
#endif // WINNT_40

//
// Resource IDs for dialogs
//

#define IDD_CONFLICTS                   100
#define IDC_IGNORE                      101
#define IDC_FEATURE1                    102
#define IDC_OPTION1                     103
#define IDC_FEATURE2                    104
#define IDC_OPTION2                     105
#define IDC_RESOLVE                     106
#define IDC_CANCEL                      107
#define IDC_CANCEL_FINAL                108

//
// Font installer dialog
//

#define FONTINST                        300

#define IDD_ADD                         302
#define IDD_DELFONT                     303
#define IDD_FONTDIR                     304
#define IDD_NEWFONTS                    305
#define IDD_CURFONTS                    306
#define IDD_OPEN                        307

#define TID_FONTDIR                     308
#define TID_NEWFONTS                    309
#define TID_CURFONTS                    310

//
// String resource IDs
//

#define IDS_DQPERR_PARAM                101
#define IDS_DQPERR_COMMONINFO           102
#define IDS_DQPERR_DEVMODE              103
#define IDS_DQPERR_RESOLUTION           104
#define IDS_DQPERR_OPTSELECT            105
#define IDS_DQPERR_FORMTRAY_ANY         106
#define IDS_DQPERR_FORMTRAY             107
#define IDS_DQPERR_MEMORY               108
#define IDS_DQPERR_PRINTERDATA          109

#define IDS_POSTSCRIPT                  250
#define IDS_UNIDRV                      251

#define IDS_POSTSCRIPT_VM               400
#define IDS_KBYTES                      401
#define IDS_SECONDS                     402
#define IDS_PSTIMEOUTS                  403
#define IDS_JOBTIMEOUT                  404
#define IDS_WAITTIMEOUT                 405
#define IDS_PRINTER_DEFAULT             406
#define IDS_INSTALLABLE_OPTIONS         407
#define IDS_DOWNLOAD_AS_SOFTFONT        408
#define IDS_USE_DEVFONTS                409
#define IDS_FONTSUB_OPTION              410
#define IDS_FONTSUB_DEFAULT             411
#define IDS_FONTSUB_SLOW                412
#define IDS_FONTSUB_TABLE               413
#define IDS_DEFAULT_TRAY                414
#define IDS_DRAW_ONLY_FROM_SELECTED     415
#define IDS_RESTORE_DEFAULTS            417
#define IDS_PRINTER_FEATURES            418
#define IDS_METAFILE_SPOOLING           419
#define IDS_ENABLED                     420
#define IDS_DISABLED                    421
#define IDS_PSOPTIONS                   422
#define IDS_MIRROR                      423
#define IDS_NEGATIVE_PRINT              424
#define IDS_PAGEINDEP                   425
#define IDS_COMPRESSBMP                 426
#define IDS_CTRLD_BEFORE                427
#define IDS_CTRLD_AFTER                 428
#define IDS_JOB_CONTROL                 429
#define IDS_TEXT_ASGRX                  431
#define IDS_PAGE_PROTECTION             432
#define IDS_CANCEL_CONFLICT             433
#define IDS_IGNORE_CONFLICT             434
#define IDS_RESOLVE_CONFLICT            435
#define IDS_GETDATA_FAILED              436
#define IDS_DRIVERUI_COLORMODE          437
#define IDS_ENVELOPE                    438
#define IDS_ENV_PREFIX                  439
#define IDS_PSPROTOCOL                  440
#define IDS_PSPROTOCOL_ASCII            441
#define IDS_PSPROTOCOL_BCP              442
#define IDS_PSPROTOCOL_TBCP             443
#define IDS_PSPROTOCOL_BINARY           444
#define IDS_TRAY_FORMSOURCE             445
#define IDS_OEMERR_DLGTITLE             446
#define IDS_OEMERR_OPTITEM              447
#define IDS_OEMERR_PROPSHEET            448
#define IDS_CANCEL_CONFLICT_FINAL       449

#define IDS_PSERROR_HANDLER             450
#define IDS_PSMINOUTLINE                451
#define IDS_PSMAXBITMAP                 452
#define IDS_PIXELS                      453
#define IDS_PSOUTPUT_OPTION             454
#define IDS_PSOPT_SPEED                 455
#define IDS_PSOPT_PORTABILITY           456
#define IDS_PSOPT_EPS                   457
#define IDS_PSOPT_ARCHIVE               458
#define IDS_PSTT_DLFORMAT               459
#define IDS_TTDL_DEFAULT                460
#define IDS_TTDL_TYPE1                  461
#define IDS_TTDL_TYPE3                  462
#define IDS_TTDL_TYPE42                 463

#ifdef WINNT_40
#define IDS_NUPOPTION                   464
#define IDS_ONE_UP                      465
#define IDS_TWO_UP                      466
#define IDS_FOUR_UP                     467
#define IDS_SIX_UP                      468
#define IDS_NINE_UP                     469
#define IDS_SIXTEEN_UP                  470
#else
#define IDS_NUPOPTION                   IDS_CPSUI_NUP
#define IDS_ONE_UP                      IDS_CPSUI_NUP_NORMAL
#define IDS_TWO_UP                      IDS_CPSUI_NUP_TWOUP
#define IDS_FOUR_UP                     IDS_CPSUI_NUP_FOURUP
#define IDS_SIX_UP                      IDS_CPSUI_NUP_SIXUP
#define IDS_NINE_UP                     IDS_CPSUI_NUP_NINEUP
#define IDS_SIXTEEN_UP                  IDS_CPSUI_NUP_SIXTEENUP
#endif //WINNT_40

#define IDS_PSLEVEL                     471
#define IDS_ICMMETHOD                   475
#define IDS_ICMMETHOD_NONE              476
#define IDS_ICMMETHOD_SYSTEM            477
#define IDS_ICMMETHOD_DRIVER            478
#define IDS_ICMMETHOD_DEVICE            479
#define IDS_ICMINTENT                   480
#define IDS_ICMINTENT_SATURATE          481
#define IDS_ICMINTENT_CONTRAST          482
#define IDS_ICMINTENT_COLORIMETRIC      483
#define IDS_ICMINTENT_ABS_COLORIMETRIC  484
#define IDS_CUSTOMSIZE_ERROR            485
#define IDS_CUSTOMSIZEPARAM_ERROR       486
#define IDS_CUSTOMSIZE_UNRESOLVED       488

#define IDS_FEEDDIRECTION_BASE          489
#define IDS_FEED_LONGEDGEFIRST          (IDS_FEEDDIRECTION_BASE + LONGEDGEFIRST)
#define IDS_FEED_SHORTEDGEFIRST         (IDS_FEEDDIRECTION_BASE + SHORTEDGEFIRST)
#define IDS_FEED_LONGEDGEFIRST_FLIPPED  (IDS_FEEDDIRECTION_BASE + LONGEDGEFIRST_FLIPPED)
#define IDS_FEED_SHORTEDGEFIRST_FLIPPED (IDS_FEEDDIRECTION_BASE + SHORTEDGEFIRST_FLIPPED)

#define IDS_EDIT_CUSTOMSIZE             493

#ifdef WINNT_40
#define IDS_PAGEORDER                   494
#define IDS_PAGEORDER_NORMAL            495
#define IDS_PAGEORDER_REVERSE           496
#else
#define IDS_PAGEORDER                   IDS_CPSUI_PAGEORDER
#define IDS_PAGEORDER_NORMAL            IDS_CPSUI_FRONTTOBACK
#define IDS_PAGEORDER_REVERSE           IDS_CPSUI_BACKTOFRONT
#endif // WINNT_40

#define IDS_QUALITY_FIRST               500
#define IDS_QUALITY_BEST                IDS_QUALITY_FIRST
#define IDS_QUALITY_BETTER              501
#define IDS_QUALITY_DRAFT               502
#define IDS_QUALITY_SETTINGS            503
#define IDS_QUALITY_CUSTOM              504
#define IDS_PP_SOFTFONTS                505
#define IDS_BOOKLET                     506

#define IDS_TRUE_GRAY_TEXT              507
#define IDS_TRUE_GRAY_GRAPH             508

#define IDS_ADD_EURO                    509

#define IDS_FONTINST_DIRECTORYTOOLONG   510
#define IDS_FONTINST_FONTINSTALLER      511
#define IDS_FONTINST_INVALIDDIR         512
#define IDS_FONTINST_NOFONTFOUND        513
#define IDS_FONTINST_NODIRNAME          514
#define IDS_FONTINST_OUTOFMEMORY        515


// DCR - use appropriate icons

#define IDI_USE_DEFAULT                 0
#define IDI_PSPROTOCOL                  IDI_USE_DEFAULT
#define IDI_PSOPT_SPEED                 IDI_USE_DEFAULT
#define IDI_PSOPT_PORTABILITY           IDI_USE_DEFAULT
#define IDI_PSOPT_EPS                   IDI_USE_DEFAULT
#define IDI_PSOPT_ARCHIVE               IDI_USE_DEFAULT
#define IDI_ONE_UP                      IDI_USE_DEFAULT
#define IDI_TWO_UP                      IDI_USE_DEFAULT
#define IDI_FOUR_UP                     IDI_USE_DEFAULT
#define IDI_SIX_UP                      IDI_USE_DEFAULT
#define IDI_NINE_UP                     IDI_USE_DEFAULT
#define IDI_SIXTEEN_UP                  IDI_USE_DEFAULT
#define IDI_BOOKLET                     IDI_USE_DEFAULT
#define IDI_PSTT_DLFORMAT               IDI_USE_DEFAULT
#define IDI_PSLEVEL                     IDI_USE_DEFAULT
#define IDI_ICMMETHOD_NONE              IDI_CPSUI_ICM_METHOD
#define IDI_ICMMETHOD_SYSTEM            IDI_CPSUI_ICM_METHOD
#define IDI_ICMMETHOD_DRIVER            IDI_CPSUI_ICM_METHOD
#define IDI_ICMMETHOD_DEVICE            IDI_CPSUI_ICM_METHOD
#define IDI_ICMINTENT_SATURATE          IDI_CPSUI_ICM_INTENT
#define IDI_ICMINTENT_CONTRAST          IDI_CPSUI_ICM_INTENT
#define IDI_ICMINTENT_COLORIMETRIC      IDI_CPSUI_ICM_INTENT
#define IDI_ICMINTENT_ABS_COLORIMETRIC  IDI_CPSUI_ICM_INTENT
#define IDI_CUSTOM_PAGESIZE             IDI_USE_DEFAULT
#define IDI_PAGEORDER_NORMAL            IDI_USE_DEFAULT
#define IDI_PAGEORDER_REVERSE           IDI_USE_DEFAULT


//
// PostScript custom page size dialog resources
//

#ifdef PSCRIPT

#define IDD_PSCRIPT_CUSTOMSIZE          1000

#define IDS_PS_VERSION                  1002

#define IDC_RESTOREDEFAULTS             100
#define IDC_CS_INCH                     101
#define IDC_CS_MM                       102
#define IDC_CS_POINT                    103
#define IDC_CS_WIDTH                    104
#define IDC_CS_HEIGHT                   105
#define IDC_CS_WIDTHRANGE               106
#define IDC_CS_HEIGHTRANGE              107
#define IDC_CS_XOFFSET                  108
#define IDC_CS_YOFFSET                  109
#define IDC_CS_XOFFSETRANGE             110
#define IDC_CS_YOFFSETRANGE             111
#define IDC_CS_FEEDDIRECTION            112
#define IDC_CS_CUTSHEET                 113
#define IDC_CS_ROLLFED                  114

#define IDD_ABOUT                       1001
#define IDC_WINNT_VER                   100
#define IDC_MODELNAME                   101
#define IDC_PPD_FILENAME                102
#define IDC_PPD_FILEVER                 103

#define IDI_PSCRIPT                     1000

#endif // PSCRIPT

#ifdef UNIDRV

#define IDD_ABOUT                       1001
#define IDC_WINNT_VER                   100
#define IDC_MODELNAME                   101
#define IDC_GPD_FILENAME                102
#define IDC_GPD_FILEVER                 103

#define IDI_UNIDRV                      1000

#endif // UNIDRV

#define IDI_WARNING_ICON                2000

#ifdef WINNT_40

#define VER_54DRIVERVERSION_STR         "4.50"

#endif // WINNT_40
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\ps\custsize.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    custsize.c

Abstract:

    Display PostScript custom page size UI

Environment:

    Windows NT PostScript driver UI

Revision History:

    03/31/97 -davidx-
        Created it.

--*/

#include "precomp.h"
#include <windowsx.h>
#include <math.h>


//
// PostScript custom page size context-sensitive help IDs
//

static const DWORD PSCustSizeHelpIDs[] = {

    IDC_CS_WIDTH,           IDH_PSCUST_Width,
    IDC_CS_HEIGHT,          IDH_PSCUST_Height,
    IDC_CS_INCH,            IDH_PSCUST_Unit_Inch,
    IDC_CS_MM,              IDH_PSCUST_Unit_Millimeter,
    IDC_CS_POINT,           IDH_PSCUST_Unit_Point,
    IDC_CS_FEEDDIRECTION,   IDH_PSCUST_PaperFeed_Direction,
    IDC_CS_CUTSHEET,        IDH_PSCUST_Paper_CutSheet,
    IDC_CS_ROLLFED,         IDH_PSCUST_Paper_RollFeed,
    IDC_CS_XOFFSET,         IDH_PSCUST_Offset_Perpendicular,
    IDC_CS_YOFFSET,         IDH_PSCUST_Offset_Parallel,
    IDOK,                   IDH_PSCUST_OK,
    IDCANCEL,               IDH_PSCUST_Cancel,
    IDC_RESTOREDEFAULTS,    IDH_PSCUST_Restore_Defaults,

    0, 0
};

//
// Display units
// Note: These constants must be in the same order as dialog control IDs:
//  IDC_CS_INCH, IDC_CS_MM, IDC_CS_POINT
//

enum { CSUNIT_INCH, CSUNIT_MM, CSUNIT_POINT, CSUNIT_MAX };

static const double adCSUnitData[CSUNIT_MAX] =
{
    25400.0,            // microns per inch
    1000.0,             // microns per millimeter
    25400.0 / 72.0,     // microns per point
};

//
// Data structure used to pass information to custom page size dialog
//

typedef struct _CUSTOMSIZEDLG {

    CUSTOMSIZEDATA  csdata;     // custom page size data, must be the first field
    PUIDATA         pUiData;    // pointer to UIDATA structure
    PPPDDATA        pPpdData;   // pointer to PPDDATA structure
    BOOL            bMetric;    // whether we're on metric system
    INT             iUnit;      // current display unit
    BOOL            bSetText;   // we're calling SetDlgItemText
    BOOL            bOKPassed;  // user hit OK and setting passed validation/resolution

    // feed direction to combo box option mapping table (round up to 4-byte boundary)
    BYTE            aubFD2CBOptionMapping[(MAX_FEEDDIRECTION + 3) & ~3];

} CUSTOMSIZEDLG, *PCUSTOMSIZEDLG;

#define MAXDIGITLEN                16     // maximum number of digits for user-entered numbers
#define INVALID_CBOPTION_INDEX     0xFF   // invalid option index for the feeding direction combo box

#define CUSTSIZE_ROUNDUP(x)        (ceil((x) * 100.0) / 100.0 + 0.001)
#define CUSTSIZE_ROUNDDOWN(x)      (floor((x) * 100.0) / 100.0 + 0.001)


VOID
VUpdateCustomSizeTextField(
    HWND             hDlg,
    PCUSTOMSIZEDLG   pDlgData,
    INT              iCtrlID,
    PCUSTOMSIZERANGE pCSRange
    )

/*++

Routine Description:

    Update the custom size parameter text fields:
        width, height, and offsets

Arguments:

    hDlg - Handle to custom page size dialog window
    pDlgData - Points to custom page size dialog data
    iCtrlID - Specifies the interested text field control ID
    pCSRange - custom page size parameter ranges

Return Value:

    NONE

--*/

{
    TCHAR   tchBuf[MAX_DISPLAY_NAME];
    DWORD   dwVal;
    double  dMin, dMax;
    double  dNum;

    switch (iCtrlID)
    {
    case IDC_CS_WIDTH:
        dwVal = pDlgData->csdata.dwX;
        pCSRange += CUSTOMPARAM_WIDTH;
        break;

    case IDC_CS_HEIGHT:
        dwVal = pDlgData->csdata.dwY;
        pCSRange += CUSTOMPARAM_HEIGHT;
        break;

    case IDC_CS_XOFFSET:
        dwVal = pDlgData->csdata.dwWidthOffset;
        pCSRange += CUSTOMPARAM_WIDTHOFFSET;
        break;

    case IDC_CS_YOFFSET:
        dwVal = pDlgData->csdata.dwHeightOffset;
        pCSRange += CUSTOMPARAM_HEIGHTOFFSET;
        break;
    }

    //
    // The dMin/dMax algorithm here must be the same as in following function
    // VUpdateCustomSizeRangeField.
    //
    // We only show 2 digits after the decimal point. We round the min
    // number up (ceil) and round the max number down (floor). Also, in
    // order to correct double -> DWORD conversion error we saw in some
    // cases (ex. 39.000 is converted to DWROD 38 since the 39.000 is actually
    // 38.999999...), we add the extra 0.001.
    //

    dMin = (double) pCSRange->dwMin / adCSUnitData[pDlgData->iUnit];
    dMin = CUSTSIZE_ROUNDUP(dMin);

    dMax = (double) pCSRange->dwMax / adCSUnitData[pDlgData->iUnit];
    dMax = CUSTSIZE_ROUNDDOWN(dMax);

    // Fix bug Adobe #260379. 7/25/98  jjia
    // _stprintf(tchBuf, TEXT("%0.2f"), (double) dwVal / adCSUnitData[pDlgData->iUnit]);

    //
    // Fix MS #23733: PostScript custom page size dialog warns in border cases.
    //
    // Round the number first (2 digits after decimal point), then add 0.001 as explained above.
    //

    dNum = (double) dwVal / adCSUnitData[pDlgData->iUnit] + 0.005;
    dNum = CUSTSIZE_ROUNDDOWN(dNum);

    //
    // Make sure we don't show value outside of the range. This is to take care of rounding errors.
    //

    if (dNum < dMin)
    {
        dNum = dMin;
    }
    else if (dNum > dMax)
    {
        dNum = dMax;
    }

    StringCchPrintfW(tchBuf, CCHOF(tchBuf), TEXT("%ld.%0.2lu"),
                     (DWORD)dNum, (DWORD)((dNum - (DWORD)dNum) * 100.0));

    SetDlgItemText(hDlg, iCtrlID, tchBuf);
}



VOID
VUpdateCustomSizeRangeField(
    HWND             hDlg,
    PCUSTOMSIZEDLG   pDlgData,
    INT              iCtrlID,
    PCUSTOMSIZERANGE pCSRange
    )

/*++

Routine Description:

    Update the custom size parameter range fields:
        width, height, and offsets

Arguments:

    hDlg - Handle to custom page size dialog window
    pDlgData - Points to custom page size dialog data
    iCtrlID - Specifies the interested range field control ID
    pCSRange - custom page size parameter ranges

Return Value:

    NONE

--*/

{
    TCHAR   tchBuf[MAX_DISPLAY_NAME];
    double  dMin, dMax;

    switch (iCtrlID)
    {
    case IDC_CS_WIDTHRANGE:
        pCSRange += CUSTOMPARAM_WIDTH;
        break;

    case IDC_CS_HEIGHTRANGE:
        pCSRange += CUSTOMPARAM_HEIGHT;
        break;

    case IDC_CS_XOFFSETRANGE:
        pCSRange += CUSTOMPARAM_WIDTHOFFSET;
        break;

    case IDC_CS_YOFFSETRANGE:
        pCSRange += CUSTOMPARAM_HEIGHTOFFSET;
        break;
    }

    // Fix bug Adobe #260379. 7/25/98  jjia
    // If we build the driver using public MSVC, MSTOOLS and DDK,
    // the text string will become garbage. So, Don't use '%0.2f'
    // to format numbers.
    //  _stprintf(tchBuf,
    //            TEXT("(%0.2f, %0.2f)"),
    //            (double) pCSRange->dwMin / adCSUnitData[pDlgData->iUnit],
    //            (double) pCSRange->dwMax / adCSUnitData[pDlgData->iUnit]);

    //
    // Fix MS #23733: PostScript custom page size dialog warns in border cases.
    //
    // We only show 2 digits after the decimal point. We round the min
    // number up (ceil) and round the max number down (floor). Also, in
    // order to correct double -> DWORD conversion error we saw in some
    // cases (ex. 39.000 is converted to DWROD 38 since the 39.000 is actually
    // 38.999999...), we add the extra 0.001.
    //

    dMin = (double) pCSRange->dwMin / adCSUnitData[pDlgData->iUnit];
    dMin = CUSTSIZE_ROUNDUP(dMin);

    dMax = (double) pCSRange->dwMax / adCSUnitData[pDlgData->iUnit];
    dMax = CUSTSIZE_ROUNDDOWN(dMax);

    StringCchPrintfW(tchBuf, CCHOF(tchBuf),
                     TEXT("(%ld.%0.2lu, %ld.%0.2lu)"),
                     (DWORD)dMin, (DWORD)((dMin - (DWORD)dMin) * 100.0),
                     (DWORD)dMax, (DWORD)((dMax - (DWORD)dMax) * 100.0));

    SetDlgItemText(hDlg, iCtrlID, tchBuf);
}



VOID
VUpdateCustomSizeDlgFields(
    HWND            hDlg,
    PCUSTOMSIZEDLG  pDlgData,
    BOOL            bUpdateRangeOnly
    )

/*++

Routine Description:

    Update the custom page size dialog controls with
    the current custom page size parameter values

Arguments:

    hDlg - Handle to custom page size dialog window
    pDlgData - Points to custom page size dialog data
    bUpdateRangeOnly - Whether we need to update the range fields only

Return Value:

    NONE

--*/

{
    CUSTOMSIZERANGE csrange[4];

    VGetCustomSizeParamRange(pDlgData->pUiData->ci.pRawData, &pDlgData->csdata, csrange);

    if (! bUpdateRangeOnly)
    {
        //
        // Update the text fields
        //

        pDlgData->bSetText = TRUE;

        VUpdateCustomSizeTextField(hDlg, pDlgData, IDC_CS_WIDTH, csrange);
        VUpdateCustomSizeTextField(hDlg, pDlgData, IDC_CS_HEIGHT, csrange);
        VUpdateCustomSizeTextField(hDlg, pDlgData, IDC_CS_XOFFSET, csrange);
        VUpdateCustomSizeTextField(hDlg, pDlgData, IDC_CS_YOFFSET, csrange);

        pDlgData->bSetText = FALSE;

        //
        // Update the paper feed direction combo box
        //

        ASSERT(pDlgData->aubFD2CBOptionMapping[pDlgData->csdata.wFeedDirection] != INVALID_CBOPTION_INDEX);

        if (SendDlgItemMessage(hDlg,
                               IDC_CS_FEEDDIRECTION,
                               CB_SETCURSEL,
                               pDlgData->aubFD2CBOptionMapping[pDlgData->csdata.wFeedDirection],
                               0) == CB_ERR)
        {
            ERR(("CB_SETCURSEL failed: %d\n", GetLastError()));
        }

        //
        // Update cut-sheet vs. roll-fed radio buttons
        //

        CheckDlgButton(hDlg, IDC_CS_CUTSHEET, pDlgData->csdata.wCutSheet);
        CheckDlgButton(hDlg, IDC_CS_ROLLFED, !pDlgData->csdata.wCutSheet);
    }

    //
    // Update ranges for width, height, and offsets
    //

    VUpdateCustomSizeRangeField(hDlg, pDlgData, IDC_CS_WIDTHRANGE, csrange);
    VUpdateCustomSizeRangeField(hDlg, pDlgData, IDC_CS_HEIGHTRANGE, csrange);
    VUpdateCustomSizeRangeField(hDlg, pDlgData, IDC_CS_XOFFSETRANGE, csrange);
    VUpdateCustomSizeRangeField(hDlg, pDlgData, IDC_CS_YOFFSETRANGE, csrange);
}



BOOL
BGetWidthHeightOffsetVal(
    HWND            hDlg,
    PCUSTOMSIZEDLG  pDlgData,
    INT             iCtrlID,
    PDWORD          pdwVal
    )

/*++

Routine Description:

    Get the current width/height/offset value in the specified text field

Arguments:

    hDlg - Handle to custom page size dialog window
    pDlgData - Points to custom page size dialog data
    iCtrlID - Specifies the interested text field control ID
    pdwVal - Return the current value in the specified text field (in microns)

Return Value:

    TRUE if successful, FALSE if the text field doesn't contain
    valid floating-point number.

    Note that this function doesn't perform any range check.
    That's done in a later step.

--*/

{
    TCHAR   tchBuf[MAXDIGITLEN];
    double  d;
    PTSTR   ptstr;
    BOOL    bResult = FALSE;

    //
    // Get the current value in the speicified text field
    //

    if (GetDlgItemText(hDlg, iCtrlID, tchBuf, MAXDIGITLEN) > 0)
    {
        //
        // Treat the string as floating-point number
        // Make sure there are no non-space characters left
        //

        d = _tcstod(tchBuf, &ptstr);

        while (*ptstr != NUL)
        {
            if (! _istspace(*ptstr))
                break;

            ptstr++;
        }

        if (bResult = (*ptstr == NUL))
        {
            //
            // Convert from current unit to microns
            //

            d *= adCSUnitData[pDlgData->iUnit];

            if (d < 0 || d > MAX_LONG)
                bResult = FALSE;
            else
                *pdwVal = (DWORD) d;
        }
    }

    if (!bResult)
    {
        //
        // automatically correct user's invalid input to value 0.00
        //

        SetDlgItemText(hDlg, iCtrlID, TEXT("0.00"));

        *pdwVal = 0;
    }

    return TRUE;
}



BOOL
BGetFeedDirectionSel(
    HWND            hDlg,
    PCUSTOMSIZEDLG  pDlgData,
    INT             iCtrlID,
    PDWORD          pdwVal
    )

/*++

Routine Description:

    Get the currently selected paper direction value

Arguments:

    hDlg - Handle to custom page size dialog window
    pDlgData - Points to custom page size dialog data
    iCtrlID - Specifies the paper feed direction combo box control ID
    pdwVal - Return the selected paper feed direction value

Return Value:

    TRUE if successful, FALSE if the selected choice is constrained
    or if there is an error

--*/

{
    LRESULT    lIndex, lVal;

    //
    // Get the currently chosen paper feed direction index
    //

    if (((lIndex = SendDlgItemMessage(hDlg, iCtrlID, CB_GETCURSEL, 0, 0)) == CB_ERR) ||
        ((lVal = SendDlgItemMessage(hDlg, iCtrlID, CB_GETITEMDATA, (WPARAM)lIndex, 0)) == CB_ERR))
        return FALSE;

    *pdwVal = (DWORD)lVal;
    return TRUE;
}



BOOL
BChangeCustomSizeData(
    HWND            hDlg,
    PCUSTOMSIZEDLG  pDlgData,
    INT             iCtrlID,
    DWORD           dwVal
    )

/*++

Routine Description:

    Change the specified custom page size parameter

Arguments:

    hDlg - Handle to custom page size dialog window
    pDlgData - Points to custom page size dialog data
    iCtrlID - Control ID indicating which parameter should be changed
    dwVal - New value for the specified parameter

Return Value:

    TRUE

--*/

{
    PCUSTOMSIZEDATA pCSData;

    //
    // Update the appropriate custom page size parameter
    //

    pCSData = &pDlgData->csdata;

    switch (iCtrlID)
    {
    case IDC_CS_WIDTH:
        pCSData->dwX = dwVal;
        break;

    case IDC_CS_HEIGHT:
        pCSData->dwY = dwVal;
        break;

    case IDC_CS_XOFFSET:
        pCSData->dwWidthOffset = dwVal;
        break;

    case IDC_CS_YOFFSET:
        pCSData->dwHeightOffset = dwVal;
        break;

    case IDC_CS_FEEDDIRECTION:
        pCSData->wFeedDirection = (WORD)dwVal;
        break;

    case IDC_CS_CUTSHEET:
        pCSData->wCutSheet = TRUE;
        return TRUE;

    case IDC_CS_ROLLFED:
        pCSData->wCutSheet = FALSE;
        return TRUE;
    }

    VUpdateCustomSizeDlgFields(hDlg, pDlgData, TRUE);
    return TRUE;
}



VOID
VInitPaperFeedDirectionList(
    HWND            hwndList,
    PCUSTOMSIZEDLG  pDlgData
    )

/*++

Routine Description:

    Initialize the paper feed direction combo box

Arguments:

    hwndList - Window handle to the paper feed direction combo box
    pDlgData - Points to custom page size dialog data

Return Value:

    NONE

--*/

{
    PUIINFO    pUIInfo;
    PPPDDATA   pPpdData;
    DWORD      dwIndex;
    TCHAR      tchBuf[MAX_DISPLAY_NAME];
    LRESULT    lIndex;

    if (hwndList == NULL)
        return;

    ASSERT(pDlgData);

    pUIInfo = pDlgData->pUiData->ci.pUIInfo;
    pPpdData = pDlgData->pPpdData;

    ASSERT(pUIInfo && pPpdData);

    for (dwIndex=0; dwIndex < MAX_FEEDDIRECTION; dwIndex++)
    {
        //
        // First: initialize the mapping table
        //

        pDlgData->aubFD2CBOptionMapping[dwIndex] = INVALID_CBOPTION_INDEX;

        //
        // Don't show the feeding direction if device doesn't supported it.
        //

        if ((dwIndex == LONGEDGEFIRST || dwIndex == LONGEDGEFIRST_FLIPPED) &&
            !LONGEDGEFIRST_SUPPORTED(pUIInfo, pPpdData))
            continue;

        if ((dwIndex == SHORTEDGEFIRST || dwIndex == SHORTEDGEFIRST_FLIPPED) &&
            !SHORTEDGEFIRST_SUPPORTED(pUIInfo, pPpdData))
            continue;

        if ((dwIndex == LONGEDGEFIRST || dwIndex == SHORTEDGEFIRST) &&
            (MINCUSTOMPARAM_ORIENTATION(pPpdData) > 1))
            continue;

        if ((dwIndex == LONGEDGEFIRST_FLIPPED || dwIndex == SHORTEDGEFIRST_FLIPPED) &&
            (MAXCUSTOMPARAM_ORIENTATION(pPpdData) < 2))
            continue;

        if (LoadString(ghInstance,
                       IDS_FEEDDIRECTION_BASE + dwIndex,
                       tchBuf,
                       MAX_DISPLAY_NAME))
        {
            if (((lIndex = SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) tchBuf)) == CB_ERR) ||
                (SendMessage(hwndList, CB_SETITEMDATA, (WPARAM)lIndex, (LPARAM)dwIndex) == CB_ERR))
            {
                if (lIndex != CB_ERR)
                {
                    SendMessage(hwndList, CB_DELETESTRING, (WPARAM)lIndex, 0);
                    ERR(("CB_SETITEMDATA failed: %d\n", GetLastError()));
                }
                else
                {
                    ERR(("CB_ADDSTRING failed: %d\n", GetLastError()));
                }
            }
            else
            {
                //
                // Record the mapping from feed direction to combo box option index.
                // Note that the combo box can NOT be sorted.
                //

                pDlgData->aubFD2CBOptionMapping[dwIndex] = (BYTE)lIndex;
            }
        }
    }
}



BOOL
BCheckCustomSizeData(
    HWND            hDlg,
    PCUSTOMSIZEDLG  pDlgData
    )

{
    CUSTOMSIZEDATA  csdata;
    INT             iCtrlID;

    //
    // If there is no inconsistency, return TRUE
    //

    csdata = pDlgData->csdata;

    if (BValidateCustomPageSizeData(pDlgData->pUiData->ci.pRawData, &csdata))
        return TRUE;

    //
    // Otherwise, indicate which field is invalid
    //

    if (hDlg != NULL)
    {
        if (csdata.dwX != pDlgData->csdata.dwX)
            iCtrlID = IDC_CS_WIDTH;
        else if (csdata.dwY != pDlgData->csdata.dwY)
            iCtrlID = IDC_CS_HEIGHT;
        else if (csdata.dwWidthOffset != pDlgData->csdata.dwWidthOffset)
            iCtrlID = IDC_CS_XOFFSET;
        else if (csdata.dwHeightOffset != pDlgData->csdata.dwHeightOffset)
            iCtrlID = IDC_CS_YOFFSET;
        else if (csdata.wFeedDirection != pDlgData->csdata.wFeedDirection)
            iCtrlID = IDC_CS_FEEDDIRECTION;
        else
            iCtrlID = IDC_CS_CUTSHEET;

        SetFocus(GetDlgItem(hDlg, iCtrlID));

        if (iCtrlID == IDC_CS_WIDTH ||
            iCtrlID == IDC_CS_HEIGHT ||
            iCtrlID == IDC_CS_XOFFSET ||
            iCtrlID == IDC_CS_YOFFSET)
        {
            SendDlgItemMessage(hDlg, iCtrlID, EM_SETSEL, 0, -1);
        }
    }

    return FALSE;
}


BOOL
BCheckCustomSizeFeature(
    HWND            hDlg,
    PCUSTOMSIZEDLG  pDlgData,
    DWORD           dwFeatureID
    )

{
    PUIINFO         pUIInfo;
    PPPDDATA        pPpdData;
    PFEATURE        pFeature;
    DWORD           dwFeatureIndex, dwOptionIndex;
    CONFLICTPAIR    ConflictPair;

    //
    // If the specified feature doesn't exist, simply return TRUE
    //

    pUIInfo = pDlgData->pUiData->ci.pUIInfo;

    if (! (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, dwFeatureID)))
        return TRUE;

    dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);
    pPpdData = pDlgData->pPpdData;

    if (dwFeatureID == GID_LEADINGEDGE)
    {
        if (SKIP_LEADINGEDGE_CHECK(pUIInfo, pPpdData))
            return TRUE;

        dwOptionIndex = (pDlgData->csdata.wFeedDirection == SHORTEDGEFIRST ||
                         pDlgData->csdata.wFeedDirection == SHORTEDGEFIRST_FLIPPED) ?
                                pPpdData->dwLeadingEdgeShort :
                                pPpdData->dwLeadingEdgeLong;

        if (dwOptionIndex == OPTION_INDEX_ANY)
        {
            goto error;
        }
    }
    else // (dwFeatureID == GID_USEHWMARGINS)
    {
        dwOptionIndex = pDlgData->csdata.wCutSheet ?
                                pPpdData->dwUseHWMarginsTrue :
                                pPpdData->dwUseHWMarginsFalse;
    }

    //
    // Return TRUE if there is no conflict. This is opposite of
    // EnumNewPickOneUIConflict which returns TRUE if there is a conflict.
    //

    if (! EnumNewPickOneUIConflict(
                    pDlgData->pUiData->ci.pRawData,
                    pDlgData->pUiData->ci.pCombinedOptions,
                    dwFeatureIndex,
                    dwOptionIndex,
                    &ConflictPair))
    {
        return TRUE;
    }

    error:

    if (hDlg != NULL)
    {
        SetFocus(GetDlgItem(hDlg,
                            dwFeatureID == GID_LEADINGEDGE ?
                                IDC_CS_FEEDDIRECTION :
                                IDC_CS_CUTSHEET));
    }

    return FALSE;
}


BOOL
BResolveCustomSizeData(
    HWND            hDlg,
    PCUSTOMSIZEDLG  pDlgData
    )

{
    PRAWBINARYDATA  pRawData;
    CUSTOMSIZEDATA  cssave;
    PCUSTOMSIZEDATA pCSData;

    pRawData = pDlgData->pUiData->ci.pRawData;
    cssave = pDlgData->csdata;
    pCSData = &pDlgData->csdata;

    //
    // Choose alternative wCutSheet and wFeedDirection
    // value if the current value is constrained.
    //

    if (! BCheckCustomSizeFeature(hDlg, pDlgData, GID_USEHWMARGINS))
        pCSData->wCutSheet = pCSData->wCutSheet ? FALSE : TRUE;

    if (! BCheckCustomSizeFeature(hDlg, pDlgData, GID_LEADINGEDGE))
    {
       pCSData->wFeedDirection =
            (pCSData->wFeedDirection == SHORTEDGEFIRST ||
             pCSData->wFeedDirection == SHORTEDGEFIRST_FLIPPED) ?
                LONGEDGEFIRST : SHORTEDGEFIRST;
    }

    //
    // Check to see if the specified custom page size parameters are consistent
    //

    (VOID) BValidateCustomPageSizeData(pRawData, pCSData);

    if (pCSData->dwX != cssave.dwX || pCSData->dwY != cssave.dwY)
    {
        CUSTOMSIZEDATA  cstemp;

        //
        // If the width or height parameter is adjusted,
        // try to adjust the feed direction parameter first
        //

        cstemp = *pCSData;
        *pCSData = cssave;
        pCSData->wCutSheet = cstemp.wCutSheet;

        pCSData->wFeedDirection =
            (cstemp.wFeedDirection == SHORTEDGEFIRST ||
             cstemp.wFeedDirection == SHORTEDGEFIRST_FLIPPED) ?
                LONGEDGEFIRST : SHORTEDGEFIRST;

        (VOID) BValidateCustomPageSizeData(pRawData, pCSData);

        if (pCSData->dwX != cssave.dwX ||
            pCSData->dwY != cssave.dwY ||
            !BCheckCustomSizeFeature(hDlg, pDlgData, GID_LEADINGEDGE))
        {
            *pCSData = cstemp;
        }
    }

    if ((hDlg != NULL) &&
        (!BCheckCustomSizeFeature(hDlg, pDlgData, GID_USEHWMARGINS) ||
         !BCheckCustomSizeFeature(hDlg, pDlgData, GID_LEADINGEDGE)))
    {
        *pCSData = cssave;
        return FALSE;
    }

    return TRUE;
}


BOOL
BCheckCustomSizeDataConflicts(
    HWND            hDlg,
    PCUSTOMSIZEDLG  pDlgData
    )

/*++

Routine Description:

    Resolve any conflicts involving *LeadingEdge and *UseHWMargins
    and any inconsistencies between custom page size parameters

Arguments:

    hDlg - Handle to custom page size dialog window
        NULL if the window is not displayed yet
    pDlgData - Points to custom page size dialog data

Return Value:

    FALSE if there are any unresolved conflicts or inconsistencies,
    TRUE otherwise

--*/

{
    BOOL bResult;

    //
    // Check if there is any inconsistency
    //

    bResult = BCheckCustomSizeFeature(hDlg, pDlgData, GID_LEADINGEDGE) &&
              BCheckCustomSizeFeature(hDlg, pDlgData, GID_USEHWMARGINS) &&
              BCheckCustomSizeData(hDlg, pDlgData);

    if (! bResult)
    {
        //
        // Display an error message and ask the user whether he wants
        // to let the system automatically resolve the inconsistency.
        //

        if (hDlg == NULL ||
            IDisplayErrorMessageBox(hDlg,
                                    MB_OKCANCEL | MB_ICONERROR,
                                    IDS_CUSTOMSIZE_ERROR,
                                    IDS_CUSTOMSIZEPARAM_ERROR) == IDOK)
        {
            bResult = BResolveCustomSizeData(hDlg, pDlgData);

            if (!bResult && hDlg != NULL)
            {
                (VOID) IDisplayErrorMessageBox(
                            hDlg,
                            0,
                            IDS_CUSTOMSIZE_ERROR,
                            IDS_CUSTOMSIZE_UNRESOLVED);
            }
        }
    }

    return bResult;
}



INT_PTR CALLBACK
BCustomSizeDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for custom page size dialog

Arguments:

    hDlg - Handle to dialog window
    uMsg - Message
    wParam, lParam - Parameters

Return Value:

    TRUE or FALSE depending on whether message is processed

--*/

{
    PCUSTOMSIZEDLG  pDlgData;
    INT             iCmd;
    DWORD           dwVal;

    switch (uMsg)
    {
    case WM_INITDIALOG:

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lParam);
        pDlgData = (PCUSTOMSIZEDLG) lParam;

        if (pDlgData == NULL)
        {
            RIP(("Dialog parameter is NULL\n"));
            EndDialog(hDlg, IDCANCEL);
            return FALSE;
        }

        SendDlgItemMessage(hDlg, IDC_CS_WIDTH, EM_SETLIMITTEXT, MAXDIGITLEN-1, 0);
        SendDlgItemMessage(hDlg, IDC_CS_HEIGHT, EM_SETLIMITTEXT, MAXDIGITLEN-1, 0);
        SendDlgItemMessage(hDlg, IDC_CS_XOFFSET, EM_SETLIMITTEXT, MAXDIGITLEN-1, 0);
        SendDlgItemMessage(hDlg, IDC_CS_YOFFSET, EM_SETLIMITTEXT, MAXDIGITLEN-1, 0);

        pDlgData->iUnit = pDlgData->bMetric ? CSUNIT_MM : CSUNIT_INCH;
        CheckRadioButton(hDlg, IDC_CS_INCH, IDC_CS_POINT, IDC_CS_INCH + pDlgData->iUnit);

        //
        // Determine which feed directions should be disabled
        //

        VInitPaperFeedDirectionList(GetDlgItem(hDlg, IDC_CS_FEEDDIRECTION), pDlgData);

        //
        // Set up the initial display
        //

        if (! (pDlgData->pPpdData->dwCustomSizeFlags & CUSTOMSIZE_CUTSHEET))
            EnableWindow(GetDlgItem(hDlg, IDC_CS_CUTSHEET), FALSE);

        if (! (pDlgData->pPpdData->dwCustomSizeFlags & CUSTOMSIZE_ROLLFED))
            EnableWindow(GetDlgItem(hDlg, IDC_CS_ROLLFED), FALSE);

        VUpdateCustomSizeDlgFields(hDlg, pDlgData, FALSE);
        ShowWindow(hDlg, SW_SHOW);
        break;

    case WM_COMMAND:

        pDlgData = (PCUSTOMSIZEDLG) GetWindowLongPtr(hDlg, DWLP_USER);

        if (pDlgData == NULL)
        {
            RIP(("Dialog parameter is NULL\n"));
            break;
        }

        iCmd = GET_WM_COMMAND_ID(wParam, lParam);

        switch (iCmd)
        {
        case IDOK:

            //
            // Check if the selected paper feed direction is constrained
            //

            if (BCheckCustomSizeDataConflicts(hDlg, pDlgData))
            {
                pDlgData->bOKPassed = TRUE;
                EndDialog(hDlg, IDOK);
            }

            return TRUE;

        case IDCANCEL:

            EndDialog(hDlg, IDCANCEL);
            return TRUE;

        case IDC_RESTOREDEFAULTS:

            //
            // Use default custom page size parameters
            //

            VFillDefaultCustomPageSizeData(
                    pDlgData->pUiData->ci.pRawData,
                    &pDlgData->csdata,
                    pDlgData->bMetric);

            VUpdateCustomSizeDlgFields(hDlg, pDlgData, FALSE);
            return TRUE;

        case IDC_CS_INCH:
        case IDC_CS_MM:
        case IDC_CS_POINT:

            //
            // Change display unit
            //

            pDlgData->iUnit = (iCmd == IDC_CS_INCH) ? CSUNIT_INCH :
                              (iCmd == IDC_CS_MM) ? CSUNIT_MM : CSUNIT_POINT;

            VUpdateCustomSizeDlgFields(hDlg, pDlgData, FALSE);
            return TRUE;

        case IDC_CS_WIDTH:
        case IDC_CS_HEIGHT:
        case IDC_CS_XOFFSET:
        case IDC_CS_YOFFSET:

            if (GET_WM_COMMAND_CMD(wParam, lParam) != EN_KILLFOCUS ||
                pDlgData->bSetText ||
                pDlgData->bOKPassed)
            {
                break;
            }

            if (! BGetWidthHeightOffsetVal(hDlg, pDlgData, iCmd, &dwVal) ||
                ! BChangeCustomSizeData(hDlg, pDlgData, iCmd, dwVal))
            {
                VUpdateCustomSizeDlgFields(hDlg, pDlgData, FALSE);
                SetFocus(GetDlgItem(hDlg, iCmd));
                SendDlgItemMessage(hDlg, iCmd, EM_SETSEL, 0, -1);
            }
            return TRUE;

        case IDC_CS_FEEDDIRECTION:

            if (GET_WM_COMMAND_CMD(wParam, lParam) != CBN_SELCHANGE)
                break;

            if (! BGetFeedDirectionSel(hDlg, pDlgData, iCmd, &dwVal) ||
                ! BChangeCustomSizeData(hDlg, pDlgData, iCmd, dwVal))
            {
                VUpdateCustomSizeDlgFields(hDlg, pDlgData, FALSE);
                SetFocus(GetDlgItem(hDlg, iCmd));
            }
            return TRUE;

        case IDC_CS_CUTSHEET:
        case IDC_CS_ROLLFED:

            BChangeCustomSizeData(hDlg, pDlgData, iCmd, 0);
            return TRUE;
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        //
        // Sanity check
        //

        pDlgData = (PCUSTOMSIZEDLG) GetWindowLongPtr(hDlg, DWLP_USER);

        if (pDlgData == NULL ||
            pDlgData->pUiData->ci.pDriverInfo3->pHelpFile == NULL)
        {
            return FALSE;
        }

        if (uMsg == WM_HELP)
        {
            WinHelp(((LPHELPINFO) lParam)->hItemHandle,
                    pDlgData->pUiData->ci.pDriverInfo3->pHelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)PSCustSizeHelpIDs);
        }
        else
        {
            WinHelp((HWND) wParam,
                    pDlgData->pUiData->ci.pDriverInfo3->pHelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)PSCustSizeHelpIDs);
        }

        return TRUE;
    }

    return FALSE;
}



BOOL
BDisplayPSCustomPageSizeDialog(
    PUIDATA pUiData
    )

/*++

Routine Description:

    Display PostScript custom page size dialog

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if user pressed OK, FALSE otherwise

--*/

{
    CUSTOMSIZEDLG   dlgdata;
    PPSDRVEXTRA     pdmPrivate;

    ZeroMemory(&dlgdata, sizeof(dlgdata));

    dlgdata.pUiData = pUiData;
    dlgdata.pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pUiData->ci.pRawData);
    dlgdata.bMetric = IsMetricCountry();

    ASSERT(SUPPORT_CUSTOMSIZE(pUiData->ci.pUIInfo) &&
           SUPPORT_FULL_CUSTOMSIZE_FEATURES(pUiData->ci.pUIInfo, dlgdata.pPpdData));

    //
    // Make sure the custom page size devmode fields are validated
    //

    pdmPrivate = pUiData->ci.pdmPrivate;
    dlgdata.csdata = pdmPrivate->csdata;

    (VOID) BCheckCustomSizeDataConflicts(NULL, &dlgdata);

    pdmPrivate->csdata = dlgdata.csdata;

    //
    // Display the custom page size dialog.
    // If the user pressed OK, update the devmode fields again.
    //

    if (DialogBoxParam(ghInstance,
                       MAKEINTRESOURCE(IDD_PSCRIPT_CUSTOMSIZE),
                       pUiData->hDlg,
                       BCustomSizeDlgProc,
                       (LPARAM) &dlgdata) == IDOK)
    {
        pdmPrivate->csdata = dlgdata.csdata;
        return TRUE;
    }
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\upgrade.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    upgrade.c

Abstract:

    This file handles the DrvUpgradePrinter spooler API

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/13/97 -davidx-
        Implement OEM plugin support.

    02/06/97 -davidx-
        Rewrote it to use common data management functions.

    07/17/96 -amandan-
        Created it.

--*/

#include "precomp.h"

//
// Forward and external function declarations
//

BOOL BInitOrUpgradePrinterProperties(PCOMMONINFO);
BOOL BUpgradeFormTrayTable(PCOMMONINFO);
VOID VUpgradeDefaultDevmode(PCOMMONINFO);

#if defined(UNIDRV) && !defined(WINNT_40)
BOOL
BUpgradeSoftFonts(
    PCOMMONINFO             pci,
    PDRIVER_UPGRADE_INFO_2  pUpgradeInfo);
#endif //defined(UNIDRV) && !defined(WINNT_40)



BOOL
DrvUpgradePrinter(
    DWORD   dwLevel,
    LPBYTE  pDriverUpgradeInfo
    )
/*++

Routine Description:

    This function is called by the spooler everytime a new driver
    is copied to the system.  This function checks for appropriate
    registry keys in the registry.  If the new registry keys are not
    present, it will set the new keys with default values.  This function
    will handle the upgrading of information in the registry to the new driver format.

Arguments:

    dwLevel - version info for DRIVER_UPGRADE_INFO
    pDriverUpgradeInfo - pointer to DRIVER_UPGRADE_INFO_1

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    PDRIVER_UPGRADE_INFO_1  pUpgradeInfo1 = (PDRIVER_UPGRADE_INFO_1) pDriverUpgradeInfo;
    PCOMMONINFO             pci;
    BOOL                    bResult = TRUE;
    DWORD                   dwSize, dwType = REG_SZ;
    PFN_OEMUpgradePrinter   pfnOEMUpgradePrinter;
    PFN_OEMUpgradeRegistry  pfnOEMUpgradeRegistry;

    //
    // Verify the validity of input parameters
    //


    if (pDriverUpgradeInfo == NULL)
    {
        ERR(("Invalid DrvUpgradePrinter parameters.\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    #if  defined(WINNT_40)
    if (dwLevel != 1 )
    {
        ERR(("DrvUpgradePrinter...dwLevel != 1\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    #else // NT 5.0
    if (dwLevel != 1 && dwLevel != 2)
    {
        WARNING(("Level is neither 1 nor 2.\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    #endif // defined(WINNT_40)


    //
    // Open the printer with administrator access
    // and load basic printer information
    //

    pci = PLoadCommonInfo(NULL,
                          pUpgradeInfo1->pPrinterName,
                          FLAG_OPENPRINTER_ADMIN |
                          FLAG_INIT_PRINTER |
                          FLAG_REFRESH_PARSED_DATA |
                          FLAG_UPGRADE_PRINTER);

    if (pci == NULL)
    {
        ERR(("DrvUpgradePrinter..pci==NULL.\n"));
        return FALSE;
    }

    //
    // Update printer properties information
    //

    (VOID) BInitOrUpgradePrinterProperties(pci);
    (VOID) BUpgradeFormTrayTable(pci);

    VUpgradeDefaultDevmode(pci);

    #ifndef WINNT_40

    VNotifyDSOfUpdate(pci->hPrinter);

    #endif // !WINNT_40


    #if defined(UNIDRV) && !defined(WINNT_40)

    //
    // NT 5.0 UniDriver specific upgrade steps
    //

    //
    // Make sure that the DRIVER_UPGRADE_INFO's level is 2.
    //

    if (dwLevel == 2)
    {
        BUpgradeSoftFonts(pci, (PDRIVER_UPGRADE_INFO_2)pUpgradeInfo1);
    }

    #endif //defined(UNIDRV) && !defined(WINNT_40)

    //
    // call OEMUpgradePrinter entrypoint for each plugin
    //

    FOREACH_OEMPLUGIN_LOOP(pci)

        if (HAS_COM_INTERFACE(pOemEntry))
        {
            //
            // If the OEM does not implement upgradeprinter, then they
            // cannot support upgraderegistry since you can only upgrade
            // registry if you support upgradeprinter.
            //

            HRESULT hr;

            hr = HComOEMUpgradePrinter(pOemEntry,
                                       dwLevel,
                                       pDriverUpgradeInfo) ;

            if (hr == E_NOTIMPL)
                continue;

            bResult = SUCCEEDED(hr);

        }
        else
        {

            if ((pfnOEMUpgradePrinter = GET_OEM_ENTRYPOINT(pOemEntry, OEMUpgradePrinter)) &&
                !pfnOEMUpgradePrinter(dwLevel, pDriverUpgradeInfo))
            {
                ERR(("OEMUpgradePrinter failed for '%ws': %d\n",
                    CURRENT_OEM_MODULE_NAME(pOemEntry),
                    GetLastError()));

                bResult = FALSE;
            }

            if ((pfnOEMUpgradeRegistry = GET_OEM_ENTRYPOINT(pOemEntry, OEMUpgradeRegistry)) &&
                !pfnOEMUpgradeRegistry(dwLevel, pDriverUpgradeInfo, BUpgradeRegistrySettingForOEM))
            {
                ERR(("OEMUpgradeRegistry failed for '%ws': %d\n",
                    CURRENT_OEM_MODULE_NAME(pOemEntry),
                    GetLastError()));

                bResult = FALSE;
            }

        }
    END_OEMPLUGIN_LOOP

    VFreeCommonInfo(pci);
    return bResult;
}



BOOL
BUpgradeFormTrayTable(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Upgrade the form-to-tray assignment table in the registry

Arguments:

    pci - Points to basic printer information

Return Value:

    TRUE if upgrade is successful, FALSE otherwise

--*/

{
    PWSTR   pFormTrayTable;
    DWORD   dwSize;
    BOOL    bResult;

    //
    // Get a copy of the current form-to-tray assignment table.
    // If new format data is not present but old format data is,
    // this will call the appropriate library function to convert
    // old format data to new format.
    //

    pFormTrayTable = PGetFormTrayTable(pci->hPrinter, &dwSize);

    if (pFormTrayTable == NULL)
        return TRUE;

    //
    // Save the form-to-tray assignment table back to registry
    //

    bResult = BSaveFormTrayTable(pci->hPrinter, pFormTrayTable, dwSize);
    MemFree(pFormTrayTable);

    return bResult;
}



VOID
VUpgradeDefaultDevmode(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Upgrade the default printer devmode, if necessary

Arguments:

    pci - Points to basic printer information

Return Value:

    NONE

--*/

{
    PPRINTER_INFO_2 pPrinterInfo2;
    PDEVMODE        pdm;

    if ((pPrinterInfo2 = MyGetPrinter(pci->hPrinter, 2)) &&
        (pdm = pPrinterInfo2->pDevMode) &&
        BFillCommonInfoDevmode(pci, pdm, NULL) &&
        (pci->pdm->dmSpecVersion != pdm->dmSpecVersion ||
         pci->pdm->dmDriverVersion != pdm->dmDriverVersion ||
         pci->pdm->dmSize != pdm->dmSize ||
         pci->pdm->dmDriverExtra != pdm->dmDriverExtra))
    {
        pPrinterInfo2->pDevMode = pci->pdm;
        SetPrinter(pci->hPrinter, 2, (PBYTE) pPrinterInfo2, 0);
    }

    MemFree(pPrinterInfo2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\uihelp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    uihelp.h

Abstract:

    DriverUI driver help indices

[Environment:]

        Win32 subsystem, PostScript driver

Revision History:

        10/05/95 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _UIHELP_H_
#define _UIHELP_H_

////////////////////////////////////
// For document properties dialog //
////////////////////////////////////

// Select page orientation
//  Portrait
//  Landscape (90 degrees clockwise)
//  Rotated landscape (90 degrees counterclockwise)

#define HELP_INDEX_ORIENTATION          1001

// Select scale factor (1-1000%)

#define HELP_INDEX_SCALE                1002

// Select number of copies to print. Also decide whether to turn on
// collation if more than one copy is requested and the printer
// supports collation.

#define HELP_INDEX_COPIES_COLLATE       1003

// Select color or monochrome option

#define HELP_INDEX_COLOR                1004

// Bring up halftone color adjustment dialog

#define HELP_INDEX_HALFTONE_COLORADJ    1005

// Select duplex options
//  Simplex / None
//  Horizontal / Tumble
//  Vertical / NoTuble

#define HELP_INDEX_DUPLEX               1006

// Select output resolution

#define HELP_INDEX_RESOLUTION           1007

// Select input slot

#define HELP_INDEX_INPUT_SLOT           1008

// Select a form to use

#define HELP_INDEX_FORMNAME             1009

// Select TrueType font options
//  Substitute TrueType font with device font
//      (according to the font substitution table)
//  Download TrueType font to the printer as softfont

#define HELP_INDEX_TTOPTION             1010

// Enable/Disable metafile spooling

#define HELP_INDEX_METAFILE_SPOOLING    1011

// Select PostScript options

#define HELP_INDEX_PSOPTIONS            1012

// Whether the output is mirrored

#define HELP_INDEX_MIRROR               1013

// Whether the output is printed negative

#define HELP_INDEX_NEGATIVE             1014

// Whether to keep the output pages independent of each other.
// This is normally turned off when you're printing directly
// to a printer. But if you're generating PostScript output
// files and doing post-processing on it, you should turn on
// this option.

#define HELP_INDEX_PAGEINDEP            1015

// Whether to compress bitmaps (only available on level 2 printers)

#define HELP_INDEX_COMPRESSBMP          1016

// Whether to prepend a ^D character before each job

#define HELP_INDEX_CTRLD_BEFORE         1017

// Whether to append a ^D character after each job

#define HELP_INDEX_CTRLD_AFTER          1018

// Select printer-specific features

#define HELP_INDEX_PRINTER_FEATURES     1019

///////////////////////////////////
// For printer properties dialog //
///////////////////////////////////

// Set amount of PostScript virtual memory
//  This is different from the total amount of printer memory.
//  For example, a printer might have 4MB RAM, but the amount
//  allocated for printer VM could be 700KB.
//  Most of the time, you don't have to enter the number yourself.
//  PS driver can figure it out from the PPD file. Or if there
//  is an installable option for printer memory configurations,
//  choose it there and a correct number will be filled in.

#define HELP_INDEX_PRINTER_VM           1020

// Whether to do halftone on the host computer or do it inside
// the printer. For PostScript printers, this should always be
// left at the default setting, i.e. to let the printer do the
// halftone.

#define HELP_INDEX_HOST_HALFTONE        1021

// Bring up halftone setup dialog

#define HELP_INDEX_HALFTONE_SETUP       1022

// Ignore device fonts
//  This option is only available on non-1252 code page systems.
//  Since fonts on most printers used 1252 code page, you can't
//  use them with non-1252 systems.

#define HELP_INDEX_IGNORE_DEVFONT       1023

// Font substitution option
//  This option is only available on 1252 code page systems.
//  You should leave it at the default setting "Normal".
//  If you notice character spacing problems in your text output,
//  you can try to set it to "Slower but more accurate". This
//  will direct the driver to place each character invididually,
//  resulting in more accurate character positioning.

#define HELP_INDEX_FONTSUB_OPTION       1024

// Edit TrueType font substitution table

#define HELP_INDEX_FONTSUB_TABLE        1025

// Substitute a TrueType with a device font.

#define HELP_INDEX_TTTODEV              1026

// Edit form-to-tray assignment table

#define HELP_INDEX_FORMTRAYASSIGN       1027

// Assign a form to a tray. If "Draw selected form only from this tray"
// is checked, then any time the user requests for the selected form,
// it will be drawn from this tray.

#define HELP_INDEX_TRAY_ITEM            1028

// Set PostScript timeout values

#define HELP_INDEX_PSTIMEOUTS           1029

// Set PostScript job timeout value
//  Number of seconds a job is allowed to run on the printer
//  before it's automatically terminated. This is to prevent
//  run-away jobs from tying up the printer indefinitely.
//  Set it to 0 if jobs are allowed to run forever.

#define HELP_INDEX_JOB_TIMEOUT          1030

// Set PostScript wait timeout value
//  Number of seconds the printer will wait for data before it
//  considers a job is completed. This is intended for non-network
//  communication channels such as serial or parallel ports where
//  there is no job control protocol.

#define HELP_INDEX_WAIT_TIMEOUT         1031

// Configure printer installable options

#define HELP_INDEX_INSTALLABLE_OPTIONS  1032

// Whether to generate job control code in the output

#define HELP_INDEX_JOB_CONTROL          1033

// Text as Graphics
#define HELP_INDEX_TEXTASGRX            1034

// Page Protection
#define HELP_INDEX_PAGE_PROTECT         1035

// Media Type
#define HELP_INDEX_MEDIA_TYPE           1036

// Font cartridges
#define HELP_INDEX_FONTSLOT_TYPE        1037

// Color Mode
#define  HELP_INDEX_COLORMODE_TYPE      1038

// Halftoning
#define  HELP_INDEX_HALFTONING_TYPE     1039

// PostScript communication protocol

#define HELP_INDEX_PSPROTOCOL           1040


// Download PostScript error handler with each job

#define HELP_INDEX_PSERROR_HANDLER      1042

// Minimum font size to download as outline

#define HELP_INDEX_PSMINOUTLINE         1043

// Maximum font size to download as bitmap

#define HELP_INDEX_PSMAXBITMAP          1044

// PostScript output option

#define HELP_INDEX_PSOUTPUT_OPTION      1045

// PostScript TrueType download option

#define HELP_INDEX_PSTT_DLFORMAT        1046

// N-up option

#define HELP_INDEX_NUPOPTION            1047

// PostScript language level

#define HELP_INDEX_PSLEVEL              1048

// ICM methods

#define HELP_INDEX_ICMMETHOD            1049

// ICM intents

#define HELP_INDEX_ICMINTENT            1050

// Reverse-order printing option

#define HELP_INDEX_REVPRINT             1051

// Quality Macro settings

#define HELP_INDEX_QUALITY_SETTINGS     1052

// Soft font settings

#define HELP_INDEX_SOFTFONT_SETTINGS    1053

// Soft font dialog help

#define HELP_INDEX_SOFTFONT_DIALOG      1054

// Whether to detect TrueGray

#define HELP_INDEX_TRUE_GRAY_TEXT       1055
#define HELP_INDEX_TRUE_GRAY_GRAPH      1056

// Whether to augment device fonts with the Euro character

#define HELP_INDEX_ADD_EURO             1057

//
// Help indices for PostScript custom page size dialog
//

#define IDH_PSCUST_Width                2000
#define IDH_PSCUST_Height               2010
#define IDH_PSCUST_Unit_Inch            2020
#define IDH_PSCUST_Unit_Millimeter      2030
#define IDH_PSCUST_Unit_Point           2040
#define IDH_PSCUST_PaperFeed_Direction  2050
#define IDH_PSCUST_Paper_CutSheet       2060
#define IDH_PSCUST_Paper_RollFeed       2070
#define IDH_PSCUST_Offset_Perpendicular 2080
#define IDH_PSCUST_Offset_Parallel      2090
#define IDH_PSCUST_OK                   2100
#define IDH_PSCUST_Cancel               2110
#define IDH_PSCUST_Restore_Defaults     2120


//
// Help indices for Unidrv Font Installer dialog
//

#define IDH_SOFT_FONT_DIRECTORY         3000
#define IDH_SOFT_FONT_NEW_LIST          3010
#define IDH_SOFT_FONT_INSTALLED_LIST    3020
#define IDH_SOFT_FONT_OPEN_BTN          3030
#define IDH_SOFT_FONT_ADD_BTN           3040
#define IDH_SOFT_FONT_DELETE_BTN        3050

#endif  //!_UIHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Sources file shared by PostScript and UniDriver UI

!ENDIF

!include $(PRNROOT)\print.inc

USE_MSVCRT=1
DLLENTRY=_DllMainCRTStartup
BUFFER_OVERFLOW_CHECKS=1

TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=\
    $(PRNROOT)\lib\utils\um\$(O)\utils.lib  \
    $(PRNROOT)\lib\oemutil\um\$(O)\oemutil.lib  \
    $(PRNROOT)\lib\helper\um\$(O)\helper.lib  \
    $(SDK_LIB_PATH)\user32.lib   \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\winspool.lib \
    $(SDK_LIB_PATH)\gdi32.lib    \
    $(SDK_LIB_PATH)\shell32.lib  \
    $(SDK_LIB_PATH)\comctl32.lib \
    $(SDK_LIB_PATH)\ntdll.lib

NTPROFILEINPUT=yes

!if defined(WINNT_40)
INCLUDES=$(INCLUDES);.;..;$(BASEDIR)\private\windows\inc;$(PRNROOT)\parsers\ppd;$(PRNROOT)\unidrv2\inc
!else
INCLUDES=$(INCLUDES);.;..;$(PRNROOT)\parsers\ppd;$(PRNROOT)\unidrv2\inc; \
    $(WINDOWS_INC_PATH);
!endif

C_DEFINES=$(C_DEFINES) -DOEMCOM

SOURCES=\
    ..\intfui.cxx  \
    ..\initdll.c    \
    ..\fontsub.c    \
    ..\commonui.c   \
    ..\dm.c         \
    ..\driverui.c   \
    ..\devcaps.c    \
    ..\docprop.c    \
    ..\prnprop.c    \
    ..\prnevent.c   \
    ..\quryprnt.c   \
    ..\upgrade.c    \
    ..\forms.c      \
    ..\oemui.c      \
    ..\driverui.rc

PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\ps\precomp.h ===
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
#include "lib.h"
#include <commctrl.h>
#include <winddiui.h>
#include "ppd.h"
#include "oemutil.h"
#include "pslib.h"
#include "uires.h"
#include "uihelp.h"
#include "driverui.h"
#include "oemui.h"
#include <prcomoem.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\ps\ps.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ps.c

Abstract:

    This file handles Postscript specific UI options

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/25/97 -davidx-
        Finish PS-specific items.

    02/04/97 -davidx-
        Reorganize driver UI to separate ps and uni DLLs.

        12/17/96 -amandan-
                Created it.

--*/

#include "precomp.h"
#include <ntverp.h>

BOOL BSearchConstraintList(PUIINFO, DWORD, DWORD, DWORD);

static CONST WORD ScaleItemInfo[] =
{
    IDS_CPSUI_SCALING, TVITEM_LEVEL1, DMPUB_SCALE,
    SCALE_ITEM, HELP_INDEX_SCALE,
    2, TVOT_UDARROW,
    IDS_CPSUI_PERCENT, IDI_CPSUI_SCALING,
    0, MIN_SCALE,
    ITEM_INFO_SIGNATURE
};


BOOL
_BPackItemScale(
    PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack scaling option.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    return BPackUDArrowItemTemplate(
                pUiData,
                ScaleItemInfo,
                pUiData->ci.pdm->dmScale,
                pUiData->ci.pUIInfo->dwMaxScale,
                NULL);
}


DWORD
_DwEnumPersonalities(
    PCOMMONINFO pci,
    PWSTR       pwstrOutput
    )

/*++

Routine Description:

    Enumerate the list of supported printer description languages

Arguments:

    pci - Points to common printer info
    pwstrOutput - Points to output buffer

Return Value:

    Number of personalities supported
    GDI_ERROR if there is an error

--*/

{
    if (pwstrOutput)
        CopyString(pwstrOutput, TEXT("PostScript"), CCHLANGNAME);

    return 1;
}



DWORD
_DwGetOrientationAngle(
    PUIINFO     pUIInfo,
    PDEVMODE    pdm
    )
/*++

Routine Description:

    Get the orienation angle requested by DrvDeviceCapabilities(DC_ORIENTATION)

Arguments:

    pUIInfo - Pointer to UIINFO
    pdm  - Pointer to DEVMODE

Return Value:

    The angle (90 or 270 or landscape rotation)

--*/

{
    DWORD       dwRet;
    PPSDRVEXTRA pdmPrivate;

    pdmPrivate = (PPSDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdm);

    //
    // Normal landscape rotates counterclockwise
    // Rotated landscape rotates clockwise
    //

    if (pUIInfo->dwFlags & FLAG_ROTATE90)
        dwRet = (pdmPrivate->dwFlags & PSDEVMODE_LSROTATE) ? 270 : 90;
    else
        dwRet = (pdmPrivate->dwFlags & PSDEVMODE_LSROTATE) ? 90 : 270;

    return dwRet;
}


static CONST WORD PSOrientItemInfo[] =
{
    IDS_CPSUI_ORIENTATION, TVITEM_LEVEL1, DMPUB_ORIENTATION,
    ORIENTATION_ITEM, HELP_INDEX_ORIENTATION,
    3, TVOT_3STATES,
    IDS_CPSUI_PORTRAIT, IDI_CPSUI_PORTRAIT,
    IDS_CPSUI_LANDSCAPE, IDI_CPSUI_LANDSCAPE,
    IDS_CPSUI_ROT_LAND, IDI_CPSUI_ROT_LAND,
    ITEM_INFO_SIGNATURE
};


BOOL
_BPackOrientationItem(
    IN OUT PUIDATA pUiData
    )
/*++

Routine Description:

    Synthesize the orientation feature for Doc property sheet

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

Note:

    Always synthesize orienation for PostScript

--*/

{
    PFEATURE    pFeature;
    DWORD       dwSelection;

    //
    // If there is no predefined orientation feature, we displays it ourselves.
    //

    if ((pUiData->ci.pdm->dmFields & DM_ORIENTATION) &&
        (pUiData->ci.pdm->dmOrientation == DMORIENT_LANDSCAPE))
    {
        PPSDRVEXTRA pdmPrivate;

        pdmPrivate = (PPSDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pUiData->ci.pdm);
        dwSelection = pdmPrivate->dwFlags &  PSDEVMODE_LSROTATE ?  2 : 1;
    }
    else
        dwSelection = 0;

    //
    // Synthesize the feature ourselves
    //

    return BPackOptItemTemplate(pUiData, PSOrientItemInfo, dwSelection, NULL);
}



static CONST WORD PSOutputOptionItemInfo[] =
{
    IDS_PSOUTPUT_OPTION, TVITEM_LEVEL2, DMPUB_NONE,
    PSOUTPUT_OPTION_ITEM, HELP_INDEX_PSOUTPUT_OPTION,
    4, TVOT_LISTBOX,
    IDS_PSOPT_SPEED, IDI_PSOPT_SPEED,
    IDS_PSOPT_PORTABILITY, IDI_PSOPT_PORTABILITY,
    IDS_PSOPT_EPS, IDI_PSOPT_EPS,
    IDS_PSOPT_ARCHIVE, IDI_PSOPT_ARCHIVE,
    ITEM_INFO_SIGNATURE
};


BOOL
BPackItemPSOutputOption(
    PUIDATA     pUiData,
    PPSDRVEXTRA pdmPrivate
    )

/*++

Routine Description:

    Pack PostScript output option item

Arguments:

    pUiData - Points to UIDATA structure
    pdmPrivate - Points to pscript private devmode

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD   dwSel;

    switch (pdmPrivate->iDialect)
    {
    case PORTABILITY:
        dwSel = 1;
        break;

    case EPS:
        dwSel = 2;
        break;

    case ARCHIVE:
        dwSel = 3;
        break;

    case SPEED:
    default:
        dwSel = 0;
        break;
    }

    return BPackOptItemTemplate(pUiData, PSOutputOptionItemInfo, dwSel, NULL);
}



static CONST WORD PSTTDLFormatItemInfo[] =
{
    IDS_PSTT_DLFORMAT, TVITEM_LEVEL2, DMPUB_NONE,
    PSTT_DLFORMAT_ITEM, HELP_INDEX_PSTT_DLFORMAT,
    4, TVOT_LISTBOX,
    IDS_TTDL_DEFAULT, IDI_PSTT_DLFORMAT,
    IDS_TTDL_TYPE1, IDI_PSTT_DLFORMAT,
    IDS_TTDL_TYPE3, IDI_PSTT_DLFORMAT,
    IDS_TTDL_TYPE42, IDI_PSTT_DLFORMAT,
    ITEM_INFO_SIGNATURE
};


BOOL
BPackItemTTDownloadFormat(
    PUIDATA     pUiData,
    PPSDRVEXTRA pdmPrivate
    )

/*++

Routine Description:

    Pack PostScript TrueType download option item

Arguments:

    pUiData - Points to UIDATA structure
    pdmPrivate - Points to pscript private devmode

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD       dwSel;
    BOOL        bSupportType42;
    POPTTYPE    pOptType = pUiData->pOptType;

    bSupportType42 = (pUiData->ci.pUIInfo->dwTTRasterizer == TTRAS_TYPE42);

    switch (pdmPrivate->iTTDLFmt)
    {
    case TYPE_1:
        dwSel = 1;
        break;

    case TYPE_3:
        dwSel = 2;
        break;

    case TYPE_42:

        dwSel = bSupportType42 ? 3 : 0;
        break;

    case TT_DEFAULT:
    default:
        dwSel = 0;
        break;
    }

    if (! BPackOptItemTemplate(pUiData, PSTTDLFormatItemInfo, dwSel, NULL))
        return FALSE;

    //
    // if printer doesn't support Type42, hide Type42 option
    //

    if (pOptType && !bSupportType42)
        pOptType->pOptParam[3].Flags |= OPTPF_HIDE;

    return TRUE;
}



static CONST WORD PSLevelItemInfo[] =
{
    IDS_PSLEVEL, TVITEM_LEVEL2, DMPUB_NONE,
    PSLEVEL_ITEM, HELP_INDEX_SCALE,
    2, TVOT_UDARROW,
    0, IDI_PSLEVEL,
    0,

    //
    // Adobe doesn't want to support level 1
    //

    #ifdef ADOBE
    2,
    #else
    1,
    #endif

    ITEM_INFO_SIGNATURE
};

BOOL
BPackItemPSLevel(
    PUIDATA     pUiData,
    PPSDRVEXTRA pdmPrivate
    )

/*++

Routine Description:

    Pack PostScript output option item

Arguments:

    pUiData - Points to UIDATA structure
    pdmPrivate - Points to pscript private devmode

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD       dwSel = pdmPrivate->iPSLevel;
    DWORD       dwLangLevel = pUiData->ci.pUIInfo->dwLangLevel;

    //
    // we don't expect language level to be higher than 4
    //

    if (dwLangLevel <= 1)
        return TRUE;

    if (dwLangLevel > 4)
        dwLangLevel = 4;

    //
    // make sure the current selection is sensible
    //

    if (dwSel == 0 || dwSel > dwLangLevel)
        dwSel = dwLangLevel;

    return BPackUDArrowItemTemplate(pUiData, PSLevelItemInfo, dwSel, dwLangLevel, NULL);
}



static CONST WORD EHandlerItemInfo[] =
{
    IDS_PSERROR_HANDLER, TVITEM_LEVEL2, DMPUB_NONE,
    PSERROR_HANDLER_ITEM, HELP_INDEX_PSERROR_HANDLER,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};

static CONST WORD MirrorItemInfo[] =
{
    IDS_MIRROR, TVITEM_LEVEL2, DMPUB_NONE,
    MIRROR_ITEM, HELP_INDEX_MIRROR,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};

static CONST WORD NegativeItemInfo[] =
{
    IDS_NEGATIVE_PRINT, TVITEM_LEVEL2, DMPUB_NONE,
    NEGATIVE_ITEM, HELP_INDEX_NEGATIVE,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};

static CONST WORD CompressBmpItemInfo[] =
{
    IDS_COMPRESSBMP, TVITEM_LEVEL2, DMPUB_NONE,
    COMPRESSBMP_ITEM, HELP_INDEX_COMPRESSBMP,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};

BOOL
_BPackDocumentOptions(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack PostScript specific options such as Job Control etc.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    POPTITEM    pOptItem;
    PPSDRVEXTRA pdmPrivate;
    DWORD       dwFlags;

    pdmPrivate = pUiData->ci.pdmPrivate;
    dwFlags = pdmPrivate->dwFlags;
    pOptItem = pUiData->pOptItem;

    VPackOptItemGroupHeader(pUiData,
                            IDS_PSOPTIONS,
                            IDI_CPSUI_POSTSCRIPT,
                            HELP_INDEX_PSOPTIONS);

    if (pOptItem)
        pOptItem->Flags |= OPTIF_COLLAPSE;

    return BPackItemPSOutputOption(pUiData, pdmPrivate) &&
           BPackItemTTDownloadFormat(pUiData, pdmPrivate) &&
           BPackItemPSLevel(pUiData, pdmPrivate) &&
           BPackOptItemTemplate(
                    pUiData,
                    EHandlerItemInfo,
                    (dwFlags & PSDEVMODE_EHANDLER) ? 0 : 1, NULL) &&
           (pUiData->ci.pUIInfo->dwLangLevel > 1 ||
            BPackOptItemTemplate(
                    pUiData,
                    CompressBmpItemInfo,
                    (dwFlags & PSDEVMODE_COMPRESSBMP) ? 0 : 1, NULL)) &&
           BPackOptItemTemplate(
                    pUiData,
                    MirrorItemInfo,
                    (dwFlags & PSDEVMODE_MIRROR) ? 0 : 1, NULL) &&
           (IS_COLOR_DEVICE(pUiData->ci.pUIInfo) ||
            BPackOptItemTemplate(
                     pUiData,
                     NegativeItemInfo,
                     (dwFlags & PSDEVMODE_NEG) ? 0 : 1, NULL));
}


VOID
_VUnpackDocumentOptions(
    POPTITEM    pOptItem,
    PDEVMODE    pdm
    )

/*++

Routine Description:

    Extract Postscript devmode information from an OPTITEM
    Stored it back into Postscript devmode.

Arguments:

    pOptItem - Pointer to an OPTITEM
    pdm - Pointer to Postscript DEVMODE structure

Return Value:

    None

--*/

{
    PPSDRVEXTRA pdmPrivate;

    pdmPrivate = (PPSDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdm);

    switch (GETUSERDATAITEM(pOptItem->UserData))
    {
    case ORIENTATION_ITEM:

        pdm->dmFields |= DM_ORIENTATION;
        pdm->dmOrientation = (pOptItem->Sel == 0) ?
                                    DMORIENT_PORTRAIT :
                                    DMORIENT_LANDSCAPE;

        if (pOptItem->Sel != 2)
            pdmPrivate->dwFlags &= ~PSDEVMODE_LSROTATE;
        else
            pdmPrivate->dwFlags |= PSDEVMODE_LSROTATE;

        break;

    case PSOUTPUT_OPTION_ITEM:

        switch (pOptItem->Sel)
        {
        case 1:
            pdmPrivate->iDialect = PORTABILITY;
            break;

        case 2:
            pdmPrivate->iDialect = EPS;
            break;

        case 3:
            pdmPrivate->iDialect = ARCHIVE;
            break;

        case 0:
        default:
            pdmPrivate->iDialect = SPEED;
            break;
        }
        break;

    case PSTT_DLFORMAT_ITEM:

        switch (pOptItem->Sel)
        {
        case 1:
            pdmPrivate->iTTDLFmt = TYPE_1;
            break;

        case 2:
            pdmPrivate->iTTDLFmt = TYPE_3;
            break;

        case 3:
            pdmPrivate->iTTDLFmt = TYPE_42;
            break;

        case 0:
        default:
            pdmPrivate->iTTDLFmt = TT_DEFAULT;
            break;
        }
        break;

    case PSLEVEL_ITEM:

        pdmPrivate->iPSLevel = pOptItem->Sel;
        break;

    case PSERROR_HANDLER_ITEM:

        if (pOptItem->Sel == 0)
            pdmPrivate->dwFlags |= PSDEVMODE_EHANDLER;
        else
            pdmPrivate->dwFlags &= ~PSDEVMODE_EHANDLER;
        break;

    case PSHALFTONE_FREQ_ITEM:
    case PSHALFTONE_ANGLE_ITEM:

        // DCR - not implemented yet
        break;

    case MIRROR_ITEM:

        if (pOptItem->Sel == 0)
            pdmPrivate->dwFlags |= PSDEVMODE_MIRROR;
        else
            pdmPrivate->dwFlags &= ~PSDEVMODE_MIRROR;
        break;

    case NEGATIVE_ITEM:

        if (pOptItem->Sel == 0)
            pdmPrivate->dwFlags |= PSDEVMODE_NEG;
        else
            pdmPrivate->dwFlags &= ~PSDEVMODE_NEG;
        break;

    case COMPRESSBMP_ITEM:

        if (pOptItem->Sel == 0)
            pdmPrivate->dwFlags |= PSDEVMODE_COMPRESSBMP;
        else
            pdmPrivate->dwFlags &= ~PSDEVMODE_COMPRESSBMP;
        break;
   }
}



static CONST WORD IgnoreDevFontItemInfo[] =
{
    IDS_USE_DEVFONTS, TVITEM_LEVEL1, DMPUB_NONE,
    IGNORE_DEVFONT_ITEM, HELP_INDEX_IGNORE_DEVFONT,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};


BOOL
_BPackFontSubstItems(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack font substitution related items (printer-sticky)

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    BOOL bNoDeviceFont;

    bNoDeviceFont = (pUiData->ci.pPrinterData->dwFlags & PFLAGS_IGNORE_DEVFONT);

    //
    // On non-1252 code page systems, gives user the option
    // to disable all device fonts
    //
    // Note: On non-1252 CodePage systems (Cs-Ct-Ja-Ko & Cyr-Grk-Tur, etc),
    // PScript NT4 had difficulty mapping printer font Encodings to GDI strings.
    // AdobePS5/PScript5 is supposed to handle these correctly. So Adobe wants
    // this choice to be suppressed on all code pages.
    //
    // Fix MS bug #121883, Adobe bug #235417
    //

    if (FALSE && GetACP() != 1252 &&
        !BPackOptItemTemplate(pUiData, IgnoreDevFontItemInfo, bNoDeviceFont ? 1 : 0, NULL))
    {
        return FALSE;
    }

    //
    // Don't display the font substitution table if device font is disabled
    //

    if (bNoDeviceFont)
        return TRUE;

    return BPackItemFontSubstTable(pUiData);
}



static CONST WORD ProtocolItemInfo[] =
{
    IDS_PSPROTOCOL, TVITEM_LEVEL1, DMPUB_NONE,
    PSPROTOCOL_ITEM, HELP_INDEX_PSPROTOCOL,
    4, TVOT_LISTBOX,
    IDS_PSPROTOCOL_ASCII, IDI_PSPROTOCOL,
    IDS_PSPROTOCOL_BCP, IDI_PSPROTOCOL,
    IDS_PSPROTOCOL_TBCP, IDI_PSPROTOCOL,
    IDS_PSPROTOCOL_BINARY, IDI_PSPROTOCOL,
    ITEM_INFO_SIGNATURE
};


BOOL
BPackPSProtocolItem(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack PostScript communication protocol item

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD       dwSel;
    POPTITEM    pOptItem;
    POPTPARAM   pOptParam;
    PUIINFO     pUIInfo;

    pOptItem = pUiData->pOptItem;

    if (! BPackOptItemTemplate(pUiData, ProtocolItemInfo, 0, NULL))
        return FALSE;

    if (pOptItem)
    {
        //
        // Hide those selections which are not supported on the printer
        //

        pOptParam = pOptItem->pOptType->pOptParam;
        pUIInfo = pUiData->ci.pUIInfo;

        if (! (pUIInfo->dwProtocols & PROTOCOL_BCP))
            pOptParam[1].Flags |= OPTPF_HIDE;

        if (! (pUIInfo->dwProtocols & PROTOCOL_TBCP))
            pOptParam[2].Flags |= OPTPF_HIDE;

        if (! (pUIInfo->dwProtocols & PROTOCOL_BINARY))
            pOptParam[3].Flags |= OPTPF_HIDE;

        switch (pUiData->ci.pPrinterData->wProtocol)
        {
        case PROTOCOL_BCP:
            dwSel = 1;
            break;

        case PROTOCOL_TBCP:
            dwSel = 2;
            break;

        case PROTOCOL_BINARY:
            dwSel = 3;
            break;

        default:
            dwSel = 0;
            break;
        }

        if (pOptParam[dwSel].Flags & OPTPF_HIDE)
            pOptItem->Sel = 0;
        else
            pOptItem->Sel = dwSel;
    }

    return TRUE;
}

//
// We will use different lower limit for Printer VM
// based on printer level. The 10th element of this
// ItemInfo must be filled with correct lower limit
// number before begin used.
//

static WORD PrinterVMItemInfo[] =
{
    IDS_POSTSCRIPT_VM, TVITEM_LEVEL1, DMPUB_NONE,
    PRINTER_VM_ITEM, HELP_INDEX_PRINTER_VM,
    2, TVOT_UDARROW,
    IDS_KBYTES, IDI_CPSUI_MEM,
    0, 0,
    ITEM_INFO_SIGNATURE
};

static CONST WORD JobTimeoutItemInfo[] =
{
    IDS_JOBTIMEOUT, TVITEM_LEVEL1, DMPUB_NONE,
    JOB_TIMEOUT_ITEM, HELP_INDEX_JOB_TIMEOUT,
    2, TVOT_UDARROW,
    IDS_SECONDS, IDI_USE_DEFAULT,
    0, 0,
    ITEM_INFO_SIGNATURE
};

static CONST WORD WaitTimeoutItemInfo[] =
{
    IDS_WAITTIMEOUT, TVITEM_LEVEL1, DMPUB_NONE,
    WAIT_TIMEOUT_ITEM, HELP_INDEX_WAIT_TIMEOUT,
    2, TVOT_UDARROW,
    IDS_SECONDS, IDI_USE_DEFAULT,
    0, 0,
    ITEM_INFO_SIGNATURE
};

static CONST WORD CtrlDBeforeItemInfo[] =
{
    IDS_CTRLD_BEFORE, TVITEM_LEVEL1, DMPUB_NONE,
    CTRLD_BEFORE_ITEM, HELP_INDEX_CTRLD_BEFORE,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};

static CONST WORD CtrlDAfterItemInfo[] =
{
    IDS_CTRLD_AFTER, TVITEM_LEVEL1, DMPUB_NONE,
    CTRLD_AFTER_ITEM, HELP_INDEX_CTRLD_AFTER,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};

static CONST WORD TrueGrayTextItemInfo[] =
{
    IDS_TRUE_GRAY_TEXT, TVITEM_LEVEL1, DMPUB_NONE,
    TRUE_GRAY_TEXT_ITEM, HELP_INDEX_TRUE_GRAY_TEXT,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};

static CONST WORD TrueGrayGraphItemInfo[] =
{
    IDS_TRUE_GRAY_GRAPH, TVITEM_LEVEL1, DMPUB_NONE,
    TRUE_GRAY_GRAPH_ITEM, HELP_INDEX_TRUE_GRAY_GRAPH,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};

static CONST WORD AddEuroItemInfo[] =
{
    IDS_ADD_EURO, TVITEM_LEVEL1, DMPUB_NONE,
    ADD_EURO_ITEM, HELP_INDEX_ADD_EURO,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};

static CONST WORD MinOutlineItemInfo[] =
{
    IDS_PSMINOUTLINE, TVITEM_LEVEL1, DMPUB_NONE,
    PSMINOUTLINE_ITEM, HELP_INDEX_PSMINOUTLINE,
    2, TVOT_UDARROW,
    IDS_PIXELS, IDI_USE_DEFAULT,
    0, 0,
    ITEM_INFO_SIGNATURE
};

static CONST WORD MaxBitmapItemInfo[] =
{
    IDS_PSMAXBITMAP, TVITEM_LEVEL1, DMPUB_NONE,
    PSMAXBITMAP_ITEM, HELP_INDEX_PSMAXBITMAP,
    2, TVOT_UDARROW,
    IDS_PIXELS, IDI_USE_DEFAULT,
    0, 0,
    ITEM_INFO_SIGNATURE
};

BOOL
_BPackPrinterOptions(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack driver-specific options (printer-sticky)

Arguments:

    pUiData - Points to a UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    PPRINTERDATA pPrinterData = pUiData->ci.pPrinterData;
    BOOL rc;

    //
    // Fill in the lower limit number of PrinterVMItemInfo
    // based on printer level.
    //

    PrinterVMItemInfo[10] = (pUiData->ci.pUIInfo->dwLangLevel <= 1 ? MIN_FREEMEM_L1 : MIN_FREEMEM_L2) / KBYTES;

    rc = BPackUDArrowItemTemplate(
                    pUiData,
                    PrinterVMItemInfo,
                    pPrinterData->dwFreeMem / KBYTES,
                    0x7fff, NULL) &&
         BPackPSProtocolItem(pUiData) &&
         BPackOptItemTemplate(
                    pUiData,
                    CtrlDBeforeItemInfo,
                    (pPrinterData->dwFlags & PFLAGS_CTRLD_BEFORE) ? 0 : 1, NULL) &&
         BPackOptItemTemplate(
                    pUiData,
                    CtrlDAfterItemInfo,
                    (pPrinterData->dwFlags & PFLAGS_CTRLD_AFTER) ? 0 : 1, NULL) &&
         BPackOptItemTemplate(
                    pUiData,
                    TrueGrayTextItemInfo,
                    (pPrinterData->dwFlags & PFLAGS_TRUE_GRAY_TEXT) ? 0 : 1, NULL) &&
         BPackOptItemTemplate(
                    pUiData,
                    TrueGrayGraphItemInfo,
                    (pPrinterData->dwFlags & PFLAGS_TRUE_GRAY_GRAPH) ? 0 : 1, NULL);
    if (!rc)
         return FALSE;

    if (pUiData->ci.pUIInfo->dwLangLevel > 1)
    {
        rc = BPackOptItemTemplate(
                    pUiData,
                    AddEuroItemInfo,
                    (pPrinterData->dwFlags & PFLAGS_ADD_EURO) ? 0 : 1, NULL);
        if (!rc)
            return FALSE;
    }

    return BPackUDArrowItemTemplate(
                    pUiData,
                    JobTimeoutItemInfo,
                    pPrinterData->dwJobTimeout,
                    0x7fff, NULL) &&
           BPackUDArrowItemTemplate(
                    pUiData,
                    WaitTimeoutItemInfo,
                    pPrinterData->dwWaitTimeout,
                    0x7fff, NULL) &&
           BPackUDArrowItemTemplate(
                    pUiData,
                    MinOutlineItemInfo,
                    pPrinterData->wMinoutlinePPEM,
                    0x7fff, NULL) &&
           BPackUDArrowItemTemplate(
                    pUiData,
                    MaxBitmapItemInfo,
                    pPrinterData->wMaxbitmapPPEM,
                    0x7fff, NULL);
}



VOID
_VUnpackDriverPrnPropItem(
    PUIDATA     pUiData,
    POPTITEM    pOptItem
    )

/*++

Routine Description:

    Unpack driver-specific printer property items

Arguments:

    pUiData - Points to our UIDATA structure
    pOptItem - Specifies the OPTITEM to be unpacked

Return Value:

    NONE

--*/

{
    PPRINTERDATA pPrinterData = pUiData->ci.pPrinterData;

    switch (GETUSERDATAITEM(pOptItem->UserData))
    {
    case PRINTER_VM_ITEM:

        if (pUiData->ci.dwFlags & FLAG_USER_CHANGED_FREEMEM)
        {
            pPrinterData->dwFreeMem = pOptItem->Sel * KBYTES;
        }
        break;

    case PSPROTOCOL_ITEM:

        switch (pOptItem->Sel)
        {
        case 1:
            pPrinterData->wProtocol = PROTOCOL_BCP;
            break;

        case 2:
            pPrinterData->wProtocol = PROTOCOL_TBCP;
            break;

        case 3:
            pPrinterData->wProtocol = PROTOCOL_BINARY;
            break;

        default:
            pPrinterData->wProtocol = PROTOCOL_ASCII;
            break;
        }
        break;

    case CTRLD_BEFORE_ITEM:

        if (pOptItem->Sel == 0)
            pPrinterData->dwFlags |= PFLAGS_CTRLD_BEFORE;
        else
            pPrinterData->dwFlags &= ~PFLAGS_CTRLD_BEFORE;
        break;

    case CTRLD_AFTER_ITEM:

        if (pOptItem->Sel == 0)
            pPrinterData->dwFlags |= PFLAGS_CTRLD_AFTER;
        else
            pPrinterData->dwFlags &= ~PFLAGS_CTRLD_AFTER;
        break;


    case TRUE_GRAY_TEXT_ITEM:

        if (pOptItem->Sel == 0)
            pPrinterData->dwFlags |= PFLAGS_TRUE_GRAY_TEXT;
        else
            pPrinterData->dwFlags &= ~PFLAGS_TRUE_GRAY_TEXT;
        break;
    case TRUE_GRAY_GRAPH_ITEM:

        if (pOptItem->Sel == 0)
            pPrinterData->dwFlags |= PFLAGS_TRUE_GRAY_GRAPH;
        else
            pPrinterData->dwFlags &= ~PFLAGS_TRUE_GRAY_GRAPH;
        break;


    case ADD_EURO_ITEM:

        if (pOptItem->Sel == 0)
            pPrinterData->dwFlags |= PFLAGS_ADD_EURO;
        else
            pPrinterData->dwFlags &= ~PFLAGS_ADD_EURO;

        pPrinterData->dwFlags |= PFLAGS_EURO_SET;
        break;


    case PSMINOUTLINE_ITEM:

        pPrinterData->wMinoutlinePPEM = (WORD) pOptItem->Sel;
        break;

    case PSMAXBITMAP_ITEM:

        pPrinterData->wMaxbitmapPPEM = (WORD) pOptItem->Sel;
        break;
    }
}



BOOL
BUpdateModelNtfFilename(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Save model-specific NTF filename under PrinterDriverData registry key
    for compatibility with the new NT4 driver.

Arguments:

    pci - Points to basic printer information

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    //
    // Get the list of driver dependent files and
    // save it in registry for NT4 compatibility
    //

    PTSTR  ptstr, ptstrNext, ptstrDependentFiles, ptstrCopy, ptstrFileNamesWithoutPath;
    DWORD  dwCharCount = 0;
    BOOL   bResult;

    if ((ptstrDependentFiles = pci->pDriverInfo3->pDependentFiles) == NULL)
    {
        return BSetPrinterDataString(pci->hPrinter,
                                     REGVAL_DEPFILES,
                                     ptstrDependentFiles,
                                     REG_MULTI_SZ);
    }

    //
    // First pass of the MULTI_SZ string to get file names char count
    //

    while (*ptstrDependentFiles != NUL)
    {
        //
        // Go the end of current string
        //

        ptstr = ptstrDependentFiles + _tcslen(ptstrDependentFiles);
        ptstrNext = ptstr + 1;

        dwCharCount++;      // for the NUL char of current string

        //
        // Search backward for '\' path separator
        //

        while (--ptstr >= ptstrDependentFiles)
        {
            if (*ptstr == TEXT(PATH_SEPARATOR))
            {
                break;
            }

            dwCharCount++;
        }

        ptstrDependentFiles = ptstrNext;
    }

    dwCharCount++;      // for the last NUL of the MULTI_SZ string

    if ((ptstrFileNamesWithoutPath = MemAllocZ(dwCharCount * sizeof(TCHAR))) == NULL)
    {
        ERR(("Memory allocation failed\n"));
        return FALSE;
    }

    //
    // Second pass of the MULTI_SZ string to copy the file names
    //

    ptstrDependentFiles = pci->pDriverInfo3->pDependentFiles;
    ptstrCopy = ptstrFileNamesWithoutPath;

    while (*ptstrDependentFiles != NUL)
    {
        INT     iNameLen;

        //
        // Go the end of current string
        //

        ptstr = ptstrDependentFiles + _tcslen(ptstrDependentFiles);
        ptstrNext = ptstr + 1;

        //
        // Search backward for '\' path separator
        //

        while (--ptstr >= ptstrDependentFiles)
        {
            if (*ptstr == TEXT(PATH_SEPARATOR))
            {
                break;
            }
        }

        ptstr++;    // point to the char after '\'

        iNameLen = _tcslen(ptstr);

        CopyMemory(ptstrCopy, ptstr, iNameLen * sizeof(TCHAR));
        ptstrCopy += iNameLen + 1;

        ptstrDependentFiles = ptstrNext;
    }

    bResult = BSetPrinterDataString(pci->hPrinter,
                                    REGVAL_DEPFILES,
                                    ptstrFileNamesWithoutPath,
                                    REG_MULTI_SZ);

    MemFree(ptstrFileNamesWithoutPath);

    return bResult;
}



#ifdef WINNT_40

BOOL
BUpdateVMErrorMessageID(
        PCOMMONINFO pci
        )
/*++

Routine Description:

        Save the VM Error message ID calculated from the current user's locale
        under PrinterDriverData registry key.

Arguments:

        pci - Points to basic printer information

Return Value:

        TRUE if successful, FALSE if there is an error

--*/

{
        DWORD dwVMErrorMessageID = DWGetVMErrorMessageID();

        return BSetPrinterDataDWord(pci->hPrinter,
                                                                 REGVAL_VMERRORMESSAGEID,
                                                                 dwVMErrorMessageID);
}

#endif // WINNT_40


INT
_IListDevFontNames(
    HDC     hdc,
    PWSTR   pwstrBuf,
    INT     iSize
    )

{
    DWORD dwParam = QUERY_FAMILYNAME;

    //
    // Ask the driver graphics module for the list of permanant device fonts
    //

    return ExtEscape(hdc,
                     DRIVERESC_QUERY_DEVFONTS,
                     sizeof(dwParam),
                     (PCSTR) &dwParam,
                     iSize,
                     (PSTR) pwstrBuf);
}


INT_PTR CALLBACK
_AboutDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Procedure for handling "Printer Properties" proerty sheet page

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    PUIDATA pUiData;
    PWSTR   pPpdFilename;
    CHAR    achBuf[64]  = {0};
    CHAR    achMsg[136] = {0};
    PPDDATA *pPpdData;

    switch (message)
    {
    case WM_INITDIALOG:

        //
        // Initialize the About dialog box
        //

        pUiData = (PUIDATA) lParam;
        ASSERT(VALIDUIDATA(pUiData));

        if (LoadStringA(ghInstance, IDS_PS_VERSION, achBuf, sizeof(achBuf) - 1))
        {
            #ifdef WINNT_40

            if (FAILED(StringCchPrintfA(achMsg,
                                        CCHOF(achMsg),
                                        "%s (" VER_54DRIVERVERSION_STR ")",
                                        achBuf)))

            #else  // WINNT_40

            if (FAILED(StringCchPrintfA(achMsg,
                                        CCHOF(achMsg),
                                        "%s (" VER_PRODUCTVERSION_STR ")",
                                        achBuf)))

            #endif  // WINNT_40
            {
                WARNING(("Device Settings About box version string truncated.\n"));
            }
        }
        else
        {
            WARNING(("Device Setting About box attempt to load version string failed.\n"));
        }

        SetDlgItemTextA(hDlg, IDC_WINNT_VER, achMsg);

        SetDlgItemText(hDlg, IDC_MODELNAME, pUiData->ci.pDriverInfo3->pName);

        if (pPpdFilename = pUiData->ci.pDriverInfo3->pDataFile)
        {
            if (pPpdFilename = wcsrchr(pPpdFilename, TEXT(PATH_SEPARATOR)))
                pPpdFilename++;
            else
                pPpdFilename = pUiData->ci.pDriverInfo3->pDataFile;

            SetDlgItemText(hDlg, IDC_PPD_FILENAME, pPpdFilename);

            pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER(pUiData->ci.pInfoHeader);

            ASSERT(pPpdData != NULL);

            StringCchPrintfA(achBuf,
                             CCHOF(achBuf),
                             "%d.%d",
                             HIWORD(pPpdData->dwPpdFilever), LOWORD(pPpdData->dwPpdFilever));

            SetDlgItemTextA(hDlg, IDC_PPD_FILEVER, achBuf);
        }

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
        case IDCANCEL:

            EndDialog(hDlg, LOWORD(wParam));
            return TRUE;
        }
        break;
    }

    return FALSE;
}




//
// Determine whether the printer supports stapling
//

BOOL
_BSupportStapling(
    PCOMMONINFO pci
    )

{
    PFEATURE pFeature, pFeatureY;
    DWORD    dwIndex;
    BOOL     bStapleFeatureExist = FALSE;

    //
    // Except for *StapleOrientation (whose None option doesn't mean stapling off),
    // if any of following stapling keywords appear in the PPD file, we check if that
    // feature is supported with current installable option selections.
    //
    // *StapleLocation
    // *StapleX
    // *StapleY
    // *StapleWhen
    //
    // PPD spec says that a PPD file can contain either *StapleLocation or
    // *StapleX and *StapleY but not both.
    //

    if (pFeature = PGetNamedFeature(pci->pUIInfo, "StapleLocation", &dwIndex))
    {
        bStapleFeatureExist = TRUE;

        if (!_BSupportFeature(pci, GID_UNKNOWN, pFeature))
        {
            return FALSE;
        }
    }
    else if ( (pFeature = PGetNamedFeature(pci->pUIInfo, "StapleX", &dwIndex)) &&
              (pFeatureY = PGetNamedFeature(pci->pUIInfo, "StapleY", &dwIndex)) )
    {
        bStapleFeatureExist = TRUE;

        if (!_BSupportFeature(pci, GID_UNKNOWN, pFeature) ||
            !_BSupportFeature(pci, GID_UNKNOWN, pFeatureY))
        {
            return FALSE;
        }
    }

    if (pFeature = PGetNamedFeature(pci->pUIInfo, "StapleWhen", &dwIndex))
    {
        bStapleFeatureExist = TRUE;

        if (!_BSupportFeature(pci, GID_UNKNOWN, pFeature))
        {
            return FALSE;
        }
    }

    //
    // We didn't find any constraints on the stapling features caused by installable options,
    // so we will assume the printer can support stapling if any of the standard PPD stapling
    // keywords are present.
    //

    return bStapleFeatureExist ||
           PGetNamedFeature(pci->pUIInfo, "StapleOrientation", &dwIndex) != NULL;
}




BOOL
BFeatureIsConstrained(
    PUIINFO  pUIInfo,
    PFEATURE pFeature,
    DWORD    dwFeatureIndex,
    DWORD    dwOptionCount,
    DWORD    dwConstraintList,
    PBYTE    aubConstrainedOption,
    DWORD    dwGid
    )

/*++

Routine Description:

    Determine whether the particular constraint list constrains feature options.

Arguments:

    pUIInfo - Points to a UIINFO structure
    pFeature - Points to feature structure to be checked whether constraint or not
    dwFeatureIndex - index for the  feature
    dwOptionCount - number of options for the feature
    dwConstraintList - Specifies the constraint list to be searched
    aubConstrainedOption - Byte array of option constrained flag
    dwGid - GID_DUPLEX, GID_COLLATE or GID_UNKNOWN to allow feature specific don't cares

Return Value:

    TRUE if the feature is constrained by the constraint list, FALSE otherwise.

--*/

{
    POPTION  pOption;
    DWORD    dwOptionIndex;

    ASSERT(dwOptionCount < MAX_PRINTER_OPTIONS);

    if (dwConstraintList == NULL_CONSTRAINT)
        return FALSE;

    for (dwOptionIndex = 0; dwOptionIndex < dwOptionCount; dwOptionIndex++)
    {
        pOption = PGetIndexedOption(pUIInfo, pFeature, dwOptionIndex);

        ASSERT(pOption != NULL);

        switch(dwGid)
        {
        case GID_COLLATE:

            //
            // don't care about constraints for no-collate
            //

            if (((PCOLLATE) pOption)->dwCollateID == DMCOLLATE_FALSE)
                continue;
            break;

        case GID_DUPLEX:

            //
            // don't care about constraints for non-duplex
            //

            if (((PDUPLEX) pOption)->dwDuplexID == DMDUP_SIMPLEX)
                continue;
            break;

        case GID_UNKNOWN:
        default:

            //
            // skip the check for None/False option
            //

            if (pFeature->dwNoneFalseOptIndex == dwOptionIndex)
                continue;
            break;
        }

        if (BSearchConstraintList(pUIInfo, dwConstraintList,
                                  dwFeatureIndex, dwOptionIndex))
        {
            aubConstrainedOption[dwOptionIndex] = 1;
        }

        //
        // If one option is unconstrained, the feature is not constrained by the
        // constraint list
        //
        if (!aubConstrainedOption[dwOptionIndex])
            return FALSE;
    }

    return TRUE;
}


BOOL
_BSupportFeature(
    PCOMMONINFO pci,
    DWORD       dwGid,
    PFEATURE    pFeatureIn
    )

/*++

Routine Description:

    Determine whether the printer supports a feature based on current printer-sticky
    feature selections.

Arguments:

    pci - Points to basic printer information
    dwGid - the GID of the feature to check for constraints. (currently only GID_COLLATE or GID_DUPLEX
            if pFeatureIn is NULL)
    pFeatureIn - pointer to the feature structure if the feature doesn't have predefined GID_xxx value

Return Value:

    TRUE if feature can be supported, FALSE otherwise.

--*/

{
    POPTSELECT pCombinedOptions = pci->pCombinedOptions;
    PUIINFO  pUIInfo = pci->pUIInfo;
    PFEATURE pCheckFeature, pFeature;
    POPTION  pOption;
    BYTE     aubConstrainedOption[MAX_PRINTER_OPTIONS];
    DWORD    dwCheckFeatureIndex, dwCheckOptionCount;
    DWORD    dwFeatureIndex;
    BYTE     ubCurOptIndex, ubNext;

    if (!pCombinedOptions)
        return FALSE;

    if (pFeatureIn)
    {
        //
        // If the input feature pointer is provided, dwGid should be GID_UNKNOWN.
        //

        ASSERT(dwGid == GID_UNKNOWN);

        pCheckFeature = pFeatureIn;
    }
    else
    {
        //
        // If no input feature pointer, use dwGid to find the feature. dwGid should be
        // either GID_DUPLEX or GID_COLLATE.
        //

        ASSERT((dwGid == GID_DUPLEX) || (dwGid == GID_COLLATE));

        if (!(pCheckFeature = GET_PREDEFINED_FEATURE(pUIInfo, dwGid)))
            return FALSE;
    }

    dwCheckFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pCheckFeature);

    dwCheckOptionCount = pCheckFeature->Options.dwCount;

    //
    // Mark all options of the checked feature as non-constrained.
    //

    memset(aubConstrainedOption, 0, sizeof(aubConstrainedOption));

    //
    // Scan the feature list to check if it will be constrained by current selections
    //

    if (!(pFeature = OFFSET_TO_POINTER(pUIInfo->pInfoHeader, pUIInfo->loFeatureList)))
        return FALSE;

    //
    // We only care about printer-sticky features
    //

    pFeature += pUIInfo->dwDocumentFeatures;

    for (dwFeatureIndex = pUIInfo->dwDocumentFeatures;
         dwFeatureIndex < pUIInfo->dwDocumentFeatures + pUIInfo->dwPrinterFeatures;
         dwFeatureIndex++, pFeature++)
    {
         //
         // If the feature's current selection is not None/False, it may constrain the checked feature
         //

         if ((DWORD)pCombinedOptions[dwFeatureIndex].ubCurOptIndex != pFeature->dwNoneFalseOptIndex)
         {
             if (BFeatureIsConstrained(pUIInfo, pCheckFeature, dwCheckFeatureIndex, dwCheckOptionCount,
                                       pFeature->dwUIConstraintList, aubConstrainedOption, dwGid))
                 return FALSE;
         }

         ubNext = (BYTE)dwFeatureIndex;
         while (1)
         {
             ubCurOptIndex = pCombinedOptions[ubNext].ubCurOptIndex;
             pOption = PGetIndexedOption(pUIInfo, pFeature, ubCurOptIndex == OPTION_INDEX_ANY ? 0 : ubCurOptIndex);

             if (pOption && BFeatureIsConstrained(pUIInfo, pCheckFeature, dwCheckFeatureIndex, dwCheckOptionCount,
                                                  pOption->dwUIConstraintList, aubConstrainedOption, dwGid))
                 return FALSE;

             if ((ubNext = pCombinedOptions[ubNext].ubNext) == NULL_OPTSELECT)
                 break;
         }
    }

    //
    // No constraints found, so the feature can be supported.
    //

    return TRUE;
}


VOID
VSyncRevPrintAndOutputOrder(
    PUIDATA    pUiData,
    POPTITEM   pCurItem
    )

/*++

Routine Description:

    For PostScript driver, PPD could have "*OpenUI *OutputOrder", which enables user to
    select "Normal" or "Reverse" output order. In order to avoid spooler performing reverse
    printing simulation, we will ssync up option selections between REVPRINT_ITEM and
    "OutputOrder".

Arguments:

    pUiData - Pointer to UIDATA structure
    pCurItem - Pointer to currently selected option item. It will be non-NULL for
               REVPRINT_ITEM, and will be NULL otherwise.

Return Value:

    None.

--*/

{
    PUIINFO   pUIInfo;
    PPPDDATA  pPpdData;
    PFEATURE  pFeature;
    POPTION   pOption;
    PCSTR     pstrKeywordName;
    POPTITEM  pRevPrintItem, pOutputOrderItem;
    BOOL      bReverse;

    ASSERT(VALIDUIDATA(pUiData));

    pUIInfo = pUiData->ci.pUIInfo;

    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER)pUiData->ci.pRawData);

    ASSERT(pPpdData != NULL);

    if (pPpdData->dwOutputOrderIndex != INVALID_FEATURE_INDEX &&
        (pOutputOrderItem = PFindOptItemWithKeyword(pUiData, "OutputOrder")) &&
        pOutputOrderItem->Sel < 2 &&
        (pFeature = PGetIndexedFeature(pUIInfo, pPpdData->dwOutputOrderIndex)) &&
        (pOption = PGetIndexedOption(pUIInfo, pFeature, pOutputOrderItem->Sel)) &&
        (pstrKeywordName = OFFSET_TO_POINTER(pUIInfo->pubResourceData, pOption->loKeywordName)))
    {
        //
        // "OutputOrder" feature is available.
        //

        if (strcmp(pstrKeywordName, "Reverse") == EQUAL_STRING)
            bReverse = TRUE;
        else
            bReverse = FALSE;

        if (pCurItem)
        {
            //
            // Currently selected item is REVPRINT_ITEM. We should change "OutputOrder" option
            // if needed to match the requested output order.
            //

            if ((pCurItem->Sel == 0 && bReverse) || (pCurItem->Sel == 1 && !bReverse))
            {
                pOutputOrderItem->Sel = 1 - pOutputOrderItem->Sel;
                pOutputOrderItem->Flags |= OPTIF_CHANGED;

                //
                // Save the new settings in the options array
                //

                VUnpackDocumentPropertiesItems(pUiData, pOutputOrderItem, 1);

                //
                // The change could trigger constraints.
                //

                if (ICheckConstraintsDlg(pUiData, pOutputOrderItem, 1, FALSE) == CONFLICT_CANCEL)
                {
                    //
                    // If there is a conflict and the user clicked CANCEL,
                    // we need to restore the origianl selection.
                    //

                    pCurItem->Sel = 1 - pCurItem->Sel;
                    pCurItem->Flags |= OPTIF_CHANGED;

                    VUnpackDocumentPropertiesItems(pUiData, pCurItem, 1);

                    pOutputOrderItem->Sel = 1 - pOutputOrderItem->Sel;
                    pOutputOrderItem->Flags |= OPTIF_CHANGED;

                    VUnpackDocumentPropertiesItems(pUiData, pOutputOrderItem, 1);
                }
            }
        }
        else
        {
            //
            // Sync up REVPRINT_ITEM selection based on "OutputOrder" selection.
            //

            if ((pRevPrintItem = PFindOptItemWithUserData(pUiData, REVPRINT_ITEM)) &&
                ((pRevPrintItem->Sel == 0 && bReverse) || (pRevPrintItem->Sel == 1 && !bReverse)))
            {
                pRevPrintItem->Sel = 1 - pRevPrintItem->Sel;
                pRevPrintItem->Flags |= OPTIF_CHANGED;

                //
                // Save the new settings in the options array
                //

                VUnpackDocumentPropertiesItems(pUiData, pRevPrintItem, 1);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\uni\precomp.h ===
#include "lib.h"
#include <commctrl.h>
#include <winddiui.h>
#include <printoem.h>
#include <prntfont.h>
#include "oemutil.h"
#include "unilib.h"
#include "gpd.h"
#include "uires.h"
#include "uihelp.h"
#include "driverui.h"
#include "oemui.h"
#include "fmoldfm.h"
#include "fontinst.h"
#include "softfont.h"
#include "osff.h"
#include "winres.h"
#include <prcomoem.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\uni\osffread.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    osffread.c

Abstract:

    Functions to assist processing of the data of NT 4.0 soft font
    installer file format.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/02/96 -ganeshp-
        Created

--*/

#include "precomp.h"

#ifndef WINNT_40

// NT 5.0 only


//
// Local function prototypes.
//

INT
IFIOpenRead(
    FI_MEM  *pFIMem,                /* Output goes here */
    PWSTR    pwstrName             /* Name of printer data file */
    )
/*++

Routine Description:

    Makes the font installer file accessible & memory mapped.  Called
    by a driver to gain access to the fonts in the font installer's
    output file.


Arguments:


    FI_MEM : Font Installer Header
    PWSTR  : Font file.

    Return Value:

    Number of records in the file;  0 for an empty/non-existant file.

Note:
    12-02-96: Created it -ganeshp-
--*/

{

    INT     iRet;
    DWORD   dwSize;             /* Size of buffer needed for file name */
    PWSTR   pwstrLocal;

    //
    // Initiazlie to ZERO.
    //
    iRet = 0;

    //
    // Initalize pFIMem
    //
    pFIMem->hFile =  NULL;      /* No data until we have it */
    pFIMem->pbBase = NULL;

    //
    // First map the file to memory.  However,we do need firstly to
    // generate the file name of interest.  This is based on the data
    // file name for this type of printer.
    // Allocate more storage than is indicated:  we MAY want to add
    // a prefix to the file name rather than replace the existing one.
    //

    //
    // Filename + ".fi_" + NULL
    //
    dwSize = sizeof( WCHAR ) * (wcslen( pwstrName ) + 4 + 1);

    if( pwstrLocal = (PWSTR)MemAllocZ( dwSize ) )
    {
        /*  Got the memory,  so fiddle the file name to our standard */

        int    iPtOff;             /* Location of '.' */
        DWORD  dwAttributes;

        StringCchCopyW(pwstrLocal, dwSize / sizeof(WCHAR), pwstrName);

        //
        // Go looking for a '.' - if not found,  append to string.
        //

        iPtOff = wcslen( pwstrLocal );

        while( --iPtOff > 0 )
        {
            if( *(pwstrLocal + iPtOff) == (WCHAR)'.' )
                break;
        }

        if( iPtOff <= 0 )
        {
            iPtOff = wcslen( pwstrLocal );              /* Presume none! */
            *(pwstrLocal + iPtOff) = L'.';
        }
        ++iPtOff;               /* Skip the period */

        //
        // Generate the name and map the file
        //
        StringCchCopyW(pwstrLocal + iPtOff,
                       dwSize / sizeof(WCHAR) - iPtOff,
                       FILE_FONTS);

        //
        // Check the existence of soft font file.
        //
        dwAttributes = GetFileAttributes(pwstrLocal);

        //
        // If the function succeeds, open file. Otherwise return 0.
        //
        if (dwAttributes != 0xffffffff)
        {
            pFIMem->hFile = MapFile( pwstrLocal);

            if (pFIMem->hFile)
            {
                pFIMem->pbBase = pFIMem->hFile;

                iRet = IFIRewind( pFIMem );
            }
        }

        MemFree( pwstrLocal );        /* No longer needed */
    }

    return iRet;

}


BOOL
BFINextRead(
    FI_MEM   *pFIMem
    )
/*++

Routine Description:

    Updates pFIMem to the next entry in the font installer file.
    Returns TRUE if OK, and updates the pointers in pFIMem.

Arguments:

    FI_MEM : Font Installer Header

    Return Value:

    TRUE/FALSE.   FALSE for EOF,  otherwise pFIMem updated.

Note:
    12-02-96: Created it -ganeshp-
--*/

{
    FF_HEADER      *pFFH;               /* Overall file header */
    FF_REC_HEADER  *pFFRH;              /* Per record header */

    /*
     *  Validate that we have valid data.
     */


    if( pFIMem == 0 || pFIMem->hFile == NULL )
        return  FALSE;                          /* Empty file */


    pFFH = (FF_HEADER *)pFIMem->pbBase;

    if( pFFH->ulID != FF_ID )
    {
        ERR(( "UnidrvUI!bFINextRead: FF_HEADER has invalid ID\n" ));
        return  FALSE;
    }

    /*
     *   If pFIMem->pvFix == 0, we should return the data from the
     * first record.  Otherwise,  return the next record in the chain.
     * This is done to avoid the need to have a ReadFirst()/ReadNext()
     * pair of functions.
     */

    if( pFIMem->pvFix )
    {
        /*
         *   The header is located immediately before the data we last
         * returned for the fixed portion of the record.  SO,  we back
         * over it to get the header which then gives us the address
         * of the next header.
         */

        pFFRH = (FF_REC_HEADER *)((BYTE *)pFIMem->pvFix -
                                                 sizeof( FF_REC_HEADER ));

        if( pFFRH->ulRID != FR_ID )
        {
            ERR(( "UnidrvUI!bFINextRead: Invalid FF_REC_HEADER ID\n" ));
            return  FALSE;
        }

        /*
         *   We could check here for EOF on the existing structure, but this
         * is not required BECAUSE THE ulNextOff field will be 0, so when
         * it is added to our current address,  we don't move.  Hence, the
         * check for the NEW address is OK to detect EOF.
         */

        (BYTE *)pFFRH += pFFRH->ulNextOff;              /* Next entry */

    }
    else
    {
        /*   Point to the first record.  */
        pFFRH = (FF_REC_HEADER *)(pFIMem->pbBase + pFFH->ulFixData);
    }

    if( pFFRH->ulNextOff == 0 )
        return  FALSE;

    pFIMem->pvFix = (BYTE *)pFFRH + sizeof( FF_REC_HEADER );
    pFIMem->ulFixSize = pFFRH->ulSize;

    if( pFIMem->ulVarSize = pFFRH->ulVarSize )
        pFIMem->ulVarOff = pFFRH->ulVarOff + pFFH->ulVarData;
    else
        pFIMem->ulVarOff = 0;              /* None here */


    return  TRUE;

}


INT
IFIRewind(
    FI_MEM   *pFIMem               /* File of importance */
    )
/*++

Routine Description:

    Reset pFIMem to the first font in the file.

Arguments:

    FI_MEM : Font Installer Header

    Return Value:

    Number of entries in the file.

Note:
    12-02-96: Created it -ganeshp-
--*/

{
    /*
     *  Not hard!  The pFIMem contains the base address of the file, so we
     * use this to find the address of the first record,  and any variable
     * data that corresponds with it.
     */

    FF_HEADER      *pFFH;
    FF_REC_HEADER  *pFFRH;

    if( pFIMem == 0 || pFIMem->hFile == NULL )
        return  0;                              /* None! */


    /*
     *   The location of the first record is specified in the header.
     */

    pFFH = (FF_HEADER *)pFIMem->pbBase;
    if( pFFH->ulID != FF_ID )
    {
        ERR(( "UnidrvUI!iFIRewind: FF_HEADER has invalid ID\n" ));
        return  0;
    }

    pFFRH = (FF_REC_HEADER *)(pFIMem->pbBase + pFFH->ulFixData);

    if( pFFRH->ulRID != FR_ID )
    {
        ERR(( "UnidrvUI!iFIRewind: Invalid FF_REC_HEADER ID\n" ));
        return  0;
    }

    /*
     * Set the pvFix field in the header to 0.  This is used in bFINextRead
     * to mean that the data for the first record should be supplied.
     */
    pFIMem->pvFix = 0;          /* MEANS USE FIRST NEXT READ */
    pFIMem->ulFixSize = 0;
    pFIMem->ulVarOff = 0;       /* None here */

    return  pFFH->ulRecCount;

}


BOOL
BFICloseRead(
    FI_MEM  *pFIMem                /* File/memory we are finished with */
    )
/*++

Routine Description:

    Called when finished with this font file.

Arguments:

    FI_MEM : Font Installer Header
    PDEV:    Pointer to PDEV

    Return Value:

    TRUE for success and FALSE for failure.

Note:
    12-02-96: Created it -ganeshp-
--*/

{
    /*
     *   Easy!  All we need do is unmap the file.  We have the address too!
     */

    BOOL   bRet;                /* Return code */


    if( pFIMem == 0 || pFIMem->hFile == NULL )
        return  TRUE;           // Nothing there to Free.


    bRet =  FREEMODULE( pFIMem->hFile);
    pFIMem->hFile = NULL;       // Stops freeing more than once


    return  bRet;

}


PVOID
MapFile(
    PWSTR   pwstr
    )
/*++
Routine Description:
    Returns a pointer to the mapped file defined by pwstr.

Arguments:
    pwstr   UNICODE string containing fully qualified pathname of the
            file to map.

Return Value:
    Pointer to mapped memory if success, NULL if error.

Note:
    UnmapViewOfFile will have to be called by the user at some point to free up
    this allocation.Macro FREEMODULE can be used for this purpose.

    11/3/1997 -ganeshp-
        Created it.
--*/

{
    PVOID   pv;
    HANDLE  hFile, hFileMap;

    //
    // open the file we are interested in mapping.
    //

    pv = NULL;

    if ((hFile = CreateFileW(pwstr,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL))
        != INVALID_HANDLE_VALUE)
    {
        //
        // create the mapping object.
        //

        if (hFileMap = CreateFileMappingW(hFile,
                                          NULL,
              PAGE_READONLY,
              0,
              0,
              (PWSTR)NULL))
        {
            //
            // get the pointer mapped to the desired file.
            //

            if (!(pv = (PVOID)MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 0)))
            {
                ERR(("Unidrvui!MapFile: MapViewOfFile failed.\n"));
            }

            //
            // now that we have our pointer, we can close the file and the
            // mapping object.
            //

            if (!CloseHandle(hFileMap))
                ERR(("Unidrvui!MapFile: CloseHandle(hFileMap) failed.\n"));
        }
        else
            ERR(("Unidrvui!MapFile:CreateFileMappingW failed: %s\n",pwstr));

        if (!CloseHandle(hFile))
            ERR(("Unidrvui!MapFile: CloseHandle(hFile) failed.\n"));
    }
    else
        ERR(("Unidrvui!Mapfile:CreateFileW failed for %s\n",pwstr));

    return(pv);
}

#endif //ifndef WINNT_40
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\uni\osff.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oldsfiff.h

Abstract:

    Data structures  used for reading the NT 4.0 font installer file format.
    Typically used by drivers during upgrade from NT 4.0 to 5.0.
    EnabldPDEV() time - at the time of writing!  Subject to change as the
    DDI/GDI change.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/02/96 -ganeshp-
        Created

    dd-mm-yy -author-
        description

--*/

/*
 *   The following structure is returned from the FIOpenRead() function,
 * and contains the basic information needed to access the data in the
 * file once it is memory mapped.
 */

typedef  struct
{
    VOID  *hFile;               /* Font installer file, for downloaded part */
    BYTE  *pbBase;              /* Base address of data as mapped */
    void  *pvFix;               /* Fixed part at start of file */
    ULONG  ulFixSize;           /* Bytes in fixed data record */
    ULONG  ulVarOff;            /* File offset of data, relative file start */
    ULONG  ulVarSize;           /* Bytes in variable part */
}  FI_MEM;


/*
 *      Definitions used in the font file.  This is the file which holds
 *      information about cartridge and download fonts.  The file format
 *      is quite basic:  a header for verification; then an array of
 *      records,  each with a header.  These records contain FONTMAP
 *      information.  Cartridges have an array of these, one for each
 *      font.  Finally,  the tail of the file contains extra data, as
 *      required.  For download fonts,  this would be the download data.
 *
 */


/*
 *   The file header.   One of these is located at the beginning of the file.
 *  The ulVarData field is relative to the beginning of the file.  This
 *  makes it easier to regenerate the file when fonts are deleted.
 */

typedef  struct
{
    ULONG   ulID;               /* ID info - see value below */
    ULONG   ulVersion;          /* Version information - see below */
    ULONG   ulFixData;          /* Start of FF_REC_HEADER array */
    ULONG   ulFixSize;          /* Number of bytes in fixed section */
    ULONG   ulRecCount;         /* Number of records in fixed part */
    ULONG   ulVarData;          /* Start of variable data, rel to 0 */
    ULONG   ulVarSize;          /* Numbier of bytes in variable portion */
}  FF_HEADER;

/*
 *   Values for the ID and Version fields.
 */

#define FF_ID           0x6c666e66              /* "fnfl" - fOnTfIlE */
#define FF_VERSION      1                       /* Start at the bottom */

/*
 *   Each entry in the file starts with the following header.  Typically
 * there will be one of these for a softfont, and one per cartridge.
 * In the case of a cartridge,  there will be an array of these, within
 * the master entry.  Each sub-entry will be for one specific font.
 *
 *   Note that there is a dummy entry at the end.  This contains a 0
 * in the ulSize field - it is to mark the last one,  and makes it
 * easier to manipulate the file.
 */

typedef  struct
{
    ULONG   ulRID;              /* Record ID */
    ULONG   ulNextOff;          /* Offset from here to next record: 0 == end */
    ULONG   ulSize;             /* Bytes in this record */
    ULONG   ulVarOff;           /* Offset from start of variable data */
    ULONG   ulVarSize;          /* Number of bytes in variable part */
}  FF_REC_HEADER;

#define FR_ID           0x63657266              /* "frec" - fONT recORD */

/*
 *   Define the file extensions used.  The first is the name of the
 * font installer file;  the others are temporaries used during update
 * of the (possibly) existing file.
 */


#define  FILE_FONTS     L"fi_"           /* "Existing" single file */
#define  TFILE_FIX      L"fiX"           /* Fixed part of file */
#define  TFILE_VAR      L"fiV"           /* Variable (optional) portion */

#define FREEMODULE(hmodule) UnmapViewOfFile((PVOID) (hmodule))

/*
 * Upgrade related Function Declarations.
 */


INT
IFIOpenRead(
    FI_MEM  *pFIMem,
    PWSTR    pwstrName
    );
BOOL
BFINextRead(
    FI_MEM   *pFIMem
    );
INT
IFIRewind(
    FI_MEM   *pFIMem
    );
BOOL
BFICloseRead(
    FI_MEM  *pFIMem
    );

PVOID MapFile(
    PWSTR   pwstr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\uni\sfupgrd.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

     sfupgrd.c

Abstract:

    Routines to upgrade the NT 4.0 SoftFont File format to NT 5.0 file format.

Environment:

    Windows NT Unidrv driver

Revision History:

    29/10/97 -ganeshp-
        Created

--*/
#include "precomp.h"

#ifndef WINNT_40 

// NT 5.0 only


//
// Internal helper function prototype
//

HANDLE HCreateHeapForCI();


BOOL
BSoftFontsAreInstalled(
    HANDLE   hPrinter
    )
/*++
Routine Description:

Arguments:
    Determine whether font installer keys are present in the registry or not.

Return Value:
    TRUE/FALSE,  TRUE meaning New keys are Present

Note:

    10/29/1997 -ganeshp-
        Created it.
--*/

{

    BOOL    bRet      = FALSE;
    DWORD   dwType    = REG_SZ ;
    DWORD   cbNeeded  = 0;
    DWORD   dwErrCode = 0;

    dwErrCode = GetPrinterData( hPrinter, REGVAL_FONTFILENAME, &dwType,
                                NULL,0, &cbNeeded );

    if ( cbNeeded &&
         ((dwErrCode == ERROR_MORE_DATA) ||
          (dwErrCode == ERROR_INSUFFICIENT_BUFFER))
       )
    {
        bRet = TRUE;
    }

    return bRet;
}

BOOL
BIsUNIDRV(
    PDRIVER_UPGRADE_INFO_2 pUpgradeInfo
    )
/*++

Routine Description:
    This routine checks if new driver is UNIDRV base GPD minidriver.

Arguments:

    pUpgradeInfo    Upgrade Info 2 structure.

Return Value:

    TRUE if it's UNIDRV, Otherwise FALSE.

Note:

--*/
{
    PWSTR pDriverName;     // Old Printer Driver data file name

    //
    // Search "UNIDRV" string in the pDriverPath. If there is, 
    // it is GPD base printer driver.
    // since the end of string must be "UNIDRV.DLL" in case of GPD minidriver.
    // Compare it with "unidrv.dll".
    //
    // Get the unqulaified driver name. Add +1 to point to first letter 
    // of driver name.
    //
    pDriverName = wcsrchr( pUpgradeInfo->pDriverPath, L'\\' ) + 1; 
    return (0 == _wcsicmp(pDriverName, L"unidrv.dll"));

}


BOOL
BUpgradeSoftFonts(
    PCOMMONINFO             pci,
    PDRIVER_UPGRADE_INFO_2  pUpgradeInfo
)

/*++

Routine Description:
    This routine upgrade the NT 4.0 soft font file to NT 5.0  format.

Arguments:

    pci             Structure containing all necessary information.
    pUpgradeInfo    Upgrade Info structure.

Return Value:

    TRUE for success, FALSE for failure.
Note:
    10/29/97: Created it -ganeshp-


--*/
{

    INT      iNum;              // Number of fonts
    INT      iI,iRet;           // Loop parameter
    FI_MEM   FIMem;             // For accessing installed fonts
    BOOL     bRet;
    LPTSTR   pOldDataFile;     // Old Printer Driver data file name

    bRet    = FALSE;
    pOldDataFile = NULL ;

    ASSERT(pci);

    //
    // Create heap if it is not allocated yet.
    //
    if (!pci->hHeap)
        pci->hHeap = HCreateHeapForCI();

    //
    // Check if any soft fonts are installed. If yes then we don't need to do
    // anything. return TRUE.
    //

    pOldDataFile = pUpgradeInfo->pDataFile;

    if ( pUpgradeInfo->pOldDriverDirectory &&
         !BIsUNIDRV(pUpgradeInfo) &&
         !BSoftFontsAreInstalled(pci->hPrinter) )
    {
        //
        // Initialize Old driver's datafile
        //

        if (iNum = IFIOpenRead( &FIMem, pOldDataFile) )
        {
            VERBOSE(( "UniFont!iXtraFonts: ++++ Got %ld EXTRA FONTS", iNum ));

            for( iRet = 0, iI = 0; iI < iNum; ++iI )
            {
                if( BFINextRead( &FIMem ) )
                {
                    PVOID pPCLData;

                    //
                    // Get the Pointer to PCL data
                    //
                    pPCLData = FIMem.pbBase + FIMem.ulVarOff;

                    //
                    // Now Call the fontinstaller to install the font.
                    //
                    if (BInstallSoftFont( pci->hPrinter, pci->hHeap, pPCLData, FIMem.ulVarSize) )
                        ++iRet;
                    else
                    {
                        ERR(("Unidrvui!BUpgradeSoftFonts:BInstallSoftFont Failed.\n"));
                        goto ErrorExit;
                    }
                }
                else
                    break;              /* Should not happen */
            }

            if( !BFICloseRead(&FIMem))
            {
                ERR(("\nUniFont!iXtraFonts: bFICloseRead() fails\n" ));
            }
        }
    }


    bRet = TRUE;

    //
    // Here means that there are no fonts OR that the HeapAlloc()
    // failed.  In either case,  return no fonts.
    //

    ErrorExit:

    return  bRet;
}
#endif //ifndef WINNT_40
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\uni\softfont.h ===
/***************************** MODULE HEADER ********************************
 *  sf_pcl.h
 *      Structures etc used to define PCL Softfont file format.
 *
 *  Copyright (C) 1992  Microsoft Corporation.
 *
 *****************************************************************************/

#ifndef SOFTFONT_H_

#define SOFTFONT_H_

/*
 *    A structure corresponding to the layout of Font Descriptor for a PCL
 *  soft font file.  The Font Descriptor is at the beginning of the file,
 *  and contains overall font info.
 *
 *    Note that there are several different versions of this structure;
 *  the first is the original (pre LJ4) format,  while the second is
 *  the LJ4 introduced variety that allows specifying the resolution
 *  at which the font was digitised.  This is used for downloading TT
 *  fonts etc. which are generated at the graphics resolution.
 *
 *    NOTE:  The data layout is designed for the 68000 family - which is
 *  big endian.  So,  an amount of shuffling is required for little
 *  endian machines like the x86.
 */

typedef  signed  char  SBYTE;

#define SFH_NM_SZ       16      /* Bytes allowed in name field */

typedef  struct
{
    WORD   wSize;               /* Number of bytes in here */
    BYTE   bFormat;             /* Format: original, TT, intellifont, etc */
    BYTE   bFontType;           /* 7, 8 or PC-8 style font */
    WORD   wRes1;               /* Reserved */
    WORD   wBaseline;           /* Baseline to cell top, PCL dots */
    WORD   wCellWide;           /* Cell width in dots */
    WORD   wCellHeight;         /* Cell height in dots */
    BYTE   bOrientation;        /* Orientation: 0 portrait, 1 Landscape */
    BYTE   bSpacing;            /* 0 fixed pitch, 1 proportional */
    WORD   wSymSet;             /* Symbol set, using HP encoding */
    WORD   wPitch;              /* Pitch in quarter dot units == HMI */
    WORD   wHeight;             /* Design height in quarter dot units */
    WORD   wXHeight;            /* Design height, quarter dots, of x */
    SBYTE  sbWidthType;         /* Relative width of glyphs */
    BYTE   bStyle;              /* 0 for regular, 1 for italic */
    SBYTE  sbStrokeW;           /* Stroke weight; -7 (thin) to +7 (thick) */
    BYTE   bTypeface;           /* Typeface ID - predefined types */
    BYTE   bRes2;
    BYTE   bSerifStyle;         /* Serif style; predefined values */
    WORD   wRes3;
    SBYTE  sbUDist;             /* Underline distance from baseline */
    BYTE   bUHeight;            /* Underline height */
    WORD   wTextHeight;         /* Quarter dot interline spacing */
    WORD   wTextWidth;          /* Quarter dot glyph increment */
    WORD   wRes4;
    WORD   wRes5;
    BYTE   bPitchExt;           /* Additional pitch resolution */
    BYTE   bHeightExt;          /* Ditto, for height */
    WORD   wRes6;
    WORD   wRes7;
    WORD   wRes8;
    char   chName[ SFH_NM_SZ ]; /* May not be null terminated! */
} SF_HEADER;


typedef  struct
{
    WORD   wSize;               /* Number of bytes in here */
    BYTE   bFormat;             /* Format: original, TT, intellifont, etc */
    BYTE   bFontType;           /* 7, 8 or PC-8 style font */
    WORD   wRes1;               /* Reserved */
    WORD   wBaseline;           /* Baseline to cell top, PCL dots */
    WORD   wCellWide;           /* Cell width in dots */
    WORD   wCellHeight;         /* Cell height in dots */
    BYTE   bOrientation;        /* Orientation: 0 portrait, 1 Landscape */
    BYTE   bSpacing;            /* 0 fixed pitch, 1 proportional */
    WORD   wSymSet;             /* Symbol set, using HP encoding */
    WORD   wPitch;              /* Pitch in quarter dot units == HMI */
    WORD   wHeight;             /* Design height in quarter dot units */
    WORD   wXHeight;            /* Design height, quarter dots, of x */
    SBYTE  sbWidthType;         /* Relative width of glyphs */
    BYTE   bStyle;              /* 0 for regular, 1 for italic */
    SBYTE  sbStrokeW;           /* Stroke weight; -7 (thin) to +7 (thick) */
    BYTE   bTypeface;           /* Typeface ID - predefined types */
    BYTE   bRes2;
    BYTE   bSerifStyle;         /* Serif style; predefined values */
    WORD   wRes3;
    SBYTE  sbUDist;             /* Underline distance from baseline */
    BYTE   bUHeight;            /* Underline height */
    WORD   wTextHeight;         /* Quarter dot interline spacing */
    WORD   wTextWidth;          /* Quarter dot glyph increment */
    WORD   wRes4;
    WORD   wRes5;
    BYTE   bPitchExt;           /* Additional pitch resolution */
    BYTE   bHeightExt;          /* Ditto, for height */
    WORD   wRes6;
    WORD   wRes7;
    WORD   wRes8;
    char   chName[ SFH_NM_SZ ]; /* May not be null terminated! */
    WORD   wXResn;              /* X resolution of font design */
    WORD   wYResn;              /* Y design resolution */
} SF_HEADER20;


/*
 *   Typical values used above to identify different types of fonts.
 */

#define PCL_FM_ORIGINAL     0     /* Bitmap font, digitised at 300 DPI */
#define PCL_FM_RESOLUTION  20     /* Bitmap font, includes digitised resn */
#define PCL_FM_TT          15     /* TT scalable, bound or unbound */


/*   bFontType values */

#define PCL_FT_7BIT     0       /* 7 bit: glyphs from 32 - 127 inc */
#define PCL_FT_8LIM     1       /* 8 bit, glyphs 32 - 127 & 160 - 255 */
#define PCL_FT_PC8      2       /* PC-8, glyphs 0 - 255, transparent too! */


/*   sbStrokeW values */

#define PCL_LIGHT       -3
#define PCL_BOLD         3



/*
 *   In addition,  each glyph in the font contains a Character Descriptor.
 *  So now define a structure for that too!
 */

typedef  struct
{
    BYTE    bFormat;            /* Format identifier: 4 for PCL 4 */
    BYTE    bContinuation;      /* Set if continuation of prior entry */
    BYTE    bDescSize;          /* Size of this structure */
    BYTE    bClass;             /* Format of data: 1 for PCL 4 */
    BYTE    bOrientation;       /* Zero == portrait; 1 == landscape */
    BYTE    bRes0;
    short   sLOff;              /* Dots from ref. to left side of char */
    short   sTOff;              /* Dots from ref. to top of char */
    WORD    wChWidth;           /* Char width in dots */
    WORD    wChHeight;          /* Char height in dots */
    WORD    wDeltaX;            /* Quarter dot position increment after print */
} CH_HEADER;

/*
 *   Character records can be continued due to the limit of 32767 bytes in
 * a PCL command sequence.  Continuation records have the following
 * format.  Really it is only the first two elements of the above
 * structure.
 */

typedef  struct
{
    BYTE    bFormat;            /* Format identifier; 4 for PCL 4 */
    BYTE    bContinuation;      /* TRUE if this is a continuation record */
}  CH_CONT_HDR;

/*
 *   Values for some of the fields in the above structs.
 */

/*  bFormat */
#define CH_FM_RASTER             4      /* Bitmap type */
#define CH_FM_SCALE             10      /* Intellifont scalable */

/*  bClass */
#define CH_CL_BITMAP            1       /* A bitmap font */
#define CH_CL_COMPBIT           2       /* Compressed bitmap */
#define CH_CL_CONTOUR           3       /* Intellifont scalable contour */
#define CH_CL_COMPCONT          4       /* Ditto, but compound contour */

#define EXP_SIZE        2

#define FDH_VER 0x100           /* 1.00 in BCD */

/*
 *  Flags bits.
 */
#define FDH_SOFT        0x0001  /* Softfont, thus needs downloading */
#define FDH_CART        0x0002  /* This is a cartridge font */
#define FDH_CART_MAIN   0x0004  /* Main (first) entry for this cartridge */

/*
 *  Selection criteria bits:  dwSelBits.  These bits are used as
 * follows.  During font installation,  the installer set the following
 * values as appropriate.  During initialisation,  the driver sets
 * up a mask of these bits,  depending upon the printer's abilities.
 * For example,  the FDH_SCALABLE bit is set only if the printer can
 * handle scalable fonts.   When the fonts are examined to see if
 * they are usable,  the following test is applied:
 *
 *      (font.dwSelBits & printer.dwSelBits) == font.dwSelBits
 *
 * If true,  the font is usable.
 */

#define FDH_LANDSCAPE   0x00000001      /* Font is landscape orientation */
#define FDH_PORTRAIT    0x00000002      /* Font is portrait */
#define FDH_OR_REVERSE  0x00000004      /* 180 degree rotation of above */
#define FDH_BITMAP      0x00000008      /* Bitmap font */
#define FDH_COMPRESSED  0x00000010      /* Data is compressed bitmap */
#define FDH_SCALABLE    0x00000020      /* Font is scalable */
#define FDH_CONTOUR     0x00000040      /* Intellifont contour */

#define FDH_ERROR       0x80000000      /* Set if some error condition */

#endif  // #ifndef SOFTFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\ps\psoemhlp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved.

Module Name:

    psoemhlp.c

Abstract:

    PostScript helper functions for OEM UI plugins

        HSetOptions

Author:

    Feng Yue (fengy)

    8/24/2000 fengy Completed with support of both PPD and driver features.
    7/21/2000 fengy Created it with function framework.

--*/

#include "precomp.h"

//
// PS driver's helper functions for OEM UI plugins
//


/*++

Routine Name:

    VUpdatePSF_EMFFeatures

Routine Description:

    change EMF features' settings to make sure they are in sync with each other

Arguments:

    pci - pointer to driver's COMMONINFO structure
    dwChangedItemID - ID to indicate which item has been changed

Return Value:

    None

Last Error:

    None

--*/
VOID
VUpdatePSF_EMFFeatures(
    IN  PCOMMONINFO  pci,
    IN  DWORD        dwChangedItemID
    )
{
    PDEVMODE    pdm = pci->pdm;
    PPSDRVEXTRA pdmPrivate = pci->pdmPrivate;

    //
    // (refer to VUpdateEmfFeatureItems and VUnpackDocumentPropertiesItems)
    //

    if (!((PUIDATA)pci)->bEMFSpooling)
    {
        ERR(("VUpdatePSF_EMFFeatures: spooler EMF disabled\n"));
        return;
    }

    if (dwChangedItemID != METASPOOL_ITEM)
    {
        if (!ISSET_MFSPOOL_FLAG(pdmPrivate))
        {
            //
            // need to turn driver EMF on to support the EMF feature
            //

            if (dwChangedItemID == NUP_ITEM)
            {
                //
                // booklet
                //

                if (NUPOPTION(pdmPrivate) == BOOKLET_UP)
                {
                    TERSE(("EMF turned on for BOOKLET_UP\n"));
                    SET_MFSPOOL_FLAG(pdmPrivate);
                }
            }
            else if (dwChangedItemID == REVPRINT_ITEM)
            {
                BOOL bReversed = BGetPageOrderFlag(pci);

                //
                // reverse printing
                //

                if ((!REVPRINTOPTION(pdmPrivate) && bReversed) ||
                    (REVPRINTOPTION(pdmPrivate) && !bReversed))
                {
                    TERSE(("EMF turned on for reverse order\n"));
                    SET_MFSPOOL_FLAG(pdmPrivate);
                }
            }
            else if (dwChangedItemID == COPIES_COLLATE_ITEM)
            {
                //
                // collate
                //

                if ((pdm->dmFields & DM_COLLATE) &&
                    (pdm->dmCollate == DMCOLLATE_TRUE) &&
                    !PRINTER_SUPPORTS_COLLATE(pci))
                {
                    TERSE(("EMF turned on for collate\n"));
                    SET_MFSPOOL_FLAG(pdmPrivate);
                }
            }
            else
            {
                RIP(("unknown dwChangedItemID: %d\n", dwChangedItemID));
            }
        }
    }
    else
    {
        //
        // driver EMF option has being changed
        //

        if (!ISSET_MFSPOOL_FLAG(pdmPrivate))
        {
            BOOL bReversed = BGetPageOrderFlag(pci);

            //
            // drier EMF option is turned off, need to handle several EMF features

            //
            // booklet
            //

            if (NUPOPTION(pdmPrivate) == BOOKLET_UP)
            {
                TERSE(("EMF off, so BOOKLET_UP to ONE_UP\n"));
                NUPOPTION(pdmPrivate) = ONE_UP;
            }

            //
            // collate
            //

            if ((pdm->dmFields & DM_COLLATE) &&
                (pdm->dmCollate == DMCOLLATE_TRUE) &&
                !PRINTER_SUPPORTS_COLLATE(pci))
            {
                TERSE(("EMF off, so collate off\n"));
                pdm->dmCollate = DMCOLLATE_FALSE;

                //
                // Update Collate feature option index
                //

                ChangeOptionsViaID(pci->pInfoHeader,
                                   pci->pCombinedOptions,
                                   GID_COLLATE,
                                   pdm);
            }

            //
            // reverse order printing
            //

            if ((!REVPRINTOPTION(pdmPrivate) && bReversed) ||
                (REVPRINTOPTION(pdmPrivate) && !bReversed))
            {
                TERSE(("EMF off, so reverse %d\n", bReversed));
                REVPRINTOPTION(pdmPrivate) = bReversed;
            }
        }
    }
}


/*++

Routine Name:

    BUpdatePSF_RevPrintAndOutputOrder

Routine Description:

    sync up settings between driver synthesized feature %PageOrder
    and PPD feature *OutputOrder to avoid spooler simulation

Arguments:

    pci - pointer to driver's COMMONINFO structure
    dwChangedItemID - ID to indicate which item has been changed

Return Value:

    TRUE      if the sync up succeeds
    FALSE     if there is no PPD feature "OutputOrder" or current
              setting for "OutputOrder" is invalid

Last Error:

    None

--*/
BOOL
BUpdatePSF_RevPrintAndOutputOrder(
    IN  PCOMMONINFO  pci,
    IN  DWORD        dwChangedItemID
    )
{
    PUIINFO   pUIInfo = pci->pUIInfo;
    PPPDDATA  pPpdData;
    PFEATURE  pFeature;

    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER(pci->pInfoHeader);
    ASSERT(pPpdData != NULL && pPpdData->dwSizeOfStruct == sizeof(PPDDATA));

    //
    // refer to VSyncRevPrintAndOutputOrder
    //

    if (pPpdData &&
        pPpdData->dwOutputOrderIndex != INVALID_FEATURE_INDEX &&
        (pFeature = PGetIndexedFeature(pUIInfo, pPpdData->dwOutputOrderIndex)))
    {
        INT      iSelection;
        POPTION  pOption;
        PCSTR    pstrOptionName;
        BOOL     bReverse;

        //
        // "OutputOrder" feature is available. We only recognize the 2 standard options
        // "Normal" and "Reverse".
        //

        iSelection = pci->pCombinedOptions[pPpdData->dwOutputOrderIndex].ubCurOptIndex;

        if (iSelection < 2 &&
            (pOption = PGetIndexedOption(pUIInfo, pFeature, iSelection)) &&
            (pstrOptionName = OFFSET_TO_POINTER(pUIInfo->pubResourceData, pOption->loKeywordName)))
        {
            PPSDRVEXTRA pdmPrivate = pci->pdmPrivate;

            if (strcmp(pstrOptionName, "Reverse") == EQUAL_STRING)
                bReverse = TRUE;
            else
                bReverse = FALSE;

            if (dwChangedItemID == REVPRINT_ITEM)
            {
                //
                // reverse printing setting has just being changed. We should change
                // "OutputOrder" option if needed to match the requested output order.
                //

                if ((!REVPRINTOPTION(pdmPrivate) && bReverse) ||
                    (REVPRINTOPTION(pdmPrivate) && !bReverse))
                {
                    TERSE(("RevPrint change causes OutputOrder to be %d\n", 1 - iSelection));
                    pci->pCombinedOptions[pPpdData->dwOutputOrderIndex].ubCurOptIndex = (BYTE)(1 - iSelection);
                }
            }
            else
            {
                //
                // output order setting has just being changed. We should change reverse
                // printing option to match the request output order.
                //

                TERSE(("OutputOrder change causes RevPrint to be %d\n", bReverse));
                REVPRINTOPTION(pdmPrivate) = bReverse;
            }

            //
            // sync between reverse print and output order succeeeded
            //

            return TRUE;
        }
    }

    //
    // sync between reverse print and output order failed
    //

    return FALSE;
}


/*++

Routine Name:

    VUpdatePSF_BookletAndDuplex

Routine Description:

    sync up settings between driver synthesized feature %PagePerSheet
    and PPD feature *Duplex

Arguments:

    pci - pointer to driver's COMMONINFO structure
    dwChangedItemID - ID to indicate which item has been changed

Return Value:

    None

Last Error:

    None

--*/
VOID
VUpdatePSF_BookletAndDuplex(
    IN  PCOMMONINFO  pci,
    IN  DWORD        dwChangedItemID
    )
{
    PUIINFO     pUIInfo = pci->pUIInfo;
    PFEATURE    pDuplexFeature;

    //
    // refer to VUpdateBookletOption
    //

    if (pDuplexFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_DUPLEX))
    {
        PDUPLEX     pDuplexOption;
        DWORD       dwFeatureIndex, dwOptionIndex;
        PPSDRVEXTRA pdmPrivate = pci->pdmPrivate;

        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pDuplexFeature);
        dwOptionIndex = pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex;
        pDuplexOption = PGetIndexedOption(pUIInfo, pDuplexFeature, dwOptionIndex);

        if (pDuplexOption &&
            pDuplexOption->dwDuplexID == DMDUP_SIMPLEX &&
            NUPOPTION(pdmPrivate) == BOOKLET_UP)
        {
            ASSERT(((PUIDATA)pci)->bEMFSpooling);

            if (dwChangedItemID == NUP_ITEM)
            {
                DWORD  cIndex;

                //
                // Booklet is enabled - turn duplex on
                //

                pDuplexOption = PGetIndexedOption(pUIInfo, pDuplexFeature, 0);

                for (cIndex = 0 ; cIndex < pDuplexFeature->Options.dwCount; cIndex++)
                {
                    if (pDuplexOption->dwDuplexID != DMDUP_SIMPLEX)
                    {
                        TERSE(("Booklet change causes Duplex to be %d\n", cIndex));
                        pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex = (BYTE)cIndex;
                        break;
                    }

                    pDuplexOption++;
                }
            }
            else
            {
                ASSERT(dwChangedItemID == DUPLEX_ITEM);

                //
                // Duplex is turned off, so disable booklet and set to 2 up.
                //

                TERSE(("Simplex change causes Booklet to be 2up\n"));
                NUPOPTION(pdmPrivate) = TWO_UP;
            }
        }
    }
}


/*++

Routine Name:

    HSetOptions

Routine Description:

    set new driver settings for PPD features and driver synthesized features

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the set operation
    pmszFeatureOptionBuf - MULTI_SZ ASCII string containing new settings'
                           feature/option keyword pairs
    cbin - size in bytes of the pmszFeatureOptionBuf string
    pdwResult - pointer to the DWORD that will store the result of set operation

Return Value:

    S_OK           if the set operation succeeds
    E_INVALIDARG   if input pmszFeatureOptionBuf is not in valid MULTI_SZ format,
                   or flag for the set operation is not recognized
    E_FAIL         if the set operation fails

Last Error:

    None

--*/
HRESULT
HSetOptions(
    IN  POEMUIOBJ  poemuiobj,
    IN  DWORD      dwFlags,
    IN  PCSTR      pmszFeatureOptionBuf,
    IN  DWORD      cbIn,
    OUT PDWORD     pdwResult
    )
{
    PCOMMONINFO  pci = (PCOMMONINFO)poemuiobj;
    PDEVMODE     pdm;
    PPSDRVEXTRA  pdmPrivate;
    PUIINFO      pUIInfo;
    PPPDDATA     pPpdData;
    PCSTR        pszFeature, pszOption;
    BOOL         bPageSizeSet = FALSE, bPrinterSticky, bNoConflict;
    INT          iMode;
    LAYOUT       iOldLayout;

    //
    // do some validation on the input parameters
    //

    if (!BValidMultiSZString(pmszFeatureOptionBuf, cbIn, TRUE))
    {
        ERR(("Set: invalid MULTI_SZ input param\n"));
        return E_INVALIDARG;
    }

    if (!(dwFlags & SETOPTIONS_FLAG_RESOLVE_CONFLICT) &&
        !(dwFlags & SETOPTIONS_FLAG_KEEP_CONFLICT))
    {
        ERR(("Set: invalid dwFlags %d\n", dwFlags));
        return E_INVALIDARG;
    }

    pUIInfo = pci->pUIInfo;

    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER(pci->pInfoHeader);
    ASSERT(pPpdData != NULL && pPpdData->dwSizeOfStruct == sizeof(PPDDATA));

    if (pPpdData == NULL)
    {
        return E_FAIL;
    }

    pdm = pci->pdm;

    bPrinterSticky = ((PUIDATA)pci)->iMode == MODE_PRINTER_STICKY ? TRUE : FALSE;

    if (!bPrinterSticky)
    {
        ASSERT(pdm);
        pdmPrivate = (PPSDRVEXTRA)GET_DRIVER_PRIVATE_DEVMODE(pdm);
        iOldLayout = NUPOPTION(pdmPrivate);

        //
        // First we need to propagate devmode settings (in case
        // plugin has changed it) into option array.
        //
        // devmode is only valid in non printer-sticky mode. Refer to comments
        // in HEnumConstrainedOptions().
        //

        VFixOptionsArrayWithDevmode(pci);
    }

    //
    // Then set each feature specified by plugin.
    //

    pszFeature = pmszFeatureOptionBuf;

    while (*pszFeature)
    {
        DWORD cbFeatureKeySize, cbOptionKeySize;

        cbFeatureKeySize = strlen(pszFeature) + 1;
        pszOption = pszFeature + cbFeatureKeySize;
        cbOptionKeySize = strlen(pszOption) + 1;

        //
        // Feature or option setting string can't be empty.
        //

        if (cbFeatureKeySize == 1 || cbOptionKeySize == 1)
        {
            ERR(("Set: empty feature or option keyword\n"));
            goto next_feature;
        }

        if (*pszFeature == PSFEATURE_PREFIX)
        {
            PPSFEATURE_ENTRY pEntry, pMatchEntry;

            //
            // synthesized PS driver feature
            //

            pMatchEntry = NULL;
            pEntry = (PPSFEATURE_ENTRY)(&kPSFeatureTable[0]);

            while (pEntry->pszPSFeatureName)
            {
                if ((*pszFeature == *(pEntry->pszPSFeatureName)) &&
                    (strcmp(pszFeature, pEntry->pszPSFeatureName) == EQUAL_STRING))
                {
                    pMatchEntry = pEntry;
                    break;
                }

                pEntry++;
            }

            //
            // See comments in HEnumConstrainedOptions for following stickiness mode check.
            //

            if (!pMatchEntry ||
                (bPrinterSticky && !pMatchEntry->bPrinterSticky) ||
                (!bPrinterSticky && pMatchEntry->bPrinterSticky))
            {
                VERBOSE(("Set: invalid or mode-mismatched feature %s\n", pszFeature));
                goto next_feature;
            }

            if (pMatchEntry->pfnPSProc)
            {
                BOOL  bResult;

                bResult = (pMatchEntry->pfnPSProc)(pci->hPrinter,
                                                   pUIInfo,
                                                   pPpdData,
                                                   pdm,
                                                   pci->pPrinterData,
                                                   pszFeature,
                                                   pszOption,
                                                   NULL,
                                                   0,
                                                   NULL,
                                                   PSFPROC_SETOPTION_MODE);

                if (bResult)
                {
                    //
                    // PS driver EMF features EMF, PageOrder, Nup need special postprocessing
                    // to synchronize among EMF features (refer to cpcbDocumentPropertyCallback).
                    //

                    if ((*pszFeature == kstrPSFEMF[0]) &&
                        (strcmp(pszFeature, kstrPSFEMF) == EQUAL_STRING))
                    {
                        ASSERT(!bPrinterSticky);

                        VUpdatePSF_EMFFeatures(pci, METASPOOL_ITEM);
                    }
                    else if ((*pszFeature == kstrPSFPageOrder[0]) &&
                            (strcmp(pszFeature, kstrPSFPageOrder) == EQUAL_STRING))
                    {
                        ASSERT(!bPrinterSticky);

                        //
                        // first try to sync between reverse print and output order feature
                        //

                        if (!BUpdatePSF_RevPrintAndOutputOrder(pci, REVPRINT_ITEM))
                        {
                            //
                            // if that failed, reverse print could force EMF on
                            //

                            VUpdatePSF_EMFFeatures(pci, REVPRINT_ITEM);
                        }
                    }
                    else if ((*pszFeature == kstrPSFNup[0]) &&
                            (strcmp(pszFeature, kstrPSFNup) == EQUAL_STRING))
                    {
                        ASSERT(!bPrinterSticky);

                        if (NUPOPTION(pdmPrivate) == BOOKLET_UP)
                        {
                            if (!((PUIDATA)pci)->bEMFSpooling || !SUPPORTS_DUPLEX(pci))
                            {
                                //
                                // booklet is not supported if duplex is constrained by an installable
                                // feature such as duplex unit not installed or spooler EMF is disabled
                                // (refer to BPackItemEmfFeatures)
                                //

                                ERR(("Set: BOOKLET_UP ignored for %s\n", pszFeature));
                                NUPOPTION(pdmPrivate) = iOldLayout;
                            }
                            else
                            {
                                //
                                // Booklet will force EMF on
                                //

                                VUpdatePSF_EMFFeatures(pci, NUP_ITEM);

                                //
                                // Booklet will also turn duplex on
                                //

                                VUpdatePSF_BookletAndDuplex(pci, NUP_ITEM);
                            }
                        }
                    }
                }
                else
                {
                    if (GetLastError() == ERROR_INVALID_PARAMETER)
                    {
                        ERR(("Set: %%-feature handler found invalid option %s for %s\n", pszOption, pszFeature));
                    }
                    else
                    {
                        ERR(("Set: %%-feature handler failed on %s-%s: %d\n", pszFeature, pszOption, GetLastError()));
                    }
                }
            }
        }
        else
        {
            PFEATURE   pFeature;
            POPTION    pOption;
            DWORD      dwFeatureIndex, dwOptionIndex;
            POPTSELECT pOptionsArray = pci->pCombinedOptions;

            //
            // PPD *OpenUI feature
            //

            pFeature = PGetNamedFeature(pUIInfo, pszFeature, &dwFeatureIndex);

            //
            // See comments in HEnumConstrainedOptions for following stickiness mode check.
            //

            if (!pFeature ||
                (bPrinterSticky && pFeature->dwFeatureType != FEATURETYPE_PRINTERPROPERTY) ||
                (!bPrinterSticky && pFeature->dwFeatureType == FEATURETYPE_PRINTERPROPERTY))
            {
                VERBOSE(("Set: invalid or mode-mismatched feature %s\n", pszFeature));
                goto next_feature;
            }

            //
            // Skip GID_LEADINGEDGE, GID_USEHWMARGINS. They are not real PPD *OpenUI features.
            // Also skip GID_PAGEREGION, it's only set internally. We don't allow user or plugin
            // to set it.
            //

            if (pFeature->dwFeatureID == GID_PAGEREGION ||
                pFeature->dwFeatureID == GID_LEADINGEDGE ||
                pFeature->dwFeatureID == GID_USEHWMARGINS)
            {
                ERR(("Set: skip feature %s\n", pszFeature));
                goto next_feature;
            }

            pOption = PGetNamedOption(pUIInfo, pFeature, pszOption, &dwOptionIndex);

            if (!pOption)
            {
                ERR(("Set: invalid input option %s for feature %s\n", pszOption, pszFeature));
                goto next_feature;
            }

            //
            // update the option selection
            //

            pOptionsArray[dwFeatureIndex].ubCurOptIndex = (BYTE)dwOptionIndex;

            //
            // We don't support pick-many yet.
            //

            ASSERT(pOptionsArray[dwFeatureIndex].ubNext == NULL_OPTSELECT);

            //
            // some special postprocessing after the option setting is changed
            //

            if (pFeature->dwFeatureID == GID_PAGESIZE)
            {
                PPAGESIZE  pPageSize = (PPAGESIZE)pOption;

                ASSERT(!bPrinterSticky);

                //
                // special handling of PS custom page size
                //
                // refer to VUnpackDocumentPropertiesItems case FORMNAME_ITEM in docprop.c
                //

                if (pPageSize->dwPaperSizeID == DMPAPER_CUSTOMSIZE)
                {
                    pdm->dmFields &= ~(DM_PAPERLENGTH|DM_PAPERWIDTH|DM_FORMNAME);
                    pdm->dmFields |= DM_PAPERSIZE;
                    pdm->dmPaperSize = DMPAPER_CUSTOMSIZE;

                    LOAD_STRING_PAGESIZE_NAME(pci,
                                              pPageSize,
                                              pdm->dmFormName,
                                              CCHFORMNAME);
                }

                bPageSizeSet = TRUE;
            }
            else if (pFeature->dwFeatureID == GID_OUTPUTBIN)
            {
                ASSERT(!bPrinterSticky);

                //
                // output bin change could force EMF on
                //

                VUpdatePSF_EMFFeatures(pci, REVPRINT_ITEM);
            }
            else if (pPpdData->dwOutputOrderIndex != INVALID_FEATURE_INDEX &&
                     dwFeatureIndex == pPpdData->dwOutputOrderIndex)
            {
                ASSERT(!bPrinterSticky);

                //
                // output order change causes reverse print change
                //

                if (!BUpdatePSF_RevPrintAndOutputOrder(pci, UNKNOWN_ITEM))
                {
                    ERR(("OutputOrder change syncs RevPrint failed\n"));
                }
            }
        }

        next_feature:

        pszFeature += cbFeatureKeySize + cbOptionKeySize;
    }

    iMode = bPrinterSticky ? MODE_PRINTER_STICKY : MODE_DOCANDPRINTER_STICKY;

    if (dwFlags & SETOPTIONS_FLAG_KEEP_CONFLICT)
    {
        iMode |= DONT_RESOLVE_CONFLICT;
    }

    //
    // If we're inside DrvDocumentPropertySheets,
    // we'll call the parser to resolve conflicts between
    // all printer features. Since all printer-sticky
    // features have higher priority than all doc-sticky
    // features, only doc-sticky option selections should
    // be affected.
    //

    bNoConflict = ResolveUIConflicts(pci->pRawData,
                                     pci->pCombinedOptions,
                                     MAX_COMBINED_OPTIONS,
                                     iMode);

    if (pdwResult)
    {
        if (dwFlags & SETOPTIONS_FLAG_RESOLVE_CONFLICT)
        {
            *pdwResult = bNoConflict ? SETOPTIONS_RESULT_NO_CONFLICT :
                                       SETOPTIONS_RESULT_CONFLICT_RESOLVED;
        }
        else
        {
            *pdwResult = bNoConflict ? SETOPTIONS_RESULT_NO_CONFLICT :
                                       SETOPTIONS_RESULT_CONFLICT_REMAINED;
        }
    }

    if (!bPrinterSticky)
    {
        //
        // Lastly we need to transfer options array settings back
        // to devmode so they are in sync.
        //

        VOptionsToDevmodeFields(pci, bPageSizeSet);

        //
        // A few more postprocessing here
        //
        // collate could force EMF on
        //

        VUpdatePSF_EMFFeatures(pci, COPIES_COLLATE_ITEM);

        //
        // simplex could change booklet setting
        //

        VUpdatePSF_BookletAndDuplex(pci, DUPLEX_ITEM);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\uni\fontinst.c ===
/****************************Module*Header******************************\
* Module Name: FONTINST.C
*
* Module Descripton:
*      Unidrv's built in font installer. Generously borrowed from Rasdd's
*      font installer code.
*
* Warnings:
*
* Issues:
*
* Created:  22 October 1997
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#include "precomp.h"

//
// Global constants
//


static const DWORD FontInstallerHelpIDs[]=
{
    IDD_ADD,        IDH_SOFT_FONT_ADD_BTN,
    IDD_DELFONT,    IDH_SOFT_FONT_DELETE_BTN,
    IDD_FONTDIR,    IDH_SOFT_FONT_DIRECTORY,
    IDD_NEWFONTS,   IDH_SOFT_FONT_NEW_LIST,
    IDD_CURFONTS,   IDH_SOFT_FONT_INSTALLED_LIST,
    IDD_OPEN,       IDH_SOFT_FONT_OPEN_BTN,
    TID_FONTDIR,    IDH_SOFT_FONT_DIRECTORY,
    TID_NEWFONTS,   IDH_SOFT_FONT_NEW_LIST,
    TID_CURFONTS,   IDH_SOFT_FONT_INSTALLED_LIST,
    0, 0
};

//
// External functions
//

BOOL bSFontToFIData(FI_DATA *, HANDLE, BYTE *, DWORD);


//
// Structure used to remember state
//

typedef struct tagSFINFO
{
    HANDLE        hModule;              // Module handle of calling program
    HANDLE        hPrinter;             // Printer handle passed by caller
    HANDLE        hHeap;                // Handle to heap that we allocate memory from
    DWORD         dwFlags;              // Miscellaneous flags
    DWORD         cMaxFontNum;          // Maximum ID of of fonts already in the file
    DWORD         cFonts;               // Number of fonts added from font file
    DWORD         cCartridgeFonts;      // Number of cartridge fonts in file
    PFNTDAT       pFNTDATHead;          // Head of linked list of FNTDATs
    PFNTDAT       pFNTDATTail;          // The last of them
} SFINFO, *PSFINFO;


//
// Internal functions
//

void vFontInit(HWND, PSFINFO);
void vAddFont(HWND, PSFINFO);
void vDelFont(HWND, PSFINFO);
void vDelSel(HWND, int);
void vFontClean(PSFINFO);
BOOL bNewFontDir(HWND, PSFINFO);
BOOL bIsFileFont(PSFINFO, FI_DATA *, PWSTR);
BOOL bFontUpdate(HWND, PSFINFO);
BOOL InMultiSzSet(PWSTR, PWSTR);

/******************************************************************************
 *
 *                          FontInstProc
 *
 *  Function:
 *       Entry point for font installer dialog code.
 *
 *  Arguments:
 *       hWnd           - Handle to window
 *       usMsg          - Message code
 *       wParam         - wParam
 *       lParam         - lParam
 *
 *  Returns:
 *       TRUE on success, FALSE otherwise
 *
 ******************************************************************************/

INT_PTR CALLBACK
FontInstProc(
    HWND    hWnd,                   // The window of interest
    UINT    usMsg,                  // Message code
    WPARAM  wParam,                 // Depends on above, but message subcode
    LPARAM  lParam                  // Miscellaneous usage
    )
{
    POEMFONTINSTPARAM pfip;
    PSFINFO           pSFInfo;

    switch( usMsg )
    {

    case WM_INITDIALOG:

        //
        // Get the passed in parameter and set SFINFO as the window data
        //

        pfip =  (POEMFONTINSTPARAM)lParam;
        if (!(pSFInfo = HEAPALLOC(pfip->hHeap, sizeof(SFINFO))))
            return FALSE;

        memset(pSFInfo, 0, sizeof(SFINFO));
        pSFInfo->hModule = pfip->hModule;
        pSFInfo->hPrinter = pfip->hPrinter;
        pSFInfo->hHeap = pfip->hHeap;
        pSFInfo->dwFlags = pfip->dwFlags;

        SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pSFInfo);

        //
        // Get list of installed fonts and show them
        //

        vFontInit(hWnd, pSFInfo);
        return TRUE;

    case WM_COMMAND:

        pSFInfo = (PSFINFO)GetWindowLongPtr(hWnd, GWLP_USERDATA);

        switch (LOWORD(wParam))
        {

        case IDD_OPEN:                  // User selects Open button
            return bNewFontDir(hWnd, pSFInfo);

        case IDD_NEWFONTS:              // New font list
            if( HIWORD( wParam ) != CBN_SELCHANGE )
                return FALSE;
            break;

        case IDD_CURFONTS:              // Existing font activity
            if (HIWORD (wParam) != CBN_SELCHANGE)
                return FALSE;
            break;

        case IDD_DELFONT:               // Delete the selected fonts
            vDelFont(hWnd, pSFInfo);

            return TRUE;

        case IDD_ADD:                   // Add the selected fonts
            vAddFont(hWnd, pSFInfo);
            return TRUE;

        case IDOK:

            //
            // Save the updated information
            //

            if (pSFInfo->dwFlags & FG_CANCHANGE)
                bFontUpdate(hWnd, pSFInfo);

            //
            // Fall thru
            //

        case IDCANCEL:
            EndDialog(hWnd, LOWORD(wParam) == IDOK ? TRUE : FALSE);
            return TRUE;

        default:
            return FALSE;
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
    {
       PDRIVER_INFO_3  pDriverInfo3;
       pSFInfo = (PSFINFO)GetWindowLongPtr(hWnd, GWLP_USERDATA);

        if (!pSFInfo ||
            !(pDriverInfo3 = MyGetPrinterDriver(pSFInfo->hPrinter, NULL, 3)))
        {
            return FALSE;
        }

        if (usMsg == WM_HELP)
        {
            WinHelp(((LPHELPINFO) lParam)->hItemHandle,
                    pDriverInfo3->pHelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)FontInstallerHelpIDs);
        }
        else
        {
            WinHelp((HWND) wParam,
                    pDriverInfo3->pHelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)FontInstallerHelpIDs);
        }
    }
        break;

    case WM_DESTROY:

        pSFInfo = (PSFINFO)GetWindowLongPtr(hWnd, GWLP_USERDATA);

        vFontClean(pSFInfo);                 // Free what we consumed

        //
        // Free the SFINFO structure
        //

        HeapFree(pSFInfo->hHeap, 0, pSFInfo);

        return TRUE;

    default:
        return FALSE;                       // didn't process the message
    }

    return FALSE;
}


/******************************************************************************
 *
 *                          BInstallSoftFont
 *
 *  Function:
 *       This function installs a softfont for the given printer
 *
 *  Arguments:
 *       hPrinter       - Handle of printer to install fonts for
 *       hHeap          - Handle of heap to use to allocate memory
 *       pInBuf         - Pointer to PCL data buffer
 *       dwSize         - Size of buffer
 *
 *  Returns:
 *       TRUE on success, FALSE otherwise
 *
 ******************************************************************************/

BOOL APIENTRY
BInstallSoftFont(
    HANDLE      hPrinter,
    HANDLE      hHeap,
    PBYTE       pInBuf,
    DWORD       dwSize
    )
{
    FNTDAT   FntDat;
    HANDLE   hOldFile = NULL;
    HANDLE   hFontFile = NULL;
    DWORD    cFonts = 0, i;
    BOOL     bRc = FALSE;

    //
    // Parse the given PCL font
    //

    if (!bSFontToFIData(&FntDat.fid, hHeap, pInBuf, dwSize))
        return FALSE;

    FntDat.pVarData = pInBuf;
    FntDat.dwSize = dwSize;

    //
    // Open exisiting font file
    //

    if (hOldFile = FIOpenFontFile(hPrinter, hHeap))
    {
        cFonts = FIGetNumFonts(hOldFile);
    }

    //
    // Create a new font file
    //

    hFontFile = FICreateFontFile(hPrinter, hHeap, cFonts+1);
    if (!hFontFile)
    {
        WARNING(("Error creating a new font file\n"));
        goto EndInstallSoftFont;
    }

    //
    // Seek past header and font directory in new file
    //

    FIAlignedSeek(hFontFile, sizeof(UFF_FILEHEADER) + (cFonts + 1) * sizeof(UFF_FONTDIRECTORY));

    for (i=0; i<cFonts; i++)
    {
        if (!FICopyFontRecord(hFontFile, hOldFile, i, i))
        {
            WARNING(("Error copying font record %d\n", i));
            goto EndInstallSoftFont;
        }
    }

    //
    // Add new font record
    //

    if (!FIAddFontRecord(hFontFile, cFonts, &FntDat))
    {
        WARNING(("Error adding new font record\n"));
        goto EndInstallSoftFont;
    }

    //
    // Write out the font header and directory
    //

    if (!FIWriteFileHeader(hFontFile) ||
        !FIWriteFontDirectory(hFontFile))
    {
        WARNING(("Error writing font file header/directory of font file\n"))
        goto EndInstallSoftFont;
    }

    bRc = TRUE;

EndInstallSoftFont:

    (VOID)FIUpdateFontFile(hOldFile, hFontFile, bRc);

    return bRc;
}


/******************************************************************************
 *
 *                          BUpdateExternalFonts
 *
 *  Function:
 *       This function is called by the driver UI to update the font installer
 *       file if one or more cartridges are added or removed by the user.
 *
 *  Arguments:
 *       hPrinter        - Handle of printer
 *       hHeap           - Handle of heap to use to allocate memory
 *       pwstrCartridges - Pointer to MULTI_SZ string of cartridges currently
 *                         installed on the printer
 *
 *  Returns:
 *       TRUE on success, FALSE otherwise
 *
 ******************************************************************************/

BOOL APIENTRY
BUpdateExternalFonts(
    HANDLE      hPrinter,
    HANDLE      hHeap,
    PWSTR       pwstrCartridges
    )
{
    HANDLE hOldFile  = NULL;
    HANDLE hFontFile = NULL;
    HANDLE hCartFile = NULL;
    DWORD  cFonts = 0;
    DWORD  cCartFonts = 0;
    DWORD  cNewFonts = 0;
    DWORD  i, j;
    PWSTR  pwstrName;
    BOOL   bRc = FALSE;

    //
    // Open exisiting font file
    //

    if ((hOldFile = FIOpenFontFile(hPrinter, hHeap)) == NULL)
    {
        WARNING(("Error opening font file\n"));
        return FALSE;
    }

    cFonts = FIGetNumFonts(hOldFile);

    //
    // Find out number of non cartridge fonts
    //

    for (i=0; i<cFonts; i++)
    {
        if (FIGetFontCartridgeName(hOldFile, i) == NULL)
            cNewFonts++;
    }

    //
    // Open font cartridge file
    //

    if ((hCartFile = FIOpenCartridgeFile(hPrinter, hHeap)) == NULL &&
        pwstrCartridges != NULL)
    {
        WARNING(("Error opening cartridge file\n"));
        goto EndUpdateExternalFonts;
    }

    if (hCartFile)
    {
        //
        // Find number of fonts belonging to these cartridges
        //

        cCartFonts = FIGetNumFonts(hCartFile);

        for (i=0; i<cCartFonts; i++)
        {
            pwstrName = FIGetFontCartridgeName(hCartFile, i);
            ASSERT(pwstrName != NULL);

            if (InMultiSzSet(pwstrCartridges, pwstrName))
                cNewFonts++;
        }
    }

    //
    // Create a new font file
    //

    hFontFile = FICreateFontFile(hPrinter, hHeap, cNewFonts);
    if (!hFontFile)
    {
        WARNING(("Error creating a new font file\n"));
        goto EndUpdateExternalFonts;
    }

    //
    // Seek past header and font directory in new file
    //

    FIAlignedSeek(hFontFile, sizeof(UFF_FILEHEADER) + cNewFonts * sizeof(UFF_FONTDIRECTORY));

    //
    // Copy over all fonts from old font file that don't belong to any
    // cartridges
    //

    for (i=0, j=0; i<cFonts; i++)
    {
        if (FIGetFontCartridgeName(hOldFile, i) != NULL)
            continue;

        if (!FICopyFontRecord(hFontFile, hOldFile, j, i))
        {
            WARNING(("Error copying font record %d\n", i));
            goto EndUpdateExternalFonts;
        }
        j++;
    }


    //
    // NOTE: Do not change j - we continue to use it below
    //

    //
    // Copy over cartridge fonts that are curently selected
    //

    for (i=0; i<cCartFonts; i++)
    {
        pwstrName = FIGetFontCartridgeName(hCartFile, i);

        if (!InMultiSzSet(pwstrCartridges, pwstrName))
            continue;

        if (!FICopyFontRecord(hFontFile, hCartFile, j, i))
        {
            WARNING(("Error copying font record %d\n", i));
            goto EndUpdateExternalFonts;
        }
        j++;
    }

    //
    // Write out the font header and directory
    //

    if (!FIWriteFileHeader(hFontFile) ||
        !FIWriteFontDirectory(hFontFile))
    {
        WARNING(("Error writing font file header/directory of font file\n"))
        goto EndUpdateExternalFonts;
    }

    bRc = TRUE;

EndUpdateExternalFonts:

    (VOID)FIUpdateFontFile(hOldFile, hFontFile, bRc);

    (VOID)FICloseFontFile(hCartFile);

    return bRc;
}


/******************************************************************************
 *
 *                          BGetFontCartridgeFile
 *
 *  Function:
 *       This function is called by the driver UI to copy the font cartridge
 *       file from the server to the client
 *
 *  Arguments:
 *       hPrinter        - Handle of printer
 *       hHeap           - Handle of heap to use to allocate memory
 *
 *  Returns:
 *       TRUE on success, FALSE otherwise
 *
 ******************************************************************************/

BOOL
BGetFontCartridgeFile(
    HANDLE hPrinter,
    HANDLE hHeap
    )
{
    CACHEDFILE      CachedFile;
    PPRINTER_INFO_2 ppi2 = NULL;
    DWORD           dwSize = 0;
    BOOL            bRc = FALSE;

    GetPrinterW(hPrinter, 2, NULL, 0, &dwSize);

    if ((dwSize == 0) ||
        !(ppi2 = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize)) ||
        !(GetPrinterW(hPrinter, 2, (PBYTE)ppi2, dwSize, &dwSize)))
    {
        goto EndGetFCF;
    }

    if (!(ppi2->Attributes & PRINTER_ATTRIBUTE_LOCAL))
    {

        if (! _BPrepareToCopyCachedFile(hPrinter, &CachedFile, REGVAL_CARTRIDGEFILENAME) ||
            ! _BCopyCachedFile(NULL, &CachedFile))
            bRc = FALSE;
        else
            bRc = TRUE;

        _VDisposeCachedFileInfo(&CachedFile);

        goto EndGetFCF;
    }

    bRc = TRUE;

EndGetFCF:

    if (ppi2)
        HeapFree(hHeap, 0, ppi2);

    return bRc;
}

/******************************************************************************
 *                      Internal helper functions
 ******************************************************************************/

/******************************************************************************
 *
 *                             vFontInit
 *
 *  Function:
 *      Called to initialise the dialog before it is displayed to the
 *      user.  Requires making decisions about buttons based on any
 *      existing fonts.
 *
 *  Arguments:
 *       hWnd           - Handle to window
 *       pSFInfo        - Pointer to structure that holds state information
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/

void
vFontInit(
    HWND     hWnd,
    PSFINFO  pSFInfo
    )
{
    HANDLE    hFontFile;        // Handle to font file
    INT       iNum = 0;         // Number of entries
    INT       i;                // Loop parameter
    DWORD     cFonts = 0;       // Number of fonts

    //
    // If there is a font file associated with this printer, open it and
    // read the fonts
    //

    if (hFontFile = FIOpenFontFile(pSFInfo->hPrinter, pSFInfo->hHeap))
    {
        iNum = FIGetNumFonts(hFontFile);
    }

    for (i=0; i<iNum; i++)
    {
        LONG_PTR  iFont;
        PWSTR    pwstr;            // Font display name

        //
        // We do not display fonts that belong to font cartridges
        //

        pwstr = FIGetFontCartridgeName(hFontFile, i);
        if (pwstr)
        {
            pSFInfo->cCartridgeFonts++;
            continue;
        }

        pwstr = FIGetFontName(hFontFile, i);

        if (!pwstr)
            continue;           // Should not happen!

        //
        // Add font name to list of installed fonts
        //

        iFont = SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_ADDSTRING, 0, (LPARAM)pwstr);

        //
        // Set the font number
        //

        SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_SETITEMDATA, iFont, (LPARAM)i);

        cFonts++;               // Increment number of fonts
    }

    pSFInfo->cMaxFontNum = (DWORD)i;  // For separating new/old

    if (cFonts > 0)
    {
        //
        //  There are existing fonts, so we can enable the DELETE button
        //

        pSFInfo->cFonts = cFonts;         // Number of fonts added

        EnableWindow(GetDlgItem(hWnd, IDD_DELFONT), TRUE);
    }

    if (hFontFile)
    {
        FICloseFontFile(hFontFile);
    }

    if (pSFInfo->dwFlags & FG_CANCHANGE)
    {
        //
        // User has access to change stuff,  so place a default directory
        //

        SetDlgItemText(hWnd, IDD_FONTDIR, L"A:\\");
    }
    else
    {
        //
        // No permission to change things, so disable most of the dialog
        //

        EnableWindow( GetDlgItem( hWnd, IDD_FONTDIR ), FALSE );
        EnableWindow( GetDlgItem( hWnd, TID_FONTDIR ), FALSE );
        EnableWindow( GetDlgItem( hWnd, IDD_OPEN ), FALSE );
        EnableWindow( GetDlgItem( hWnd, IDD_ADD ), FALSE );
        EnableWindow( GetDlgItem( hWnd, IDD_DELFONT ), FALSE );
        EnableWindow( GetDlgItem( hWnd, IDD_NEWFONTS ), FALSE );
        EnableWindow( GetDlgItem( hWnd, TID_NEWFONTS ), FALSE );
    }

    return;
}


/******************************************************************************
 *
 *                             bNewFontDir
 *
 *  Function:
 *      Processes a new font directory. This means opening the
 *      directory and passing the file names to the screening function.
 *
 *  Arguments:
 *       hWnd           - Handle to window
 *       pSFInfo        - Pointer to structure that holds state information
 *
 *  Returns:
 *       TRUE on success, FALSE otherwise
 *
 ******************************************************************************/

BOOL
bNewFontDir(
    HWND    hWnd,
    PSFINFO pSFInfo
    )
{
    WIN32_FIND_DATA  ffd;               // Data about the file we find
    UINT             iErrMode;          // For manipulating error msgs
    INT              cOKFiles;          // Count the number of font files found
    HANDLE           hDir;              // FindFirstFile ... scanning
    HCURSOR          hCursor;           // Switch to wait symbol while reading
    INT              cDN;               // Length of directory name
                                        // (count of chars, excluding terminating null char)
    WCHAR            wchDirNm[MAX_PATH];// Font directory + file name

    //
    // GetDlgItemText's 4th parameter is the max number of characters, not bytes.
    //
    cDN = GetDlgItemTextW(hWnd, IDD_FONTDIR, wchDirNm, sizeof(wchDirNm) / sizeof(WCHAR));

    //
    // Check to see if the name will be too long: the 5 below is the
    // number of additional characters to add to the directory name:
    // namely, L"\\*.*".
    //
    if (cDN >= (CCHOF(wchDirNm) - 5))
    {
        IDisplayErrorMessageBox(hWnd,
                                MB_OK | MB_ICONERROR,
                                IDS_FONTINST_FONTINSTALLER,
                                IDS_FONTINST_DIRECTORYTOOLONG);
        return FALSE;
    }

    if (cDN > 0)
    {
        if (wchDirNm[cDN - 1] != (WCHAR)'\\' )
        {
            StringCchCatW(wchDirNm, CCHOF(wchDirNm), L"\\");
            cDN++;                      // One more now!
        }

        StringCchCatW(wchDirNm, CCHOF(wchDirNm), L"*.*");

        //
        // Save error mode, and enable file open error box.
        //
        iErrMode = SetErrorMode(0);
        SetErrorMode(iErrMode & ~SEM_NOOPENFILEERRORBOX);

        hDir = FindFirstFile(wchDirNm, &ffd);

        SetErrorMode(iErrMode);                // Restore old mode

        cOKFiles = 0;

        if (hDir == INVALID_HANDLE_VALUE)
        {
            //
            // Put up a dialog box to tell the user "no such directory".
            //
            if (GetLastError() == ERROR_PATH_NOT_FOUND)
            {
               IDisplayErrorMessageBox(hWnd,
                                       MB_OK | MB_ICONERROR,
                                       IDS_FONTINST_FONTINSTALLER,
                                       IDS_FONTINST_INVALIDDIR);
            }

            return  FALSE;
        }

        //
        // Switch to the hourglass cursor while reading,  since the data
        // is probably coming from a SLOW floppy.  Also stop redrawing,
        // since the list box looks ugly during this time.
        //
        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        SendMessage(hWnd, WM_SETREDRAW, FALSE, 0L);

        do
        {
            //
            // Generate a file name which is passed to a function to determine
            // whether this file is understood by us. This function returns
            // FALSE if it does not understand the file;  otherwise it returns
            // TRUE, and also a string to display.  We display the string,
            // and remember the file name for future use.
            //
            LONG_PTR  iFont;            // List Box index
            FI_DATA  FD;                // Filled in by bIsFileFont
            PFNTDAT  pFNTDAT;           // For remembering it all

            StringCchCopyW(&wchDirNm[cDN],
                           CCHOF(wchDirNm) - cDN,
                           ffd.cFileName);

            if (bIsFileFont(pSFInfo, &FD, wchDirNm))
            {
                //
                // Part of the data returned is a descriptive string
                // for the font.  We need to display this to the user.
                // We also allocate a structure we use to keep track of
                // all the data we have.  This includes the file name
                // that we have!
                //

                pFNTDAT = (PFNTDAT)HEAPALLOC(pSFInfo->hHeap, sizeof(FNTDAT));
                if (pFNTDAT == NULL)
                {
                    break;
                }

                if (pSFInfo->pFNTDATHead == NULL)
                {
                    //
                    // Starting a chain,  so remember the first.
                    // AND also enable the Add button in the dialog,
                    // now that we have something to add.
                    //

                    pSFInfo->pFNTDATHead = pFNTDAT;
                    EnableWindow(GetDlgItem(hWnd, IDD_ADD), TRUE);
                }

                if (pSFInfo->pFNTDATTail)
                    pSFInfo->pFNTDATTail->pNext = pFNTDAT;

                pSFInfo->pFNTDATTail = pFNTDAT;

                pFNTDAT->pNext = 0;
                pFNTDAT->pVarData = NULL;
                pFNTDAT->dwSize = 0;
                pFNTDAT->fid = FD;
                wcsncpy(pFNTDAT->wchFileName, wchDirNm, cDN);
                StringCchCatW(pFNTDAT->wchFileName,
                              CCHOF(pFNTDAT->wchFileName),
                              ffd.cFileName);

                //
                // Display this message, and tag it with the address
                // of the data area we just allocated.
                //

                iFont = SendDlgItemMessage(hWnd,
                                           IDD_NEWFONTS,
                                           LB_ADDSTRING,
                                           0,
                                           (LPARAM)FD.dsIdentStr.pvData);

                SendDlgItemMessage(hWnd,
                                   IDD_NEWFONTS,
                                   LB_SETITEMDATA,
                                   iFont,
                                   (LPARAM)pFNTDAT);

                ++cOKFiles;         // One more to the list
            }

        } while (FindNextFile(hDir, &ffd));

        //
        // Now can redraw the box & return to the previous cursor
        //

        SendMessage(hWnd, WM_SETREDRAW, TRUE, 0L);
        InvalidateRect(hWnd, NULL, TRUE);

        SetCursor(hCursor);

        //
        //   Finished with the directory now, so close it up
        //

        FindClose(hDir);

        if (cOKFiles == 0)
        {
            //
            // Didn't find any files, so tell the user
            //
            IDisplayErrorMessageBox(hWnd,
                                    MB_OK | MB_ICONERROR,
                                    IDS_FONTINST_FONTINSTALLER,
                                    IDS_FONTINST_NOFONTFOUND);
        }
    }
    else
    {
        //
        // Empty font directory name!
        //
        IDisplayErrorMessageBox(hWnd,
                                MB_OK | MB_ICONERROR,
                                IDS_FONTINST_FONTINSTALLER,
                                IDS_FONTINST_NODIRNAME);
    }

    return TRUE;
}


/******************************************************************************
 *
 *                             vAddFont
 *
 *  Function:
 *      Called to move the new selected fonts to the font list
 *
 *  Arguments:
 *       hWnd           - Handle to window
 *       pSFInfo        - Pointer to structure that holds state information
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/

void
vAddFont(
    HWND    hWnd,
    PSFINFO pSFInfo
    )
{
    LONG_PTR  cSel;                 // Number of entries selected
    LONG_PTR  *piSel;                // List of selected fonts
    INT      iI;                   // Loop index

    //
    // Find the selected items in the new font box and move them to the
    // Installed box.  Also set up the linked list of stuff to pass
    // to the common font installer code should the user decide to
    // update the list.
    //

    cSel = SendDlgItemMessage(hWnd, IDD_NEWFONTS, LB_GETSELCOUNT, 0, 0);

    piSel = (LONG_PTR *)HEAPALLOC(pSFInfo->hHeap, (DWORD)(cSel * sizeof(INT)));

    if (piSel == NULL )
    {
        IDisplayErrorMessageBox(hWnd,
                                MB_OK | MB_ICONERROR,
                                IDS_FONTINST_FONTINSTALLER,
                                IDS_FONTINST_OUTOFMEMORY);

        return;
    }

    //
    // Disable updates to reduce screen flicker
    //

    SendMessage(hWnd, WM_SETREDRAW, FALSE, 0L);

    SendDlgItemMessage(hWnd, IDD_NEWFONTS, LB_GETSELITEMS, cSel, (LPARAM)piSel);

    for (iI=0; iI<cSel; ++iI)
    {
        LONG_PTR iFont;         // Index in list box
        FNTDAT  *pFontData;     // Significant font info

        pFontData = (FNTDAT *)SendDlgItemMessage(hWnd,
                                                 IDD_NEWFONTS,
                                                 LB_GETITEMDATA,
                                                 piSel[iI],
                                                 0L);

        if ((LONG_PTR)pFontData == LB_ERR )
            continue;           // SHOULD NOT HAPPEN


        iFont = SendDlgItemMessage(hWnd,
                                   IDD_CURFONTS,
                                   LB_ADDSTRING,
                                   0,
                                   (LPARAM)pFontData->fid.dsIdentStr.pvData);

        SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_SETITEMDATA, iFont, (LPARAM)pFontData);
    }

    if (iI > 0)
        EnableWindow(GetDlgItem(hWnd, IDD_DELFONT), TRUE);

    //
    // Can now delete the selected items: we no longer need them
    //

    vDelSel(hWnd, IDD_NEWFONTS);


    //
    // Re enable updates
    //

    SendMessage(hWnd, WM_SETREDRAW, TRUE, 0L);
    InvalidateRect(hWnd, NULL, TRUE);

    HeapFree(pSFInfo->hHeap, 0, (LPSTR)piSel);

    return;
}


/******************************************************************************
 *
 *                             vDelFont
 *
 *  Function:
 *      Called when the Delete button is clicked.  We discover which
 *      items in the Installed fonts list box are selected, and mark these
 *      for deletion. We do NOT delete them, simply remove them from
 *      display and mark for deletion later.
 *
 *  Arguments:
 *       hWnd           - Handle to window
 *       pSFInfo        - Pointer to structure that holds state information
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/

void
vDelFont(
    HWND    hWnd,
    PSFINFO pSFInfo
    )
{
    INT     iI;                 // Loop index
    LONG_PTR cSel;               // Number of selected items
    LONG_PTR *piSel;              // From heap, contains selected items list

    //
    //  Obtain the list of selected items in the Installed list box.
    //  Then place any existing fonts into the to delete list,  and
    //  move any new fonts back into the New fonts list.
    //

    cSel = SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_GETSELCOUNT, 0, 0);

    piSel = (LONG_PTR *)HEAPALLOC(pSFInfo->hHeap, (DWORD)(cSel * sizeof(INT)));

    if (piSel == NULL)
    {
        IDisplayErrorMessageBox(hWnd,
                                MB_OK | MB_ICONERROR,
                                IDS_FONTINST_FONTINSTALLER,
                                IDS_FONTINST_OUTOFMEMORY);
        return;
    }

    //
    // Disable updates to reduce screen flicker
    //

    SendMessage(hWnd, WM_SETREDRAW, FALSE, 0L);

    SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_GETSELITEMS, cSel, (LPARAM)piSel);

    for (iI=0; iI<cSel; ++iI)
    {
        LONG_PTR iVal;

        iVal = SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_GETITEMDATA, piSel[iI], 0);

        if (iVal == LB_ERR)
            continue;                   // SHOULD NOT HAPPEN

        if (iVal >= (LONG_PTR)pSFInfo->cMaxFontNum)
        {
            //
            //  We are deleting a font that we just installed, so add it back
            // into the new fonts, so that it remains visible.
            //

            LONG_PTR iFont;               // New list box index
            WCHAR   awch[256];           // ???

            if (SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_GETTEXT,
                                   piSel[iI], (LPARAM)awch) != LB_ERR)
            {
                //
                // Have the text and value, so back into the new list
                //

                iFont = SendDlgItemMessage(hWnd, IDD_NEWFONTS, LB_ADDSTRING, 0, (LPARAM)awch);

                SendDlgItemMessage(hWnd, IDD_NEWFONTS, LB_SETITEMDATA, iFont, (LPARAM)iVal);
            }
        }
    }

    //
    // Now delete them from the list
    //

    vDelSel(hWnd, IDD_CURFONTS);


    //
    // Disable the delete button if there are no fonts.
    //

    if (SendDlgItemMessage( hWnd, IDD_CURFONTS, LB_GETCOUNT, 0, 0L) == 0)
        EnableWindow(GetDlgItem(hWnd, IDD_DELFONT), FALSE);

    //
    /// Re-enable updates
    //

    SendMessage(hWnd, WM_SETREDRAW, TRUE, 0L);
    InvalidateRect(hWnd, NULL, TRUE);


    HeapFree(pSFInfo->hHeap, 0, (LPSTR)piSel);

    return;
}


/******************************************************************************
 *
 *                             vDelSel
 *
 *  Function:
 *      Delete all selected items in the specified list box.
 *
 *  Arguments:
 *       hWnd           - Handle to window
 *       iBox           - Identifies the list box
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/

void
vDelSel(
    HWND    hWnd,
    INT     iBox
    )
{
    INT   iSel;

    //
    //  Find how many items are selected, then retrieve their index
    //  one at a time until they are all deleted. This is needed because
    //  otherwise we delete the wrong ones! This is because the data is
    //  presented to us as an array of indices, and these are wrong when
    //  we start deleting them.
    //

    while (SendDlgItemMessage(hWnd, iBox, LB_GETSELITEMS, 1, (LPARAM)&iSel) > 0)
        SendDlgItemMessage(hWnd, iBox, LB_DELETESTRING, iSel, 0L);

    return;
}

/******************************************************************************
 *
 *                             vFontClean
 *
 *  Function:
 *      Clean up all the dangling bits & pieces we have left around.
 *
 *  Arguments:
 *       pSFInfo        - Pointer to structure that holds state information
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/

void
vFontClean(
    PSFINFO pSFInfo
    )
{
    //
    // Look at the storage addresses we allocate.  If non zero,
    // free them up and set to NULL to prevent a second freeing.
    //

    if (pSFInfo->pFNTDATHead)
    {
        //
        //  The details of each new font we found. These form a linked
        //  list, so we need to traverse the chain and free every entry.
        //

        FNTDAT *pFD0, *pFD1;

        for (pFD0 = pSFInfo->pFNTDATHead; pFD0; pFD0 = pFD1)
        {
            pFD1 = pFD0->pNext;                 // Next one, perhaps

            HeapFree(pSFInfo->hHeap, 0, (LPSTR)pFD0);
        }

        pSFInfo->pFNTDATHead = NULL;
        pSFInfo->pFNTDATTail = NULL;
    }

    return;
}


/******************************************************************************
 *
 *                             bIsFileFont
 *
 *  Function:
 *      Called with a file name and returns TRUE if this file is a font
 *      format we understand. Also returns a FONT_DATA structure.
 *
 *  Arguments:
 *       pSFInfo        - Pointer to structure that holds state information
 *       pFIDat         - Information about the font to fill if successful
 *       pwstr          - Name of file to check
 *
 *  Returns:
 *       TRUE on success, FALSE otherwise
 *
 ******************************************************************************/

BOOL
bIsFileFont(
    PSFINFO    pSFInfo,
    FI_DATA   *pFIDat,
    PWSTR      pwstr
    )
{
    HANDLE   hFile;
    BYTE    *pbFile;
    DWORD    dwSize;
    BOOL     bRet;

    hFile = CreateFile(pwstr,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL | SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    if (!MapFileIntoMemory(pwstr, &pbFile, NULL))
    {
        CloseHandle(hFile);
        return FALSE;
    }

    //
    // Want to find out how big the file is,  so now seek to the
    // end,  and see what address comes back!  There appears to be
    // no other way to do this.
    //

    dwSize = SetFilePointer(hFile, 0L, NULL, FILE_END);

    bRet = bSFontToFIData(pFIDat, pSFInfo->hHeap, pbFile, dwSize);

    UnmapFileFromMemory((HFILEMAP)pbFile);
    CloseHandle(hFile);

    return bRet;
}


/******************************************************************************
 *
 *                             bFontUpdate
 *
 *  Function:
 *      Update the font installer common file.  Called when the user
 *      has clicked on the OK button.
 *
 *  Arguments:
 *       hWnd           - Handle to window
 *       pSFInfo        - Pointer to structure that holds state information
 *
 *  Returns:
 *       TRUE on success, FALSE otherwise
 *
 ******************************************************************************/

BOOL
bFontUpdate(
    HWND    hWnd,
    PSFINFO pSFInfo
    )
{
    HANDLE    hOldFile = NULL;     // Handle to old font file
    HANDLE    hFontFile = NULL;    // Handle to new font file
    DWORD     cFonts;              // Final number of fonts selected
    DWORD     dwIndex;             // Index into current font file
    LRESULT   lrOldIndex;          // Index into old font file
    DWORD     i;                   // Loop index
    BOOL      bRc = FALSE;         // Return code

    //
    // Initialize some variables
    //

    hOldFile = hFontFile = NULL;

    //
    // Get number of fonts that have finally been added
    //

    cFonts = (DWORD)SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_GETCOUNT, 0, 0);

    //
    // If no fonts have been added or deleted, we can skip doing anything.
    // Check for this case
    //

    if (cFonts == pSFInfo->cFonts)
    {
        BOOL   bNoChange = TRUE;

        for (i=0; i<cFonts; i++)
        {
            lrOldIndex = SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_GETITEMDATA, i, 0);
            if (lrOldIndex >= (LONG)(pSFInfo->cMaxFontNum))
            {
                bNoChange = FALSE;
                break;
            }
        }

        if (bNoChange)
        {
            return TRUE;
        }
    }

    //
    // Open existing font file
    //

    hOldFile = FIOpenFontFile(pSFInfo->hPrinter, pSFInfo->hHeap);
    if (!hOldFile && pSFInfo->cMaxFontNum > 0)
    {
        WARNING(("Unable to open existing font file\n"));
        goto EndFontUpdate;
    }

    //
    // Create a new font file
    //

    hFontFile = FICreateFontFile(pSFInfo->hPrinter, pSFInfo->hHeap, cFonts+pSFInfo->cCartridgeFonts);
    if (!hFontFile)
    {
        WARNING(("Error creating new font file\n"));
        goto EndFontUpdate;
    }

    //
    // Seek past header and font directory in new file
    //

    FIAlignedSeek(hFontFile, sizeof(UFF_FILEHEADER) + (cFonts+pSFInfo->cCartridgeFonts) * sizeof(UFF_FONTDIRECTORY));

    for (dwIndex=0; dwIndex<cFonts; dwIndex++)
    {
        lrOldIndex = SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_GETITEMDATA, dwIndex, 0);

        if (lrOldIndex < (LONG)(pSFInfo->cMaxFontNum))
        {
            //
            // This is an old font from existing font file
            //

            if (!FICopyFontRecord(hFontFile, hOldFile, dwIndex, (DWORD)lrOldIndex))
            {
                WARNING(("Error copying font record\n"));
                goto EndFontUpdate;
            }
        }
        else
        {
            //
            // This is a font being newly added
            //

            if (!FIAddFontRecord(hFontFile, dwIndex, (PFNTDAT)lrOldIndex))
            {
                WARNING(("Error creating new font record\n"));
                goto EndFontUpdate;
            }
        }
    }

    //
    // NOTE: Do not change dwIndex - we continue to use it below
    //

    if (pSFInfo->cCartridgeFonts > 0)
    {
        //
        // Copy cartridge fonts to new font file
        //

        cFonts = FIGetNumFonts(hOldFile);
        for (i=0; i<cFonts; i++)
        {
            PWSTR pwstr = FIGetFontCartridgeName(hOldFile, i);
            if (pwstr)
            {
                if (!FICopyFontRecord(hFontFile, hOldFile, dwIndex, i))
                {
                    WARNING(("Error copyinf font record\n"));
                    goto EndFontUpdate;
                }
                dwIndex++;
            }
        }
    }

    //
    // Write out the font header and directory
    //

    if (!FIWriteFileHeader(hFontFile) ||
        !FIWriteFontDirectory(hFontFile))
    {
        WARNING(("Error writing font header/directory of font file\n"))
        goto EndFontUpdate;
    }

    bRc = TRUE;

EndFontUpdate:

    (VOID)FIUpdateFontFile(hOldFile, hFontFile, bRc);

    return bRc;
}

BOOL
InMultiSzSet(
    PWSTR pwstrMultiSz,
    PWSTR pwstr
    )
{
    while (*pwstrMultiSz)
    {
        if (wcscmp(pwstrMultiSz, pwstr) == 0)
        {
            return TRUE;
        }

        pwstrMultiSz += wcslen(pwstrMultiSz) + 1;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\uni\softfont.c ===
/****************************Module*Header******************************\
* Module Name: SOFTFONT.C
*
* Module Descripton:
 *      Functions associated with PCL softfonts.  These are fonts which are
 *      downloaded into the printer.  We read those files and interpre the
 *      information contained therein.  This happens during font installation
 *      time,  so that when in use,  this information is in the format
 *      required by the driver.
*
* Warnings:
*
* Issues:
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#include "precomp.h"


/*
 *   A macro to swap the bytes around:  we then get them in little endian
 * order from the big endian 68000 format.
 */

#define SWAB( x )       ((WORD)(x) = (WORD)((((x) >> 8) & 0xff) | (((x) << 8) & 0xff00)))


#define BBITS   8               /* Bits in a byte */


/*
 *   Define the values returned from the header checking code.  The
 * function is called to see what is next in the file,  and so we
 * can determine that the file is in an order we understand.
 */

#define TYPE_INDEX      0       /* Character index record follows */
#define TYPE_HEADER     1       /* Character header */
#define TYPE_CONT       2       /* Continuation record */
#define TYPE_INVALID    3       /* Unexpected sequence */

/*
 *   The structure and data for matching symbol sets with translation tables.
 */

typedef  struct
{
    WORD    wSymSet;            /* Symbol set encoded in file */
    short   sCTT;               /* Translation table index */
} CTT_MAP;

/*
 *   Note about this table:  we do not include the generic7 ctt,  this simply
 * maps glyphs 128 - 255 to 0x7f. Since we only use the glyphs available
 * in the font,  and these we discover from the file, we have no need of
 * this type since we will map such chars because of the wcLastChar in
 * the IFIMETRICS!
 */

static   const  CTT_MAP  CttMap[] =
{
    { 277,  2 },                /* Roman 8 */
    { 269,  4 },                /* Math 8 */
    { 21,   5 },                /* US ASCII */
    { 14,  19 },                /* ECMA-94 */
    { 369, 20 },                /* Z1A - variety of ECMA-94, ss = 11Q */
};

#define NUM_CTTMAP      (sizeof( CttMap ) / sizeof( CttMap[ 0 ] ))


/*
 *   The bClass field mapping table:  maps from values in bClass parameter
 *  to bits in the dwSelBits field.
 */

static  const  DWORD  dwClassMap[] =
{
    FDH_BITMAP,         /* A bitmap font */
    FDH_COMPRESSED,     /* A compressed bitmap */
    FDH_CONTOUR,        /* A contour font (Intellifont special) */
    FDH_CONTOUR,        /* A compressed contour font: presume as above */
};

#define MAX_CLASS_MAP   (sizeof( dwClassMap ) / sizeof( dwClassMap[ 0 ] ))

/*
 *    Typeface to name index.   Comes from the LaserJet III technical manual.
 */

static const WCHAR  *pwcName[] =
{
    L"Line Printer",
    L"Pica",
    L"Elite",
    L"Courier",
    L"Helv" ,
    L"TmsRmn",
    L"Letter Gothic",
    L"Script",
    L"Prestige",
    L"Caslon",
    L"Orator",
    L"Presentations",
    L"Helv Cond",
    L"Serifa",
    L"Futura",
    L"Palatino",
    L"ITC Souvenir",
    L"Optima",
    L"Garamond",
    L"Cooper Black",
    L"Coronet Bold",
    L"Broadway",
    L"Bauer Bodoni Black Condensed",
    L"Century Schoolbook",
    L"University Roman",
    L"Helvetica Outline",
    L"Futura Condensed",
    L"ITC Korinna",
    L"Naskh",
    L"Cloister Black",
    L"ITC Galliard",
    L"ITC Avant Garde Gothic",
    L"Brush",
    L"Blippo",
    L"Hobo",
    L"Windsor",
    L"Helvetica Compressed",
    L"Helvetica Extra Compressed",
    L"Peignot",
    L"Baskerville",
    L"ITC Garamond Condensed",
    L"Trade Gothic",
    L"Goudy Old Style",
    L"ITC Zapf Chancery",
    L"Clarendon",
    L"ITC Zapf Dingbats",
    L"Cooper",
    L"ITC Bookman",
    L"Stick",
    L"HP-GL Drafting",
    L"HP-GL Spline",
    L"Gill Sans",
    L"Univers",
    L"Bodoni",
    L"Rockwell",
    L"Mellior",
    L"ITC Tiffany",
    L"ITC Clearface",
    L"Amelia",
    L"Park Avenue",
    L"Handel Gothic",
    L"Dom Casual",
    L"ITC Benguiat",
    L"ITC Cheltenham",
    L"Century Expanded",
    L"Franklin Gothic",
    L"Franklin Gothic Expressed",
    L"Frankiln Gothic Extra Condensed",
    L"Plantin",
    L"Trump Mediaeval",
    L"Futura Black",
};

#define NUM_TYPEFACE    (sizeof( pwcName ) / sizeof( pwcName[ 0 ] ))


BOOL   bWrite( HANDLE, void  *, int );

/*
 *    Local function prototypes.
 */


BYTE  *pbReadSFH( BYTE *, SF_HEADER * );
BYTE  *pbReadIndex( BYTE *, int * );
BYTE  *pbReadCHH( BYTE *, CH_HEADER *, BOOL );
int    iNextType( BYTE * );
PWSTR  strcpy2WChar( PWSTR, LPSTR );
DWORD  FICopy(HANDLE, HANDLE);
int   iWriteFDH( HANDLE, FI_DATA * );
BOOL   bWrite( HANDLE, void  *, int );

/*  SoftFont to NT conversion functions */

IFIMETRICS  *SfhToIFI( SF_HEADER *, HANDLE, PWSTR );


#if  PRINT_INFO
/*
 *    Print out the IFIMETRICS results!
 */
typedef VOID (*VPRINT) (char*,...);


VOID
vPrintIFIMETRICS(
    IFIMETRICS *pifi,
    VPRINT vPrint
    );

#endif

/****************************** Function Header ***************************
 * bSFontToFontMap
 *      Read in a PCL softfont file and generate all the fontmap details
 *      The file contains a header with general font information, followed
 *      by an array of entries, one per glyph, each of which contains a
 *      header with per glyph data such as char width.
 *
 * RETURNS:
 *      TRUE/FALSE,  TRUE for success.
 *
 * HISTORY:
 *  09:54 on Wed 19 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      First incarnation.
 *
 ***************************************************************************/

BOOL
bSFontToFIData( pFIDat, hheap, pbFile, dwSize )
FI_DATA   *pFIDat;                 /* FI_DATA with all the important stuff! */
HANDLE     hheap;               /* For storage allocation */
BYTE      *pbFile;              /* Mmemory mapped file with the softfont */
DWORD      dwSize;              /* Number of bytes in the file */
{

    int        iVal;            /* Character code from file */
    int        iI;              /* Loop index */
    int        iType;           /* Record type that we have */

    int        iMaxWidth;       /* Widest glyph we found */
    int        iWidth;          /* For calculating the average width */
    int        cGlyphs;         /* For the above */

    SF_HEADER  sfh;             /* Header information */
    CH_HEADER  chh;             /* Per glyph information */

    BYTE      *pbEnd;

    WCHAR     *pwch;            /* Points to font name to display */

    IFIMETRICS *pIFI;

    WCHAR      awchTemp[ 128 ]; /* For building up the name to show user */



    pbEnd = pbFile + dwSize;                    /* Last byte + 1 */
    ZeroMemory( pFIDat, sizeof( FI_DATA ) );

    if( (pbFile = pbReadSFH( pbFile, &sfh )) == 0 )
        return  FALSE;          /* No go - presume wrong format */

    pFIDat->dsIFIMet.pvData = pIFI = SfhToIFI( &sfh, hheap, L"PCL_SF" );

    if( pIFI == 0 )
        return  FALSE;

    pFIDat->dsIFIMet.cBytes = pIFI->cjThis;

    if( sfh.bSpacing )
    {
        /*
         *   Allocate space for the width table,  if there is to be one.
         * Only proportionally spaced fonts have this luxury!
         */

        iI = (pIFI->chLastChar - pIFI->chFirstChar + 1) * sizeof( short );

        if( !(pFIDat->dsWidthTab.pvData = (short *)HEAPALLOC( hheap, iI )) )
        {
            HeapFree( hheap, 0, (LPSTR)pIFI );

            return  FALSE;
        }
        pFIDat->dsWidthTab.cBytes = iI;

        ZeroMemory( pFIDat->dsWidthTab.pvData, iI );   /* Zero the width table */
    }
    /*  Else clause not required,  since the structure is initialised to 0 */

    /*
     *    Generate an ID string for this font.  The ID string is displayed
     *  in UI components,  so we use the font name + point size.  The + 15 s
     *  allows for the string "%d Pt" at the end of the name.
     */


    /*
     *   If the typeface field gives us a name,  then we should display that
     *  one to the user.  We check to see if the value is within range,
     *  and use the pointer value if so.  Note that this pointer is NULL
     *  for an unknown name,  so we need to check that we end up pointing
     *  at something!
     */

    pwch = NULL;             /*  Means have not found one,  yet */

    if( sfh.bTypeface >= 0 && sfh.bTypeface < NUM_TYPEFACE )
    {
        /*    We have the "proper" name for this one!  */
        (const WCHAR *)pwch = pwcName[ sfh.bTypeface ];
    }

    if( pwch == NULL )
    {
        /*    Use the name supplied */
        pwch = (WCHAR *)((BYTE *)pIFI + pIFI->dpwszFaceName);
    }
    else
    {
        /*  Use the "standard" name we found above, and add StyleName  */
        StringCchCopyW(awchTemp, CCHOF(awchTemp), pwch); /* Standard name */
        pwch = (WCHAR *)((BYTE *)pIFI + pIFI->dpwszStyleName);
        if( *pwch )
        {
            StringCchCatW(awchTemp, CCHOF(awchTemp), L" ");
            StringCchCatW(awchTemp, CCHOF(awchTemp), pwch);
        }
        pwch = awchTemp;
    }

    /*   Allocate the storage we need */

    iI = (15 + wcslen( pwch )) * sizeof( WCHAR );

    if( !(pFIDat->dsIdentStr.pvData = HEAPALLOC( hheap, iI )) )
    {
        HeapFree( hheap, 0, (LPSTR)pIFI );
        HeapFree( hheap, 0, pFIDat->dsWidthTab.pvData );

        return  FALSE;
    }

    pFIDat->dsIdentStr.cBytes = iI;

    /*   Calculate point size,  to nearest quarter point */

    iI = 25 * (((pIFI->fwdWinAscender + pIFI->fwdWinDescender) * 72 * 4 + 150)
                                                                        / 300);

    StringCchPrintfW(pFIDat->dsIdentStr.pvData,
                     pFIDat->dsIdentStr.cBytes / sizeof(WCHAR),
                     L"%ws %d.%0d Pt", pwch, iI / 100, iI % 100);

    /*
     *   Set the landscape/portrait selection bits.
     */

    pFIDat->dwSelBits |= sfh.bOrientation ? FDH_LANDSCAPE : FDH_PORTRAIT;

    /*
     *    Loop through the remainder of the file processing whatever
     *  glyphs we discover.  Process means read the header to determine
     *  widths etc.
     */


    iMaxWidth = 0;
    iWidth = 0;
    cGlyphs = 0;

    while( pbFile < pbEnd )
    {
        /*   First step is to find the character index for this glyph */

        short   sWidth;                        /* Width in integral pels */


        iType = iNextType( pbFile );

        if( iType == TYPE_INVALID )
            return  FALSE;                      /* Cannot use this one */

        if( iType == TYPE_INDEX )
        {
            if( !(pbFile = pbReadIndex( pbFile, &iVal )) )
                return   FALSE;

            if( iVal < 0 )
                break;                  /* Illegal value: assume EOF */

            continue;                   /* Onwards & upwards */
        }


        if( !(pbFile = pbReadCHH( pbFile, &chh, iType == TYPE_CONT )) )
            return  FALSE;

        if( iType == TYPE_CONT )
            continue;                   /* Nothing else to do! */

        if( chh.bFormat == CH_FM_RASTER )
            pFIDat->dwSelBits |= FDH_BITMAP;
        else
        {
            if( chh.bFormat == CH_FM_SCALE )
                pFIDat->dwSelBits |= FDH_SCALABLE;
        }

        if( chh.bClass >= 1 && chh.bClass <= MAX_CLASS_MAP )
        {
            pFIDat->dwSelBits |= dwClassMap[ chh.bClass - 1 ];
        }
        else
        {
            /*
             *  Not a format we understand - yet!
             */

#if PRINT_INFO
            DbgPrint( "...Not our format: Format = %d, Class = %d\n",
                                                 chh.bFormat, chh.bClass );
#endif
            HeapFree( hheap, 0, (LPSTR)pIFI );

            return  FALSE;
        }

        /*
         *   If this is a valid glyph,  then we may want to record its
         * width (if proportionally spaced) and we are also interested
         * in some of the cell dimensions too!
         */

        if( iVal >= (int)pIFI->chFirstChar && iVal <= (int)pIFI->chLastChar &&
            (sfh.bFontType != PCL_FT_8LIM || (iVal <= 127 || iVal >= 160)) )
        {
            /*  Is valid for this font,  so process it.  */

            sWidth = (chh.wDeltaX + 2) / 4;     /* PCL in quarter dots */

            if( pFIDat->dsWidthTab.pvData )
                *((short *)pFIDat->dsWidthTab.pvData + iVal - pIFI->chFirstChar) =
                                                                 sWidth;

            if( sWidth > (WORD)iMaxWidth )
                iMaxWidth = sWidth;     /* Bigger & better */

            /*   Accumulate the averages */
            iWidth += sWidth;
            cGlyphs++;
        }
    }
    /*
     *   Most softfonts do not include the space char!  SO, we check to
     * see if it's width is zero.  If so,  we use the wPitch field to
     * calculate the HMI (horizontal motion index) and hence the width
     * of the space char.
     */

    iVal = ' ' - pIFI->chFirstChar;     /* Offset of space in width array */

    if( pFIDat->dsWidthTab.pvData &&
        *((short *)pFIDat->dsWidthTab.pvData + iVal) == 0 )
    {
        /*
         *  Zero width space,  so fill it in now.  The HMI is determined
         * from the pitch in the font header,  so we use that to
         * evaluate the size.  The pitch is in 0.25 dot units, so
         * round it to the nearest numbr of dots.
         */
        *((short *)pFIDat->dsWidthTab.pvData + iVal) = (short)((sfh.wPitch + 2) / 4);
        cGlyphs++;
        iWidth += (sfh.wPitch + 2) / 4;
    }

    /*
     *   A slight amendment to the IFIMETRICS.  We calculate the average
     *  width,  given the character data we have read!
     */

    if( cGlyphs > 0 )
    {
        pIFI->fwdAveCharWidth = (iWidth + cGlyphs / 2) / cGlyphs;
    }

    if( iMaxWidth > 0 )
    {
        pIFI->fwdMaxCharInc = (short)iMaxWidth;
    }
#if PRINT_INFO
    /*
     *    Print out the IFIMETRICS for this font - debugging is easier!
     */

    vPrintIFIMETRICS( pIFI, (VPRINT)DbgPrint );

#endif
    /*
     *   Set up the relevant translation table.  This is based on the
     * symbol set of the font.  We use a lookup table to scan and match
     * the value from those we have.  If outside the range, set to no
     * translation.  Not much choice here.
     */


    for( iI = 0; iI < NUM_CTTMAP; ++iI )
    {
        if( CttMap[ iI ].wSymSet == sfh.wSymSet )
        {
            /*   Bingo!  */
            pFIDat->dsCTT.cBytes = CttMap[ iI ].sCTT;
            break;
        }
    }

    /*  The following are GROSS assumptions!! */

    pFIDat->wXRes = 300;
    pFIDat->wYRes = 300;


    return  TRUE;
}

/***************************** Function Header *****************************
 * pbReadSFH
 *      Read a PCL SoftFont header and fill in the structure passed to us.
 *      The file is presumed mapped into memory, and that it's address
 *      is passed to us.  We return the address of the first byte past
 *      the header we process.
 *
 * RETURNS:
 *      Address of next location if OK,  else 0 for failure (bad format).
 *
 * HISTORY:
 *  11:01 on Wed 19 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      Numero uno.
 *
 ****************************************************************************/

BYTE  *
pbReadSFH( pbFile, psfh )
BYTE       *pbFile;             /* THE file */
SF_HEADER  *psfh;               /* Where the data goes */
{


    int     iSize;              /* Determine header size */


    /*
     *   The file should start off with \033)s...W   where ... is a decimal
     * ASCII count of the number of bytes following.  This may be larger
     * than the size of the SF_HEADER.
     */

    if( *pbFile++ != '\033' || *pbFile++ != ')' || *pbFile++ != 's' )
    {
#if PRINT_INFO
        DbgPrint( "Rasdd!pbReadSFH: bad file - first 2 bytes\n" );
#endif
        return   0;
    }

    /*  Now have a decimal byte count - convert it */

    iSize = 0;

    while( *pbFile >= '0' && *pbFile <= '9' )
        iSize = iSize * 10 + *pbFile++ - '0';



    if( *pbFile++ != 'W' )
    {
#if PRINT_INFO
        DbgPrint( "Rasdd!pbReadSFH: bad file: W missing\n" );
#endif

        return  0;
    }

    if( iSize < sizeof( SF_HEADER ) )
    {
#if PRINT_INFO
        DbgPrint( "Rasdd!pbReadSFH: Header size too small: %d vs %d\n", iSize,
                                                sizeof( SF_HEADER ) );
#endif

        return  0;

    }

    /*
     *   Now COPY the data into the structure passed in.  This IS NECESSARY
     * as the file data may not be aligned - the file contains no holes,
     * so we may have data with an incorrect offset.
     */

    CopyMemory( psfh, pbFile, sizeof( SF_HEADER ) );

    /*
     *   The big endian/little endian switch.
     */

    SWAB( psfh->wSize );
    SWAB( psfh->wBaseline );
    SWAB( psfh->wCellWide );
    SWAB( psfh->wCellHeight );
    SWAB( psfh->wSymSet );
    SWAB( psfh->wPitch );
    SWAB( psfh->wHeight );
    SWAB( psfh->wXHeight );
    SWAB( psfh->wTextHeight );
    SWAB( psfh->wTextWidth );

    return  pbFile + iSize;             /* Next part of the operation */
}

/**************************** Function Header *******************************
 * iNextType
 *      Read ahead to see what sort of record appears next.
 *
 * RETURNS:
 *      The type of record found.
 *
 * HISTORY:
 *  15:17 on Tue 03 Mar 1992    -by-    Lindsay Harris   [lindsayh]
 *      First version.
 *
 ****************************************************************************/

int
iNextType( pbFile )
BYTE  *pbFile;
{
    /*
     *   First character MUST be an escape!
     */

    CH_HEADER  *pCH;                    /* Character header: for continuation */



    if( *pbFile++ != '\033' )
        return  TYPE_INVALID;           /* No go */

    /*
     *   If the next two bytes are "*c", we have a character code command.
     *  Otherwise,  we can expect a "(s",  which indicates a font
     *  descriptor command.
     */


    if( *pbFile == '*' && *(pbFile + 1) == 'c' )
    {
        /*
         *   Verifu that this really is an index record: we should see
         * a numeric string and then a 'E'.
         */

        pbFile += 2;

        while( *pbFile >= '0' && *pbFile <= '9' )
                ++pbFile;


        return  *pbFile == 'E' ? TYPE_INDEX : TYPE_INVALID;
    }

    if( *pbFile != '(' || *(pbFile + 1) != 's' )
        return  TYPE_INVALID;

    /*
     *   Must now check to see if this is a continuation record or a
     * new record.  There is a byte in the header to indicate which
     * it is.   But first skip the byte count and trailing W.
     */

    pbFile += 2;
    while( *pbFile >= '0' && *pbFile <= '9' )
                pbFile++;

    if( *pbFile != 'W' )
        return  TYPE_INVALID;

    pCH = (CH_HEADER *)(pbFile + 1);

    /*
     *   Note that alignment is not a problem in the following
     * since we are dealing with a byte quantity.
     */

    return  pCH->bContinuation ? TYPE_CONT : TYPE_HEADER;
}


/**************************** Function Header *******************************
 * pbReadIndex
 *      Reads data from the pointer passed to us,  and attempts to interpret
 *      it as a PCL Character Code escape sequence.
 *
 * RETURNS:
 *      Pointer to byte past command,  else 0 for failure.
 *
 * HISTORY:
 *  16:21 on Wed 19 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      Number one
 *
 *****************************************************************************/


BYTE *
pbReadIndex( pbFile, piCode )
BYTE    *pbFile;                /* Where to start looking */
int     *piCode;                /* Where the result is placed */
{
    /*
     *   Command sequence is "\033*c..E" - where ... is the ASCII decimal
     * representation of the character code for this glyph.  That is
     * the value returned in *piCode.
     */

    int  iVal;


    if( *pbFile == '\0' )
    {
        /*  EOF is not really an error: return an OK value and -1 index */

        *piCode = -1;

        return  pbFile;         /* Presume EOF */
    }

    if( *pbFile++ != '\033' || *pbFile++ != '*' || *pbFile++ != 'c' )
    {
#if PRINT_INFO
        DbgPrint( "Rasdd!pbReadIndex: invalid character code\n" );
#endif

        return  0;
    }

    iVal = 0;
    while( *pbFile >= '0' && *pbFile <= '9' )
        iVal = iVal * 10 + *pbFile++ - '0';

    *piCode = iVal;

    if( *pbFile++ != 'E' )
    {
#if PRINT_INFO
        DbgPrint( "Rasdd!pbReadIndex: Missing 'E' in character code escape\n" );
#endif

        return  0;
    }

    return  pbFile;
}

/**************************** Function Header *******************************
 * pbReadCHH
 *      Function to read the Character Header at the memory location
 *      pointed to by by pbFile,  return a filled in CH_HEADER structure,
 *      and advance the file address to the next header.
 *
 * RETURNS:
 *      Address of first byte past where we finish; else 0 for failure.
 *
 * HISTORY:
 *  11:23 on Thu 20 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      Gotta start somewhere.
 *
 ****************************************************************************/

BYTE  *
pbReadCHH( pbFile, pchh, bCont )
BYTE       *pbFile;             /* File mapped into memory */
CH_HEADER  *pchh;               /* Structure to fill in */
BOOL        bCont;              /* TRUE if this is a continuation record */
{

    int    iSize;               /* Bytes of data to skip over */

    /*
     *   The entry starts with a string "\033(s..W" where .. is the ASCII
     * decimal count of the number of bytes following the W.  Since this
     * includes the download stuff,  we would expect more than the size
     * of the CH_HEADER.
     */


    if( *pbFile++ != '\033' || *pbFile++ != '(' || *pbFile++ != 's' )
    {
#if PRINT_INFO
        DbgPrint( "Rasdd!pbReadCHH: bad format, first 3 bytes\n" );
#endif

        return  0;
    }

    iSize = 0;
    while( *pbFile >= '0' && *pbFile <= '9' )
        iSize = iSize * 10 + *pbFile++ - '0';


    if( iSize < sizeof( CH_HEADER ) )
    {
#if PRINT_INFO
        DbgPrint( "Rasdd!pbReadCHH: size field (%ld) < header size\n", iSize );
#endif

        return  0;
    }

    if( *pbFile++ != 'W' )
    {
#if PRINT_INFO
        DbgPrint( "Rasdd!pbReadCHH: invalid escape sequence\n" );
#endif

        return  0;
    }

    /*
     *   If this is a continuation record,  there is no more to do but
     * return the address past this record.
     */
    if( bCont )
        return  pbFile + iSize;


    /*  Copy the data to the structure - may not be aligned in the file */
    CopyMemory( pchh, pbFile, sizeof( CH_HEADER ) );

    pbFile += iSize;            /* End of this record */


    SWAB( pchh->sLOff );
    SWAB( pchh->sTOff );
    SWAB( pchh->wChWidth );
    SWAB( pchh->wChHeight );
    SWAB( pchh->wDeltaX );


    /*
     *   If this glyph is in landscape,  we need to swap some data
     * around,  since the data format is designed for the printer's
     * convenience, and not ours!
     */

    if( pchh->bOrientation )
    {
        /*   Landscape,  so swap the entries around  */
        short  sSwap;
        WORD   wSwap;

        /* Left & Top offsets: see pages 10-19, 10-20 of LJ II manual */
        sSwap = pchh->sTOff;
        pchh->sTOff = -pchh->sLOff;
        pchh->sLOff = (short)(sSwap + 1 - pchh->wChHeight);

        /*  Delta X remains the same */

        /*  Height and Width are switched around */
        wSwap = pchh->wChWidth;
        pchh->wChWidth = pchh->wChHeight;
        pchh->wChHeight = wSwap;
    }


    /*
     *     pbFile is pointing at the correct location when we reach here.
     */
    return  pbFile;
}


/*************************** Function Header *******************************
 * SfhToIFI
 *      Generate IFIMETRICS data from the PCL softfont header.  There are
 *      some fields we are unable to evaluate,  e.g. first/last char,
 *      since these are obtained from the file.
 *
 * RETURNS:
 *      Pointer to IFIMETRICS,  allocated from heap; 0 on error.
 *
 * HISTORY:
 *  13:57 on Fri 18 Jun 1993    -by-    Lindsay Harris   [lindsayh]
 *      Assorted bug fixing for that infamous tax program
 *
 *  16:03 on Thu 11 Mar 1993    -by-    Lindsay Harris   [lindsayh]
 *      Correct conversion to Unicode - perhaps??
 *
 *  16:45 on Wed 03 Mar 1993    -by-    Lindsay Harris   [lindsayh]
 *      Update to libc wcs functions rather than printers\lib versions.
 *
 *  14:19 on Thu 20 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      Fresh off the presses.
 *
 ****************************************************************************/

IFIMETRICS  *
SfhToIFI( psfh, hheap, pwstrUniqNm )
SF_HEADER  *psfh;               /* The data source */
HANDLE      hheap;              /* Source of memory */
PWSTR       pwstrUniqNm;        /* Unique name for IFIMETRICS */
{
    /*
     *   Several hard parts:  the hardest are the panose numbers.
     * It is messy, though not difficult to generate the variations
     * of the font name.
     */

    register  IFIMETRICS   *pIFI;


    int     iI;                 /* Loop index,  of course! */
    int     cWC;                /* Number of WCHARS to add */
    int     cbAlloc;            /* Number of bytes to allocate */
    int     cChars;             /* Number chars to convert to Unicode */
    WCHAR  *pwch, *pwchEnd;     /* For string manipulations */
    WCHAR  *pwchTypeface;       /* Name from typeface value */
    WCHAR  *pwchGeneric;        /* Generic windows name */

    char    ajName[ SFH_NM_SZ + 1 ];    /* Guaranteed null terminated name */
    WCHAR   awcName[ SFH_NM_SZ + 1 ];   /* Wide version of the above */

               /*  NOTE:  FOLLOWING 2 MUST BE 256 ENTRIES LONG!!! */
    WCHAR   awcAttrib[ 256 ];           /* For generating attributes */
    BYTE    ajANSI[ 256 ];              /* ANSI equivalent of above */


    /*
     *   First massage the font name.  We need to null terminate it, since
     * the softfont data need not be.  And we also need to truncate any
     * trailing blanks.
     *
     *   But we also calculate all the aliases we are going to add.  Apart
     * from the name in the file (which may not be useful), there is
     * the name based on the bTypeface field in the header, AND there
     * is the generic (SWISS/MODERN/ROMAN) type based on the font
     * characteristics.
     *
     *  NOTE: change of plans here:  we only use the font name from the
     *  file if the header's typeface index is for a font that we don't
     *  know about.  This causes the least problems for GDI and it's
     *  font mapper.
     */


    if( psfh->bTypeface >= 0 && psfh->bTypeface < NUM_TYPEFACE )
    {
        (const WCHAR *)pwchTypeface = pwcName[ psfh->bTypeface ];
    }
    else
    {
        FillMemory( ajName, SFH_NM_SZ, ' ' );

        strncpy( ajName, psfh->chName, SFH_NM_SZ );
        ajName[ SFH_NM_SZ ] = '\0';


        for( iI = strlen( ajName ) - 1; iI >= 0; --iI )
        {
            if( ajName[ iI ] != ' ' )
            {
                ajName[ iI + 1 ] = '\0';            /* Must be the end */
                break;
            }
        }
        strcpy2WChar( awcName, ajName );            /* Base name */
        pwchTypeface = awcName;                     /* For later use */
    }


    /*
     *    The generic name is based on 2 facts:  fixed or variable pitch,
     *  and variable pitch switches between serifed and non-serifed fonts.
     */

    if( psfh->bSpacing )
    {
        /*
         *    Proportional font,  so we need to look for serifs.
         */

        if( (psfh->bSerifStyle >= 2 && psfh->bSerifStyle <= 8) ||
            (psfh->bSerifStyle & 0xc0) == 0x80 )
        {
            /*   A font with serifs,  so set this as a Roman font */
            pwchGeneric = L"Roman";
        }
        else
            pwchGeneric = L"Swiss";         /* No serifs */
    }
    else
        pwchGeneric = L"Modern";



    /*
     *   Produce the desired attributes: Italic, Bold, Light etc.
     * This is largely guesswork,  and there should be a better method.
     */


    awcAttrib[ 0 ] = L'\0';
    awcAttrib[ 1 ] = L'\0';               /* Write out an empty string */

    if( psfh->bStyle )                  /* 0 normal, 1 italic */
        StringCchCatW(awcAttrib, CCHOF(awcAttrib), L" Italic");

    if( psfh->sbStrokeW >= PCL_BOLD )           /* As per HP spec */
        StringCchCatW(awcAttrib, CCHOF(awcAttrib), L" Bold");
    else
    {
        if( psfh->sbStrokeW <= PCL_LIGHT )
            StringCchCatW(awcAttrib, CCHOF(awcAttrib), L" Light");
    }

    /*
     *    First step is to determine the length of the WCHAR strings
     *  that are placed at the end of the IFIMETRICS,  since we need
     *  to include these in our storage allocation.
     *
     *   The attribute string appears in 3 entries of IFIMETRICS,  so
     * calculate how much storage this will take.  NOTE THAT THE LEADING
     * CHAR IN awcAttrib is NOT placed in the style name field,  so we
     * subtract one in the following formula to account for this.
     */


    cWC = 3 * wcslen( pwchTypeface ) +         /* Base name */
          wcslen( pwchGeneric ) +              /* In the alias section */
          3 * wcslen( awcAttrib ) +            /* In most places */
          wcslen( pwstrUniqNm ) + 1 +          /* Printer name plus space */
          6;                                   /* Terminating nulls */

    cbAlloc = sizeof( IFIMETRICS ) + sizeof( WCHAR ) * cWC;

    pIFI = (IFIMETRICS *)HEAPALLOC( hheap, cbAlloc );

    if( !pIFI )
        return   NULL;                          /* Not very nice! */


    ZeroMemory( pIFI, cbAlloc );                /* In case we miss something */


    pIFI->cjThis = cbAlloc;                     /* Everything */

    pIFI->cjIfiExtra = 0;

    /*   The family name:  straight from the FaceName - no choice?? */

    pwch = (WCHAR *)(pIFI + 1);         /* At the end of the structure */
    pIFI->dpwszFamilyName = (PTRDIFF)((BYTE *)pwch - (BYTE *)pIFI);

    pwchEnd = pwch + cWC;

    StringCchCopyW(pwch, pwchEnd - pwch, pwchTypeface); /* Base name */

    /*   Add the aliases too! */
    pwch += wcslen( pwch ) + 1;                         /* After the nul */
    StringCchCopyW(pwch, pwchEnd - pwch, pwchGeneric);  /* Windows generic */


    pwch += wcslen( pwch ) + 2;         /* Skip what we just put in */


    /*   Now the face name:  we add bold, italic etc to family name */

    pIFI->dpwszFaceName = (PTRDIFF)((BYTE *)pwch - (BYTE *)pIFI);

    StringCchCopyW(pwch, pwchEnd - pwch, pwchTypeface); /* Base name */
    StringCchCatW(pwch, pwchEnd - pwch, awcAttrib);


    /*   Now the unique name - well, sort of, anyway */

    pwch += wcslen( pwch ) + 1;         /* Skip what we just put in */
    pIFI->dpwszUniqueName = (PTRDIFF)((BYTE *)pwch - (BYTE *)pIFI);

    StringCchCopyW(pwch, pwchEnd - pwch, pwstrUniqNm);
    StringCchCatW(pwch, pwchEnd - pwch, L" ");
    StringCchCatW(pwch, pwchEnd - pwch, (PWSTR)((BYTE *)pIFI + pIFI->dpwszFaceName));

    /*  Onto the attributes only component */

    pwch += wcslen( pwch ) + 1;         /* Skip what we just put in */
    pIFI->dpwszStyleName = (PTRDIFF)((BYTE *)pwch - (BYTE *)pIFI);
    StringCchCatW(pwch, pwchEnd - pwch, &awcAttrib[1]);

#if DBG
    /*
     *    Check on a few memory sizes:  JUST IN CASE.....
     */

    if( (wcslen( awcAttrib ) * sizeof( WCHAR )) >= sizeof( awcAttrib ) )
    {
        DbgPrint( "Rasdd!SfhToIFI: STACK CORRUPTED BY awcAttrib" );

        HeapFree( hheap, 0, (LPSTR)pIFI );         /* No memory leaks */

        return  0;
    }


    if( ((BYTE *)(pwch + wcslen( pwch ) + 1)) > ((BYTE *)pIFI + cbAlloc) )
    {
        DbgPrint( "Rasdd!SfhToIFI: IFIMETRICS overflow: Wrote to 0x%lx, allocated to 0x%lx\n",
                ((BYTE *)(pwch + wcslen( pwch ) + 1)),
                ((BYTE *)pIFI + cbAlloc) );

        HeapFree( hheap, 0, (LPSTR)pIFI );         /* No memory leaks */

        return  0;

    }
#endif

    /*
     *   Change to use new IFIMETRICS.
     */

    pIFI->flInfo = FM_INFO_TECH_BITMAP | FM_INFO_1BPP |
                                 FM_INFO_RIGHT_HANDED | FM_INFO_FAMILY_EQUIV;


    pIFI->lEmbedId     = 0;
    pIFI->lItalicAngle = 0;
    pIFI->lCharBias    = 0;
    pIFI->dpCharSets   = 0; // no multiple charsets in rasdd fonts


    pIFI->fwdUnitsPerEm = psfh->wCellHeight;
    pIFI->fwdLowestPPEm = 1;                   /* Not important for us */

    pIFI->fwdWinAscender = psfh->wBaseline;
    pIFI->fwdWinDescender = psfh->wCellHeight - psfh->wBaseline;

    pIFI->fwdMacAscender =    pIFI->fwdWinAscender;
    pIFI->fwdMacDescender = - pIFI->fwdWinDescender;

    pIFI->fwdMacLineGap = 0;

    pIFI->fwdTypoAscender  = pIFI->fwdMacAscender;
    pIFI->fwdTypoDescender = pIFI->fwdMacDescender;
    pIFI->fwdTypoLineGap   = pIFI->fwdMacLineGap;

    pIFI->fwdAveCharWidth = (psfh->wTextWidth + 2) / 4;
    pIFI->fwdMaxCharInc = psfh->wCellWide;

    pIFI->fwdCapHeight = psfh->wBaseline;
    pIFI->fwdXHeight   = psfh->wBaseline;


    pIFI->fwdUnderscoreSize = psfh->bUHeight;
    pIFI->fwdUnderscorePosition = -(psfh->sbUDist - psfh->bUHeight / 2);

    pIFI->fwdStrikeoutSize = psfh->bUHeight;
    pIFI->fwdStrikeoutPosition = psfh->wBaseline / 3;

    pIFI->jWinCharSet = OEM_CHARSET;

    if( psfh->bSpacing )
    {
        /*
         *   Proportional,  so also look at the serif style.  Consult the
         *  LaserJet III Technical Reference Manual to see the following
         *  constants.  Basically,  the serif fonts have a value between
         *  2 and 8, or the top two bits have the value 64.
         */
        if( (psfh->bSerifStyle >= 2 && psfh->bSerifStyle <= 8) ||
            (psfh->bSerifStyle & 0xc0) == 0x80 )
         {
            pIFI->jWinPitchAndFamily = FF_ROMAN | VARIABLE_PITCH;
         }
         else
            pIFI->jWinPitchAndFamily = FF_SWISS | VARIABLE_PITCH;
    }
    else
    {
        /*  Fixed pitch,  so select FF_MODERN as the style */
        pIFI->jWinPitchAndFamily = FF_MODERN | FIXED_PITCH;
    }


    pIFI->usWinWeight = 400;                 /* Normal weight */
    pIFI->panose.bWeight = PAN_WEIGHT_MEDIUM;
    if( psfh->sbStrokeW >= PCL_BOLD )           /* As per HP spec */
    {
        /*  Set a bold value */
        pIFI->usWinWeight = 700;
        pIFI->panose.bWeight = PAN_WEIGHT_BOLD;
    }
    else
    {
        if( psfh->sbStrokeW <= PCL_LIGHT )
        {
            pIFI->usWinWeight = 200;
            pIFI->panose.bWeight = PAN_WEIGHT_LIGHT;
        }
    }

    pIFI->fsType = FM_NO_EMBEDDING;


    /*
     *   The first/last/break/default glyphs:  these are determined by the
     * type of the font.  ALL PCL fonts (according to HP documentation)
     * include the space character, so we use that.
     */

    if( psfh->bFontType != PCL_FT_PC8 )
        pIFI->chFirstChar = ' ';
    else
        pIFI->chFirstChar = 0;

    if( psfh->bFontType == PCL_FT_7BIT )
        pIFI->chLastChar = 127;
    else
        pIFI->chLastChar = 255;

    pIFI->chDefaultChar = '.' - pIFI->chFirstChar;
    pIFI->chBreakChar = ' ' - pIFI->chFirstChar;


    /*   Fill in the WCHAR versions of these values */

    cChars = pIFI->chLastChar - pIFI->chFirstChar + 1;
    for( iI = 0; iI < cChars; ++iI )
        ajANSI[ iI ] = (BYTE)(pIFI->chFirstChar + iI);

    MultiByteToWideChar( CP_ACP, 0, ajANSI, cChars, awcAttrib, cChars );


    pIFI->wcDefaultChar = awcAttrib[ pIFI->chDefaultChar ];
    pIFI->wcBreakChar = awcAttrib[ pIFI->chBreakChar ];

    pIFI->wcFirstChar = 0xffff;
    pIFI->wcLastChar = 0;


    /*   Scan for first and last */
    for( iI = 0; iI < cChars; ++iI )
    {
        if( awcAttrib[ iI ] > pIFI->wcLastChar )
            pIFI->wcLastChar = awcAttrib[ iI ];

        if( awcAttrib[ iI ] < pIFI->wcFirstChar )
            pIFI->wcFirstChar = awcAttrib[ iI ];
    }

    /*   StemDir:  either roman or italic */


    if( psfh->sbStrokeW >= PCL_BOLD )           /* As per HP spec */
        pIFI->fsSelection |= FM_SEL_BOLD;

    if( psfh->bStyle )
    {
        /*
         *   Tan (17.5 degrees) = .3153
         */
        pIFI->ptlCaret.x =  3153;
        pIFI->ptlCaret.y = 10000;
        pIFI->fsSelection |= FM_SEL_ITALIC;
    }
    else
    {
        pIFI->ptlCaret.x = 0;
        pIFI->ptlCaret.y = 1;
    }

    if( (pIFI->fsSelection & (FM_SEL_ITALIC | FM_SEL_BOLD)) == 0 )
        pIFI->fsSelection |= FM_SEL_REGULAR;

    if( !psfh->bSpacing )
        pIFI->flInfo |= FM_INFO_CONSTANT_WIDTH;

    pIFI->ptlBaseline.x = 1;
    pIFI->ptlBaseline.y = 0;

    pIFI->ptlAspect.x = pIFI->ptlAspect.y = 300;

    pIFI->fwdSubscriptXSize = (FWORD)(pIFI->fwdAveCharWidth / 4);
    pIFI->fwdSubscriptYSize = (FWORD)(pIFI->fwdWinAscender / 4);

    pIFI->fwdSubscriptXOffset = (FWORD)(3 * pIFI->fwdAveCharWidth / 4);
    pIFI->fwdSubscriptYOffset = (FWORD)(-pIFI->fwdWinAscender / 4);

    pIFI->fwdSuperscriptXSize = (FWORD)(pIFI->fwdAveCharWidth / 4);
    pIFI->fwdSuperscriptYSize = (FWORD)(pIFI->fwdWinAscender / 4);

    pIFI->fwdSuperscriptXOffset = (FWORD)(3 * pIFI->fwdAveCharWidth / 4);
    pIFI->fwdSuperscriptYOffset = (FWORD)(3 * pIFI->fwdWinAscender / 4);


    pIFI->rclFontBox.left = 0;
    pIFI->rclFontBox.top = pIFI->fwdWinAscender;
    pIFI->rclFontBox.right = pIFI->fwdMaxCharInc;
    pIFI->rclFontBox.bottom = -pIFI->fwdWinDescender;

    pIFI->achVendId[ 0 ] = 'U';
    pIFI->achVendId[ 1 ] = 'n';
    pIFI->achVendId[ 2 ] = 'k';
    pIFI->achVendId[ 3 ] = 'n';

    pIFI->cKerningPairs = 0;

    pIFI->ulPanoseCulture         = FM_PANOSE_CULTURE_LATIN;
    pIFI->panose.bFamilyType      = PAN_ANY;
    pIFI->panose.bSerifStyle      = PAN_ANY;
    pIFI->panose.bProportion      = PAN_ANY;
    pIFI->panose.bContrast        = PAN_ANY;
    pIFI->panose.bStrokeVariation = PAN_ANY;
    pIFI->panose.bArmStyle        = PAN_ANY;
    pIFI->panose.bLetterform      = PAN_ANY;
    pIFI->panose.bMidline         = PAN_ANY;
    pIFI->panose.bXHeight         = PAN_ANY;

    return  pIFI;
}


/************************* Function Header ********************************
 * strcpy2WChar
 *      Convert a char * string to a WCHAR string.  Basically this means
 *      converting each input character to 16 bits by zero extending it.
 *
 * RETURNS:
 *      Value of first parameter.
 *
 * HISTORY:
 *  12:35 on Thu 18 Mar 1993    -by-    Lindsay Harris   [lindsayh]
 *      Use the correct conversion method to Unicode.
 *
 *  09:36 on Thu 07 Mar 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it.
 *
 **************************************************************************/

PWSTR
strcpy2WChar( pWCHOut, lpstr )
PWSTR   pWCHOut;              /* Destination */
LPSTR   lpstr;                /* Source string */
{

    /*
     *   Put buffering around the NLS function that does all this stuff.
     */

    int     cchIn;             /* Number of input chars */


    cchIn = strlen( lpstr ) + 1;

    MultiByteToWideChar( CP_ACP, 0, lpstr, cchIn, pWCHOut, cchIn );


    return  pWCHOut;
}


/******************************************************************************
 *
 *                            FIWriteFix
 *
 *  Function:
 *      Write the IFIMETRICS fixed data to the output file
 *
 *  Returns:
 *       Number of bytes written
 *
 ******************************************************************************/

DWORD
FIWriteFix(
    HANDLE    hFile,
    WORD      wDataID,
    FI_DATA  *pFD           // Pointer to data to write
    )
{

    DATA_HEADER dh;
    DWORD       dwSize;

    //
    // Then write out the header, followed by the actual data
    //

    dh.dwSignature = DATA_IFI_SIG;
    dh.wSize       = (WORD)sizeof(DATA_HEADER);
    dh.wDataID     = wDataID;
    dh.dwDataSize  = sizeof(FI_DATA_HEADER) +
                     pFD->dsIFIMet.cBytes   +
                     pFD->dsWidthTab.cBytes +
                     pFD->dsSel.cBytes      +
                     pFD->dsDesel.cBytes    +
                     pFD->dsIdentStr.cBytes +
                     pFD->dsETM.cBytes;

    dh.dwReserved  = 0;

    WriteFile(hFile, (PVOID)&dh, sizeof(DATA_HEADER), &dwSize, NULL);

    return sizeof(DATA_HEADER) + iWriteFDH(hFile, pFD);
}


/******************************************************************************
 *
 *                            FIWriteVar
 *
 *  Function:
 *      Write the PCL variable data to the output file
 *
 *  Returns:
 *       Number of bytes written
 *
 ******************************************************************************/

DWORD
FIWriteVar(
    HANDLE   hFile,         // The file to which the data is written
    TCHAR   *ptchName       // File name containing the data
    )
{
    DATA_HEADER dh;
    HANDLE      hIn;
    DWORD       dwSize = 0;

    if (ptchName == 0 || *ptchName == (TCHAR)0)
        return   0;

    hIn = CreateFileW(ptchName,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      0,
                      0);

    if (hIn == INVALID_HANDLE_VALUE)
    {
        WARNING(("Error %d opening file %ws\n", GetLastError(), ptchName));
        return  0;
    }

    //
    // First write out the header, followed by the actual data
    //

    dh.dwSignature = DATA_VAR_SIG;
    dh.wSize       = (WORD)sizeof(DATA_HEADER);
    dh.wDataID     = 0;
    dh.dwDataSize  = GetFileSize(hIn, NULL);
    dh.dwReserved  = 0;

    if (WriteFile(hFile, (PVOID)&dh, sizeof(DATA_HEADER), &dwSize, NULL))
    {
        dwSize += FICopy(hFile, hIn);
    }

    CloseHandle(hIn);

    return dwSize;
}


/******************************************************************************
 *
 *                            FIWriteRawVar
 *
 *  Function:
 *      Write the PCL variable data to the output file
 *
 *  Returns:
 *       Number of bytes written
 *
 ******************************************************************************/

DWORD
FIWriteRawVar(
    HANDLE   hFile,         // The file to which the data is written
    PBYTE    pRawVar,       // Buffer containing PCL data
    DWORD    dwSize         // Size of buffer
    )
{
    DATA_HEADER dh;
    DWORD       dwBytesWritten = 0;

    if (pRawVar == NULL || dwSize == 0)
        return   0;

    //
    // First write out the header, followed by the actual data
    //

    dh.dwSignature = DATA_VAR_SIG;
    dh.wSize       = (WORD)sizeof(DATA_HEADER);
    dh.wDataID     = 0;
    dh.dwDataSize  = dwSize;
    dh.dwReserved  = 0;

    if (! WriteFile(hFile, (PVOID)&dh, sizeof(DATA_HEADER), &dwBytesWritten, NULL) ||
        ! WriteFile(hFile, (PVOID)pRawVar, dwSize, &dwSize, NULL))
        return 0;

    return dwSize+dwBytesWritten;
}



/************************** Function Header ********************************
 * FICopy
 *      Copy the file contents of the input handle to that of the output
 *      handle.
 *
 * RETURNS:
 *      Number of bytes copied,  -1 on error, 0 is legitimate.
 *
 * HISTORY:
 *  18:06 on Mon 24 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      Start
 *
 ***************************************************************************/


DWORD
FICopy(
    HANDLE   hOut,          /* Output file:  write to current position */
    HANDLE   hIn            /* Input file: copy from current position to EOF */
    )
{
    /*
     *   Simple read/write operations until EOF is reached on the input.
     * May also be errors,  so handle these too.  As we are dealing with
     * relatively small files (a few 10s of k), we use a stack buffer.
     */

#define CPBSZ   2048

    DWORD  dwSize;
    DWORD  dwGot;
    DWORD  dwTot;               /* Accumulate number of bytes copied */

    BYTE   ajBuf[ CPBSZ ];

    dwTot = 0;

    while (ReadFile(hIn, ajBuf, CPBSZ, &dwGot, NULL))
    {
        /*  A read of zero means we have reached EOF  */

        if (dwGot == 0)
            return  dwTot;              /* However much so far */

        if (!WriteFile( hOut, ajBuf, dwGot, &dwSize, NULL) ||
            dwSize != dwGot)
        {
            /*  Assume some serious problem */

            return  0;
        }

        dwTot += dwSize;
    }

    /*
     *   We only come here for an error,  so return the bad news.
     */

    return  0;
}

/******************************* Function Header *****************************
 * iWriteFDH
 *      Write the FI_DATA_HEADER data out to our file.  We do the conversion
 *      from addresses to offsets, and write out any data we find.
 *
 * RETURNS:
 *      The number of bytes actually written; -1 for error, 0 for nothing.
 *
 * HISTORY:
 *  16:58 on Thu 05 Mar 1992    -by-    Lindsay Harris   [lindsayh]
 *      Based on an experimental version first used in font installer.
 *
 *  17:11 on Fri 21 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      First version.
 *
 *****************************************************************************/

int
iWriteFDH( hFile, pFD )
HANDLE    hFile;        /* File wherein to place the data */
FI_DATA  *pFD;          /* Pointer to FM to write out */
{
    /*
     *   Decide how many bytes will be written out.  We presume that the
     * file pointer is located at the correct position when we are called.
     */

    int  iSize;         /* Evaluate output size */


    FI_DATA_HEADER   fdh;       /* Header written to file */




    if( pFD == 0 )
        return  0;      /* Perhaps only deleting?  */

    memset( &fdh, 0, sizeof( fdh ) );           /* Zero for convenience */

    /*
     *  Set the miscellaneous flags etc.
     */

    fdh.cjThis = sizeof( fdh );

    fdh.fCaps = pFD->fCaps;
    fdh.wFontType= pFD->wFontType; /* Device Font Type */

    fdh.wXRes = pFD->wXRes;
    fdh.wYRes = pFD->wYRes;

    fdh.sYAdjust = pFD->sYAdjust;
    fdh.sYMoved = pFD->sYMoved;

    fdh.u.sCTTid = (short)pFD->dsCTT.cBytes;

    fdh.dwSelBits = pFD->dwSelBits;

    fdh.wPrivateData = pFD->wPrivateData;


    iSize = sizeof( fdh );              /* Our header already */
    fdh.dwIFIMet = iSize;               /* Location of IFIMETRICS */

    iSize += pFD->dsIFIMet.cBytes;              /* Bytes in struct */

    /*
     *   And there may be a width table too!  The pFD values are zero if none.
     */

    if( pFD->dsWidthTab.cBytes )
    {
        fdh.dwWidthTab = iSize;

        iSize += pFD->dsWidthTab.cBytes;
    }

    /*
     *  Finally are the select/deselect strings.
     */

    if( pFD->dsSel.cBytes )
    {
        fdh.dwCDSelect = iSize;
        iSize += pFD->dsSel.cBytes;
    }

    if( pFD->dsDesel.cBytes )
    {
        fdh.dwCDDeselect = iSize;
        iSize += pFD->dsDesel.cBytes;
    }

    /*
     *   There may also be some sort of identification string.
     */

    if( pFD->dsIdentStr.cBytes )
    {
        fdh.dwIdentStr = iSize;
        iSize += pFD->dsIdentStr.cBytes;
    }

    if( pFD->dsETM.cBytes )
    {
        fdh.dwETM = iSize;
        iSize += pFD->dsETM.cBytes;
    }


    /*
     *   Sizes all figured out,  so write the data!
     */

    if( !bWrite( hFile, &fdh, sizeof( fdh ) ) ||
        !bWrite( hFile, pFD->dsIFIMet.pvData, pFD->dsIFIMet.cBytes ) ||
        !bWrite( hFile, pFD->dsWidthTab.pvData, pFD->dsWidthTab.cBytes ) ||
        !bWrite( hFile, pFD->dsSel.pvData, pFD->dsSel.cBytes ) ||
        !bWrite( hFile, pFD->dsDesel.pvData, pFD->dsDesel.cBytes ) ||
        !bWrite( hFile, pFD->dsIdentStr.pvData, pFD->dsIdentStr.cBytes ) ||
        !bWrite( hFile, pFD->dsETM.pvData, pFD->dsETM.cBytes ) )
                return   0;


    return  iSize;                      /* Number of bytes written */

}

/************************* Function Header *********************************
 * bWrite
 *      Writes data out to a file handle.  Returns TRUE on success.
 *      Functions as a nop if the size request is zero.
 *
 * RETURNS:
 *      TRUE/FALSE,  TRUE for success.
 *
 * HISTORY:
 *  17:38 on Fri 21 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      # 1
 *
 ****************************************************************************/

BOOL
bWrite( hFile, pvBuf, iSize )
HANDLE   hFile;         /* The file to which to write */
VOID    *pvBuf;         /* Data to write */
int      iSize;         /* Number of bytes to write */
{
    /*
     *   Simplify the ugly NT interface.  Returns TRUE if the WriteFile
     * call returns TRUE and the number of bytes written equals the
     * number of bytes desired.
     */


    BOOL   bRet;
    DWORD  dwSize;              /* Filled in by WriteFile */


    bRet = TRUE;

    if( iSize > 0 &&
        (!WriteFile( hFile, pvBuf, (DWORD)iSize, &dwSize, NULL ) ||
         (DWORD)iSize != dwSize) )
             bRet = FALSE;              /* Too bad */


    return  bRet;
}

#if  PRINT_INFO

/******************************Public*Routine******************************\
* vCheckIFIMETRICS
*
* This is where you put sanity checks on an incomming IFIMETRICS structure.
*
* History:
*  Sun 01-Nov-1992 22:55:31 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

VOID
vCheckIFIMETRICS(
    IFIMETRICS *pifi,
    VPRINT vPrint
    )
{
    BOOL bGoodPitch;

    BYTE jPitch =
        pifi->jWinPitchAndFamily & (DEFAULT_PITCH | FIXED_PITCH | VARIABLE_PITCH);


    if (pifi->flInfo & FM_INFO_CONSTANT_WIDTH)
    {
        bGoodPitch = (jPitch == FIXED_PITCH);
    }
    else
    {
        bGoodPitch = (jPitch == VARIABLE_PITCH);
    }
    if (!bGoodPitch)
    {
        vPrint("\n\n<INCONSISTENCY DETECTED>\n");
        vPrint(
            "    jWinPitchAndFamily = %-#2x, flInfo = %-#8lx\n\n",
            pifi->jWinPitchAndFamily,
            pifi->flInfo
            );
    }
}


/******************************Public*Routine******************************\
* vPrintIFIMETRICS
*
* Dumps the IFMETERICS to the screen
*
* History:
*  Wed 13-Jan-1993 10:14:21 by Kirk Olynyk [kirko]
* Updated it to conform to some changes to the IFIMETRICS structure
*
*  Thu 05-Nov-1992 12:43:06 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

VOID
vPrintIFIMETRICS(
    IFIMETRICS *pifi,
    VPRINT vPrint
    )
{
//
// Convenient pointer to Panose number
//
    PANOSE *ppan = &pifi->panose;

    PWSZ pwszFamilyName = (PWSZ)(((BYTE*) pifi) + pifi->dpwszFamilyName);
    PWSZ pwszStyleName  = (PWSZ)(((BYTE*) pifi) + pifi->dpwszStyleName );
    PWSZ pwszFaceName   = (PWSZ)(((BYTE*) pifi) + pifi->dpwszFaceName  );
    PWSZ pwszUniqueName = (PWSZ)(((BYTE*) pifi) + pifi->dpwszUniqueName);

    vPrint("    cjThis                 %-#8lx\n" , pifi->cjThis );
    vPrint("    cjIfiExtra             %-#8lx\n" , pifi->cjIfiExtra );
    vPrint("    pwszFamilyName         \"%ws\"\n", pwszFamilyName );

    if( pifi->flInfo & FM_INFO_FAMILY_EQUIV )
    {
        /*  Aliasing is in effect!  */

        while( *(pwszFamilyName += wcslen( pwszFamilyName ) + 1) )
            vPrint("                               \"%ws\"\n", pwszFamilyName );
    }

    vPrint("    pwszStyleName          \"%ws\"\n", pwszStyleName );
    vPrint("    pwszFaceName           \"%ws\"\n", pwszFaceName );
    vPrint("    pwszUniqueName         \"%ws\"\n", pwszUniqueName );
    vPrint("    dpFontSim              %-#8lx\n" , pifi->dpFontSim );
    vPrint("    lEmbedId               %d\n",      pifi->lEmbedId    );
    vPrint("    lItalicAngle           %d\n",      pifi->lItalicAngle);
    vPrint("    lCharBias              %d\n",      pifi->lCharBias   );
    vPrint("    lEmbedId               %d\n"     , pifi->lEmbedId);
    vPrint("    lItalicAngle           %d\n"     , pifi->lItalicAngle);
    vPrint("    lCharBias              %d\n"     , pifi->lCharBias);
    vPrint("    jWinCharSet            %04x\n"   , pifi->jWinCharSet );
    vPrint("    jWinPitchAndFamily     %04x\n"   , pifi->jWinPitchAndFamily );
    vPrint("    usWinWeight            %d\n"     , pifi->usWinWeight );
    vPrint("    flInfo                 %-#8lx\n" , pifi->flInfo );
    vPrint("    fsSelection            %-#6lx\n" , pifi->fsSelection );
    vPrint("    fsType                 %-#6lx\n" , pifi->fsType );
    vPrint("    fwdUnitsPerEm          %d\n"     , pifi->fwdUnitsPerEm );
    vPrint("    fwdLowestPPEm          %d\n"     , pifi->fwdLowestPPEm );
    vPrint("    fwdWinAscender         %d\n"     , pifi->fwdWinAscender );
    vPrint("    fwdWinDescender        %d\n"     , pifi->fwdWinDescender );
    vPrint("    fwdMacAscender         %d\n"     , pifi->fwdMacAscender );
    vPrint("    fwdMacDescender        %d\n"     , pifi->fwdMacDescender );
    vPrint("    fwdMacLineGap          %d\n"     , pifi->fwdMacLineGap );
    vPrint("    fwdTypoAscender        %d\n"     , pifi->fwdTypoAscender );
    vPrint("    fwdTypoDescender       %d\n"     , pifi->fwdTypoDescender );
    vPrint("    fwdTypoLineGap         %d\n"     , pifi->fwdTypoLineGap );
    vPrint("    fwdAveCharWidth        %d\n"     , pifi->fwdAveCharWidth );
    vPrint("    fwdMaxCharInc          %d\n"     , pifi->fwdMaxCharInc );
    vPrint("    fwdCapHeight           %d\n"     , pifi->fwdCapHeight );
    vPrint("    fwdXHeight             %d\n"     , pifi->fwdXHeight );
    vPrint("    fwdSubscriptXSize      %d\n"     , pifi->fwdSubscriptXSize );
    vPrint("    fwdSubscriptYSize      %d\n"     , pifi->fwdSubscriptYSize );
    vPrint("    fwdSubscriptXOffset    %d\n"     , pifi->fwdSubscriptXOffset );
    vPrint("    fwdSubscriptYOffset    %d\n"     , pifi->fwdSubscriptYOffset );
    vPrint("    fwdSuperscriptXSize    %d\n"     , pifi->fwdSuperscriptXSize );
    vPrint("    fwdSuperscriptYSize    %d\n"     , pifi->fwdSuperscriptYSize );
    vPrint("    fwdSuperscriptXOffset  %d\n"     , pifi->fwdSuperscriptXOffset);
    vPrint("    fwdSuperscriptYOffset  %d\n"     , pifi->fwdSuperscriptYOffset);
    vPrint("    fwdUnderscoreSize      %d\n"     , pifi->fwdUnderscoreSize );
    vPrint("    fwdUnderscorePosition  %d\n"     , pifi->fwdUnderscorePosition);
    vPrint("    fwdStrikeoutSize       %d\n"     , pifi->fwdStrikeoutSize );
    vPrint("    fwdStrikeoutPosition   %d\n"     , pifi->fwdStrikeoutPosition );
    vPrint("    chFirstChar            %-#4x\n"  , (int) (BYTE) pifi->chFirstChar );
    vPrint("    chLastChar             %-#4x\n"  , (int) (BYTE) pifi->chLastChar );
    vPrint("    chDefaultChar          %-#4x\n"  , (int) (BYTE) pifi->chDefaultChar );
    vPrint("    chBreakChar            %-#4x\n"  , (int) (BYTE) pifi->chBreakChar );
    vPrint("    wcFirsChar             %-#6x\n"  , pifi->wcFirstChar );
    vPrint("    wcLastChar             %-#6x\n"  , pifi->wcLastChar );
    vPrint("    wcDefaultChar          %-#6x\n"  , pifi->wcDefaultChar );
    vPrint("    wcBreakChar            %-#6x\n"  , pifi->wcBreakChar );
    vPrint("    ptlBaseline            {%d,%d}\n"  , pifi->ptlBaseline.x,
                                                   pifi->ptlBaseline.y );
    vPrint("    ptlAspect              {%d,%d}\n"  , pifi->ptlAspect.x,
                                                   pifi->ptlAspect.y );
    vPrint("    ptlCaret               {%d,%d}\n"  , pifi->ptlCaret.x,
                                                   pifi->ptlCaret.y );
    vPrint("    rclFontBox             {%d,%d,%d,%d}\n",pifi->rclFontBox.left,
                                                      pifi->rclFontBox.top,
                                                      pifi->rclFontBox.right,
                                                      pifi->rclFontBox.bottom );
    vPrint("    achVendId              \"%c%c%c%c\"\n",pifi->achVendId[0],
                                                   pifi->achVendId[1],
                                                   pifi->achVendId[2],
                                                   pifi->achVendId[3] );
    vPrint("    cKerningPairs          %d\n"     , pifi->cKerningPairs );
    vPrint("    ulPanoseCulture        %-#8lx\n" , pifi->ulPanoseCulture);
    vPrint(
           "    panose                 {%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x}\n"
                                                 , ppan->bFamilyType
                                                 , ppan->bSerifStyle
                                                 , ppan->bWeight
                                                 , ppan->bProportion
                                                 , ppan->bContrast
                                                 , ppan->bStrokeVariation
                                                 , ppan->bArmStyle
                                                 , ppan->bLetterform
                                                 , ppan->bMidline
                                                 , ppan->bXHeight );
    vCheckIFIMETRICS(pifi, vPrint);
}
#endif                /* PRINT_INFO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\glyphset\mkgly\mkgly.c ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation


Module Name:

    mkgly.c


Abstract:

    Construct FD_GLYPHSET structure in memory and dump it as binary
    data so that a printer driver can include it in its resource.
    The input data format is as following:

    <codepage>
    <multibyte code>\t<run length>
    <multibyte code>\t<run length>
    ...

    "codepage" is the codepage id to be used in multibyte to Unicode
    conversion.  "Multibyte code" and "run length" pairs describes
    which codepoints of multibyte codes are available on the device.

    mkgly will warn if there are multiple multibyte codepoints which
    are mapped to single Unicode codepoint.  The user is expected
    to fix this in the source, then re-run mkgly.

    Follogins are command line options recogized by mkgly:

    -e  Allow EUDC codepoints.  Default is not allow.
    -t  Output mapping table in text format also.
    -v  Verbose.

Author:

    08-Apr-1995 Sat 00:00:00 created -by- Takashi Matsuzawa (takashim)
    03-Mar-1996 Sat 00:00:00 updated -by- Takashi Matsuzawa (takashim)

Environment:

    GDI device drivers (printer)


Notes:


Revision History:



--*/

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <winddi.h>
#include <wingdi.h>

#define MIN_WCHAR_VALUE 0x0000
#define MAX_WCHAR_VALUE 0xfffd
#define INVALID_WCHAR_VALUE 0xffff
#define IS_COMMENT(c) \
    ((c) == ';' || (c) == '#' || (c) == '%' || (c) == '\n')
#define IS_EUDC_W(wc) \
    ((wc) >= 0xe000 && (wc) <= 0xf8ff)

WORD awMultiByteArray[0x10000];
BOOL bEudc, bTable, bGTTHandleBase;
INT iVerbose;

FD_GLYPHSET
*pvBuildGlyphSet(
    WORD *pwArray,
    DWORD dwcbByte)

/*++

Routine Description:

    Build FD_GLYPHSET data on memory.

Arguments:


Return Value:

    None.

Author:


    08-Apr-1995 Sat 00:00:00 created -by- Takashi Matsuzawa (takashim)


Revision History:


--*/

{
    DWORD        cGlyphs;           // count of glyph handles.
    DWORD        cRuns;             // count of runs within FD_GLYPHSET.
    DWORD        cbTotalMem;        // count of bytes needed for FD_GLYPHSET.
    HGLYPH      *phg;	            // pointer to HGLYPH's.
    FD_GLYPHSET *pGlyphSet;
    WCRUN       *pWCRun;
    BOOL bFirst;
    WCHAR wcChar, wcPrev, wcGTTHandle;
    DWORD cEudc;
    DWORD        cRunsGlyphs = 0;

    if (NULL == pwArray ||
        0 == dwcbByte    )
    {
        fprintf( stderr, "pvBuildGlyphSet: Invalid paremeters.\n" );
        return NULL;
    }

    if (dwcbByte < MAX_WCHAR_VALUE * 2)
    {
        fprintf( stderr, "pvBuildGlyphSet: Invalid paremeters.\n" );
        return NULL;
    }

    cRuns = 0;
    cGlyphs = 0;
    cEudc = 0;

    bFirst = TRUE;

    for ( wcChar = MIN_WCHAR_VALUE; wcChar <= MAX_WCHAR_VALUE; wcChar++)
    {
        if (pwArray[wcChar] == INVALID_WCHAR_VALUE)
            continue;

        // GDI can't handle the value which cRunsGlyphs over 256. sueyas

        if (bFirst || (wcChar - wcPrev) > 1 || cRunsGlyphs++ > 255)
        {
            if (bFirst)
                bFirst = FALSE;

            cRuns++;
            cRunsGlyphs = 1;
        }

        if (IS_EUDC_W(wcChar))
            cEudc++;

        cGlyphs++;
        wcPrev = wcChar;
    }

    if (iVerbose > 1) {
        fprintf( stderr, "cGlyphs = %d, cRuns = %d\n", cGlyphs, cRuns );
    }

    // Allocate memory to build the FD_GLYPHSET structure in.  this
    // include space for the FD_GLYPHSET structure itself, as well
    // as space for all the glyph handles.
    // DWORD bound it.

    cbTotalMem = sizeof(FD_GLYPHSET) - sizeof(WCRUN)
        + cRuns * sizeof(WCRUN) + cGlyphs * sizeof(HGLYPH);
    cbTotalMem = (cbTotalMem + 3) & ~3;

    if ((phg = (PVOID)GlobalAlloc( 0, cbTotalMem )) == NULL) {

        fprintf( stderr, "Error alloating memory\n" );
        return NULL;
    }

    // fill in the FD_GLYPHSET structure.

    pGlyphSet = (FD_GLYPHSET *)phg;
    pGlyphSet->cjThis
        = sizeof(FD_GLYPHSET) - sizeof(WCRUN)
        + cRuns * sizeof(WCRUN);  // size excluding HGLYPH array.
    pGlyphSet->flAccel = 0;		// no accelerators for us.
    pGlyphSet->cGlyphsSupported = cGlyphs;
    pGlyphSet->cRuns = cRuns;

    // Now set the phg pointer to the first WCRUN structure.

    (PBYTE)phg += (sizeof(FD_GLYPHSET) - sizeof(WCRUN));
    pWCRun = (WCRUN *)phg;
    (PBYTE)phg += sizeof(WCRUN) * cRuns;

    if (bTable || iVerbose > 0)
    {
        fprintf(stdout, "; Number of glyphs = %ld\n", cGlyphs );
        fprintf(stdout, "; Number of eudc = %ld\n", cEudc);
    }

    bFirst = TRUE;
    cRunsGlyphs = 0;

    for ( wcGTTHandle = 1,wcChar = MIN_WCHAR_VALUE;
          wcChar <= MAX_WCHAR_VALUE;
          wcChar++)
    {
        if (pwArray[wcChar] == INVALID_WCHAR_VALUE)
            continue;

        // GDI can't handle the value which cRunsGlyphs over 256. sueyas

        if (bFirst || (wcChar - wcPrev) > 1 || cRunsGlyphs++ > 255)
        {
            if (bFirst)
                bFirst = FALSE;
            else
                pWCRun++;

            pWCRun->wcLow = wcChar;
            pWCRun->cGlyphs = 0;
            pWCRun->phg = phg;
            cRunsGlyphs = 1;
        }

        // Glyph handle needs to be stored anyway.

        *phg++ = (HGLYPH)wcGTTHandle++;
        pWCRun->cGlyphs++;
        wcPrev = wcChar;

        if (bTable)
        {
            fprintf(stdout, "%x\t%x\n", wcChar, pwArray[wcChar]);
        }
    }

    // Debug output

    if (iVerbose > 1) {

        INT i, j;

        fprintf( stderr, "FD_GLYPHSET\n" );
        fprintf( stderr, "->cjThis  = %d (%d + %d)\n", pGlyphSet->cjThis,
            sizeof (FD_GLYPHSET) - sizeof (WCRUN),
            pGlyphSet->cjThis - sizeof (FD_GLYPHSET) + sizeof (WCRUN) );
        fprintf( stderr, "->fdAccel = %08lx\n", pGlyphSet->flAccel );
        fprintf( stderr, "->cGlyphsSupported = %d\n",
            pGlyphSet->cGlyphsSupported );
        fprintf( stderr, "->cRuns = %d\n", pGlyphSet->cRuns );

        if (iVerbose > 2)
        {
            for ( i = 0; i < (INT)pGlyphSet->cRuns; i++ ) {
                fprintf( stderr, "awcrun[%d]->wcLow = %04x\n",
                    i, pGlyphSet->awcrun[i].wcLow );
                fprintf( stderr, "awcrun[%d]->cGlyphs = %d\n",
                    i, pGlyphSet->awcrun[i].cGlyphs );
                //
                // This casting could chop a 64 pointer.
                // This tools is assumed to be used only on 32.
                // Also this is a verbose mode output to stdout. It won't
                // cause any serious problem.
                //
                fprintf( stderr, "awcrun[%d]->phg = %lx\n",
                    i, (LONG)pGlyphSet->awcrun[i].phg );
                if (iVerbose > 3)
                {
                    for ( j = 0; j < pGlyphSet->awcrun[i].cGlyphs; j++ )
                        fprintf( stderr, "%02x,",
                            pGlyphSet->awcrun[i].phg[j] );
                    fprintf( stderr, "\n" );
                } /* iVerbose > 3 */
            }
        } /* iVerbose > 2 */
    }

    return pGlyphSet;
}

BOOL
bWriteGlyphSet(
    FD_GLYPHSET *pGlyphSet,
    CHAR *pFileName )

/*++

Routine Description:

    Dump FD_GLYPHSET data into specified file.

Arguments:


Return Value:

    None.

Author:


    08-Apr-1995 Sat 00:00:00 created -by- Takashi Matsuzawa (takashim)


Revision History:


--*/

{
    HANDLE hFile;

    ULONG   iIndex;
    WCRUN  *pWcRun;
    HGLYPH *phg;
    DWORD dwTmp;
   
    if ((hFile = CreateFileA(
        pFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0))
            == INVALID_HANDLE_VALUE) {

        return FALSE;
    }

    // FD_GLYPHSET structure itself + WCRUN array

    if (!WriteFile( hFile, pGlyphSet, pGlyphSet->cjThis,
        &dwTmp, NULL )) {

        return FALSE;
    }

    // HGLYPH array

    if (!WriteFile( hFile, pGlyphSet->awcrun[0].phg,
            pGlyphSet->cGlyphsSupported * sizeof (HGLYPH),
        &dwTmp, NULL )) {

        return FALSE;
    }

    if (!CloseHandle( hFile )) {
        return FALSE;
    }

    return TRUE;
}

VOID
Usage()
{
    fprintf ( stderr, "\nUsage : mkgly [-etvv] outfile\n" );
    exit (EXIT_FAILURE);
}

BOOL
GetLine(
    BYTE *pjBuffer,
    INT cjSize)
{
    do
    {
        if(fgets(pjBuffer, cjSize, stdin) == NULL)
            return FALSE;
    } while (IS_COMMENT(*pjBuffer));

    return TRUE;
}

void __cdecl
main(
    int argc,
    char *argv[] )

/*++

Routine Description:

    Main routine for mkgly.exe

Arguments:

    Output filename.  Input data is read from standard input.

Return Value:

    None.

Author:


    08-Apr-1995 Sat 00:00:00 created -by- Takashi Matsuzawa (takashim)


Revision History:


--*/

{
    FD_GLYPHSET *pGlyphSet;
    CHAR *pFileName;
    INT iRet;
    INT iMbLen;
    CHAR *pStr;
    WORD wCodePage;
    WORD wMbChar, wMbRun, wMbChar2;
    WCHAR wcSysChar;
    BYTE ajMbChar[2];
    BYTE ajBuffer[256];

    bEudc = FALSE;
    bTable = FALSE;
    iVerbose = 0;
    pFileName = NULL;
    bGTTHandleBase = FALSE;

    while (--argc)
    {
        pStr = *(++argv);

        if (*pStr == '-')
        {
            for ( pStr++; *pStr; pStr++)
            {
                if (*pStr == 'e')
                    bEudc = TRUE;
                else if (*pStr == 't')
                    bTable = TRUE;
                else if (*pStr == 'v')
                    iVerbose++;
                else if (*pStr == 'g')
                    bGTTHandleBase = TRUE;
                else
                    Usage();
            }
         }
         else
         {
             pFileName = pStr;
             break;
         }
    }

    if (pFileName == NULL)
    {
        Usage();
    }

    // get the codepage id used for conversion

    if (!GetLine(ajBuffer, sizeof(ajBuffer)))
    {
        fprintf(stderr, "mkgly: unexpected end of file\n");
        exit(EXIT_FAILURE);
    }

    if (EOF == (iRet = sscanf(ajBuffer, "%hd", &wCodePage )))
    {
        fprintf(stderr, "mkgly: unexpected end of file.\n");
        exit(EXIT_FAILURE);
    }

    if (0 == iRet)
    {
        fprintf(stderr, "mkgly: unexpected string.\n");
        exit(EXIT_FAILURE);
    }


    if (iVerbose)
    {
        fprintf(stderr, "mkgly: wCodePage = %d\n", wCodePage);
    }

    memset(awMultiByteArray, 0xff, sizeof(awMultiByteArray));

    while (1)
    {
        if (!GetLine(ajBuffer, sizeof(ajBuffer)))
            break;
        if ( sscanf (ajBuffer, "%hx%hd", &wMbChar, &wMbRun ) != 2 )
        {
            fprintf(stderr, "mkgly: unrecognized line - \"%s\"\n", ajBuffer);
            exit(EXIT_FAILURE);
        }

        if (iVerbose > 1)
        {
            fprintf(stderr, "mkgly: wMbChar = %x, wMbrun = %d\n",
                wMbChar, wMbRun);
        }

        for (; wMbRun--; wMbChar++)
        {
            iMbLen = 0;

            if (wMbChar & 0xff00)
            {
                ajMbChar[iMbLen++] = (BYTE)((wMbChar >> 8) & 0xff);
            }
            ajMbChar[iMbLen++] = (BYTE)(wMbChar & 0xff);

            if (MultiByteToWideChar(wCodePage, MB_ERR_INVALID_CHARS,
                    ajMbChar, iMbLen, &wcSysChar, 1) != 1)
            {
                fprintf(stderr, "mkgly: MultiByteToWideChar failed - %d\n",
                    GetLastError());
                exit(EXIT_FAILURE);
            }

            if ((iMbLen = WideCharToMultiByte(wCodePage, 0,
                &wcSysChar, 1, ajMbChar, sizeof(ajMbChar), NULL, NULL)) == FALSE)
            {
                fprintf(stderr, "mkgly: WideCharToMultiByte failed - %d\n",
                    GetLastError());
                exit(EXIT_FAILURE);
            }

            if (iMbLen == 2)
                wMbChar2 = (ajMbChar[0] << 8) + ajMbChar[1];
            else
                wMbChar2 = ajMbChar[0];

            if (wMbChar != wMbChar2)
            {
                fprintf(stderr, "mkgly: round-trip not achieved %x => %x => %x\n",
                    wMbChar, wcSysChar, wMbChar2 );
            }

            if (IS_EUDC_W(wcSysChar))
            {
                if (iVerbose > 1)
                {
                    fprintf(stderr, "mkgly: eudc character %x => %x%s\n",
                        wcSysChar, wMbChar, (bEudc ? "" : " ignored."));
                }

                if (!bEudc)
                    continue;
            }

            if (awMultiByteArray[wcSysChar] != INVALID_WCHAR_VALUE)
            {
                fprintf(stderr, "mkgly: duplicate mapping %x => %x overwritten by => %x\n",
                    wcSysChar, awMultiByteArray[wcSysChar], wMbChar);
            }
            awMultiByteArray[wcSysChar] = wMbChar;
        }
    }

    if ((pGlyphSet = pvBuildGlyphSet( awMultiByteArray, sizeof(awMultiByteArray) )) == NULL) {
        fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
        return;
    }

    bWriteGlyphSet( pGlyphSet, pFileName );
    GlobalFree( pGlyphSet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\alpsres\alpsres.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

// NTRAID#NTBUG9-576656-2002/03/14-yasuho-: Possible buffer overrun

typedef struct {
    INT iPaperSizeID;
    LONG iLogicalPageWidth;
    LONG iLogicalPageHeight;
    INT iTopMargin;
    INT iLeftMargin;
    INT iRightMargin;
    BOOL bAsfOk;
    /* Add new attributes here */
} PAPERSIZE;

typedef struct {

    int  iCurrentResolution; // current resolution
    int  iPaperQuality;      // paper quality
    int  iPaperSize;         // paper size
    int  iPaperSource;       // paper source
    int  iTextQuality;       // photo or business graphics or character or grayscale
    int  iModel;             // MD-2000, MD-2010 or MD-4000
    int  iDither;            // DITHER_HIGH or DITHER_LOW
    BOOL fRequestColor;      // 1: user selected color 0: user selected mono
    INT iUnitScale;
    INT iEmulState; // Current emulation status.
    BOOL bXflip; // TRUE if mirror output mode
    int  y;

    PAPERSIZE *pPaperSize;

    WORD wRasterOffset[4]; // Temp. counter used for Y move.
    WORD wRasterCount; // # or raster lines left in logical page.

    INT PlaneColor[4]; // Color ID for each plane 
    INT iCompMode[4];  // Current compression mode.  (arranged by YoshitaO)

    BYTE *pData; // Pointer for allocated memory
    BYTE *pData2; // Scratch buffer
    BYTE *pRaster[4]; // Raster data buffer for each plane
    BYTE *pRasterC; // Cyan raster data (pointer to pRaster[x])
    BYTE *pRasterM; // Magenta ( " )
    BYTE *pRasterY; // Yellow ( " )
    BYTE *pRasterK; // Black ( " )

    HANDLE TempFile[4]; // Temp. file handles
    TCHAR TempName[4][MAX_PATH]; // Temp. file names

    BYTE KuroTBL[256];
    BYTE UcrTBL[256];
    BYTE YellowUcr;
    int  RGB_Rx;
    int  RGB_Ry;
    int  RGB_Gx;
    int  RGB_Gy;
    int  RGB_Bx;
    int  RGB_By;
    int  RGB_Wx;
    int  RGB_Wy;
    int  RGB_Cx;
    int  RGB_Cy;
    int  RGB_Mx;
    int  RGB_My;
    int  RGB_Yx;
    int  RGB_Yy;
    int  CMY_Cx;
    int  CMY_Cy;
    int  CMY_Mx;
    int  CMY_My;
    int  CMY_Yx;
    int  CMY_Yy;
    int  CMY_Rx;
    int  CMY_Ry;
    int  CMY_Gx;
    int  CMY_Gy;
    int  CMY_Bx;
    int  CMY_By;
    int  CMY_Wx;
    int  CMY_Wy;
    int  CMY_Cd;
    int  CMY_Md;
    int  CMY_Yd;
    int  CMY_Rd;
    int  CMY_Gd;
    int  CMY_Bd;
    int  RedAdj;
    int  RedStart;
    int  GreenAdj;
    int  GreenStart;
    int  BlueAdj;
    int  BlueStart;
    BYTE RedHosei[256];
    BYTE GreenHosei[256];
    BYTE BlueHosei[256];
} CURRENTSTATUS, *PCURRENTSTATUS;

#define CMDID_PSIZE_FIRST             1
#define CMDID_PSIZE_A4                1
#define CMDID_PSIZE_B5                2
#define CMDID_PSIZE_EXECTIVE          3
#define CMDID_PSIZE_LEGAL             4
#define CMDID_PSIZE_LETTER            5
#define CMDID_PSIZE_POSTCARD          6
#define CMDID_PSIZE_POSTCARD_DOUBLE   7
#define CMDID_PSIZE_PHOTO_COLOR_LABEL 17
#define CMDID_PSIZE_GLOSSY_LABEL      18
#define CMDID_PSIZE_CD_MASTER         19
#define CMDID_PSIZE_VD_PHOTO_POSTCARD 22

#define CMDID_RESOLUTION_1200_MONO   10
#define CMDID_RESOLUTION_600         11
#define CMDID_RESOLUTION_300         12

#define CMDID_COLORMODE_MONO         15
#define CMDID_COLORMODE_COLOR        16

#define CMDID_CURSOR_RELATIVE        20

#define CMDID_TEXTQUALITY_PHOTO      30
#define CMDID_TEXTQUALITY_GRAPHIC    31
#define CMDID_TEXTQUALITY_CHARACTER  32
#define CMDID_TEXTQUALITY_GRAY       33

#define CMDID_PAPERQUALITY_FIRST            40
#define CMDID_PAPERQUALITY_PPC_NORMAL       40
#define CMDID_PAPERQUALITY_PPC_FINE         41
#define CMDID_PAPERQUALITY_OHP_NORMAL       42
#define CMDID_PAPERQUALITY_OHP_FINE         43
#define CMDID_PAPERQUALITY_OHP_EXCL_NORMAL  44
#define CMDID_PAPERQUALITY_OHP_EXCL_FINE    45
#define CMDID_PAPERQUALITY_IRON_PPC         46
#define CMDID_PAPERQUALITY_IRON_OHP         47
#define CMDID_PAPERQUALITY_THICK            48
#define CMDID_PAPERQUALITY_POSTCARD         49
#define CMDID_PAPERQUALITY_HIGRADE          50
#define CMDID_PAPERQUALITY_BACKPRINTFILM    51
#define CMDID_PAPERQUALITY_LABECA_SHEET     52
#define CMDID_PAPERQUALITY_CD_MASTER        53
#define CMDID_PAPERQUALITY_DYE_SUB_PAPER    54
#define CMDID_PAPERQUALITY_DYE_SUB_LABEL    55
#define CMDID_PAPERQUALITY_GLOSSY_PAPER     56
#define CMDID_PAPERQUALITY_VD_PHOTO_FILM    57
#define CMDID_PAPERQUALITY_VD_PHOTO_CARD    58
#define CMDID_PAPERQUALITY_LAST             58
#define MAX_MEDIATYPES (CMDID_PAPERQUALITY_LAST - CMDID_PAPERQUALITY_FIRST + 1)

#define CMDID_BEGINDOC_FIRST      60
#define CMDID_BEGINDOC_MD2000     60
#define CMDID_BEGINDOC_MD2010     61
#define CMDID_BEGINDOC_MD5000     65
#define CMDID_BEGINPAGE           62
#define CMDID_ENDPAGE             63
#define CMDID_ENDDOC              64

#define CMDID_PAPERSOURCE_CSF     70
#define CMDID_PAPERSOURCE_MANUAL  71

#define CMDID_MIRROR_ON           80
#define CMDID_MIRROR_OFF          81

#define NONE                       0
#define YELLOW                     1
#define CYAN                       2
#define MAGENTA                    3
#define BLACK                      4

#define DPI1200                 1200
#define DPI600                   600
#define DPI300                   300

#define TEMP_NAME_PREFIX __TEXT("~AL")

// Macros to get current plane model.  We have following
// three types of the plane model:
//
//    K - 1 plane/composite, send order K.
//    MCY - 3 planes, send order M, C, Y.
//    YMC - 3 planes, send order Y, C, M.
//    CMYK - 4 planes, send order C, M, Y, K.
//

// NTRAID#NTBUG9-24281-2002/03/14-yasuho-: 
// large bitmap does not printed on 1200dpi.
// Do not use black plane (K) on the 1200dpi with color mode.
#define bPlaneSendOrderCMY(p) \
    ((p)->fRequestColor && (p)->iCurrentResolution == DPI1200)

#define bPlaneSendOrderMCY(p) \
    (((p)->iPaperQuality == CMDID_PAPERQUALITY_OHP_EXCL_NORMAL) || \
    ((p)->iPaperQuality == CMDID_PAPERQUALITY_OHP_EXCL_FINE))

#define bPlaneSendOrderYMC(p) \
    (((p)->iPaperQuality == CMDID_PAPERQUALITY_DYE_SUB_PAPER) || \
    ((p)->iPaperQuality == CMDID_PAPERQUALITY_DYE_SUB_LABEL) || \
    ((p)->iPaperQuality == CMDID_PAPERQUALITY_GLOSSY_PAPER) || \
    ((p)->iPaperQuality == CMDID_PAPERQUALITY_IRON_OHP))

#define bPlaneSendOrderCMYK(p) \
    (!bPlaneSendOrderCMY(p) && !bPlaneSendOrderMCY(p) && !bPlaneSendOrderYMC(p))


//
// Printer emulation state.  MD-xxxx printers have three major
// state and what kind of printer commands can be issued at a time
// will be decided by in which emulation state currently the printer
// is at.
//

#define EMUL_IDLE               0
#define EMUL_RGL                1
#define EMUL_DATA_TRANSFER      2

//
// Compression modes.  
//

#define COMP_NONE       0
#define COMP_TIFF4      1

//
// The following switch is to force use of black ribbon whenever
// the data to print is black.  Originally, the dither algprithm
// is designed so that this mode is only used with text objects
// in the docouemnt (graphics images are output by using composite
// blacks).
//
// Unfortunately in Unidriver <-> Minidriver model the data is
// passed to Minidriver after rendering.  This means that Minidriver
// cannot distinguish between text objects and graphics objects.
// We may have some degree of quality degrade, however it is better
// than the customers claiming the printer wastes his/her color
// ribbons.
//

#define BLACK_RIBBON_HACK 1

//
// We cache each plane data in a temporary file.  We can omit
// caching the first plane (so that the data is send to the printer
// immediately) by setting following flag to 0.
//

#define CACHE_FIRST_PLANE 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\alpsres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

// NTRAID#NTBUG9-576661-2002/03/14-yasuho-: Remove the dead codes

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE((DLLTEXT("OEMGetInfo(%s) entry.\n"), OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        VERBOSE((ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\n")));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        VERBOSE((ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n")));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE((DLLTEXT("OEMDevMode(), dwMode=%d\n"), dwMode));
//    VERBOSE((DLLTEXT("OEMDevMode(%s) entry.\n"), OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        VERBOSE((ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\n")));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        VERBOSE((ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n")));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            VERBOSE(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        VERBOSE((("\tcbSize = %d.\n"), pOEMDevModeParam->cbSize));
        VERBOSE((("\thPrinter = %#lx.\n"), pOEMDevModeParam->hPrinter));
        VERBOSE((("\thModule = %#lx.\n"), pOEMDevModeParam->hModule));
        VERBOSE((("\tpPublicDMIn = %#lx.\n"), pOEMDevModeParam->pPublicDMIn));
        VERBOSE((("\tpPublicDMOut = %#lx.\n"), pOEMDevModeParam->pPublicDMOut));
        VERBOSE((("\tpOEMDMIn = %#lx.\n"), pOEMDevModeParam->pOEMDMIn));
        VERBOSE((("\tpOEMDMOut = %#lx.\n"), pOEMDevModeParam->pOEMDMOut));
        VERBOSE((("\tcbBufSize = %d.\n"), pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\driverui\uni\unidrv.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    unidrv.c

Abstract:

    This file handles Unidrv specific UI options

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    12/17/96 -amandan-
        Created it.

--*/

#include "precomp.h"
#include <ntverp.h>


DWORD DwCollectFontCart(PUIDATA, PWSTR, DWORD);
PWSTR PwstrGetFontCartSelections(HANDLE, HANDLE, PDWORD);
INT   IGetCurrentFontCartIndex(POPTTYPE, PWSTR);
PWSTR PwstrGetFontCartName( PCOMMONINFO, PUIINFO, FONTCART *, DWORD, HANDLE);
DWORD DwGetExternalCartridges(HANDLE, HANDLE, PWSTR *);


DWORD
_DwEnumPersonalities(
    PCOMMONINFO pci,
    PWSTR       pwstrOutput
    )

/*++

Routine Description:

    Enumerate the list of supported printer description languages

Arguments:

    pci - Points to common printer info
    pwstrOutput - Points to output buffer

Return Value:

    Number of personalities supported
    GDI_ERROR if there is an error

--*/

{

    PWSTR pwstrPersonality = PGetReadOnlyDisplayName(pci,
                                          pci->pUIInfo->loPersonality);

    if (pwstrPersonality == NULL)
    {
        SetLastError(ERROR_NOT_SUPPORTED);
        return GDI_ERROR;
    }

    if (pwstrOutput)
        CopyString(pwstrOutput, pwstrPersonality, CCHLANGNAME);

    return 1;
}



DWORD
_DwGetFontCap(
    PUIINFO     pUIInfo
    )

/*++

Routine Description:

    Get the font capability for DrvDeviceCapabilites (DC_TRUETYPE)

Arguments:

    pUIInfo - Pointer to UIINFO

Return Value:

    DWORD describing the TrueType cap for Unidrv

--*/

{
    DWORD dwRet;

    if (pUIInfo->dwFlags & FLAG_FONT_DOWNLOADABLE)
        dwRet = (DWORD) (DCTT_BITMAP | DCTT_DOWNLOAD);
    else
        dwRet = DCTT_BITMAP;

    return dwRet;
}

DWORD
_DwGetOrientationAngle(
    PUIINFO     pUIInfo,
    PDEVMODE    pdm
    )

/*++

Routine Description:

    Get the orienation angle requested by DrvDeviceCapabilities(DC_ORIENTATION)

Arguments:

    pUIInfo - Pointer to UIINFO
    pdm  - Pointer to DEVMODE

Return Value:

    The angle (90 or 270 or landscape rotation)

Note:

--*/

{
    DWORD        dwRet = GDI_ERROR;
    DWORD        dwIndex;
    PORIENTATION pOrientation;
    PFEATURE     pFeature;

    if (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_ORIENTATION))
    {
        //
        // Currently Unidrv only allows at most 2 options for feature "Orientation".
        // So when we see the first non-Portrait option, that's the Landscape option
        // we can use to get the orientation angle.
        //

        pOrientation = (PORIENTATION)PGetIndexedOption(pUIInfo, pFeature, 0);

        for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++, pOrientation++)
        {
            if (pOrientation->dwRotationAngle == ROTATE_90)
            {
                return 90;
            }
            else if (pOrientation->dwRotationAngle == ROTATE_270)
            {
                return 270;
            }
        }

        //
        // If we are here, it means the printer doesn't support Landscape
        // orientation, so we return angle 0.
        //

        return 0;
    }

    return dwRet;
}

BOOL
_BPackOrientationItem(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack the orientation feature for Doc property sheet

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    return BPackItemPrinterFeature(
                pUiData,
                GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_ORIENTATION),
                TVITEM_LEVEL1,
                DMPUB_ORIENTATION,
                (ULONG_PTR)ORIENTATION_ITEM,
                HELP_INDEX_ORIENTATION);
}


BOOL
BPackHalftoneFeature(
    IN OUT PUIDATA  pUiData
    )
/*++

Routine Description:

    Pack the halfone feature

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

Note:

--*/

{
    return BPackItemPrinterFeature(
                pUiData,
                GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_HALFTONING),
                TVITEM_LEVEL1,
                DMPUB_NONE,
                (ULONG_PTR)HALFTONING_ITEM,
                HELP_INDEX_HALFTONING_TYPE);
}

BOOL
BPackColorModeFeature(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack Color mode feature

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    return BPackItemPrinterFeature(
                pUiData,
                GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_COLORMODE),
                TVITEM_LEVEL1,
                DMPUB_NONE,
                (ULONG_PTR)COLORMODE_ITEM,
                HELP_INDEX_COLORMODE_TYPE);
}


BOOL
BPackQualityFeature(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack Quality Macro feature

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
#ifndef WINNT_40
    INT i, iSelection, iParamCount = 0;
    PUIINFO pUIInfo = pUiData->ci.pUIInfo;
    POPTPARAM   pParam;
    PEXTCHKBOX  pExtCheckbox;
    INT         Quality[MAX_QUALITY_SETTINGS];

    memset(Quality, -1, sizeof(INT)*MAX_QUALITY_SETTINGS);

    if (pUIInfo->liDraftQualitySettings != END_OF_LIST )
    {
        Quality[QS_DRAFT] = QS_DRAFT;
        iParamCount++;
    }

    if ( pUIInfo->liBetterQualitySettings != END_OF_LIST )
    {
        Quality[QS_BETTER] = QS_BETTER;
        iParamCount++;
    }

    if ( pUIInfo->liBestQualitySettings != END_OF_LIST)
    {
        Quality[QS_BEST] = QS_BEST;
        iParamCount++;
    }

    if (iParamCount < MIN_QUALITY_SETTINGS)
    {
        return TRUE;
    }

    if (pUiData->pOptItem)
    {
        pParam = PFillOutOptType(pUiData->pOptType,
                                 TVOT_3STATES,
                                 MAX_QUALITY_SETTINGS,
                                 pUiData->ci.hHeap);

        if (pParam == NULL)
            return FALSE;

        for (i = QS_BEST; i < QS_BEST + MAX_QUALITY_SETTINGS; i ++)
        {
            pParam->cbSize = sizeof(OPTPARAM);
            pParam->pData = (PWSTR)ULongToPtr(IDS_QUALITY_FIRST + i);
            pParam->IconID = IDI_USE_DEFAULT;
            pParam++;

        }

        // Look for the current selection in the private devmode
        //

        if (pUiData->ci.pdm->dmDitherType & DM_DITHERTYPE &&
            pUiData->ci.pdm->dmDitherType >= QUALITY_MACRO_START &&
            pUiData->ci.pdm->dmDitherType < QUALITY_MACRO_END)
        {
            iSelection = pUiData->ci.pdm->dmDitherType;
        }
        else if (Quality[pUiData->ci.pdmPrivate->iQuality] < 0)
            iSelection = pUiData->ci.pUIInfo->defaultQuality;
        else
            iSelection = pUiData->ci.pdmPrivate->iQuality;


        //
        // Fill out OPTITEM, OPTTYPE, and OPTPARAM structures
        //

        pExtCheckbox = HEAPALLOC(pUiData->ci.hHeap, sizeof(EXTCHKBOX));

        if (pExtCheckbox == NULL)
        {
            ERR(("Memory allocation failed\n"));
            return FALSE;
        }

        pExtCheckbox->cbSize = sizeof(EXTCHKBOX);
        pExtCheckbox->Flags = ECBF_CHECKNAME_ONLY;
        pExtCheckbox->pTitle = (PWSTR) IDS_QUALITY_CUSTOM;
        pExtCheckbox->pSeparator = NULL;
        pExtCheckbox->pCheckedName = (PWSTR) IDS_QUALITY_CUSTOM;
        pExtCheckbox->IconID = IDI_CPSUI_GENERIC_ITEM;

        pUiData->pOptItem->pExtChkBox = pExtCheckbox;

        if (pUiData->ci.pdmPrivate->dwFlags & DXF_CUSTOM_QUALITY)
            pUiData->pOptItem->Flags |= OPTIF_ECB_CHECKED;

        FILLOPTITEM(pUiData->pOptItem,
                    pUiData->pOptType,
                    ULongToPtr(IDS_QUALITY_SETTINGS),
                    IntToPtr(iSelection),
                    TVITEM_LEVEL1,
                    DMPUB_QUALITY,
                    QUALITY_SETTINGS_ITEM,
                    HELP_INDEX_QUALITY_SETTINGS);


           pUiData->pOptItem++;
           pUiData->pOptType++;

    }

    pUiData->dwOptItem++;
    pUiData->dwOptType++;

#endif // !WINNT_40

    return TRUE;

}



BOOL
BPackSoftFontFeature(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack Quality Macro feature

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    PUIINFO     pUIInfo = pUiData->ci.pUIInfo;
    PGPDDRIVERINFO  pDriverInfo;
    POPTPARAM   pParam;
    PWSTR       pwstr = NULL;
    DWORD       dwType, dwSize, dwFontFormat;
    OEMFONTINSTPARAM fip;

    pDriverInfo = OFFSET_TO_POINTER(pUiData->ci.pInfoHeader,
                                    pUiData->ci.pInfoHeader->loDriverOffset);

    ASSERT(pDriverInfo != NULL);

    //
    // If the model doesn't support download softfont. we don't add the feature
    //

    dwFontFormat = pDriverInfo->Globals.fontformat;

    if (!(dwFontFormat == FF_HPPCL || dwFontFormat == FF_HPPCL_OUTLINE || dwFontFormat == FF_HPPCL_RES))
        return TRUE;

    //
    // If there is an exe based font installer, we don't add
    // this feature
    //

    dwSize = 0;

    if (GetPrinterData(pUiData->ci.hPrinter, REGVAL_EXEFONTINSTALLER, &dwType, NULL, dwSize, &dwSize) == ERROR_MORE_DATA)
        return TRUE;

    if (pUiData->pOptItem)
    {
        PFN_OEMFontInstallerDlgProc pDlgProc = NULL;

        pParam = PFillOutOptType(pUiData->pOptType,
                                 TVOT_PUSHBUTTON,
                                 1,
                                 pUiData->ci.hHeap);

        if (pParam == NULL)
            return FALSE;

        //
        // Get the String for Soft Fonts
        //

        FOREACH_OEMPLUGIN_LOOP(&pUiData->ci)

            memset(&fip, 0, sizeof(OEMFONTINSTPARAM));
            fip.cbSize = sizeof(OEMFONTINSTPARAM);
            fip.hPrinter = pUiData->ci.hPrinter;
            fip.hModule = ghInstance;
            fip.hHeap = pUiData->ci.hHeap;


            if (HAS_COM_INTERFACE(pOemEntry))
            {
                if (HComOEMFontInstallerDlgProc(pOemEntry,
                                                NULL,
                                                0,
                                                0,
                                                (LPARAM)&fip) == E_NOTIMPL)
                    continue;

                pwstr = fip.pFontInstallerName;
                break;
            }
            else
            {

                if (pDlgProc = GET_OEM_ENTRYPOINT(pOemEntry, OEMFontInstallerDlgProc))
                {
                    (*pDlgProc)(NULL, 0, 0, (LPARAM)&fip);

                    pwstr = fip.pFontInstallerName;

                    break;
                }

            }

        END_OEMPLUGIN_LOOP

        //
        // If that didn't work out, put our string
        //

        if (!pwstr)
        {
            //
            // LoadString's 4th parameter is the max. number of characters to load,
            // so make sure we allocate enough bytes here.
            //

            if (!(pwstr = HEAPALLOC(pUiData->ci.hHeap, MAX_DISPLAY_NAME * sizeof(WCHAR))))
            {
                return FALSE;
            }

            if (!LoadString(ghInstance, IDS_PP_SOFTFONTS, pwstr, MAX_DISPLAY_NAME))
            {
                WARNING(("Soft Font string not found in Unidrv\n"));
                StringCchCopyW(pwstr, MAX_DISPLAY_NAME, L"Soft Fonts");
            }
        }

        pParam->cbSize = sizeof(OPTPARAM);
        pParam->Style = PUSHBUTTON_TYPE_CALLBACK;

        //
        // Fill out OPTITEM, OPTTYPE, and OPTPARAM structures
        //

        FILLOPTITEM(pUiData->pOptItem,
                    pUiData->pOptType,
                    pwstr,
                    NULL,
                    TVITEM_LEVEL1,
                    DMPUB_NONE,
                    SOFTFONT_SETTINGS_ITEM,
                    HELP_INDEX_SOFTFONT_SETTINGS);


           pUiData->pOptItem++;
           pUiData->pOptType++;

    }

    pUiData->dwOptItem++;
    pUiData->dwOptType++;

    return TRUE;

}



BOOL
_BPackDocumentOptions(
    IN OUT PUIDATA  pUiData
    )
/*++

Routine Description:

    Pack Unidrv specific options such are enabling Print text as graphics etc

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

Note:

--*/
{
    static CONST WORD ItemInfoTxtAsGrx[] =
    {
        IDS_TEXT_ASGRX, TVITEM_LEVEL1, DMPUB_NONE,
        TEXT_ASGRX_ITEM, HELP_INDEX_TEXTASGRX,
        2, TVOT_2STATES,
        IDS_ENABLED, IDI_CPSUI_ON,
        IDS_DISABLED, IDI_CPSUI_OFF,
        ITEM_INFO_SIGNATURE
    };

    PUNIDRVEXTRA pdmPrivate;
    DWORD        dwSelTxt;
    BOOL         bDisplayTxtAsGrx;
    GPDDRIVERINFO *pDriverInfo;

    pDriverInfo = OFFSET_TO_POINTER(pUiData->ci.pInfoHeader,
                                    pUiData->ci.pInfoHeader->loDriverOffset);

    ASSERT(pDriverInfo != NULL);

    bDisplayTxtAsGrx = ((pUiData->ci.pUIInfo->dwFlags &
                        (FLAG_FONT_DEVICE | FLAG_FONT_DOWNLOADABLE)) &&
                        (pDriverInfo->Globals.printertype != PT_TTY));

    pdmPrivate = pUiData->ci.pdmPrivate;
    dwSelTxt  = (pdmPrivate->dwFlags & DXF_TEXTASGRAPHICS) ? 1 : 0;

    return (BPackColorModeFeature(pUiData) &&
            BPackQualityFeature(pUiData)   &&
            BPackHalftoneFeature(pUiData) &&
            (bDisplayTxtAsGrx ?
             BPackOptItemTemplate(pUiData, ItemInfoTxtAsGrx, dwSelTxt, NULL):TRUE));
}


VOID
_VUnpackDocumentOptions(
    POPTITEM    pOptItem,
    PDEVMODE    pdm
    )

/*++

Routine Description:

    Extract Unidrv devmode information from an OPTITEM
    Stored it back into Unidrv devmode.

Arguments:

    pOptItem - Pointer to an array of OPTITEMs
    pdm - Pointer to a DEVMODE structure

Return Value:

    None

--*/
{
    PUNIDRVEXTRA pdmPrivate;

    pdmPrivate = (PUNIDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdm);

    switch (GETUSERDATAITEM(pOptItem->UserData))
    {
        case TEXT_ASGRX_ITEM:
            if (pOptItem->Sel == 1)
                pdmPrivate->dwFlags |= DXF_TEXTASGRAPHICS;
            else
                pdmPrivate->dwFlags &= ~DXF_TEXTASGRAPHICS;
            break;


        case QUALITY_SETTINGS_ITEM:
            if (pOptItem->Flags & OPTIF_ECB_CHECKED)
            {
                pdmPrivate->dwFlags |= DXF_CUSTOM_QUALITY;
                pdm->dmDitherType = QUALITY_MACRO_CUSTOM;
            }
            else
            {
                pdmPrivate->dwFlags &= ~DXF_CUSTOM_QUALITY;
                pdm->dmDitherType = QUALITY_MACRO_START + pOptItem->Sel;
            }

            pdm->dmFields |= DM_DITHERTYPE;
            pdmPrivate->iQuality = pOptItem->Sel;

    }
}

BOOL
BPackFontCartsOptions(
    IN OUT PUIDATA  pUiData
    )
/*++

Routine Description:

    Pack Font Cartridge options

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{

    PUIINFO pUIInfo = pUiData->ci.pUIInfo;
    DWORD   dwFontSlot, dwFontCartsAvailable, dwExtCartsAvailable, dwSize = 0;
    INT     iSelection = -1;
    POPTPARAM pParam;
    PWSTR   pwstrCurrentSelection, pwstrEndSelection, pwstrExtCartNames;


    VERBOSE(("\nUniPackFontCartsOptions:pUIInfo->dwCartridgeSlotCount = %d\n",pUIInfo->dwCartridgeSlotCount));

    if (pUIInfo->dwCartridgeSlotCount == 0)
        return TRUE;

    VPackOptItemGroupHeader(pUiData, IDS_CPSUI_INSTFONTCART,
        IDI_CPSUI_FONTCARTHDR, HELP_INDEX_FONTSLOT_TYPE);


    if (pUiData->pOptItem)
    {
        PFONTCART pFontCarts;

        //
        // Get the current selections for the slots from registry
        // Read the list of font cartridge selections out of registry
        //

        pwstrCurrentSelection = PwstrGetFontCartSelections(pUiData->ci.hPrinter, pUiData->ci.hHeap, &dwSize);
        pwstrEndSelection = pwstrCurrentSelection + (dwSize/2);


        pFontCarts = OFFSET_TO_POINTER( pUIInfo->pubResourceData,
                                        pUIInfo->CartridgeSlot.loOffset );

        ASSERT(pFontCarts);

        //
        // Save the slot count and OPTITEM for slots for unpacking later
        //

        pUiData->dwFontCart = pUIInfo->dwCartridgeSlotCount;
        pUiData->pFontCart = pUiData->pOptItem;

        for (dwFontSlot = 0; dwFontSlot < pUIInfo->dwCartridgeSlotCount; dwFontSlot++)
        {
            //
            // We'll distinguish between driver built in font cartridges and external
            // font cartridges. dwFontCartsAvailable refers to the count of built
            // in driver cartridges. To this we need to add any external cartridges.
            //

            dwFontCartsAvailable = pUIInfo->CartridgeSlot.dwCount;
            dwExtCartsAvailable = DwGetExternalCartridges(pUiData->ci.hPrinter, pUiData->ci.hHeap, &pwstrExtCartNames);

            //
            // Build a list of OPTPARAM
            //

            pParam = PFillOutOptType(pUiData->pOptType,
                                    TVOT_LISTBOX,
                                    (WORD)(dwFontCartsAvailable + dwExtCartsAvailable),
                                    pUiData->ci.hHeap);

            pUiData->pOptType->Style |= OTS_LBCB_INCL_ITEM_NONE;

            if (pParam == NULL)
                return FALSE;


            while (dwFontCartsAvailable)
            {
                pParam->cbSize = sizeof(OPTPARAM);
                pParam->pData = PwstrGetFontCartName(
                                    &pUiData->ci,
                                    pUIInfo,
                                    pFontCarts,
                                    pUIInfo->CartridgeSlot.dwCount - dwFontCartsAvailable,
                                    pUiData->ci.hHeap);

                pParam->IconID = IDI_CPSUI_FONTCART;
                dwFontCartsAvailable--;
                pParam++;
            }

            while (dwExtCartsAvailable)
            {
                pParam->cbSize = sizeof(OPTPARAM);
                pParam->pData = pwstrExtCartNames;

                pParam->IconID = IDI_CPSUI_FONTCART;
                dwExtCartsAvailable--;

                pwstrExtCartNames += wcslen(pwstrExtCartNames);
                pwstrExtCartNames++;

                pParam++;
            }

            //
            // Look for the current selection in the font cart table
            //

            if (pwstrCurrentSelection)
                iSelection = IGetCurrentFontCartIndex(pUiData->pOptType,
                                                      pwstrCurrentSelection);

            //
            // Fill out OPTITEM, OPTTYPE, and OPTPARAM structures
            //

            FILLOPTITEM(pUiData->pOptItem,
                        pUiData->pOptType,
                        ULongToPtr(IDS_CPSUI_SLOT1 + dwFontSlot),
                        IntToPtr(iSelection),
                        TVITEM_LEVEL2,
                        DMPUB_NONE,
                        (ULONG_PTR)FONTSLOT_ITEM,
                        HELP_INDEX_FONTSLOT_TYPE);


           if (pwstrCurrentSelection && pwstrCurrentSelection < pwstrEndSelection)
           {
                pwstrCurrentSelection += wcslen(pwstrCurrentSelection);
                pwstrCurrentSelection++;
           }

           pUiData->pOptItem++;
           pUiData->pOptType++;

        }
    }

    pUiData->dwOptItem += pUIInfo->dwCartridgeSlotCount;
    pUiData->dwOptType += pUIInfo->dwCartridgeSlotCount;


    return TRUE;
}


BOOL
BPackPageProtection(
    IN OUT PUIDATA  pUiData
    )
/*++

Routine Description:

    Pack the page protection feature

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{

    return BPackItemPrinterFeature(
                pUiData,
                GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_PAGEPROTECTION),
                TVITEM_LEVEL1,
                DMPUB_NONE,
                (ULONG_PTR)PAGE_PROTECT_ITEM,
                HELP_INDEX_PAGE_PROTECT);
}

BOOL
BPackHalftoneSetup(
    IN OUT PUIDATA  pUiData
    )
/*++

Routine Description:

    Do nothing, serves as common stubs

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    // DCR - not implemented
    return TRUE;
}


BOOL
_BPackPrinterOptions(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack driver-specific options (printer-sticky)

Arguments:

    pUiData - Points to a UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    return BPackHalftoneSetup(pUiData) &&
           BPackFontCartsOptions(pUiData) &&
           BPackPageProtection(pUiData) &&
           BPackSoftFontFeature(pUiData);
}


PWSTR
PwstrGetFontCartSelections(
    HANDLE   hPrinter,
    HANDLE   hHeap,
    PDWORD   pdwSize
    )
/*++

Routine Description:

    Read the font cart selections for the slots from the registry

Arguments:

    hPrinter - Handle to printer instance
    hHeap - Handle to UI heap
    pdwSize - Pointer to DWORD to hold the size of the MULTI_SZ

Return Value:

    Pointer to a MULTI-SZ containing the selections for the slots

--*/
{
    PWSTR   pwstrData, pFontCartSelections = NULL;
    DWORD   dwSize;

    pwstrData = PtstrGetFontCart(hPrinter, &dwSize);

    if (pwstrData == NULL || !BVerifyMultiSZ(pwstrData, dwSize))
    {
        MemFree(pwstrData);
        return NULL;
    }

    if (pFontCartSelections = HEAPALLOC(hHeap, dwSize))
    {
        CopyMemory(pFontCartSelections, pwstrData, dwSize);
    }

    MemFree(pwstrData);

    if (pdwSize)
        *pdwSize = dwSize;

    return pFontCartSelections;
}


PWSTR
PwstrGetFontCartName(
    PCOMMONINFO pci,
    PUIINFO     pUIInfo,
    FONTCART    *pFontCarts,
    DWORD       dwIndex,
    HANDLE      hHeap
    )
/*++

Routine Description:

    Get the font cart name associated with the index.

Arguments:

    pci - Pointer to COMMONINFO
    pUIInfo - Pointer to UIINFO
    pFontCarts  - Pointer to array of FONTCART for the slot
    dwIndex - Index of font cart
    hHeap - Handle to Heap

Return Value:

    Pointer to the Font Cart Name

--*/
{
    DWORD       dwLen;
    PWSTR       pwstrFontCartName;
    WCHAR       awchBuf[MAX_DISPLAY_NAME];

    pFontCarts += dwIndex;

    pwstrFontCartName = (PWSTR)OFFSET_TO_POINTER(pUIInfo->pubResourceData,
                                pFontCarts->strCartName.loOffset);

    if (!pwstrFontCartName)
    {
        if (! BPrepareForLoadingResource(pci, TRUE))
            return NULL;


        dwLen = ILOADSTRING(pci, pFontCarts->dwRCCartNameID,
                           awchBuf, MAX_DISPLAY_NAME);


        pwstrFontCartName = HEAPALLOC(pci->hHeap, (dwLen+1) * sizeof(WCHAR));

        if (pwstrFontCartName == NULL)
        {
            ERR(("Memory allocation failed\n"));
            return NULL;
        }

        //
        // Copy the string to allocated memory and
        // return a pointer to it.
        //

        CopyMemory(pwstrFontCartName, awchBuf, dwLen*sizeof(WCHAR));
        return pwstrFontCartName;


    }
    else
        return pwstrFontCartName;
}


INT
IGetCurrentFontCartIndex(
    POPTTYPE    pOptType,
    PWSTR       pCurrentSelection
    )
/*++

Routine Description:

    Find the matching font cart

Arguments:

    pOptType - Pointer to OPTTYPE containing the font carts options
    pCurrentSelection - The name of the cartridge selection for the slot

Return Value:

    Index to the options list

--*/
{

    INT iIndex;
    POPTPARAM pParam = pOptType->pOptParam;

    for (iIndex = 0 ; iIndex < pOptType->Count; iIndex++)
    {
        if (wcscmp(pCurrentSelection, pParam->pData) == EQUAL_STRING)
            return iIndex;

        pParam++;

    }
    return -1;
}


DWORD
DwCollectFontCart(
    PUIDATA     pUiData,
    PWSTR       pwstrTable,
    DWORD       cbSize
    )

/*++

Routine Description:

    Collect Font Cart assignment information

Arguments:

    pUiData - Pointer to our UIDATA structure
    pwstrTable - Pointer to memory buffer for storing the table
                 (NULL if the caller is only interested in the table size)
    cbSize - size (in bytes) of the pwstrTable memory buffer
             (0 if pwstrTable is NULL)

Return Value:

    Size of the table bytes. 0 if there is an error.

--*/

{
    DWORD dwChars = 0;
    LONG lLength = 0;
    DWORD dwIndex;
    POPTPARAM pOptParam;
    DWORD dwOptItem = pUiData->dwFontCart;
    POPTITEM pOptItem = pUiData->pFontCart;

    for (dwIndex=0; dwIndex < dwOptItem; dwIndex++, pOptItem++)
    {

        if (pOptItem->Flags & OPTIF_DISABLED)
            continue;

        //
        // Get the Font Cart name for each slot (dwIndex)
        //

        if (pOptItem->Sel == -1)
        {
            lLength = wcslen(L"Not Available") + 1;

        }
        else
        {
            pOptParam = pOptItem->pOptType->pOptParam + pOptItem->Sel;
            lLength = wcslen(pOptParam->pData) + 1;
        }

        dwChars += lLength;

        if (pwstrTable != NULL)
        {
            if (pOptItem->Sel == -1)
                StringCchCopyW(pwstrTable, cbSize / sizeof(WCHAR), L"Not Available");
            else
                StringCchCopyW(pwstrTable, cbSize / sizeof(WCHAR), pOptParam->pData);

            pwstrTable += lLength;
        }
    }

    //
    // Append a NUL character at the end of the table
    //

    dwChars++;

    if (pwstrTable != NULL)
        *pwstrTable = NUL;

    //
    // Return the table size in bytes
    //

    return (dwChars * sizeof(WCHAR));
}


BOOL
BUnPackFontCart(
    PUIDATA     pUiData
    )
/*++

Routine Description:

    Save the Font Cart selection into registry

Arguments:

    pUiData - Pointer to UIDATA

Return Value:

    TRUE for success and FALSE for failure

Note:

--*/

{
    PFN_OEMUpdateExternalFonts pUpdateProc = NULL;
    PWSTR                      pwstrTable;
    DWORD                      dwTableSize;
    BOOL                       bHasOEMUpdateFn = FALSE;

    //
    // Figure out how much memory we need to store
    // the Font Cart table
    //

    dwTableSize = DwCollectFontCart(pUiData, NULL, 0);

    if (dwTableSize == 0 || (pwstrTable = MemAllocZ(dwTableSize)) == NULL)
    {
        ERR(("DwCollectFontCart/MemAlloc"));
        return FALSE;
    }

    //
    // Assemble the font cartridge table to be saved in registry
    //

    if (dwTableSize != DwCollectFontCart(pUiData, pwstrTable, dwTableSize))
    {
        ERR(("CollectFontCart"));
        MemFree(pwstrTable);
        return FALSE;
    }

    //
    // Save the font cart information to registry
    //

    if (! BSaveFontCart(pUiData->ci.hPrinter, pwstrTable))
    {
        ERR(("SaveFontCart"));
    }

    //
    // Inform font installer (if present) about font cartridge selection change
    //

    FOREACH_OEMPLUGIN_LOOP(&pUiData->ci)

        if (HAS_COM_INTERFACE(pOemEntry))
        {
            if (HComOEMUpdateExternalFonts(pOemEntry,
                                           pUiData->ci.hPrinter,
                                           pUiData->ci.hHeap,
                                           pwstrTable) == E_NOTIMPL)
                continue;

            bHasOEMUpdateFn = TRUE;
            break;

        }
        else
        {
            pUpdateProc = GET_OEM_ENTRYPOINT(pOemEntry, OEMUpdateExternalFonts);

            if (pUpdateProc)
            {
                bHasOEMUpdateFn = TRUE;
                pUpdateProc(pUiData->ci.hPrinter, pUiData->ci.hHeap, pwstrTable);
                break;
            }

        }

    END_OEMPLUGIN_LOOP

    if (!bHasOEMUpdateFn)
    {
        //
        // No OEM Dll wants to handle this, we'll handle it ourselves
        //

        BUpdateExternalFonts(pUiData->ci.hPrinter, pUiData->ci.hHeap, pwstrTable);
    }

    MemFree(pwstrTable);

    return TRUE;
}


DWORD
DwGetExternalCartridges(
    IN  HANDLE hPrinter,
    IN  HANDLE hHeap,
    OUT PWSTR  *ppwstrExtCartNames
    )
{
    PWSTR pwstrData;
    DWORD dwSize;

    *ppwstrExtCartNames = NULL;

    pwstrData = PtstrGetPrinterDataString(hPrinter, REGVAL_EXTFONTCART, &dwSize);

    if (pwstrData == NULL || !BVerifyMultiSZ(pwstrData, dwSize))
    {
        MemFree(pwstrData);
        return 0;
    }

    if (*ppwstrExtCartNames = HEAPALLOC(hHeap, dwSize))
    {
        CopyMemory(*ppwstrExtCartNames, pwstrData, dwSize);
    }

    MemFree(pwstrData);

    return DwCountStringsInMultiSZ(*ppwstrExtCartNames);
}


BOOL
BUnpackHalftoneSetup(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Unpack halftone setup information

Arguments:

    pUiData - Points to a UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    // DCR - not implemented
    return TRUE;
}


BOOL
_BUnpackPrinterOptions(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Unpack driver-specific options (printer-sticky)

Arguments:

    pUiData - Points to a UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    return BUnpackHalftoneSetup(pUiData) &&
           BUnPackFontCart(pUiData);
}



//
// Data structures and functions for enumerating printer device fonts
//

typedef struct _ENUMDEVFONT {

    INT     iBufSize;
    INT     iCurSize;
    PWSTR   pwstrBuf;

} ENUMDEVFONT, *PENUMDEVFONT;

INT CALLBACK
EnumDevFontProc(
    ENUMLOGFONT    *pelf,
    NEWTEXTMETRIC  *pntm,
    INT             FontType,
    LPARAM          lParam
    )

{
    PENUMDEVFONT    pEnumData;
    PWSTR           pFamilyName;
    INT             iSize;

    //
    // We only care about printer device fonts.
    //

    if (!(FontType & DEVICE_FONTTYPE))
        return 1;

    //
    // For app compatibility, GDI sets FontType to be DEVICE_FONTTYPE
    // even for PS OpenType fonts and Type1 fonts. So we also need to
    // filter them out using Win2K+ only GDI flags.
    //

    #ifndef WINNT_40

    if ((pntm->ntmFlags & NTM_PS_OPENTYPE) ||
        (pntm->ntmFlags & NTM_TYPE1))
        return 1;

    #endif // WINNT_40

    pEnumData = (PENUMDEVFONT) lParam;
    pFamilyName = pelf->elfLogFont.lfFaceName;

    iSize = SIZE_OF_STRING(pFamilyName);
    pEnumData->iCurSize += iSize;

    if (pEnumData->pwstrBuf == NULL)
    {
        //
        // Calculating output buffer size only
        //
    }
    else if (pEnumData->iCurSize >= pEnumData->iBufSize)
    {
        //
        // Output buffer is too small
        //

        return 0;
    }
    else
    {
        CopyMemory(pEnumData->pwstrBuf, pFamilyName, iSize);
        pEnumData->pwstrBuf = (PWSTR) ((PBYTE) pEnumData->pwstrBuf + iSize);
    }

    return 1;
}


INT
_IListDevFontNames(
    HDC     hdc,
    PWSTR   pwstrBuf,
    INT     iSize
    )

{
    INT         iOldMode;
    ENUMDEVFONT EnumData;


    EnumData.iBufSize = iSize;
    EnumData.pwstrBuf = pwstrBuf;
    EnumData.iCurSize = 0;

    //
    // Enumerate device fonts
    //

    iOldMode = SetGraphicsMode(hdc, GM_ADVANCED);

    if (! EnumFontFamilies(
                    hdc,
                    NULL,
                    (FONTENUMPROC) EnumDevFontProc,
                    (LPARAM) &EnumData))
    {
        return 0;
    }

    SetGraphicsMode(hdc, iOldMode);

    //
    // Remember the list of device font names is in MULTI_SZ format;
    // Take the last NUL terminator into consideration
    //

    EnumData.iCurSize += sizeof(WCHAR);

    if (EnumData.pwstrBuf)
        *(EnumData.pwstrBuf) = NUL;

    return EnumData.iCurSize;
}


//
// Determine whether the printer supports stapling
//

BOOL
_BSupportStapling(
    PCOMMONINFO pci
    )

{
    DWORD   dwIndex;

    return (PGetNamedFeature(pci->pUIInfo, "Stapling", &dwIndex) &&
            !_BFeatureDisabled(pci, dwIndex, GID_UNKNOWN));
}



INT_PTR CALLBACK
_AboutDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Dlg Proc for About button

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    PUIDATA pUiData;
    PWSTR   pGpdFilename;
    PGPDDRIVERINFO  pDriverInfo;

    switch (message)
    {
    case WM_INITDIALOG:

        //
        // Initialize the About dialog box
        //

        pUiData = (PUIDATA) lParam;
        ASSERT(VALIDUIDATA(pUiData));

        #ifdef WINNT_40

        SetDlgItemTextA(hDlg, IDC_WINNT_VER, "Version " VER_54DRIVERVERSION_STR);

        #else

        SetDlgItemTextA(hDlg, IDC_WINNT_VER, "Version " VER_PRODUCTVERSION_STR);

        #endif // WINNT_40

        SetDlgItemText(hDlg, IDC_MODELNAME, pUiData->ci.pDriverInfo3->pName);

        pDriverInfo = OFFSET_TO_POINTER(pUiData->ci.pInfoHeader, pUiData->ci.pInfoHeader->loDriverOffset);

        ASSERT(pDriverInfo != NULL);

        if (pDriverInfo->Globals.pwstrGPDFileName)
            SetDlgItemText(hDlg, IDC_GPD_FILENAME, pDriverInfo->Globals.pwstrGPDFileName);
        else
            SetDlgItemText(hDlg, IDC_GPD_FILENAME, L"Not Available");

        if (pDriverInfo->Globals.pwstrGPDFileVersion)
            SetDlgItemTextA(hDlg, IDC_GPD_FILEVER, (PSTR)pDriverInfo->Globals.pwstrGPDFileVersion);
        else
            SetDlgItemText(hDlg, IDC_GPD_FILEVER,  L"Not Available");

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
        case IDCANCEL:

            EndDialog(hDlg, LOWORD(wParam));
            return TRUE;
        }
        break;
    }

    return FALSE;
}

BOOL
BFoundInDisabledList(
    IN  PGPDDRIVERINFO  pDriverInfo,
    IN  POPTION         pOption,
    IN  DWORD           dwFeatureID
    )

/*++

Routine Description:

    Determines whether the feature indicated by dwFeatureID is found in the
    pOption->liDisabledFeatureList.

Arguments:


Return Value:

    TRUE for disabled feature, otherwise FALSE

--*/

{
    PLISTNODE       pListNode;

    pListNode = LISTNODEPTR(pDriverInfo, pOption->liDisabledFeatures);

    while (pListNode)
    {
        if ( ((PQUALNAME)(&pListNode->dwData))->wFeatureID == (WORD)dwFeatureID)
        {
            return TRUE;
        }

        pListNode = LISTNODEPTR(pDriverInfo, pListNode->dwNextItem);
    }

    return FALSE;
}


BOOL
_BFeatureDisabled(
    IN  PCOMMONINFO pci,
    IN  DWORD       dwFeatureIndex,
    IN  WORD        wGID
    )

/*++

Routine Description:

    Determines whether the feature indicated by wGID is disabled.
    For example, a device can support collate but only if the hard disk is
    installed.

Arguments:

    pci     - Points to COMMONINFO
    wGID    - GID_XXX

Return Value:

    TRUE for disabled feature, otherwise FALSE

--*/

{

    DWORD           dwFeatureID, dwIndex, dwFeatureCount;
    PFEATURE        pFeatureList, pFeature = NULL;
    PGPDDRIVERINFO  pDriverInfo;
    PUIINFO         pUIInfo = pci->pUIInfo;
    POPTSELECT      pCombinedOptions = pci->pCombinedOptions;
    BYTE            ubCurOptIndex, ubNext;
    POPTION         pOption;

    pDriverInfo = OFFSET_TO_POINTER(pUIInfo->pInfoHeader,
                                    pUIInfo->pInfoHeader->loDriverOffset);

    dwFeatureCount = pUIInfo->dwDocumentFeatures + pUIInfo->dwPrinterFeatures;

    if (pDriverInfo == NULL)
        return FALSE;

    if (dwFeatureIndex != 0xFFFFFFFF &&
        wGID == GID_UNKNOWN &&
        dwFeatureIndex <= dwFeatureCount)
    {
        dwFeatureID = dwFeatureIndex;
    }
    else
    {
        ASSERT(wGID < MAX_GID);

        if (wGID < MAX_GID)
        {
            pFeature = GET_PREDEFINED_FEATURE(pUIInfo, wGID);
        }
        else
            pFeature = NULL;

        if (pFeature == NULL)
            return FALSE;

        dwFeatureID =  GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);
    }

    if (!(pFeatureList = OFFSET_TO_POINTER(pUIInfo->pInfoHeader, pUIInfo->loFeatureList)))
        return FALSE;

    for (dwIndex = 0;
         dwIndex < dwFeatureCount;
         dwIndex++, pFeatureList++)
    {
        //
        // Currently we only allow *DisabledFeatures to be used with PRINTER_PROPERTY features. This
        // is because the UI code won't be able to refresh the document settings correctly if you have
        // *DisabledFeatures on non-printer-sticky features.
        //
        // Example: if you put *DisabledFeatures: LIST(Collate) into a PaperSize option, then in the
        // document settings select that PaperSize option, you won't see EMF features refreshed
        // correctly unless you close and reopen the UI. This is because in cpcbDocumentPropertyCallback,
        // we only call VUpdateEmfFeatureItems when EMF-related feature settings are changed. Changing
        // PaperSize option won't trigger the calling of VUpdateEmfFeatureItems, therefore no refresh.
        //

        if (pFeatureList->dwFeatureType != FEATURETYPE_PRINTERPROPERTY)
           continue;

        ubNext = (BYTE)dwIndex;
        while (1)
        {
            ubCurOptIndex = pCombinedOptions[ubNext].ubCurOptIndex;
            pOption = PGetIndexedOption(pUIInfo, pFeatureList, ubCurOptIndex == OPTION_INDEX_ANY ? 0 : ubCurOptIndex);

            if (pOption && BFoundInDisabledList(pDriverInfo, pOption, dwFeatureID))
                return TRUE;

            if ((ubNext = pCombinedOptions[ubNext].ubNext) == NULL_OPTSELECT)
                break;
         }
    }

    return FALSE;
}

PTSTR
PtstrUniGetDefaultTTSubstTable(
    IN  PCOMMONINFO pci,
    IN  PUIINFO     pUIInfo
    )

/*++

Routine Description:

    Get the default font substitution table for Unidrv

Arguments:

    pci     - Points to COMMONINFO
    pUIInfo - Points to UIINFO

Return Value:

   Pointer to the font substituion table , otherwise NULL

--*/

{

#define     DEFAULT_FONTSUB_SIZE        (1024 * sizeof(WCHAR))

    PTTFONTSUBTABLE pDefaultTTFontSub, pCopyTTFS;
    PTSTR           ptstrTable, ptstrTableOrg;
    DWORD           dwCount, dwEntrySize, dwTTFontLen, dwDevFontLen, dwBuffSize, dwAvail;
    PWSTR           pTTFontName, pDevFontName;

    if (pUIInfo->dwFontSubCount)
    {
        if (!(pDefaultTTFontSub = OFFSET_TO_POINTER(pUIInfo->pubResourceData,
                                    pUIInfo->loFontSubstTable)))
        {
            ERR(("Default TT font sub table from GPD Parser is NULL \n"));
            return NULL;
        }

        dwBuffSize = sizeof(TTFONTSUBTABLE) * pUIInfo->dwFontSubCount;

        if (!(pCopyTTFS = HEAPALLOC(pci->hHeap,  dwBuffSize)))
        {
            ERR(("Fatal: unable to alloc requested memory: %d bytes.\n", dwBuffSize));
            return NULL;
        }

        //
        // Make a writable copy of the font substitution table
        // if arDevFontName.dwCount is zero,
        // move rcID into arDevFontName.loOffset like other
        // snapshot entries and set highbit.
        //

        CopyMemory((PBYTE)pCopyTTFS,
                   (PBYTE)pDefaultTTFontSub,
                   dwBuffSize);

        for (dwCount = 0 ; dwCount < pUIInfo->dwFontSubCount ; dwCount++)
        {
            if(!pCopyTTFS[dwCount].arTTFontName.dwCount)
            {
                pCopyTTFS[dwCount].arTTFontName.loOffset =
                    pCopyTTFS[dwCount].dwRcTTFontNameID | GET_RESOURCE_FROM_DLL ;
            }
            if(!pCopyTTFS[dwCount].arDevFontName.dwCount)
            {
                pCopyTTFS[dwCount].arDevFontName.loOffset =
                    pCopyTTFS[dwCount].dwRcDevFontNameID | GET_RESOURCE_FROM_DLL ;
            }
        }

        dwBuffSize = dwAvail = DEFAULT_FONTSUB_SIZE;

        if (!(ptstrTableOrg = ptstrTable = MemAlloc(dwBuffSize)))
        {
            ERR(("Fatal: unable to alloc requested memory: %d bytes.\n", dwBuffSize));
            return NULL;
        }

        for (dwCount = 0; dwCount < pUIInfo->dwFontSubCount; dwCount++, pCopyTTFS ++)
        {
            pTTFontName = PGetReadOnlyDisplayName( pci,
                                          pCopyTTFS->arTTFontName.loOffset );

            pDevFontName = PGetReadOnlyDisplayName( pci,
                                          pCopyTTFS->arDevFontName.loOffset );

            if (pTTFontName == NULL || pDevFontName == NULL)
                continue;

            dwTTFontLen = wcslen(pTTFontName) + 1;

            dwDevFontLen = wcslen( pDevFontName) + 1 ;

            dwEntrySize = (dwDevFontLen + dwTTFontLen + 1) * sizeof(WCHAR);

            if (dwAvail < dwEntrySize)
            {
                DWORD dwCurrOffset;

                //
                // Reallocate the Buffer
                //

                dwAvail = max(dwEntrySize, DEFAULT_FONTSUB_SIZE);
                dwBuffSize += dwAvail;
                dwCurrOffset =  (DWORD)(ptstrTable - ptstrTableOrg);

                if (!(ptstrTable = MemRealloc(ptstrTableOrg, dwCurrOffset * sizeof(WCHAR), dwBuffSize)))
                {
                       ERR(("Fatal: unable to realloac requested memory: %d bytes.\n", dwBuffSize));
                       MemFree(ptstrTableOrg);
                       return NULL;
                }

                ptstrTableOrg = ptstrTable;
                ptstrTable +=  dwCurrOffset;
                dwAvail = dwBuffSize - dwCurrOffset*sizeof(WCHAR);
            }

            dwAvail -= dwEntrySize;

            CopyString(ptstrTable, pTTFontName, dwTTFontLen);
            ptstrTable += dwTTFontLen;

            CopyString(ptstrTable, pDevFontName, dwDevFontLen);
            ptstrTable += dwDevFontLen;

        }
        *ptstrTable = NUL;
    }
    else
    {
        ptstrTableOrg = NULL;
    }

    return ptstrTableOrg;
}




BOOL
BOkToChangeColorToMono(
    IN  PCOMMONINFO pci,
    IN  PDEVMODE    pdm,
    OUT SHORT *     pPrintQuality,
    OUT SHORT *     pYResolution
    )

/*++

Routine Description:

    This function determines if the resolution can be left
    unchanged when switching from Color to Mono printing.
    This is implemented for switching between color and monochrome
    mode within a job for performance

Arguments:

    pci     - Points to COMMONINFO
    pdm     - Points to DEVMODE
    pPrintQuality, pYResolution - To contain the output resolution
    pUIInfo - Points to UIINFO

Return Value:

    Returns TRUE  if the same resolution used to print Color
    can also be used to print Mono.  If true, this resolution
    is placed in pptRes  for the spooler to use in place of
    negative values of print quality.
    otherwise return FALSE and pptRes is not initialized.


--*/

{

    PFEATURE   pFeatureColor, pFeatureRes;
    DWORD      dwColorModeIndex, dwCurOption, dwResIndex, dwNewResOption, dwCurResOption ;
    SHORT      sXres, sYres;
    POPTION    pColorMode;
    PCOLORMODEEX pColorModeEx;
    PRESOLUTION pResOption;
    PDEVMODE    pDevmode, pTmpDevmode;


    if ((pFeatureColor =  GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_COLORMODE))== NULL)
        return FALSE;

    dwColorModeIndex = GET_INDEX_FROM_FEATURE(pci->pUIInfo, pFeatureColor);

    pColorMode = (POPTION)PGetIndexedOption(pci->pUIInfo,
                                            pFeatureColor,
                                            pci->pCombinedOptions[dwColorModeIndex].ubCurOptIndex);

    if (pColorMode == NULL)
        return FALSE;

    pColorModeEx = OFFSET_TO_POINTER(
                        pci->pInfoHeader,
                        pColorMode->loRenderOffset);

    if(pColorModeEx == NULL || pColorModeEx->bColor == FALSE)
        return(FALSE);

    if ((pFeatureRes = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_RESOLUTION)) == NULL)
        return FALSE;

    dwResIndex = GET_INDEX_FROM_FEATURE(pci->pUIInfo, pFeatureRes);

    dwCurResOption = pci->pCombinedOptions[dwResIndex].ubCurOptIndex ;
    pResOption = (PRESOLUTION)PGetIndexedOption(pci->pUIInfo,
                                                pFeatureRes,
                                                dwCurResOption);
    if (pResOption == NULL)
        return FALSE;

    sXres = (SHORT)pResOption->iXdpi;
    sYres = (SHORT)pResOption->iYdpi;

    //
    // Make a copy of the public devmode
    //

    if ((pDevmode = MemAllocZ(sizeof(DEVMODE))) == NULL)
        return FALSE;

    CopyMemory(pDevmode, pdm, sizeof(DEVMODE));

    pDevmode->dmPrintQuality = sXres ;
    pDevmode->dmYResolution = sYres ;

    //
    //  Now ask to print in mono
    //

    pDevmode->dmColor = DMCOLOR_MONOCHROME ;

    //
    // This is a kludge to fix up the devmode in pci. I hope it works!
    //

    pTmpDevmode = pci->pdm;
    pci->pdm = pDevmode;

    VFixOptionsArrayWithDevmode(pci);

    (VOID)ResolveUIConflicts( pci->pRawData,
                                                pci->pCombinedOptions,
                                                MAX_COMBINED_OPTIONS,
                                                MODE_DOCANDPRINTER_STICKY);

    pci->pdm = pTmpDevmode;


    dwNewResOption = pci->pCombinedOptions[dwResIndex].ubCurOptIndex ;

    if(dwNewResOption != dwCurResOption)
    {
        //  gotta compare resolutions
        if ((pResOption = (PRESOLUTION)PGetIndexedOption(pci->pUIInfo,
                                                        pFeatureRes,
                                                        dwNewResOption)) == NULL)
        {
            MemFree(pDevmode);
            return FALSE;
        }

        if ((sXres != pResOption->iXdpi)  ||  (sYres != pResOption->iYdpi))
        {
            MemFree(pDevmode);
            return(FALSE);
        }
        else // Same dpi for Color and Monochrome.
        {
            //
            // For predefined negative user defined resolution don't replace
            // the values in dmPrintQuality and dmYResolution. This is needed
            // because user defined print quality may map to multiple settings
            // like Ink density.
            //
            if ( (pdm->dmFields & DM_PRINTQUALITY) &&
                 (pdm->dmPrintQuality >= DMRES_HIGH) &&
                 (pdm->dmPrintQuality <= DMRES_DRAFT) )
            {
                sXres = pdm->dmPrintQuality;
                sYres = pdm->dmYResolution;

            }

        }

    }
    else // Same resolution for Color and Monochrome.
    {
        //
        // For negative user defined resolution don't replace the values in
        // in dmPrintQuality and dmYResolution. This is needed because user
        // defined print quality may map to multiple settings like Ink density.
        //
        if ( (pdm->dmFields & DM_PRINTQUALITY) &&
             (pdm->dmPrintQuality < DMRES_HIGH) )
        {
            sXres = pdm->dmPrintQuality;
            sYres = pdm->dmYResolution;

        }

    }

    dwCurOption = pci->pCombinedOptions[dwColorModeIndex].ubCurOptIndex ;

    if ((pColorMode = (POPTION)PGetIndexedOption(pci->pUIInfo, pFeatureColor,dwCurOption)) == NULL ||
        (pColorModeEx = OFFSET_TO_POINTER(pci->pInfoHeader, pColorMode->loRenderOffset)) == NULL ||
        (pColorModeEx->bColor))
    {
        MemFree(pDevmode);
        return FALSE;
    }

    if (pPrintQuality)
        *pPrintQuality =  sXres ;

    if (pYResolution)
        *pYResolution = sYres ;

    //
    // Free the devmode.
    //
    if (pDevmode)
        MemFree(pDevmode);

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\glyphset\mkgtt\mkgtt.c ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation


Module Name:

    mkgtt.c


Abstract:

    Construct UNI_GLYPHSETDATA structure in memory and dump it as binary
    data so that a printer driver can include it in its resource.
    The input data format is as following:

    <codepage>
    <multibyte code>\t<run length>
    <multibyte code>\t<run length>
    ...

    "codepage" is the codepage id to be used in multibyte to Unicode
    conversion.  "Multibyte code" and "run length" pairs describes
    which codepoints of multibyte codes are available on the device.

    mkgtt will warn if there are multiple multibyte codepoints which
    are mapped to single Unicode codepoint.  The user is expected
    to fix this in the source, then re-run mkgtt.

    Follogins are command line options recogized by mkgtt:

    -e  Allow EUDC codepoints.  Default is not allow.
    -t  Output mapping table in text format also.
    -v  Verbose.

Author:

    08-Apr-1995 Sat 00:00:00 created -by- Takashi Matsuzawa (takashim)
    03-Mar-1996 Sat 00:00:00 updated -by- Takashi Matsuzawa (takashim)
    02-Feb-1997 Sat 00:00:00 ported  -by- Eigo Shimizu (eigos)

Environment:

    GDI device drivers (printer)


Notes:


Revision History:



--*/

#include <lib.h>
#include <win30def.h>
#include <uni16gpc.h>
#include <uni16res.h>
#include <fmnewfm.h>
#include <fmnewgly.h>
#include <unilib.h>
#include <fd_glyph.h>
#include <unirc.h>
#include <mkgtt.h>

//
// Macros
//

#define MIN_WCHAR_VALUE 0x0001
#define MAX_WCHAR_VALUE 0xfffd
#define INVALID_WCHAR_VALUE 0xffff
#define IS_COMMENT(c) \
    ((c) == ';' || (c) == '#' || (c) == '%' || (c) == '\n')
#define IS_EUDC_W(wc) \
    ((wc) >= 0xe000 && (wc) <= 0xf8ff)
#define SWAPW(x)                    (((WORD)(x)<<8) | ((WORD)(x)>>8))


//
// Globals
//

WORD awMultiByteArray[0x10000];
BOOL bEudc, bTable;
INT  iVerbose;

//
// Forward declaration
//

VOID
VPrintGTT(
     IN PUNI_GLYPHSETDATA pGly);

BOOL
BCreateSubFileName(
    IN CHAR *pDestFileName,
    IN CHAR *pSrcFileName,
    IN CHAR cAdd);

//
// Functions.
//

PUNI_GLYPHSETDATA
PBuildGTT(
    SHORT sMode,
    WORD  wCodepage,
    WORD  *pwArray,
    DWORD dwcbSize)

/*++

Routine Description:

    Build UNI_GLYPHSETDATA on memory.

Arguments:


Return Value:

    None.

Author:



Revision History:


--*/

{
    DWORD        cGlyphs;           // count of glyph handles.
    DWORD        cRuns;             // count of runs within FD_GLYPHSET.
    DWORD        cbTotalMem;        // count of bytes needed for FD_GLYPHSET.
    DWORD        cEudc;
    DWORD        cRunsGlyphs = 0;
    WCHAR        wcChar, wcPrev, wcIndex, wcCommand;
    PBYTE        pBase;             // pointer to HGLYPH's.
    BYTE         aubChar[2];
    BOOL         bFirst, bInRun;

    PUNI_GLYPHSETDATA pGlyphSet;
    PUNI_CODEPAGEINFO pCodePageInfo;
    PGLYPHRUN         pGlyphRun, pGlyphRunTmp;
    PMAPTABLE         pMapTable;
    PTRANSDATA        pTrans;

    TRANSTAB         *lpctt;
    HMODULE           hModule;
    HRSRC             hRes;

    if (NULL == pwArray ||
        0 == dwcbSize    )
    {
        fprintf( stderr, "Invalid parameters\n" );
        return NULL;
    }

    if (dwcbSize < MAX_WCHAR_VALUE * 2)
    {
        fprintf( stderr, "Invalid parameters\n" );
        return NULL;
    }

    DBGMESSAGE(("sMode = %d, wCodepage = %d\n", sMode, wCodepage));

    cRuns = 0;
    cGlyphs = 0;
    cEudc = 0;

    bFirst = TRUE;

    for ( wcChar = MIN_WCHAR_VALUE; wcChar <= MAX_WCHAR_VALUE; wcChar++)
    {
        if (pwArray[wcChar] == INVALID_WCHAR_VALUE)
            continue;

        // GDI can't handle the value which cRunsGlyphs over 256. sueyas

        if (bFirst || (wcChar - wcPrev) > 1 || cRunsGlyphs++ > 255)
        {
            if (bFirst)
                bFirst = FALSE;

            cRuns++;
            cRunsGlyphs = 1;
        }

        if (IS_EUDC_W(wcChar))
            cEudc++;

        cGlyphs++;
        wcPrev = wcChar;
    }

    DBGMESSAGE(("cGlyphs = %d, cRuns = %d\n", cGlyphs, cRuns));

    // Allocate memory to build the UNI_GLYPHSET structure in.  this
    // include space for the FD_GLYPHSET structure itself, as well
    // as space for all the glyph handles.
    // DWORD bound it.

    cbTotalMem = sizeof(UNI_GLYPHSETDATA) +
                 sizeof(UNI_CODEPAGEINFO) +
                 cRuns * sizeof(GLYPHRUN) +
                 sizeof(MAPTABLE) +
                 (cGlyphs - 1) * sizeof(TRANSDATA);

    cbTotalMem = (cbTotalMem + 3) & ~3;

    if ((pBase = (PVOID)GlobalAlloc( 0, cbTotalMem )) == NULL) {

        fprintf( stderr, "Error alloating memory\n" );
        return NULL;
    }

    //
    // fill in the UNI_GLYPHSETDATA structure.
    //

    DBGMESSAGE(("fill in the UNI_GLYPHSETDATA structure.\n"));

    pGlyphSet                   = (PUNI_GLYPHSETDATA) pBase;
    pGlyphSet->dwSize           = cbTotalMem;
    pGlyphSet->dwVersion        = UNI_GLYPHSETDATA_VERSION_1_0;
    pGlyphSet->dwFlags          = 0;
    pGlyphSet->lPredefinedID    = CC_NOPRECNV;
    pGlyphSet->dwGlyphCount     = cGlyphs;
    pGlyphSet->dwRunCount       = cRuns;
    pGlyphSet->loRunOffset      = sizeof(UNI_GLYPHSETDATA);
    pGlyphSet->dwCodePageCount  = 1;
    pGlyphSet->loCodePageOffset = sizeof(UNI_GLYPHSETDATA) +
                                  sizeof(GLYPHRUN) * cRuns;
    pGlyphSet->loMapTableOffset = sizeof(UNI_GLYPHSETDATA) +
                                  sizeof(GLYPHRUN) * cRuns +
                                  sizeof(UNI_CODEPAGEINFO) ;

    pGlyphRun                   = (PGLYPHRUN)((PBYTE)pBase +
                                          pGlyphSet->loRunOffset);
    pCodePageInfo               = (PUNI_CODEPAGEINFO)((PBYTE)pBase +
                                          pGlyphSet->loCodePageOffset);
    pMapTable                   = (PMAPTABLE)((PBYTE)pBase +
                                          pGlyphSet->loMapTableOffset);
    pTrans                      = pMapTable->Trans;

    pCodePageInfo->dwCodePage                 = wCodepage;
    pCodePageInfo->SelectSymbolSet.dwCount    = 0;
    pCodePageInfo->SelectSymbolSet.loOffset   = (ULONG)NULL;
    pCodePageInfo->UnSelectSymbolSet.dwCount  = 0;
    pCodePageInfo->UnSelectSymbolSet.loOffset = (ULONG)NULL;

    DBGMESSAGE(("Load resource\n"));

    hModule = GetModuleHandle(TEXT("mkgtt.exe"));
    DBGMESSAGE(("hModule=0x%xl\n", (LONG)hModule));

    switch (sMode)
    {
    case CC_JIS:
    case CC_JIS_ANK:
        hRes = FindResource(hModule, TEXT("CC_JIS"), TEXT("RC_TRANSTAB"));
        DBGMESSAGE(("hRes=0x%lx\n", (LONG)hRes));
        lpctt = (TRANSTAB*)LoadResource(hModule, hRes);

        if (lpctt == NULL)
        {
            return FALSE;
        }
        break;

    case CC_ISC:
        hRes = FindResource(hModule, TEXT("CC_ISC"), TEXT("RC_TRANSTAB"));
        DBGMESSAGE(("hRes=0x%lx\n", (LONG)hRes));
        lpctt = (TRANSTAB*)LoadResource(hModule, hRes);

        if (lpctt == NULL)
        {
            return FALSE;
        }
        break;

    case CC_NS86:
        hRes = FindResource(hModule, TEXT("CC_NS86"), TEXT("RC_TRANSTAB"));
        DBGMESSAGE(("hRes=0x%lx\n", (LONG)hRes));
        lpctt = (TRANSTAB*)LoadResource(hModule, hRes);

        if (lpctt == NULL)
        {
            return FALSE;
        }
        break;

    case CC_TCA:
        hRes = FindResource(hModule, TEXT("CC_ISC"), TEXT("RC_TRANSTAB"));
        DBGMESSAGE(("hRes=0x%lx\n", (LONG)hRes));
        lpctt = (TRANSTAB*)LoadResource(hModule, hRes);

        if (lpctt == NULL)
        {
            return FALSE;
        }
        break;

    default:
        lpctt = NULL;

    }

    DBGMESSAGE(("Start to create GLYPHRUN.\n"));

    bInRun = FALSE;
    cRuns = 1;

    for ( wcIndex = 1, wcChar = MIN_WCHAR_VALUE;
          wcChar <= MAX_WCHAR_VALUE;
          wcChar++)
    {
        if (pwArray[wcChar] == INVALID_WCHAR_VALUE)
        {
            if (bInRun)
            {
                bInRun = FALSE;
                pGlyphRun ++;
                cRuns ++;
            }
        }
        else
        {
            //
            // GDI can't handle the value which cRunsGlyphs over 256. sueyas
            //

            if (!bInRun)
            {
                bInRun = TRUE;
                pGlyphRun->wcLow = wcChar;
                pGlyphRun->wGlyphCount = 1;
            }
            else
            {
                pGlyphRun->wGlyphCount++;
                if (pGlyphRun->wGlyphCount > 255)
                {
                    bInRun = FALSE;
                    pGlyphRun ++;
                    cRuns ++;
                }
            }

            pMapTable->Trans[wcIndex - 1].ubCodePageID = 0;
            switch (sMode)
            {
            case CC_JIS:
                if (HIBYTE(pwArray[wcChar]))
                {
                    aubChar[0] = HIBYTE(pwArray[wcChar]);
                    aubChar[1] = LOBYTE(pwArray[wcChar]);
                    SJisToJis(lpctt, (LPSTR)aubChar, (LPSTR)&wcCommand);
                    pMapTable->Trans[wcIndex - 1].ubType = MTYPE_DOUBLE |
                                                           MTYPE_PAIRED;
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[0] =
                                                    LOBYTE(wcCommand);
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[1] =
                                                    HIBYTE(wcCommand);
                }
                else
                {
                    AnkToJis(lpctt, (LPSTR)&pwArray[wcChar], (LPSTR)&wcCommand);
                    pMapTable->Trans[wcIndex - 1].ubType = MTYPE_SINGLE |
                                                           MTYPE_PAIRED;
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[0] =
                                                    LOBYTE(wcCommand);
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[1] =
                                                    HIBYTE(wcCommand);
                }
                DBGMESSAGE(("wcSJis=0x%4x, wcJis=0x%x\n", pwArray[wcChar], wcCommand));
                break;

            case CC_JIS_ANK:
                if (HIBYTE(pwArray[wcChar]))
                {
                    aubChar[0] = HIBYTE(pwArray[wcChar]);
                    aubChar[1] = LOBYTE(pwArray[wcChar]);
                    SJisToJis(lpctt, (LPSTR)aubChar, (LPSTR)&wcCommand);
                    pMapTable->Trans[wcIndex - 1].ubType = MTYPE_DOUBLE |
                                                           MTYPE_PAIRED;
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[0] =
                                                    LOBYTE(wcCommand);
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[1] =
                                                    HIBYTE(wcCommand);
                }
                else
                {
                    wcCommand = pwArray[wcChar];
                    pMapTable->Trans[wcIndex - 1].ubType = MTYPE_SINGLE |
                                                           MTYPE_PAIRED;
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[0] = 0;
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[1] =
                                                    LOBYTE(wcCommand);
                }
                DBGMESSAGE(("wcSJis=0x%4x, wcJis=0x%x\n", pwArray[wcChar], wcCommand));
                break;

            case CC_ISC:
                if (HIBYTE(pwArray[wcChar]))
                {
                    aubChar[0] = HIBYTE(pwArray[wcChar]);
                    aubChar[1] = LOBYTE(pwArray[wcChar]);
                    KSCToISC(lpctt, (LPSTR)aubChar, (LPSTR)&wcCommand);
                }
                else
                {
                    wcCommand = pwArray[wcChar];
                }
                goto SetTransData;

            case CC_NS86:
                if (HIBYTE(pwArray[wcChar]))
                {
                    aubChar[0] = HIBYTE(pwArray[wcChar]);
                    aubChar[1] = LOBYTE(pwArray[wcChar]);
                    Big5ToNS86(lpctt, (LPSTR)aubChar, (LPSTR)&wcCommand);
                }
                else
                {
                    wcCommand = pwArray[wcChar];
                }
                goto SetTransData;

            case CC_TCA:
                if (HIBYTE(pwArray[wcChar]))
                {
                    aubChar[0] = HIBYTE(pwArray[wcChar]);
                    aubChar[1] = LOBYTE(pwArray[wcChar]);
                    Big5ToTCA(lpctt, (LPSTR)aubChar, (LPSTR)&wcCommand);
                }
                else
                {
                    wcCommand = pwArray[wcChar];
                }
                goto SetTransData;

            default:
                wcCommand = pwArray[wcChar];

            SetTransData:
                if (!HIBYTE(wcCommand))
                {
                    pMapTable->Trans[wcIndex - 1].ubType = MTYPE_SINGLE |
                                                           MTYPE_DIRECT;
                    pMapTable->Trans[wcIndex - 1].uCode.ubCode =
                                                    LOBYTE(wcCommand);
                }
                else
                {
                    pMapTable->Trans[wcIndex - 1].ubType = MTYPE_DOUBLE |
                                                           MTYPE_PAIRED;
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[0] =
                                                    HIBYTE(wcCommand);
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[1] =
                                                    LOBYTE(wcCommand);
                }
                break;
            }


            DBGMESSAGE(("Valid char:0x%x, sMode=%d, Run=%d, GlyphHandle=%d, ubType=0x%x, Command=0x%x\n", wcChar, sMode, cRuns, wcIndex, pMapTable->Trans[wcIndex - 1].ubType, wcCommand));
            wcIndex ++;
        }
    }

    wcIndex --;
    pMapTable->dwSize = sizeof(MAPTABLE) + sizeof(TRANSDATA) * (wcIndex - 1);
    pMapTable->dwGlyphNum = wcIndex;

    if (hRes)
    {
        FreeResource(hRes);
    }

    DBG_VPRINTGTT(pGlyphSet);

    return pGlyphSet;
}

BOOL
bWriteGlyphSet(
    IN PUNI_GLYPHSETDATA  pGlyphSet,
    IN CHAR              *pFileName )

/*++

Routine Description:

    Dump FD_GLYPHSET data into specified file.

Arguments:


Return Value:

    None.

    08-Apr-1995 Sat 00:00:00 created -by- Takashi Matsuzawa (takashim)


Revision History:


--*/

{
    HANDLE hFile;

    ULONG   iIndex;
    WCRUN  *pWcRun;
    HGLYPH *phg;
    DWORD dwTmp;
   
    if (NULL == pFileName)
    {
        fprintf( stderr, "Invalid parameters\n" );
        return FALSE;
    }

    if ((hFile = CreateFileA(
        pFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0))
            == INVALID_HANDLE_VALUE) {

        return FALSE;
    }

    // FD_GLYPHSET structure itself + WCRUN array

    if (!WriteFile( hFile, pGlyphSet, pGlyphSet->dwSize, &dwTmp, NULL ))
    {
        return FALSE;
    }

    return TRUE;
}

VOID
Usage()
{
    fprintf ( stderr, "\nUsage : mkgtt [-etvv] outfile\n" );
    exit (EXIT_FAILURE);
}

BOOL
GetLine(
    BYTE *pjBuffer,
    INT cjSize)
{
    if (NULL == pjBuffer)
    {
        fprintf( stderr, "Invalid parameters\n" );
        return NULL;
    }

    do
    {
        if(fgets(pjBuffer, cjSize, stdin) == NULL)
            return FALSE;
    } while (IS_COMMENT(*pjBuffer));

    return TRUE;
}

VOID __cdecl
main(
    int argc,
    char *argv[] )

/*++

Routine Description:

    Main routine for mkgtt.exe

Arguments:

    Output filename.  Input data is read from standard input.

Return Value:

    None.

Author:


    08-Apr-1995 Sat 00:00:00 created -by- Takashi Matsuzawa (takashim)


Revision History:


--*/

{
    PUNI_GLYPHSETDATA pGlyphSet;
    CHAR *pFileName;
    INT iArg, iMbLen;
    CHAR *pStr;
    WORD wCodePage;
    WORD wMbChar, wMbRun, wMbChar2;
    WCHAR wcSysChar;
    BYTE ajMbChar[2];
    BYTE ajBuffer[256];
    BYTE FileName[256];

    bEudc = FALSE;
    bTable = FALSE;
    iVerbose = 1;
    pFileName = NULL;

    if (NULL == argv)
    {
        fprintf( stderr, "Invalid parameters.\n");
        return;
    }

    while (--argc)
    {
        pStr = *(++argv);

        if (*pStr == '-')
        {
            for ( pStr++; *pStr; pStr++)
            {
                if (*pStr == 'e')
                    bEudc = TRUE;
                else if (*pStr == 't')
                    bTable = TRUE;
                else if (*pStr == 'v')
                    iVerbose++;
                else
                    Usage();
            }
         }
         else
         {
             pFileName = pStr;
             break;
         }
    }

    if (pFileName == NULL)
    {
        Usage();
    }

    // get the codepage id used for conversion

    if (!GetLine(ajBuffer, sizeof(ajBuffer)))
    {
        fprintf(stderr, "mkgtt: unexpected end of file\n");
        exit(EXIT_FAILURE);
    }
    if (EOF == sscanf(ajBuffer, "%hd", &wCodePage ))
    {
        fprintf(stderr, "mkgtt: unexpected end of file\n");
        exit(EXIT_FAILURE);
    }

    DBGMESSAGE(("mkgtt: wCodePage = %d\n", wCodePage));

    memset(awMultiByteArray, 0xff, sizeof(awMultiByteArray));

    while (1)
    {
        if (!GetLine(ajBuffer, sizeof(ajBuffer)))
            break;
        if ( sscanf (ajBuffer, "%hx%hd", &wMbChar, &wMbRun ) != 2 )
        {
            fprintf(stderr, "mkgtt: unrecognized line - \"%s\"\n", ajBuffer);
            exit(EXIT_FAILURE);
        }

        DBGMESSAGE(("mkgtt: wMbChar = %x, wMbrun = %d\n", wMbChar, wMbRun));

        for (; wMbRun--; wMbChar++)
        {
            iMbLen = 0;

            if (wMbChar & 0xff00)
            {
                ajMbChar[iMbLen++] = (BYTE)((wMbChar >> 8) & 0xff);
            }
            ajMbChar[iMbLen++] = (BYTE)(wMbChar & 0xff);

            if (MultiByteToWideChar(wCodePage, MB_ERR_INVALID_CHARS,
                    ajMbChar, iMbLen, &wcSysChar, 1) != 1)
            {
                fprintf(stderr, "mkgtt: MultiByteToWideChar failed - %d\n",
                    GetLastError());
                exit(EXIT_FAILURE);
            }

            if ((iMbLen = WideCharToMultiByte(wCodePage, 0,
                &wcSysChar, 1, ajMbChar, sizeof(ajMbChar), NULL, NULL)) == FALSE)
            {
                fprintf(stderr, "mkgtt: WideCharToMultiByte failed - %d\n",
                    GetLastError());
                exit(EXIT_FAILURE);
            }

            if (iMbLen == 2)
                wMbChar2 = (ajMbChar[0] << 8) + ajMbChar[1];
            else
                wMbChar2 = ajMbChar[0];

            if (wMbChar != wMbChar2)
            {
                fprintf(stderr, "mkgtt: round-trip not achieved %x => %x => %x\n",
                    wMbChar, wcSysChar, wMbChar2 );
            }

            if (IS_EUDC_W(wcSysChar))
            {
                DBGMESSAGE(("mkgtt: eudc character %x => %x%s\n", wcSysChar, wMbChar, (bEudc ? "" : " ignored.")));

                if (!bEudc)
                    continue;
            }

            if (awMultiByteArray[wcSysChar] != INVALID_WCHAR_VALUE)
            {
                fprintf(stderr, "mkgtt: duplicate mapping %x => %x overwritten by => %x\n",
                    wcSysChar, awMultiByteArray[wcSysChar], wMbChar);
            }
            awMultiByteArray[wcSysChar] = wMbChar;
        }
    }

    DBGMESSAGE(("Call PBuildGTT\n"));

    switch (wCodePage)
    {
    case CP_SHIFTJIS_932:
        DBGMESSAGE(("Shiftjis\n"));

        if ((pGlyphSet = PBuildGTT(CC_SJIS, wCodePage, awMultiByteArray, sizeof(awMultiByteArray) )) ==
            NULL)
        {
            fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
            return;
        }

        bWriteGlyphSet( pGlyphSet, pFileName );
        GlobalFree( pGlyphSet );

        DBGMESSAGE(("Jis\n"));

        if ((pGlyphSet = PBuildGTT(CC_JIS, wCodePage, awMultiByteArray, sizeof(awMultiByteArray) )) ==
            NULL)
        {
            fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
            return;
        }

        BCreateSubFileName(FileName, pFileName, 'J');

        bWriteGlyphSet( pGlyphSet, FileName );
        GlobalFree( pGlyphSet );

        DBGMESSAGE(("Ank\n"));

        if ((pGlyphSet = PBuildGTT(CC_JIS_ANK, wCodePage, awMultiByteArray, sizeof(awMultiByteArray) )) ==
            NULL)
        {
            fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
            return;
        }

        BCreateSubFileName(FileName, pFileName, 'A');

        bWriteGlyphSet( pGlyphSet, FileName );
        GlobalFree( pGlyphSet );
        break;

    case CP_GB2312_936:
        if ((pGlyphSet = PBuildGTT(0, wCodePage, awMultiByteArray, sizeof(awMultiByteArray) )) ==
            NULL)
        {
            fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
            return;
        }

        bWriteGlyphSet( pGlyphSet, pFileName );
        GlobalFree( pGlyphSet );
        break;

    case CP_WANSUNG_949:
        if ((pGlyphSet = PBuildGTT(0, wCodePage, awMultiByteArray, sizeof(awMultiByteArray) )) ==
            NULL)
        {
            fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
            return;
        }

        bWriteGlyphSet( pGlyphSet, pFileName );
        GlobalFree( pGlyphSet );

        if ((pGlyphSet = PBuildGTT(CC_ISC, wCodePage, awMultiByteArray, sizeof(awMultiByteArray) )) ==
            NULL)
        {
            fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
            return;
        }

        BCreateSubFileName(FileName, pFileName, 'I');
        bWriteGlyphSet( pGlyphSet, FileName );
        GlobalFree( pGlyphSet );
        break;

    case CP_CHINESEBIG5_950:
        if ((pGlyphSet = PBuildGTT(CC_BIG5, wCodePage, awMultiByteArray, sizeof(awMultiByteArray) )) ==
            NULL)
        {
            fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
            return;
        }

        bWriteGlyphSet( pGlyphSet, pFileName );
        GlobalFree( pGlyphSet );

        if ((pGlyphSet = PBuildGTT(CC_TCA, wCodePage, awMultiByteArray, sizeof(awMultiByteArray) )) ==
            NULL)
        {
            fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
            return;
        }

        BCreateSubFileName(FileName, pFileName, 'T');
        bWriteGlyphSet( pGlyphSet, FileName );
        GlobalFree( pGlyphSet );

        if ((pGlyphSet = PBuildGTT(CC_NS86, wCodePage, awMultiByteArray, sizeof(awMultiByteArray) )) ==
            NULL)
        {
            fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
            return;
        }

        BCreateSubFileName(FileName, pFileName, 'N');
        bWriteGlyphSet( pGlyphSet, FileName );
        GlobalFree( pGlyphSet );

        break;
    }
}

VOID
VPrintGTT(
     IN PUNI_GLYPHSETDATA pGly)
{
    PUNI_CODEPAGEINFO pCP;
    PGLYPHRUN         pGlyphRun;
    PMAPTABLE         pMapTable;
    TRANSDATA        *pTrans;
    DWORD             dwI;
    WORD              wSize, wJ;
    PBYTE             pCommand;

    if (NULL == pGly)
    {
        fprintf( stderr, "Invalid parameters.\n");
        return;
    }

    pCP       = (PUNI_CODEPAGEINFO)((PBYTE) pGly + pGly->loCodePageOffset);
    pGlyphRun = (PGLYPHRUN) ((PBYTE)pGly + pGly->loRunOffset);
    pMapTable = (PMAPTABLE) ((PBYTE)pGly + pGly->loMapTableOffset);
    pTrans    = pMapTable->Trans;

    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("G L Y P H S E T   D A T A   F I L E\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("GLYPHSETDATA\n");
    printf("GLYPHSETDATA.dwSize              : %d\n", pGly->dwSize);
    printf("             dwVersion           : %d.%d\n", (pGly->dwVersion) >>16,
                                                 0x0000ffff&pGly->dwVersion);
    printf("             dwFlags             : %d\n", pGly->dwFlags);
    printf("             lPredefinedID       : %d\n", pGly->lPredefinedID);
    printf("             dwGlyphCount        : %d\n", pGly->dwGlyphCount);
    printf("             dwRunCount          : %d\n", pGly->dwRunCount);
    printf("             loRunOffset         : 0x%x\n", pGly->loRunOffset);
    printf("             dwCodePageCount     : %d\n", pGly->dwCodePageCount);
    printf("             loCodePageOffset    : 0x%x\n", pGly->loCodePageOffset);
    printf("             loMapTableOffset    : 0x%x\n", pGly->loMapTableOffset);
    printf("\n");

    pCP = (PUNI_CODEPAGEINFO)((PBYTE) pGly + pGly->loCodePageOffset);

    printf("\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("CODEPAGEINFO\n");
    for (dwI = 0; dwI < pGly->dwCodePageCount; dwI ++)
    {
        printf ("UNI_CODEPAGEINFO[%d].dwCodePage                = %d\n",
            dwI, pCP->dwCodePage);
        printf ("UNI_CODEPAGEINFO[%d].SelectSymbolSet.dwCount   = %d\n",
            dwI, pCP->SelectSymbolSet.dwCount);
        printf ("UNI_CODEPAGEINFO[%d].SelectSymbolSet:Command   = %s\n",
            dwI, (PBYTE)pCP+pCP->SelectSymbolSet.loOffset);
        printf ("UNI_CODEPAGEINFO[%d].UnSelectSymbolSet.dwCount = %d\n",
            dwI, pCP->UnSelectSymbolSet.dwCount);
        printf ("UNI_CODEPAGEINFO[%d].UnSelectSymbolSet:Command = %s\n",
            dwI, (PBYTE)pCP+pCP->UnSelectSymbolSet.loOffset);
        pCP++;
    }

    pGlyphRun =
            (PGLYPHRUN) ((PBYTE)pGly + pGly->loRunOffset);

    printf("\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("GLYPHRUN\n");
    for (dwI = 0; dwI < pGly->dwRunCount; dwI ++)
    {
         printf("GLYPHRUN[%2d].wcLow       = 0x%-4x\n",
             dwI, pGlyphRun->wcLow);
         printf("GLYPHRUN[%2d].wGlyphCount = %d\n",
             dwI, pGlyphRun->wGlyphCount);
         pGlyphRun++;
    }

    pMapTable = (PMAPTABLE) ((PBYTE)pGly + pGly->loMapTableOffset);
    pTrans    = pMapTable->Trans;

    printf("\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("MAPTABLE\n");
    printf("MAPTABLE.dwSize     = %d\n", pMapTable->dwSize);
    printf("MAPTABLE.dwGlyphNum = %d\n", pMapTable->dwGlyphNum);

    for (dwI = 0; dwI < pMapTable->dwGlyphNum; dwI ++)
    {
        printf("MAPTABLE.pTrans[%5d].ubCodePageID = %d\n",
            dwI, pTrans[dwI].ubCodePageID);
        printf("MAPTABLE.pTrans[%5d].ubType       = 0x%x\n",
            dwI, pTrans[dwI].ubType);
        switch(pTrans[dwI].ubType & MTYPE_FORMAT_MASK)
        {
        case MTYPE_DIRECT:
            printf("MAPTABLE.pTrans[%5d].ubCode       = 0x%02x\n",
                dwI, pTrans[dwI].uCode.ubCode);
            break;
        case MTYPE_PAIRED:
            printf("MAPTABLE.pTrans[%5d].ubPairs[0]   = 0x%02x\n",
                dwI, pTrans[dwI].uCode.ubPairs[0]);
            printf("MAPTABLE.pTrans[%5d].ubPairs[1]   = 0x%02x\n",
                dwI, pTrans[dwI].uCode.ubPairs[1]);
            break;
        case MTYPE_COMPOSE:
                printf("MAPTABLE.pTrans[%5d].sCode        = 0x%02x\n",
                    dwI, pTrans[dwI].uCode.sCode);
                pCommand = (PBYTE)pMapTable + pTrans[dwI].uCode.sCode;
                wSize = *(WORD*)pCommand;
                pCommand += 2;
                printf("Size                                = 0x%d\n", wSize);
                printf("Command                             = 0x");
                for (wJ = 0; wJ < wSize; wJ ++)
                {
                    printf("%02x",pCommand[wJ]);
                }
                printf("\n");
            break;
        }
    }
}


BOOL
BCreateSubFileName(
    IN CHAR *pDestFileName,
    IN CHAR *pSrcFileName,
    IN CHAR cAdd)
{
    INT iFileNameLen, iI;

    if (NULL == pDestFileName ||
        NULL == pSrcFileName   )
    {
        fprintf( stderr, "Invalid parameters\n" );
        return FALSE;
    }

    iFileNameLen = strlen(pSrcFileName);
    strcpy(pDestFileName, pSrcFileName);

    for (iI = 0; iI < iFileNameLen; iI ++)
    {
        if (pSrcFileName[iI] == '.')
        {
            break;
        }
    }

    pDestFileName[iI]     = cAdd;
    pDestFileName[iI + 1] = pSrcFileName[iI];
    pDestFileName[iI + 2] = pSrcFileName[iI + 1];
    pDestFileName[iI + 3] = pSrcFileName[iI + 2];
    pDestFileName[iI + 4] = pSrcFileName[iI + 3];
    pDestFileName[iI + 5] = (CHAR)NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\alpsres\alpsres.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

// NTRAID#NTBUG9-553877-2002/02/28-yasuho-: Security: mandatory changes
// NTRAID#NTBUG9-576656-2002/03/14-yasuho-: Possible buffer overrun
// NTRAID#NTBUG9-576658-2002/03/14-yasuho-: Possible divide by zero
// NTRAID#NTBUG9-576660-2002/03/14-yasuho-: Need impersonate for file access
// NTRAID#NTBUG9-576661-2002/03/14-yasuho-: Remove the dead codes

#include "pdev.h"
#include "alpsres.h"
#include "dither.h"

#include <stdio.h>
// #include <winsplp.h>

INT		iCompTIFF( BYTE *, int, BYTE *, int );
HANDLE	RevertToPrinterSelf( VOID );
BOOL	ImpersonatePrinterClient( HANDLE );

BOOL bTextQuality(
PDEVOBJ     pdevobj);


BOOL IsAsfOkMedia(
PDEVOBJ     pdevobj);

BOOL
bDataSpool(
   PDEVOBJ    pdevobj,
   HANDLE hFile,
   LPSTR  pBuf,
   DWORD dwLen);

BOOL
bSpoolOut(
    PDEVOBJ pdevobj);

#define DATASPOOL(p, f, s, n) \
    if (TRUE != bDataSpool((p), (f), (s), (n))) \
        return FALSE;
#define SPOOLOUT(p) \
    if (TRUE != bSpoolOut(p)) \
        return FALSE;
//
// Decision table for media type/paper
// source selection.  To avoid hardware damage,
// we will select "manual feed" whenever ASF is
// not appropriate to specified media.
//

static struct {
    BOOL bAsfOk; // Can print on ASF
    // Add new attributes here
} gMediaType[MAX_MEDIATYPES] = {
    {1}, // PPC (Normal)
    {1}, // PPC (Fine)
    {1}, // OHP (Normal)
    {1}, // OHP (Fine)
    {1}, // ExcOHP (Normal)
    {1}, // ExcOHP (Fine)
    {0}, // Iron (PPC)
    {0}, // Iron (OHP)
    {0}, // Thick Paper
    {1}, // Postcard
    {1}, // High Grade Paper
    {0}, // Back Print Film
    {0}, // Labeca Sheet
    {0}, // CD Master
    {1}, // Dye-sub Paper
    {1}, // Dye-sub Label
    {0}, // Glossy Paper
    {1}, // VD Photo Film
    {1}, // VD Photo Postcard
    // Add new media type here
};

static
PAPERSIZE
gPaperSize[] = {
    {2, 4800 * 2, 5960 * 2, 0, 0, 0, 1}, // Letter
    {3, 4800 * 2, 7755 * 2, 0, 0, 0, 1}, // Legal
    {1, 4190 * 2, 5663 * 2, 0, 0, 0, 1}, // Exective
    {4, 4800 * 2, 6372 * 2, 0, 0, 0, 1}, // A4
    {5, 4138 * 2, 5430 * 2, 0, 0, 0, 1}, // B5
    {6, 2202 * 2, 2856 * 2, 0, 0, 0, 1}, // Postcard
    {6, 4564 * 2, 2856 * 2, 0, 0, 0, 1}, // Double Postcard
    {7, 2202 * 2, 3114 * 2, 0, 0, 0, 1}, // Photo Color Label
    {7, 2202 * 2, 2740 * 2, 0, 0, 0, 1}, // Glossy Label
    {0, 2030 * 2, 3164 * 2, 0, 0, 0, 1}, // CD Master
    {6, 2202 * 2, 3365 * 2, 0, 0, 0, 1}, // VD Photo Postcard
    /* Add new paper sizes here */
};

#define PAPER_SIZE_LETTER   0
#define PAPER_SIZE_LEGAL    1
#define PAPER_SIZE_EXECTIVE 2
#define PAPER_SIZE_A4       3
#define PAPER_SIZE_B5       4
#define PAPER_SIZE_POSTCARD 5
#define PAPER_SIZE_DOUBLE_POSTCARD 6
#define PAPER_PHOTO_COLOR_LABEL    7
#define PAPER_GLOSSY_LABEL  8
#define PAPER_CD_MASTER     9
#define PAPER_VD_PHOTO_POSTCARD   10
/* Add new paper sizes here */
#define MAX_PAPERS          (sizeof(gPaperSize)/sizeof(gPaperSize[0]))

//
// ---- F U N C T I O N S ----
//
//////////////////////////////////////////////////////////////////////////
//  Function:   OEMEnablePDEV
//
//  Description:  OEM callback for DrvEnablePDEV;
//                  allocate OEM specific memory block
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ. pdevobj->pdevOEM is undefined.
//        pPrinterName    name of the current printer.
//        cPatterns, phsurfPatterns, cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo:
//                These parameters are identical to what's passed
//                into DrvEnablePDEV.
//        pded        points to a function table which contains the 
//                system driver's implementation of DDI entrypoints.
//
//  Returns:
//        Pointer to the PDEVOEM
//
//  Comments:
//        
//
//  History:
//
//////////////////////////////////////////////////////////////////////////

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ pdevobj,
    PWSTR pPrinterName,
    ULONG cPatterns,
    HSURF *phsurfPatterns,
    ULONG cjGdiInfo,
    GDIINFO* pGdiInfo,
    ULONG cjDevInfo,
    DEVINFO* pDevInfo,
    DRVENABLEDATA *pded)
{
    PCURRENTSTATUS pTemp = NULL;

    VERBOSE((DLLTEXT("OEMEnablePDEV() entry.\n")));

    pdevobj->pdevOEM = NULL;

    // Allocate minidriver private PDEV block.

    pTemp = (PCURRENTSTATUS)MemAllocZ(sizeof(CURRENTSTATUS));
    if (NULL == pTemp) {
        ERR(("Memory allocation failure.\n"));
        goto FAIL_NO_MEMORY;
    }

#define MAX_RASTER_PIXELS 5100
// In worstcase, Photo color printing mode use 4 bits par pixel
#define MAX_RASTER_BYTES (MAX_RASTER_PIXELS + 1 / 2)
// Buffers for four plane rasters and one for the
// the scratch work enough for worstcase compression
// overhead.
// The 1st one byte is used for On/Off flag.
#define MAX_RASTER_BUFFER_BYTES \
    (4 + MAX_RASTER_BYTES * 5 + (MAX_RASTER_BYTES >> 4))

    pTemp->pData = (PBYTE)MemAllocZ(MAX_RASTER_BUFFER_BYTES);
    if (NULL == pTemp->pData) {
        ERR(("Memory allocation failure.\n"));
        goto FAIL_NO_MEMORY;
    }

    pTemp->pRaster[0] = pTemp->pData;
    pTemp->pRaster[1] = pTemp->pRaster[0] + (1 + MAX_RASTER_BYTES);
    pTemp->pRaster[2] = pTemp->pRaster[1] + (1 + MAX_RASTER_BYTES);
    pTemp->pRaster[3] = pTemp->pRaster[2] + (1 + MAX_RASTER_BYTES);
    pTemp->pData2 = pTemp->pRaster[3] + (1 + MAX_RASTER_BYTES);

    pTemp->pPaperSize = (PAPERSIZE *)MemAllocZ(
            sizeof (gPaperSize));
    if (NULL == pTemp->pPaperSize) {
        ERR(("Memory allocation failure.\n"));
        goto FAIL_NO_MEMORY;
    }
    CopyMemory(pTemp->pPaperSize, gPaperSize,
            sizeof (gPaperSize));

    // Set minidriver PDEV address.

    pdevobj->pdevOEM = (MINIDEV *)MemAllocZ(sizeof(MINIDEV));
    if (NULL == pdevobj->pdevOEM) {
        ERR(("Memory allocation failure.\n"));
        goto FAIL_NO_MEMORY;
    }

    MINIDEV_DATA(pdevobj) = pTemp;

    return pdevobj->pdevOEM;

FAIL_NO_MEMORY:
    if (NULL != pTemp) {
        if (NULL != pTemp->pData) {
            MemFree(pTemp->pData);
        }
        if (NULL != pTemp->pPaperSize) {
            MemFree(pTemp->pPaperSize);
        }
        MemFree(pTemp);
    }
    return NULL;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDisablePDEV
//
//  Description:  OEM callback for DrvDisablePDEV;
//                  free all allocated OEM specific memory block(s)
//
//  Parameters:
//
//        pdevobj            Pointer to the DEVOBJ.
//
//  Returns:
//        None
//
//  Comments:
//        
//
//  History:
//
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj)
{
    PCURRENTSTATUS pTemp;

    VERBOSE((DLLTEXT("OEMDisablePDEV() entry.\n")));

    if ( NULL != pdevobj->pdevOEM ) {

        pTemp = (PCURRENTSTATUS)MINIDEV_DATA(pdevobj);

        if (NULL != pTemp) { 
            if (NULL != pTemp->pData) {
                MemFree(pTemp->pData);
            }
            if (NULL != pTemp->pPaperSize) {
                MemFree(pTemp->pPaperSize);
            }
            MemFree( pTemp );
        }

        MemFree( pdevobj->pdevOEM );
        pdevobj->pdevOEM = NULL;
    }
}


BOOL APIENTRY
OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew )
{
    PCURRENTSTATUS pTempOld, pTempNew;
    PBYTE pTemp;

    VERBOSE((DLLTEXT("OEMResetPDEV entry.\n")));

    // Do some verificatin on PDEV data passed in.
    pTempOld = (PCURRENTSTATUS)MINIDEV_DATA(pdevobjOld);
    pTempNew = (PCURRENTSTATUS)MINIDEV_DATA(pdevobjNew);

    // Copy mindiriver specific part of PDEV
    if (NULL != pTempNew && NULL != pTempOld) {
// NTRAID#NTBUG9-279876-2002/03/14-yasuho-: Should implement OEMResetPDEV().
// NTRAID#NTBUG9-249133-2002/03/14-yasuho-: 2nd page is distorted with duplex.
        // This printer doesn't have duplex but we should copy them.
        pTempNew->iCurrentResolution = pTempOld->iCurrentResolution;
        pTempNew->iPaperQuality = pTempOld->iPaperQuality;
        pTempNew->iPaperSize = pTempOld->iPaperSize;
        pTempNew->iPaperSource = pTempOld->iPaperSource;
        pTempNew->iTextQuality = pTempOld->iTextQuality;
        pTempNew->iModel = pTempOld->iModel;
        pTempNew->iDither = pTempOld->iDither;
        pTempNew->fRequestColor = pTempOld->fRequestColor;
        pTempNew->iUnitScale = pTempOld->iUnitScale;
        pTempNew->iEmulState = pTempOld->iEmulState;
        pTempNew->bXflip = pTempOld->bXflip;
    }

    return TRUE;
}


VOID
XFlip(
    PDEVOBJ pdevobjOld,
    PCURRENTSTATUS pdevOEM,
    PBYTE pBuf,
    DWORD dwLen)
{
    INT i, j, k;
    BYTE jTemp, jTemp2;

#define SWAP_3BYTES(p, q) { \
    jTemp = *(PBYTE)(p); \
    *(PBYTE)(p) = *(PBYTE)(q); \
    *(PBYTE)(q) = jTemp; \
    jTemp = *((PBYTE)(p) + 1); \
    *((PBYTE)(p) + 1) = *((PBYTE)(q) + 1); \
    *((PBYTE)(q) + 1) = jTemp; \
    jTemp = *((PBYTE)(p) + 2); \
    *((PBYTE)(p) + 2) = *((PBYTE)(q) + 2); \
    *((PBYTE)(q) + 2) = jTemp; }

    if (pdevOEM->fRequestColor) {

        j = (dwLen / 3) * 3 - 3;
        for (i = 0; i < j; i += 3, j -= 3) {
            SWAP_3BYTES(pBuf + i, pBuf + j);
        }
    }
    else {

        j = dwLen - 1;

        for (i = 0; i < j; i++, j--) {

            jTemp = pBuf[j];
            jTemp2 = 0;

            for (k = 0; k < 8; k++) {
                if ((jTemp >> k) & 1) {
                    jTemp2 |= (1 << (7 - k));
                }
            }

            if (i == j) {
                pBuf[j] = jTemp2;
                continue;
            }
            jTemp = pBuf[i];
            pBuf[i] = jTemp2;
            jTemp2 = 0;

            for (k = 0; k < 8; k++) {
                if ((jTemp >> k) & 1) {
                    jTemp2 |= (1 << (7 - k));
                }
            }
            pBuf[j] = jTemp2;
        }
    }
}


BOOL APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    PCURRENTSTATUS lpnp;
    int            i, x;
    WORD           wByteLen, wDataSize;
    BYTE           bRed, bGreen, bBlue;
    BYTE           py, pm, pc, pk, rm;
    BYTE           by, bm, bc, bk;
    BYTE           bCmd[128];
    LONG           iTemp;
    INT iColor, iPlane;
    BYTE *pTemp;
    BOOL bLast = FALSE;
    WORD           wTemp;
    PBYTE          pCmd;

    lpnp = (PCURRENTSTATUS)MINIDEV_DATA(pdevobj);

    VERBOSE(("%d lines left in logical page.\n",
        lpnp->wRasterCount));

    // We clip off any raster lines exceeding the
    // harware margins since it will feed paper too
    // much and we cannot back feed the paper
    // for 2nd plane and aftter.  This result as
    // "only cyan (1st plane) image is printed on
    // paper."

    if (lpnp->wRasterCount <= 0) {
        WARNING(("Line beyond page length.\n"));
        // We discard this line silently.
        return TRUE;
    }
    else if (lpnp->wRasterCount <= 1) {
        // The last raster in logical page,
        // Need special handling.
        bLast = TRUE;
    }
    lpnp->wRasterCount--;

    // Do x-flip when requested.
    if (lpnp->bXflip) {
        XFlip(pdevobj, MINIDEV_DATA(pdevobj), pBuf, dwLen);
    }

    // Get resulting buffer length in bytes.
    if ( lpnp->fRequestColor ) {
        if ((dwLen / 3) > MAX_RASTER_BYTES) {
            ERR((DLLTEXT("dwLen is too big (%d).\n"), dwLen));
            return FALSE;
        }
// NTRAID#NTBUG9-644657-2002/04/09-yasuho-: AV occured on OEMFilterGraphics()
// The pointer(s) will be not valid if the MDP_StartPage() has been failed.
        if (!lpnp->pRaster)
            return FALSE;

        wByteLen = (WORD)(dwLen / 3);
        memset(lpnp->pRaster[0], 0, wByteLen+1);
        memset(lpnp->pRaster[1], 0, wByteLen+1);
        memset(lpnp->pRaster[2], 0, wByteLen+1);
        memset(lpnp->pRaster[3], 0, wByteLen+1);
    }
    else {
        if (dwLen > MAX_RASTER_BYTES) {
            ERR((DLLTEXT("dwLen is too big (%d).\n"), dwLen));
            return FALSE;
        }

        wByteLen = (WORD)dwLen;
    }

    // Check if we have K ribbon
    if (NULL != lpnp->pRasterK) {
// NTRAID#NTBUG9-644657-2002/04/09-yasuho-: AV occured on OEMFilterGraphics()
// The pointer(s) will be not valid if the MDP_StartPage() has been failed.
        if (!lpnp->pRasterK)
            return FALSE;
        lpnp->pRasterK[0] = 0;
    }

    if ( lpnp->fRequestColor ) {

// NTRAID#NTBUG9-644657-2002/04/09-yasuho-: AV occured on OEMFilterGraphics()
// The pointer(s) will be not valid if the MDP_StartPage() has been failed.
        if (!lpnp->pRasterC || !lpnp->pRasterM || !lpnp->pRasterY)
            return FALSE;
        lpnp->pRasterC[0] = 0;
        lpnp->pRasterM[0] = 0;
        lpnp->pRasterY[0] = 0;

    for ( i = 0, x = 0; i+2 < (INT)dwLen ; i+=3, x++ ) {

        bRed = pBuf[i];
        bGreen = pBuf[i+1];
        bBlue = pBuf[i+2];

        // RGB -> YMCK

        // DITHER_OHP: No longer used.

        switch ( lpnp->iTextQuality ) {

        case CMDID_TEXTQUALITY_PHOTO:

            bPhotoConvert(pdevobj, bRed, bGreen, bBlue, &py, &pm, &pc, &pk);

            // Processing dither
            bDitherProcess(pdevobj, x, py, pm, pc, pk, &by, &bm, &bc, &bk);

            break;

        case CMDID_TEXTQUALITY_GRAPHIC:

            bBusinessConvert(pdevobj, bRed, bGreen, bBlue, &py, &pm, &pc, &pk);

            // Processing dither
            bDitherProcess(pdevobj, x, py, pm, pc, pk, &by, &bm, &bc, &bk);

            break;

        case CMDID_TEXTQUALITY_CHARACTER:

            bCharacterConvert(pdevobj, bRed, bGreen, bBlue, &py, &pm, &pc, &pk);

            // Processing dither
            bDitherProcess(pdevobj, x, py, pm, pc, pk, &by, &bm, &bc, &bk);

            break;

        //case CMDID_TEXTQUALITY_GRAY: dead code
        }

        if ((lpnp->iDither == DITHER_DYE) || (lpnp->iDither == DITHER_VD)) {

            if ( bc ) {
                lpnp->pRasterC[0] = 1;
                lpnp->pRasterC[1 + x / 2] |= (BYTE)(bc << ((x % 2) ? 0 : 4));
            }

            if ( bm ) {
                lpnp->pRasterM[0] = 1;
                lpnp->pRasterM[1 + x / 2] |= (BYTE)(bm << ((x % 2) ? 0 : 4));
            }

            if ( by ) {
                lpnp->pRasterY[0] = 1;
                lpnp->pRasterY[1 + x / 2] |= (BYTE)(by << ((x % 2) ? 0 : 4));
            }

            // K make sure we have K ribbon
            if ( bk && (lpnp->iDither == DITHER_VD) ) {
                lpnp->pRasterK[0] = 1;
                lpnp->pRasterK[1 + x / 2] |= (BYTE)(bk << ((x % 2) ? 0 : 4));
            }

        } else {

            if ( bc ) {
                lpnp->pRasterC[0] = 1;
                lpnp->pRasterC[1 + x / 8] |= (BYTE)(0x80 >> (x % 8));
            }

            if ( bm ) {
                lpnp->pRasterM[0] = 1;
                lpnp->pRasterM[1 + x / 8] |= (BYTE)(0x80 >> (x % 8));
            }

            if ( by ) {
                lpnp->pRasterY[0] = 1;
                lpnp->pRasterY[1 + x / 8] |= (BYTE)(0x80 >> (x % 8));
            }

            // K make sure we have K ribbon
            if ( bk && lpnp->pRasterK ) {
                lpnp->pRasterK[0] = 1;
                lpnp->pRasterK[1 + x / 8] |= (BYTE)(0x80 >> (x % 8));
            }
        }
    }

    }
    else {

        // Monochrome.

        pTemp = pBuf;
        for (i = 0; i < wByteLen; i++, pTemp++) {

            if (*pTemp) {
                lpnp->pRasterK[0] = 1;
                break;
            }
        }
    }


    // Loop process for each color start here.

    for ( iPlane = 0; iPlane < 4; iPlane++ ) {

        if (NONE == lpnp->PlaneColor[iPlane]) {

            // No more plane to process.
            break;
        }

        if (!lpnp->fRequestColor) {
            pTemp = pBuf;
        }
        else {
            // Color rasters
            pTemp = lpnp->pRaster[iPlane] + 1;
        }

        // If we do not have ink on this raster line,
        // skip this line, just move cursor to the next one.

        if (0 == lpnp->pRaster[iPlane][0]) {
            lpnp->wRasterOffset[iPlane]++;
            continue;
        }

        // We have ink, output data.

        iColor = lpnp->PlaneColor[iPlane];

        if (0 > iColor) {

            iColor *= -1;
            lpnp->PlaneColor[iPlane] = iColor;

            // Ink selection commands
            switch (iColor) {
            case CYAN:
                 DATASPOOL(pdevobj, lpnp->TempFile[iPlane],
                        "\x1B\x1A\x01\x00\x72", 5);
                break;
            case MAGENTA:
                DATASPOOL(pdevobj, lpnp->TempFile[iPlane],
                        "\x1B\x1A\x02\x00\x72", 5);
                break;
            case YELLOW:
                DATASPOOL(pdevobj, lpnp->TempFile[iPlane],
                        "\x1B\x1A\x03\x00\x72", 5);
                break;
            case BLACK:
                DATASPOOL(pdevobj, lpnp->TempFile[iPlane],
                        "\x1B\x1A\x00\x01\x72", 5);
                break;
            default:
                ERR((DLLTEXT("Invalid color or plane IDs (%d, %d).\n"),
                    lpnp->PlaneColor[iPlane], iPlane));
                return FALSE;
            }
        }

        
        // First we move cursor to the correct raster offset.

        if (0 < lpnp->wRasterOffset[iPlane]) {

            // Send Y cursor move command

            if (FAILED(StringCchPrintfExA(bCmd, sizeof bCmd, &pCmd, NULL, 0,
                "\x1B\x2A\x62%c%c\x59",
                LOBYTE(lpnp->wRasterOffset[iPlane]), 
                HIBYTE(lpnp->wRasterOffset[iPlane]))))
                return FALSE;

            DATASPOOL(pdevobj, lpnp->TempFile[iPlane], bCmd, (DWORD)(pCmd - bCmd));

            // Reset Y position index.
            lpnp->wRasterOffset[iPlane] = 0;
        }

        // Decide if we want to do compress

        if ((lpnp->iDither == DITHER_DYE) || (lpnp->iDither == DITHER_VD))
            wDataSize = ( wByteLen + 1 ) / 2;  // 2 pixels par byte
        else
            wDataSize = ( wByteLen + 7 ) / 8;  // 8 pixels par byte


        if ((lpnp->iDither != DITHER_DYE) && (lpnp->iDither != DITHER_VD)) {

// NTRAID#NTBUG9-24281-2002/03/14-yasuho-: 
// large bitmap does not printed on 1200dpi.
// Unnecessary data were sent to printer.
        wTemp = bPlaneSendOrderCMY(lpnp) ? wDataSize : wByteLen;
        if ((iTemp = iCompTIFF(lpnp->pData2,
							   MAX_RASTER_BUFFER_BYTES - (1 + MAX_RASTER_BYTES)*4,
							   pTemp, wTemp)) > 0 && iTemp < wTemp) {
            pTemp = lpnp->pData2;
            wDataSize = (WORD)iTemp;

            // Turn on compression mode.
            if (lpnp->iCompMode[iPlane] != COMP_TIFF4) {
                DATASPOOL(pdevobj, lpnp->TempFile[iPlane], "\x1B*b\x02\x00M", 6);
                lpnp->iCompMode[iPlane] = COMP_TIFF4;
            }
        }
        else if (lpnp->iCompMode[iPlane] != COMP_NONE) {

            // Turn off compression mode.
            DATASPOOL(pdevobj, lpnp->TempFile[iPlane], "\x1B*b\x00\x00M", 6);
            lpnp->iCompMode[iPlane] = COMP_NONE;
        }

        } // not DITHER_DYE

        //
        // a) ESC * xx V - one raster output, mo move.
        // b) ESC * xx W - one raster output, move to next raster.
        //
        // Use a) on the last raster to avoid page eject.  For the
        // other rasters use b).

        // Send one raster data
        if (FAILED(StringCchPrintfExA(bCmd, sizeof bCmd, &pCmd, NULL, 0,
            "\x1B\x2A\x62%c%c%c",
            LOBYTE(wDataSize), HIBYTE(wDataSize),
            (BYTE)(bLast ? 0x56 : 0x57))))
            return FALSE;
        DATASPOOL(pdevobj, lpnp->TempFile[iPlane], bCmd, (DWORD)(pCmd - bCmd));
        DATASPOOL(pdevobj, lpnp->TempFile[iPlane], pTemp, wDataSize);

    } // end of Color loop

    lpnp->y++;

    return TRUE;
}

INT
GetPlaneColor(
    PDEVOBJ pdevobj,
    PCURRENTSTATUS lpnp,
    INT iPlane)
{
    INT iColor;

    iColor = NONE;

    if (!lpnp->fRequestColor) {
        if (0 == iPlane) {
            iColor = BLACK;
        }
        return iColor;
    }

    // Color
// NTRAID#NTBUG9-24281-2002/03/14-yasuho-: 
// large bitmap does not printed on 1200dpi.
// Do not use black plane (K) on the 1200dpi with color mode.
    if (bPlaneSendOrderCMY(lpnp)) {

        switch (iPlane) {
        case 0:
            iColor = CYAN;
            break;
        case 1:
            iColor = MAGENTA;
            break;
        case 2:
            iColor = YELLOW;
            break;
        }
    }
    else if (bPlaneSendOrderMCY(lpnp)) {

        switch (iPlane) {
        case 0:
            iColor = MAGENTA;
            break;
        case 1:
            iColor = CYAN;
            break;
        case 2:
            iColor = YELLOW;
            break;
        }
    }
    else if (bPlaneSendOrderYMC(lpnp)) {

        switch (iPlane) {
        case 0:
            iColor = YELLOW;
            break;
        case 1:
            iColor = MAGENTA;
            break;
        case 2:
            iColor = CYAN;
            break;
        }
    }
    else if (bPlaneSendOrderCMYK(lpnp)) {

        switch (iPlane) {
        case 0:
            iColor = CYAN;
            break;
        case 1:
            iColor = MAGENTA;
            break;
        case 2:
            iColor = YELLOW;
            break;
        case 3:
            iColor = BLACK;
            break;
        }
    }
    return iColor;
}

VOID
MDP_StartDoc(
    PDEVOBJ pdevobj,
    PCURRENTSTATUS pdevOEM)
{
    VERBOSE(("MDP_StartDoc called.\n"));
    WRITESPOOLBUF(pdevobj, "\x1B\x65\x1B\x25\x80\x41", 6);
}

VOID
MDP_EndDoc(
    PDEVOBJ pdevobj,
    PCURRENTSTATUS pdevOEM)
{
    WRITESPOOLBUF(pdevobj, "\x1B\x25\x00\x58", 4);
}

BOOL
MDP_CreateTempFile(
    PDEVOBJ pdevobj,
    PCURRENTSTATUS pdevOEM,
    INT iPlane)
{
    HANDLE hFile;
    BOOL bRet = FALSE;
    HANDLE hToken = NULL;
    PBYTE pBuf = NULL;
    DWORD dwSize, dwNeeded = 0;

    pdevOEM->TempName[iPlane][0] = __TEXT('\0');
    pdevOEM->TempFile[iPlane] = INVALID_HANDLE_VALUE;

    dwSize = (MAX_PATH + 1) * sizeof(WCHAR);
    for (;;) {
        if ((pBuf = MemAlloc(dwSize)) == NULL)
            goto out;
        if (GetPrinterData(pdevobj->hPrinter, SPLREG_DEFAULT_SPOOL_DIRECTORY,
            NULL, pBuf, dwSize, &dwNeeded) == ERROR_SUCCESS)
            break;
        if (dwNeeded < dwSize || GetLastError() != ERROR_MORE_DATA)
            goto out;
        MemFree(pBuf);
        dwSize = dwNeeded;
    }

    if (!(hToken = RevertToPrinterSelf()))
        goto out;

    if (!GetTempFileName((LPWSTR)pBuf, TEMP_NAME_PREFIX, 0,
        pdevOEM->TempName[iPlane])) {
        ERR((DLLTEXT("GetTempFileName failed (%d).\n"), GetLastError()))
        goto out;
    }

    hFile = CreateFile(pdevOEM->TempName[iPlane],
            (GENERIC_READ | GENERIC_WRITE), 0, NULL,
            CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        ERR((DLLTEXT("CreateFile failed.\n")))
        DeleteFile(pdevOEM->TempName[iPlane]);
        goto out;
    }

    pdevOEM->TempFile[iPlane] = hFile;
    bRet = TRUE;

out:
    if (pBuf) MemFree(pBuf);
    if (hToken) (void)ImpersonatePrinterClient(hToken);

    return bRet;
} 

BOOL
MDP_StartPage(
    PDEVOBJ pdevobj,
    PCURRENTSTATUS pdevOEM)
{
    LONG iPageLength;
    INT iPaperSizeID;
    BYTE bCmd[128];
    INT iColor, iPlane;
    PBYTE pCmd;
  
    // Set resolution

    switch (pdevOEM->iCurrentResolution) {

    case DPI1200:

        WRITESPOOLBUF(pdevobj, "\x1B\x2A\x74\x04\x52", 5);
        break;

    case DPI600:

        WRITESPOOLBUF(pdevobj, "\x1B\x2A\x74\x03\x52", 5);
        break;

    case DPI300:

        WRITESPOOLBUF(pdevobj, "\x1B\x2A\x74\x02\x52", 5);
        break;
    }

    // Set Paper Dimentions

    // Make sure top margin is 0 and we are at top.
    WRITESPOOLBUF(pdevobj, "\x1B\x26\x6C\x00\x00\x45", 6);
    WRITESPOOLBUF(pdevobj, "\x1B\x1A\x00\x00\x0C", 5);

    if (pdevOEM->iPaperSize < 0 || pdevOEM->iPaperSize >= MAX_PAPERS)
        return FALSE;
    if (!(pdevOEM->iUnitScale))
        return FALSE;

    iPaperSizeID
        = pdevOEM->pPaperSize[pdevOEM->iPaperSize].iPaperSizeID;
    if (FAILED(StringCchPrintfExA(bCmd, sizeof bCmd, &pCmd, NULL, 0,
        "\x1B\x26\x6C%c%c\x41",
        LOBYTE(iPaperSizeID), HIBYTE(iPaperSizeID))))
        return FALSE;
    WRITESPOOLBUF(pdevobj, bCmd, (DWORD)(pCmd - bCmd));

    iPageLength
        = pdevOEM->pPaperSize[pdevOEM->iPaperSize].iLogicalPageHeight;
    iPageLength /= pdevOEM->iUnitScale;
    if (FAILED(StringCchPrintfExA(bCmd, sizeof bCmd, &pCmd, NULL, 0,
        "\x1B\x26\x6C%c%c\x50",
        LOBYTE(iPageLength), HIBYTE(iPageLength))))
        return FALSE;
    WRITESPOOLBUF(pdevobj, bCmd, (DWORD)(pCmd - bCmd));

    // # of raster lines in logical page.
    pdevOEM->wRasterCount = (WORD)iPageLength;

    // Determine dither methods.

    pdevOEM->iDither = DITHER_HIGH_DIV2;

    if (!(pdevOEM->fRequestColor)) {

        pdevOEM->iTextQuality = CMDID_TEXTQUALITY_GRAY;
    }
    else {

        if (!(bTextQuality(pdevobj))){

            ERR((DLLTEXT("bTextQuality failed\n")));
            return FALSE;
        }
    }

    // Initialize dither tables

    if (!(bInitialDither(pdevobj))){

        ERR((DLLTEXT("bInitialDither failed\n")));
        return FALSE;
    }

    // Pre-processing of color conversion. needed only photo.

    if (pdevOEM->iTextQuality == CMDID_TEXTQUALITY_PHOTO ) {

        if (!(bInitialColorConvert(pdevobj)) ){
            ERR((DLLTEXT("bInitialColorConvert failed\n")));
            return FALSE;
        }
    }

    // Start Raster Data Transfer
    WRITESPOOLBUF(pdevobj, "\x1B\x2A\x72\x00\x41", 5);

    if ( pdevOEM->fRequestColor ) {

        // Open temporary files.  One file per one plain.

        for (iPlane = 0; iPlane < 4; iPlane++) {

#if !CACHE_FIRST_PLANE
            // We do not spool 1st plane
            if (0 == iPlane) {
                pdevOEM->TempFile[iPlane] = INVALID_HANDLE_VALUE;
                continue;
            }
#endif // !CACHE_FIRST_PLANE

            if (!MDP_CreateTempFile(pdevobj, pdevOEM, iPlane))
                return FALSE;
        }
    }
    else {

        for (iPlane = 0; iPlane < 4; iPlane++) {
            pdevOEM->TempFile[iPlane] = INVALID_HANDLE_VALUE;
        }
    }

    // Change printer emulation state.
    pdevOEM->iEmulState = EMUL_DATA_TRANSFER;
    pdevOEM->iCompMode[0] = pdevOEM->iCompMode[1] = pdevOEM->iCompMode[2]
            = pdevOEM->iCompMode[3] = COMP_NONE;

    // Misc setup.
    pdevOEM->y = 0;

    if (!pdevOEM->fRequestColor) {
        WRITESPOOLBUF(pdevobj, "\x1B\x1A\x00\x01\x72", 5);
    }

    pdevOEM->pRasterC = NULL;
    pdevOEM->pRasterM = NULL;
    pdevOEM->pRasterY = NULL;
    pdevOEM->pRasterK = NULL;

    for (iPlane = 0; iPlane < 4; iPlane++) {

        pdevOEM->wRasterOffset[iPlane] = 0;

        // Set color ID for each plane.
        // Negative value = Has no ink so do not have to ouput
        // Positive value = Has ink on the plane.  Have to output.
        //

        iColor = GetPlaneColor(pdevobj, pdevOEM, iPlane);
        pdevOEM->PlaneColor[iPlane] = (-iColor);

        switch (iColor) {
// NTRAID#NTBUG9-644657-2002/04/09-yasuho-: AV occured on OEMFilterGraphics()
// If the GetPlaneColor() failed, this function must return as failure.
        default:
            return FALSE;
        case CYAN:
            pdevOEM->pRasterC = pdevOEM->pRaster[iPlane];
            break;
        case MAGENTA:
            pdevOEM->pRasterM = pdevOEM->pRaster[iPlane];
            break;
        case YELLOW:
            pdevOEM->pRasterY = pdevOEM->pRaster[iPlane];
            break;
        case BLACK:
            pdevOEM->pRasterK = pdevOEM->pRaster[iPlane];
            break;
        }
    }
    return TRUE;
}

BOOL
MDP_EndPage(
    PDEVOBJ pdevobj,
    PCURRENTSTATUS pdevOEM)
{
    INT i;
    HANDLE hToken = NULL;
    BOOL bRet = FALSE;

    // Spooled data transfer
    if ( pdevOEM->fRequestColor )
        SPOOLOUT(pdevobj);

    // End Raster Transfer, FF.
    WRITESPOOLBUF(pdevobj, "\x1B\x2A\x72\x43\x0C", 5);

    // Change printer emulation state.
    pdevOEM->iEmulState = EMUL_RGL;

    // Close cache files.

    for (i = 0; i < 4; i++) {

        if (INVALID_HANDLE_VALUE != pdevOEM->TempFile[i]) {

            if (0 == CloseHandle(pdevOEM->TempFile[i])) {
                ERR((DLLTEXT("CloseHandle error %d\n"),
                        GetLastError()));
                goto out;
            }
            pdevOEM->TempFile[i] = INVALID_HANDLE_VALUE;

            if (!(hToken = RevertToPrinterSelf()))
                goto out;

            if (0 == DeleteFile(pdevOEM->TempName[i])) {
                ERR((DLLTEXT("DeleteName error %d\n"),
                        GetLastError()));
                goto out;
            }
            pdevOEM->TempName[i][0] = __TEXT('\0');

            (void)ImpersonatePrinterClient(hToken);
            hToken = NULL;
        }
    }
    bRet = TRUE;

out:
    if (hToken) (void)ImpersonatePrinterClient(hToken);

    return bRet;
}

INT APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD dwCmdCbID,
    DWORD dwCount,
    PDWORD pdwParams)
{

    PCURRENTSTATUS lpnp;
    WORD   len;
    WORD   wPageLength;
    WORD   wVerticalOffset;
    WORD   wRealOffset;
    INT iRet;

    VERBOSE((DLLTEXT("OEMCommandCallback(%d) entry.\n"),dwCmdCbID));

    lpnp = (PCURRENTSTATUS)MINIDEV_DATA(pdevobj);

    iRet = 0;

    switch ( dwCmdCbID ){

    case CMDID_PAPERSOURCE_CSF:
    // \x1B&l\x03\x00H
    lpnp->iPaperSource = CMDID_PAPERSOURCE_CSF;
    break;

    case CMDID_PAPERSOURCE_MANUAL:
    // \x1B&l\x02\x00H
    lpnp->iPaperSource = CMDID_PAPERSOURCE_MANUAL;
    break;

    case CMDID_PAPERQUALITY_PPC_NORMAL:
    case CMDID_PAPERQUALITY_PPC_FINE:
    case CMDID_PAPERQUALITY_OHP_NORMAL:
    case CMDID_PAPERQUALITY_OHP_FINE:
    case CMDID_PAPERQUALITY_OHP_EXCL_NORMAL:
    case CMDID_PAPERQUALITY_OHP_EXCL_FINE:
    case CMDID_PAPERQUALITY_IRON_PPC:
    case CMDID_PAPERQUALITY_IRON_OHP:
    case CMDID_PAPERQUALITY_THICK:
    case CMDID_PAPERQUALITY_POSTCARD:
    case CMDID_PAPERQUALITY_HIGRADE:
    case CMDID_PAPERQUALITY_BACKPRINTFILM:
    case CMDID_PAPERQUALITY_LABECA_SHEET:
    case CMDID_PAPERQUALITY_CD_MASTER:
    case CMDID_PAPERQUALITY_DYE_SUB_PAPER:
    case CMDID_PAPERQUALITY_DYE_SUB_LABEL:
    case CMDID_PAPERQUALITY_GLOSSY_PAPER:
    case CMDID_PAPERQUALITY_VD_PHOTO_FILM:
    case CMDID_PAPERQUALITY_VD_PHOTO_CARD:
    {

        switch ( dwCmdCbID ){

        case CMDID_PAPERQUALITY_PPC_NORMAL:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x00\x00M", 6);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_PPC_NORMAL;
        break;

        case CMDID_PAPERQUALITY_PPC_FINE: // only mono color
        if( lpnp->fRequestColor ){
            // If user selects color, then we selects PPC NORMAL
            // because, PPC FINE is not accepted color
            WRITESPOOLBUF(pdevobj, "\x1B&l\x00\x00M", 6);
            lpnp->iPaperQuality = CMDID_PAPERQUALITY_PPC_NORMAL;
        }else{
            WRITESPOOLBUF(pdevobj, "\x1B&l\x00\x02M", 6);
            lpnp->iPaperQuality = CMDID_PAPERQUALITY_PPC_FINE;
        }
        break;

        case CMDID_PAPERQUALITY_OHP_NORMAL:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x08\x01M", 6);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_OHP_NORMAL;
        break;

        case CMDID_PAPERQUALITY_OHP_FINE:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x08\x02M", 6);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_OHP_FINE;
        break;

        case CMDID_PAPERQUALITY_OHP_EXCL_NORMAL:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x01\x01M", 6);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_OHP_EXCL_NORMAL;
        break;

        case CMDID_PAPERQUALITY_OHP_EXCL_FINE:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x01\x02M", 6);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_OHP_EXCL_FINE;
        break;

        case CMDID_PAPERQUALITY_IRON_PPC:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x02\x02M", 6);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_IRON_PPC;
        break;

        case CMDID_PAPERQUALITY_IRON_OHP:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x02\x01M", 6);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_IRON_OHP;
        break;

        case CMDID_PAPERQUALITY_THICK:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x05\x00M", 6);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_THICK;
        break;

        case CMDID_PAPERQUALITY_POSTCARD:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x06\x00M", 6);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_POSTCARD;
        break;

        case CMDID_PAPERQUALITY_HIGRADE:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x07\x00M", 6);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_HIGRADE;
        break;

        case CMDID_PAPERQUALITY_BACKPRINTFILM:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x09\x00M", 6);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_BACKPRINTFILM;
        break;

        case CMDID_PAPERQUALITY_LABECA_SHEET:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x03\x00M", 6);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_LABECA_SHEET;
        break;

        case CMDID_PAPERQUALITY_CD_MASTER:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x04\x01M", 6);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_CD_MASTER;
        break;

        case CMDID_PAPERQUALITY_DYE_SUB_PAPER:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x0A\x00M", 6);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_DYE_SUB_PAPER;
        break;

        case CMDID_PAPERQUALITY_DYE_SUB_LABEL:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x0C\x00M", 6);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_DYE_SUB_LABEL;
        break;

        case CMDID_PAPERQUALITY_GLOSSY_PAPER:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x0F\x00M", 6);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_GLOSSY_PAPER;
        break;

        case CMDID_PAPERQUALITY_VD_PHOTO_FILM:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x10\x00M", 6);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_VD_PHOTO_FILM;
        break;

        case CMDID_PAPERQUALITY_VD_PHOTO_CARD:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x11\x00M", 6);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_VD_PHOTO_CARD;
        break;

        }

        if (lpnp->iPaperSource == CMDID_PAPERSOURCE_MANUAL){

            WRITESPOOLBUF(pdevobj, "\x1B&l\x02\x00H", 6);

        } else {
        // Check if this media ( PAPERQUALITY ) and this
        // paper size is printable on CSF.

            if (IsAsfOkMedia(pdevobj)){
                WRITESPOOLBUF(pdevobj, "\x1B&l\x03\x00H", 6);
            }else{
                WRITESPOOLBUF(pdevobj, "\x1B&l\x02\x00H", 6);
            }
        }

        if( lpnp->fRequestColor ){
        // YMCK Page Plane
            WRITESPOOLBUF(pdevobj, "\x1B\x2A\x72\x04\x55", 5);
        }else{
        // Black Raster Plane
            WRITESPOOLBUF( pdevobj, "\x1B\x2A\x72\x00\x55", 5);
        }

    }
    break;

    case CMDID_TEXTQUALITY_PHOTO:
    case CMDID_TEXTQUALITY_GRAPHIC:
    case CMDID_TEXTQUALITY_CHARACTER:

        lpnp->iTextQuality =  dwCmdCbID;
        break;

    // ####

    case CMDID_MIRROR_ON:
        lpnp->bXflip = TRUE;
        break;

    case CMDID_MIRROR_OFF:

        lpnp->bXflip = FALSE;
        break;

    case CMDID_CURSOR_RELATIVE:

        if (dwCount < 1 || !pdwParams)
            break;
        if (!lpnp->iUnitScale)
            break;

        // this printer's linespacing cmd is influenced with current resolution.

        wVerticalOffset = (WORD)(pdwParams[0]);
        wVerticalOffset /= (WORD)lpnp->iUnitScale;

        lpnp->wRasterOffset[0] += wVerticalOffset;
        lpnp->wRasterOffset[1] += wVerticalOffset;
        lpnp->wRasterOffset[2] += wVerticalOffset;
        lpnp->wRasterOffset[3] += wVerticalOffset;

        lpnp->wRasterCount -= wVerticalOffset;

        // Return offset change in device's units
        iRet = wVerticalOffset;
        break;

    case CMDID_RESOLUTION_1200_MONO:

        lpnp->iCurrentResolution = DPI1200;
        lpnp->iUnitScale = 2;
        break;

    case CMDID_RESOLUTION_600:

        lpnp->iCurrentResolution = DPI600;
        lpnp->iUnitScale = 2;
        break;

    case CMDID_RESOLUTION_300:

        lpnp->iCurrentResolution = DPI300;
        lpnp->iUnitScale = 4;
        break;

    case CMDID_PSIZE_LETTER:

        lpnp->iPaperSize = PAPER_SIZE_LETTER;
        break;

    case CMDID_PSIZE_LEGAL:

        lpnp->iPaperSize = PAPER_SIZE_LEGAL;
        break;

    case CMDID_PSIZE_EXECTIVE:

        lpnp->iPaperSize = PAPER_SIZE_EXECTIVE;
        break;

    case CMDID_PSIZE_A4:

        lpnp->iPaperSize = PAPER_SIZE_A4;
        break;

    case CMDID_PSIZE_B5:

        lpnp->iPaperSize = PAPER_SIZE_B5;
        break;

    case CMDID_PSIZE_POSTCARD:

        lpnp->iPaperSize = PAPER_SIZE_POSTCARD;
        break;

    case CMDID_PSIZE_POSTCARD_DOUBLE:

        lpnp->iPaperSize = PAPER_SIZE_DOUBLE_POSTCARD;
        break;

    case CMDID_PSIZE_PHOTO_COLOR_LABEL:

        lpnp->iPaperSize = PAPER_PHOTO_COLOR_LABEL;
        break;

    case CMDID_PSIZE_GLOSSY_LABEL:

        lpnp->iPaperSize = PAPER_GLOSSY_LABEL;
        break;

    case CMDID_PSIZE_CD_MASTER:

        lpnp->iPaperSize = PAPER_CD_MASTER;
        break;

    case CMDID_PSIZE_VD_PHOTO_POSTCARD:

        lpnp->iPaperSize = PAPER_VD_PHOTO_POSTCARD;
        break;

    case CMDID_COLORMODE_COLOR:
    case CMDID_COLORMODE_MONO:
        lpnp->fRequestColor = (dwCmdCbID == CMDID_COLORMODE_COLOR);
        break;

    case CMDID_BEGINDOC_MD5000: // Postcard printable area is expantioned on MD-5000

        lpnp->pPaperSize[PAPER_SIZE_POSTCARD].iLogicalPageHeight
            = 3082 * 2;
        lpnp->pPaperSize[PAPER_SIZE_DOUBLE_POSTCARD].iLogicalPageHeight
            = 3082 * 2;

    case CMDID_BEGINDOC_MD2000:
    case CMDID_BEGINDOC_MD2010:

        lpnp->iModel = dwCmdCbID;
        MDP_StartDoc(pdevobj, MINIDEV_DATA(pdevobj));
        break;

    case CMDID_ENDDOC:

        MDP_EndDoc(pdevobj, MINIDEV_DATA(pdevobj));
        break;

    case CMDID_BEGINPAGE:

        MDP_StartPage(pdevobj, MINIDEV_DATA(pdevobj));
        break;

    case CMDID_ENDPAGE:

        MDP_EndPage(pdevobj, MINIDEV_DATA(pdevobj));
        break;

    default:

        ERR((DLLTEXT("Unknown CallbackID = %d\n"), dwCmdCbID));
    }

    return iRet;
}

/*************************** Function Header *******************************
 *  IsAsfOkMedia
 *
 *  Check if the media and the paper size is printable on Cut Sheet Feeder.
 *
 * HISTORY:
 *  24 Sep 1996    -by-    Sueya Sugihara    [sueyas]
 *     Created.
 *
 ***************************************************************************/
BOOL IsAsfOkMedia(
PDEVOBJ     pdevobj)
{

    PCURRENTSTATUS lpnp;

    lpnp = (PCURRENTSTATUS)(MINIDEV_DATA(pdevobj));

    if (lpnp->iPaperQuality < CMDID_PAPERQUALITY_FIRST ||
        lpnp->iPaperQuality > CMDID_PAPERQUALITY_LAST)
        return FALSE;
    if (lpnp->iPaperSize < 0 || lpnp->iPaperSize > MAX_PAPERS)
        return FALSE;

    // ASF enabled only with ASF-allowed paper size AND
    // ASF-allowed media type

    if (gMediaType[lpnp->iPaperQuality - CMDID_PAPERQUALITY_FIRST].bAsfOk
            && lpnp->pPaperSize[lpnp->iPaperSize].bAsfOk) {
        return TRUE;
    }

    return FALSE;
}
/*************************** Function Header *******************************
 *  bTextQuality
 *
 *  Select dither table according to the paper quality(Media Type) and
 *  resolution and the requested halftoning type.
 *  If appropriate halftoning type is not selected, then this function
 *  selects halftoning type.
 *
 * HISTORY:
 *  24 Sep 1996    -by-    Sueya Sugihara    [sueyas]
 *     Created.
 *
 ***************************************************************************/
BOOL bTextQuality(
PDEVOBJ     pdevobj)
{

    PCURRENTSTATUS lpnp;

    lpnp = (PCURRENTSTATUS)(MINIDEV_DATA(pdevobj));

    switch ( lpnp->iPaperQuality ){

    case CMDID_PAPERQUALITY_PPC_NORMAL:
    case CMDID_PAPERQUALITY_OHP_NORMAL:
    case CMDID_PAPERQUALITY_OHP_EXCL_NORMAL:
    case CMDID_PAPERQUALITY_OHP_EXCL_FINE:
    case CMDID_PAPERQUALITY_IRON_PPC:
    case CMDID_PAPERQUALITY_IRON_OHP:
    case CMDID_PAPERQUALITY_THICK:
    case CMDID_PAPERQUALITY_POSTCARD:
    case CMDID_PAPERQUALITY_HIGRADE:
    case CMDID_PAPERQUALITY_BACKPRINTFILM:
    case CMDID_PAPERQUALITY_LABECA_SHEET:
    case CMDID_PAPERQUALITY_CD_MASTER:
    case CMDID_PAPERQUALITY_GLOSSY_PAPER:
    if ( lpnp->iTextQuality == CMDID_TEXTQUALITY_PHOTO ){
        lpnp->iDither = DITHER_HIGH; // 145LPI
    }else if ( lpnp->iTextQuality == CMDID_TEXTQUALITY_GRAPHIC ){
        lpnp->iDither = DITHER_LOW;  // 95LPI
    }else{
        lpnp->iDither = DITHER_HIGH_DIV2;  // 145/2LPI
    }
    break;

    case CMDID_PAPERQUALITY_DYE_SUB_PAPER:
    case CMDID_PAPERQUALITY_DYE_SUB_LABEL:
        lpnp->iDither = DITHER_DYE;  // Dye-sub Media dither
    break;

    case CMDID_PAPERQUALITY_VD_PHOTO_FILM:
    case CMDID_PAPERQUALITY_VD_PHOTO_CARD:
        lpnp->iDither = DITHER_VD;  // Dye-sub Media dither
    break;

    default:
    return FALSE;
    }

    return TRUE;
}

BOOL
bDataSpool(
    PDEVOBJ pdevobj,
    HANDLE hFile,
    LPSTR lpBuf,
    DWORD dwLen)
{
    DWORD dwTemp, dwTemp2;
    BYTE *pTemp;

    if (hFile != INVALID_HANDLE_VALUE) {

        pTemp = lpBuf;
        dwTemp = dwLen;
        while (dwTemp > 0) {

            if (0 == WriteFile(hFile, pTemp, dwTemp, &dwTemp2, NULL)) {

                ERR((DLLTEXT("Writing cache faild, WriteFile() error %d.\n"),
                    GetLastError()));
                return FALSE;
            }
            pTemp += dwTemp2;
            dwTemp -= dwTemp2;
        }
       
    }
    else {
        WRITESPOOLBUF(pdevobj, lpBuf, dwLen);
    }
    return TRUE;
}

BOOL
bSpoolOut(
    PDEVOBJ pdevobj)
{
    PCURRENTSTATUS lpnp;

    INT iPlane, iColor, iFile;
    DWORD dwSize, dwTemp, dwTemp2;
    HANDLE hFile;

#define    BUF_SIZE 1024
    BYTE  Buf[BUF_SIZE];

    lpnp = (PCURRENTSTATUS)(MINIDEV_DATA(pdevobj));

    VERBOSE((DLLTEXT("bSpoolOut entry.\n")));

    for (iPlane = 0; iPlane < 4; iPlane++) {

    // CMDID_PAPERQUALITY_OHP_EXCL_NORMAL : MCY
    // CMDID_PAPERQUALITY_OHP_EXCL_FINE   : MCY
    // CMDID_PAPERQUALITY_IRON_OHP        : YMC
    // Except above                       : CMYK

        VERBOSE((DLLTEXT("About to send plane %d.\n"), iPlane));

        // Check if we have ink in this plane.
        iColor = lpnp->PlaneColor[iPlane];

        // Exit loop if no remaining plane to print
        if (iColor == NONE) {
            VERBOSE((DLLTEXT("No remaining plane left.\n")));
            break;
        }
        else if (0 > iColor) {
            VERBOSE((DLLTEXT("No ink on this plane.\n")));
            continue;
        }

        // If it is 2nd plane and after, send Back Feed.
        if (0 < iPlane) {
            WRITESPOOLBUF(pdevobj, "\x1B\x1A\x00\x00\x0C", 5);
        }

        VERBOSE((DLLTEXT("Cached data Plane=%d Color=%d\n"),
                iPlane, iColor));

        // Get file handle.
        hFile = lpnp->TempFile[iPlane];
        if (INVALID_HANDLE_VALUE == hFile) {

#if CACHE_FIRST_PLANE
            ERR((DLLTEXT("file handle NULL in SendCachedData.\n")));
            return FALSE;
#endif // CACHE_FIRST_PLANE

            // Allow fp to be NULL for the case where we
            // immediately send data to printer.
            continue;
        }

        dwSize = SetFilePointer(hFile, 0L, NULL, FILE_CURRENT);
        if (0xffffffff == dwSize) {
            ERR((DLLTEXT("SetFilePointer failed %d\n"),
                GetLastError()));
            return FALSE;
        }

        // Output cached data.

        if (0L != SetFilePointer(hFile, 0L, NULL, FILE_BEGIN)) {

            ERR((DLLTEXT("SetFilePointer failed %d\n"),
                GetLastError()));
            return FALSE;
        }

        VERBOSE((DLLTEXT("Size of data to be read and sent = %ld\n"), dwSize));

        for ( ; dwSize > 0; dwSize -= dwTemp2) {

            dwTemp = ((BUF_SIZE < dwSize) ? BUF_SIZE : dwSize);

            if (0 == ReadFile(hFile, Buf, dwTemp, &dwTemp2, NULL)) {
                ERR((DLLTEXT("ReadFile error in SendCachedData.\n")));
                return FALSE;
            }

            if (dwTemp2 > 0) {
                WRITESPOOLBUF(pdevobj, Buf, dwTemp2);
            }
        }
    }
    return TRUE;
}

/*++

Routine Name

    ImpersonationToken

Routine Description:

    This routine checks if a token is a primary token or an impersonation 
    token.    
    
Arguments:

    hToken - impersonation token or primary token of the process
    
Return Value:

    TRUE, if the token is an impersonation token
    FALSE, otherwise.
    
--*/
BOOL
ImpersonationToken(
    IN HANDLE hToken
    )
{
    BOOL       bRet = TRUE;
    TOKEN_TYPE eTokenType;
    DWORD      cbNeeded;
    DWORD      LastError;

    //
    // Preserve the last error. Some callers of ImpersonatePrinterClient (which
    // calls ImpersonationToken) rely on the fact that ImpersonatePrinterClient
    // does not alter the last error.
    //
    LastError = GetLastError();
        
    //
    // Get the token type from the thread token.  The token comes 
    // from RevertToPrinterSelf. An impersonation token cannot be 
    // queried, because RevertToPRinterSelf doesn't open it with 
    // TOKEN_QUERY access. That's why we assume that hToken is
    // an impersonation token by default
    //
    if (GetTokenInformation(hToken,
                            TokenType,
                            &eTokenType,
                            sizeof(eTokenType),
                            &cbNeeded))
    {
        bRet = eTokenType == TokenImpersonation;
    }        
    
    SetLastError(LastError);

    return bRet;
}

/*++

Routine Name

    RevertToPrinterSelf

Routine Description:

    This routine will revert to the local system. It returns the token that
    ImpersonatePrinterClient then uses to imersonate the client again. If the
    current thread doesn't impersonate, then the function merely returns the
    primary token of the process. (instead of returning NULL) Thus we honor
    a request for reverting to printer self, even if the thread is not impersonating.
    
Arguments:

    None.
    
Return Value:

    NULL, if the function failed
    HANDLE to token, otherwise.
    
--*/
HANDLE
RevertToPrinterSelf(
    VOID
    )
{
    HANDLE   NewToken, OldToken, cToken;
    BOOL	 Status;

    NewToken = NULL;

    Status = OpenThreadToken(GetCurrentThread(),
							 TOKEN_IMPERSONATE,
							 TRUE,
							 &OldToken);
    if (Status) 
    {
        //
        // We are currently impersonating
        //
		cToken = GetCurrentThread();
        Status = SetThreadToken(&cToken,
								NewToken);       
		if (!Status) {
			return NULL;
		}
    }
	else if (GetLastError() == ERROR_NO_TOKEN)
    {
        //
        // We are not impersonating
        //
        Status = OpenProcessToken(GetCurrentProcess(),
								  TOKEN_QUERY,
								  &OldToken);

		if (!Status) {
			return NULL;
		}
    }
    
    return OldToken;
}

/*++

Routine Name

    ImpersonatePrinterClient

Routine Description:

    This routine attempts to set the passed in hToken as the token for the
    current thread. If hToken is not an impersonation token, then the routine
    will simply close the token.
    
Arguments:

    hToken - impersonation token or primary token of the process
    
Return Value:

    TRUE, if the function succeeds in setting hToken
    FALSE, otherwise.
    
--*/
BOOL
ImpersonatePrinterClient(
    HANDLE  hToken)
{
    BOOL	Status;
	HANDLE	cToken;

    //
    // Check if we have an impersonation token
    //
    if (ImpersonationToken(hToken)) 
    {
		cToken = GetCurrentThread();
        Status = SetThreadToken(&cToken,
								hToken);       

        if (!Status) 
        {
            return FALSE;
        }
    }

    CloseHandle(hToken);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\alpsres\dither.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

// NTRAID#NTBUG9-576661-2002/03/14-yasuho-: Remove the dead codes

#define Yellow                     0
#define Cyan                       1
#define Magenta                    2
#define Black                      3

#define DITHER_HIGH                1
#define DITHER_LOW                 2
// #define DITHER_OHP                 3 - No longer used.
#define DITHER_HIGH_DIV2           4
#define DITHER_DYE                 5
#define DITHER_VD                  6

// bOHPConvert() - No longer used.

BOOL bPhotoConvert(
PDEVOBJ pdevobj,
BYTE bRed,
BYTE bGreen,
BYTE bBlue,
BYTE *ppy,
BYTE *ppm,
BYTE *ppc,
BYTE *ppk);

BOOL bBusinessConvert(
PDEVOBJ pdevobj,
BYTE bRed,
BYTE bGreen,
BYTE bBlue,
BYTE *ppy,
BYTE *ppm,
BYTE *ppc,
BYTE *ppk);

BOOL bCharacterConvert(
PDEVOBJ pdevobj,
BYTE bRed,
BYTE bGreen,
BYTE bBlue,
BYTE *ppy,
BYTE *ppm,
BYTE *ppc,
BYTE *ppk);

BOOL bMonoConvert(
PDEVOBJ pdevobj,
BYTE bRed,
BYTE bGreen,
BYTE bBlue,
BYTE *ppk);

BOOL bDitherProcess(
PDEVOBJ pdevobj,
int  x,
BYTE py,
BYTE pm,
BYTE pc,
BYTE pk,
BYTE *pby,
BYTE *pbm,
BYTE *pbc,
BYTE *pbk);

BOOL bInitialDither(
PDEVOBJ     pdevobj);

BOOL bInitialColorConvert(
PDEVOBJ     pdevobj);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\alpsres\dither.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

// NTRAID#NTBUG9-576656-2002/03/14-yasuho-: Possible buffer overrun
// NTRAID#NTBUG9-576658-2002/03/14-yasuho-: Possible divide by zero
// NTRAID#NTBUG9-576661-2002/03/14-yasuho-: Remove the dead codes

#include "pdev.h"
#include "alpsres.h"
#include "dither.h"
#include "dtable.h"

int Calc_degree(int x, int y);

/*************************** Function Header *******************************
 *  bInitialDither
 *
 *  Pre-processing of dither tables.
 *
 * HISTORY:
 *  24 Jun 1996    -by-    Sueya Sugihara    [sueyas]
 *     Created.
 *
 ***************************************************************************/
BOOL bInitialDither(
PDEVOBJ     pdevobj)
{

    PCURRENTSTATUS lpnp;

    lpnp = (PCURRENTSTATUS)MINIDEV_DATA(pdevobj);

    // Already created the NewTable[][][] by dither.exe.

    if( lpnp->iTextQuality != CMDID_TEXTQUALITY_GRAY ){

    int B_LOW;
    int B_R;
    int UCR;
    int YUCR;
    int B_GEN;
    int i;
//    FLOATOBJ  f1,f2;
    float  f1,f2;

    // initialize.

    if( lpnp->iTextQuality == CMDID_TEXTQUALITY_PHOTO ){

        B_LOW = 0;
        B_R   = 70;
        UCR   = 50;
        YUCR  = 4;
        B_GEN = 2;

    }else{

        B_LOW = 0;
        B_R   = 100;
        UCR   = 60;
        YUCR  = 4;
        B_GEN = 3;
    }

    // Create KuroTBL[] to get black from YMC.

    for( i=0; i< 256; i++){

        if( i < B_LOW )

        lpnp->KuroTBL[i] = 0;

        else{

        int       k;

        FLOATOBJ_SetLong(&f1, (i - B_LOW));
        FLOATOBJ_DivLong(&f1, (255 - B_LOW));

        f2 = f1;

        for(k=0; k<(B_GEN - 1); k++){

            FLOATOBJ_Mul(&f1, &f2);

        }

        FLOATOBJ_MulLong(&f1, 255);

        FLOATOBJ_MulLong(&f1, B_R);

        FLOATOBJ_DivLong(&f1, 100);

        FLOATOBJ_AddFloat(&f1,(FLOAT)0.5);

        lpnp->KuroTBL[i] = (unsigned char)FLOATOBJ_GetLong(&f1);

        }

    }

    // Create UcrTBL[] to reduce extracting black density from YMC

    for( i=0; i< 256; i++){

        if( i < B_LOW )

        lpnp->UcrTBL[i] = 0;

        else{

        FLOATOBJ_SetLong(&f1, (i - B_LOW));

        FLOATOBJ_MulLong(&f1, UCR);

        FLOATOBJ_DivLong(&f1, 100);

        lpnp->UcrTBL[i] = (unsigned char)FLOATOBJ_GetLong(&f1);

        }
    }


    lpnp->YellowUcr = (unsigned char)((unsigned int)(100 - YUCR) * 255 / 100);

    }

    return TRUE;
}

/*************************** Function Header *******************************
 *  bInitialColorConvert
 *
 *  Pre-processing of color conversion process.
 *
 * HISTORY:
 *  24 Jun 1996    -by-    Sueya Sugihara    [sueyas]
 *     Created.
 *
 ***************************************************************************/
BOOL bInitialColorConvert(
PDEVOBJ     pdevobj)
{

    PCURRENTSTATUS lpnp;
    int            i;
    BYTE          *RedHosei;
    BYTE          *GreenHosei;
    BYTE          *BlueHosei;

    lpnp = (PCURRENTSTATUS)MINIDEV_DATA(pdevobj);

    // Color definitions.

    lpnp->RGB_Rx = 6400;      // X value of Red 100% on monitor
    lpnp->RGB_Ry = 3300;      // Y value of Red 100% on monitor
    lpnp->RGB_Gx = 2900;      // X value of Green 100% on monitor
    lpnp->RGB_Gy = 6000;      // Y value of Green 100% on monitor
    lpnp->RGB_Bx = 1500;      // X value of Blue 100% on monitor
    lpnp->RGB_By =  600;      // Y value of Blue 100% on monitor
    lpnp->RGB_Wx = 3127;      // X value of White 100% on monitor
    lpnp->RGB_Wy = 3290;      // Y value of White 100% on monitor

    lpnp->CMY_Cx = 1726;      // X value of Cyan 100% on ribbon
    lpnp->CMY_Cy = 2248;      // Y value of Cyan 100% on ribbon
    lpnp->CMY_Mx = 3923;      // X value of Magenta 100% on ribbon
    lpnp->CMY_My = 2295;      // Y value of Magenta 100% on ribbon
    lpnp->CMY_Yx = 4600;      // X value of Yellow 100% on ribbon
    lpnp->CMY_Yy = 4600;      // Y value of Yellow 100% on ribbon
    lpnp->CMY_Rx = 6000;      // X value of Red (MY) 100% on ribbon
    lpnp->CMY_Ry = 3200;      // Y value of Red (MY) 100% on ribbon
    lpnp->CMY_Gx = 2362;      // X value of Green (CY) 100% on ribbon
    lpnp->CMY_Gy = 5024;      // Y value of Green (CY) 100% on ribbon
    lpnp->CMY_Bx = 2121;      // X value of Blue (CM) 100% on ribbon
    lpnp->CMY_By = 1552;      // Y value of Blue (CM) 100% on ribbon
    lpnp->CMY_Wx = 3148;      // X value of White on paper
    lpnp->CMY_Wy = 3317;      // Y value of White on paper

    lpnp->RedAdj     =   0;   // Param for density adjust
    lpnp->RedStart   =   0;   // Position of start for density adjust
    lpnp->GreenAdj   = 400;   // Param for density adjust
    lpnp->GreenStart =  50;   // Position of start for density adjust
    lpnp->BlueAdj    =   0;   // Param for density adjust
    lpnp->BlueStart  =   0;   // Position of start for density adjust


    // Calculation of density adjustment table.

    RedHosei = lpnp->RedHosei;
    GreenHosei = lpnp->GreenHosei;
    BlueHosei = lpnp->BlueHosei;

    for(i = 0; i < 256; i ++){

    RedHosei[i] = GreenHosei[i] = BlueHosei[i] = 0;
    }

    if( lpnp->RedAdj != 0 ){

    for(i = lpnp->RedStart; i < 255; i++)

        RedHosei[i] = (unsigned char)((255 - i) * (i - lpnp->RedStart) / lpnp->RedAdj);

    }

    if( lpnp->GreenAdj != 0 ){

    for(i = lpnp->GreenStart; i < 255; i++)

        GreenHosei[i] = (unsigned char)((255 - i) * (i - lpnp->GreenStart) / lpnp->GreenAdj);

    }

    if( lpnp->BlueAdj != 0 ){

    for(i = lpnp->BlueStart; i < 255; i++)

        BlueHosei[i] = (unsigned char)((255 - i) * (i - lpnp->BlueStart) / lpnp->BlueAdj);

    }

    // Calculation of color definition data.

    lpnp->RGB_Rx -= lpnp->RGB_Wx;        lpnp->RGB_Ry -= lpnp->RGB_Wy;
    lpnp->RGB_Gx -= lpnp->RGB_Wx;        lpnp->RGB_Gy -= lpnp->RGB_Wy;
    lpnp->RGB_Bx -= lpnp->RGB_Wx;        lpnp->RGB_By -= lpnp->RGB_Wy;

    lpnp->RGB_Cx = ( lpnp->RGB_Gx - lpnp->RGB_Bx ) / 2 + lpnp->RGB_Bx;
    lpnp->RGB_Cy = ( lpnp->RGB_Gy - lpnp->RGB_By ) / 2 + lpnp->RGB_By;
    lpnp->RGB_Mx = ( lpnp->RGB_Rx - lpnp->RGB_Bx ) / 2 + lpnp->RGB_Bx;
    lpnp->RGB_My = ( lpnp->RGB_Ry - lpnp->RGB_By ) / 2 + lpnp->RGB_By;
    lpnp->RGB_Yx = ( lpnp->RGB_Rx - lpnp->RGB_Gx ) / 2 + lpnp->RGB_Gx;
    lpnp->RGB_Yy = ( lpnp->RGB_Ry - lpnp->RGB_Gy ) / 2 + lpnp->RGB_Gy;

    lpnp->CMY_Cx -= lpnp->CMY_Wx;        lpnp->CMY_Cy -= lpnp->CMY_Wy;
    lpnp->CMY_Mx -= lpnp->CMY_Wx;        lpnp->CMY_My -= lpnp->CMY_Wy;
    lpnp->CMY_Yx -= lpnp->CMY_Wx;        lpnp->CMY_Yy -= lpnp->CMY_Wy;
    lpnp->CMY_Rx -= lpnp->CMY_Wx;        lpnp->CMY_Ry -= lpnp->CMY_Wy;
    lpnp->CMY_Gx -= lpnp->CMY_Wx;        lpnp->CMY_Gy -= lpnp->CMY_Wy;
    lpnp->CMY_Bx -= lpnp->CMY_Wx;        lpnp->CMY_By -= lpnp->CMY_Wy;

    // Calculation of data for color dimension judgement

    lpnp->CMY_Cd = Calc_degree( lpnp->CMY_Cx, lpnp->CMY_Cy );
    lpnp->CMY_Md = Calc_degree( lpnp->CMY_Mx, lpnp->CMY_My );
    lpnp->CMY_Yd = Calc_degree( lpnp->CMY_Yx, lpnp->CMY_Yy );
    lpnp->CMY_Rd = Calc_degree( lpnp->CMY_Rx, lpnp->CMY_Ry );
    lpnp->CMY_Gd = Calc_degree( lpnp->CMY_Gx, lpnp->CMY_Gy );
    lpnp->CMY_Bd = Calc_degree( lpnp->CMY_Bx, lpnp->CMY_By );

    return TRUE;
}

int Calc_degree( int x, int y)
{
    register int    val;

    if( x == 0 ){

    if( y == 0 )

        val = 0;

    else if( y > 0 )

        val = 30000;

    else

        val = -30000;

    }else{

    val = y / x;

    if( val > 300 )

        val = 30000;

    else if( val < -300 )

        val = -30000;

    else

        val = (y * 100) / x;

    }

    return val;

}


// bOHPConvert() - No longer used.


/*************************** Function Header *******************************
 *  bPhotoConvert
 *
 *  Convert RGB to CMYK for photo graphics.
 *
 *
 * HISTORY:
 *  24 Jun 1996    -by-    Sueya Sugihara    [sueyas]
 *     Created.
 *
 ***************************************************************************/
BOOL bPhotoConvert(
PDEVOBJ pdevobj,
BYTE bRed,
BYTE bGreen,
BYTE bBlue,
BYTE *ppy,
BYTE *ppm,
BYTE *ppc,
BYTE *ppk)
{

    int  k, w, pk, r, g, b;
    int  Est_x, Est_y;
    int  p1, p2;
    int  deg, area;
    register int  val_a, val_b, val_c, val_d;
    register int  val1,  val2;
    BYTE hosei;
    int  py, pm, pc;
    int  wx, wy;
    PCURRENTSTATUS lpnp;

    lpnp = (PCURRENTSTATUS)MINIDEV_DATA(pdevobj);

    k = max( bRed, bGreen );
    k = max( k, bBlue );

    // Set black element

    pk = 255 - k;

    w = min( bRed, bGreen );
    w = min( w, bBlue );

    // Cut white element from each color

    r = bRed - w;
    g = bGreen - w;
    b = bBlue - w;

    // Get estimation for Est_x and Est_y

    if( r == 0 ){                       // G->C->B

    if(( g == 0 ) && ( b == 0 )){   // no color

        Est_x = 0;
        Est_y = 0;

    }
    else if( g >= b ){              // G->C dimension

        p1 = (lpnp->RGB_Gx * g) / 255;
        p2 = (lpnp->RGB_Cx * g) / 255;
        Est_x = ((p2 - p1) * b) / g + p1;
        p1 = (lpnp->RGB_Gy * g) / 255;
        p2 = (lpnp->RGB_Cy * g) / 255;
        Est_y = ((p2 - p1) * b) / g + p1;

    }
    else {                          // B->C dimension

        p1 = (lpnp->RGB_Bx * b) / 255;
        p2 = (lpnp->RGB_Cx * b) / 255;
        Est_x = ((p2 - p1) * g) / b + p1;
        p1 = (lpnp->RGB_By * b) / 255;
        p2 = (lpnp->RGB_Cy * b) / 255;
        Est_y = ((p2 - p1) * g) / b + p1;

    }

    }
    else if( g == 0 ){                  // B->M->R

    if( b >= r ){                   // B->M dimension

        p1 = (lpnp->RGB_Bx * b) / 255;
        p2 = (lpnp->RGB_Mx * b) / 255;
        Est_x = ((p2 - p1) * r) / b + p1;
        p1 = (lpnp->RGB_By * b) / 255;
        p2 = (lpnp->RGB_My * b) / 255;
        Est_y = ((p2 - p1) * r) / b + p1;

    }
    else{                           // R->M dimension

        p1 = (lpnp->RGB_Rx * r) / 255;
        p2 = (lpnp->RGB_Mx * r) / 255;
        Est_x = ((p2 - p1) * b) / r + p1;
        p1 = (lpnp->RGB_Ry * r) / 255;
        p2 = (lpnp->RGB_My * r) / 255;
        Est_y = ((p2 - p1) * b) / r + p1;

    }

    }
    else{                               // G->Y->R

    if( g >= r ){                   // G->Y dimension

        p1 = (lpnp->RGB_Gx * g) / 255;
        p2 = (lpnp->RGB_Yx * g) / 255;
        Est_x = ((p2 - p1) * r) / g + p1;
        p1 = (lpnp->RGB_Gy * g) / 255;
        p2 = (lpnp->RGB_Yy * g) / 255;
        Est_y = ((p2 - p1) * r) / g + p1;

    }
    else{                           // R->Y dimension

        p1 = (lpnp->RGB_Rx * r) / 255;
        p2 = (lpnp->RGB_Yx * r) / 255;
        Est_x = ((p2 - p1) * g) / r + p1;
        p1 = (lpnp->RGB_Ry * r) / 255;
        p2 = (lpnp->RGB_Yy * r) / 255;
        Est_y = ((p2 - p1) * g) / r + p1;

    }

    }

    // Convert origin of Est_x and Est_y to paper color

    wx = lpnp->RGB_Wx ? lpnp->RGB_Wx : 1;
    wy = lpnp->RGB_Wy ? lpnp->RGB_Wy : 1;

    Est_x += lpnp->RGB_Wx;
    Est_y += lpnp->RGB_Wy;
    Est_x = Est_x * lpnp->CMY_Wx / wx;
    Est_y = Est_y * lpnp->CMY_Wy / wy;
    Est_x -= lpnp->CMY_Wx;
    Est_y -= lpnp->CMY_Wy;

    pc = pm = py = 0;

    if( !((Est_x == 0) && (Est_y == 0)) ){

    // Get deg on CMY color dimension from Est_x and Est_y

    if( Est_x == 0 ){

        if( Est_y > 0 )

        deg = 30000;

        else

        deg = -30000;

    }
    else{

        deg = Est_y / Est_x;

        if( deg > 300 )

        deg = 30000;

        else if( deg  < -300 )

        deg = -30000;

        else

        deg = ( Est_y * 100 ) / Est_x;

    }


    if( Est_x >= 0 ){

        if( deg <= lpnp->CMY_Md )       // M->B dimension

        area = 1;

        else if( deg <= lpnp->CMY_Rd )  // M->R dimension

        area = 2;

        else if( deg <= lpnp->CMY_Yd )  // Y->R dimension

        area = 3;

        else                            // Y->G dimension

        area = 4;

    }
    else{

        if( deg <= lpnp->CMY_Gd )       // Y->G dimension

        area = 4;

        else if( deg <= lpnp->CMY_Cd )  // C->G dimension

        area = 5;

        else if( deg <= lpnp->CMY_Bd )  // C->B dimension

        area = 6;

        else                            // M->B dimension

        area = 1;

    }

    switch ( area ){

    case 1:                             // M->B dimension

        val_a = lpnp->CMY_Bx - lpnp->CMY_Mx;
        val_b = lpnp->CMY_By - lpnp->CMY_My;
        val_c = lpnp->CMY_Mx;
        val_d = lpnp->CMY_My;

        val1 = val_b * val_c - val_a * val_d;
        val2 = ( val_b * Est_x - val_a * Est_y ) * 255;

        val1 = val1 ? val1 : 1;

        pm = val2 / val1;

        if( pm < 0 )
        pm = 0;

        val1 = val_a * val_d - val_b * val_c;
        val2 = ( val_d * Est_x - val_c * Est_y ) * 255;

        val1 = val1 ? val1 : 1;

        pc = val2 / val1;

        if( pc < 0 )
        pc = 0;

        if( pc > 255 )
        pc = 255;

        hosei = lpnp->BlueHosei[pc];

        pc += hosei;
        pm += hosei;

        if( pc > 255 )
        pc = 255;

        if( pm > 255 )
        pm = 255;

        break;

    case 2:                             // M->R dimension

        val_a = lpnp->CMY_Rx - lpnp->CMY_Mx;
        val_b = lpnp->CMY_Ry - lpnp->CMY_My;
        val_c = lpnp->CMY_Mx;
        val_d = lpnp->CMY_My;

        val1 = val_b * val_c - val_a * val_d;
        val2 = ( val_b * Est_x - val_a * Est_y ) * 255;

        val1 = val1 ? val1 : 1;

        pm = val2 / val1;

        if( pm < 0 )
        pm = 0;

        val1 = val_a * val_d - val_b * val_c;
        val2 = ( val_d * Est_x - val_c * Est_y ) * 255;

        val1 = val1 ? val1 : 1;

        py = val2 / val1;

        if( py < 0 )
        py = 0;

        if( py > 255 )
        py = 255;

        hosei = lpnp->RedHosei[py];

        py += hosei;
        pm += hosei;

        if( pm > 255 )
        pm = 255;

        if( py > 255 )
        py = 255;

        break;

    case 3:                             // Y->R dimension

        val_a = lpnp->CMY_Rx - lpnp->CMY_Yx;
        val_b = lpnp->CMY_Ry - lpnp->CMY_Yy;
        val_c = lpnp->CMY_Yx;
        val_d = lpnp->CMY_Yy;

        val1 = val_b * val_c - val_a * val_d;
        val2 = ( val_b * Est_x - val_a * Est_y ) * 255;

        val1 = val1 ? val1 : 1;

        py = val2 / val1;

        if( py < 0 )
        py = 0;

        val1 = val_a * val_d - val_b * val_c;
        val2 = ( val_d * Est_x - val_c * Est_y ) * 255;

        val1 = val1 ? val1 : 1;

        pm = val2 / val1;

        if( pm < 0 )
        pm = 0;

        if( pm > 255 )
        pm = 255;

        hosei = lpnp->RedHosei[pm];

        py += hosei;
        pm += hosei;

        if( pm > 255 )
        pm = 255;

        if( py > 255 )
        py = 255;

        break;

    case 4:                             // Y->G dimension

        val_a = lpnp->CMY_Gx - lpnp->CMY_Yx;
        val_b = lpnp->CMY_Gy - lpnp->CMY_Yy;
        val_c = lpnp->CMY_Yx;
        val_d = lpnp->CMY_Yy;

        val1 = val_b * val_c - val_a * val_d;
        val2 = ( val_b * Est_x - val_a * Est_y ) * 255;

        val1 = val1 ? val1 : 1;

        py = val2 / val1;

        if( py < 0 )
        py = 0;

        val1 = val_a * val_d - val_b * val_c;
        val2 = ( val_d * Est_x - val_c * Est_y ) * 255;

        val1 = val1 ? val1 : 1;

        pc = val2 / val1;

        if( pc < 0 )
        pc = 0;

        if( pc > 255 )
        pc = 255;

        hosei = lpnp->GreenHosei[pc];

        py += hosei;
        pc += hosei;

        if( pc > 255 )
        pc = 255;

        if( py > 255 )
        py = 255;

        break;

    case 5:                             // C->G dimension

        val_a = lpnp->CMY_Gx - lpnp->CMY_Cx;
        val_b = lpnp->CMY_Gy - lpnp->CMY_Cy;
        val_c = lpnp->CMY_Cx;
        val_d = lpnp->CMY_Cy;

        val1 = val_b * val_c - val_a * val_d;
        val2 = ( val_b * Est_x - val_a * Est_y ) * 255;

        val1 = val1 ? val1 : 1;

        pc = val2 / val1;

        if( pc < 0 )
        pc = 0;

        val1 = val_a * val_d - val_b * val_c;
        val2 = ( val_d * Est_x - val_c * Est_y ) * 255;

        val1 = val1 ? val1 : 1;

        py = val2 / val1;

        if( py < 0 )
        py = 0;

        if( py > 255 )
        py = 255;

        // Dwnsity adjustment for green
        hosei = lpnp->GreenHosei[py];

        py += hosei;
        pc += hosei;

        if( pc > 255 )
        pc = 255;

        if( py > 255 )
        py = 255;

        break;

    case 6:                             // C->B dimension

        val_a = lpnp->CMY_Bx - lpnp->CMY_Cx;
        val_b = lpnp->CMY_By - lpnp->CMY_Cy;
        val_c = lpnp->CMY_Cx;
        val_d = lpnp->CMY_Cy;

        val1 = val_b * val_c - val_a * val_d;
        val2 = ( val_b * Est_x - val_a * Est_y ) * 255;

        val1 = val1 ? val1 : 1;

        pc = val2 / val1;

        if( pc < 0 )
        pc = 0;

        val1 = val_a * val_d - val_b * val_c;
        val2 = ( val_d * Est_x - val_c * Est_y ) * 255;

        val1 = val1 ? val1 : 1;

        pm = val2 / val1;

        if( pm < 0 )
        pm = 0;

        if( pm > 255 )
        pm = 255;

        hosei = lpnp->BlueHosei[pm];

        pc += hosei;
        pm += hosei;

        if( pc > 255 )
        pc = 255;

        if( pm > 255 )
        pm = 255;

    } // switch area

    }

    // Add pk to color

    k = pc;

    if( k < pm )
    k = pm;

    if( k < py )
    k = py;

    r = ( pk  + k > 255) ? 255 - k : pk;

    pk -= r;
    pc += r;
    pm += r;
    py += r;


    // Extract K and adjust to other color for its extracting value

    if (bPlaneSendOrderCMYK(lpnp)) {

    int min_p;
    BYTE ucr_sub, ucr_div;

    min_p = min( py, pm );
    min_p = min( min_p, pc );

#ifdef BLACK_RIBBON_HACK
    if( min_p == 255 ){
        pk = 255;
        pc = pm = py = 0;
    }
    else{
#endif // BLACK_RIBBOM_HACK

    pk += lpnp->KuroTBL[min_p];
    pk = ( pk > 255 ) ? 255 : pk;

    ucr_sub = lpnp->UcrTBL[min_p];
    ucr_div = 255 - ucr_sub;

    ucr_div = ucr_div ? ucr_div : 1;

    py = (BYTE)((UINT)(py - ucr_sub) * lpnp->YellowUcr / ucr_div);
    pm = (BYTE)((UINT)(pm - ucr_sub) * 255 / ucr_div);
    pc = (BYTE)((UINT)(pc - ucr_sub) * 255 / ucr_div);

#ifdef BLACK_RIBBON_HACK
    }
#endif // BLACK_RIBBON_HACK

    }

    py = 255 - py;
    pm = 255 - pm;
    pc = 255 - pc;
    pk = 255 - pk;

    *ppy = (BYTE)py;
    *ppm = (BYTE)pm;
    *ppc = (BYTE)pc;
    *ppk = (BYTE)pk;

    return TRUE;
}
/*************************** Function Header *******************************
 *  bBusinessConvert
 *
 *  Convert RGB to CMYK for business graphics.
 *
 *
 * HISTORY:
 *  24 Jun 1996    -by-    Sueya Sugihara    [sueyas]
 *     Created.
 *
 ***************************************************************************/
BOOL bBusinessConvert(
PDEVOBJ pdevobj,
BYTE bRed,
BYTE bGreen,
BYTE bBlue,
BYTE *ppy,
BYTE *ppm,
BYTE *ppc,
BYTE *ppk)
{
    int    py, pm, pc, pk;
    int    min_p;
    BYTE   ucr_sub, ucr_div;
    PCURRENTSTATUS lpnp;

    lpnp = (PCURRENTSTATUS)MINIDEV_DATA(pdevobj);

    // Simple convert RGB to CMY

    py = 255 - bBlue;
    pm = 255 - bGreen;
    pc = 255 - bRed;
    pk = 0;

    // Extract K and adjust to other color for its extracting value

    // Extract pk from py, pm and pc by using followings, and erase black element.

    // When this media is 3 plane type, we do not extract black.

    if (bPlaneSendOrderCMYK(lpnp)) {

    min_p = min( py, pm );
    min_p = min( min_p, pc );

#ifdef BLACK_RIBBON_HACK
    if( min_p == 255 ){
        pk = 255;
        pc = pm = py = 0;
    }
    else{
#endif // BLACK_RIBBON_HACK

    pk = lpnp->KuroTBL[min_p];

    ucr_sub = lpnp->UcrTBL[min_p];

    ucr_div = 255 - ucr_sub;

    ucr_div = ucr_div ? ucr_div : 1;

    py = (BYTE)((UINT)(py - ucr_sub) * lpnp->YellowUcr / ucr_div);
    pm = (BYTE)((UINT)(pm - ucr_sub) * 255 / ucr_div);
    pc = (BYTE)((UINT)(pc - ucr_sub) * 255 / ucr_div);

#ifdef BLACK_RIBBON_HACK
    }
#endif // BLACK_RIBBON_HACK

    }

    py = 255 - py;
    pm = 255 - pm;
    pc = 255 - pc;
    pk = 255 - pk;

    *ppy = (BYTE)py;
    *ppm = (BYTE)pm;
    *ppc = (BYTE)pc;
    *ppk = (BYTE)pk;

    return TRUE;
}

/*************************** Function Header *******************************
 *  bCharacterConvert
 *
 *  Convert RGB to CMYK for character graphics.
 *
 *
 * HISTORY:
 *  24 Jun 1996    -by-    Sueya Sugihara    [sueyas]
 *     Created.
 *
 ***************************************************************************/
BOOL bCharacterConvert(
PDEVOBJ pdevobj,
BYTE bRed,
BYTE bGreen,
BYTE bBlue,
BYTE *ppy,
BYTE *ppm,
BYTE *ppc,
BYTE *ppk)
{
    int    py, pm, pc, pk;
    int    min_p;
    BYTE   ucr_sub, ucr_div;
    PCURRENTSTATUS lpnp;

    lpnp = (PCURRENTSTATUS)MINIDEV_DATA(pdevobj);

    // Simple convert RGB to CMY

    py = 255 - bBlue;
    pm = 255 - bGreen;
    pc = 255 - bRed;
    pk = 0;

    // Extract K and adjust to other color for its extracting value

    // Extract pk from py, pm and pc by using followings, and erase black element.

    // When this media is 3 plane type, we do not extract black.

    if (bPlaneSendOrderCMYK(lpnp)) {

    min_p = min( py, pm );
    min_p = min( min_p, pc );

    if( min_p == 255 ){

        pk = 255;
        pc = pm = py = 0;

    }
    else{

        pk = lpnp->KuroTBL[min_p];

        ucr_sub = lpnp->UcrTBL[min_p];

        ucr_div = 255 - ucr_sub;

        ucr_div = ucr_div ? ucr_div : 1;

        py = (BYTE)((UINT)(py - ucr_sub) * lpnp->YellowUcr / ucr_div);
        pm = (BYTE)((UINT)(pm - ucr_sub) * 255 / ucr_div);
        pc = (BYTE)((UINT)(pc - ucr_sub) * 255 / ucr_div);

    }
    }

    py = 255 - py;
    pm = 255 - pm;
    pc = 255 - pc;
    pk = 255 - pk;

    *ppy = (BYTE)py;
    *ppm = (BYTE)pm;
    *ppc = (BYTE)pc;
    *ppk = (BYTE)pk;

    return TRUE;
}
/*************************** Function Header *******************************
 *  bMonoConvert
 *
 *  Convert RGB to Grayscale.
 *
 *
 * HISTORY:
 *  24 Jun 1996    -by-    Sueya Sugihara    [sueyas]
 *     Created.
 *
 ***************************************************************************/
BOOL bMonoConvert(
PDEVOBJ pdevobj,
BYTE bRed,
BYTE bGreen,
BYTE bBlue,
BYTE *ppk)
{
    int    mono;

    mono = ( 30 * bRed + 59 * bGreen + 11 * bBlue ) / 100;

    *ppk = 0xff - (BYTE)( mono & 0xff );


    return TRUE;

}


/*************************** Function Header *******************************
 *  cVDColorDither
 *
 *  VD Color Dither processing
 *
 *
 * HISTORY:
 *  11 Jan 1999    -by-    Yoshitaka Oku    [yoshitao]
 *     Created.
 *
 *    BYTE Color : Plane Color <Yellow, Cyan, Magenta, Black>
 *    BYTE c     : oliginal tone of the pixel
 *    int  x     : X position of the pixel
 *    int  y     : Y position of the pixel
 *
 ***************************************************************************/
cVDColorDither(
BYTE Color,
BYTE c,
int  x,
int  y)
{
    int   m, n;
    short Base;
    BYTE  Tone;
    BYTE  C_Thresh, Thresh;
    short AdjustedColor;
    BYTE  TempTone;
    BYTE  BaseTone;

    switch (Color) {
        case Yellow:
            Base = 112;
            m = n = 12;
            break;

        case Cyan:
        case Magenta:
            Base = 208;
            m = n = 40;
            break;

        case Black:
            Base = 96;
            m = n = 24;
            break;
        default:
            Color = Black;
            Base = 96;
            m = n = 24;
            break;
    }

    Tone = 0;                   /* Clear Tone value */
    c = VD_ColorAdjustTable[Color][c];  /* Convert orignal color */ 
    if (c != 0) {
        C_Thresh = (VD_DitherTable[Color][y % m][x % n]);
        if ( C_Thresh < 16 )
            Thresh = 1;
        else {
            C_Thresh -= 16;
            Thresh = (C_Thresh >> 2) + 1;
        }
        AdjustedColor = VD_ExpandValueTable[Color][c] - 1;
        if ( AdjustedColor < Base )
            TempTone = ( AdjustedColor >> 4 ) + 1;
        else {
            AdjustedColor -= Base;
            TempTone = ( AdjustedColor >> 2 ) + ( Base >> 4 ) + 1;
        }
        if (TempTone >= 232) TempTone = 232-1;
        BaseTone = VD_ToneOptimaizeTable[Color][TempTone].base;
        if ( BaseTone > Thresh ) {
            Tone = 15;
        } else {
            if ( BaseTone == Thresh ) {
                if ( BaseTone == 1 )  {
                    if (( AdjustedColor & 0x0f ) >= C_Thresh )
                        Tone = VD_ToneOptimaizeTable[Color][(( AdjustedColor >> 4) & 0x0f )+ 1 ].offset;
                    else
                        Tone = VD_ToneOptimaizeTable[Color][( AdjustedColor >> 4) & 0x0f ].offset ;	
                } else {
                    if ((AdjustedColor & 0x03) >= (C_Thresh & 0x03))
                        Tone = VD_ToneOptimaizeTable[Color][TempTone].offset;
                    else {
                        if (TempTone < 1) TempTone = 1;
                        if (VD_ToneOptimaizeTable[Color][TempTone -1].base == BaseTone)
                            Tone = VD_ToneOptimaizeTable[Color][TempTone -1].offset;
                    }
                }
            }
        }
    }
    return (Tone);
}





/*************************** Function Header *******************************
 *  bDitherProcess
 *
 *  Dither processing
 *
 *
 * HISTORY:
 *  24 Jun 1996    -by-    Sueya Sugihara    [sueyas]
 *     Created.
 *
 ***************************************************************************/
BOOL bDitherProcess(
PDEVOBJ pdevobj,
int  x,
BYTE py,
BYTE pm,
BYTE pc,
BYTE pk,
BYTE *pby,
BYTE *pbm,
BYTE *pbc,
BYTE *pbk)
{

    PCURRENTSTATUS lpnp;
    BYTE           rm;

    lpnp = (PCURRENTSTATUS)MINIDEV_DATA(pdevobj);


    if( lpnp->iDither == DITHER_VD ){

    // Yellow
    *pby = (BYTE)cVDColorDither(Yellow, (BYTE)(255 - py), x, lpnp->y);

    // Magenta
    *pbm = (BYTE)cVDColorDither(Magenta, (BYTE)(255 - pm), x, lpnp->y);

    // Cyan
    *pbc = (BYTE)cVDColorDither(Cyan, (BYTE)(255 - pc), x, lpnp->y);

    // Black
    *pbk = (BYTE)cVDColorDither(Black, (BYTE)(255 - pk), x, lpnp->y);

    }else if( lpnp->iDither == DITHER_DYE ){

    rm = DYE_NewTable[lpnp->y % DYE_MaxY][x % DYE_MaxX];

    // Yellow
    *pby = ( (255 - py) / kToneLevel ) + ( ( ( (255 - py) % kToneLevel ) > rm ) ? 1 : 0 );

    // Magenta
    *pbm = ( (255 - pm) / kToneLevel ) + ( ( ( (255 - pm) % kToneLevel ) > rm ) ? 1 : 0 );

    // Cyan
    *pbc = ( (255 - pc) / kToneLevel ) + ( ( ( (255 - pc) % kToneLevel ) > rm ) ? 1 : 0 );

    // Black
    *pbk = 0;

    }else if( lpnp->iDither == DITHER_HIGH ){

    // Yellow
    rm = H_NewTable[Yellow][lpnp->y % H_MaxY[Yellow]][x % H_MaxX[Yellow]];

    *pby = ( py <= rm ) ? 1 : 0;

    // Magenta
    rm = H_NewTable[Magenta][lpnp->y % H_MaxY[Magenta]][x % H_MaxX[Magenta]];

    *pbm = ( pm <= rm ) ? 1 : 0;

    // Cyan
    rm = H_NewTable[Cyan][lpnp->y % H_MaxY[Cyan]][x % H_MaxX[Cyan]];

    *pbc = ( pc <= rm ) ? 1 : 0;

    // Black
    rm = H_NewTable[Black][lpnp->y % H_MaxY[Black]][x % H_MaxX[Black]];

    if( lpnp->iTextQuality == CMDID_TEXTQUALITY_PHOTO )
        *pbk = ( pk < rm ) ? 1 : 0;
    else
        *pbk = ( pk <= rm ) ? 1 : 0;

    }else if( lpnp->iDither == DITHER_LOW ){

    // Yellow
    rm = L_NewTable[Yellow][lpnp->y % L_MaxY[Yellow]][x % L_MaxX[Yellow]];

    *pby = ( py <= rm ) ? 1 : 0;

    // Magenta
    rm = L_NewTable[Magenta][lpnp->y % L_MaxY[Magenta]][x % L_MaxX[Magenta]];

    *pbm = ( pm <= rm ) ? 1 : 0;

    // Cyan
    rm = L_NewTable[Cyan][lpnp->y % L_MaxY[Cyan]][x % L_MaxX[Cyan]];

    *pbc = ( pc <= rm ) ? 1 : 0;

    // Black
    rm = L_NewTable[Black][lpnp->y % L_MaxY[Black]][x % L_MaxX[Black]];

    if( lpnp->iTextQuality == CMDID_TEXTQUALITY_PHOTO )
        *pbk = ( pk < rm ) ? 1 : 0;
    else
        *pbk = ( pk <= rm ) ? 1 : 0;

    }else{ // DITHER_HIGH_DIV2

    // Yellow
    rm = H_NewTable[Yellow][(lpnp->y/2) % H_MaxY[Yellow]][(x/2) % H_MaxX[Yellow]];

    *pby = ( py <= rm ) ? 1 : 0;

    // Magenta
    rm = H_NewTable[Magenta][(lpnp->y/2) % H_MaxY[Magenta]][(x/2) % H_MaxX[Magenta]];

    *pbm = ( pm <= rm ) ? 1 : 0;

    // Cyan
    rm = H_NewTable[Cyan][(lpnp->y/2) % H_MaxY[Cyan]][(x/2) % H_MaxX[Cyan]];

    *pbc = ( pc <= rm ) ? 1 : 0;

    // Black
    rm = H_NewTable[Black][(lpnp->y/2) % H_MaxY[Black]][(x/2) % H_MaxX[Black]];

    if( lpnp->iTextQuality == CMDID_TEXTQUALITY_PHOTO )
        *pbk = ( pk < rm ) ? 1 : 0;
    else
        *pbk = ( pk <= rm ) ? 1 : 0;
    }


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\alpsres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

// NTRAID#NTBUG9-553877-2002/02/28-yasuho-: Security: mandatory changes

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>
#include <strsafe.h>

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)   "ERROR " DLLTEXT(s)

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'ALPS'      // ALPS MD Series
#define DLLTEXT(s)      "ALPSRES: " s
#define OEM_VERSION      0x00010000L

// ####

//
// Minidriver device data block which we maintain.
// Its address is saved in the DEVOBJ.pdevOEM of
// OEM customiztion I/F.
//

typedef struct {
    VOID *pData; // Minidriver private data.
    VOID *pIntf; // a.k.a. pOEMHelp
} MINIDEV;

//
// Easy access to the OEM data and the printer
// driver helper functions.
//

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

    extern
    HRESULT
    XXXDrvWriteSpoolBuf(
        VOID *pIntf,
        PDEVOBJ pDevobj,
        PVOID pBuffer,
        DWORD cbSize,
        DWORD *pdwResult);

#ifdef __cplusplus
}
#endif // __cplusplus

#define MINIDEV_DATA(p) \
    (((MINIDEV *)(p)->pdevOEM)->pData)

#define MINIDEV_INTF(p) \
    (((MINIDEV *)(p)->pdevOEM)->pIntf)

#define WRITESPOOLBUF(pdevobj, cmd, len) \
    (pdevobj)->pDrvProcs->DrvWriteSpoolBuf(pdevobj, cmd, len)

#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\alpsres\compress.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#include        <windows.h>

#define TIFF_MIN_RUN       4            /* Minimum repeats before use RLE */
#define TIFF_MAX_RUN     128            /* Maximum repeats */
#define TIFF_MAX_LITERAL 128            /* Maximum consecutive literal data */

int
iCompTIFF( pbOBuf, cbO, pbIBuf, cb )
BYTE  *pbOBuf;         /* Output buffer,  PRESUMED BIG ENOUGH: see above */
int    cbO;            /* Output buffer size */
BYTE  *pbIBuf;         /* Raster data to send */
int    cb;             /* Number of bytes in the above */
{
    BYTE   *pbOut;        /* Output byte location */
    BYTE   *pbStart;      /* Start of current input stream */
    BYTE   *pb;           /* Miscellaneous usage */
    BYTE   *pbEnd;        /* The last byte of input */
    BYTE    jLast;        /* Last byte,  for match purposes */
    BYTE   *pbOEnd;       /* The last byte of Output buffer */

    int     cSize;        /* Bytes in the current length */
    int     cSend;        /* Number to send in this command */


    pbOut = pbOBuf;
    pbStart = pbIBuf;

	pbEnd  = pbIBuf + cb;         /* The last byte */
	pbOEnd = pbOBuf + cbO;        /* The last byte of Output buffer */

    jLast = *pbIBuf++;

    while( pbIBuf < pbEnd )
    {
        if( jLast == *pbIBuf )
        {
            /*  Find out how long this run is.  Then decide on using it */

            for( pb = pbIBuf; pb < pbEnd && *pb == jLast; ++pb )
                                   ;

            /*
             *   Note that pbIBuf points at the SECOND byte of the pattern!
             *  AND also that pb points at the first byte AFTER the run.
             */

            if( (pb - pbIBuf) >= (TIFF_MIN_RUN - 1) )
            {
                /*
                 *    Worth recording as a run,  so first set the literal
                 *  data which may have already been scanned before recording
                 *  this run.
                 */

                if( (cSize = (int)(pbIBuf - pbStart - 1)) > 0 )
                {
                    /*   There is literal data,  so record it now */
                    while( (cSend = min( cSize, TIFF_MAX_LITERAL )) > 0 )
                    {
						// Buffer over run check
						if ( (pbOut+cSend)<=pbOEnd ) {
                            *pbOut++ = cSend - 1;
                            CopyMemory( pbOut, pbStart, cSend );
                            pbOut += cSend;
                            pbStart += cSend;
                            cSize -= cSend;
						} else {
							return 0;
					    }
                    }
                }

                /*
                 *   Now for the repeat pattern.  Same logic,  but only
                 * one byte is needed per entry.
                 */

                cSize = (int)(pb - pbIBuf + 1);

                while( (cSend = min( cSize, TIFF_MAX_RUN )) > 0 )
                {
					// Buffer over run check
					if ( (pbOut+2)<=pbOEnd ) {
						*pbOut++ = 1 - cSend;        /* -ve indicates repeat */
						*pbOut++ = jLast;
						cSize -= cSend;
					} else {
						return 0;
					}
                }

                pbStart = pb;           /* Ready for the next one! */
            }
            pbIBuf = pb;                /* Start from this position! */
        }
        else
            jLast = *pbIBuf++;                   /* Onto the next byte */
 
    }

    if( pbStart < pbIBuf )
    {
        /*  Left some dangling.  This can only be literal data.   */

        cSize = (int)(pbIBuf - pbStart);

        while( (cSend = min( cSize, TIFF_MAX_LITERAL )) > 0 )
        {
			// Buffer over run check
			if ( (pbOut+cSend)<=pbOEnd ) {
				*pbOut++ = cSend - 1;
				CopyMemory( pbOut, pbStart, cSend );
				pbOut += cSend;
				pbStart += cSend;
				cSize -= cSend;
			} else {
				return 0;
			}
        }
    }

    return  (int)(pbOut - pbOBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\alpsres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:


Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

// NTRAID#NTBUG9-553877-2002/02/28-yasuho-: Security: mandatory changes
// NTRAID#NTBUG9-576661-2002/03/14-yasuho-: Remove the dead codes
// NTRAID#NTBUG9-588563-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:    
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid,
        void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
        }
        else
        {
            *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));

        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release() 
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));

        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this;
            return 0;
        }
        return m_cRef;
    }

    //
    // IPrintOemCommon methods
    //

    STDMETHODIMP
        DevMode(
        DWORD dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // IPrintOemEngine methods
    //

    STDMETHODIMP
    EnableDriver(
    DWORD dwDriverVersion,
    DWORD cbSize,
    PDRVENABLEDATA pded)
{
    VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

//
// Function Name: DisableDriver
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

    STDMETHODIMP
    DisableDriver(VOID)
{
    VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

        PDEVOEM pTemp;

        pTemp = OEMEnablePDEV(pdevobj,
            pPrinterName, cPatterns, phsurfPatterns,
            cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);

        if (NULL == pTemp) {
            return E_FAIL;
        }

        //
        // Save necessary helpder function addresses.
        //

        ((MINIDEV *)pTemp)->pIntf = this->pOEMHelp;
        *pDevOem = pTemp;

        return S_OK;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
    PDEVOBJ pdevobj)
    {
        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

        OEMDisablePDEV(pdevobj);
        return S_OK;
    }

//
// Function Name: ResetPDEV
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

    STDMETHODIMP
    ResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));

    if (OEMResetPDEV(pdevobjOld, pdevobjNew)) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

    //
    // IPrintOemUni methods
    //

    STDMETHODIMP
    PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

//
// Function Name: GetImplementationMethod
// Plug-in: Rendering module
// Driver: Any
// Type: Mandatory
//

static
int __cdecl
iCompNames(
    const void *p1,
    const void *p2) {

    return strcmp(
        *((char **)p1),
        *((char **)p2));
}

    STDMETHODIMP
    GetImplementedMethod(
    PSTR pMethodName)
{
    LONG lRet = E_NOTIMPL;
    PSTR pTemp;

    VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

    if (NULL != pMethodName) {

        pTemp = (PSTR)bsearch(
            &pMethodName,
            gMethodsSupported,
            (sizeof (gMethodsSupported) / sizeof (PSTR)),
            sizeof (PSTR),
            iCompNames);

        if (NULL != pTemp)
            lRet = S_OK;
    }

    VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

    return lRet;
}

//
// Function Name: DriverDMS
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: CommandCallback
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    CommandCallback(
    PDEVOBJ pdevobj,
    DWORD dwCallbackID,
    DWORD dwCount,
    PDWORD pdwParams,
    OUT INT *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    if (*piResult >= 0)
        return S_OK;
    else
        return E_FAIL;
}

//
// Function Name: ImageProcessing
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: FilterGraphics
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    FilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    if (TRUE != OEMFilterGraphics(pdevobj, pBuf, dwLen)) {
        return E_FAIL;
    }
    return S_OK;
}

//
// Function Name: Compression
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: HalftonePattern
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: MemoryUsge
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TTYGetInfo
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DownloadFontHeader
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DownloadCharGlyph
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TTDonwloadMethod
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: OutputCharStr
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: SendFontCmd
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TextOutputAsBitmap
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
    return E_NOTIMPL;
}

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

// XXXDrvWriteSpoolBuf() - Obsolete.

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

///////////////////////////////////////////////////////////
//
// Class factory body
//
    STDMETHODIMP_(HRESULT)
    QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

    STDMETHODIMP_(ULONG)
    AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

    STDMETHODIMP_(ULONG)
    Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation

    STDMETHODIMP_(HRESULT)
    CreateInstance(
    IUnknown *pUnknownOuter,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

    // Cannot aggregate.
    if (NULL != pUnknownOuter) {

        return CLASS_E_NOAGGREGATION;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB;
    if (NULL == pOemCB) {

        return E_OUTOFMEMORY;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release();
    return hr ;
}

// LockServer
    STDMETHODIMP_(HRESULT)
    LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK ;
}

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

///////////////////////////////////////////////////////////
//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\alpsres\dtable.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/





static int H_MaxX[4] =
{
    15, 18, 68, 68        //YCMK
};
static int H_MaxY[4] =
{
    10, 12, 68, 68        //YCMK
};
static int L_MaxX[4] =
{
    12, 9, 20, 20         //YCMK
};
static int L_MaxY[4] =
{
    12, 9, 20, 20         //YCMK
};

#define M_MaxX   14
#define M_MaxY   14
#define OHP_MaxX  8
#define OHP_MaxY  8
#define DYE_MaxX  17
#define DYE_MaxY  17
#define kToneLevel 17

static unsigned char H_NewTable[4][68][68] =
{
 { // Yellow
  {1,42,77,39,1,1,19,52,16,1,1,29,62,26,1},
  {3,138,177,154,8,8,133,159,144,1,1,133,169,149,3},
  {85,200,253,230,95,80,195,235,220,90,82,197,243,225,93},
  {85,189,205,218,95,80,182,202,207,90,82,184,202,212,93},
  {1,103,133,110,1,1,98,118,105,1,1,100,128,108,1},
  {1,24,57,21,1,1,36,70,34,1,1,14,47,11,1},
  {1,133,164,146,1,1,136,174,151,6,6,133,156,141,1},
  {82,195,240,223,93,82,197,248,228,95,80,192,233,220,87},
  {82,182,202,210,93,82,187,202,215,95,80,179,200,205,87},
  {1,98,123,108,1,1,100,131,110,1,1,95,113,105,1}
 },
 { // Cyan
  {138,90,29,26,52,210,141,93,34,34,54,215,144,95,24,24,49,205},
  {105,1,1,26,238,159,108,16,16,34,243,161,110,6,6,24,233,159},
  {65,1,1,179,151,123,70,16,16,184,154,128,75,6,6,172,149,121},
  {44,59,223,146,100,47,47,62,228,149,103,39,39,57,218,144,98,44},
  {44,251,167,116,8,8,47,253,169,118,1,1,39,248,164,113,19,19},
  {197,156,133,82,8,8,202,156,136,87,1,1,192,154,131,77,19,19},
  {141,93,36,36,54,218,144,95,24,24,49,207,138,90,29,31,52,212},
  {108,14,14,36,246,161,110,3,3,24,235,159,105,1,1,31,240,159},
  {72,14,14,189,154,128,75,3,3,174,149,121,67,1,1,182,151,126},
  {47,62,230,149,103,39,39,57,220,144,98,42,42,59,225,146,100,47},
  {47,253,169,118,21,21,39,248,164,113,1,1,42,251,167,116,11,11},
  {205,156,136,87,21,21,195,154,131,80,1,1,200,156,133,85,11,11}
 },
 { // Magenta
  {19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19},
  {253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47},
  {182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189},
  {131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98},
  {1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70},
  {52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31},
  {195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207},
  {138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154},
  {77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98},
  {29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8},
  {205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220},
  {151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164},
  {95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110},
  {14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14},
  {223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246},
  {167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179},
  {113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126},
  {6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6},
  {233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57},
  {177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197},
  {123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141},
  {11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82},
  {42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21},
  {184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200},
  {133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144},
  {62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87},
  {39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19},
  {215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225},
  {159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172},
  {103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116},
  {1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1},
  {218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230},
  {161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174},
  {105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121},
  {16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16},
  {248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49},
  {182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192},
  {128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136},
  {3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72},
  {54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34},
  {197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210},
  {138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156},
  {80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100},
  {26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6},
  {205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220},
  {136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164},
  {93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108},
  {11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11},
  {223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243},
  {167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179},
  {113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126},
  {8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8},
  {238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59},
  {177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200},
  {123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141},
  {14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85},
  {44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24},
  {187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202},
  {133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146},
  {65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90},
  {36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16},
  {212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225},
  {156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169},
  {103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116},
  {3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3},
  {215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228},
  {161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174},
  {105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118}
 },
 { // Black
  {19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80},
  {184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105},
  {118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90},
  {3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3},
  {3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3},
  {238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174},
  {187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110},
  {136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16},
  {31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16},
  {233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251},
  {215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197},
  {128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159},
  {36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21},
  {77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220},
  {103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200},
  {85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121},
  {8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67},
  {8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82},
  {179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108},
  {113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100},
  {14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14},
  {14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14},
  {248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182},
  {195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116},
  {154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6},
  {24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6},
  {225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240},
  {205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192},
  {123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138},
  {47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26},
  {82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230},
  {105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210},
  {93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126},
  {16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44},
  {16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80},
  {184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105},
  {118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90},
  {1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1},
  {1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1},
  {235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172},
  {187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110},
  {133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19},
  {34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19},
  {233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253},
  {218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197},
  {131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167},
  {39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21},
  {77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223},
  {103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202},
  {87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121},
  {6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62},
  {6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82},
  {177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108},
  {113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98},
  {11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11},
  {11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11},
  {246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182},
  {195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116},
  {149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8},
  {24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8},
  {228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243},
  {207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192},
  {123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144},
  {52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29},
  {82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230},
  {108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212},
  {95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126},
  {19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42}
 }
};

static unsigned char L_NewTable[4][20][20] =
{
 { // Yellow
  {254,254,239,182,133,133,243,243,228,171,122,122},
  {239,239,224,182,118,118,228,228,213,171,107,107},
  {224,224,209,167,118,118,213,213,205,152,107,107},
  {201,201,186,167,103,103,190,190,186,152,92,92},
  {148,148,58,43,28,28,137,137,47,32,9,9},
  {88,84,58,43,24,24,65,62,47,32,5,5},
  {246,246,231,175,126,126,250,250,235,179,130,130},
  {231,231,216,175,111,111,235,235,220,179,114,114},
  {216,216,205,156,111,111,220,220,209,163,114,114},
  {194,194,186,156,96,96,197,197,186,160,99,99},
  {141,141,50,35,13,13,145,145,54,39,20,20},
  {73,69,50,35,1,1,81,77,54,39,16,16}
 },
 { // Cyan
  {34,27,23,199,247,247,217,93,78},
  {12,9,9,195,236,236,217,122,71},
  {12,1,1,133,188,181,140,129,64},
  {173,166,144,89,56,45,42,115,151},
  {232,228,214,86,38,31,31,107,210},
  {254,254,221,75,20,5,5,104,206},
  {239,239,221,67,16,1,1,100,195},
  {192,184,148,148,159,155,144,111,137},
  {49,53,60,203,225,225,214,96,82}
 },
 { // Magenta
  {13,253,253,219,182,137,137,223,223,208,163,118,118,152,144,114,107,54,39,13},
  {9,242,234,219,174,129,129,201,193,186,156,58,58,69,69,92,80,54,31,9},
  {137,227,227,212,167,122,122,148,140,110,103,50,24,5,5,246,246,216,178,133},
  {129,204,197,189,159,62,62,65,65,77,73,46,16,1,1,238,231,216,171,125},
  {122,152,144,114,107,54,39,13,13,253,253,219,182,137,137,223,223,208,163,118},
  {62,69,69,92,80,54,31,9,9,242,234,219,174,129,129,201,193,186,156,58},
  {39,5,5,246,246,216,178,133,133,227,227,212,167,122,122,148,140,110,103,50},
  {31,1,1,238,231,216,171,125,125,204,197,189,159,62,62,65,65,77,73,46},
  {182,137,137,223,223,208,163,118,118,152,144,114,107,54,39,13,13,253,253,219},
  {174,129,129,201,193,186,156,58,58,69,69,92,80,54,31,9,9,242,234,219},
  {167,122,122,148,140,110,103,50,24,5,5,246,246,216,178,133,133,227,227,212},
  {159,62,62,65,65,77,73,46,16,1,1,238,231,216,171,125,125,204,197,189},
  {107,54,39,13,13,253,253,219,182,137,137,223,223,208,163,118,118,152,144,114},
  {80,54,31,9,9,242,234,219,174,129,129,201,193,186,156,58,58,69,69,92},
  {246,216,178,133,133,227,227,212,167,122,122,148,140,110,103,50,24,5,5,246},
  {231,216,171,125,125,204,197,189,159,62,62,65,65,77,73,46,16,1,1,238},
  {223,208,163,118,118,152,144,114,107,54,39,5,5,253,253,219,182,137,137,223},
  {193,186,156,58,58,69,69,92,80,54,31,1,1,242,234,219,174,129,129,201},
  {140,110,103,50,24,5,5,246,246,216,178,133,133,227,227,212,167,122,122,148},
  {65,77,73,46,16,1,1,238,231,216,171,125,125,204,197,189,159,62,62,65}
 },
 { // Black
  {162,162,170,202,194,186,154,154,6,78,118,114,102,26,30,90,134,134,106,38},
  {22,74,66,54,46,14,146,146,182,230,234,242,246,254,30,82,122,122,106,38},
  {34,94,142,142,106,42,166,166,178,226,222,210,162,158,2,78,110,110,98,26},
  {34,86,130,126,106,42,18,70,62,50,46,10,150,150,174,218,214,238,242,250},
  {6,78,118,114,102,26,30,90,134,134,106,38,162,162,170,202,194,186,154,154},
  {182,230,234,242,246,254,30,82,122,122,106,38,22,74,66,54,46,14,146,146},
  {178,226,222,210,162,158,2,78,110,110,98,26,34,94,142,142,106,42,166,166},
  {62,50,46,10,150,150,174,218,214,238,242,250,34,86,130,126,106,42,18,70},
  {134,134,106,38,162,162,170,202,194,186,154,154,6,78,118,114,102,26,30,90},
  {122,122,106,38,22,74,66,54,46,14,146,146,182,230,234,242,246,254,30,82},
  {110,110,98,26,34,94,142,142,106,42,166,166,178,226,222,210,162,158,2,78},
  {214,238,242,250,34,86,130,126,106,42,18,70,62,50,46,10,150,150,174,218},
  {194,186,154,154,6,78,118,114,102,26,30,90,134,134,106,38,162,162,170,202},
  {46,14,146,146,182,230,234,242,246,254,30,82,122,122,106,38,22,74,66,54},
  {106,42,166,166,178,226,222,210,162,158,2,78,110,110,98,26,34,94,142,142},
  {106,42,18,70,62,50,46,10,150,150,174,218,214,238,242,250,34,86,130,126},
  {102,26,30,90,134,134,106,38,162,162,170,202,194,186,154,154,6,78,118,114},
  {246,254,30,82,122,122,106,38,22,74,66,54,46,14,146,146,182,230,234,242},
  {162,158,2,78,110,110,98,26,34,94,142,142,106,42,166,166,178,226,222,210},
  {150,150,174,218,214,238,242,250,34,86,130,126,106,42,18,70,62,50,46,10}
 }
};

static unsigned char M_NewTable[14][14] =
{
 {21,72,154,149,93,67,11,19,70,151,146,90,65,8},
 {77,159,200,195,144,138,62,75,156,197,192,141,136,59},
 {164,205,251,246,230,189,133,161,202,248,243,228,187,131},
 {169,210,240,235,225,184,128,167,207,238,233,223,182,126},
 {98,174,220,215,179,123,87,95,172,218,212,177,121,85},
 {36,103,108,113,118,82,31,34,100,105,110,116,80,29},
 {16,42,47,52,57,26,6,14,39,44,49,54,24,255},
 {19,70,151,146,90,65,8,21,72,154,149,93,67,11},
 {75,156,197,192,141,136,59,77,159,200,195,144,138,62},
 {161,202,248,243,228,187,131,164,205,251,246,230,189,133},
 {167,207,238,233,223,182,126,169,210,240,235,225,184,128},
 {95,172,218,212,177,121,85,98,174,220,215,179,123,87},
 {34,100,105,110,116,80,29,36,103,108,113,118,82,31},
 {14,39,44,49,54,24,1,16,42,47,52,57,26,3}
};

static unsigned char OHP_NewTable[8][8] =
{
 {110,94,102,126,146,162,154,130},
 {38,30,22,78,218,226,234,178},
 {46,6,14,86,210,250,242,170},
 {70,54,62,118,186,202,194,138},
 {150,166,158,134,106,90,98,122},
 {222,230,238,182,34,26,18,74},
 {214,254,246,174,42,2,10,82},
 {190,206,198,142,66,50,58,114}
};

static unsigned char DYE_NewTable[17][17] =
{
 {1,14,4,13,1,14,4,10,5,12,15,3,6,13,7,3,15},
 {12,7,16,6,12,5,12,2,14,4,8,13,9,1,17,10,6},
 {3,11,2,11,4,17,7,15,6,17,10,2,16,11,5,9,16},
 {13,5,17,7,14,8,2,9,11,1,6,14,7,3,14,2,10},
 {8,15,3,13,1,10,16,4,15,8,15,4,10,17,5,13,4},
 {1,10,9,5,15,6,11,9,3,13,2,12,8,1,11,8,17},
 {13,5,17,11,3,14,2,17,10,7,16,5,13,6,15,3,9},
 {3,12,2,6,12,7,13,5,12,4,9,14,4,16,10,6,15},
 {14,8,16,9,15,3,8,16,1,15,8,1,12,7,2,12,7},
 {10,4,10,1,6,17,10,5,11,6,11,17,5,15,8,17,1},
 {16,6,13,8,14,9,2,14,3,13,2,9,12,3,11,4,11},
 {3,14,2,16,3,7,13,7,17,5,15,4,10,16,5,15,8},
 {6,11,9,7,10,17,4,11,1,12,8,14,1,7,13,2,14},
 {17,1,15,4,12,1,14,6,16,9,3,9,17,11,5,12,7},
 {10,12,5,13,6,15,5,11,4,12,6,13,6,4,16,9,2},
 {7,3,16,2,10,3,13,2,15,8,17,2,9,14,1,8,16},
 {12,8,10,8,17,9,7,16,9,1,7,11,16,4,11,14,5}
};


static unsigned char VD_ColorAdjustTable[4][256] =
{
/*******************************************************/
/*           Start ColorAdjustTable            */
/*******************************************************/
 {  /* Yellow ColorAdjustTable (256 bytes) */
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
  64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
  80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
  96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,
 112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
 128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
 144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
 160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,
 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,
 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255},

 {  /* Cyan ColorAdjustTable (256 bytes) */
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
  64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
  80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
  96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,
 112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
 128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
 144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
 160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,
 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,
 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255},

 {  /* Magenta ColorAdjustTable (256 bytes) */
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
  64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
  80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
  96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,
 112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
 128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
 144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
 160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,
 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
 224,225,226,227,228,229,230,231,232,233,234,235,23