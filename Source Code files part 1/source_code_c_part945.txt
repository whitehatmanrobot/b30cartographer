****************************************************\

    NAME: ::FillUnicodeString

    SYNOPSIS:	Standalone method for filling in a UNICODE_STRING struct using
		another UNICODE_STRING

\**********************************************************/
APIERR FillUnicodeString( UNICODE_STRING *       punistrDest,
                          const UNICODE_STRING * punistrSource )
{
    ASSERT( punistrDest != NULL && punistrSource != NULL );

    punistrDest->Length = punistrSource->Length;
    punistrDest->MaximumLength = punistrSource->MaximumLength;
    punistrDest->Buffer = (PWSTR)new BYTE[ punistrSource->MaximumLength ];
    APIERR err = NERR_Success;
    if (punistrDest->Buffer == NULL)
        err = ERROR_NOT_ENOUGH_MEMORY;
    else
        ::memcpyf( punistrDest->Buffer, punistrSource->Buffer, punistrSource->MaximumLength );

    return err;
}


/**********************************************************\

    NAME: ::CompareUnicodeString

    SYNOPSIS:	Standalone method for comparing two UNICODE_STRINGs
                case-sensitive

\**********************************************************/

INT CompareUnicodeString( const UNICODE_STRING * punistr1,
                          const UNICODE_STRING * punistr2 )
{
    INT cch1 = punistr1->Length / sizeof(WCHAR);
    INT cch2 = punistr2->Length / sizeof(WCHAR);

    if (cch1 == 0)
    {
        return (cch2 == 0) ? 0 : -1;
    }
    else if (cch2 == 0)
    {
        return 1;
    }

    return NETUI_strncmp2( punistr1->Buffer, cch1,
                           punistr2->Buffer, cch2 );
}



/**********************************************************\

    NAME: ::ICompareUnicodeString

    SYNOPSIS:	Standalone method for comparing two UNICODE_STRINGs
                case-insensitive

\**********************************************************/

INT ICompareUnicodeString( const UNICODE_STRING * punistr1,
                           const UNICODE_STRING * punistr2 )
{
    INT cch1 = punistr1->Length / sizeof(WCHAR);
    INT cch2 = punistr2->Length / sizeof(WCHAR);

    if (cch1 == 0)
    {
        return (cch2 == 0) ? 0 : -1;
    }
    else if (cch2 == 0)
    {
        return 1;
    }

    return NETUI_strnicmp2( punistr1->Buffer, cch1,
                            punistr2->Buffer, cch2 );

}



/*******************************************************************

    NAME:       USER_LBI::USER_LBI

    SYNOPSIS:   USER_LBI constructor

    ENTRY:      pszAccount -    Pointer to account name (logon name)
                pszFullname -   Pointer to full name
                pszComment -    Pointer to comment
                pulb -          Pointer to LAZY_USER_LISTBOX which will
                                provide the context for this LBI

    NOTES:      Account name is assumed to come straight from the
                Net API; this method does not validate or canonicalize
                the account name.

    HISTORY:
        rustanl     01-Jul-1991     Created
        rustanl     10-Jul-1991     Added sort order dependency
********************************************************************/

USER_LBI::USER_LBI( const TCHAR * pszAccount,
                    const TCHAR * pszFullName,
                    const TCHAR * pszComment,
                    const LAZY_USER_LISTBOX * pulb,
                    ULONG ulRID,
                    enum MAINUSRLB_USR_INDEX  nIndex )
    :   LBI(),
        _pddu( NULL ),
        _fPrivateCopy( TRUE ),
        _pulb( pulb ),
        _nlsAccountName( pszAccount )
{
    if ( QueryError() != NERR_Success )
        return;

    if ( _pulb == NULL )
    {
        UIASSERT( FALSE ); //USER_LBI constructed with invalid LAZY_USER_LISTBOX pointer
        ReportError( ERROR_INVALID_PARAMETER );
        return;
    }

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    _pddu = new DOMAIN_DISPLAY_USER();
    if (   _pddu == NULL
        || (err = _nlsAccountName.QueryError()) != NERR_Success
        || (::memsetf(_pddu, 0, sizeof(DOMAIN_DISPLAY_USER)), FALSE)
        || (err = ::FillUnicodeString( &(_pddu->LogonName), pszAccount) ) != NERR_Success
        || (err = ::FillUnicodeString( &(_pddu->AdminComment), pszComment) ) != NERR_Success
        || (err = ::FillUnicodeString( &(_pddu->FullName), pszFullName) ) != NERR_Success
       )
    {
        UIDEBUG( SZ("USER_LBI ct:  Ct of data members failed\r\n") );
        ReportError( err );
        return;
    }

    // never mind about _pddu->Index
    _pddu->Rid = ulRID;
    _pddu->AccountControl = (nIndex == MAINUSRLB_NORMAL) ? USER_NORMAL_ACCOUNT
                                                         : USER_TEMP_DUPLICATE_ACCOUNT;
}  // USER_LBI::USER_LBI


USER_LBI::USER_LBI( const DOMAIN_DISPLAY_USER * pddu,
                    const LAZY_USER_LISTBOX * pulb,
                    BOOL fPrivateCopy )
    :   LBI(),
        _pddu( NULL ),
        _fPrivateCopy( fPrivateCopy ),
        _pulb( pulb ),
        _nlsAccountName( pddu->LogonName.Buffer, (pddu->LogonName.Length / sizeof(WCHAR)) )
{
    if ( QueryError() != NERR_Success )
        return;

    if ( _pulb == NULL )
    {
        UIASSERT( FALSE ); //USER_LBI constructed with invalid LAZY_USER_LISTBOX pointer
        ReportError( ERROR_INVALID_PARAMETER );
        return;
    }

    if ( !fPrivateCopy )
    {
        _pddu = (DOMAIN_DISPLAY_USER *) pddu;
        return;
    }

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    _pddu = new DOMAIN_DISPLAY_USER();
    if (   _pddu == NULL
        || (err = _nlsAccountName.QueryError()) != NERR_Success
        || (::memsetf(_pddu, 0, sizeof(DOMAIN_DISPLAY_USER)), FALSE)
        || (err = ::FillUnicodeString( &(_pddu->LogonName), &(pddu->LogonName) )) != NERR_Success
        || (err = ::FillUnicodeString( &(_pddu->AdminComment), &(pddu->AdminComment) )) != NERR_Success
        || (err = ::FillUnicodeString( &(_pddu->FullName), &(pddu->FullName) )) != NERR_Success
       )
    {
        UIDEBUG( SZ("USER_LBI ct:  Ct of data members failed\r\n") );
        ReportError( err );
        return;
    }

    // never mind about _pddu->Index
    _pddu->Rid = pddu->Rid;
    _pddu->AccountControl = pddu->AccountControl;
}

/*******************************************************************

    NAME:       USER_LBI::~USER_LBI

    SYNOPSIS:   USER_LBI destructor

    HISTORY:
        JonN        16-Dec-1992     Created
********************************************************************/

USER_LBI::~USER_LBI()
{
    if ( _fPrivateCopy && (_pddu != NULL) )
    {
        ::FreeUnicodeString( &(_pddu->LogonName) );
        ::FreeUnicodeString( &(_pddu->AdminComment) );
        ::FreeUnicodeString( &(_pddu->FullName) );
        delete _pddu;
    }
}


/*******************************************************************

    NAME:       USER_LBI::Paint

    SYNOPSIS:   Paints the USER_LBI

    ENTRY:      plb -       Pointer to listbox which provides the context
                            for this LBI.  This is assumed to be the
                            same as the _pulb.
                hdc -       The device context handle to be used
                prect -     Pointer to clipping rectangle
                pGUILTT -   Pointer to GUILTT structure

    NOTES:      Note, the order of the columns depends on the sort order
                of the listbox.

    HISTORY:
        rustanl     01-Jul-1991 Created
        rustanl     10-Jul-1991 Added sort order dependency
        beng        08-Nov-1991 Unsigned widths
        o-SimoP     26-Nov-1991 added support for Group Properties subdlg
        beng        24-Apr-1992 Change to LBI::Paint
        beng        18-Jun-1992 Widen first column

********************************************************************/

VOID USER_LBI::Paint( LISTBOX * plb,
                      HDC hdc,
                      const RECT * prect,
                      GUILTT_INFO * pGUILTT ) const
{

    UNICODE_STR_DTE dteAccount( QueryAccountUstr() );
    UNICODE_STR_DTE dteFullName( QueryFullNameUstr() );

    int icolAccount;
    int icolFullname;
    UINT * padColWidths;
    switch ( _pulb->QuerySortOrder())
    {
    case ULB_SO_LOGONNAME:
        icolAccount = 1;
        icolFullname = 2;
        padColWidths = (((LAZY_USER_LISTBOX *)plb)->QuerypadColUsername())->QueryColumnWidth();
        break;

    default:
        UIASSERT( !SZ("Control should never reach this point") );
        // fall through

    case ULB_SO_FULLNAME:
        icolAccount = 2;
        icolFullname = 1;
        padColWidths = (((LAZY_USER_LISTBOX *)plb)->QuerypadColFullname())->QueryColumnWidth();
        break;
    }

    UNICODE_STR_DTE dteComment( QueryCommentUstr() );

    DISPLAY_TABLE dtab( 4, padColWidths);
    dtab[ 0            ] = ((LAZY_USER_LISTBOX *)_pulb)->QueryDmDte( QueryIndex() );
    dtab[ icolAccount  ] = &dteAccount;
    dtab[ icolFullname ] = &dteFullName;
    dtab[ 3            ] = &dteComment;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}  // USER_LBI::Paint


/*******************************************************************

    NAME:       USER_LBI::QueryLeadingChar

    SYNOPSIS:   Returns the leading character of the listbox item

    RETURNS:    The leading character of the listbox item

    NOTES:      Note, the leading character changes depending on the
                listbox sort order.

    HISTORY:
        rustanl     01-Jul-1991 Created
        rustanl     10-Jul-1991 Added sort order dependency
        beng        22-Nov-1991 Removed STR_OWNERALLOC

********************************************************************/

WCHAR USER_LBI::QueryLeadingChar( void ) const
{
    switch ( _pulb->QuerySortOrder())
    {
    case ULB_SO_FULLNAME:
        if ( QueryFullNameCch() > 0 )
        {
            return QueryFullNamePtr()[0];
        }
        //  fullname is empty
        //  fall through, and use first leading char of logon name

    case ULB_SO_LOGONNAME:
        {
            return QueryAccountPtr()[0];
        }

    default:
        break;

    }

    UIASSERT( FALSE ); // Control should never reach this point
    return TCH('\0'); // BUGBUG should be WCHAR regardless of UNICODE switch

}  // USER_LBI::QueryLeadingChar


/*******************************************************************

    NAME:       USER_LBI::Compare

    SYNOPSIS:   Compares two USER_LBI's

    ENTRY:      plbi -      Pointer to other USER_LBI object ('this'
                            being the first)

    RETURNS:    < 0         *this < *plbi
                = 0         *this = *plbi
                > 0         *this > *plbi

    NOTES:      This comparison depends on the current sort order of
                the listbox.  We do not make use of the fact that the
                "magic user enumerator" returns accounts in sorted order
                (primarily because the sort order is that of the server
                rather than that of the client).

    HISTORY:
        rustanl     01-Jul-1991     Created
        rustanl     10-Jul-1991     Added sort order dependency

********************************************************************/

INT USER_LBI::Compare( const LBI * plbi ) const
{
    const USER_LBI * pulbiThat = (const USER_LBI *)plbi;

    switch ( _pulb->QuerySortOrder())
    {
    case ULB_SO_LOGONNAME:
        return ::ICompareUnicodeString( QueryAccountUstr(),
                                        pulbiThat->QueryAccountUstr() );

    case ULB_SO_FULLNAME:
        {
            //  Sort by fullname.  Place any empty fullname at the
            //  bottom of the list, and use logon name as secondary
            //  sort key.

            int cchThisFullname = QueryFullNameCch();
            int cchThatFullname = pulbiThat->QueryFullNameCch();

            if ( cchThisFullname > 0 &&
                 cchThatFullname > 0 )
            {
                int nResult = ::ICompareUnicodeString( QueryFullNameUstr(),
                                                       pulbiThat->QueryFullNameUstr() );

                if ( nResult != 0 )
                    return nResult;
            }
            else
            {
                //  At least one of the fullnames is empty

                if ( cchThisFullname > 0 || cchThatFullname > 0 )
                {
                    //  Exactly one of the two fullnames is empty
                    if ( cchThisFullname > 0 )
                    {
                        // This fullname is non-empty; sort it first
                        return -1;
                    }

                    // That fullname is non-empty; sort it first
                    return 1;
                }
            }

            //  Use secondary sort key
            return ::ICompareUnicodeString( QueryAccountUstr(),
                                            pulbiThat->QueryAccountUstr() );
        }

    default:
        break;

    }

    UIASSERT( FALSE ); //Control should never reach this point
    return 0;

}  // USER_LBI::Compare


/*******************************************************************

    NAME:       USER_LBI::QueryName

    SYNOPSIS:   Returns the name of the LBI

    RETURNS:    Pointer to name of LBI

                CODEWORK:  This should be removed when _nlsAccountName
                is removed.

    HISTORY:
        rustanl     17-Jul-1991     Created

********************************************************************/

const TCHAR * USER_LBI::QueryName( void ) const
{
    return _nlsAccountName.QueryPch();

}  // USER_LBI::QueryName


/*******************************************************************

    NAME:       USER_LBI::CompareAll

    SYNOPSIS:   Compares the entire LBI item, in order to optimize
                painting of refreshed items

    ENTRY:      pddu0, pddu1 -    Pointers to DOMAIN_DISPLAY_USERs to compare

    RETURNS:    TRUE if both items are identical; FALSE otherwise

    HISTORY:
        jonn        29-Dec-1992     Created

********************************************************************/

BOOL USER_LBI::CompareAll( const DOMAIN_DISPLAY_USER * pddu0,
                           const DOMAIN_DISPLAY_USER * pddu1 )
{
    return ( ::CompareUnicodeString( &(pddu0->LogonName),
                                     &(pddu1->LogonName) ) == 0 &&
             ::CompareUnicodeString( &(pddu0->FullName),
                                     &(pddu1->FullName) ) == 0 &&
             ::CompareUnicodeString( &(pddu0->AdminComment),
                                     &(pddu1->AdminComment) ) == 0 &&
             pddu0->Rid == pddu1->Rid &&
             (pddu0->AccountControl & USER_NORMAL_ACCOUNT)
                  == (pddu1->AccountControl & USER_NORMAL_ACCOUNT)
           );

}  // USER_LBI::CompareAll



/*******************************************************************

    NAME:       USER_COLUMN_HEADER::USER_COLUMN_HEADER

    SYNOPSIS:   USER_COLUMN_HEADER constructor

    HISTORY:
        rustanl     22-Jul-1991     Created

********************************************************************/

USER_COLUMN_HEADER::USER_COLUMN_HEADER( OWNER_WINDOW * powin, CID cid,
                                        XYPOINT xy, XYDIMENSION dxy,
                                        const LAZY_USER_LISTBOX * pulb )
    :   ADMIN_COLUMN_HEADER( powin, cid, xy, dxy ),
        _pulb( pulb )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( _pulb != NULL );

    APIERR err;
    if ( ( err = _nlsLogonName.QueryError()) != NERR_Success ||
         ( err = _nlsFullname.QueryError()) != NERR_Success ||
         ( err = _nlsComment.QueryError()) != NERR_Success )
    {
        UIDEBUG( SZ("USER_COLUMN_HEADER ct:  String ct failed\r\n") );
        ReportError( err );
        return;
    }

    RESOURCE_STR res1( IDS_COL_HEADER_LOGON_NAME );
    RESOURCE_STR res2( IDS_COL_HEADER_FULLNAME );
    RESOURCE_STR res3( IDS_COL_HEADER_USER_COMMENT );
    if ( ( err = res1.QueryError() ) != NERR_Success ||
         ( err = ( _nlsLogonName = res1, _nlsLogonName.QueryError())) != NERR_Success ||
         ( err = res2.QueryError() ) != NERR_Success ||
         ( err = ( _nlsFullname = res2, _nlsFullname.QueryError())) != NERR_Success  ||
         ( err = res3.QueryError() ) != NERR_Success ||
         ( err = ( _nlsComment = res3, _nlsComment.QueryError())) != NERR_Success )
    {
        UIDEBUG( SZ("USER_COLUMN_HEADER ct:  Loading resource strings failed\r\n") );
        ReportError( err );
        return;
    }

}  // USER_COLUMN_HEADER::USER_COLUMN_HEADER


/*******************************************************************

    NAME:       USER_COLUMN_HEADER::~USER_COLUMN_HEADER

    SYNOPSIS:   USER_COLUMN_HEADER destructor

    HISTORY:
        rustanl     22-Jul-1991     Created

********************************************************************/

USER_COLUMN_HEADER::~USER_COLUMN_HEADER()
{
    // do nothing else

}  // USER_COLUMN_HEADER::~USER_COLUMN_HEADER


/*******************************************************************

    NAME:       USER_COLUMN_HEADER::OnPaintReq

    SYNOPSIS:   Paints the column header control

    RETURNS:    TRUE if message was handled; FALSE otherwise

    HISTORY:
        rustanl     22-Jul-1991 Created
        jonn        07-Oct-1991 Uses PAINT_DISPLAY_CONTEXT
        beng        08-Nov-1991 Unsigned widths
        beng        18-Jun-1992 Widen first column

********************************************************************/

BOOL USER_COLUMN_HEADER::OnPaintReq( void )
{
    INT icolAccount;
    INT icolFullname;
    UINT * padColWidths;
    switch ( _pulb->QuerySortOrder())
    {
    case ULB_SO_LOGONNAME:
        icolAccount = 0;
        icolFullname = 1;
        padColWidths = ((_pulb)->QuerypadColUsername())->QueryColHeaderWidth();
        break;

    default:
        DBGEOL( "Please contact JonN: bad sort order in USER_COLUMN_HEADER:OnPaintReq" );
        // shouldn't assert during paint request  UIASSERT( !SZ("Control should never reach this point") );
        // fall through

    case ULB_SO_FULLNAME:
        icolAccount = 1;
        icolFullname = 0;
        padColWidths = ((_pulb)->QuerypadColFullname())->QueryColHeaderWidth();
        break;
    }

    PAINT_DISPLAY_CONTEXT dc( this );

    XYRECT xyrect(this); // get client rectangle

    METALLIC_STR_DTE strdteLogonName( _nlsLogonName.QueryPch());
    METALLIC_STR_DTE strdteFullname( _nlsFullname.QueryPch());
    METALLIC_STR_DTE strdteComment( _nlsComment.QueryPch());

    //  Assign the column widths.  Note, these are the same as for the
    //  listbox columns, except that the first two listbox columns are
    //  represented as one column here.  Hence, COL_WIDTH_DM is added
    //  to the first of these columns.

    DISPLAY_TABLE cdt( 3, padColWidths );
    cdt[ icolAccount  ] = &strdteLogonName;
    cdt[ icolFullname ] = &strdteFullname;
    cdt[ 2            ] = &strdteComment;
    cdt.Paint( NULL, dc.QueryHdc(), xyrect );

    return TRUE;

}  // USER_COLUMN_HEADER::OnPaintReq




/**********************************************************************

    NAME:       USER_LBI::Compare_HAWforHawaii

    SYNOPSIS:   Determine whether this listbox item starts with the
                string provided

    HISTORY:
        jonn        28-Jul-1992 Created

**********************************************************************/

INT USER_LBI::Compare_HAWforHawaii( const NLS_STR & nls ) const
{
    return W_Compare_HAWforHawaii( nls, QueryDDU(), _pulb->QuerySortOrder() );
}

INT USER_LBI::W_Compare_HAWforHawaii( const NLS_STR & nls,
                                      const DOMAIN_DISPLAY_USER * pddu,
                                      USER_LISTBOX_SORTORDER ulbso )
{
    ASSERT( sizeof(TCHAR) == 2 ); // must be UNICODE

    INT nResult = 1;

    INT cchNls = nls.QueryTextLength();

    switch ( ulbso )
    {
    case ULB_SO_FULLNAME:
        //  Sort by fullname.  Place any empty fullname at the
        //  bottom of the list, and use logon name as secondary
        //  sort key.

        if ( pddu->FullName.Length >= (cchNls * sizeof(WCHAR)) )
        {
            nResult = my_strnicmpf( nls.QueryPch(),
                                    pddu->FullName.Buffer,
                                    cchNls );
            break;
        }

        if ( pddu->FullName.Length > 0 )
        {
            break;
        }
        // else fall through

    case ULB_SO_LOGONNAME:
        if ( pddu->LogonName.Length >= (cchNls * sizeof(WCHAR)) )
        {
            nResult = my_strnicmpf( nls.QueryPch(),
                                    pddu->LogonName.Buffer,
                                    cchNls );
        }
        break;

    default:
        UIASSERT(FALSE);
        DBGEOL( SZ("User Manager: Compare_HAWforHawaii(): invalid sort order") );
        break;
    }

    return nResult;

} // USER_LBI::W_Compare_HAWforHawaii
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\userprop.cxx ===
/**********************************************************************/
/**                Microsoft LAN Manager                             **/
/**          Copyright(c) Microsoft Corp., 1990, 1991                **/
/**********************************************************************/

/*
    userprop.cxx


    FILE HISTORY:
    JonN	17-Jul-1991	Created
    JonN	20-Aug-1991	Multiselection redesign
    JonN	26-Aug-1991	PROP_DLG code review changes
    JonN	28-Aug-1991	Added password and account-enabled
    JonN	29-Aug-1991	Added Copy... variant
    JonN	31-Aug-1991	Changes account-enabled to acct-disabled
    JonN	03-Sep-1991	Added validation
    JonN	03-Sep-1991	Preparation for code review
    JonN	05-Sep-1991	Added USER_MEMB array
    JonN	11-Sep-1991	USERPROP_DLG code review changes part 1 (9/6/91)
				Attending: KevinL, RustanL, JonN, o-SimoP
    JonN	17-Oct-1991	Uses SLE_STRIP
    JonN	03-Nov-1991	Strips PARMS field on Clone User...
    terryk	10-Nov-1991	change I_NetXXX to I_MNetXXX
    o-SimoP	11-Dec-1991	Added USER_LISTBOX * to subdialogs
			        and TRISTATE
    JonN	11-Dec-1991	Added Logon Hours subproperty dialog
    JonN	20-Oct-1991	Graphical buttons
    JonN	30-Dec-1991	Work around LM2x bug in PerformOne()
    JonN	01-Jan-1992	Changed W_MapPerformOneAPIError to
				W_MapPerformOneError
				Split PerformOne() into
				I_PerformOneClone()/Write()
    JonN	27-Jan-1992	NTISSUES 564:  Fullname not required
    JonN	12-Feb-1992	Allow A/U/G except for downlevel
    JonN	19-Feb-1992	Moved Cannot Change Password from USERACCT
    JonN	28-Feb-1992	Added QueryUser3Ptr
    JonN	17-Apr-1992	Skip USER_MEMB for WindowsNT
    JonN	23-Apr-1992	Changed powin to pumadminapp
    JonN	27-Apr-1992	Use USER_3 where appropriate
    Thomaspa	28-Apr-1992	Added alias membership support
    JonN	14-May-1992	Hide unused buttons
    JonN	15-May-1992	Move USERPROP_DLG::OnCommand to usrmain.cxx
    JonN	28-May-1992     Enable force logoff checkbox
    JonN	04-Jun-1992	New users in proper groups
    Johnl	05-Jul-1992	Added security on homedirs
    JonN	24-Aug-1992	Nonbold font for graphical buttons (bug 739)
    JonN        31-Aug-1992     Re-enable %USERNAME%
    CongpaY	05-Oct-1993	Add NetWare user support.
    CODEWORK should use VALIDATED_DIALOG for edit field validation

    NOTE:  We rely on I_PerformOne_Write() being called immediately
    after each MembersToLMOBJ, rather than all MembersToLMOBJ and
    then all writes.  Otherwise _fGeneralizedHomeDir will not work right.
*/


//  Define this to disable %USERNAME%
// #define DISABLE_GENERALIZE



#include <ntincl.hxx>

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NET
#define INCL_NETLIB
#define INCL_NETACCESS
#define INCL_ICANON
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#define INCL_BLT_SETCONTROL
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_TIME_DATE
#include <blt.hxx>

// usrmgrrc.h must be included after blt.hxx (more exactly, after bltrc.h)
extern "C"
{
    #include <usrmgrrc.h>
    #include <mnet.h>
    #include <ntsam.h>
    #include <ntlsa.h>
    #include <ntseapi.h>
    #include <umhelpc.h>
    #include <fpnwname.h>
    #include <dllfunc.h>
    #include <dsmnname.h>
}

#include <uitrace.hxx>
#include <uiassert.hxx>

#include <lmouser.hxx>
#include <ntuser.hxx>  // USER_3
#include <nwlb.hxx>    // for NW_PASSWORD_DLG
#include <userprop.hxx>
#include <usrmain.hxx>
#include <uintsam.hxx>
#include <security.hxx>
#include <ntacutil.hxx>
#include <uintlsax.hxx>
#include <nwuser.hxx>  // USER_NW
#include <strnumer.hxx>
#include <lmsvc.hxx>

// hydra
#include "uconfig.hxx"

// CODEWORK These values are taken from net\access\userp.c.  It would be nice
// if we could share these values with that code in case they change.
#define USER3_DESIRED_ACCESS_READ ( USER_LIST_GROUPS | USER_READ_GENERAL | USER_READ_LOGON | USER_READ_ACCOUNT | USER_READ_PREFERENCES | READ_CONTROL )
#define USER3_DESIRED_ACCESS_WRITE ( USER_WRITE_ACCOUNT | WRITE_DAC | USER_WRITE_PREFERENCES | USER_FORCE_PASSWORD_CHANGE )
#define USER3_DESIRED_ACCESS_ALL ( USER3_DESIRED_ACCESS_READ | USER3_DESIRED_ACCESS_WRITE )

// not currently disabled
// #define DISABLE_ACCESS_CHECK

DEFINE_SLIST_OF( RID_AND_SAM_ALIAS );

//
// BEGIN MEMBER FUNCTIONS
//
/*******************************************************************

    NAME:	RID_AND_SAM_ALIAS::RID_AND_SAM_ALIAS

    SYNOPSIS:	Constructor for RID_AND_SAM_ALIAS

    ENTRY:	rid of alias

		psamalias ( optional ) pointer to SAM_ALIAS

    HISTORY:
    thomaspa        28-Apr-1992     Created
********************************************************************/
RID_AND_SAM_ALIAS::RID_AND_SAM_ALIAS( ULONG rid,
				      BOOL fBuiltin,
				      SAM_ALIAS * psamalias )
	: _rid( rid ),
	  _fBuiltin( fBuiltin ),
	  _psamalias( psamalias )
{ }


/*******************************************************************

    NAME:	RID_AND_SAM_ALIAS::~RID_AND_SAM_ALIAS

    SYNOPSIS:	Destructor for RID_AND_SAM_ALIAS

    ENTRY:

    HISTORY:
    thomaspa        28-Apr-1992     Created
********************************************************************/
RID_AND_SAM_ALIAS::~RID_AND_SAM_ALIAS()
{
	_rid = 0;
	delete _psamalias;
	_psamalias = NULL;
}


/*******************************************************************

    NAME:	RID_AND_SAM_ALIAS::SetSamAlias

    HISTORY:
    thomaspa        28-Apr-1992     Created
********************************************************************/
void RID_AND_SAM_ALIAS::SetSamAlias( SAM_ALIAS * psamalias )
{
    delete _psamalias; _psamalias = psamalias;
}



enum UM_SUBDIALOG_TYPE UM_ButtonsTable [UM_NUM_TARGET_TYPES+2]
				       [UM_NUM_USERPROP_BUTTONS]
// hydra
        = { { UM_SUBDLG_GROUPS, UM_SUBDLG_PRIVS, UM_SUBDLG_PROFILES,
          UM_SUBDLG_HOURS,  UM_SUBDLG_VLW,   UM_SUBDLG_DETAIL,
              UM_SUBDLG_DIALIN, UM_SUBDLG_NONE  }
	   ,{ UM_SUBDLG_GROUPS, UM_SUBDLG_PRIVS , UM_SUBDLG_PROFILES, UM_SUBDLG_DIALIN,
	      UM_SUBDLG_NONE,   UM_SUBDLG_NONE, // UM_SUBDLG_NONE,
              UM_SUBDLG_NONE,   UM_SUBDLG_NONE  }
	   ,{ UM_SUBDLG_GROUPS, UM_SUBDLG_PROFILES, UM_SUBDLG_HOURS,
	      UM_SUBDLG_VLW,    UM_SUBDLG_DETAIL,   UM_SUBDLG_NONE,
              UM_SUBDLG_NONE,   UM_SUBDLG_NONE }
	   ,{ UM_SUBDLG_GROUPS, UM_SUBDLG_PRIVS, UM_SUBDLG_PROFILES,
          UM_SUBDLG_HOURS,  UM_SUBDLG_VLW,   UM_SUBDLG_DETAIL,
              UM_SUBDLG_DIALIN, UM_SUBDLG_NCP   }
	   ,{ UM_SUBDLG_GROUPS, UM_SUBDLG_PROFILES, UM_SUBDLG_DIALIN,
	      UM_SUBDLG_NCP,    UM_SUBDLG_NONE,     UM_SUBDLG_NONE,
              UM_SUBDLG_NONE,   UM_SUBDLG_NONE  }
	  };
// hydra end

/* Original setting
	= { { UM_SUBDLG_GROUPS, UM_SUBDLG_PROFILES, UM_SUBDLG_HOURS,
	      UM_SUBDLG_VLW,    UM_SUBDLG_DETAIL, UM_SUBDLG_DIALIN,
              UM_SUBDLG_NONE  }
	   ,{ UM_SUBDLG_GROUPS, UM_SUBDLG_PROFILES,UM_SUBDLG_DIALIN,
	      UM_SUBDLG_NONE,   UM_SUBDLG_NONE,    UM_SUBDLG_NONE,
              UM_SUBDLG_NONE  }
	   ,{ UM_SUBDLG_GROUPS, UM_SUBDLG_PROFILES, UM_SUBDLG_HOURS,
	      UM_SUBDLG_VLW,    UM_SUBDLG_DETAIL, UM_SUBDLG_NONE,
              UM_SUBDLG_NONE  }
	   ,{ UM_SUBDLG_GROUPS, UM_SUBDLG_PROFILES, UM_SUBDLG_HOURS,
	      UM_SUBDLG_VLW,    UM_SUBDLG_DETAIL, UM_SUBDLG_DIALIN,
              UM_SUBDLG_NCP   }
	   ,{ UM_SUBDLG_GROUPS, UM_SUBDLG_PROFILES,UM_SUBDLG_DIALIN,
	      UM_SUBDLG_NCP,    UM_SUBDLG_NONE,    UM_SUBDLG_NONE,
              UM_SUBDLG_NONE  }
	  };
*/

/*******************************************************************

    NAME:       USERPROP_DLG::QuerySubdialogType

    SYNOPSIS:   Returns the ID of the subdialog which should appear
                for this button.
		variants.

    HISTORY:
               JonN  15-May-1992    created

********************************************************************/

enum UM_SUBDIALOG_TYPE USERPROP_DLG::QuerySubdialogType( UINT iButton )
{
    INT nIndex;

    // hydra
    if ( vfIsCitrixOrDomain )
        nIndex = IsNetWareInstalled()? UM_LANMANNT + 3: UM_LANMANNT;
    else
    // hydra end
    if (QueryTargetServerType() == UM_LANMANNT)
        nIndex = IsNetWareInstalled()? UM_LANMANNT + 3: UM_LANMANNT;
    else if (QueryTargetServerType() == UM_WINDOWSNT)
        nIndex = IsNetWareInstalled()? UM_WINDOWSNT + 3 : UM_WINDOWSNT;
    else
        nIndex = UM_DOWNLEVEL;

    return ::UM_ButtonsTable[nIndex][iButton];
}


/*******************************************************************

    NAME:	USERPROP_DLG::USERPROP_DLG

    SYNOPSIS:	Constructor for User Properties main dialog, base class

    ENTRY:	Note that psel is required to be NULL for NEW variants,
		non-NULL otherwise.

    NOTES:	cItems must be passed to the constructor because we
		cannot rely on virtual QueryObjectCount before the
		object has been fully initialized.

		We do not define a maximum length for comments.

    HISTORY:
    JonN        17-Jul-1991     Created
    JonN	20-Aug-1991	Multiselection redesign
    o-SimoP	11-Dec-1991	Added USER_LISTBOX * , default NULL
    thomaspa	28-Apr-1992	Alias membership support
    JonN        28-Dec-1993     Added account lockout
********************************************************************/

USERPROP_DLG::USERPROP_DLG(
	const TCHAR * pszResourceName,
	const UM_ADMIN_APP * pumadminapp,
	const LOCATION & loc,
	const LAZY_USER_SELECTION * psel,
	const LAZY_USER_LISTBOX * pulb
	) : PROP_DLG( loc, pszResourceName, pumadminapp, (psel == NULL) ),
            _pumadminapp( pumadminapp ),
	    _pulb( pulb ),
	    _psel( psel ),
	    _apuser2( NULL ),
	    _apusermemb( NULL ),
	    _apsamrmBuiltin( NULL ),
	    _apsamrmAccounts( NULL ),
        // hydra
            _apUserConfig( NULL ),


            _slAddToAliases(),
            _slRemoveFromAliases(),
            _resstrUsernameReplace( IDS_PR_USERNAME_REPLACE ),
            // CODEWORK _strlstExtensionReplace not needed for MUM
            _strlstExtensionReplace(),
	    _cItems( (psel != NULL) ? psel->QueryCount() : 1 ),
	    _nlsComment(),
	    _fIndeterminateComment( FALSE ),
	    _fIndetNowComment( FALSE ),
	    _fAccountDisabled( FALSE ),
	    _fIndeterminateAccountDisabled( FALSE ),
	    _fAccountLockout( FALSE ),
	    _fIndeterminateAccountLockout( FALSE ),
	    _triCannotChangePasswd( AI_TRI_UNCHECK ),		
	    _sleComment( this, IDUP_ET_COMMENT, LM20_MAXCOMMENTSZ ),
	    _cbUserCannotChange( this, IDUP_CB_USERCANCHANGE ),
	    _cbAccountDisabled( this, IDUP_CB_ACCOUNTDISABLED ),
	    _pcbAccountLockout( NULL ),
            _triNoPasswordExpire( AI_TRI_UNCHECK ),
	    _pcbNoPasswordExpire( NULL ),
	    _phiddenNoPasswordExpire( NULL ),
	    _triForcePWChange( AI_TRI_UNCHECK ),
            _pcbForcePWChange( NULL ),
	    _phiddenForcePWChange( NULL ),
            _triIsNetWareUser( AI_TRI_UNCHECK ),
	    _pcbIsNetWareUser( NULL ),
	    _phiddenIsNetWareUser( NULL ),
            _fNetWareUserChanged (FALSE),
            _fPasswordChanged (FALSE),
            _fCancel (FALSE),
            _nMsgPopupRet (MP_YES),  //set yes for single user case.
	    _apgbButtons(NULL),
            _aphiddenctrl(NULL),
            _fontHelv( FONT_DEFAULT ),
	    _fCommonHomeDirCreated( FALSE ),
        // hydra 
        _fCommonWFHomeDirCreated( FALSE ),
        


	    _fGeneralizedHomeDir( FALSE )
{
    ASSERT( pumadminapp != NULL );
    ASSERT( _cItems >= 1 );

    if ( QueryError() != NERR_Success )
	return;

    APIERR err;
    if (   ((err = _nlsComment.QueryError()) != NERR_Success)
        || ((err = _resstrUsernameReplace.QueryError()) != NERR_Success)
        || ((err = _fontHelv.QueryError()) != NERR_Success) )
    {
	ReportError( err );
	return;
    }

    NLS_STR* pnls1 = NULL;
    NLS_STR* pnls2 = NULL;
    NLS_STR* pnls3 = NULL;
    NLS_STR* pnls4 = NULL;
    err = ERROR_NOT_ENOUGH_MEMORY;
    if (   (pnls1 = new RESOURCE_STR(IDS_PR_EXTENSION1_REPLACE)) == NULL
        || (pnls2 = new RESOURCE_STR(IDS_PR_EXTENSION2_REPLACE)) == NULL
        || (pnls3 = new RESOURCE_STR(IDS_PR_EXTENSION3_REPLACE)) == NULL
        || (pnls4 = new RESOURCE_STR(IDS_PR_EXTENSION4_REPLACE)) == NULL
        || (err = pnls1->QueryError()) != NERR_Success
        || (err = pnls2->QueryError()) != NERR_Success
        || (err = pnls3->QueryError()) != NERR_Success
        || (err = pnls4->QueryError()) != NERR_Success
        || (err = _strlstExtensionReplace.Append(pnls1)) != NERR_Success
        || (err = _strlstExtensionReplace.Append(pnls2)) != NERR_Success
        || (err = _strlstExtensionReplace.Append(pnls3)) != NERR_Success
        || (err = _strlstExtensionReplace.Append(pnls4)) != NERR_Success
       )
    {
	ReportError( err );
        DBGEOL(   "USERPROP_DLG::ctor(): error " << err
               << " trying to load strlstExtensionReplace" );
	return;
    }


    if ( IsDownlevelVariant() )
    {
	_phiddenNoPasswordExpire = new HIDDEN_CONTROL(
					  this, IDUP_CB_NOPASSWORDEXPIRE );
	_phiddenForcePWChange    = new HIDDEN_CONTROL(
					  this, IDUP_CB_FORCEPWCHANGE );
    }
    else
    {
	_pcbNoPasswordExpire = new TRISTATE( this, IDUP_CB_NOPASSWORDEXPIRE );
	_pcbForcePWChange    = new TRISTATE( this, IDUP_CB_FORCEPWCHANGE );
    }
    if (   (IsDownlevelVariant()  &&  _phiddenNoPasswordExpire == NULL )
        || (IsDownlevelVariant()  &&  _phiddenForcePWChange == NULL )
        || (!IsDownlevelVariant() &&  _pcbNoPasswordExpire == NULL )
        || (!IsDownlevelVariant() &&  _pcbForcePWChange == NULL )
       )
    {
	ReportError( ERROR_NOT_ENOUGH_MEMORY );
	return;
    }

    // no Account Lockout for New variants
    if ( !IsNewVariant() )
    {
        _pcbAccountLockout = new TRISTATE( this, IDUP_CB_ACCOUNTLOCKOUT );
        if (_pcbAccountLockout == NULL)
        {
            ReportError( err );
            return;
        }
    }

    if ( IsDownlevelVariant() || !IsNetWareInstalled() )
    {
        _phiddenIsNetWareUser = new HIDDEN_CONTROL(
            this, IDUP_CB_ISNETWAREUSER );

        if (_phiddenIsNetWareUser == NULL)
        {
            ReportError (ERROR_NOT_ENOUGH_MEMORY);
            return;
        }
    }
    else
    {
        _pcbIsNetWareUser = new TRISTATE( this, IDUP_CB_ISNETWAREUSER );
        if (_pcbIsNetWareUser == NULL)
        {
            ReportError (ERROR_NOT_ENOUGH_MEMORY);
            return;
        }
    }

    _apuser2 = new PUSER_2[ _cItems ];
    if ( _apuser2 == NULL )
    {
	ReportError( ERROR_NOT_ENOUGH_MEMORY );
	return;
    }

    _apusermemb = new PUSER_MEMB[ _cItems ];
    if ( _apusermemb == NULL )
    {
	ReportError( ERROR_NOT_ENOUGH_MEMORY );
	return;
    }

    _apsamrmAccounts = new SAM_RID_MEM * [ _cItems ];
    if ( _apsamrmAccounts == NULL )
    {
	ReportError( ERROR_NOT_ENOUGH_MEMORY );
	return;
    }

    _apsamrmBuiltin = new SAM_RID_MEM * [ _cItems ];
    if ( _apsamrmBuiltin == NULL )
    {
	ReportError( ERROR_NOT_ENOUGH_MEMORY );
	return;
    }

    // hydra
    _apUserConfig = new PUSER_CONFIG[ _cItems ];
    if ( _apUserConfig == NULL )
    {
	ReportError( ERROR_NOT_ENOUGH_MEMORY );
	return;
    }
    // hydra end

    UINT i;
    for ( i = 0; i < _cItems; i++ )
    {
	// These array elements will be initialized in GetOne()
	_apuser2[ i ] = NULL;
	_apusermemb[ i ] = NULL;
	_apsamrmAccounts[ i ] = NULL;
	_apsamrmBuiltin[ i ] = NULL;

    // hydra
    _apUserConfig[ i ] = NULL;
    }

    _apgbButtons = (GRAPHICAL_BUTTON **) new PVOID[ UM_NUM_USERPROP_BUTTONS ];
    _aphiddenctrl = (HIDDEN_CONTROL **) new PVOID[ UM_NUM_USERPROP_BUTTONS ];
    if ( _apgbButtons == NULL || _aphiddenctrl == NULL )
    {
	ReportError( ERROR_NOT_ENOUGH_MEMORY );
	return;
    }

    for ( i = 0; i < UM_NUM_USERPROP_BUTTONS; i++ )
    {
	_apgbButtons[i] = NULL;
	_aphiddenctrl[i] = NULL;
    }

    for ( i = 0; i < UM_NUM_USERPROP_BUTTONS; i++ )
    {
	enum UM_SUBDIALOG_TYPE subdlgType = QuerySubdialogType(i);
	if (subdlgType == UM_SUBDLG_NONE)
	{
	    DBGEOL( "Hiding button " << i );
            _aphiddenctrl[i] = new HIDDEN_CONTROL( this,
                                                   (CID)(IDUP_GB_1 + i) );
	    err = ERROR_NOT_ENOUGH_MEMORY;
	    if (   (_aphiddenctrl[i] == NULL)
	        || (err = _aphiddenctrl[i]->QueryError()) != NERR_Success
	       )
	    {
	        DBGEOL( "failed to hide button " << i );
	        ReportError( err );
	        return;
	    }
	}
        else
        {
	    DBGEOL(   "Trying to load button " << i
                   << " userprop type " << (INT)QueryTargetServerType()
                   << " makes button type " << (INT)subdlgType );
	    _apgbButtons[i] = new GRAPHICAL_BUTTON(
	    	this,
	    	(CID)(IDUP_GB_1 + i),
	    	MAKEINTRESOURCE(BMID_USRPROP_BTN_BASE + subdlgType));
	    RESOURCE_STR nlsButtonText( IDS_UM_BTN_BASE + subdlgType );
	    err = ERROR_NOT_ENOUGH_MEMORY;
	    if (   (_apgbButtons[i] == NULL)
	        || (err = nlsButtonText.QueryError()) != NERR_Success
	        || (err = _apgbButtons[i]->QueryError()) != NERR_Success
	       )
	    {
	        DBGEOL( "failed to init button " << i );
	        ReportError( err );
	        return;
	    }
	    _apgbButtons[i]->SetFont( _fontHelv );
	    _apgbButtons[i]->SetText( nlsButtonText );

        }
    }

}// USERPROP_DLG::USERPROP_DLG



/*******************************************************************

    NAME:       USERPROP_DLG::~USERPROP_DLG

    SYNOPSIS:   Destructor for User Properties main dialog, base class

    HISTORY:
    JonN        17-Jul-1991     Created
    thomaspa	28-Apr-1992	Alias membership support

********************************************************************/

USERPROP_DLG::~USERPROP_DLG( void )
{
    UINT i;

    if ( _apuser2 != NULL )
    {
	for ( i = 0; i < _cItems; i++ )
	{
	    delete _apuser2[ i ];
	    _apuser2[ i ] = NULL;
	}
	delete _apuser2;
	_apuser2 = NULL;
    }

    if ( _apusermemb != NULL )
    {
	for ( i = 0; i < _cItems; i++ )
	{
	    delete _apusermemb[ i ];
	    _apusermemb[ i ] = NULL;
	}
	delete _apusermemb;
	_apusermemb = NULL;
    }

    if ( _apsamrmAccounts != NULL )
    {
	for ( i = 0; i < _cItems; i++ )
	{
	    delete _apsamrmAccounts[ i ];
	    _apsamrmAccounts[ i ] = NULL;
	}
	delete _apsamrmAccounts;
	_apsamrmAccounts = NULL;
    }

    if ( _apsamrmBuiltin != NULL )
    {
	for ( i = 0; i < _cItems; i++ )
	{
	    delete _apsamrmBuiltin[ i ];
	    _apsamrmBuiltin[ i ] = NULL;
	}
	delete _apsamrmBuiltin;
	_apsamrmBuiltin = NULL;
    }

    // hydra
    if ( _apUserConfig != NULL )
    {
	for ( i = 0; i < _cItems; i++ )
	{
	    delete _apUserConfig[ i ];
	    _apUserConfig[ i ] = NULL;
	}
	delete _apUserConfig;
	_apUserConfig = NULL;
    }
    // hydra end


    if ( _apgbButtons != NULL )
    {
	for ( i = 0; i < UM_NUM_USERPROP_BUTTONS; i++ )
	{
	    delete _apgbButtons[ i ];
	    _apgbButtons[ i ] = NULL;
	}
	delete _apgbButtons;
	_apgbButtons = NULL;
    }

    if ( _aphiddenctrl != NULL )
    {
	for ( i = 0; i < UM_NUM_USERPROP_BUTTONS; i++ )
	{
	    delete _aphiddenctrl[ i ];
	    _aphiddenctrl[ i ] = NULL;
	}
	delete _aphiddenctrl;
	_aphiddenctrl = NULL;
    }

    delete _phiddenNoPasswordExpire;
    _phiddenNoPasswordExpire = NULL;
    delete _pcbNoPasswordExpire;
    _pcbNoPasswordExpire = NULL;

    delete _phiddenForcePWChange;
    _phiddenForcePWChange = NULL;
    delete _pcbForcePWChange;
    _pcbForcePWChange = NULL;

    delete _pcbAccountLockout;
    _pcbAccountLockout = NULL;

    delete _phiddenIsNetWareUser;
    _phiddenIsNetWareUser = NULL;
    delete _pcbIsNetWareUser;
    _pcbIsNetWareUser = NULL;
}

/*******************************************************************

    NAME:       USERPROP_DLG::IsCloneVariant

    SYNOPSIS:   Indicates whether this dialog is a Clone variant
                (a subclass of New).  Redefine for variants which are
                (potentially) Clone variants.

    HISTORY:
               JonN  23-Apr-1991    created

********************************************************************/

BOOL USERPROP_DLG::IsCloneVariant( void )
{
    return FALSE;

}   // USERPROP_DLG::IsCloneVariant

/*******************************************************************

    NAME:       USERPROP_DLG::OnOK

    SYNOPSIS:   OK button handler.  This handler applies to all variants
		including EDITSINGLE_, EDITMULTI_, and NEW_USERPROP_DLG.

    EXIT:	Dismiss() return code indicates whether the dialog wrote
		any changes successfully to the API at any time.

    HISTORY:
               JonN  17-Jul-1991    created
	       JonN  20-Aug-1991    Multiselection redesign
	       JonN  26-Aug-1991    PROP_DLG code review changes

********************************************************************/

BOOL USERPROP_DLG::OnOK( void )
{
    APIERR err = W_DialogToMembers();
    if ( err != NERR_Success )
    {
        MsgPopup( this, err );
        return TRUE;
    }

    if ( PerformSeries())
    	Dismiss(QueryWorkWasDone());
    return TRUE;

}   // USERPROP_DLG::OnOK

// USERPROP_DLG::OnCommand() has been moved to from userprop.cxx to
//  usrmain.cxx!  This allows allow MUM to avoid linking unnecessary
//  subproperty dialogs.
//  JonN 05/15/92

/*******************************************************************

    NAME:       USERPROP_DLG::QueryObjectName

    SYNOPSIS:   Returns the name of a selected user.  This is meant for
		use with "edit user(s)" variants and should be redefined
		for "new user" variants.

    HISTORY:
               JonN  17-Jul-1991    created
               JonN  20-Aug-1991    multiselection redesign

********************************************************************/

const TCHAR * USERPROP_DLG::QueryObjectName(
	UINT		iObject
	) const
{
    UIASSERT( _psel != NULL ); // must be redefined for NEW variants
    return _psel->QueryItemName( iObject );
}


/*******************************************************************

    NAME:       USERPROP_DLG::QueryObjectCount

    SYNOPSIS:   Returns the number of selected users, or 1 for "new user"
		variants.

    HISTORY:
               JonN  18-Jul-1991    created

********************************************************************/

UINT USERPROP_DLG::QueryObjectCount( void ) const
{
    return _cItems;
}


/*******************************************************************

    NAME:       USERPROP_DLG::InitControls

    SYNOPSIS:   Initializes the controls maintained by USERPROP_DLG,
		according to the values in the class data members.

    RETURNS:	error code.

    CODEWORK  Should this be called W_MembersToDialog?  This would fit
    in with the general naming scheme.

    HISTORY:
               JonN  24-Jul-1991    created
	       JonN  20-Aug-1991    Multiselection redesign

********************************************************************/

APIERR USERPROP_DLG::InitControls()
{
    ASSERT( _nlsComment.QueryError() == NERR_Success );
    _sleComment.SetText( _nlsComment );
    if( !_fIndeterminateAccountDisabled )
    {
	_cbAccountDisabled.SetCheck( _fAccountDisabled );
	_cbAccountDisabled.EnableThirdState(FALSE);
    }
    else
    {
	_cbAccountDisabled.SetIndeterminate();
    }

    if( _triCannotChangePasswd == AI_TRI_INDETERMINATE )
    {
	_cbUserCannotChange.SetIndeterminate();	
    }
    else
    {
	_cbUserCannotChange.SetCheck( _triCannotChangePasswd == AI_TRI_CHECK );
	_cbUserCannotChange.EnableThirdState(FALSE);
    }

    if ( !IsNewVariant() )
    {
        ASSERT( _pcbAccountLockout != NULL );

        if( !_fIndeterminateAccountLockout )
        {
    	    _pcbAccountLockout->SetCheck( _fAccountLockout );
            /*
             *  Disable this control if accounts not currently locked out
             */
            if (_fAccountLockout)
    	        _pcbAccountLockout->EnableThirdState(FALSE);
            else
                _pcbAccountLockout->Enable( FALSE );
        }
        else
        {
    	    _pcbAccountLockout->SetIndeterminate();
        }
    }

    if ( !IsDownlevelVariant() )
    {
        if( _triNoPasswordExpire == AI_TRI_INDETERMINATE )
        {
	    _pcbNoPasswordExpire->SetIndeterminate();	
        }
        else
        {
	    _pcbNoPasswordExpire->SetCheck(
				_triNoPasswordExpire == AI_TRI_CHECK );
	    _pcbNoPasswordExpire->EnableThirdState(FALSE);
        }

        if (IsNetWareInstalled())
        {
            if( _triIsNetWareUser == AI_TRI_INDETERMINATE )
            {
    	    _pcbIsNetWareUser->SetIndeterminate();	
            }
            else
            {
    	    _pcbIsNetWareUser->SetCheck(
    				_triIsNetWareUser == AI_TRI_CHECK );
    	    _pcbIsNetWareUser->EnableThirdState(FALSE);
            }
        }
    }

    if ( !IsDownlevelVariant() )
    {
        if( _triForcePWChange == AI_TRI_INDETERMINATE )
        {
	    _pcbForcePWChange->SetIndeterminate();	
        }
        else
        {
	    _pcbForcePWChange->SetCheck(
				_triForcePWChange == AI_TRI_CHECK );
	    _pcbForcePWChange->EnableThirdState(FALSE);
        }
    }

	if( !vfIsCitrixOrDomain )
	{
		UIASSERT( _apgbButtons[ 1 ] != NULL );

		_apgbButtons[ 1 ]->Enable( FALSE) ;
	}

    // Set the NetWare button.
    if (IsNetWareInstalled())
    {    
        // hydra netware -- not for NT5.0
        if ( (QueryTargetServerType() == UM_WINDOWSNT) && !vfIsCitrixOrDomain )
        // if (QueryTargetServerType() == UM_WINDOWSNT)
        {
            UIASSERT (_apgbButtons[3] != NULL);
            _apgbButtons[3]->Enable ( _triIsNetWareUser ==  AI_TRI_CHECK );
        }
        else
        {
            // hydra
            UIASSERT (_apgbButtons[7] != NULL);
            _apgbButtons[7]->Enable ( _triIsNetWareUser ==  AI_TRI_CHECK );
            // original code
            // UIASSERT (_apgbButtons[6] != NULL);
            // _apgbButtons[6]->Enable ( _triIsNetWareUser ==  AI_TRI_CHECK );
        }
    }

    return PROP_DLG::InitControls();
}


/*******************************************************************

    NAME:       USERPROP_DLG::W_LMOBJtoMembers

    SYNOPSIS:	Loads class data members from initial data

    ENTRY:	Index of user to examine.  W_LMOBJToMembers expects to be
		called once for each user, starting from index 0.

    RETURNS:	error code

    NOTES:	This API takes a UINT rather than a USER_2 * because it
		must be able to recognize the first user.

    HISTORY:
               JonN  20-Aug-1991    created
	       JonN  20-Aug-1991    Multiselection redesign

********************************************************************/

APIERR USERPROP_DLG::W_LMOBJtoMembers(
	UINT		iObject
	)
{
    USER_2 * puser2 = QueryUser2Ptr( iObject );
    UIASSERT( puser2 != NULL );

    enum AI_TRI_STATE triCurrCannotChangePasswd =
        puser2->QueryUserCantChangePass() ? AI_TRI_CHECK : AI_TRI_UNCHECK;

    enum AI_TRI_STATE triCurrNoPasswordExpire = AI_TRI_INDETERMINATE;

    enum AI_TRI_STATE triCurrForcePWChange = AI_TRI_INDETERMINATE;

    enum AI_TRI_STATE triCurrIsNetWareUser = AI_TRI_INDETERMINATE;
    APIERR err = NERR_Success;

    if ( !IsDownlevelVariant() )
    {
        triCurrNoPasswordExpire =
	    QueryUser3Ptr(iObject)->QueryNoPasswordExpire()
		? AI_TRI_CHECK : AI_TRI_UNCHECK;

        triCurrForcePWChange =
	    (QueryUser3Ptr(iObject)->QueryPasswordExpired() != (DWORD)(0L))
		? AI_TRI_CHECK : AI_TRI_UNCHECK;

        if ( IsNetWareInstalled() )
        {
            BOOL fIsNetWareUser;
            if ((err = QueryUserNWPtr(iObject)->QueryIsNetWareUser(&fIsNetWareUser)) != NERR_Success)
                return err;

            triCurrIsNetWareUser = fIsNetWareUser ? AI_TRI_CHECK : AI_TRI_UNCHECK;
        }
    }

    if ( iObject == 0 ) // first object
    {
	_fIndeterminateComment = FALSE;

	err = _nlsComment.CopyFrom( puser2->QueryComment() );
	if ( err != NERR_Success )
	    return err;

	_fIndeterminateAccountDisabled = FALSE;

	_fAccountDisabled = puser2->QueryAccountDisabled();

	_fIndeterminateAccountLockout = FALSE;

	_fAccountLockout = puser2->QueryLockout();

	_triCannotChangePasswd = triCurrCannotChangePasswd;
	if ( !IsDownlevelVariant() )
	{
	    _triNoPasswordExpire = triCurrNoPasswordExpire;

	    _triForcePWChange = triCurrForcePWChange;

            _triIsNetWareUser = triCurrIsNetWareUser;
	}
    }
    else
    {
	if ( !_fIndeterminateComment )
	{
	    const TCHAR * pszNewComment = puser2->QueryComment();
	    ALIAS_STR nlsNewComment( pszNewComment );
	    if ( _nlsComment.strcmp( nlsNewComment ) )
	    {
	        _fIndeterminateComment = TRUE;
		APIERR err = _nlsComment.CopyFrom( NULL );
		if ( err != NERR_Success )
		    return err;
	    }
	}

	if ( !_fIndeterminateAccountDisabled )
	{
	    BOOL fNewAccountDisabled = puser2->QueryAccountDisabled();
	    if ( _fAccountDisabled != fNewAccountDisabled )
	    {
	        _fIndeterminateAccountDisabled = TRUE;
	    }
	}

	if ( !_fIndeterminateAccountLockout )
	{
	    BOOL fNewAccountLockout = puser2->QueryLockout();
	    if ( _fAccountLockout != fNewAccountLockout )
	    {
	        _fIndeterminateAccountLockout = TRUE;
	    }
	}

	if ( _triCannotChangePasswd != AI_TRI_INDETERMINATE &&
	     _triCannotChangePasswd != triCurrCannotChangePasswd )
	{
	    _triCannotChangePasswd = AI_TRI_INDETERMINATE;

	}

	if ( !IsDownlevelVariant() )
	{
	    if ( _triNoPasswordExpire != AI_TRI_INDETERMINATE &&
	         _triNoPasswordExpire != triCurrNoPasswordExpire )
	    {
	        _triNoPasswordExpire = AI_TRI_INDETERMINATE;
	    }

	    if ( _triIsNetWareUser != AI_TRI_INDETERMINATE &&
	         _triIsNetWareUser != triCurrIsNetWareUser )
	    {
	        _triIsNetWareUser = AI_TRI_INDETERMINATE;
	    }
	}

	if ( !IsDownlevelVariant() )
	{
	    if ( _triForcePWChange != AI_TRI_INDETERMINATE &&
	         _triForcePWChange != triCurrForcePWChange )
	    {
	        _triForcePWChange = AI_TRI_INDETERMINATE;
	    }
	}

    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       USERPROP_DLG::W_MembersToLMOBJ

    SYNOPSIS:	Loads class data members into the USER_2 object

    ENTRY:	Pointer to a USER_2 to be modified

    RETURNS:	error code

    NOTES:	If some fields were different for multiply-selected
    		objects, the initial contents of the edit fields
		contained only a default value.  In this case, we only
		want to change the LMOBJ if the value of the edit field
		has changed.  This is also important for "new" variants,
		where PerformOne will not always copy the object and
		work with the copy.

    NOTES:	Note that the LMOBJ is not changed if the current
		contents of the edit field are the same as the
		initial contents.

    HISTORY:
	       JonN  20-Aug-1991    Multiselection redesign

********************************************************************/

APIERR USERPROP_DLG::W_MembersToLMOBJ(
	USER_2 *	puser2,
	USER_MEMB *	pusermemb
	)
{
    UNREFERENCED( pusermemb );

    APIERR err = NERR_Success;

    if ( !_fIndetNowComment )
    {
	err = puser2->SetComment( _nlsComment );
	if ( err != NERR_Success )
	    return err;
    }

    if ( !_fIndetNowAccountDisabled )
    {
	err = puser2->SetAccountDisabled( _fAccountDisabled );
	if ( err != NERR_Success )
	    return err;
    }

    if ( !IsNewVariant() && !_fIndetNowAccountLockout )
    {
	err = puser2->SetLockout( _fAccountLockout );
	if ( err != NERR_Success )
	    return err;
    }

    if ( _triCannotChangePasswd != AI_TRI_INDETERMINATE )
    {
        err = puser2->SetUserCantChangePass( (_triCannotChangePasswd ==
		AI_TRI_CHECK) ? TRUE : FALSE );
	if( err != NERR_Success )
	    return err;
    }

    if ( !IsDownlevelVariant() )
    {
        if ( _triNoPasswordExpire != AI_TRI_INDETERMINATE )
        {
            err = ((USER_3 *)puser2)->SetNoPasswordExpire(
		(_triNoPasswordExpire == AI_TRI_CHECK) ? TRUE : FALSE );
	    if( err != NERR_Success )
	        return err;
        }

        if ( _triForcePWChange != AI_TRI_INDETERMINATE )
        {
            // CODEWORK Manifest for -1
            err = ((USER_3 *)puser2)->SetPasswordExpired(
		(_triForcePWChange == AI_TRI_CHECK) ? (DWORD)(-1L) : 0L );
	    if( err != NERR_Success )
	        return err;
        }

        if ( IsNetWareInstalled() && _triIsNetWareUser != AI_TRI_INDETERMINATE )
        {
            if (_triIsNetWareUser == AI_TRI_UNCHECK)
                return ((USER_NW *)puser2)->RemoveNetWareUser ();

            BOOL fWasNetWareUser;
            if ((err = ((USER_NW *) puser2)->QueryIsNetWareUser(&fWasNetWareUser)) != NERR_Success)
                return err;

            // Set the password if the user was not NetWare user or password changed.
            if (!fWasNetWareUser || _fPasswordChanged)
            {
                NLS_STR nlsNWPassword;
                if ((( err = nlsNWPassword.QueryError()) != NERR_Success) ||
                    (( err = GetNWPassword (puser2, &nlsNWPassword, &_fCancel)) != NERR_Success) ||
                    _fCancel)
                {
                    return err;
                }

                AUTO_CURSOR autocur;

                DWORD dwUserId = ((USER_3 *)puser2)->QueryUserId();

                //
                // map Rid to Object Id.
                //
                if ((err = CallMapRidToObjectId (dwUserId,
                                                 (LPWSTR)((USER_3 *)puser2)->QueryName(),
                                                 QueryTargetServerType()==UM_LANMANNT,
                                                 FALSE,
                                                 &dwUserId)) != NERR_Success)
                    return err;

                if (!fWasNetWareUser)
                {
                    err = ((USER_NW *) puser2)->CreateNetWareUser(
                              QueryAdminAuthority(),
                              dwUserId,
                              nlsNWPassword.QueryPch());
                    if (err == NERR_Success)
                    {
                        err = ((USER_NW *) puser2)->SetupNWLoginScript(
                                   QueryAdminAuthority(),
                                   dwUserId);
                    }

                }
                else
                {
                    UIASSERT (_fPasswordChanged);
                    err = ((USER_NW *) puser2)->SetNWPassword (QueryAdminAuthority(), dwUserId, nlsNWPassword.QueryPch());
                }

                return err;
            }
        }
    }

    return NERR_Success;
}

/*******************************************************************

    NAME:       USERPROP_DLG::GetNWPassword

    SYNOPSIS:	Get NetWare password from the NetWare password dialog.

    RETURNS:	

    HISTORY:
	       CongpaY  13-Oct-1993     Created

********************************************************************/
APIERR USERPROP_DLG::GetNWPassword (USER_2 *	puser2,
                                    NLS_STR *   pnlsNWPassword,
                                    BOOL *      pfCancel )
{
    ASSERT( IsNetWareInstalled() );

    APIERR err = NERR_Success;

    if (*pfCancel)
        return ((USER_NW *)puser2)->RemoveNetWareUser ();

    BOOL fOK;
    NW_PASSWORD_DLG * pdlg = new NW_PASSWORD_DLG (this,
                                                  puser2->QueryName(),
                                                  pnlsNWPassword);

    if (pdlg == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    err = pdlg->Process(&fOK);
    delete pdlg;

    if (!fOK)
    {
        *pfCancel = TRUE;
        return ((USER_NW *)puser2)->RemoveNetWareUser ();
    }

    return err;
}

/*******************************************************************

    NAME:       USERPROP_DLG::W_DialogToMembers

    SYNOPSIS:	Loads data from dialog into class data members

    RETURNS:	error message (not necessarily an error code)

    HISTORY:
	       JonN  21-Aug-1991    Multiselection redesign

********************************************************************/

APIERR USERPROP_DLG::W_DialogToMembers(
	)
{
    // BUGBUG should this clear leading/trailing whitespace?
    APIERR err = NERR_Success;
    if (    ((err = _sleComment.QueryText( &_nlsComment )) != NERR_Success )
	 || ((err = _nlsComment.QueryError()) != NERR_Success ) )
    {
	return err;
    }

    _fIndetNowComment = ( _fIndeterminateComment &&
		(_nlsComment.strlen() == 0) );

    _fIndetNowAccountDisabled = _cbAccountDisabled.IsIndeterminate();
    if( !_fIndetNowAccountDisabled )
	 _fAccountDisabled = _cbAccountDisabled.IsChecked();

    if ( !IsNewVariant() )
    {
        ASSERT( _pcbAccountLockout != NULL );

        _fIndetNowAccountLockout = _pcbAccountLockout->IsIndeterminate();
        if( !_fIndetNowAccountLockout )
        {
            _fAccountLockout = _pcbAccountLockout->IsChecked();
            /*
             *  Accounts cannot be forced to lockout.  This can only
             *  happen if they were originally indeterminate.
             */
            if ( _fAccountLockout && _fIndeterminateAccountLockout )
            {
	        _pcbAccountLockout->ClaimFocus();
    	        _pcbAccountLockout->SetIndeterminate();
                return IDS_CannotForceLockout;
            }
        }
    }

    if( _cbUserCannotChange.IsIndeterminate() )
    {
	_triCannotChangePasswd = AI_TRI_INDETERMINATE;
    }
    else
    {
	_triCannotChangePasswd = _cbUserCannotChange.IsChecked() ?
		AI_TRI_CHECK : AI_TRI_UNCHECK;
    }	

    if ( !IsDownlevelVariant() )
    {
        if( _pcbNoPasswordExpire->IsIndeterminate() )
        {
	    _triNoPasswordExpire = AI_TRI_INDETERMINATE;
        }
        else
        {
	    _triNoPasswordExpire = _pcbNoPasswordExpire->IsChecked() ?
		    AI_TRI_CHECK : AI_TRI_UNCHECK;
        }	

        if( _pcbForcePWChange->IsIndeterminate() )
        {
	    _triForcePWChange = AI_TRI_INDETERMINATE;
        }
        else
        {
	    _triForcePWChange = _pcbForcePWChange->IsChecked() ?
		    AI_TRI_CHECK : AI_TRI_UNCHECK;
        }	

        /*
         * Check for inconsistencies in the password control checkboxes
         */

        BOOL fInconsistentPWControl = FALSE;
        BOOL fForcePWChangeIgnore = FALSE;
        switch (_triForcePWChange)
        {
        case AI_TRI_CHECK:
            if (_triCannotChangePasswd != AI_TRI_UNCHECK)
                fInconsistentPWControl = TRUE;
            if (_triNoPasswordExpire != AI_TRI_UNCHECK)
                fForcePWChangeIgnore = TRUE;
            break;

        case AI_TRI_UNCHECK:
            break;

        case AI_TRI_INDETERMINATE:
            if (_triCannotChangePasswd == AI_TRI_CHECK)
                fInconsistentPWControl = TRUE;
            if (_triNoPasswordExpire == AI_TRI_CHECK)
                fForcePWChangeIgnore = TRUE;
            break;

        }

    	if ( fInconsistentPWControl )
	    {
	        return IERR_UM_InconsistentPWControl;
	    }

    	if ( fForcePWChangeIgnore )
	    {
	        // Just warn the user.
	        ::MsgPopup( this, IDS_UM_ForcePWChangeIgnore,
			            MPSEV_WARNING, MP_OK );
	    }

        if (IsNetWareInstalled())
        {
            if( _pcbIsNetWareUser->IsIndeterminate() )
            {
    	        _triIsNetWareUser = AI_TRI_INDETERMINATE;
            }
            else
            {
                if (_pcbIsNetWareUser->IsChecked())
                {
                    if (_triIsNetWareUser != AI_TRI_CHECK || _fNetWareUserChanged)
                    {
                        _fNetWareUserChanged = TRUE;
                        _triIsNetWareUser = AI_TRI_CHECK;
                        if (_cItems > 1)
                        {
                            if (MsgPopup ( this,
                                           IDS_NETWARE_PASSWORD_PROMPT,
                                           MPSEV_WARNING,
                                           MP_YESNO,
                                           MP_YES) != IDYES )
                                return ERROR_CANCELLED;
                        }
                    }
                }
                else
                {
                    if (_triIsNetWareUser != AI_TRI_UNCHECK)
                    {
                        LM_SERVICE svc( QueryLocation().QueryServer(),
                                        NW_SYNCAGENT_SERVICE);

                        if ((svc.QueryError() == NERR_Success) &&
                            svc.IsStarted())
                        {
                            if (MsgPopup ( this,
                                           _cItems > 1 ?
                                               IDS_REMOVE_NETWARE_USERS:
                                               IDS_REMOVE_NETWARE_USER,
                                           MPSEV_WARNING,
                                           MP_YESNO,
                                           MP_YES) != IDYES )
                                return ERROR_CANCELLED;
                        }

                        _fNetWareUserChanged = TRUE;
                        _triIsNetWareUser = AI_TRI_UNCHECK;
                    }
                }
            }	
        }
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       USERPROP_DLG::GetOne

    SYNOPSIS:   Loads information on one user

    ENTRY:	iObject is the index of the object to load

		perrMsg returns the error message to be displayed if an
		error occurs, see PERFORMER::PerformSeries for details

    RETURNS:	error code

    NOTES:      This version of GetOne assumes that the user already
		exists.  Subclasses which work with new users will want
		to redefine GetOne.

    CAVEATS:	Error 5 in GetInfo here has some unusual implications.
		The error text should note that account operators may not
		view properties of any admin or any user with operator
		rights, except him/herself.  More confusing, an account
		operator may view him/herself but may not edit
		him/herself.  Also noted for PerformOne().

    HISTORY:
               JonN  17-Jul-1991    created
	       JonN  20-Aug-1991    Multiselection redesign
               JonN  16-Apr-1992    Skip USER_MEMB for WindowsNT
               JonN  07-Jul-1992    Normal users can run UsrMgr, so
                                    check if user can write

********************************************************************/

APIERR USERPROP_DLG::GetOne(
	UINT		iObject,
	APIERR *	perrMsg
	)
{
    UIASSERT( iObject < QueryObjectCount() );
    UIASSERT( perrMsg != NULL );

    *perrMsg = IDS_UMGetOneFailure;
    const TCHAR * pszName = QueryObjectName( iObject );
    UIASSERT( pszName != NULL );

    APIERR err = NERR_Success;

#ifndef DISABLE_ACCESS_CHECK

// Check whether we have write permission.  If not, do not allow
// editing.
// CODEWORK:  We might want a better error message for the case where
// we can read but not edit.
// CODEWORK:  It would be nice if this dialog had a "read-only mode".
    if ( !IsDownlevelVariant() )
    {
        UIASSERT( _psel != NULL );
        SAM_USER samuser( *(QueryAdminAuthority()->QueryAccountDomain()),
                          ((USER_LBI *)(_psel->QueryItem(iObject)))->QueryRID(),
                          USER3_DESIRED_ACCESS_ALL );
        err = samuser.QueryError();
        if (err != NERR_Success)
        {
            DBGEOL( "User Manager: no permission to edit user" );
            return err;
        }
    }

#endif // DISABLE_ACCESS_CHECK

    USER_2 * puser2New = NULL;
    if (IsDownlevelVariant())
    {
        puser2New = new USER_2( pszName, QueryLocation() );
    }
    else
    {
        puser2New = new USER_3( pszName, QueryLocation() );
    }
    if ( puser2New == NULL )
	return ERROR_NOT_ENOUGH_MEMORY;
    err = puser2New->QueryError();
    if ( err == NERR_Success )
    	err = puser2New->GetInfo();
    if ( err != NERR_Success )
    {
	delete puser2New;
	return err;
    }
    SetUser2Ptr( iObject, puser2New ); // change and delete previous

    if (DoShowGroups())
    {
        USER_MEMB * pusermembNew = new USER_MEMB( QueryLocation(), pszName );
        if ( pusermembNew == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;
        err = pusermembNew->QueryError();
        if ( err == NERR_Success )
        	err = pusermembNew->GetInfo();
        if ( err != NERR_Success )
        {
            delete pusermembNew;
            return err;
        }

        // next we remove special groups for downlevel
        if ( IsDownlevelVariant() )
        {
            if (   (err = RemoveGroup( ::pszSpecialGroupGuests, pusermembNew )) != NERR_Success
                || (err = RemoveGroup( ::pszSpecialGroupUsers,  pusermembNew )) != NERR_Success
                || (err = RemoveGroup( ::pszSpecialGroupAdmins, pusermembNew )) != NERR_Success
            )
        	{
                delete pusermembNew;
                return err;
            }
        }

        SetUserMembPtr( iObject, pusermembNew ); // change and delete previous
    }

    // hydra
    USER_CONFIG * pUserConfig = NULL;
    pUserConfig = new USER_CONFIG( pszName, QueryLocation().QueryServer() );

    if ( pUserConfig == NULL )
	return ERROR_NOT_ENOUGH_MEMORY;

    if ( (err = pUserConfig->QueryError()) == NERR_Success ) {

    	if ( pUserConfig->GetInfo() != NERR_Success ) {

            /*
             * Error on GetInfo() (the user is not configured) -- set defaults.
             */
            pUserConfig->SetDefaults( ((UM_ADMIN_APP *)_pumadminapp)->QueryDefaultUserConfig() );
        }

    } else {

	delete pUserConfig;
	return err;
    }

    SetUserConfigPtr( iObject, pUserConfig );
    // hydra end

    return W_LMOBJtoMembers( iObject );
}


/*******************************************************************

    NAME:       USERPROP_DLG::RemoveGroup
	
    SYNOPSIS:	Removes group from USER_MEMB

    ENTRY:	psz	-	pointer to group to removed
	
		pumemb  -	pointer to USER_MEMB

    RETURNS:	error message which is NERR_Success on success
	        (it is success if we don't even find the group)

    HISTORY:
               o-SimoP  29-Oct-1991    created

********************************************************************/

APIERR USERPROP_DLG::RemoveGroup( const TCHAR * psz,
				  USER_MEMB * pumemb )
{
    APIERR err = NERR_Success;
    UINT uIndex;
    if( pumemb->FindAssocName( psz, &uIndex ) )
    {	
	err = pumemb->DeleteAssocName( uIndex );
    }
    return err;
}


/*******************************************************************

    NAME:       USERPROP_DLG::PerformOne

    SYNOPSIS:	Saves information on one user

    ENTRY:	iObject is the index of the object to save

		perrMsg is the error message to be displayed if an
		error occurs, see PERFORMER::PerformSeries for details

		pfWorkWasDone indicates whether any UAS changes were
		successfully written out.  This may return TRUE even if
		the PerformOne action as a whole failed (i.e. PerformOne
		returned other than NERR_Success).

    RETURNS:	error message (not necessarily an error code)

    NOTES:	CODEWORK  This implementation sets user membership even
		for the "existing user(s)" variants.  This is only
		necessary for the "new user" variants.

    HISTORY:
               JonN  17-Jul-1991    created
	       JonN  20-Aug-1991    Multiselection redesign
	       JonN  26-Aug-1991    PROP_DLG code review changes
	       JonN  30-Dec-1991    New variant inherits this version
	       JonN  31-Dec-1991    Workaround for LM2x InvalParam bug
	       JonN  01-Jan-1992    Split off I_PerformOneClone()/Write()
               JonN  16-Apr-1992    Skip USER_MEMB for WindowsNT
    thomaspa	28-Apr-1992	Alias membership support
               JonN  03-Feb-1993    split membership support to
                                    NEW_USERPROP_DLG::PerformOne

********************************************************************/

APIERR USERPROP_DLG::PerformOne(
	UINT		iObject,
	APIERR *	perrMsg,
	BOOL *		pfWorkWasDone
	)
{
    UIASSERT( iObject < QueryObjectCount() );
    UIASSERT( (!IsNewVariant()) || (iObject == 0) );
    UIASSERT( (perrMsg != NULL) && (pfWorkWasDone != NULL) );

    TRACEEOL( "USERPROP_DLG::PerformOne : " << QueryObjectName( iObject ) );

    *perrMsg = (IsNewVariant()) ? IDS_UMCreateFailure : IDS_UMEditFailure;
    *pfWorkWasDone = FALSE;

    USER_2 * puser2New = NULL;
    USER_MEMB * pusermembNew = NULL;

    APIERR err = I_PerformOne_Clone( iObject,
                                     &puser2New,
                                     (DoShowGroups()) ? &pusermembNew : NULL );

    if ( err == NERR_Success )
    {
	err = W_MembersToLMOBJ( puser2New, pusermembNew );
	if ( err != NERR_Success )
	{
	    delete puser2New;
	    puser2New = NULL;
	    delete pusermembNew;
	    pusermembNew = NULL;

	}
    }

    if ( (err == NERR_Success) && IsNewVariant() )
    {
        err = W_MapPerformOneError(
                ((UM_ADMIN_APP *)_pumadminapp)->ConfirmNewObjectName( puser2New->QueryName() ));

        // hydra
        if ( err == NERR_Success ) {

            USER_CONFIG * pUserConfig = QueryUserConfigPtr( iObject );
            err = pUserConfig->SetUserName( puser2New->QueryName() );
        }
        // hydra end
    }

    if ( err == NERR_Success )
    {
	err = I_PerformOne_Write( iObject,
				  puser2New,
				  pusermembNew,
				  pfWorkWasDone );

        // Note that puser2New may no longer be valid after I_PerformOne_Write

        // We used to call NotifyCreateExtensions here, but no more; this
        // is now delayed until after setting up the aliases, so that we
        // can pass the RID of the new user.  JonN 8/3/94

	if ( err != NERR_Success )
	    err = W_MapPerformOneError( err );
    }

    
    // hydra
    if ( err == NERR_Success ) {

        USER_CONFIG * pUserConfig = QueryUserConfigPtr( iObject );
        if ( (err = pUserConfig->SetInfo()) == NERR_Success )
            *pfWorkWasDone = TRUE;

    }
    // hydra end

    TRACEEOL( "USERPROP_DLG::PerformOne returns " << err );

    return err;

}


/*******************************************************************

    NAME:       USERPROP_DLG::I_PerformOne_Clone

    SYNOPSIS:	Clones the existing USER_2 and/or USER_MEMB for the
		selected user, and returns pointers to the cloned
		objects.  If ppuser2New is NULL, the USER_2 is not
		cloned; same for ppusermembNew.

		The returned objects (if any) must be freed by the caller,
		regardless of the return code.  These objects are only
		guaranteed to be valid if the return code is NERR_Success.

    ENTRY:      ppuser2New: location to store cloned USER_2; if NULL,
			do not clone USER_2
		ppusermembMew: see ppuser2New

    RETURNS:	Standard error code

    HISTORY:
	       JonN  01-Jan-1992    Split from PerformOne()
               JonN  16-Apr-1992    Skip USER_MEMB for WindowsNT

********************************************************************/

APIERR USERPROP_DLG::I_PerformOne_Clone(
	UINT		iObject,
	USER_2 **	ppuser2New,
	USER_MEMB **	ppusermembNew
	)
{
    USER_2 * puser2New = NULL;
    USER_MEMB * pusermembNew = NULL;

    APIERR err = NERR_Success;

    if ( ppuser2New != NULL )
    {
        USER_2 * puser2Old = QueryUser2Ptr( iObject );
	UIASSERT( puser2Old != NULL );
        if (IsDownlevelVariant())
        {
            puser2New = new USER_2( puser2Old->QueryName() );
	    err = ERROR_NOT_ENOUGH_MEMORY;
	    if (   (puser2New != NULL )
	        && (err = puser2New->QueryError()) == NERR_Success )
	    {
	        err = puser2New->CloneFrom( *puser2Old );
	    }
        }
        else
        {
	    puser2New = new USER_3( puser2Old->QueryName() );
	    err = ERROR_NOT_ENOUGH_MEMORY;
	    if (   (puser2New != NULL )
	        && (err = puser2New->QueryError()) == NERR_Success )
	    {
	        err = ((USER_3 *)puser2New)->CloneFrom(*((USER_3 *)puser2Old));
	    }
        }
    }

    if ( (err == NERR_Success) && (ppusermembNew != NULL) )
    {
	USER_MEMB * pusermembOld = QueryUserMembPtr( iObject );
        if (pusermembOld != NULL)
        {
            // CODEWORK USER_MEMB should have a QueryName method
            pusermembNew = new USER_MEMB( QueryLocation(), pusermembOld->QueryName() );
            err = ERROR_NOT_ENOUGH_MEMORY;
            if (   (pusermembNew != NULL )
                && (err = pusermembNew->QueryError()) == NERR_Success )
            {
                err = pusermembNew->CloneFrom( *pusermembOld );
            }
        }
    }

    if ( err != NERR_Success )
    {
	delete puser2New;
	puser2New = NULL;
	delete pusermembNew;
	pusermembNew = NULL;
    }

    if ( ppuser2New != NULL )
	*ppuser2New = puser2New;
    if ( ppusermembNew != NULL )
	*ppusermembNew = pusermembNew;

    return err;

}


/*******************************************************************

    NAME:       USERPROP_DLG::I_PerformOne_Write

    SYNOPSIS:	Writes out the provided USER_2 and USER_MEMB objects,
		and if successful, replaces the remembers objects for
		the selected user. If puser2New is NULL, the USER_2 is not
		written; same for pusermembNew.

		The provided objects (if any) will be freed by this
		method, and should not be further accessed by the
		caller.  The caller should also be warned that this
		method may or may not replace the remembered objects for
		this user, whether or not it returns success.

    ENTRY:      puser2New: cloned USER_2 to be written; if NULL,
			do not write USER_2
		pusermembMew: see ppuser2New

		pfWorkWasDone indicates whether any UAS changes were
		successfully written out.  This may return TRUE even if
		the PerformOne action as a whole failed (i.e. PerformOne
		returned other than NERR_Success).

    RETURNS:	Standard error code

    NOTES:      There is an odd workaround to deal with a bug in LM2x.
		If you try to change a user with operator rights
		(account operator etc.) directly into a guest,
		NetUserSetInfo will fail with ERROR_INVALID_PARAMETER (87).
		You must first remove the operator right, then change
		the privilege level.  When USER_2::Write() fails with
		this error code, we check whether this may potentially
		have happened, and if so, we try to change the user's
		properties in two steps rather than one (for a total of
		3 net calls).  This workaround is in response to
		NTISSUES bug 656.

    CAVEATS:	Error 5 in GetInfo here has some unusual implications.
		The error text should note that account operators may not
		view properties of any admin or any user with operator
		rights, except him/herself.  More confusing, an account
		operator may view him/herself but may not edit
		him/herself.  Also noted for GetOne().

    HISTORY:
	       JonN  01-Jan-1992    Split from PerformOne()
	       Thomaspa 30-Jul-1992 Create HomeDir
	       Johnl	05-Aug-1992 Added security for Homedir
               JonN     05-May-1993 Restructured PrimaryGroup support
               JonN     17-Jun-1993 Fixed PrimaryGroup for new users

********************************************************************/

APIERR USERPROP_DLG::I_PerformOne_Write(
	UINT		iObject,
	USER_2 *	puser2New,
	USER_MEMB *	pusermembNew,
	BOOL *		pfWorkWasDone,
        OWNER_WINDOW *  pwndPopupParent
	)
{
    APIERR err = NERR_Success;
    BOOL fHomeDirChanged = FALSE;
    NLS_STR * pnlsHomeDir = NULL;
    ULONG ulPrimaryGroupIdSave = 0L;

    // hydra 
    NLS_STR       *pnlsWFHomeDir     = NULL;
    USER_CONFIG   *pUserConfig       = QueryUserConfigPtr( iObject );
    // hydra end

    if ( puser2New != NULL )
    {
	// Determine if a Home Directory has changed
	pnlsHomeDir = new NLS_STR( puser2New->QueryHomeDir() );

	err = ERROR_NOT_ENOUGH_MEMORY;
	if ( pnlsHomeDir == NULL
	    || (err = pnlsHomeDir->QueryError()) != NERR_Success )
	{
            delete pnlsHomeDir;
	    return err;
	}

	if ( pnlsHomeDir->strlen() > 0
	    && ( IsNewVariant()
		|| ::stricmpf( pnlsHomeDir->QueryPch(),
			     QueryUser2Ptr(iObject)->QueryHomeDir() ) != 0  ) )
	{
	    fHomeDirChanged = TRUE;
	}

        //
	// If the user's Primary Group has changed, add that group
        // to the group membership before changing the primary group.
        //
	if ( QueryTargetServerType() == UM_LANMANNT
             && pusermembNew != NULL
           )
	{
	    ULONG ulPrimaryGroupIdOld = QueryUser3Ptr(iObject)->QueryPrimaryGroupId();
	    ULONG ulPrimaryGroupIdNew = ((USER_3 *)puser2New)->QueryPrimaryGroupId();
            ASSERT( (ulPrimaryGroupIdOld != 0L) && (ulPrimaryGroupIdNew != 0L) );
            if ( IsNewVariant() )
            {
                if ( ulPrimaryGroupIdNew != DOMAIN_GROUP_RID_USERS )
                {
                    TRACEEOL( "USERPROP_DLG::I_PerformOne_Write: new user primary group " << ulPrimaryGroupIdNew );
                    ulPrimaryGroupIdSave = ulPrimaryGroupIdNew;
                    err = ((USER_3 *)puser2New)->SetPrimaryGroupId(
                                  DOMAIN_GROUP_RID_USERS );
                }
            }
            else if (ulPrimaryGroupIdOld != ulPrimaryGroupIdNew)
            {
                TRACEEOL( "USERPROP_DLG::I_PerformOne_Write: existing user new primary group "
                     << ulPrimaryGroupIdNew << ", old was " << ulPrimaryGroupIdOld );
                err = I_SetExtendedMembership( QueryUserMembPtr( iObject ),
                                               ulPrimaryGroupIdNew,
                                               FALSE );
            }
	}

        if (err != NERR_Success)
        {
            delete pnlsHomeDir;
	    return err;
        }

        if ( err == NERR_Success )
        {
            err = puser2New->Write();
        }

	switch (err)
	{

	case NERR_Success:

            //
            // Now that we have written the new or corrected password, we
            // do not attempt to rewrite the user account with the same
            // password.  As the admin, we are not subject to the password
            // history restriction, but there is not point in redoing it
            // every time.
            //
            err = puser2New->SetPassword( UI_NULL_USERSETINFO_PASSWD );

	    *pfWorkWasDone = TRUE;
	    SetUser2Ptr( iObject, puser2New ); // change and delete previous
	    puser2New = NULL;			// do not delete
	    break;

	// workaround for LM2x bug
	// It is important to set *pfWorkWasDone to TRUE and call SetUser2Ptr
	//   after the first Write() succeeds, otherwise if the second Write
	//   fails, the remembered USER_2 object and the UAS/SAM object will be
	//   inconsistent.
	// If we cannot determine whether the domain of focus is an LM2x
	//   domain, we assume it is and try the workaround.
	case ERROR_INVALID_PARAMETER:
	{
	    if ( ( QueryTargetServerType() == UM_DOWNLEVEL )
		&& ( puser2New->QueryPriv() == USER_PRIV_GUEST )
		&& ( QueryUser2Ptr( iObject )->QueryAuthFlags() != 0L ) )
	    {
		DBGEOL( "I_PerformOne_Write(): Attempting workaround" );
		if (   (err = puser2New->SetPriv( USER_PRIV_USER )) == NERR_Success
		    && (err = puser2New->Write()) == NERR_Success )
		    {
			UIDEBUG( SZ("Workaround: first write succeeded\n\r"));
		        *pfWorkWasDone = TRUE;
		        SetUser2Ptr( iObject, puser2New ); // change and
							   // delete previous
                        //
                        // Now that we have written the new or corrected password, we
                        // do not attempt to rewrite the user account with the same
                        // password.  As the admin, we are not subject to the password
                        // history restriction, but there is not point in redoing it
                        // every time.
                        //
                        err = puser2New->SetPassword( UI_NULL_USERSETINFO_PASSWD );

		        puser2New = NULL; // do not delete
			if (   (err = I_PerformOne_Clone( iObject, &puser2New, NULL )) == NERR_Success
			    && (err = puser2New->SetPriv( USER_PRIV_GUEST )) == NERR_Success
		    	    && (err = puser2New->Write()) == NERR_Success )
			{
			    UIDEBUG( SZ("Workaround: second write succeeded\n\r"));
		            SetUser2Ptr( iObject, puser2New ); // change and
							    // delete previous
			    puser2New = NULL;
			}
		    }
	    }
	}
	    break;

	default:
	    UIDEBUG(SZ("USERPROP_DLG::I_PerformOne_Write -- puser2New->Write failed\n\r"));
	    break;

	} // end of switch
    }

    if ( (err == NERR_Success) && (ulPrimaryGroupIdSave != 0L) )
    {
        ASSERT( IsNewVariant() && (QueryTargetServerType() == UM_LANMANNT) );

        USER_3 * puser3Newer = new USER_3( NULL );
	err = ERROR_NOT_ENOUGH_MEMORY;
	if (   puser3Newer == NULL
	    || (err = puser3Newer->QueryError()) != NERR_Success
	    || (err = puser3Newer->CloneFrom( *QueryUser3Ptr( iObject )) ) != NERR_Success
            || (err = I_SetExtendedMembership( pusermembNew,
                                               DOMAIN_GROUP_RID_USERS,
                                               TRUE )) != NERR_Success
            || (err = puser3Newer->SetPrimaryGroupId(
                                       ulPrimaryGroupIdSave )) != NERR_Success
            || (err = puser3Newer->Write()) != NERR_Success
           )
        {
            DBGEOL( "USERPROP_DLG::I_PerformOne_Write: error backpatching primary group " << err );
            delete puser3Newer;
        }
        else
        {
            SetUser2Ptr( iObject, puser3Newer ); // change and delete previous
        }
    }

    if ( (err == NERR_Success) && (pusermembNew != NULL) )
    {

        err = pusermembNew->Write();
        if ( err == NERR_Success )
	{
	    *pfWorkWasDone = TRUE;		// once we get this far
	    SetUserMembPtr( iObject, pusermembNew ); // change and delete prev
	    pusermembNew = NULL;			// do not delete
	}
#ifdef DEBUG
        else
        {
	    UIDEBUG(SZ("USERPROP_DLG::I_PerformOne_Write -- pusermembNew->Write failed\n\r"));
        }
#endif // DEBUG
    }

    // Create a new home directory if necessary

    if ( (err == NERR_Success) && (pnlsHomeDir != NULL) )
    {
	ISTR istr( *pnlsHomeDir );

        if ( err == NERR_Success
	    && fHomeDirChanged
	    && !( iObject > 0
	        && ::stricmpf( pnlsHomeDir->QueryPch(),
		               QueryUser2Ptr(0)->QueryHomeDir() ) == 0
	        && _fCommonHomeDirCreated )
            // hydra
            )
            /* original code
	    && ( QueryTargetServerType() == UM_WINDOWSNT
	        || (pnlsHomeDir->QueryChar(++istr) == TCH('\\')
		    && pnlsHomeDir->QueryChar(istr) == TCH('\\')) ) )
            */
        {
            istr.Reset();
	    // If focused on a Windows NT machine and the home dir is
	    // not a UNC path, we must make it into a UNC path
	    APIERR warn = NERR_Success;
	    BOOL   fIsUNC = (pnlsHomeDir->QueryChar(istr) == TCH('\\')) ;
	    if ( QueryLocation().QueryServer() != NULL
		&& QueryTargetServerType() == UM_WINDOWSNT
		&& pnlsHomeDir->QueryChar(istr) != TCH('\\') )
	    {
		NLS_STR nlsTemp = QueryLocation().QueryServer();
		// CODEWORK char constants
		nlsTemp.AppendChar( TCH('\\') );
		nlsTemp.AppendChar( pnlsHomeDir->QueryChar(istr) );
		nlsTemp.AppendChar( TCH('$') );
		istr += 2;
		NLS_STR *pnlsTemp2 = pnlsHomeDir->QuerySubStr( istr );
		warn = (pnlsTemp2 == NULL ? ERROR_NOT_ENOUGH_MEMORY :
					    pnlsTemp2->QueryError());
		if ( warn == NERR_Success )
		{
		    nlsTemp += *pnlsTemp2;
		    warn = nlsTemp.QueryError();
		}
		if ( warn == NERR_Success )
		{
		    warn = pnlsHomeDir->CopyFrom( nlsTemp );
		}
		delete pnlsTemp2 ;
	    }

            /* If the home directory is a root directory e.g. "C:\",
             * we map error ERROR_ACCESS_DENIED to ERROR_ALREADY_EXISTS.
             */
            BOOL fRootDir = FALSE;

	    while ( warn == NERR_Success ) // Error breakout loop
	    {
                /* Don't bother trying to create a root directory e.g. "C:\"
                 */
                if (pnlsHomeDir->QueryTextLength() == 3)
                {
                    ISTR istrTemp( *pnlsHomeDir );
                    if (   (pnlsHomeDir->QueryChar( ++istrTemp ) == TCH(':'))
                        && (pnlsHomeDir->QueryChar( ++istrTemp ) == TCH('\\'))
                       )
                    {
                        TRACEEOL( "USERPROP_DLG::I_PerformOne_Write: homedir is root directory" );
                        fRootDir = TRUE;
                    }
                }

		/* If the target is a WinNT machine and the homedir is remote
		 * or the target is downlevel
		 *     then don't put security on it.
		 */
		if ( (QueryTargetServerType() == UM_WINDOWSNT && fIsUNC) ||
		      QueryTargetServerType() == UM_DOWNLEVEL )
		{
		    if ( !::CreateDirectory( (TCHAR *)pnlsHomeDir->QueryPch(),
					     NULL ) )
		    {
			warn = ::GetLastError();
            // hydra
		    } else {

                        NLS_STR nlsDir( (TCHAR *)pnlsHomeDir->QueryPch() );
                        NLS_STR nlsTemp( TEXT("\\windows") );
                        if ( ((warn = nlsDir.QueryError()) != NERR_Success) ||
                             ((warn = nlsTemp.QueryError()) != NERR_Success) ||
                             ((warn = nlsDir.Append(nlsTemp)) != NERR_Success) )
                            goto breakout1; // error breakout

		        if ( !::CreateDirectory( (TCHAR *)nlsDir.QueryPch(),
			                         NULL ) )
		        {
			    warn = ::GetLastError();
                            goto breakout1; // error breakout
		    }

                        nlsTemp = TEXT("\\system");
                        if ( ((warn = nlsTemp.QueryError()) != NERR_Success) ||
                             ((warn = nlsDir.Append(nlsTemp)) != NERR_Success) )
                            goto breakout1;  // error breakout

		        if ( !::CreateDirectory( (TCHAR *)nlsDir.QueryPch(),
			                         NULL ) )
		        {
			    warn = ::GetLastError();
                        }
		    }
breakout1:
            // hydra end
        /* Original code

		    }
            */
		    break ; // Get out of this error breakout loop
		}

		OS_SECURITY_DESCRIPTOR sdNewDir ;
		OS_SID		       ossid ;
		OS_ACL		       aclDacl ;
		OS_ACE		       osace ;
		if ( (warn = sdNewDir.QueryError()) ||
		     (warn = ossid.QueryError())    ||
		     (warn = aclDacl.QueryError())  ||
		     (warn = osace.QueryError()) )
		{
		    break ;
		}

		/* This sets up an ACE with Generic all access that will be
		 * inheritted by directories and files
		 */
		osace.SetAccessMask( GENERIC_ALL ) ;
		osace.SetInheritFlags( CONTAINER_INHERIT_ACE|OBJECT_INHERIT_ACE) ;
		osace.SetType( ACCESS_ALLOWED_ACE_TYPE ) ;

        // hydra
                /* Set up a special admins ACE with Generic all access but
                 * no inheritance for directories and files.  This is for
                 * the Home directory only.  Directory and file inheritance
                 * will be given for the Windows and System directories before
                 * those directories are created.
                 */
                OS_ACE                     osadminace ;
 	        if ( (warn = osadminace.QueryError()) )
                {
                    break ;
		}
		osadminace.SetAccessMask( GENERIC_ALL ) ;
		osadminace.SetInheritFlags( 0 ) ;
		osadminace.SetType( ACCESS_ALLOWED_ACE_TYPE ) ;
        // hydra end

		/* NTFS puts the Administrator's alias as both the primary
		 * group and owner of the root of NTFS drives.
		 * We'll do the same thing for the homedir.
		 */
		SAM_DOMAIN * psamdomAccount =
				QueryAdminAuthority()->QueryAccountDomain();
		OS_SID ossidAdmins(QueryAdminAuthority()->QueryBuiltinDomain()->
					       QueryPSID(),
				    (ULONG) DOMAIN_ALIAS_RID_ADMINS ) ;
		if ( (warn = ossidAdmins.QueryError())	       ||
		     (warn = sdNewDir.SetGroup( ossidAdmins )) ||
		     (warn = sdNewDir.SetOwner( ossidAdmins	))   )
		{
		    break ;
		}

		/* If multi-select and all of the homedirs are the same
		 *    then put World (Full Access)
		 * else
		 *    Put the selected user w/Full Access
		 */
		if ( QueryObjectCount() > 1
		    && !_fGeneralizedHomeDir )
		{
		    /* Add World (Full Access)
		     */
		    OS_SID ossidWorld ;
		    if ( (warn = ossidWorld.QueryError()) ||
			 (warn = NT_ACCOUNTS_UTILITY::QuerySystemSid(
							       UI_SID_World,
							       &ossidWorld )) ||
			 (warn = osace.SetSID( ossidWorld )) ||
			 (warn = aclDacl.AddACE( 0, osace )) ||
			 (warn = sdNewDir.SetDACL( TRUE, &aclDacl )) )
		    {
			break ;
		    }
		}
		else
		{
		    /* Add <User> (Full Access)
		     */
		    const TCHAR * pszUser = QueryUser2Ptr(iObject)->QueryName() ;
		    SAM_RID_MEM SAMRidMem ;
		    SAM_SID_NAME_USE_MEM SAMSidNameUseMem ;

		    if ( (warn = SAMRidMem.QueryError()) ||
			 (warn = SAMSidNameUseMem.QueryError()) ||
			 (warn = psamdomAccount->TranslateNamesToRids(
							&pszUser,
							1,
							&SAMRidMem,
							&SAMSidNameUseMem )))
		    {
			DBGEOL("USERPROP_DLG::I_PerformOne_Write - TranslateNamesToRids "
				<< "failed with error " << warn ) ;
			break ;
		    }

		    OS_SID ossidUser( psamdomAccount->QueryPSID(),
				      SAMRidMem.QueryRID( 0 )) ;

		    if ( (warn = ossidUser.QueryError()) ||
			 (warn = osace.SetSID( ossidUser )) ||
			 (warn = aclDacl.AddACE( 0, osace )) ||
             // hydra
                         /* Add <admins> (Full Access; no inherit)
                          */
			 (warn = osadminace.SetSID( ossidAdmins )) ||
			 (warn = aclDacl.AddACE( 1, osadminace )) ||
            // hydra end

			 (warn = sdNewDir.SetDACL( TRUE, &aclDacl )) )
		    {
			break ;
		    }
		}

#if defined(DEBUG) && defined(TRACE)
		TRACEEOL("USERPROP_DLG::I_PerformOne_Write - Creating homedir "
			 << "with the following security descriptor:") ;
		sdNewDir.DbgPrint() ;
#endif

		SECURITY_ATTRIBUTES saNewHomeDir ;
		saNewHomeDir.nLength = sizeof( SECURITY_ATTRIBUTES ) ;
		saNewHomeDir.bInheritHandle = TRUE ;  // probably ignored
		saNewHomeDir.lpSecurityDescriptor = sdNewDir.QueryDescriptor() ;

		if ( !::CreateDirectory( (TCHAR *)pnlsHomeDir->QueryPch(),
					 &saNewHomeDir ) )
		{
		    warn = ::GetLastError();
            // hydra
                } else {

                    NLS_STR nlsDir( (TCHAR *)pnlsHomeDir->QueryPch() );
                    NLS_STR nlsTemp( TEXT("\\windows") );
                    if ( ((warn = nlsDir.QueryError()) != NERR_Success) ||
                         ((warn = nlsTemp.QueryError()) != NERR_Success) ||
                         ((warn = nlsDir.Append(nlsTemp)) != NERR_Success) )
                        goto breakout2;     // error breakout

                    /* Remove the admin ACE from the security descriptor
                     * and replace with an ACE that has full inheritance
                     * for creating the Windows and System directories.
                     */
                    if ( (warn = aclDacl.DeleteACE( 1 )) )
                        goto breakout2;     // error breakout

		    osadminace.SetInheritFlags( CONTAINER_INHERIT_ACE|OBJECT_INHERIT_ACE ) ;

		    if ( (warn = aclDacl.AddACE( 1, osadminace )) ||
			 (warn = sdNewDir.SetDACL( TRUE, &aclDacl )) )
                        goto breakout2;     // error breakout

		    saNewHomeDir.lpSecurityDescriptor = sdNewDir.QueryDescriptor() ;

	            if ( !::CreateDirectory( (TCHAR *)nlsDir.QueryPch(),
					     &saNewHomeDir ) )
		    {
		        warn = ::GetLastError();
                        goto breakout2;     // error breakout
		}

                    nlsTemp = TEXT("\\system");
                    if ( ((warn = nlsTemp.QueryError()) != NERR_Success) ||
                         ((warn = nlsDir.Append(nlsTemp)) != NERR_Success ) )
                        goto breakout2;     // error breakout

		    if ( !::CreateDirectory( (TCHAR *)nlsDir.QueryPch(),
                                             &saNewHomeDir ) )
                    {
		        warn = ::GetLastError();
                        goto breakout2;     // error breakout
		    }
                }
breakout2:
// hydra end                
/* original code
		}
 */
		break ; // Get out of this error breakout loop
	    }

	    // Do this whether or not the create succeeds.  If it fails once,
	    // then chances are it will fail everytime, so don't waste time.
	    _fCommonHomeDirCreated = TRUE;

            TRACEEOL("USERPROP_DLG::I_PerformOne_Write - homedir creation warning " << warn );

            switch (warn)
            {
            case NERR_Success:
            case ERROR_ALREADY_EXISTS:
                break;

            case ERROR_ACCESS_DENIED:
                if (fRootDir)
                {
                    TRACEEOL("USERPROP_DLG::I_PerformOne_Write - ignore rootdir exists warning" );
                    break;
                }
                // else fall through

            default:
		// CODEWORK - should display the username and specific error
		::MsgPopup( (pwndPopupParent == NULL) ? this : pwndPopupParent,
                            IDS_PR_CannotCreateHomeDir,
			    MPSEV_WARNING, MP_OK, pnlsHomeDir->QueryPch(),
			    QueryUser2Ptr(iObject)->QueryName() );
                break;
	    }
	}
    }

    // hydra start

//  Start WFHomeDir Stuff

    // Create a new home directory if necessary

    if ( pUserConfig != NULL )
    {
        // Determine if a Home Directory has changed
        pnlsWFHomeDir = new NLS_STR( pUserConfig->QueryWFHomeDir() );

        if ( pnlsWFHomeDir == NULL || (pnlsWFHomeDir->QueryPch())[0] == TEXT('\0')
             || (err = pnlsWFHomeDir->QueryError()) != NERR_Success )
        {
    	    if (pnlsWFHomeDir)
	           delete pnlsWFHomeDir;
            return err;
        }
    }

    if (   (err == NERR_Success)
        && (NULL != pnlsWFHomeDir) // JonN 01/28/00: PREFIX bug 444943
        && (pnlsWFHomeDir->QueryTextLength() > 0 ) ) 
    {
        ISTR istr( *pnlsWFHomeDir );

        if ( err == NERR_Success
             && pUserConfig->QueryWFHomeDirDirty()
             && !( iObject > 0
                   && ::stricmpf( pnlsWFHomeDir->QueryPch(), QueryUserConfigPtr(0)->QueryWFHomeDir() ) == 0
                   && _fCommonWFHomeDirCreated )

           )
    /* !hydra
             && ( QueryTargetServerType() == UM_WINDOWSNT
                  || (pnlsHomeDir->QueryChar(++istr) == TCH('\\')
                      && pnlsHomeDir->QueryChar(istr) == TCH('\\')) ) )
    */
        {
            
            istr.Reset();
            // If focused on a Windows NT machine and the home dir is
            // not a UNC path, we must make it into a UNC path
            APIERR warn = NERR_Success;            
            BOOL   fIsUNC = (pnlsWFHomeDir->QueryChar(istr) == TCH('\\')) ;
            if ( QueryLocation().QueryServer() != NULL
                 && QueryTargetServerType() == UM_WINDOWSNT
                 && pnlsWFHomeDir->QueryChar(istr) != TCH('\\') )
            {
                NLS_STR nlsTemp = QueryLocation().QueryServer();
                // CODEWORK char constants
                nlsTemp.AppendChar( TCH('\\') );
                nlsTemp.AppendChar( pnlsWFHomeDir->QueryChar(istr) );
                nlsTemp.AppendChar( TCH('$') );
                istr += 2;
                NLS_STR *pnlsTemp2 = pnlsWFHomeDir->QuerySubStr( istr );
                warn = (pnlsTemp2 == NULL ? ERROR_NOT_ENOUGH_MEMORY :
                        pnlsTemp2->QueryError());
                if ( warn == NERR_Success )
                {
                    nlsTemp += *pnlsTemp2;
                    warn = nlsTemp.QueryError();
                }
                if ( warn == NERR_Success )
                {
                    warn = pnlsWFHomeDir->CopyFrom( nlsTemp );
                }
                delete pnlsTemp2 ;
            }
            /* If the home directory is a root directory e.g. "C:\",
             * we map error ERROR_ACCESS_DENIED to ERROR_ALREADY_EXISTS.
             */
            BOOL fRootDir = FALSE;

            while ( warn == NERR_Success ) // Error breakout loop
            {
                /* Don't bother trying to create a root directory e.g. "C:\"
                 */
                if (pnlsWFHomeDir->QueryTextLength() == 3)
                {
                    ISTR istrTemp( *pnlsWFHomeDir );
                    if (   (pnlsWFHomeDir->QueryChar( ++istrTemp ) == TCH(':'))
                           && (pnlsWFHomeDir->QueryChar( ++istrTemp ) == TCH('\\'))
                       )
                    {
                        TRACEEOL( "USERPROP_DLG::I_PerformOne_Write: homedir is root directory" );
                        fRootDir = TRUE;
                    }
                }

                /* If the target is a WinNT machine and the homedir is remote
                 * or the target is downlevel
                 *     then don't put security on it.
                 */
                if ( (QueryTargetServerType() == UM_WINDOWSNT && fIsUNC) ||
                     QueryTargetServerType() == UM_DOWNLEVEL )
                {
                    if ( !::CreateDirectory( (TCHAR *)pnlsWFHomeDir->QueryPch(),
                                             NULL ) )
                    {
                        warn = ::GetLastError();

                    } else
                    {

                        NLS_STR nlsDir( (TCHAR *)pnlsWFHomeDir->QueryPch() );
                        NLS_STR nlsTemp( TEXT("\\windows") );
                        if ( ((warn = nlsDir.QueryError()) != NERR_Success) ||
                             ((warn = nlsTemp.QueryError()) != NERR_Success) ||
                             ((warn = nlsDir.Append(nlsTemp)) != NERR_Success) )
                            goto WFbreakout1; // error breakout

                        if ( !::CreateDirectory( (TCHAR *)nlsDir.QueryPch(),
                                                 NULL ) )
                        {
                            warn = ::GetLastError();
                            goto WFbreakout1; // error breakout
                        }

                        nlsTemp = TEXT("\\system");
                        if ( ((warn = nlsTemp.QueryError()) != NERR_Success) ||
                             ((warn = nlsDir.Append(nlsTemp)) != NERR_Success) )
                            goto WFbreakout1;  // error breakout

                        if ( !::CreateDirectory( (TCHAR *)nlsDir.QueryPch(), NULL ) )
                        {
                            warn = ::GetLastError();
                        }
                    }
WFbreakout1:
/* !hydra
                }
*/
                break ; // Get out of this error breakout loop
            }

                OS_SECURITY_DESCRIPTOR sdNewDir ;
                OS_SID             ossid ;
                OS_ACL             aclDacl ;
                OS_ACE             osace ;
                if ( (warn = sdNewDir.QueryError()) ||
                     (warn = ossid.QueryError())    ||
                     (warn = aclDacl.QueryError())  ||
                     (warn = osace.QueryError()) )
                {
                    break ;
                }

                /* This sets up an ACE with Generic all access that will be
                 * inheritted by directories and files
                 */
                osace.SetAccessMask( GENERIC_ALL ) ;
                osace.SetInheritFlags( CONTAINER_INHERIT_ACE|OBJECT_INHERIT_ACE) ;
                osace.SetType( ACCESS_ALLOWED_ACE_TYPE ) ;


                /* Set up a special admins ACE with Generic all access but
                 * no inheritance for directories and files.  This is for
                 * the Home directory only.  Directory and file inheritance
                 * will be given for the Windows and System directories before
                 * those directories are created.
                 */
                OS_ACE   osadminace ;
                if ( (warn = osadminace.QueryError()) )
                {
                    break ;
                }
                osadminace.SetAccessMask( GENERIC_ALL ) ;
                osadminace.SetInheritFlags( 0 ) ;
                osadminace.SetType( ACCESS_ALLOWED_ACE_TYPE ) ;


                /* NTFS puts the Administrator's alias as both the primary
                 * group and owner of the root of NTFS drives.
                 * We'll do the same thing for the homedir.
                 */
                SAM_DOMAIN * psamdomAccount =
                QueryAdminAuthority()->QueryAccountDomain();
                OS_SID ossidAdmins(QueryAdminAuthority()->QueryBuiltinDomain()->
                                   QueryPSID(),
                                   (ULONG) DOMAIN_ALIAS_RID_ADMINS ) ;
                if ( (warn = ossidAdmins.QueryError())         ||
                     (warn = sdNewDir.SetGroup( ossidAdmins )) ||
                     (warn = sdNewDir.SetOwner( ossidAdmins ))   )
                {
                    break ;
                }


                // Add SYSTEM Group
                OS_SID ossidSystem;
                OS_ACE osaceSystem;
                
                osaceSystem.SetAccessMask( GENERIC_ALL ) ;
                osaceSystem.SetInheritFlags( CONTAINER_INHERIT_ACE|OBJECT_INHERIT_ACE) ;
                osaceSystem.SetType( ACCESS_ALLOWED_ACE_TYPE ) ;
                
                if(
                   (warn = ossidSystem.QueryError())  ||
                   (warn = osaceSystem.QueryError())  ||
                   (warn = NT_ACCOUNTS_UTILITY::QuerySystemSid(UI_SID_System,&ossidSystem)) ||
                   (warn = ossidSystem.QueryError())  ||
                   (warn = osaceSystem.SetSID(ossidSystem)) ||
                   (warn = aclDacl.AddACE(0,osaceSystem))
                  ) {
                  break;
                }
                

                /* If multi-select and all of the homedirs are the same
                 *    then put World (Full Access)
                 * else
                 *    Put the selected user w/Full Access
                 */
                if ( QueryObjectCount() > 1
                     && !_fGeneralizedHomeDir )
                {
                    /* Add World (Full Access)
                     */
                    OS_SID ossidWorld ;
                    if ( (warn = ossidWorld.QueryError()) ||
                         (warn = NT_ACCOUNTS_UTILITY::QuerySystemSid(
                                                                    UI_SID_World,
                                                                    &ossidWorld )) ||
                         (warn = osace.SetSID( ossidWorld )) ||
                         (warn = aclDacl.AddACE( 0, osace )) ||
                         (warn = sdNewDir.SetDACL( TRUE, &aclDacl )) )
                    {
                        break ;
                    }
                } else
                {
                    /* Add <User> (Full Access)
                     */
                    const TCHAR * pszUser = QueryUser2Ptr(iObject)->QueryName() ;
                    SAM_RID_MEM SAMRidMem ;
                    SAM_SID_NAME_USE_MEM SAMSidNameUseMem ;

                    if ( (warn = SAMRidMem.QueryError()) ||
                         (warn = SAMSidNameUseMem.QueryError()) ||
                         (warn = psamdomAccount->TranslateNamesToRids(
                                                                     &pszUser,
                                                                     1,
                                                                     &SAMRidMem,
                                                                     &SAMSidNameUseMem )))
                    {
                        DBGEOL("USERPROP_DLG::I_PerformOne_Write - TranslateNamesToRids "
                               << "failed with error " << warn ) ;
                        break ;
                    }

                    OS_SID ossidUser( psamdomAccount->QueryPSID(),
                                      SAMRidMem.QueryRID( 0 )) ;

                    if ( (warn = ossidUser.QueryError()) ||
                         (warn = osace.SetSID( ossidUser )) ||
                         (warn = aclDacl.AddACE( 0, osace )) ||

                         /* Add <admins> (Full Access; no inherit)
                          */
                         (warn = osadminace.SetSID( ossidAdmins )) ||
                         (warn = aclDacl.AddACE( 1, osadminace )) ||

                         (warn = sdNewDir.SetDACL( TRUE, &aclDacl )) )
                    {
                        break ;
                    }
                }

#if defined(DEBUG) && defined(TRACE)
                TRACEEOL("USERPROP_DLG::I_PerformOne_Write - Creating homedir "
                         << "with the following security descriptor:") ;
                sdNewDir.DbgPrint() ;
#endif

                SECURITY_ATTRIBUTES saNewHomeDir ;
                saNewHomeDir.nLength = sizeof( SECURITY_ATTRIBUTES ) ;
                saNewHomeDir.bInheritHandle = TRUE ;  // probably ignored
                saNewHomeDir.lpSecurityDescriptor = sdNewDir.QueryDescriptor() ;

                if ( !::CreateDirectory( (TCHAR *)pnlsWFHomeDir->QueryPch(),
                                         &saNewHomeDir ) )
                {
                    warn = ::GetLastError();

                } else
                {

                    NLS_STR nlsDir( (TCHAR *)pnlsWFHomeDir->QueryPch() );
                    NLS_STR nlsTemp( TEXT("\\windows") );
                    if ( ((warn = nlsDir.QueryError()) != NERR_Success) ||
                         ((warn = nlsTemp.QueryError()) != NERR_Success) ||
                         ((warn = nlsDir.Append(nlsTemp)) != NERR_Success) )
                        goto WFbreakout2;     // error breakout

                    /* Remove the admin ACE from the security descriptor
                     * and replace with an ACE that has full inheritance
                     * for creating the Windows and System directories.
                     */
                    if ( (warn = aclDacl.DeleteACE( 1 )) )
                        goto WFbreakout2;     // error breakout

                    osadminace.SetInheritFlags( CONTAINER_INHERIT_ACE|OBJECT_INHERIT_ACE ) ;

                    if ( (warn = aclDacl.AddACE( 1, osadminace )) ||
                         (warn = sdNewDir.SetDACL( TRUE, &aclDacl )) )
                        goto WFbreakout2;     // error breakout

                    saNewHomeDir.lpSecurityDescriptor = sdNewDir.QueryDescriptor() ;

                    if ( !::CreateDirectory( (TCHAR *)nlsDir.QueryPch(),
                                             &saNewHomeDir ) )
                    {
                        warn = ::GetLastError();
                        goto WFbreakout2;     // error breakout
                    }

                    nlsTemp = TEXT("\\system");
                    if ( ((warn = nlsTemp.QueryError()) != NERR_Success) ||
                         ((warn = nlsDir.Append(nlsTemp)) != NERR_Success ) )
                        goto WFbreakout2;     // error breakout

                    if ( !::CreateDirectory( (TCHAR *)nlsDir.QueryPch(),
                                             &saNewHomeDir ) )
                    {
                        warn = ::GetLastError();
                        goto WFbreakout2;     // error breakout
                    }
                }
WFbreakout2:
/* !hydra
            }// endif
*/
                break ; // Get out of this error breakout loop
        } // end if

            // Do this whether or not the create succeeds.  If it fails once,
            // then chances are it will fail everytime, so don't waste time.
            _fCommonWFHomeDirCreated = TRUE;

            TRACEEOL("USERPROP_DLG::I_PerformOne_Write - homedir creation warning " << warn );

            switch (warn)
            {
                case NERR_Success:
                case ERROR_ALREADY_EXISTS:
                    break;

                case ERROR_ACCESS_DENIED:
                    if (fRootDir)
                    {
                        TRACEEOL("USERPROP_DLG::I_PerformOne_Write - ignore rootdir exists warning" );
                        break;
                    }
                    // else fall through

                default:
                    // CODEWORK - should display the username and specific error
                    ::MsgPopup( (pwndPopupParent == NULL) ? this : pwndPopupParent,
                                IDS_PR_CannotCreateHomeDir,
                                MPSEV_WARNING, MP_OK, pnlsWFHomeDir->QueryPch(),
                                QueryUser2Ptr(iObject)->QueryName() );
                    break;
            }
        }
    }

//End WFHomeDir Stuff

// hydra end

    delete puser2New;
    delete pusermembNew;
    delete pnlsHomeDir;
    // hydra
    delete pnlsWFHomeDir;
 
    return err;
}


/*******************************************************************

    NAME:       USERPROP_DLG::I_SetExtendedMembership

    SYNOPSIS:	Sets the user membership specified, but with the extra
                global group specified in ulRidExtraMember.  This is
                a worker routine for I_PerformOne_Write.

                If fForce, we set membership regardless of whether
                group ulRidExtraMember is already represented in the
                membership object.  Otherwise, we only set membership if
                ulRidExtraMember is not already a member.

    RETURNS:	Standard error code

    HISTORY:
               JonN     17-Jun-1993 Fixed PrimaryGroup for new users

********************************************************************/
APIERR USERPROP_DLG::I_SetExtendedMembership( USER_MEMB * pumembOld,
                                              ULONG ulRidAddGroup,
                                              BOOL fForce )
{
    ASSERT(   pumembOld != NULL
           && pumembOld->QueryError() == NERR_Success
           && ulRidAddGroup != 0L );

    APIERR err = NERR_Success;

    OS_SID ossidPrimaryGroupNew(
        QueryAdminAuthority()->QueryAccountDomain()->QueryPSID(),
        ulRidAddGroup );

    LSA_TRANSLATED_NAME_MEM lsatnm;
    LSA_REF_DOMAIN_MEM lsardm;

    if (   (err = ossidPrimaryGroupNew.QueryError()) != NERR_Success
        || (err = lsatnm.QueryError()) != NERR_Success
        || (err = lsardm.QueryError()) != NERR_Success )
    {
        DBGEOL( "USERPROP_DLG::I_SetExtendedMembership: ossid failure " << err );
        return err;
    }

    PSID psidPrimaryGroupNew = ossidPrimaryGroupNew.QueryPSID();
    LSA_POLICY * plsapol = QueryAdminAuthority()->QueryLSAPolicy();
    if ( (err = plsapol->TranslateSidsToNames(
    		&psidPrimaryGroupNew,
    		1,
    		&lsatnm,
    		&lsardm )) != NERR_Success )
    {
        DBGEOL( "USERPROP_DLG::I_SetExtendedMembership: xlate failure " << err );
        return err;
    }

    NLS_STR nlsTemp;
    if (   (err = nlsTemp.QueryError()) != NERR_Success
        || (err = lsatnm.QueryName( 0, &nlsTemp )) != NERR_Success
       )
    {
        DBGEOL( "USERPROP_DLG::I_SetExtendedMembership: nls failure " << err );
        return err;
    }

    UINT uDummy;
    // if not already in the new primary group
    BOOL fAlreadyThere = pumembOld->FindAssocName( nlsTemp.QueryPch(), &uDummy );
    if ( fForce || (!fAlreadyThere) )
    {
        USER_MEMB umembTemp( QueryLocation(), pumembOld->QueryName() );
        if (   (err = umembTemp.QueryError()) != NERR_Success
            || (err = umembTemp.CloneFrom( *pumembOld )) != NERR_Success
            || (   (!fAlreadyThere)
                && ((err = umembTemp.AddAssocName( nlsTemp )) != NERR_Success)
               )
            || (err = umembTemp.Write()) != NERR_Success
           )
        {
            DBGEOL( "USERPROP_DLG::I_SetExtendedMembership: write failure " << err );
    	    return err;
        }
    }

    return err;
}


/*******************************************************************

    NAME:       USERPROP_DLG::I_GetAliasMemberships

    SYNOPSIS:	Reads the alias memberships for this user.  Used by
                both the Group Membership subdialog and the New User
                dialog (clone variant).

    INTERFACE:  ridUser -- rid of user whose alias memberships
                           should be loaded
                ppsamrmAccounts -- if successful, points to a new
                           SAM_RID_MEM containing the user's alias
                           memberships in the Accounts domain.
                ppsamrmBuiltin -- if successful, points to a new
                           SAM_RID_MEM containing the user's alias
                           memberships in the built-in domain.

    RETURNS:	Error to be displayed to user

    HISTORY:
	       JonN  19-May-1992    Adapted from umembdlg.cxx

********************************************************************/

APIERR USERPROP_DLG::I_GetAliasMemberships( ULONG ridUser,
                                            SAM_RID_MEM ** ppsamrmAccounts,
                                            SAM_RID_MEM ** ppsamrmBuiltin )
{
    ASSERT( ppsamrmAccounts != NULL && ppsamrmBuiltin != NULL );

    APIERR err = NERR_Success;

    *ppsamrmAccounts = NULL;
    *ppsamrmBuiltin = NULL;

    // Create the SAM_RID_ENUMs for the user.
    SAM_DOMAIN * psamdomAccount =
		QueryAdminAuthority()->QueryAccountDomain();
    SAM_DOMAIN * psamdomBuiltin =
		QueryAdminAuthority()->QueryBuiltinDomain();

    ASSERT( psamdomAccount != NULL && psamdomBuiltin != NULL );

    OS_SID ossidUser( psamdomAccount->QueryPSID(), ridUser );

    *ppsamrmAccounts = new SAM_RID_MEM();
    *ppsamrmBuiltin = new SAM_RID_MEM();

    err = ERROR_NOT_ENOUGH_MEMORY;

    if (   (*ppsamrmAccounts == NULL)
        || (*ppsamrmBuiltin  == NULL)
        || (err = (*ppsamrmAccounts)->QueryError()) != NERR_Success
        || (err = (*ppsamrmBuiltin )->QueryError()) != NERR_Success
        || (err = ossidUser.QueryError()) != NERR_Success
        || (err = psamdomAccount->EnumerateAliasesForUser(
		            ossidUser.QuerySid(),
		            *ppsamrmAccounts )) != NERR_Success
        || (err = psamdomBuiltin->EnumerateAliasesForUser(
		            ossidUser.QuerySid(),
		            *ppsamrmBuiltin )) != NERR_Success
       )
    {
        delete *ppsamrmAccounts;
        *ppsamrmAccounts = NULL;
        delete *ppsamrmBuiltin;
        *ppsamrmBuiltin = NULL;
    }


    return err;
}


/*******************************************************************

    NAME:       USERPROP_DLG::W_MapPerformOneError

    SYNOPSIS:	Checks whether the error maps to a specific control
		and/or a more specific message.  Each level checks for
		errors specific to edit fields it maintains.  There
		are no errors associated with an invalid comment, so
		this level does nothing.

    ENTRY:      Error returned from PerformOne()

    RETURNS:	Error to be displayed to user

    HISTORY:
	       JonN  03-Sep-1991    Added validation

********************************************************************/

MSGID USERPROP_DLG::W_MapPerformOneError(
	APIERR err
	)
{
    return err;
}


/*******************************************************************

    NAME:	USERPROP_DLG::QueryUser2Ptr

    SYNOPSIS:   Accessor to the NEW_LM_OBJ arrays, for use by subdialogs

    HISTORY:
    JonN        11-Sep-1991     De-inlined

********************************************************************/

USER_2 * USERPROP_DLG::QueryUser2Ptr( UINT iObject )
{
    ASSERT( _apuser2 != NULL );
    ASSERT( iObject < _cItems );
    return _apuser2[ iObject ];
}

/*******************************************************************

    NAME:	USERPROP_DLG::QueryUser3Ptr

    SYNOPSIS:   Accessor to the NEW_LM_OBJ arrays, for use by subdialogs.
                Should only be used when focus is on an NT server.

    HISTORY:
    JonN        11-Sep-1991     De-inlined

********************************************************************/

USER_3 * USERPROP_DLG::QueryUser3Ptr( UINT iObject )
{
    ASSERT( !IsDownlevelVariant() );
    return (USER_3 *) QueryUser2Ptr( iObject );
}

/*******************************************************************

    NAME:	USERPROP_DLG::QueryUserNWPtr

    SYNOPSIS:   Accessor to the NEW_LM_OBJ arrays, for use by subdialogs.
                Should only be used when focus is on an NT server.

    HISTORY:
    CongpaY        18-Oct-1993     Added.

********************************************************************/

USER_NW * USERPROP_DLG::QueryUserNWPtr( UINT iObject )
{
    ASSERT( !IsDownlevelVariant() );
    return (USER_NW *) QueryUser3Ptr( iObject );
}

/*******************************************************************

    NAME:	USERPROP_DLG::SetUser2Ptr

    SYNOPSIS:   Accessor to the NEW_LM_OBJ arrays, for use by subdialogs

    HISTORY:
    JonN        11-Sep-1991     De-inlined

********************************************************************/

VOID USERPROP_DLG::SetUser2Ptr( UINT iObject, USER_2 * puser2New )
{
    ASSERT( _apuser2 != NULL );
    ASSERT( iObject < _cItems );
    ASSERT( (puser2New == NULL) || (puser2New != _apuser2[iObject]) );
    delete _apuser2[ iObject ];
    _apuser2[ iObject ] = puser2New;
}

/*******************************************************************

    NAME:	USERPROP_DLG::QueryUserMembPtr

    SYNOPSIS:   Accessor to the NEW_LM_OBJ arrays, for use by subdialogs

    HISTORY:
    JonN        11-Sep-1991     De-inlined

********************************************************************/

USER_MEMB * USERPROP_DLG::QueryUserMembPtr( UINT iObject )
{
    ASSERT( _apusermemb != NULL );
    ASSERT( iObject < _cItems );
    return _apusermemb[ iObject ];
}


/*******************************************************************

    NAME:	USERPROP_DLG::QueryAccountsSamRidMemPtr

    SYNOPSIS:   Accessor to the SAM_RID_MEM array, for use by subdialogs

    HISTORY:
    Thomaspa        28-Apr-1992     created

********************************************************************/

SAM_RID_MEM * USERPROP_DLG::QueryAccountsSamRidMemPtr( UINT iObject )
{
    ASSERT( _apsamrmAccounts != NULL );
    ASSERT( iObject < _cItems );
    return _apsamrmAccounts[ iObject ];
}


/*******************************************************************

    NAME:	USERPROP_DLG::QueryBuiltinSamRidMemPtr

    SYNOPSIS:   Accessor to the SAM_RID_MEM array, for use by subdialogs

    HISTORY:
    Thomaspa        28-Apr-1992     created

********************************************************************/

SAM_RID_MEM * USERPROP_DLG::QueryBuiltinSamRidMemPtr( UINT iObject )
{
    ASSERT( _apsamrmBuiltin != NULL );
    ASSERT( iObject < _cItems );
    return _apsamrmBuiltin[ iObject ];
}

// hydra
/*******************************************************************

    NAME:	USERPROP_DLG::QueryUserConfigPtr

    SYNOPSIS:   Accessor to the USER_CONFIG array, for use by subdialogs

********************************************************************/

USER_CONFIG * USERPROP_DLG::QueryUserConfigPtr( UINT iObject )
{
    ASSERT( _apUserConfig != NULL );
    ASSERT( iObject < _cItems );
    return _apUserConfig[ iObject ];
}

/*******************************************************************

    NAME:	USERPROP_DLG::Querypulb

    SYNOPSIS:   Accessor to the pulb, for use by subdialogs

********************************************************************/

const LAZY_USER_LISTBOX * USERPROP_DLG::Querypulb( )
{
    return _pulb;
}
// hydra end

/*******************************************************************

    NAME:	USERPROP_DLG::SetUserMembPtr

    SYNOPSIS:   Accessor to the NEW_LM_OBJ arrays, for use by subdialogs

    HISTORY:
    JonN        11-Sep-1991     De-inlined

********************************************************************/

VOID USERPROP_DLG::SetUserMembPtr( UINT iObject, USER_MEMB * pusermembNew )
{
    ASSERT( _apusermemb != NULL );
    ASSERT( iObject < _cItems );
    ASSERT( (pusermembNew == NULL) || (pusermembNew != _apusermemb[iObject]));
    delete _apusermemb[ iObject ];
    _apusermemb[ iObject ] = pusermembNew;
}


/*******************************************************************

    NAME:	USERPROP_DLG::SetAccountsSamRidMemPtr

    SYNOPSIS:   Accessor to the SAM_RID_MEM array, for use by subdialogs

    HISTORY:
    thomaspa        28-Apr-1992     created

********************************************************************/

VOID USERPROP_DLG::SetAccountsSamRidMemPtr( UINT iObject,
					    SAM_RID_MEM * psamrmNew )
{
    ASSERT( _apsamrmAccounts != NULL );
    ASSERT( iObject < _cItems );
    ASSERT( (psamrmNew == NULL) || (psamrmNew != _apsamrmAccounts[iObject]));
    delete _apsamrmAccounts[ iObject ];
    _apsamrmAccounts[ iObject ] = psamrmNew;
}


/*******************************************************************

    NAME:	USERPROP_DLG::SetBuiltinSamRidMemPtr

    SYNOPSIS:   Accessor to the SAM_RID_MEM array, for use by subdialogs

    HISTORY:
    thomaspa        28-Apr-1992     created

********************************************************************/

VOID USERPROP_DLG::SetBuiltinSamRidMemPtr( UINT iObject,
					   SAM_RID_MEM * psamrmNew )
{
    ASSERT( _apsamrmBuiltin != NULL );
    ASSERT( iObject < _cItems );
    ASSERT( (psamrmNew == NULL) || (psamrmNew != _apsamrmBuiltin[iObject]));
    delete _apsamrmBuiltin[ iObject ];
    _apsamrmBuiltin[ iObject ] = psamrmNew;
}


// hydra
/*******************************************************************

    NAME:	USERPROP_DLG::SetUserConfigPtr

    SYNOPSIS:   Accessor to the USER_CONFIG array, for use by subdialogs

********************************************************************/

VOID USERPROP_DLG::SetUserConfigPtr( UINT iObject,
				     USER_CONFIG * puserconfigNew )
{
    ASSERT( _apUserConfig != NULL );
    ASSERT( iObject < _cItems );
    ASSERT( (puserconfigNew == NULL) ||
            (puserconfigNew != _apUserConfig[iObject]) );
    delete _apUserConfig[ iObject ];
    _apUserConfig[ iObject ] = puserconfigNew;
}

// hydra end


/*******************************************************************

    NAME:   USERPROP_DLG::QueryHelpOffset

    SYNOPSIS:   Returns the offset to be added to the base help context
		for User Properties dialogs and sub-property dialogs

    ENTRY:	none

    HISTORY:
    thomaspa    31-Aug-1992     Created

    NOTES:  Help contexts are assumed to be organized as follows

     * Single select variants
    #define	HC_UM_DLG_LANNT	( HC_UM_BASE + 36 )
    #define	HC_UM_DLG_WINNT	( HC_UM_DLG_LANNT + UM_OFF_WINNT )
    #define	HC_UM_DLG_DOWN	( HC_UM_DLG_LANNT + UM_OFF_DOWN )
    #define	HC_UM_DLG_MINI	( HC_UM_DLG_LANNT + UM_OFF_MINI )

     * Multiselect variants
    #define	HC_UM_MDLG_LANNT ( HC_UM_BASE + 40 )
    #define	HC_UM_MDLG_WINNT ( HC_UM_MDLG_LANNT + UM_OFF_WINNT )
    #define	HC_UM_MDLG_DOWN	 ( HC_UM_MDLG_LANNT + UM_OFF_DOWN )
    #define	HC_UM_MDLG_MINI	 ( HC_UM_MDLG_LANNT + UM_OFF_MINI )

********************************************************************/
ULONG USERPROP_DLG::QueryHelpOffset( void ) const
{
    return ( _pumadminapp->QueryHelpOffset()
	+ ((QueryObjectCount()) > 1 ? UM_NUM_HELPTYPES : 0 ));
}


/*******************************************************************

    NAME:       USERPROP_DLG::GeneralizeString

    SYNOPSIS:   This function checks the last path element to see if it
                is equal (case-insensitive) to username+extension,
                and replaces the last path element with %USERNAME%+
                extension if it is.

    RETURNS:    APIERR

    HISTORY:
	JonN	10-Mar-1992    Created (%USERNAME% logic)
        JonN    22-Apr-1992    Reformed %USERNAME% (NTISSUE #974)
        JonN    01-Sep-1992    Moved from USERPROF_DLG

********************************************************************/

APIERR USERPROP_DLG::GeneralizeString (
                           NLS_STR * pnlsGeneralizeString,
                           const TCHAR * pchGeneralizeFromUsername,
                           STRLIST& strlstExtensions )
{
    // first try no extension
    APIERR err = GeneralizeString( pnlsGeneralizeString,
                                   pchGeneralizeFromUsername );
    if (err != NERR_Success)
        return err;

    // now try the extensions
    ITER_STRLIST itersl(strlstExtensions);
    NLS_STR* pnlsExtension = NULL;
    while ( (pnlsExtension = itersl.Next()) != NULL && err == NERR_Success )
    {
        err = GeneralizeString( pnlsGeneralizeString,
                                pchGeneralizeFromUsername,
                                pnlsExtension );
    }
    return err;

} // USERPROP_DLG::GeneralizeString

APIERR USERPROP_DLG::GeneralizeString (
                           NLS_STR * pnlsGeneralizeString,
                           const TCHAR * pchGeneralizeFromUsername,
                           const NLS_STR * pnlsExtension )
{

#ifndef DISABLE_GENERALIZE

    ASSERT(   (pnlsGeneralizeString != NULL)
           && (pnlsGeneralizeString->QueryError() == NERR_Success)
           && (   (pnlsExtension == NULL)
               || (pnlsExtension->QueryError() == NERR_Success) )
          );

    ASSERT(   pchGeneralizeFromUsername != NULL
           && *pchGeneralizeFromUsername != TCH('\0') );

    TRACEEOL(   SZ("User Manager::GeneralizeString( \"")
             << *pnlsGeneralizeString
             << SZ("\", \"")
             << pchGeneralizeFromUsername
             << SZ("\", \"")
             << ( (pnlsExtension==NULL) ? (SZ("NULL")) : (pnlsExtension->QueryPch()) )
             << SZ("\" )")
            );

    ISTR istrStart( *pnlsGeneralizeString );
    if (!(pnlsGeneralizeString->strrchr(
                       &istrStart, TCH('\\') ))) // CODEWORK const
    {
        istrStart.Reset();
    }
    else
    {
        ++istrStart; // advance past '\\'
    }

    NLS_STR nlsUsername( pchGeneralizeFromUsername );
    if (pnlsExtension != NULL)
    {
        nlsUsername += *pnlsExtension;
    }
    APIERR err = nlsUsername.QueryError();
    if ( err != NERR_Success )
    {
        return err;
    }

    TRACEEOL(   SZ("User Manager::GeneralizeString: stricmp( \"")
             << pnlsGeneralizeString->QueryPch(istrStart)
             << SZ("\", \"")
             << nlsUsername
             << SZ("\" )")
            );

    if ( pnlsGeneralizeString->_stricmp( nlsUsername, istrStart ) != 0 )
    {
        return NERR_Success;
    }

    NLS_STR nlsReplaceWith( _resstrUsernameReplace );
    if (pnlsExtension != NULL)
    {
        nlsReplaceWith += *pnlsExtension;
    }
    if ( (err = nlsReplaceWith.QueryError()) != NERR_Success )
    {
        return err;
    }

    pnlsGeneralizeString->DelSubStr( istrStart );
    *pnlsGeneralizeString += nlsReplaceWith;

    TRACEEOL(   SZ("User Manager::GeneralizeString(): generalized to \"")
             << *pnlsGeneralizeString
             << SZ("\"")
            );

#endif // DISABLE_GENERALIZE

    return pnlsGeneralizeString->QueryError();

} // USERPROP_DLG::GeneralizeString


/*******************************************************************

    NAME:       USERPROP_DLG::DegeneralizeString

    SYNOPSIS:   This function replaces all instances of %USERNAME%
                in the passed string with the username.

    RETURNS:    APIERR

    HISTORY:
	JonN	10-Mar-1992    Created (%USERNAME% logic)
        JonN    22-Apr-1992    Reformed %USERNAME% (NTISSUE #974)
        JonN    01-Sep-1992    Moved from USERPROF_DLG

********************************************************************/

APIERR USERPROP_DLG::DegeneralizeString(
                           NLS_STR * pnlsDegeneralizeString,
                           const TCHAR * pchDegeneralizeToUsername,
                           STRLIST& strlstExtensions,
                           BOOL * pfDidDegeneralize )
{

    BOOL fTemp;
    if ( pfDidDegeneralize == NULL )
        pfDidDegeneralize = &fTemp;

    *pfDidDegeneralize = FALSE;

    // first try no extension
    APIERR err = DegeneralizeString( pnlsDegeneralizeString,
                                     pchDegeneralizeToUsername,
                                     NULL,
                                     pfDidDegeneralize );
    if ( *pfDidDegeneralize || (err != NERR_Success) )
    {
        return err;
    }

    // now try the extensions
    ITER_STRLIST itersl(strlstExtensions);
    NLS_STR* pnlsExtension = NULL;
    while (   (pnlsExtension = itersl.Next()) != NULL
           && (!(*pfDidDegeneralize))
           && err == NERR_Success )
    {
        err = DegeneralizeString( pnlsDegeneralizeString,
                                  pchDegeneralizeToUsername,
                                  pnlsExtension,
                                  pfDidDegeneralize );
    }
    return err;

} // USERPROP_DLG::DegeneralizeString

APIERR USERPROP_DLG::DegeneralizeString(
                           NLS_STR * pnlsDegeneralizeString,
                           const TCHAR * pchDegeneralizeToUsername,
                           const NLS_STR * pnlsExtension,
                           BOOL * pfDidDegeneralize )
{

    if ( pfDidDegeneralize != NULL )
        *pfDidDegeneralize = FALSE;

#ifndef DISABLE_GENERALIZE

    ASSERT(   (pnlsDegeneralizeString != NULL)
           && (pnlsDegeneralizeString->QueryError() == NERR_Success)
           && (   (pnlsExtension == NULL)
               || (pnlsExtension->QueryError() == NERR_Success) )
          );

    ASSERT(   pchDegeneralizeToUsername != NULL
           && *pchDegeneralizeToUsername != TCH('\0') );

    TRACEEOL(   SZ("User Manager::DegeneralizeString( \"")
             << *pnlsDegeneralizeString
             << SZ("\", \"")
             << pchDegeneralizeToUsername
             << SZ("\", \"")
             << ( (pnlsExtension==NULL) ? (SZ("NULL")) : (pnlsExtension->QueryPch()) )
             << SZ("\" )")
            );

    ISTR istrStart( *pnlsDegeneralizeString );
    if (!(pnlsDegeneralizeString->strrchr(
                       &istrStart, TCH('\\') ))) // CODEWORK const
    {
        istrStart.Reset();
    }
    else
    {
        ++istrStart; // advance past '\\'
    }

    NLS_STR nlsReplace( _resstrUsernameReplace );
    if (pnlsExtension != NULL)
    {
        nlsReplace += *pnlsExtension;
    }
    APIERR err = nlsReplace.QueryError();
    if ( err != NERR_Success )
    {
        return err;
    }

    TRACEEOL(   SZ("User Manager::DegeneralizeString: stricmp( \"")
             << pnlsDegeneralizeString->QueryPch(istrStart)
             << SZ("\", \"")
             << nlsReplace
             << SZ("\" )")
            );

    if ( pnlsDegeneralizeString->_stricmp( nlsReplace, istrStart ) != 0 )
    {
        return NERR_Success;
    }

    NLS_STR nlsUsername( pchDegeneralizeToUsername );
    if (pnlsExtension != NULL)
    {
        nlsUsername += *pnlsExtension;
    }
    if ( (err = nlsUsername.QueryError()) != NERR_Success )
    {
        return err;
    }

    pnlsDegeneralizeString->DelSubStr( istrStart );
    *pnlsDegeneralizeString += nlsUsername;

    if ( pfDidDegeneralize != NULL )
        *pfDidDegeneralize = TRUE;

    TRACEEOL(   SZ("User Manager::DegeneralizeString(): degeneralized to \"")
             << *pnlsDegeneralizeString
             << SZ("\"")
            );

#endif // DISABLE_GENERALIZE

    return pnlsDegeneralizeString->QueryError();

} // USERPROP_DLG::DegeneralizeString


/*******************************************************************

    NAME:       USERPROP_DLG::QueryEnableUserProfile

    SYNOPSIS:   Tells whether User Profile field should be enabled
                for this target

    RETURNS:    BOOL

    CODEWORK:   Could be inlined, left here for now to make it easier to change

    HISTORY:
        jonn    28-Jul-1995     created

********************************************************************/

BOOL USERPROP_DLG::QueryEnableUserProfile()
{
    // MUM: we enable the sleProfile control  (JonN 7/28/95)
    // FUM->Downlevel: there is no sleProfile control
    // FUM->WinNt: we enable the sleProfile control
    // FUM->LanManNt: we enable the sleProfile control
    return ( QueryTargetServerType() != UM_DOWNLEVEL );
}


/*******************************************************************

    NAME:   SINGLE_USERPROP_DLG::SINGLE_USERPROP_DLG

    SYNOPSIS:   Base Constructor for User Properties main dialog, single
		user variants

    ENTRY:	see USERPROP_DLG

    HISTORY:
    JonN        17-Jul-1991     Created
    JonN	20-Aug-1991	Multiselection redesign

********************************************************************/

SINGLE_USERPROP_DLG::SINGLE_USERPROP_DLG(
	const TCHAR * pszResourceName,
	const UM_ADMIN_APP * pumadminapp,
	const LOCATION & loc,
	const LAZY_USER_SELECTION * psel
	) : USERPROP_DLG(
		pszResourceName,
		pumadminapp,
		loc,
		psel
		),
	    _nlsFullName(),
	    _nlsPassword(),
	    _sleFullName( this, IDUP_ET_FULL_NAME, (IsDownlevelVariant())
                                                        ? LM20_MAXCOMMENTSZ
                                                        : MAXCOMMENTSZ ),
	    _passwordNew( this, IDUP_ET_PASSWORD, LM20_PWLEN ),
	    _passwordConfirm( this, IDUP_ET_PASSWORD_CONFIRM, LM20_PWLEN )
{
    ASSERT( QueryObjectCount() == 1 );

    if ( QueryError() != NERR_Success )
	return;

    APIERR err;
    if (   ((err = _nlsFullName.QueryError()) != NERR_Success)
	|| ((err = _nlsPassword.QueryError()) != NERR_Success) )
    {
	ReportError( err );
	return;
    }


} // SINGLE_USERPROP_DLG::SINGLE_USERPROP_DLG



/*******************************************************************

    NAME:       SINGLE_USERPROP_DLG::~SINGLE_USERPROP_DLG

    SYNOPSIS:   Destructor for User Properties main dialog, single
		user variant

    HISTORY:
    JonN        17-Jul-1991     Created
    JonN        13-Jun-1993     Clear password from pagefile

********************************************************************/

SINGLE_USERPROP_DLG::~SINGLE_USERPROP_DLG( void )
{
    // clear password from pagefile
    ::memsetf( (void *)(_nlsPassword.QueryPch()),
               0x20,
               _nlsPassword.strlen() );

    _passwordNew.SetText( UI_NULL_USERSETINFO_PASSWD );
    _passwordConfirm.SetText( UI_NULL_USERSETINFO_PASSWD );
}


/*******************************************************************

    NAME:       SINGLE_USERPROP_DLG::InitControls

    SYNOPSIS:   See USERPROP_DLG::InitControls().

    RETURNS:	error code

    HISTORY:
               JonN  19-Jul-1991    created

********************************************************************/

APIERR SINGLE_USERPROP_DLG::InitControls()
{
    _sleFullName.SetText( _nlsFullName );

    // Since we monitor the Password SLE for changes and set the
    // Force Password Change checkbox if it does change, we need
    // to save and restore the state when we are initializing the
    // dialog.
    enum AI_TRI_STATE triForcePWChangeSave = _triForcePWChange;
    _passwordNew.SetText( _nlsPassword );
    _passwordConfirm.SetText( _nlsPassword );
    _triForcePWChange = triForcePWChangeSave;

    return USERPROP_DLG::InitControls();
}


/*******************************************************************

    NAME:       SINGLE_USERPROP_DLG::W_LMOBJtoMembers

    SYNOPSIS:	Loads class data members from initial data

    ENTRY:	see USERPROP_DLG::W_LMOBJtoMembers

    NOTES:	See the class interface header for information on the
		password field.

    HISTORY:
               JonN  20-Aug-1991    created

********************************************************************/

APIERR SINGLE_USERPROP_DLG::W_LMOBJtoMembers(
	UINT		iObject
	)
{
    ASSERT( iObject == 0 );

    APIERR err = _nlsFullName.CopyFrom( QueryUser2Ptr(iObject)->QueryFullName() );
    if ( err != NERR_Success )
        return err;

    // clear password from pagefile
    ::memsetf( (void *)(_nlsPassword.QueryPch()),
               0x20,
               _nlsPassword.strlen() );

    // initial password will be NULL_USERSETINFO_PASSWD for existing users
    // initial password will be NULL for new users
    err = _nlsPassword.CopyFrom( QueryUser2Ptr(iObject)->QueryPassword());
    if ( err != NERR_Success )
        return err;

    return USERPROP_DLG::W_LMOBJtoMembers( iObject );
}


/*******************************************************************

    NAME:       SINGLE_USERPROP_DLG::W_MembersToLMOBJ

    SYNOPSIS:	Loads class data members into the USER_2 object

    RETURNS:	error code

    NOTES:	See W_LMOBJtoMembers for notes on the password field

    HISTORY:
	       JonN  20-Aug-1991    Multiselection redesign

********************************************************************/

APIERR SINGLE_USERPROP_DLG::W_MembersToLMOBJ(
	USER_2 *	puser2,
	USER_MEMB *	pusermemb
	)
{
    UNREFERENCED( pusermemb );
    APIERR err = puser2->SetFullName( _nlsFullName );
    if ( err != NERR_Success )
	return err;

    // may be NULL_USERSETINFO_PASSWD
    err = puser2->SetPassword( _nlsPassword );
    if ( err != NERR_Success )
	return err;

    if ( strcmpf (_nlsPassword.QueryPch(), UI_NULL_USERSETINFO_PASSWD) != 0)
    {
        SetPasswordChanged();
    }

    return USERPROP_DLG::W_MembersToLMOBJ( puser2, pusermemb );
}


/*******************************************************************

    NAME:       SINGLE_USERPROP_DLG::GetNWPassword

    SYNOPSIS:	Get NetWare password from the password edit field.

    RETURNS:	

    HISTORY:
	       CongpaY  13-Oct-1993     Created

********************************************************************/
APIERR SINGLE_USERPROP_DLG::GetNWPassword (USER_2 *	puser2,
                                           NLS_STR *    pnlsNWPassword,
                                           BOOL *       pfCancel)
{
    ASSERT( IsNetWareInstalled() );

    if ( strcmpf (_nlsPassword.QueryPch(), UI_NULL_USERSETINFO_PASSWD) != 0)
    {
        (*pfCancel) = FALSE;
        return pnlsNWPassword->CopyFrom (_nlsPassword);
    }

    return USERPROP_DLG::GetNWPassword (puser2,
                                        pnlsNWPassword,
                                        pfCancel);
}

/*******************************************************************

    NAME:       SINGLE_USERPROP_DLG::W_DialogToMembers

    SYNOPSIS:	Loads data from dialog into class data members

    RETURNS:	error message (not necessarily an error code)

    NOTES:	This method takes care of validating the data in the
    		dialog.  This means ensuring that the fullname is not
		null, ensuring that the New and Confirm passwords match,
		and ensuring that the password are valid.  If this
		validation fails, W_DialogToMembers will change focus et
		al. in the dialog, and return the error message to be
		displayed.

    HISTORY:
	       JonN  21-Aug-1991    Multiselection redesign
	       JonN  03-Sep-1991    Added validation
	       JonN  27-Jan-1992    NTISSUES 564: fullname may be empty

********************************************************************/

APIERR SINGLE_USERPROP_DLG::W_DialogToMembers(
	)
{
    // This will clear leading/trailing whitespace
    APIERR err = NERR_Success;
    if (   ((err = _sleFullName.QueryText( &_nlsFullName )) != NERR_Success )
	|| ((err = _nlsFullName.QueryError()) != NERR_Success ) )
    {
	return err;
    }

    // REMOVED 01/27/92; UMISSUES 564
    // CODEWORK should use VALIDATED_DIALOG
    // if ( _nlsFullName.strlen() == 0 )
    // {
    //	_sleFullName.SelectString();
    //	_sleFullName.ClaimFocus();
    //	return IERR_UM_FullNameRequired;
    // }

    // clear password from pagefile
    ::memsetf( (void *)(_nlsPassword.QueryPch()),
               0x20,
               _nlsPassword.strlen() );

    // This will clear leading/trailing whitespace
    if (   ((err = _passwordNew.QueryText( &_nlsPassword )) != NERR_Success )
        || ((err = _nlsPassword.QueryError()) != NERR_Success ) )
    {
	return err;
    }

    NLS_STR nlsPasswordConfirm;
    err = nlsPasswordConfirm.QueryError();
    if ( err != NERR_Success )
	return err;

    // This will clear leading/trailing whitespace
    if (   ((err = _passwordConfirm.QueryText( &nlsPasswordConfirm )) != NERR_Success )
        || ((err = nlsPasswordConfirm.QueryError()) != NERR_Success ) )
    {
	return err;
    }

    if ( NERR_Success != ::I_MNetNameValidate( NULL,
			    		    _nlsPassword,
			    		    NAMETYPE_PASSWORD,
			    		    0L ) )
    {
	err = IERR_UM_PasswordInvalid;
    }
    else if ( _nlsPassword.strcmp( nlsPasswordConfirm ) )
    {
	err = IERR_UM_PasswordMismatch;
    }

    // clear password from pagefile
    ::memsetf( (void *)(nlsPasswordConfirm.QueryPch()),
               0x20,
               nlsPasswordConfirm.strlen() );

    if ( err != NERR_Success )
    {
	// Password in USER_2 object may not still be NULL_USERSETINFO_PASSWD
	// We want to redisplay the password last active for the user
	const TCHAR * pszPassword = QueryUser2Ptr(0)->QueryPassword();
	_passwordNew.SetText( pszPassword );
	_passwordConfirm.SetText( pszPassword );
	_passwordNew.ClaimFocus();
	return err;
    }

    return USERPROP_DLG::W_DialogToMembers();
}


/*******************************************************************

    NAME:       SINGLE_USERPROP_DLG::W_MapPerformOneError

    SYNOPSIS:	See USERPROP_DLG::W_MapPerformOneError.  This level
    		checks for errors associated with the Password and
		FullName edit fields.

    ENTRY:      Error returned from PerformOne()

    RETURNS:	Error to be displayed to user

    HISTORY:
	       JonN  03-Sep-1991    Added validation

********************************************************************/

MSGID SINGLE_USERPROP_DLG::W_MapPerformOneError(
	APIERR err
	)
{
    switch ( err )
    {
    // BUGBUG error text is specced to state the minimum password length
    //    for this domain
    case NERR_PasswordTooShort:
	_passwordNew.ClearText();
	_passwordConfirm.ClearText();
	_passwordNew.ClaimFocus();
	return IERR_UM_PasswordInvalid;
    default: // other error
	break;
    }

    return USERPROP_DLG::W_MapPerformOneError( err );
}





/*******************************************************************

    NAME:   EDITSINGLE_USERPROP_DLG::EDITSINGLE_USERPROP_DLG

    SYNOPSIS:   Constructor for User Properties main dialog, edit
		one user variant

    HISTORY:
    JonN        01-Aug-1991     Created

********************************************************************/

EDITSINGLE_USERPROP_DLG::EDITSINGLE_USERPROP_DLG(
	const UM_ADMIN_APP * pumadminapp,
	const LOCATION & loc,
	const LAZY_USER_SELECTION * psel
	) : SINGLE_USERPROP_DLG(
		MAKEINTRESOURCE(IDD_SINGLEUSER),
		pumadminapp,
		loc,
		psel
		),
	    _sltLogonName( this, IDUP_ST_LOGON_NAME )
{
    ASSERT( psel != NULL );
    UIASSERT( QueryObjectCount() == 1 );
    if ( QueryError() != NERR_Success )
	return;

}// EDITSINGLE_USERPROP_DLG::EDITSINGLE_USERPROP_DLG



/*******************************************************************

    NAME:       EDITSINGLE_USERPROP_DLG::~EDITSINGLE_USERPROP_DLG

    SYNOPSIS:   Destructor for User Properties main dialog, edit
		single user variant

    HISTORY:
    JonN        01-Aug-1991     Created

********************************************************************/

EDITSINGLE_USERPROP_DLG::~EDITSINGLE_USERPROP_DLG( void )
{
}

/*******************************************************************

    NAME:       EDITSINGLE_USERPROP_DLG::OnCommand

    SYNOPSIS:   Takes care of checking the Password control checkboxes
		if the Password SLE is changed.

    ENTRY:      ce -            Notification event

    RETURNS:    TRUE if action was taken
                FALSE otherwise

    HISTORY:
               Thomaspa  02-Sep-1992    created

********************************************************************/

BOOL EDITSINGLE_USERPROP_DLG::OnCommand( const CONTROL_EVENT & ce )
{

    CID cid = ce.QueryCid();

    /*
     * If the password edit field is changed, set the Force Password
     * change checkbox
     */
    if (   QueryTargetServerType() == UM_LANMANNT
	&& cid == IDUP_ET_PASSWORD
	&& _pcbForcePWChange != NULL
        && ce.QueryCode() == EN_CHANGE
        && _triForcePWChange != AI_TRI_CHECK // only happens once
        && _pcbNoPasswordExpire != NULL
        && !_pcbNoPasswordExpire->IsIndeterminate()
        && !_pcbNoPasswordExpire->IsChecked()
        && !_cbUserCannotChange.IsIndeterminate()
        && !_cbUserCannotChange.IsChecked() )
    {
	    _pcbForcePWChange->SetCheck( TRUE );
	    _triForcePWChange = AI_TRI_CHECK;
    }

    return USERPROP_DLG::OnCommand( ce ) ;

}


/*******************************************************************

    NAME:       EDITSINGLE_USERPROP_DLG::InitControls

    SYNOPSIS:	See USERPROP_DLG::InitControls()

    HISTORY:
               JonN  01-Aug-1991    created

********************************************************************/

APIERR EDITSINGLE_USERPROP_DLG::InitControls()
{
    _sltLogonName.SetText( QueryUser2Ptr( 0 )->QueryName() );
    return SINGLE_USERPROP_DLG::InitControls();
}


/*******************************************************************

    NAME:       EDITSINGLE_USERPROP_DLG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG - The help context for this dialog.

    NOTES:	As per FuncSpec, context-sensitive help should be
		available here to explain how to promote a backup
		domain controller to primary domain controller.

    HISTORY:
               JonN  01-Aug-1991    created

********************************************************************/

ULONG EDITSINGLE_USERPROP_DLG::QueryHelpContext( void )
{

    return HC_UM_SINGLEUSERPROP_LANNT
		+ QueryHelpOffset();

} // EDITSINGLE_USERPROP_DLG :: QueryHelpContext





/*******************************************************************

    NAME:   EDITMULTI_USERPROP_DLG::EDITMULTI_USERPROP_DLG

    SYNOPSIS:   Constructor for User Properties main dialog, edit
		multiple users variant

    HISTORY:
    JonN        01-Aug-1991     Created

********************************************************************/

EDITMULTI_USERPROP_DLG::EDITMULTI_USERPROP_DLG(
	const UM_ADMIN_APP * pumadminapp,
	const LOCATION & loc,
	const LAZY_USER_SELECTION * psel,
	const LAZY_USER_LISTBOX * pulb
	) : USERPROP_DLG(
		MAKEINTRESOURCE(IDD_MULTIUSER),
		pumadminapp,
		loc,
		psel,
		pulb ),
	    _lbLogonNames(
		this,
		IDUP_LB_USERS,
		pulb
		)
{
    ASSERT( psel != NULL );
    UIASSERT( QueryObjectCount() > 1 );
    if ( QueryError() != NERR_Success )
	return;
    APIERR err = _lbLogonNames.Fill();
    if( err != NERR_Success )
    {
    	ReportError( err );
	return;
    }
}// EDITMULTI_USERPROP_DLG::EDITMULTI_USERPROP_DLG



/*******************************************************************

    NAME:       EDITMULTI_USERPROP_DLG::~EDITMULTI_USERPROP_DLG

    SYNOPSIS:   Destructor for User Properties main dialog, edit
		multiple users variant

    HISTORY:
    JonN        01-Aug-1991     Created

********************************************************************/

EDITMULTI_USERPROP_DLG::~EDITMULTI_USERPROP_DLG( void )
{
}


/*******************************************************************

    NAME:       EDITMULTI_USERPROP_DLG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG - The help context for this dialog.

    NOTES:	As per FuncSpec, context-sensitive help should be
		available here to explain how to promote a backup
		domain controller to primary domain controller.

    HISTORY:
               JonN  01-Aug-1991    created

********************************************************************/

ULONG EDITMULTI_USERPROP_DLG::QueryHelpContext( void )
{

    return HC_UM_SINGLEUSERPROP_LANNT
		+ QueryHelpOffset();

} // EDITMULTI_USERPROP_DLG :: QueryHelpContext





/*******************************************************************

    NAME:   NEW_USERPROP_DLG::NEW_USERPROP_DLG

    SYNOPSIS:   Constructor for User Properties main dialog, new user variant

    ENTRY:	pszCopyFrom: The name of the user to be copied.  Pass
			the name for "Copy..." actions, or NULL for
			"New..." actions

    HISTORY:
    JonN        24-Jul-1991     Created

********************************************************************/

NEW_USERPROP_DLG::NEW_USERPROP_DLG(
	const UM_ADMIN_APP * pumadminapp,
	const LOCATION & loc,
	const TCHAR * pszCopyFrom,
        ULONG ridCopyFrom
	) : SINGLE_USERPROP_DLG(
		MAKEINTRESOURCE(IDD_NEWUSER),
		pumadminapp,
		loc,
		NULL
		),
            _pbOKAdd( this, IDOK ),
            // CODEWORK rename this manifest to something more general
	    _sleLogonName( this, IDUP_ET_LOGON_NAME, LM20_UNLEN ),
	    _nlsLogonName(),
	    _pszCopyFrom( pszCopyFrom ),
            _ridCopyFrom( ridCopyFrom ),

            // CODEWORK this field not needed for MUM
	    _nlsNewProfile(),

	    _nlsNewHomeDir(),
            _fDefaultForcePWChange( FALSE )

{
    // for Clone variants, if aliases are relevant, RID must be specified
    ASSERT( _pszCopyFrom == NULL || IsDownlevelVariant() || ridCopyFrom != 0L );

    if ( QueryError() != NERR_Success )
	return;

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if (   (err = _nlsLogonName.QueryError()) != NERR_Success
        || (err = _nlsNewProfile.QueryError()) != NERR_Success
        || (err = _nlsNewHomeDir.QueryError()) != NERR_Success
       )
    {
	ReportError( err );
	return;
    }


    if ( _pszCopyFrom != NULL )
    {
        NLS_STR nlsTitle;
        ALIAS_STR nlsCopyFrom( _pszCopyFrom );

        if (   (err = nlsTitle.QueryError()) != NERR_Success
            || (err = nlsTitle.Load( IDS_UM_CopyOfUserTitle )) != NERR_Success
            || (err = nlsTitle.InsertParams( nlsCopyFrom )) != NERR_Success
           )
        {
            ReportError( err );
            return;
        }

        SetText( nlsTitle );
    }

    if (!fMiniUserManager)
    {
        RESOURCE_STR nlsAddButton( IDS_UM_AddButton );
        err = nlsAddButton.QueryError();
        if ( err != NERR_Success )
        {
            ReportError( err );
            return;
        }
        _pbOKAdd.SetText( nlsAddButton );

    }

    //
    //  Only  default ForcePWChange to TRUE if "must log on
    //  to change password" is disabled.  JonN 10/25/95
    //
    if (QueryTargetServerType() != UM_DOWNLEVEL)
    {
        SAM_PSWD_DOM_INFO_MEM sampswdinfo;
        if (  (err = sampswdinfo.QueryError()) != NERR_Success
            || (err = pumadminapp->QueryAdminAuthority()
                         ->QueryAccountDomain()->GetPasswordInfo(
                                 &sampswdinfo )) != NERR_Success
           )
        {
            DBGEOL( "NEW_USERPROP_DLG::ctor: error reading NoAnonChange " << err );
            ReportError( err );
            return;
        }
        _fDefaultForcePWChange = !(sampswdinfo.QueryNoAnonChange());
    }

} // NEW_USERPROP_DLG::NEW_USERPROP_DLG



/*******************************************************************

    NAME:       NEW_USERPROP_DLG::~NEW_USERPROP_DLG

    SYNOPSIS:   Destructor for User Properties main dialog, new user variant

    HISTORY:
    JonN        24-Jul-1991     Created

********************************************************************/

NEW_USERPROP_DLG::~NEW_USERPROP_DLG( void )
{
}


/*******************************************************************

    NAME:       NEW_USERPROP_DLG::IsCloneVariant

    SYNOPSIS:   Indicates whether this dialog is a Clone variant
                (a subclass of New).  Redefine for variants which are
                (potentially) Clone variants.

    HISTORY:
               JonN  23-Apr-1991    created

********************************************************************/

BOOL NEW_USERPROP_DLG::IsCloneVariant( void )
{
    return (_pszCopyFrom != NULL);

}   // USERPROP_DLG::IsCloneVariant


/*******************************************************************

    NAME:       NEW_USERPROP_DLG::QueryClonedUsername

    SYNOPSIS:   Indicates which user was cloned.  Call only when
                IsCloneVariant().

    HISTORY:
               JonN  23-Apr-1991    created

********************************************************************/

const TCHAR * NEW_USERPROP_DLG::QueryClonedUsername( void )
{
    ASSERT( IsCloneVariant() );

    return _pszCopyFrom;

}   // USERPROP_DLG::QueryClonedUsername


/*******************************************************************

    NAME:       NEW_USERPROP_DLG::GetOne

    SYNOPSIS:   if _pszCopyFrom is NULL, then this is New User,
		otherwise this is Copy User

    RETURNS:	error code

    NOTES:	In the case where pszCopyFrom==NULL, we check to make
		sure that the server is still up.  Otherwise the user
		might enter information and be unable to save it.

    HISTORY:
               JonN  24-Jul-1991    created
               JonN  02-Dec-1991    Added PingFocus()
               JonN  16-Apr-1992    Skip USER_MEMB for WindowsNT
	       Thomaspa 30-Jul-1992 Add new users to Users alias on WinNT

********************************************************************/

APIERR NEW_USERPROP_DLG::GetOne(
	UINT		iObject,
	APIERR *	perrMsg
	)
{
    *perrMsg = IDS_UMCreateNewFailure;
    UIASSERT( iObject == 0 );

    USER_2 * puser2New = NULL;
    if (IsDownlevelVariant())
    {
        puser2New = new USER_2( _pszCopyFrom, QueryLocation() );
    }
    else
    {
        puser2New = new USER_3( _pszCopyFrom, QueryLocation() );
    }
    if ( puser2New == NULL )
    {
	delete puser2New;
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    USER_MEMB * pusermembNew = NULL;
    if (DoShowGroups())
    {
        pusermembNew = new USER_MEMB( QueryLocation(), _pszCopyFrom);
	if ( pusermembNew == NULL )
	{
	    delete puser2New;
	    return ERROR_NOT_ENOUGH_MEMORY;
	}
    }

    APIERR err;
    if (   ((err = puser2New->QueryError()) != NERR_Success)
	|| ((pusermembNew != NULL) && ((err = pusermembNew->QueryError()) != NERR_Success)) )
    {
	delete puser2New;
	delete pusermembNew;
	return err;
    }

    QuerySlAddToAliases()->Clear();
    QuerySlRemoveFromAliases()->Clear();

    // If we are on WinNT, we want to make
    // sure that the user is automatically added to the Users alias
    // even if the user membership dialog is never entered.  So,
    // we add the user alias to the slist of alias memberships
    // to add.
    if ( QueryTargetServerType() == UM_WINDOWSNT && _pszCopyFrom == NULL )
    {
	RID_AND_SAM_ALIAS * prasm = new RID_AND_SAM_ALIAS(
		DOMAIN_ALIAS_RID_USERS,
		TRUE );
	if ( prasm == NULL )
	    err = ERROR_NOT_ENOUGH_MEMORY;
	else
	    err = QuerySlAddToAliases()->Add( prasm );
    }
    if ( err != NERR_Success )
    {
	delete puser2New;
	delete pusermembNew;
	return err;
    }

    if ( _pszCopyFrom == NULL )
    {
	if (    (err = PingFocus( QueryLocation() )) != NERR_Success
             || (err = puser2New->CreateNew()) != NERR_Success
             || ((pusermembNew != NULL) && (err = pusermembNew->CreateNew()) != NERR_Success) )
        {
	    delete puser2New;
	    delete pusermembNew;
	    return err;
        }

/*
    JonN 04-Jun-1992   New users are automatically added to the Users
    global group on NT machines.  At this point, we must add that group
    to the default user membership, so that the list the user sees in the
    User Membership subdialog will correspond to the real state of a new
    user, and so that the attempt to write this new data will succeed.
*/
        if ( DoShowGroups() && !IsDownlevelVariant() )
        {

            SAM_DOMAIN * psamdomAccount = QueryAdminAuthority()
                                             ->QueryAccountDomain();
            LSA_POLICY * plsapol = QueryAdminAuthority()
                                             ->QueryLSAPolicy();
            ASSERT( psamdomAccount != NULL && psamdomAccount->QueryError() == NERR_Success );
            ASSERT( plsapol != NULL && plsapol->QueryError() == NERR_Success );

            OS_SID sidUsersGlobalGroup( psamdomAccount->QueryPSID(),
                                        (ULONG)DOMAIN_GROUP_RID_USERS ); // from winnt.h
            PSID psidUsersGlobalGroup = NULL;
            LSA_TRANSLATED_NAME_MEM lsatnm;
            LSA_REF_DOMAIN_MEM lsardm;
            NLS_STR nlsUsersGroup;
            if (   (err = sidUsersGlobalGroup.QueryError()) != NERR_Success
                || (err = lsatnm.QueryError()) != NERR_Success
                || (err = lsardm.QueryError()) != NERR_Success
                || (err = nlsUsersGroup.QueryError()) != NERR_Success
                || (psidUsersGlobalGroup = sidUsersGlobalGroup.QuerySid(), FALSE)
                || (err = plsapol->TranslateSidsToNames(
                                     &psidUsersGlobalGroup,
                                     1,
                                     &lsatnm,
                                     &lsardm )) != NERR_Success
                || (err = lsatnm.QueryName( 0, &nlsUsersGroup )) != NERR_Success
                || (err = pusermembNew->AddAssocName( nlsUsersGroup.QueryPch() )) != NERR_Success
               )
            {
                UIDEBUG( SZ("User Manager: failed to add USERS global group, err = ") );
                UIDEBUGNUM( err );
                UIDEBUG( SZ("\n\r") );
	        delete puser2New;
	        delete pusermembNew;
	        return err;
            }
        }

    }
    else
    {
	/*
	    JonN 03-Nov 1991  We trim the PARAMS field using the code
	    in USER_11.  This is as discussed with DavidTu, JawadK etc.
	    BUGBUG better unit-test this thoroughly!
	*/
        if (   ((err = puser2New->GetInfo()) != NERR_Success)
	    || ((err = puser2New->ChangeToNew()) != NERR_Success)
	    || ((err = puser2New->SetName( NULL )) != NERR_Success)
	    || ((err = puser2New->SetFullName( NULL )) != NERR_Success)
	    || ((err = puser2New->SetUserComment( NULL )) != NERR_Success)
	    || ((err = puser2New->SetPassword( NULL )) != NERR_Success)
	    || ((err = puser2New->SetAccountDisabled( FALSE )) != NERR_Success)
	    || ((pusermembNew != NULL) && ((err = pusermembNew->GetInfo()) != NERR_Success) )
	    || ((pusermembNew != NULL) && ((err = pusermembNew->ChangeToNew()) != NERR_Success) )
            || ((!IsDownlevelVariant()) && ((err = CloneAliasMemberships()) != NERR_Success) )
	   )
        {
	    delete puser2New;
	    delete pusermembNew;
	    return err;
        }
    }

    SetUser2Ptr( iObject, puser2New ); // change and delete previous
    SetUserMembPtr( iObject, pusermembNew ); // change and delete previous

    // hydra
    USER_CONFIG * pUserConfig = NULL;
    pUserConfig = new USER_CONFIG( _pszCopyFrom, QueryLocation().QueryServer() );

    if ( pUserConfig == NULL )
	return ERROR_NOT_ENOUGH_MEMORY;

    if ( (err = pUserConfig->QueryError()) == NERR_Success ) {

        /*
         * If this is a copy of existing user, fetch that user's configuration
         * settings.  Else (or if existing user not configured), set default
         * values.  Finally, change this USER_CONFIG object to the 'new' state
         * (no user name) and force the 'dirty' flag on to assure that a
         * user config structure will be written when a new user is created.
         */
        if ( (_pszCopyFrom == NULL) ||
             (pUserConfig->GetInfo() != NERR_Success) ) {

            pUserConfig->SetDefaults( ((UM_ADMIN_APP *)_pumadminapp)->QueryDefaultUserConfig() );
        }
        pUserConfig->SetUserName( SZ("") );
        pUserConfig->SetDirty();

    } else {

	delete pUserConfig;
	return err;
    }

    SetUserConfigPtr( iObject, pUserConfig );
    // hydra end

    return W_LMOBJtoMembers( iObject );
}


/*******************************************************************

    NAME:       NEW_USERPROP_DLG::PerformOne

    SYNOPSIS:	Saves information on one user

    ENTRY:	iObject is the index of the object to save

		perrMsg is the error message to be displayed if an
		error occurs, see PERFORMER::PerformSeries for details

		pfWorkWasDone indicates whether any UAS changes were
		successfully written out.  This may return TRUE even if
		the PerformOne action as a whole failed (i.e. PerformOne
		returned other than NERR_Success).

    RETURNS:	error message (not necessarily an error code)

    HISTORY:
               thomaspa	28-Apr-1992    Alias membership support
               JonN     03-Feb-1993    split from USERPROP_DLG

********************************************************************/

APIERR NEW_USERPROP_DLG::PerformOne(
	UINT		iObject,
	APIERR *	perrMsg,
	BOOL *		pfWorkWasDone
	)
{
    APIERR err = SINGLE_USERPROP_DLG::PerformOne( iObject,
                                                  perrMsg,
                                                  pfWorkWasDone );


#ifdef WIN32

    //
    // Now do alias memberships
    //

    if ( (err == NERR_Success) && (!IsDownlevelVariant()) )
    {
        APIERR errAddToAliases = NERR_Success;

        do // false loop
        {

    	    SAM_DOMAIN * psamdomAccount =
    	    		QueryAdminAuthority()->QueryAccountDomain();

    	    SAM_DOMAIN * psamdomBuiltin =
    	    		QueryAdminAuthority()->QueryBuiltinDomain();

            // We must repeat the GetInfo operation to obtain the correct
            // RID for the newly-created user.  JonN 08-Jun-1992
            // CODEWORK Some other operation would be more efficient than
            // a GetInfo().

    	    if ( (errAddToAliases = QueryUser3Ptr( iObject )->GetInfo()) != NERR_Success )
    	    {
    	        break;
    	    }

    	    ULONG ridUser = (QueryUser3Ptr( iObject ))->QueryUserId();

    	    OS_SID ossidUser( psamdomAccount->QueryPSID(), ridUser );

    	    if ( (errAddToAliases = ossidUser.QueryError()) != NERR_Success )
    	    {
    	        break;
    	    }


    	    RID_AND_SAM_ALIAS *prasm;

            SLIST_OF( RID_AND_SAM_ALIAS ) * pslrasm = QuerySlAddToAliases();

    	    ITER_SL_OF(RID_AND_SAM_ALIAS) iterAddToAliases( *pslrasm );

    	    while ( ( prasm  = iterAddToAliases.Next() ) != NULL )
    	    {
    	        SAM_ALIAS * psamalias;
    	        if ( (psamalias = prasm->QuerySamAlias()) == NULL )
    	        {
    	    	    psamalias = new SAM_ALIAS(
    	    				prasm->IsBuiltin() ? *psamdomBuiltin
    	    						   : *psamdomAccount,
    	    				prasm->QueryRID() );
    	    	    errAddToAliases = ERROR_NOT_ENOUGH_MEMORY;
    	    	    if ( psamalias == NULL ||
    	    	        (errAddToAliases = psamalias->QueryError()) != NERR_Success )
    	    	    {
    	    	        if ( errAddToAliases == NERR_Success)
    	    		    errAddToAliases = err;
    	    	        continue;	// No point in trying this alias
    	    	    }

    	    	    prasm->SetSamAlias( psamalias );
    	    			
    	        }

    	        errAddToAliases = psamalias->AddMember( ossidUser.QuerySid() );
    	        if (   errAddToAliases != NERR_Success
                    && errAddToAliases != STATUS_MEMBER_IN_ALIAS
                    && errAddToAliases != ERROR_MEMBER_IN_ALIAS
                       )
    	        {
    	    	    if ( errAddToAliases == NERR_Success )
    	    	        errAddToAliases = err;
    	    	    continue;
    	        }

                // NOTE -- we do not to remove the item from the SLIST
                // here, so that if we go back to the USERMEMB dialog,
                // it will appear in the IN listbox.
                //
                // Also note that, if the user now returns to the USERMEMB dialog
                // and removes one of the aliases from the In list, but we just
                // added the user to that alias, we will not attempt to go back
                // and remove the user from that alias.

    	    }

            //
            // Reset NetWare user's password since the old rid is incorrect.
            // Also, go ahead and create the NW login script dir now we have
            // a valid SID and RID.
            //
            if (IsNetWareChecked())
            {
                ASSERT( IsNetWareInstalled() );

                if (((err = CallMapRidToObjectId (ridUser,
                                                  (LPWSTR)(QueryUserNWPtr(iObject))->QueryName(),
                                                  QueryTargetServerType()==UM_LANMANNT,
                                                  FALSE,
                                                  &ridUser)) != NERR_Success ) ||
                    ((err = QueryUserNWPtr(iObject)->SetNWPassword (QueryAdminAuthority(),
                                                                    ridUser,
                                                                    GetPassword())) != NERR_Success ))
                {
                    break;
                }

                if ((err = QueryUser2Ptr (iObject)->Write()) == NERR_Success)
                {
                    err = ((USER_NW *)QueryUser2Ptr(iObject))->SetupNWLoginScript(
                               QueryAdminAuthority(),
                               ridUser);
                }

                if (err != NERR_Success)
                    break;
            }
        }
        while (FALSE); // false loop

        //
        // If an error occurred, display an error message and forget it.
        //

    	if ( errAddToAliases )
        {
    	    DisplayError( errAddToAliases,
                          IDS_UMNewUserAliasFailure,
                          QueryObjectName( iObject ),
                          FALSE,
                          this );
        }
    }

#endif // WIN32

    // We used to call NotifyCreateExtensions earlier, but no more; this
    // is now delayed until after setting up the aliases, so that we
    // can pass the RID of the new user.  JonN 8/3/94

    if ( *pfWorkWasDone )
        ((UM_ADMIN_APP *)_pumadminapp)->NotifyCreateExtensions( QueryHwnd(), QueryUser2Ptr( iObject ) );


    return err;

}


/*******************************************************************

    NAME:       NEW_USERPROP_DLG::CloneAliasMemberships

    SYNOPSIS:	When we clone an existing user, we will want to clone
                that user's initial alias memberships.  This means that
                we determine which aliases the user is in (on the
                Accounts and Builtin domain, we cannot clone others)
                and copy these to the AddTo SLIST.

                In order for the USER_MEMB_DLG to display initial
                membership correctly, we must save the SAM_RID_MEMs
                into the _apsamrm* arrays, as well as initializing
                the SlAddToAliases list to add the new user to all of
                those aliases.

    NOTE:       ALIAS_ENUM enumerates aliases, not alias membership.

    HISTORY:
               JonN  20-May-1992    created

********************************************************************/

APIERR NEW_USERPROP_DLG::CloneAliasMemberships()
{
    ASSERT( _ridCopyFrom != 0L );

    SAM_RID_MEM * psamrmAccounts = NULL;
    SAM_RID_MEM * psamrmBuiltin  = NULL;

    APIERR err = I_GetAliasMemberships( _ridCopyFrom,
                                        &psamrmAccounts,
                                        &psamrmBuiltin );

    ULONG i;

    for ( i = 0;
          err == NERR_Success && i < psamrmAccounts->QueryCount();
          i++ )
    {
        RID_AND_SAM_ALIAS * prasm = new RID_AND_SAM_ALIAS(
                   psamrmAccounts->QueryRID( i ),
                   FALSE );
        if ( prasm == NULL )
    	    err = ERROR_NOT_ENOUGH_MEMORY;
        else
            err = QuerySlAddToAliases()->Add( prasm );
    }

    for ( i = 0;
          err == NERR_Success && i < psamrmBuiltin->QueryCount();
          i++ )
    {
        RID_AND_SAM_ALIAS * prasm = new RID_AND_SAM_ALIAS(
                   psamrmBuiltin->QueryRID( i ),
                   TRUE );
        if ( prasm == NULL )
    	    err = ERROR_NOT_ENOUGH_MEMORY;
        else
            err = QuerySlAddToAliases()->Add( prasm );
    }

    delete psamrmAccounts;
    delete psamrmBuiltin;

    return err;
}


/*******************************************************************

    NAME:       NEW_USERPROP_DLG::InitControls

    SYNOPSIS:	See USERPROP_DLG::InitControls()

    NOTE:       This InitControls can be called several times
                during the life of the dialog, we cannot just
                assume that the initial dialog settings are correct.

    HISTORY:
               JonN  19-Jul-1991    created
               JonN  12-Jun-1992    ForceChange always starts TRUE

********************************************************************/

APIERR NEW_USERPROP_DLG::InitControls()
{
    _sleLogonName.SetText( _nlsLogonName );
    // hydra
    _triForcePWChange = (_fDefaultForcePWChange && !vfIsCitrixOrDomain)
    /* original code
    _triForcePWChange = (_fDefaultForcePWChange)
    */
    ? AI_TRI_CHECK : AI_TRI_UNCHECK;

    APIERR err = SINGLE_USERPROP_DLG::InitControls();

    // Now make sure that either User Must Change Password and User
    // cannot change password are unchecked. (could happen for copied users).
    if (   !IsDownlevelVariant()
        && _pcbForcePWChange->IsChecked()
	&& _cbUserCannotChange.IsChecked() )
    {
        _triForcePWChange = AI_TRI_UNCHECK;
        _pcbForcePWChange->SetCheck( FALSE );
    }

    _sleLogonName.SelectString();
    _sleLogonName.ClaimFocus();

    return err;
}


/*******************************************************************

    NAME:       NEW_USERPROP_DLG::OnOK

    SYNOPSIS:   OK button handler.  This handler applies only to
		New User variants.  Successfully creating a user
                does not

    EXIT:	Dismiss() return code indicates whether the dialog wrote
		any changes successfully to the API at any time.

    HISTORY:
	       JonN  13-May-1992    Dialog does not close for New variant

********************************************************************/

BOOL NEW_USERPROP_DLG::OnOK( void )
{
    APIERR err = W_DialogToMembers();
    if ( err != NERR_Success )
    {
	MsgPopup( this, err );
	return TRUE;
    }

    if ( PerformSeries() )
    {
        if (fMiniUserManager)
        {
            Dismiss( QueryWorkWasDone() );
        }
        else
        {
            err = CancelToCloseButton();
            if ( err != NERR_Success )
            {
                UIDEBUG( SZ("NEW_USERPROP_DLG::OnOK(); CancelToCloseButton failed\n\r") );
                MsgPopup( this, err );
                Dismiss( QueryWorkWasDone() );
            } else if (!GetInfo()) // reload default information
                Dismiss( QueryWorkWasDone() );
        }
    }

    return TRUE;

}   // NEW_USERPROP_DLG::OnOK


/*********************************************************************

    NAME:       NEW_USERPROP_DLG::OnCancel

    SYNOPSIS:   Called when the dialog's Cancel button is clicked.
                Assumes that the Cancel button has control ID IDCANCEL.

    RETURNS:
        TRUE if action was taken,
        FALSE otherwise.

    NOTES:
        The default implementation dismisses the dialog, returning FALSE.
        This variant returns TRUE if a user has already been added.

    HISTORY:
        jonn      13-May-1992      Templated from bltdlg.cxx

*********************************************************************/

BOOL NEW_USERPROP_DLG::OnCancel()
{
    Dismiss( QueryWorkWasDone() );
    return TRUE;
} // NEW_USERPROP_DLG::OnCancel


/*******************************************************************

    NAME:       NEW_USERPROP_DLG::W_MapPerformOneError

    SYNOPSIS:	Checks whether the error maps to a specific control
		and/or a more specific message.  Each level checks for
		errors specific to edit fields it maintains.  This
		level checks for errors associated with the LogonName
		edit field.

    ENTRY:      Error returned from PerformOne()

    RETURNS:	Error to be displayed to user

    HISTORY:
	       JonN  03-Sep-1991    Added validation

********************************************************************/

MSGID NEW_USERPROP_DLG::W_MapPerformOneError(
	APIERR err
	)
{
    APIERR errNew = NERR_Success;
    switch ( err )
    {
    case NERR_BadUsername:
	errNew = IERR_UM_UsernameRequired;
	break;
    case NERR_UserExists:
	errNew = IERR_UM_UsernameAlreadyUser;
	break;
    case NERR_GroupExists:
	errNew = IERR_UM_UsernameAlreadyGroup;
	break;
    default: // other error
        return SINGLE_USERPROP_DLG::W_MapPerformOneError( err );
    }

    _sleLogonName.SelectString();
    _sleLogonName.ClaimFocus();
    return errNew;
}


/*******************************************************************

    NAME:       NEW_USERPROP_DLG::QueryObjectName

    SYNOPSIS:	This is the "new user" variant of QueryObjectName.  The
		best name we can come up with is the last name read from
		the dialog.

    HISTORY:
               JonN  24-Jul-1991    created

********************************************************************/

const TCHAR * NEW_USERPROP_DLG::QueryObjectName(
	UINT		iObject
	) const
{
    UIASSERT( iObject == 0 );
    return _nlsLogonName.QueryPch();
}


/*******************************************************************

    NAME:       NEW_USERPROP_DLG::W_LMOBJtoMembers

    SYNOPSIS:	Loads class data members from initial data

    HISTORY:
               JonN  21-Aug-1991    created

********************************************************************/

APIERR NEW_USERPROP_DLG::W_LMOBJtoMembers(
	UINT		iObject
	)
{
    ASSERT( iObject == 0 );
    
    // hydra
    USER_CONFIG * pUserConfig;


    USER_2 * puser2 = QueryUser2Ptr(iObject);
    ASSERT( (puser2 != NULL) && (puser2->QueryError() == NERR_Success) );

    APIERR err = _nlsLogonName.CopyFrom( puser2->QueryName() );
    if (   err == NERR_Success
        && (err = SetNewHomeDir( puser2->QueryHomeDir() )) == NERR_Success
        && ( QueryEnableUserProfile() )
       )
    {
        err = SetNewProfile( ((USER_3 *)puser2)->QueryProfile() );
    }

    if ( (err == NERR_Success) && (_pszCopyFrom != NULL) )
    {

        if (   (err = GeneralizeString( &_nlsNewHomeDir,
                                        _pszCopyFrom )) == NERR_Success
            && ( QueryEnableUserProfile() )
           )
        {
            err = GeneralizeString( &_nlsNewProfile,
                                    _pszCopyFrom,
                                    QueryExtensionReplace() );
        }
    }
    
// hydra
    
    pUserConfig = QueryUserConfigPtr( iObject );
        
    
    _nlsNewWFHomeDir = pUserConfig->QueryWFHomeDir();
    
    if( QueryEnableUserProfile() )
        _nlsNewWFProfile = pUserConfig->QueryWFProfilePath();
    
    
    if ( (_pszCopyFrom != NULL) )
    {
        GeneralizeString( &_nlsNewWFHomeDir,
                          _pszCopyFrom );
        
        if(QueryEnableUserProfile() )
            GeneralizeString( &_nlsNewWFProfile,
                              _pszCopyFrom,
                              QueryExtensionReplace() );
    }
// hydra end
    return (err != NERR_Success)
                 ? err
                 : SINGLE_USERPROP_DLG::W_LMOBJtoMembers( iObject );
}


/*******************************************************************

    NAME:       NEW_USERPROP_DLG::W_MembersToLMOBJ

    SYNOPSIS:	Loads class data members into the USER_2 object

    RETURNS:	error code

    HISTORY:
	JonN     20-Aug-1991    Multiselection redesign
	thomaspa 28-Apr-1992	Don't try to SetName on pusermemb if
				this is a WIN NT machine
				

********************************************************************/

APIERR NEW_USERPROP_DLG::W_MembersToLMOBJ(
	USER_2 *	puser2,
	USER_MEMB *	pusermemb
	)
{
    APIERR err = puser2->SetName( _nlsLogonName.QueryPch() );
    if ( err != NERR_Success )
	return err;

    // Only try this for non-WIN NT machines
    if ( pusermemb != NULL )
    {
        err = pusermemb->SetName( _nlsLogonName.QueryPch() );
        if ( err != NERR_Success )
	    return err;
    }

    // templated from USERPROF_DLG variants
    // set up the _fGeneralizedHomeDir variable for later use
    // Note that this is not "clone-only", the user might enter
    // %USERNAME% by hand.
    NLS_STR nlsTemp( QueryNewHomeDir() );
    err = nlsTemp.QueryError();
    if (   err != NERR_Success
        || (err = DegeneralizeString( &nlsTemp,
                                      _nlsLogonName.QueryPch(),
                                      NULL,
                                      &_fGeneralizedHomeDir ))
                        != NERR_Success
        || (err = puser2->SetHomeDir( nlsTemp )) != NERR_Success
       )
    {
        return err;
    }

    // hydra
    USER_CONFIG * pUserConfig = QueryUserConfigPtr( 0 );
    
    nlsTemp.CopyFrom( QueryNewWFHomeDir() );
    err = nlsTemp.QueryError();
    if (   err != NERR_Success
           || (err = DegeneralizeString( &nlsTemp,
                                         _nlsLogonName.QueryPch(),
                                         NULL,
                                         &_fGeneralizedHomeDir ))
           != NERR_Success
           || (err = pUserConfig->SetWFHomeDir( nlsTemp.QueryPch() ) )!= NERR_Success
       )
    {
        return err;
    }

    pUserConfig->SetWFHomeDirDirty();
    // hydra end

    if ( QueryEnableUserProfile() )
    {
        NLS_STR nlsTemp( QueryNewProfile() );
        err = nlsTemp.QueryError();
        if (   err != NERR_Success
            || (err = DegeneralizeString( &nlsTemp,
                                          _nlsLogonName.QueryPch(),
                                          QueryExtensionReplace() ))
                              != NERR_Success
            || (err = ((USER_3 *)puser2)->SetProfile( nlsTemp )) != NERR_Success
           )
        {
            return err;
        }

        //  hydra
        nlsTemp.CopyFrom( QueryNewWFProfile() );
        err = nlsTemp.QueryError();
        if (   err != NERR_Success
               || (err = DegeneralizeString( &nlsTemp,
                                             _nlsLogonName.QueryPch(),
                                             QueryExtensionReplace() ))
               != NERR_Success
               || (err = pUserConfig->SetWFProfilePath( nlsTemp.QueryPch() ) )!= NERR_Success
           )
        {
            return err;
        }
        // hydra end

    }

    return SINGLE_USERPROP_DLG::W_MembersToLMOBJ( puser2, pusermemb );
}


/*******************************************************************

    NAME:       NEW_USERPROP_DLG::W_DialogToMembers

    SYNOPSIS:	Loads data from dialog into class data members

    RETURNS:	error message (not necessarily an error code)

    NOTES:	This method takes care of validating the data in the
    		dialog.  This means ensuring that the logon name is
		valid.  If this validation fails, W_DialogToMembers will
		change focus et al. in the dialog, and return the error
		message to be displayed.

    HISTORY:
	       JonN  21-Aug-1991    Multiselection redesign
	       JonN  03-Sep-1991    Added validation

********************************************************************/

APIERR NEW_USERPROP_DLG::W_DialogToMembers(
	)
{
    // This will clear leading/trailing whitespace
    APIERR err = NERR_Success;
    if (   ((err = _sleLogonName.QueryText( &_nlsLogonName )) != NERR_Success)
        || ((err = _nlsLogonName.QueryError()) != NERR_Success ) )
    {
	return err;
    }


#ifdef NOT_ALLOW_DBCS_USERNAME
    // #3255 6-Nov-93 v-katsuy
    // check contains DBCS for User name
    if ( NETUI_IsDBCS() )
    {
        CHAR  ansiLogonName[LM20_UNLEN * 2 + 1];
        _nlsLogonName.MapCopyTo( (CHAR *)ansiLogonName, LM20_UNLEN * 2 + 1);
        if ( ::lstrlenA( ansiLogonName ) != _nlsLogonName.QueryTextLength() )
        {
            _sleLogonName.SelectString();
            _sleLogonName.ClaimFocus();
            return IERR_UM_UsernameRequired;
        }
    }
#endif

    // CODEWORK should use VALIDATED_DIALOG
    if (   ( _nlsLogonName.strlen() == 0 )
	|| ( NERR_Success != ::I_MNetNameValidate(	NULL,
						_nlsLogonName,
						NAMETYPE_USER,
						0L ) ) )
    {
	_sleLogonName.SelectString();
	_sleLogonName.ClaimFocus();
	return IERR_UM_UsernameRequired;
    }

    return SINGLE_USERPROP_DLG::W_DialogToMembers();
}


/*******************************************************************

    NAME:       NEW_USERPROP_DLG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG - The help context for this dialog.


    HISTORY:
               JonN  24-Jul-1991    created

********************************************************************/

ULONG NEW_USERPROP_DLG::QueryHelpContext( void )
{
    return ((_pszCopyFrom == NULL) ?
		HC_UM_NEWUSERPROP_LANNT : HC_UM_COPYUSERPROP_LANNT)
	+ QueryHelpOffset();

} // NEW_USERPROP_DLG :: QueryHelpContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\usub2prp.cxx ===
/**********************************************************************/
/**                Microsoft Windows NT                              **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    usub2prp.cxx
    USER_SUB2PROP_DLG class implementation

    FILE HISTORY:
*/


#include <ntincl.hxx>
extern "C"
{
    #include <ntsam.h>
}


#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_NETACCESS // for USER_PRIV_ manifests
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_SPIN_GROUP
#include <blt.hxx>

#include <uitrace.hxx>
#include <usrmain.hxx>
#include <userprop.hxx>
#include "usub2prp.hxx"
#include <usrmgr.h>
#include <usrmgrrc.h>


/*******************************************************************

    NAME:	USER_SUB2PROP_DLG::USER_SUB2PROP_DLG

    SYNOPSIS:	USER_SUB2PROP_DLG constructor

    ENTRY:	pupropdlgParent -	Pointer to parent window
		pszResourceName -	Name of dialog resource
		pulb		-	Pointer to main user lb

    HISTORY:
********************************************************************/

USER_SUB2PROP_DLG::USER_SUB2PROP_DLG( USER_SUBPROP_DLG * pupropdlgParent,
				    const TCHAR *   pszResourceName,
				    const LAZY_USER_LISTBOX * pulb,
                                    BOOL fAnsiDialog )
    :	SUBPROP_DLG( (BASEPROP_DLG *)pupropdlgParent, pszResourceName, fAnsiDialog ),
	_sltNameLabel( this, IDUP_ST_USER_LB ),
	_sltpLogonName( this, IDUP_ST_USER ),
	_plbLogonName( NULL ),
	_phidden( NULL )
{
    if ( QueryError() != NERR_Success )
	return;

    INT i = QueryObjectCount();
    RESOURCE_STR resstr( i > 1 ? IDS_LABEL_USERS : IDS_LABEL_USER );
    APIERR err = resstr.QueryError();
    if( err != NERR_Success )
    {
	ReportError( err );
	return;
    }
    _sltNameLabel.SetText( resstr );

    err = ERROR_NOT_ENOUGH_MEMORY;
    if ( i > 1 )
    {
	_sltpLogonName.Show( FALSE );
	_plbLogonName = new USER2_LISTBOX( this, IDUP_LB_USERS, pulb );
	if(   _plbLogonName == NULL
	   || (err = _plbLogonName->QueryError() ) != NERR_Success )
	{
	    ReportError( err );
	    return;
	}
    }
    else
    {	
	_phidden = new HIDDEN_CONTROL( this, IDUP_LB_USERS );
	if(    _phidden == NULL
	    || (err = _phidden->QueryError())!= NERR_Success )
	{
	    ReportError( err );
	    return;
	}
    }

}  // USER_SUB2PROP_DLG::USER_SUB2PROP_DLG


/*******************************************************************

    NAME:	USER_SUB2PROP_DLG::~USER_SUB2PROP_DLG

    SYNOPSIS:	USER_SUB2PROP_DLG destructor

    HISTORY:
	rustanl     28-Aug-1991     Created

********************************************************************/

USER_SUB2PROP_DLG::~USER_SUB2PROP_DLG()
{
    delete _phidden;
    _phidden = NULL;
    delete _plbLogonName;
    _plbLogonName = NULL;

}  // USER_SUB2PROP_DLG::~USER_SUB2PROP_DLG


/*******************************************************************

    NAME:	USER_SUB2PROP_DLG::QueryUser2Ptr

    SYNOPSIS:   Accessor to the NEW_LM_OBJ arrays

    ENTRY:	iObject	  -	index to object

    RETURNS:	pointer to USER_2 object

    HISTORY:
    	o-SimoP        19-Sep-1991     Created

********************************************************************/

USER_2 * USER_SUB2PROP_DLG::QueryUser2Ptr( UINT iObject )
{
    return QueryParent()->QueryParent()->QueryUser2Ptr( iObject );
}


/*******************************************************************

    NAME:       USER_SUB2PROP_DLG::InitControls

    SYNOPSIS:   Initializes the controls maintained by USER_SUB2PROP_DLG,
		according to the values in the class data members.
			
    RETURNS:	An error code which is NERR_Success on success.

    HISTORY:
    	o-SimoP        08-Oct-1991     Created

********************************************************************/

APIERR USER_SUB2PROP_DLG::InitControls()
{
    APIERR err;

    if ( QueryObjectCount() == 1 )
    {
        NLS_STR nls;

	// CODEWORK:  Forming the qualified name should be done by a
	// common routine in NT_ACCOUNTS_UTILITY.
	if ( IsNewVariant() )
	{
	    NLS_STR nlsFullName;
	    NEW_USERPROP_DLG * pNewUserProp = (NEW_USERPROP_DLG *)QueryParent()->QueryParent();

	    err = pNewUserProp->_sleLogonName.QueryText( &nls );
	    if ( err == NERR_Success
		&& (err = nls.QueryError()) == NERR_Success
		&& (err = pNewUserProp->_sleFullName.QueryText( &nlsFullName ))
			== NERR_Success
		&& (err = nlsFullName.QueryError()) == NERR_Success
		&& nlsFullName.QueryPch() != NULL
		&& *nlsFullName.QueryPch() )
	    {
	        nls += SZ(" (");
	        err = nls.QueryError();

	        if( err == NERR_Success )
	        {
	            nls += nlsFullName;
	            err = nls.QueryError();
                }
	        if( err == NERR_Success )
	        {
	            nls += SZ(")");
	            err = nls.QueryError();
                }
	    }
	}
	else
	{
	    USER_2 * puser2 = QueryUser2Ptr( 0 );  //first
	    nls = puser2->QueryName();
	    err = nls.QueryError();

	    if ( err == NERR_Success
		&& puser2->QueryFullName() != NULL
		&& *puser2->QueryFullName() )
	    {
	        nls += SZ(" (");
	        err = nls.QueryError();

	        if( err == NERR_Success )
	        {
	            nls += puser2->QueryFullName();
	            err = nls.QueryError();
                }
	        if( err == NERR_Success )
	        {
	            nls += SZ(")");
	            err = nls.QueryError();
                }
	    }

	}
	if( err == NERR_Success )
	    _sltpLogonName.SetText( nls );
    }
    else
    {
	err = _plbLogonName->Fill();
    }

    return err;

} // USER_SUB2PROP_DLG::InitControls


/*******************************************************************

    NAME:       USER_SUB2PROP_DLG::W_DialogToMembers

    SYNOPSIS:	Loads data from dialog into class data members

    RETURNS:	error message (not necessarily an error code)

    HISTORY:

********************************************************************/

APIERR USER_SUB2PROP_DLG::W_DialogToMembers(
	)
{
    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_SUB2PROP_DLG::W_MapPerformOneError

    SYNOPSIS:	Checks whether the error maps to a specific control
		and/or a more specific message.  Each level checks for
		errors specific to edit fields it maintains.  There
		are no errors associated with an invalid comment, so
		this level does nothing.

    ENTRY:      Error returned from PerformOne()

    RETURNS:	Error to be displayed to user

    HISTORY:

********************************************************************/

MSGID USER_SUB2PROP_DLG::W_MapPerformOneError(
	APIERR err
	)
{
    return err;
}


/*******************************************************************

    NAME:	USER_SUB2PROP_DLG::OnOK

    SYNOPSIS:   OK button handler

    HISTORY:
        JonN        06-Mar-1992     moved from subclasses
********************************************************************/

BOOL USER_SUB2PROP_DLG::OnOK(void)
{
    APIERR err = W_DialogToMembers();

    switch( err )
    {
    case NERR_Success:
	break;
	
    case IERR_CANCEL_NO_ERROR:
        return TRUE;

    default:
	::MsgPopup( this, err );
	return TRUE;
    }

    if ( PerformSeries() )
	Dismiss(); // Dismiss code not used
    return TRUE;

} // USER_SUB2PROP_DLG::OnOK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\usrmgr.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    usrmgr.cxx
    User Manager: main application module

    FILE HISTORY:
        kevinl      12-Apr-1991     created
        kevinl      21-May-1991     Conformed to ADMIN_APP and APP_WINDOW
        gregj       23-May-1991     Cloned from Server Manager
        rustanl     02-Jul-1991     Use new USER_LISTBOX
        rustanl     18-Jul-1991     Use new GROUP_LISTBOX
        jonn        27-Aug-1991     Added OnNewUser()
        jonn        29-Aug-1991     Added OnNewUser( pszCopyFrom )
        o-SimoP     30-Sep-1991     deletemenu changes according
                                    to latest spec (1.3)
        jonn        11-Oct-1991     Added OnNewGroup( pszCopyFrom )
        jonn        14-Oct-1991     Changed OnNewUser/Group to
                                        OnNewObject/GroupMenuSel
        jonn        14-Oct-1991     Installed refresh lockcount
        beng        17-Oct-1991     Explicitly inits SLT_PLUS itself
        jonn        11-Nov-1991     Added OnFocus()
        jonn        02-Dec-1991     Added PingFocus()
        o-SimoP     11-Dec-1991     Added SetReadyToDie calls
        o-SimoP     26-Dec-1991     Removed SetReadyToDie calls
        o-SimoP     31-Dec-1991 CR changes, attended by BenG, JonN and I
        thomaspa    29-Jan-1992     Added Rename User
        jonn        20-Feb-1992     OnNewGroupMenuSel de-virtual-ed, added OnNewAliasMenuSel
        KeithMo     08-Apr-1992     Added Trusted Domain List manipulation.
        jonn        10-Apr-1992     Mini-User Manager
        Yi-HsinS    15-Apr-1992     Added audit dialog and user rights dialog
        jonn        21-Apr-1992     Added _userpropType instance variable
        jonn        26-Apr-1992     Trusted Domain for FUM only
        jonn        11-May-1992     Disable menu items on WinNt focus
        jonn        13-May-1992     Removed "Allow blank password", PgmMgt
                                    changed their minds
        JonN        15-May-1992     Move USERPROP_DLG::OnCommand to usrmain.cxx
        jonn        20-May-1992     Added OnNewUser( pszCopyFrom, ridCopyFrom )
        JonN        10-Jun-1992     Use Select Domain dialog
        JonN        20-Jul-1992     Allow normal users
        JonN        08-Oct-1993     Added horizontal splitter bar

    CODEWORK  LockRefresh() should be in effect whenever an
              ADMIN_SELECTION or LAZY_USER_SELECTION is in scope!
    CODEWORK  Remove OnFocus()/OnDefocus() when supported by
              DIALOG_WINDOW!
*/

// Define this to allow UM_LANMANNT focus on a WINNT machine
// #define FAKE_LANMANNT_FOCUS

#include <ntincl.hxx>

extern "C"
{
    #include <ntlsa.h>
    #include <ntsam.h>
}

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#include <lmapibuf.h> // used for NetApiBuffer Free

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#define INCL_BLT_SET_CONTROL
#define INCL_BLT_SPIN
#define INCL_BLT_CC
#define INCL_BLT_TIME_DATE
#define INCL_BLT_MENU
#include <blt.hxx>

#include <uitrace.hxx>
#include <uiassert.hxx>
#include <lmoloc.hxx>
#include <lmoenum.hxx>
#include <lmoeusr.hxx>
#include <lmosrv.hxx>
#include <lmowks.hxx> // WKSTA_10
#include <lmogroup.hxx> // GROUP_1
#include <lmomod.hxx> // USER_MODALS_3
#include <ntuser.hxx> // USER_3
#include <uintsam.hxx>
#include <lmow32.hxx> // GetW32ComputerName

#include <adminapp.hxx>

#include <lmomod.hxx>

#include <dbgstr.hxx>

extern "C"
{
    #include <usrmgrrc.h>

    #include <uimsg.h>
    #include <uirsrc.h>
    #include <umhelpc.h>
    #include <mnet.h>
    #include <lmuidbcs.h>       // NETUI_IsDBCS()
    #include <fpnwname.h>
    #include <dllfunc.h>
}

#include <asel.hxx>

#include <usrmain.hxx>
#include <secset.hxx>
#include <vlw.hxx>
#include <ncp.hxx>
#include <dialin.hxx>
#include <rename.hxx>
#include <userprop.hxx>
#include <alsprop.hxx>
#include <adminper.hxx>
#include <udelperf.hxx>
#ifndef MINI_USER_MANAGER
#include <grpprop.hxx>
#include <setsel.hxx>
#include <trust.hxx>
#endif // MINI_USER_MANAGER

// hydra
#include "ucedit.hxx"
//#include "ctxhlprs.hxx"
#include <utildll.h>
// hydra end


#include <rights.hxx>
#include <auditdlg.hxx>

// Sub-property dialogs used in USERPROP_DLG::OnCommand()
#include <vlw.hxx>
#include <useracct.hxx>
#include <umembdlg.hxx>
#include <logonhrs.hxx>
#include <uprofile.hxx>
#include <umx.hxx>
#include <slowcach.hxx>
#include <slestrip.hxx> // ::TrimLeading() and ::TrimTrailing()
#include <umsplit.hxx>  // USRMGR_SPLITTER_BAR

#include <security.hxx>
#include <ntacutil.hxx>
#include <uintlsax.hxx>
#include <nwuser.hxx>  // USER_NW

#define UMAA_INIKEY_SORT_ORDER SZ("SortOrder")
#define UMAA_INIKEY_LB_SPLIT   SZ("ListboxSplit")
#define UMAA_INIKEY_ALLOWNT5ADMIN   SZ("AllowNT5Admin")

#define MIN_PASS_LEN_DEFAULT    DEF_MIN_PWLEN // also in secset.cxx

// This is the minimum ADMIN_AUTHORITY access to run User Manager
#define UM_ACCESS_BUILTIN_DOMAIN (DOMAIN_LIST_ACCOUNTS | DOMAIN_GET_ALIAS_MEMBERSHIP | DOMAIN_LOOKUP)
#define UM_ACCESS_ACCOUNT_DOMAIN UM_ACCESS_BUILTIN_DOMAIN
#define UM_ACCESS_LSA_POLICY     POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION
#define UM_ACCESS_SAM_SERVER     SAM_SERVER_LOOKUP_DOMAIN

// this is the seperator for Low Speed Connection mode when the user
// enters multiple usernames
#define RASSELECT_SEPARATOR SZ(";")

#ifdef    MINI_USER_MANAGER
const BOOL fMiniUserManager = TRUE;
#else  // MINI_USER_MANAGER
const BOOL fMiniUserManager = FALSE;
#endif // MINI_USER_MANAGER

#ifdef    MINI_USER_MANAGER
#define UM_DEFAULT_USER_SPLIT 500
#else //  MINI_USER_MANAGER
#define UM_DEFAULT_USER_SPLIT 667
#endif // MINI_USER_MANAGER

const TCHAR * pszSpecialGroupUsers  = (const TCHAR *)GROUP_SPECIALGRP_USERS;
const TCHAR * pszSpecialGroupAdmins = (const TCHAR *)GROUP_SPECIALGRP_ADMINS;
const TCHAR * pszSpecialGroupGuests = (const TCHAR *)GROUP_SPECIALGRP_GUESTS;


// hydra
BOOL vfIsCitrixOrDomain; // made global because it wasn't accessible everywhere
                         // it was needed (USER vs. ADMIN).        KLB 07-18-95


// Mapping table for MsgPopups
MSGMAPENTRY amsgmapTable[] =
{
    { ERROR_INVALID_HANDLE, IERR_UM_InvalidHandle },
    { 0, 0 }
};


/*******************************************************************

    NAME:       UM_ADMIN_APP::UM_ADMIN_APP

    SYNOPSIS:   User Manager Admin App class constructor

    ENTRY:      hInstance -         Handle to application instance
                pszCmdLine -        Pointer to command line
                nCmdShow -          Window show value

    NOTES:      The dimensions mentioned for the controls don't really
                matter here, since the controls will be resized and
                re-positioned before the window is displayed, anyway.

    HISTORY:
        kevinl  21-May-1991     Created
        gregj   23-May-1991     Cloned from Server Manager
        jonn    27-Aug-1991     Added OnNewUser()
        jonn    29-Aug-1991     Added OnNewUser( pszCopyFrom )
        rustanl 03-Sep-1991     Inherit from new ADMIN_APP
        rustanl 12-Sep-1991     Restore sort order
        beng    17-Oct-1991     Explicitly init SLT_PLUS
        jonn    21-Apr-1992     Added _umfocustype instance variable
        thomaspa 1-May-1992     _umfocustype -> _umtargetsvrtype
        beng    07-May-1992     No longer display startup dialog;
                                use system about box
        jonn    06-July-1992    Allow non-admins to use User Manager
        beng    03-Aug-1992     App ctor changed

********************************************************************/

UM_ADMIN_APP::UM_ADMIN_APP( HINSTANCE  hInstance,
                            INT     nCmdShow,
                            UINT    idMinR,
                            UINT    idMaxR,
                            UINT    idMinS,
                            UINT    idMaxS )
    :   ADMIN_APP( hInstance,
                   nCmdShow,
#ifdef    MINI_USER_MANAGER
                   IDS_UMAPPNAME,
#else  // MINI_USER_MANAGER
                   IDS_UMAPPNAME_FULL,
#endif // MINI_USER_MANAGER
                   IDS_UMOBJECTNAME,
#ifndef MINI_USER_MANAGER
                   (NETUI_IsDBCS()) ? IDS_UMINISECTIONNAME_DBCS
                                    : IDS_UMINISECTIONNAME_FULL,
#else  // MINI_USER_MANAGER
                   IDS_UMINISECTIONNAME,
#endif // MINI_USER_MANAGER
#ifdef    MINI_USER_MANAGER
                   IDS_UMHELPFILENAME_MINI,
#else  // MINI_USER_MANAGER
                   IDS_UMHELPFILENAME,
#endif // MINI_USER_MANAGER
                   idMinR, idMaxR, idMinS, idMaxS,
#ifdef    MINI_USER_MANAGER
                   ID_MENU_MINI,
                   ID_APPACCEL,
                   IDI_UM_MiniUserManager,
                   FALSE,
                   DEFAULT_ADMINAPP_TIMER_INTERVAL,
                   SEL_SRV_ONLY,
                   TRUE,
                   BROWSE_LM2X_DOMAINS,
                   0,
                   (ULONG)-1L,
                   IDS_UMX_LIST),
#else  // MINI_USER_MANAGER
                   ID_APPMENU,
                   ID_APPACCEL,
                   IDI_UM_FullUserManager,
                   TRUE,
                   DEFAULT_ADMINAPP_TIMER_INTERVAL,
                   SEL_DOM_ONLY,
                   TRUE,
                   BROWSE_LOCAL_DOMAINS,
                   HC_UM_SELECT_DOMAIN,
                   (ULONG) -1L,
                   IDS_UMX_LIST ),
#endif // MINI_USER_MANAGER
        _bmpblock(),
        _lbUsers( this, IDC_LBUSERS,
                  XYPOINT( 0, 0 ), XYDIMENSION( 0, 0 )),
        _colheadUsers( this, IDC_COLHEAD_USERS,
                       XYPOINT( 0, 0 ), XYDIMENSION( 0, 0 ),
                       &_lbUsers ),
        _lbGroups( this, IDC_LBGROUPS,
                   XYPOINT( 0, 0 ), XYDIMENSION( 0, 0 )),
        _colheadGroups( this, IDC_COLHEAD_GROUPS,
                        XYPOINT( 0, 0 ), XYDIMENSION( 0, 0 ),
                        &_lbGroups ),
        _pumSplitter( NULL ),
        _sltHideUsers( this, IDC_HIDEUSERS,
                  XYPOINT( 0, 0 ), XYDIMENSION( 0, 0 ), WS_CHILD | WS_BORDER ),
        _sltHideGroups( this, IDC_HIDEGROUPS,
                  XYPOINT( 0, 0 ), XYDIMENSION( 0, 0 ), WS_CHILD | WS_BORDER ),
        _fontHideSLTs( FONT_DEFAULT ),
        _padminauth( NULL ),
        _menuitemAccountPolicy( this, IDM_POLICY_ACCOUNT ),
        _menuitemUserRights( this, IDM_POLICY_USER_RIGHTS ),
        _menuitemAuditing( this, IDM_POLICY_AUDITING ),
        _pmenuitemLogonSortOrder( NULL ),
        _pmenuitemFullNameSortOrder( NULL ),
        _pmenuitemAllUsers( NULL ),
        _pmenuitemNetWareUsers( NULL ),
        _ulViewAcctType( UM_VIEW_ALL_USERS ),
        _dyMargin( 1 ),
        _dyColHead( _colheadUsers.QueryHeight()),
        _dySplitter( 0 ), // calculated later
        _dyFixed( 0 ),    // calculated later
        _fCanCreateUsers( FALSE ),
        _fCanCreateLocalGroups( FALSE ),
        _fCanCreateGlobalGroups( FALSE ),
        _fCanChangeAccountPolicy( FALSE ),
        _fCanChangeUserRights( FALSE ),
        _fCanChangeAuditing( FALSE ),
        _fCanChangeTrustedDomains( FALSE ),
        _nlsUMExtAccountName(),
        _nlsUMExtFullName(),
        _nlsUMExtComment(),
        _nUserLBSplitIn1000ths( UM_DEFAULT_USER_SPLIT ),
        _fIsNetWareInstalled( FALSE ),
        _fAllowNT5Admin( FALSE )
{

#if defined(DEBUG) && defined(TRACE)
    DWORD start = ::GetTickCount();
#endif

    POPUP::SetMsgMapTable( amsgmapTable );

    _pctrlFocus = &_lbUsers;

    if ( QueryError() != NERR_Success )
    {
        DBGEOL( "UM_ADMIN_APP::UM_ADMIN_APP - Construction failed" ) ;
        return ;
    }

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if ( (_pumSplitter = new USRMGR_SPLITTER_BAR( this, IDC_UM_SPLITTER, this )) == NULL ||
         ( err = _pumSplitter->QueryError()) != NERR_Success ||
         ( err = _menuitemAccountPolicy.QueryError()) != NERR_Success ||
         ( err = _menuitemUserRights.QueryError()) != NERR_Success ||
         ( err = _menuitemAuditing.QueryError()) != NERR_Success
       )
    {
        DBGEOL(    "User Manager: UM_ADMIN_APP::ctor() failure " << err
                << "in splitter / menuitem checks" );
        ReportError( err );
        return;
    }

    _dySplitter = _pumSplitter->QueryDesiredHeight();
    _dyFixed = 2 * _dyMargin + 2 * _dyColHead + _dySplitter;

#ifndef MINI_USER_MANAGER

    err = ERROR_NOT_ENOUGH_MEMORY;
    if ( (_pmenuitemLogonSortOrder = new MENUITEM( this, IDM_VIEW_LOGONNAME_SORT )) == NULL ||
         (_pmenuitemFullNameSortOrder = new MENUITEM( this, IDM_VIEW_FULLNAME_SORT )) == NULL ||
         ( err = _pmenuitemLogonSortOrder->QueryError()) != NERR_Success ||
         ( err = _pmenuitemFullNameSortOrder->QueryError()) != NERR_Success ||
         ( err = _bmpblock.QueryError()) != NERR_Success
       )
    {
        DBGEOL(    "User Manager: UM_ADMIN_APP::ctor() failure " << err
                << "in second splitter/menuitem/bitmap checks" );
        ReportError( err );
        return;
    }

    {
        // load Slow Network Mode strings
        RESOURCE_STR resstrHideUsers( IDS_HIDE_USERS );
        RESOURCE_STR resstrHideGroups( IDS_HIDE_GROUPS );
        if (   (err = resstrHideUsers.QueryError()) != NERR_Success
            || (err = resstrHideGroups.QueryError()) != NERR_Success
            || (err = _fontHideSLTs.QueryError()) != NERR_Success
           )
        {
            DBGEOL(    "User Manager: UM_ADMIN_APP::ctor() failure " << err
                    << "in resstr or font loads" );
            ReportError( err );
            return;
        }
        _sltHideUsers.SetFont( _fontHideSLTs );
        _sltHideGroups.SetFont( _fontHideSLTs );
        _sltHideUsers.SetText( resstrHideUsers );
        _sltHideGroups.SetText( resstrHideGroups );
    }

#endif // MINI_USER_MANAGER

    if ( (err = BLT::RegisterHelpFile( hInstance,
#ifdef MINI_USER_MANAGER
                                 IDS_UMHELPFILENAME_MINI,
#else // MINI_USER_MANAGER
                                 IDS_UMHELPFILENAME,
#endif // MINI_USER_MANAGER
                                 HC_UI_USRMGR_BASE,
                                 HC_UI_USRMGR_LAST ) ) != NERR_Success )
    {
        DBGEOL(    "User Manager: UM_ADMIN_APP::ctor() failure " << err
                << "registering help file" );
        ReportError( err );
        return;
    }

    //  Read the ini file settings to determine the relative listbox sizes
    INT nValue;
    if (   Read( UMAA_INIKEY_LB_SPLIT, &nValue, UM_DEFAULT_USER_SPLIT )
                != NERR_Success
        || nValue < 0
        || nValue > 1000
       )
    {
        DBGEOL( "UM_ADMIN_APP::ctor(); lb split ini read failed" );
        nValue = UM_DEFAULT_USER_SPLIT;
    }
    _nUserLBSplitIn1000ths = nValue;

#ifndef MINI_USER_MANAGER
    //  Read the ini file settings to determine which sort order to use
    if ( Read( UMAA_INIKEY_SORT_ORDER, &nValue, 1 ) != NERR_Success )
        nValue = 1;
    enum USER_LISTBOX_SORTORDER ulbso;
    if ( nValue == 0 )
        ulbso = ULB_SO_FULLNAME;
    else
        ulbso = ULB_SO_LOGONNAME;
    //  There shouldn't be any items to sort at this point; thus, the second
    //  parameter to SetSortOrder is passed as FALSE.  This actually guarantees
    //  that SetSortOrder will succeed, but we check just in case.
    UIASSERT( _lbUsers.QueryCount() == 0 );
    SetSortOrderCheckmarks( ulbso );
    err = _lbUsers.SetSortOrder( ulbso, FALSE );
    if ( err != NERR_Success )
    {
        DBGEOL(    "User Manager: UM_ADMIN_APP::ctor() failure " << err
                << "in SetSortOrder()" );
        ReportError( err );
        return;
    }


    //  Read the ini file settings to determine whether to allow focus on an
    //  NT 5 domain.
    INT nAllowNT5Focus;
    if (   Read( UMAA_INIKEY_ALLOWNT5ADMIN, &nAllowNT5Focus, 0 )
                != NERR_Success
       )
    {
        nAllowNT5Focus = 0;
    }
    if (nAllowNT5Focus == 1)
        _fAllowNT5Admin = TRUE;

#endif // MINI_USER_MANAGER

    //
    //  We need to load the extensions *before* we set the view,
    //  since one of the loaded extensions may be the active view.
    //

    LoadExtensions();


    _colheadUsers.Show();
    _colheadGroups.Show();

    //  Resize the listboxes before refreshing them.  If done afterwards,
    //  scroll bars may not be used properly.

    SizeListboxes();

    _lbUsers.ClaimFocus();


#if defined(DEBUG) && defined(TRACE)
    DWORD finish = ::GetTickCount();
    TRACEEOL( "User Manager: UM_ADMIN_APP::ctor() took " << finish-start << " ms" );
#endif

}


/*******************************************************************

    NAME:       UM_ADMIN_APP::~UM_ADMIN_APP

    SYNOPSIS:   UM_ADMIN_APP destructor

    HISTORY:
        rustanl     03-Sep-1991     Created
        rustanl     12-Sep-1991     Save sort order

********************************************************************/

UM_ADMIN_APP::~UM_ADMIN_APP()
{
    if ( IsSavingSettingsOnExit())
    {
        //  Save relative listbox size

        if ( Write( UMAA_INIKEY_LB_SPLIT, _nUserLBSplitIn1000ths )
                != NERR_Success )
        {
            //  nothing else we could do
            DBGEOL( "UM_ADMIN_APP dt:  Writing listbox split failed" );
        }

#ifndef MINI_USER_MANAGER
        //  Save Sort Order

        BOOL fSortByFullname = ( _pmenuitemFullNameSortOrder->IsChecked());
        if ( Write( UMAA_INIKEY_SORT_ORDER, ( fSortByFullname ? 0 : 1 ))
             != NERR_Success )
        {
            //  nothing else we could do
            DBGEOL( "UM_ADMIN_APP dt:  Writing sort order failed" );
        }
#endif // MINI_USER_MANAGER

    }

    delete _pmenuitemLogonSortOrder;
    _pmenuitemLogonSortOrder = NULL;
    delete _pmenuitemFullNameSortOrder;
    _pmenuitemFullNameSortOrder = NULL;

    if ( _pmenuitemAllUsers )
    {
        delete _pmenuitemAllUsers;
        _pmenuitemAllUsers = NULL;
    }

    if ( _pmenuitemNetWareUsers )
    {
        delete _pmenuitemNetWareUsers;
        _pmenuitemNetWareUsers = NULL;
    }

    delete _padminauth;
    _padminauth = NULL;
    delete _pumSplitter;
    _pumSplitter = NULL;

}  // UM_ADMIN_APP::~UM_ADMIN_APP


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnStartUpSetFocusFailed

    SYNOPSIS:   If running Mini User Manager, prevents the Set Focus
                dialog from appearing on initial focus error

    ENTRY:      APIERR err - the error that occurred when trying to set
                             focus on startup

    RETURNS:

    NOTES:      virtual method

    HISTORY:
        thomaspa    15-May-1992 Created

********************************************************************/

INT UM_ADMIN_APP::OnStartUpSetFocusFailed( APIERR err )
{

#ifndef MINI_USER_MANAGER
    return ADMIN_APP::OnStartUpSetFocusFailed( err );
#else

    ::MsgPopup( this, err );
    return IERR_USERQUIT;

#endif // MINI_USER_MANAGER

}


/*******************************************************************

    NAME:       UM_ADMIN_APP :: LoadMenuExtension

    SYNOPSIS:   Loads a menu extension by name.

    ENTRY:      pszExtensionDll         - Name of the DLL containing
                                          the menu extension.

                dwDelta                 - Menu ID delta for the extension.

    RETURNS:    AAPP_MENU_EXT *         - New extension object.

    HISTORY:
        JonN        19-Nov-1992     Created (templated from srvmain.cxx)

********************************************************************/
AAPP_MENU_EXT * UM_ADMIN_APP::LoadMenuExtension( const TCHAR * pszExtensionDll,
                                                 DWORD         dwDelta )
{
    //
    //  Create the extension object.
    //

    UM_MENU_EXT * pExt = new UM_MENU_EXT( this,
                                          pszExtensionDll,
                                          dwDelta,
                                          QueryHwnd() );

    APIERR err = ( pExt == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                  : pExt->QueryError();

    if( err == NERR_Success )
    {
        //
        //  Update the menus.
        //

        err = AddExtensionMenuItem( pExt->QueryMenuName(),
                                    pExt->QueryMenuHandle(),
                                    dwDelta );
    }

    if( err != NERR_Success )
    {
        //
        //  Something failed, cleanup.
        //

        delete pExt;
        pExt = NULL;

        DBGEOL( "UM_ADMIN_APP::LoadMenuExtension - error " << err );
    }

    return (AAPP_MENU_EXT *)pExt;

}   // UM_ADMIN_APP :: LoadMenuExtension


/*******************************************************************

    NAME:       UM_ADMIN_APP::LoadMenuExtensionMgr

    SYNOPSIS:   Tries to load the User Manager menu extension manager

    RETURNS:    UI_MENU_EXT_MGR *  -  A pointer to the newly loaded
                                      extension manager.  The caller is
                                      expected to handle NULL returns or
                                      returns of objects in error state.
                                      The caller is also expected to free
                                      the object, the destructor is virtual.

    HISTORY:
        JonN         23-Nov-1992     Created.

********************************************************************/
UI_MENU_EXT_MGR * UM_ADMIN_APP::LoadMenuExtensionMgr( VOID )
{
    return new USRMGR_MENU_EXT_MGR( QueryExtMgrIf(),
                                    IDM_AAPPX_BASE,
                                    IDM_AAPPX_DELTA );
}


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnResize

    SYNOPSIS:   Called when User Tool main window is to be resized

    ENTRY:      se -        SIZE_EVENT

    EXIT:       Controls inside main window have been adjusted accordingly

    HISTORY:

********************************************************************/

BOOL UM_ADMIN_APP::OnResize( const SIZE_EVENT & se )
{
    //  Don't resize the listboxes if this is a minimize event, since in
    //  this case the width and height are invalid.  JonN 10/23/95
    if ( !se.IsMinimized() )
    {
        SizeListboxes( XYDIMENSION( se.QueryWidth(), se.QueryHeight() ) );

        //  Since the column headers draw different things depending on
        //  the right margin, invalidate the controls so they get
        //  completely repainted.
        _colheadUsers.Invalidate();
        _colheadGroups.Invalidate();
    }

    return ADMIN_APP::OnResize( se );
}


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnQMinMax

    SYNOPSIS:   Called when windows manager needs to query the mix/max
                size of the window

    ENTRY:      qmme -      QMINMAX_EVENT

    EXIT:       Appropriate min/max info has been set via the
                QMINMAX_EVENT object

    RETURNS:    TRUE if message was handled; FALSE otherwise

    HISTORY:
        rustanl     22-Jul-1991     Created

********************************************************************/

BOOL UM_ADMIN_APP::OnQMinMax( QMINMAX_EVENT & qmme )
{
    //  CODEWORK.  This doesn't seem to work!

    qmme.SetMinTrackHeight( _dyFixed );

    return TRUE;

}  // UM_ADMIN_APP::OnQMinMax


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnUserMessage

    SYNOPSIS:   Invoked for messages >= WM_USER+100.  We use this to
                see if an extension is trying to communicate.

    HISTORY:
        JonN        19-Nov-1992     Created (templated from srvmain.cxx)

********************************************************************/
BOOL UM_ADMIN_APP::OnUserMessage( const EVENT &event )
{
    //
    //  Let ADMIN_APP have a crack at it.
    //

    if( ADMIN_APP::OnUserMessage( event ) )
    {
        return TRUE;
    }

    //
    //  Let's see if an extension is trying to communicate...
    //

    switch( event.QueryMessage() )
    {
    case UM_GETUSERSELW :
        {
#ifndef UNICODE
            return FALSE;
#else
            PUMS_GETSEL psel = (PUMS_GETSEL)event.QueryLParam();
            INT iRequestedSelItem = (INT)event.QueryWParam();

            INT cSelItems = _lbUsers.QuerySelCount();
            BUFFER bufSelItems( sizeof(INT) * cSelItems );
            INT * aiSelItems;

            if (   ( psel == NULL )
                || ( bufSelItems.QueryError() != NERR_Success )
                || ( (aiSelItems = (INT *)bufSelItems.QueryPtr()) == NULL )
                || ( iRequestedSelItem < 0 )
                || ( iRequestedSelItem >= cSelItems )
                || ( _lbUsers.QuerySelItems( aiSelItems, cSelItems ) != NERR_Success )
               )
            {
                return FALSE;
            }

            USER_LBI * pulbi = (USER_LBI *) _lbUsers.QueryItem( aiSelItems[iRequestedSelItem] );
            if (   pulbi == NULL
                || (_nlsUMExtAccountName.CopyFrom( pulbi->QueryAccountPtr(),
                                                   pulbi->QueryAccountCb() ))
                                   != NERR_Success
                || (_nlsUMExtFullName.CopyFrom(    pulbi->QueryFullNamePtr(),
                                                   pulbi->QueryFullNameCb() ))
                                   != NERR_Success
                || (_nlsUMExtComment.CopyFrom(     pulbi->QueryCommentPtr(),
                                                   pulbi->QueryCommentCb() ))
                                   != NERR_Success
               )
                return FALSE;

            psel->dwRID =     pulbi->QueryRID();
            psel->pchName =   (LPWSTR)(_nlsUMExtAccountName.QueryPch());

            DWORD dwType;
            switch (pulbi->QueryIndex())
            {
            case MAINUSRLB_NORMAL:
                dwType = UM_SELTYPE_NORMALUSER;
                break;
            case MAINUSRLB_REMOTE:
                dwType = UM_SELTYPE_REMOTEUSER;
                break;
            default:
                UIASSERT( FALSE );
                dwType = 0L;
                break;
            }
            psel->dwSelType = dwType;

            psel->pchFullName = (LPWSTR)(_nlsUMExtFullName.QueryPch());
            psel->pchComment  = (LPWSTR)(_nlsUMExtComment.QueryPch());

            return TRUE;
        }
        break;
#endif

    case UM_GETGROUPSELW :
        {
#ifndef UNICODE
            return FALSE;
#else
            PUMS_GETSEL psel = (PUMS_GETSEL)event.QueryLParam();
            INT iRequestedSelItem = (INT)event.QueryWParam();

            INT cSelItems = _lbGroups.QuerySelCount();
            BUFFER bufSelItems( sizeof(INT) * cSelItems );
            INT * aiSelItems;

            if (   ( psel == NULL )
                || ( bufSelItems.QueryError() != NERR_Success )
                || ( (aiSelItems = (INT *)bufSelItems.QueryPtr()) == NULL )
                || ( iRequestedSelItem < 0 )
                || ( iRequestedSelItem >= cSelItems )
                || ( _lbGroups.QuerySelItems( aiSelItems, cSelItems ) != NERR_Success )
               )
            {
                return FALSE;
            }

            GROUP_LBI * pglbi = (GROUP_LBI *) _lbGroups.QueryItem( aiSelItems[iRequestedSelItem] );
            if ( pglbi == NULL )
                return FALSE;

            psel->pchName     = (LPWSTR)(pglbi->QueryName());
            psel->pchFullName = NULL;
            psel->pchComment  = (LPWSTR)(pglbi->QueryComment());

            if (pglbi->IsAliasLBI())
            {
                ALIAS_LBI * palbi = (ALIAS_LBI *) pglbi;

                psel->dwRID       = 0; // we don't return palbi->QueryRID();
                psel->dwSelType   = UM_SELTYPE_LOCALGROUP;
            }
            else
            {
                psel->dwRID       = 0L; // we don't know this
                psel->dwSelType   = UM_SELTYPE_GLOBALGROUP;
            }
            return TRUE;
        }
        break;
#endif

    case UM_GETSELCOUNT :
        {
            LISTBOX * plb = NULL;

            switch ( event.QueryWParam() )
            {
            case UMS_LISTBOX_USERS:
                plb = &_lbUsers;
                break;

            case UMS_LISTBOX_GROUPS:
                plb = &_lbGroups;
                break;

            default:
                break;
            }

            PUMS_GETSELCOUNT pselcount = (PUMS_GETSELCOUNT)event.QueryLParam();

            if ( ( plb == NULL ) || ( pselcount == NULL ) )
            {
                return FALSE;
            }

            pselcount->dwItems = (DWORD)plb->QuerySelCount();

            return TRUE;
        }

    case UM_GETCURFOCUSW :
    case UM_GETCURFOCUS2W :
        {
            PUMS_GETCURFOCUS pumsfocus = (PUMS_GETCURFOCUS)event.QueryLParam();
            PUMS_GETCURFOCUS2 pumsfocus2 = (PUMS_GETCURFOCUS2)pumsfocus;
            BOOL fVersion2 = (event.QueryMessage() == UM_GETCURFOCUS2);

            if ( pumsfocus == NULL || event.QueryWParam() != 0 )
            {
                return FALSE;
            }
            if (fVersion2)
            {
                pumsfocus2->dwFocusType   = 0;
                pumsfocus2->szFocus[0]    = TCH('\0');
                pumsfocus2->szFocusPDC[0] = TCH('\0');
                pumsfocus2->psidFocus     = NULL;
            } else {
                pumsfocus->dwFocusType   = 0;
                pumsfocus->szFocus[0]    = TCH('\0');
                pumsfocus->szFocusPDC[0] = TCH('\0');
                pumsfocus->psidFocus     = NULL;
            }

            // templated from SetAdminCaption

            const TCHAR  * pszFocus = NULL;
            RESOURCE_STR   nlsLocal( IDS_LOCAL_MACHINE );
            const LOCATION     & loc = QueryLocation();

            if( !nlsLocal )
            {
                return FALSE;
            }

            if( loc.IsServer() )
            {
                pszFocus       = loc.QueryServer();

                if( pszFocus == NULL  )
                {
                    pszFocus = nlsLocal.QueryPch();
                }
            }
            else
            {
                //
                //  A LOCATION object should either be a server or a domain.
                //
                UIASSERT( loc.IsDomain());

                pszFocus = loc.QueryDomain();
            }

            ASSERT( pszFocus != NULL );
            ALIAS_STR nlsFocus( pszFocus );

            APIERR err = NERR_Success;
            if (fVersion2) {
                err = nlsFocus.MapCopyTo( pumsfocus2->szFocus,
                                          sizeof(pumsfocus2->szFocus) );
            } else {
                err = nlsFocus.MapCopyTo( pumsfocus->szFocus,
                                          sizeof(pumsfocus->szFocus) );
            }
            if (err != NERR_Success)
            {
                DBGEOL( "USRMGR: GETCURFOCUS: MapCopyTo error " << err );
                return FALSE;
            }

            DWORD dwFocusType = UM_FOCUS_TYPE_UNKNOWN;
            switch ( QueryTargetServerType() )
            {
            case UM_LANMANNT:
                dwFocusType = UM_FOCUS_TYPE_DOMAIN;

                {
                    ALIAS_STR nlsPDC( loc.QueryServer() );
                    if (fVersion2) {
                        pumsfocus2->psidFocus =
                            QueryAdminAuthority()->QueryAccountDomain()->QueryPSID();

                        err = nlsPDC.MapCopyTo( pumsfocus2->szFocusPDC,
                                                sizeof(pumsfocus2->szFocusPDC) );
                    } else {
                        pumsfocus->psidFocus =
                            QueryAdminAuthority()->QueryAccountDomain()->QueryPSID();

                        err = nlsPDC.MapCopyTo( pumsfocus->szFocusPDC,
                                                sizeof(pumsfocus->szFocusPDC) );
                    }
                }
                if (err != NERR_Success)
                {
                    DBGEOL( "USRMGR: GETCURFOCUS: PDC MapCopyTo error " << err );
                    return FALSE;
                }

                break;

            case UM_WINDOWSNT:
                dwFocusType = UM_FOCUS_TYPE_WINNT;
                break;

            case UM_DOWNLEVEL:
                dwFocusType = UM_FOCUS_TYPE_LM;
                break;

            default:
                ASSERT( FALSE );
                break;
            }
            if (fVersion2) {
                pumsfocus2->dwFocusType = dwFocusType;
            } else {
                pumsfocus->dwFocusType = dwFocusType;
            }

            return TRUE;
        }
        break;

    case UM_GETOPTIONS :
    case UM_GETOPTIONS2 :
        {
            PUMS_GETOPTIONS2 poptions = (PUMS_GETOPTIONS2)event.QueryLParam();

            if ( poptions == NULL )
            {
                return FALSE;
            }

            poptions->fSaveSettingsOnExit = IsSavingSettingsOnExit();
            poptions->fConfirmation = IsConfirmationOn();
            poptions->fSortByFullName = (fMiniUserManager)
                        ? FALSE
                        : _pmenuitemFullNameSortOrder->IsChecked();
            if ( event.QueryMessage() == UM_GETOPTIONS2 )
            {
                poptions->fMiniUserManager = fMiniUserManager;
                poptions->fLowSpeedConnection = InRasMode();
            }

            return TRUE;
        }
        break;

    }

    return FALSE;
}

// hydra
/*******************************************************************

    NAME:       UM_ADMIN_APP::OnCloseReq

    SYNOPSIS:   When app close is requested, popup the anonymous
                reminder if necessary.

    HISTORY:
        ButchD  11-Mar-1997     Created

********************************************************************/

BOOL UM_ADMIN_APP::OnCloseReq()
{
    // Remind to reboot for Anonymous user changes if necessary
//    if ( ctxHaveAnonymousUsersChanged() )
    if ( HaveAnonymousUsersChanged() )
        ::MsgPopup( this, IDS_ReminderForAnonymousReboot, MPSEV_WARNING );

    return( ADMIN_APP::OnCloseReq() );
}
// hydra end

/*******************************************************************

    NAME:       UM_ADMIN_APP::SizeListboxes

    SYNOPSIS:   Resizes the main window listboxes and column headers

    ENTRY:      xydimWindow - dimensions of the main window client area

    EXIT:       Listboxes and column headers are resized appropriately

    NOTES:      This method is *not* trying to be overly efficient.  It
                is written so as to maximize readability and
                understandability.  The method is not called very often,
                and when it is, the time needed to redraw the main window
                and its components exceeds the computations herein by far.

    HISTORY:
        gregj       24-May-1991     Created
        rustanl     22-Jul-1991     Added column header logic
        jonn        15-Jun-1992     For MUM, listboxes are same size
        jonn        13-Oct-1992     set size/pos of listbox before colhead
                                    (should fix 1442 according to KeithMo)

********************************************************************/

//  A macro specialized for the SizeListboxes method
#define SET_CONTROL_SIZE_AND_POS( ctrl, dyCtrl )        \
            ctrl.SetPos( XYPOINT( dxMargin, yCurrent ));       \
            ctrl.Invalidate(); \
            ctrl.SetSize( dx, dyCtrl );       \
            ctrl.Enable( TRUE ); \
            ctrl.Show( TRUE ); \
            yCurrent += dyCtrl;
#define HIDE_CONTROL( ctrl ) \
            ctrl.Show( FALSE ); \
            ctrl.Enable( FALSE ); \
            ctrl.SetPos( XYPOINT( 0, 0 ) ); \
            ctrl.SetSize( 0, 0 );

void UM_ADMIN_APP::SizeListboxes( XYDIMENSION dxyWindow )
{
    UINT dxMainWindow = dxyWindow.QueryWidth();
    UINT dyMainWindow = dxyWindow.QueryHeight();

    //  The left and right margins are each dxMargin.  The width of
    //  each control is thus the width of the main window client area
    //  less twice dxMargin.
    //  The width thus looks like:
    //      Left Margin         Control         Right Margin
    //       (dxMargin)          (dx)            (dxMargin)

    const UINT dxMargin = 1;                // width of left/right margins
    UINT dx = dxMainWindow - 2 * dxMargin;

    //  Height looks like:
    //      Top margin                  _dyMargin
    //      User Column Header          _dyColHead
    //      User Listbox                2/3 of variable area (1/2 for MUM)
    //      Horizontal Splitter         _dySplitter
    //      Group Column Header         _dyColHead
    //      Group Listbox               1/3 of variable area (1/2 for MUM)
    //      Bottom margin               _dyMargin


    //  Group listbox uses 1/3 of variable area.  User listbox uses the rest.
    //  For MUM, listboxes are same size
    UINT dyUserListbox = dyMainWindow - _dyFixed;
    dyUserListbox = (dyUserListbox * _nUserLBSplitIn1000ths) / 1000;
    UINT dyGroupListbox = dyMainWindow - _dyFixed - dyUserListbox;

    //  Set all the sizes and positions.

    UINT yCurrent = _dyMargin;

    SET_CONTROL_SIZE_AND_POS( _colheadUsers, _dyColHead );
    if ( InRasMode() )
    {
        SET_CONTROL_SIZE_AND_POS( _sltHideUsers, dyUserListbox );
        HIDE_CONTROL( _lbUsers );
    }
    else
    {
        SET_CONTROL_SIZE_AND_POS( _lbUsers, dyUserListbox );
        HIDE_CONTROL( _sltHideUsers );
    }

    SET_CONTROL_SIZE_AND_POS( (*_pumSplitter), _dySplitter );

    SET_CONTROL_SIZE_AND_POS( _colheadGroups, _dyColHead );
    if ( InRasMode() )
    {
        SET_CONTROL_SIZE_AND_POS( _sltHideGroups, dyGroupListbox );
        HIDE_CONTROL( _lbGroups );
    }
    else
    {
        SET_CONTROL_SIZE_AND_POS( _lbGroups, dyGroupListbox );
        HIDE_CONTROL( _sltHideGroups );
    }
}

void UM_ADMIN_APP::SizeListboxes( void )
{
    RECT rect;
    QueryClientRect( &rect );
    SizeListboxes( XYDIMENSION( rect.right, rect.bottom ) );
}


/*******************************************************************

    NAME:       UM_ADMIN_APP::ChangeUserSplit

    SYNOPSIS:   The splitter bar was moved

    HISTORY:
        jonn        11-Oct-1993     Created

********************************************************************/

VOID UM_ADMIN_APP::ChangeUserSplit( INT yMainWindowCoords )
{
    TRACEEOL( "UM_ADMIN_APP::ChangeUserSplit( "
             << yMainWindowCoords
             << " )" );

    yMainWindowCoords -= (_dyFixed / 2);
    XYRECT xyrectClient( QueryHwnd() );
    INT dyClientHeight = xyrectClient.CalcHeight();
    dyClientHeight -= _dyFixed;

    if (   dyClientHeight > 0
        && yMainWindowCoords > 0
        && yMainWindowCoords < dyClientHeight
       )
    {
        _nUserLBSplitIn1000ths = (yMainWindowCoords * 1000) / dyClientHeight;

        TRACEEOL(   "UM_ADMIN_APP::ChangeUserSplit: _nUserLBSplitIn1000ths = "
                 << _nUserLBSplitIn1000ths );

        SizeListboxes();
        _colheadUsers.Invalidate();
        _colheadGroups.Invalidate();
    }
    else
    {
        TRACEEOL( "UM_ADMIN_APP::ChangeUserSplit: invalid split" );
    }
}


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnMenuInit

    SYNOPSIS:   Enables or disables menu items according to which
                menu items can be selected at this time.  This method
                is called when a menu is about to be accessed.

    ENTRY:      me -        Menu event

    EXIT:       Menu items have been enabled/disabled according to
                available functionality, which is determined by
                examining the selection of the listboxes.

    RETURNS:    TRUE if message was handled; FALSE otherwise

    HISTORY:
        rustanl     05-Sep-1991     Created
        jonn        06-July-1992    Allow non-admins to use User Manager

********************************************************************/

BOOL UM_ADMIN_APP::OnMenuInit( const MENU_EVENT & me )
{
    //  Call parent class, but ignore return code, since we know for
    //  sure that this method will handle the message
    ADMIN_APP::OnMenuInit( me );

    UpdateMenuEnabling();

    //
    //  Notify the extensions.
    //

    MenuInitExtensions();

    return TRUE;
}


/*******************************************************************

    NAME:       UM_ADMIN_APP::UpdateMenuEnabling

    SYNOPSIS:   Enables or disables menu items according to which
                menu items can be selected at this time.

    HISTORY:
        jonn        23-Feb-1993     Created

********************************************************************/

VOID UM_ADMIN_APP::UpdateMenuEnabling( void )
{

    APIERR err = NERR_Success;
    UINT clbiUsers = _lbUsers.QuerySelCount();
    UINT clbiGroups = _lbGroups.QuerySelCount();

    if ( InRasMode() )
    {
        // Since we don't actually have a selection in RAS mode, we
        // consider both users and groups to be selected
        clbiUsers = clbiGroups = 1;
    }

    BOOL fCanCopy = FALSE;
    if (clbiUsers == 1)
    {
        fCanCopy = _fCanCreateUsers;
    }
    else if (clbiGroups == 1)
    {
#ifndef MINI_USER_MANAGER
        ADMIN_SELECTION sel( _lbGroups );

        if ( sel.QueryError() != NERR_Success )
        {
            fCanCopy = FALSE;
        }
        else
        {
            UIASSERT( sel.QueryCount() == 1 );

            // Assumes only one item can be selected

            if ( ((GROUP_LBI *)(sel.QueryItem(0)))->IsAliasLBI() )
            {
                fCanCopy = _fCanCreateLocalGroups;
            }
            else
            {
                fCanCopy = _fCanCreateGlobalGroups;
            }
        }
#else  // MINI_USER_MANAGER
        fCanCopy = _fCanCreateLocalGroups;
#endif // MINI_USER_MANAGER
    }
    else
    {
        fCanCopy = FALSE;
    }

    {
        MENUITEM menuitemCopy( this, IDM_COPY );
        MENUITEM menuitemDelete( this, IDM_DELETE );
        MENUITEM menuitemProperties( this, IDM_PROPERTIES );
        MENUITEM menuitemNewUser( this, IDM_NEWOBJECT );
        MENUITEM menuitemNewAlias( this, IDM_USER_NEWALIAS );
#ifndef MINI_USER_MANAGER
        MENUITEM menuitemNewGroup( this, IDM_USER_NEWGROUP );
        MENUITEM menuitemSelectUsers( this, IDM_USER_SET_SELECTION );
        // CODEWORK should we allow refresh?  The user's access might
        // still change; old handles remain open, but NetUser/NetGroup
        // calls will be affected by interim access changes.
        MENUITEM menuitemRefresh( this, IDM_REFRESH );
#endif // MINI_USER_MANAGER
        if (   (err = menuitemCopy.QueryError()) != NERR_Success
            || (err = menuitemDelete.QueryError()) != NERR_Success
            || (err = menuitemProperties.QueryError()) != NERR_Success
            || (err = menuitemNewUser.QueryError()) != NERR_Success
            || (err = menuitemNewAlias.QueryError()) != NERR_Success
#ifndef MINI_USER_MANAGER
            || (err = menuitemNewGroup.QueryError()) != NERR_Success
            || (err = menuitemSelectUsers.QueryError()) != NERR_Success
            || (err = menuitemRefresh.QueryError()) != NERR_Success
#endif // MINI_USER_MANAGER
           )
        {
            DBGEOL( "User Manager: OnMenuInit(): error " << err <<
                    " allocating non-RAS menu items" );
        }
        else
        {
            menuitemCopy.Enable( fCanCopy );
            menuitemDelete.Enable( clbiUsers > 0 || clbiGroups > 0 );
            menuitemProperties.Enable( clbiUsers > 0 || clbiGroups == 1 );
            menuitemNewUser.Enable( _fCanCreateUsers );
            menuitemNewAlias.Enable( _fCanCreateLocalGroups );
#ifndef MINI_USER_MANAGER
            menuitemNewGroup.Enable(    DoShowGroups()
                                    && _fCanCreateGlobalGroups
                                    && !InRasMode() );
            menuitemSelectUsers.Enable( !InRasMode() );
            ASSERT(   _pmenuitemLogonSortOrder != NULL
                   && _pmenuitemFullNameSortOrder != NULL  );

            _pmenuitemLogonSortOrder->Enable( !InRasMode() );
            _pmenuitemFullNameSortOrder->Enable( !InRasMode() );

            if ( _pmenuitemAllUsers )
                _pmenuitemAllUsers->Enable( !InRasMode() && QueryTargetServerType() != UM_DOWNLEVEL );
            if ( _pmenuitemNetWareUsers )
                _pmenuitemNetWareUsers->Enable( !InRasMode() && QueryTargetServerType() != UM_DOWNLEVEL );
            menuitemRefresh.Enable( !InRasMode() );
#endif // MINI_USER_MANAGER
        }
    }

    _menuitemAccountPolicy.Enable( _fCanChangeAccountPolicy );
    _menuitemUserRights.Enable( _fCanChangeUserRights );
    _menuitemAuditing.Enable( _fCanChangeAuditing );

    MENUITEM menuitemRename( this, IDM_USER_RENAME );
#ifndef MINI_USER_MANAGER
    MENUITEM menuitemTrust( this, IDM_POLICY_TRUST );
#endif // MINI_USER_MANAGER
    if (   (err = menuitemRename.QueryError()) != NERR_Success
#ifndef MINI_USER_MANAGER
        || (err = menuitemTrust.QueryError()) != NERR_Success
#endif // MINI_USER_MANAGER
       )
    {
        DBGEOL( "User Manager: OnMenuInit(): error " << err <<
                " allocating Trust+Rename menu items" );
    }
    else
    {
        menuitemRename.Enable( QueryTargetServerType() != UM_DOWNLEVEL
                                   && (clbiUsers == 1 || InRasMode()) );
#ifndef MINI_USER_MANAGER
        menuitemTrust.Enable(    ADMIN_APP::QueryFocusType() == FOCUS_DOMAIN
                              && QueryTargetServerType() == UM_LANMANNT
                              && _fCanChangeTrustedDomains );
#endif // MINI_USER_MANAGER
    }

}  // UM_ADMIN_APP::UpdateMenuEnabling


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnMenuCommand

    SYNOPSIS:   Menu messages come here

    EXIT:       Returns TRUE if message was handled

    NOTES:      Make sure ADMIN_APP::OnMenuCommand is called for
                any messages not handled here.

    HISTORY:
        kevinl  21-May-1991     Created
        gregj   24-May-1991     Cloned from Server Manager
        jonn    29-Aug-1991     added IDM_COPY functionality
        jonn    11-Oct-1991     Enabled New/Copy for groups
        jonn    11-Oct-1991     Added OnNewGroup( pszCopyFrom )
        thomaspa29-Jan-1992     Added Rename
        jonn    20-Feb-1992     Moved OnNewGroupMenuSel from ADMINAPP
        KeithMo 08-Apr-1992     Added Trusted Domain List manipulation.
        jonn    02-Jun-1992     Refresh when user renamed
        jonn    01-Mar-1993     RAS menu extensions

********************************************************************/

BOOL UM_ADMIN_APP::OnMenuCommand( MID midMenuItem )
{
    switch ( midMenuItem )
    {

#ifndef   MINI_USER_MANAGER
    case IDM_USER_NEWGROUP:
       OnNewGroupMenuSel();
       break;
#endif // MINI_USER_MANAGER

    case IDM_USER_NEWALIAS:
       OnNewAliasMenuSel();
       break;

    case IDM_POLICY_ACCOUNT:
        LockRefresh(); // now don't return before UnlockRefresh()!
        {
            SECSET_DIALOG * psecsetdlg = NULL;

            /*
             *  We must determine whether we can call USER_MODALS at level 3.
             *  If this is supported, we use SECSET_DIALOG_LOCKOUT,
             *  otherwise just SECSET_DIALOG.  We pass the USER_MODALS_3
             *  down to the dialog in order to avoid repeating the GetInfo.
             */
            USER_MODALS_3 uminfo3( QueryLocation().QueryServer() );
            APIERR err = uminfo3.GetInfo();
            switch (err)
            {
                case NERR_Success:
                    psecsetdlg = new SECSET_DIALOG_LOCKOUT( this,
                                                            QueryLocation(),
                                                            uminfo3 );
                    break;
                case ERROR_INVALID_LEVEL:
                case ERROR_INVALID_PARAMETER:
                case RPC_S_PROCNUM_OUT_OF_RANGE:
                    psecsetdlg = new SECSET_DIALOG( this, QueryLocation() );
                    break;
                default:
                    DBGEOL( "UM_ADMIN_APP::OnMenuCommand(): UM3 error " << err );
                    break;
            }

            if ( psecsetdlg != NULL )
                err = psecsetdlg->Process();
            else if (err == NERR_Success)
                err = ERROR_NOT_ENOUGH_MEMORY;

            if ( err != NERR_Success )
                ::MsgPopup( this, err );

            delete psecsetdlg;
        }
        UnlockRefresh();
        return TRUE;

#ifndef MINI_USER_MANAGER
    case IDM_POLICY_TRUST :
        LockRefresh(); // now don't return before UnlockRefresh()!
        {
            TRUST_DIALOG * pDlg = new TRUST_DIALOG( this,
                                                    QueryLocation().QueryDomain(),
                                                    _padminauth );

            APIERR err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                          : pDlg->Process();

            if( err != NERR_Success )
            {
                ::MsgPopup( this, err );
            }

            delete pDlg;
        }
        UnlockRefresh();
        return TRUE;
#endif  // MINI_USER_MANAGER

    case IDM_POLICY_USER_RIGHTS:
        LockRefresh(); // now don't return before UnlockRefresh()!
        {
            APIERR err;

            LSA_POLICY *plsaPolicy = QueryAdminAuthority()->QueryLSAPolicy();

            USER_RIGHTS_POLICY_DIALOG *pdlg = new USER_RIGHTS_POLICY_DIALOG(
                                                  this,
                                                  plsaPolicy,
                                                  QueryLocation() );

            err = pdlg == NULL? ERROR_NOT_ENOUGH_MEMORY
                              : pdlg->QueryError();

            err = err? err : pdlg->Process();
            delete pdlg;

            if ( err != NERR_Success )
                ::MsgPopup( this, err );

            break;
        }
        UnlockRefresh();
        return TRUE;


    case IDM_POLICY_AUDITING:
        LockRefresh(); // now don't return before UnlockRefresh()!
        {
            APIERR err;

            LSA_POLICY *plsaPolicy = QueryAdminAuthority()->QueryLSAPolicy();

            AUDITING_DIALOG *pdlg = new AUDITING_DIALOG( this,
                                                         plsaPolicy,
                                                         QueryLocation() );

            err = pdlg == NULL? ERROR_NOT_ENOUGH_MEMORY
                              : pdlg->QueryError();
            err = err? err : pdlg->Process();
            delete pdlg;

            if ( err != NERR_Success )
                ::MsgPopup( this, err );

            break;
        }
        UnlockRefresh();
        return TRUE;


#ifndef MINI_USER_MANAGER
    case IDM_VIEW_LOGONNAME_SORT:
    case IDM_VIEW_FULLNAME_SORT:
        LockRefresh(); // now don't return before UnlockRefresh()!
        {
            enum USER_LISTBOX_SORTORDER ulbso;
            switch ( midMenuItem )
            {
            case IDM_VIEW_FULLNAME_SORT:
                ulbso = ULB_SO_FULLNAME;
                break;

            default:
                //  Should never happen, provided the cases in this switch
                //  statement are kept in sync with those in the outer
                //  switch statement.
                DBGEOL( "Unexpected midMenuItem" );
                UIASSERT( FALSE );
                //  fall through

            case IDM_VIEW_LOGONNAME_SORT:
                ulbso = ULB_SO_LOGONNAME;
                break;

            }
            APIERR err = _lbUsers.SetSortOrder( ulbso, TRUE );
            if ( err != NERR_Success )
            {
                ::MsgPopup( this, err );
            }
            else
            {
                //  The selection will not follow the items through
                //  the resort.  Hence, remove the selection.
                //  CODEWORK.  BLT could implement the listbox resort
                //  so that the selection does follow the items.
                _lbUsers.RemoveSelection();

                _colheadUsers.Invalidate( TRUE );
                SetSortOrderCheckmarks( ulbso );
            }
        }
        UnlockRefresh();
        return TRUE;

    case IDM_VIEW_ALL_USERS:
    case IDM_VIEW_NETWARE_USERS:
    {
        ULONG ulViewAcctType = UM_VIEW_ALL_USERS;

        if ( midMenuItem == IDM_VIEW_NETWARE_USERS )
        {
            ulViewAcctType |= UM_VIEW_NETWARE_USERS;
        }

        if ( ulViewAcctType != _ulViewAcctType )
        {
            _ulViewAcctType = ulViewAcctType;

            ASSERT(   _pmenuitemAllUsers != NULL
                   && _pmenuitemNetWareUsers != NULL  );

            _pmenuitemAllUsers->SetCheck( _ulViewAcctType == UM_VIEW_ALL_USERS);
            _pmenuitemNetWareUsers->SetCheck( _ulViewAcctType & UM_VIEW_NETWARE_USERS );

            // Selection is different, so refresh the listbox
            APIERR err = SetAdminCaption();
            if (  ( err != NERR_Success )
               || (( err = OnRefreshNow( FALSE )) != NERR_Success )
               )
            {
                ::MsgPopup( this, err );
            }

        }
        return TRUE;
    }

    case IDM_USER_SET_SELECTION:
        OnSetSelection();
        return TRUE;
#endif // MINI_USER_MANAGER

    case IDM_USER_RENAME:
        LockRefresh(); // now don't return before UnlockRefresh()!
        {
            APIERR err = NERR_Success;

            if (InRasMode())
            {
                err = GetRasSelection( IDS_RAS_TITLE_RENAME_USER,
                                       IDS_RAS_TEXT_RENAME_USER,
                                       HC_RENAME_RAS_MODE,
                                       FALSE,
                                       TRUE );
                if (err != NERR_Success) // also includes cancel
                {
                    // no need to display error message
                    return TRUE;
                }
            }

            LAZY_USER_SELECTION sel( _lbUsers );

            UIASSERT( sel.QueryCount() == 1 );

            NLS_STR nlsNewName;
            NLS_STR nlsSelectName;

            USER_LBI * pulbiOld = (USER_LBI *)(sel.QueryItem(0));
            ASSERT( pulbiOld != NULL );
            RENAME_USER_DIALOG * prenameuserdlg = new RENAME_USER_DIALOG(
                                     this,
                                     QueryAdminAuthority()->QueryAccountDomain(),
                                     pulbiOld->QueryName(),
                                     pulbiOld->QueryRID(),
                                     &nlsNewName // error OK but causes ctor failure
                                     );
            if ( prenameuserdlg == NULL )
                err = ERROR_NOT_ENOUGH_MEMORY;

            if ( err == NERR_Success )
            {
                BOOL fWorkWasDone;
                err = prenameuserdlg->Process( &fWorkWasDone );
                if ( err == NERR_Success && fWorkWasDone )
                {
                    // hydra
                    RegUserConfigRename( (WCHAR *)QueryLocation().QueryServer(),
                                         (WCHAR *)pulbiOld->QueryName(),
                                         (WCHAR *)nlsNewName.QueryPch() );
                    // hydra end
                    //
                    //  Notify the extensions.
                    //
                    NotifyRenameExtensions( prenameuserdlg->QueryHwnd(),
                                            pulbiOld,
                                            nlsNewName.QueryPch() );

                    //
                    // If the listbox is sorted by fullname, we will want
                    // to re-select the renamed user based on fullname.
                    //
                    if (_lbUsers.QuerySortOrder() == ULB_SO_FULLNAME)
                    {
                        err = nlsSelectName.CopyFrom( pulbiOld->QueryFullNamePtr(),
                                                      pulbiOld->QueryFullNameCb() );
                    } else {
                        err = nlsSelectName.CopyFrom( nlsNewName );
                    }

                    if (err == NERR_Success)
                    {
                        err = _lbUsers.RefreshNow();

                        //
                        //  Refresh any loaded extensions.
                        //

                        RefreshExtensions( QueryHwnd() );
                    }

                    _lbUsers.RemoveSelection();
                    if (   err != NERR_Success
                        || !_lbUsers.SelectUser( nlsSelectName.QueryPch() ) )
                    {
                        DBGEOL( "User Manager: IDM_USER_RENAME: could not select renamed user" );
                    }
                }
            }
            if ( err != NERR_Success )
                ::MsgPopup( this, err );

            delete prenameuserdlg;
        }
        UnlockRefresh();

        return TRUE;

    case IDM_HELP_NETWARE:
        ActivateHelp( HELP_CONTEXT, (DWORD_PTR)HC_HELP_NETWARE );
        return TRUE;
    // hydra
    case IDM_SETFOCUS:
        // Remind to reboot for Anonymous user changes if necessary
        // if ( ctxHaveAnonymousUsersChanged() )
        if ( HaveAnonymousUsersChanged() )
            ::MsgPopup( this, IDS_ReminderForAnonymousReboot, MPSEV_WARNING );
        break;
    // hydra end


    default:
        break;

    }

    return ADMIN_APP::OnMenuCommand( midMenuItem ) ;
}


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnNewObjectMenuSel

    SYNOPSIS:   New User... menu item handler

    HISTORY:
        jonn    14-Oct-1991     created

********************************************************************/

void UM_ADMIN_APP::OnNewObjectMenuSel( void )
{
    APIERR err = OnNewUser();
    if ( err != NERR_Success )
        ::MsgPopup( this, err );
}


#ifndef MINI_USER_MANAGER

/*******************************************************************

    NAME:       UM_ADMIN_APP::OnNewGroupMenuSel

    SYNOPSIS:   New Group... menu item handler

    HISTORY:
        jonn    14-Oct-1991     created

********************************************************************/

void UM_ADMIN_APP::OnNewGroupMenuSel( void )
{
    APIERR err = OnNewGroup();
    if ( err != NERR_Success )
        ::MsgPopup( this, err );
}

#endif // MINI_USER_MANAGER


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnNewAliasMenuSel

    SYNOPSIS:   New Alias... menu item handler

    HISTORY:
        jonn    20-Feb-1992     created

********************************************************************/

void UM_ADMIN_APP::OnNewAliasMenuSel( void )
{
    APIERR err = OnNewAlias();
    if ( err != NERR_Success )
        ::MsgPopup( this, err );
}


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnCopyMenuSel

    SYNOPSIS:   Copy... menu item handler

    HISTORY:
        jonn    14-Oct-1991     created
        jonn    13-May-1992     bugfix -- also copy aliases
        jonn    20-May-1992     Added OnNewUser( pszCopyFrom, ridCopyFrom )

********************************************************************/

void UM_ADMIN_APP::OnCopyMenuSel( void )
{
    APIERR err = NERR_Success;
    LockRefresh(); // now don't return before UnlockRefresh()!

    if (InRasMode())
    {
        err = GetRasSelection( IDS_RAS_TITLE_COPY,
                               IDS_RAS_TEXT_COPY,
                               HC_COPY_RAS_MODE,
                               FALSE,
                               FALSE,
                               TRUE );
    }

    if ( err != NERR_Success )
    {
        err = NERR_Success; // error in GetRasSelection has already been reported
    }
    else if ( _lbGroups.QuerySelCount() > 0 )
    {
        ADMIN_SELECTION sel( _lbGroups );
        if ( (err = sel.QueryError()) == NERR_Success )
        {

            UIASSERT( sel.QueryCount() == 1 );

            // Assumes only one item can be selected

#ifndef MINI_USER_MANAGER
            if ( ((GROUP_LBI *)(sel.QueryItem(0)))->IsAliasLBI() )
            {
#endif // MINI_USER_MANAGER
                ULONG ulRid = ((ALIAS_LBI *)(sel.QueryItem(0)))->QueryRID();
                BOOL fIsBuiltin = ((ALIAS_LBI *)(sel.QueryItem(0)))->IsBuiltinAlias();
                err = OnNewAlias( &ulRid, fIsBuiltin );
#ifndef MINI_USER_MANAGER
            }
            else
            {
                err = OnNewGroup( sel.QueryItemName( 0 ) );
            }
#endif // MINI_USER_MANAGER
        }
    }
    else
    {
        LAZY_USER_SELECTION sel( _lbUsers );

        UIASSERT( sel.QueryCount() == 1 );

        USER_LBI * pulbiCopyFrom = (USER_LBI *)sel.QueryItem( 0 );
        ASSERT( pulbiCopyFrom != NULL );

        if ( IsDownlevelVariant() )
        {
            err = OnNewUser( pulbiCopyFrom->QueryAccount() );
        }
        else
        {
            err = OnNewUser( pulbiCopyFrom->QueryAccount(),
                             pulbiCopyFrom->QueryRID() );
        }

    }

    if ( err != NERR_Success )
        ::MsgPopup( this, err );

    UnlockRefresh();
}


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnCommand

    SYNOPSIS:   Handles control notifications

    RETURNS:    TRUE if message was handled; FALSE otherwise

    HISTORY:
        rustanl     18-Jul-1991     Created

********************************************************************/

BOOL UM_ADMIN_APP::OnCommand( const CONTROL_EVENT & ce )
{
    switch ( ce.QueryCid())
    {
    case IDC_LBUSERS:
        switch ( ce.QueryCode())
        {
        case LBN_SELCHANGE:
            _lbGroups.RemoveSelection();
            _pctrlFocus = &_lbUsers;
            return TRUE;

        case LBN_DBLCLK:
            {
                APIERR err = OnUserProperties();
                if ( err != NERR_Success )
                    ::MsgPopup( this, err );
                return TRUE;
            }
        default:
            break;

        }
        break;

    case IDC_LBGROUPS:
        switch ( ce.QueryCode())
        {
        case LBN_SELCHANGE:
            _lbUsers.RemoveSelection();
            _pctrlFocus = &_lbGroups;
            return TRUE;

        case LBN_DBLCLK:
            {
                APIERR err = OnGroupProperties();
                if ( err != NERR_Success )
                    ::MsgPopup( this, err );
                return TRUE;
            }
        default:
            break;

        }
        break;

    default:
        break;

    }

    return ADMIN_APP::OnCommand( ce );

}  // UM_ADMIN_APP::OnCommand


#ifndef MINI_USER_MANAGER

/*******************************************************************

    NAME:       UM_ADMIN_APP::SetSortOrderCheckmarks

    SYNOPSIS:   Sets the check marks for the sort order options

    ENTRY:      ulbso -     Specifies the sort order to be displayed

    EXIT:       Appropriate menu item will carry the check mark

    HISTORY:
        rustanl     11-Jul-1991     Created

********************************************************************/

void UM_ADMIN_APP::SetSortOrderCheckmarks( enum USER_LISTBOX_SORTORDER ulbso )
{
    _pmenuitemLogonSortOrder->SetCheck( ulbso == ULB_SO_LOGONNAME );
    _pmenuitemFullNameSortOrder->SetCheck( ulbso == ULB_SO_FULLNAME );

}  // UM_ADMIN_APP::SetSortOrderCheckmarks


#endif // MINI_USER_MANAGER


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnPropertiesMenuSel

    SYNOPSIS:   Called when the properties sheet should be invoked

    ENTRY:      Object constructed

    EXIT:       Properties dialog shown

    NOTES:

    HISTORY:
        kevinl  21-May-1991     Created
        gregj   24-May-1991     Cloned from Server Manager

********************************************************************/

VOID UM_ADMIN_APP::OnPropertiesMenuSel()
{
    APIERR err = NERR_Success;  // assign success to simplify debug code below

    //  Exactly one of the listboxes should have focus and at
    //  least one item selected; otherwise this menu selection should
    //  not have been called.
    if (InRasMode())
    {
        err = GetRasSelection( IDS_RAS_TITLE_EDIT,
                               IDS_RAS_TEXT_EDIT,
                               HC_EDIT_RAS_MODE );
    }

    if ( err != NERR_Success )
    {
        err = NERR_Success; // error in GetRasSelection has already been reported
    }
    //  Exactly one of the listboxes should have focus and at
    //  least one item selected; otherwise this menu selection should
    //  not have been called.
    else if ( _lbGroups.QuerySelCount() > 0 )
    {
        //  Group listbox has focus

#ifdef TRACE
        ADMIN_SELECTION asel( _lbGroups );
        err = asel.QueryError();
        if ( err == NERR_Success )
        {
            DBGEOL( "Selected items:" );
            int c = asel.QueryCount();
            for ( int i = 0; i < c; i++ )
            {
                DBGEOL( "\t" << asel.QueryItemName( i ) ); // group selected
            }
        }
#endif

        if ( err == NERR_Success )
            err = OnGroupProperties();
    }
    else
    {
        //  User listbox has focus
        UIASSERT( _lbUsers.QuerySelCount() > 0 );

#ifdef TRACE
        LAZY_USER_SELECTION asel( _lbUsers );
        err = asel.QueryError();
        if ( err == NERR_Success )
        {
            DBGEOL( "Selected items:" );
            int c = asel.QueryCount();
            for ( int i = 0; i < c; i++ )
            {
                USER_LBI * pulbi = (USER_LBI *)asel.QueryItem( i );
                ASSERT( pulbi != NULL );
                DBGEOL( "\t" << pulbi->QueryAccount() );
            }
        }
#endif

        if ( err == NERR_Success )
            err = OnUserProperties();
    }

    if ( err != NERR_Success )
        ::MsgPopup( this, err );

}  // UM_ADMIN_APP::OnPropertiesMenuSel


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnDeleteMenuSel

    SYNOPSIS:   Called when user select delete menuitem

    CODEWORK:   This method consists of two large and nearly identical
                blocks of code.  They should be folded together.

    HISTORY:
        o-simop     07-Aug-1991     Created
        o-simop     14-Oct-1991     Refresh lockcount
        jonn        02-Jul-1992     Confirmation allows cancel (bug #14389)
        jonn        06-Oct-1992     No ConfirDelGroup2 for downlevel

********************************************************************/

void UM_ADMIN_APP::OnDeleteMenuSel( void )
{
    APIERR err = NERR_Success;
    if (InRasMode())
    {
        err = GetRasSelection( IDS_RAS_TITLE_DELETE,
                               IDS_RAS_TEXT_DELETE,
                               HC_DELETE_RAS_MODE,
                               TRUE );
    }

    if ( err != NERR_Success )
    {
        err = NERR_Success; // error in GetRasSelection has already been reported
    }
    else if ( _lbUsers.QuerySelCount() > 0 )
    {
        LAZY_USER_SELECTION asel( _lbUsers );
        err = asel.QueryError();
        if( err != NERR_Success )
        {
            ::MsgPopup( this, err );
            return;
        }

        USER_DELETE_PERFORMER udelperf( this, asel, QueryLocation() );
        err = udelperf.QueryError();
        if( err != NERR_Success )
        {
            ::MsgPopup( this, err );
            return;
        }

        if( IsConfirmationOn() && !IsDownlevelVariant() )
        {
            NLS_STR nls;  // the sting is splited
            err = nls.Load( IDS_ConfirDelUsers2 );
            if( err != NERR_Success )
            {
                ::MsgPopup( this, err );
                return;
            }
            if (::MsgPopup( this, IDS_ConfirDelUsers1,
                            MPSEV_WARNING, MP_OKCANCEL,
                            nls.QueryPch())
                     == IDCANCEL)
            {
                return;
            }
        }

        // CODEWORK  Refresh should be locked through this entire
        // routine, but without an object to automatically remember
        // to unlock if we return, it's safer to keep the scope short.
        LockRefresh(); // now don't return before UnlockRefresh()!
        udelperf.PerformSeries( this );
        UnlockRefresh();
        if( udelperf.QueryWorkWasDone() == TRUE )
        {
            err = _lbUsers.RefreshNow();

            //
            //  Refresh any loaded extensions.
            //

            RefreshExtensions( QueryHwnd() );

            if( err != NERR_Success )
            {
                ::MsgPopup( this, err );
                return;
            }
        }

    }
    else if( _lbGroups.QuerySelCount() > 0 )
    {
        ADMIN_SELECTION asel( _lbGroups );
        err = asel.QueryError();
        if( err != NERR_Success )
        {
            ::MsgPopup( this, err );
            return;
        }

        GROUP_DELETE_PERFORMER gdelperf( this, asel, QueryLocation() );
        err = gdelperf.QueryError();
        if( err != NERR_Success )
        {
            ::MsgPopup( this, err );
            return;
        }

        if( IsConfirmationOn() && !IsDownlevelVariant() )
        {
            NLS_STR nls;  // the sting is splited
            err = nls.Load( IDS_ConfirDelGroup2 );
            if( err != NERR_Success )
            {
                ::MsgPopup( this, err );
                return;
            }
            if (::MsgPopup( this, IDS_ConfirDelGroup1,
                            MPSEV_WARNING, MP_OKCANCEL,
                            nls.QueryPch())
                    == IDCANCEL)
            {
                return;
            }
        }
        LockRefresh(); // now don't return before UnlockRefresh()!
        gdelperf.PerformSeries( this );
        UnlockRefresh();
        if( gdelperf.QueryWorkWasDone() == TRUE )
        {
            err = _lbGroups.RefreshNow();

            //
            //  Refresh any loaded extensions.
            //

            RefreshExtensions( QueryHwnd() );

            if( err != NERR_Success )
            {
                ::MsgPopup( this, err );
                return;
            }
        }
    }

}   // UM_ADMIN_APP::OnDeleteMenuSel


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnSlowModeMenuSel

    SYNOPSIS:   Called when user selects slow mode menuitem

    HISTORY:
        jonn        22-Feb-1992     Created

********************************************************************/

void UM_ADMIN_APP::OnSlowModeMenuSel( void )
{
    SetRasMode( !InRasMode() );
    APIERR err = OnRefreshNow( TRUE );
    if (err != NERR_Success)
    {
        ::MsgPopup( this, err );

        if ( !InRasMode() )
        {
            // If we failed to leave RAS mode, perhaps we can keep the
            // app alive by switching back to RAS mode.
            SetRasMode( TRUE );
            err = OnRefreshNow( TRUE );
        }

        if (err != NERR_Success)
        {
            ::MsgPopup( this, err );

            //
            // We couldn't even restore focus in RAS mode.  Give up.
            //

            Close();
        }
    }

    (void) SLOW_MODE_CACHE::Write( QueryLocation(),
                                   ( InRasMode() ? SLOW_MODE_CACHE_SLOW
                                                 : SLOW_MODE_CACHE_FAST ));

}   // UM_ADMIN_APP::OnSlowModeMenuSel


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnFontPickChange

    SYNOPSIS:   Called to set font in applicable listboxes

    HISTORY:
        jonn        23-Sep-1993     Created

********************************************************************/

VOID UM_ADMIN_APP::OnFontPickChange( FONT & font )
{
    ADMIN_APP::OnFontPickChange( font );

    APIERR err = NERR_Success;

    if (   (err = _lbGroups.ChangeFont( QueryInstance(), font )) != NERR_Success
        || (_colheadGroups.Invalidate( TRUE ), FALSE)
       )
    {
        DBGEOL( "UM_ADMIN_APP::OnFontPickChange:: _lbGroups error " << err );
    }
    else
    if (   (err = _lbUsers.ChangeFont( QueryInstance(), font )) != NERR_Success
        || (_colheadUsers.Invalidate( TRUE ), FALSE)
       )
    {
        DBGEOL( "UM_ADMIN_APP::OnFontPickChange:: _lbUsers error " << err );
    }

}   // UM_ADMIN_APP::OnFontPickChange


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnUserProperties

    SYNOPSIS:   Called to bring up the User Properties dialog

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        jonn    18-Jul-1991     Created
        rustanl     19-Jul-1991     Copied to this function

********************************************************************/

APIERR UM_ADMIN_APP::OnUserProperties( void )
{
    //
    // By using CTRL-CLICK, it is actually possible to double-click and
    // have no selection.  Just ignore this.
    //
    if ( _lbUsers.QuerySelCount() <= 0 )
    {
        return NERR_Success;
    }

    LAZY_USER_SELECTION sel( _lbUsers );

    USERPROP_DLG * pdlgUsrPropMain;
    if ( sel.QueryCount() > 1 )
    {
        pdlgUsrPropMain = new EDITMULTI_USERPROP_DLG(
                this,
                QueryLocation(),
                &sel,
                &_lbUsers
                );
    }
    else
    {
        pdlgUsrPropMain = new EDITSINGLE_USERPROP_DLG(
                this,
                QueryLocation(),
                &sel
                );
    }

    if ( pdlgUsrPropMain == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    LockRefresh(); // now don't return before UnlockRefresh()!

    //
    // secondary constructor
    // Do not call Process() if this fails -- error already
    // reported
    //
    if ( pdlgUsrPropMain->GetInfo() )
    {
        // process dialog
        BOOL fWorkWasDone = FALSE;

        APIERR err = pdlgUsrPropMain->Process( &fWorkWasDone );
        if (   err == NERR_Success
            && (fWorkWasDone || pdlgUsrPropMain->QueryWorkWasDone()) )
        {
            err = _lbUsers.RefreshNow();

            //
            //  Refresh any loaded extensions.
            //

            RefreshExtensions( QueryHwnd() );
        }
        if ( err != NERR_Success )
            ::MsgPopup( this, err );
    }

    // Note that this code usage requires a virtual destructor
    delete pdlgUsrPropMain;

    UnlockRefresh();

    return NERR_Success;

}  // UM_ADMIN_APP::OnUserProperties


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnNewUser

    SYNOPSIS:   Called to bring up the New User dialog

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        jonn    27-Aug-1991     Created
        jonn    20-May-1992     Added OnNewUser( pszCopyFrom, ridCopyFrom )

********************************************************************/

APIERR UM_ADMIN_APP::OnNewUser( const TCHAR * pszCopyFrom,
                                ULONG ridCopyFrom )
{
    ASSERT( pszCopyFrom == NULL || IsDownlevelVariant() || ridCopyFrom != 0L );

    LockRefresh(); // now don't return before UnlockRefresh()!

    NEW_USERPROP_DLG * pdlgUsrPropMain =
            new NEW_USERPROP_DLG( this,
                                  QueryLocation(),
                                  pszCopyFrom,
                                  ridCopyFrom );

    APIERR err = NERR_Success;

    if ( pdlgUsrPropMain == NULL )
        err = ERROR_NOT_ENOUGH_MEMORY;
    //
    // secondary constructor
    // Do not call Process() if this fails -- error already
    // reported
    //
    else if ( pdlgUsrPropMain->GetInfo() )
    {
        // process dialog
        BOOL fWorkWasDone;
        err = pdlgUsrPropMain->Process( &fWorkWasDone );
        if ( err == NERR_Success && fWorkWasDone )
        {
            err = _lbUsers.RefreshNow();

            //
            //  Refresh any loaded extensions.
            //

            RefreshExtensions( QueryHwnd() );
        }
    }

    delete pdlgUsrPropMain;

    UnlockRefresh();

    return err;

}  // UM_ADMIN_APP::OnNewUser


#ifndef MINI_USER_MANAGER

/*******************************************************************

    NAME:       UM_ADMIN_APP::OnNewGroup

    SYNOPSIS:   Called to bring up the New Group dialog

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        jonn    11-Oct-1991     Added OnNewGroup( pszCopyFrom )
        o-SimoP 27-Nov-1991     Added SetReadyToDie calls
********************************************************************/

APIERR UM_ADMIN_APP::OnNewGroup( const TCHAR * pszCopyFrom )
{

    LockRefresh(); // now don't return before UnlockRefresh()!

TRACETIMESTART;
    NEW_GROUPPROP_DLG * pdlgGrpPropMain =
            new NEW_GROUPPROP_DLG( this, this, &_lbUsers, QueryLocation(), pszCopyFrom );
TRACETIMEEND( "UM_ADMIN_APP::OnNewGroup: dlg ctor " );

    APIERR err = NERR_Success;

    if ( pdlgGrpPropMain == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        return err;
    }

    //
    // secondary constructor
    // Do not call Process() if this fails -- error already
    // reported
    //
TRACETIMESTART2( 1 );
    if ( pdlgGrpPropMain->GetInfo() )
    {
TRACETIMEEND2( 1, "UM_ADMIN_APP::OnNewGroup: GetInfo() " );
        // process dialog
        BOOL fWorkWasDone;
        err = pdlgGrpPropMain->Process( &fWorkWasDone );
        if ( err == NERR_Success && fWorkWasDone )
        {
            err = _lbGroups.RefreshNow();

            //
            //  Refresh any loaded extensions.
            //

            RefreshExtensions( QueryHwnd() );
        }
    }

    delete pdlgGrpPropMain;

    UnlockRefresh();

    return err;

}  // UM_ADMIN_APP::OnNewGroup

#endif // MINI_USER_MANAGER


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnNewAlias

    SYNOPSIS:   Called to bring up the New Alias dialog

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        thomaspa        27-Mar-1992     Created
********************************************************************/

APIERR UM_ADMIN_APP::OnNewAlias( const ULONG * pridCopyFrom, BOOL fCopyBuiltin )
{

    LockRefresh(); // now don't return before UnlockRefresh()!

    NEW_ALIASPROP_DLG * pdlgAlsPropMain =
            new NEW_ALIASPROP_DLG( this,
                                   this,
                                   &_lbUsers,
                                   QueryLocation(),
                                   pridCopyFrom,
                                   fCopyBuiltin );

    APIERR err = NERR_Success;

    if ( pdlgAlsPropMain == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        return err;
    }

    //
    // secondary constructor
    // Do not call Process() if this fails -- error already
    // reported
    //
    if ( pdlgAlsPropMain->GetInfo() )
    {
        // process dialog
        BOOL fWorkWasDone;
        err = pdlgAlsPropMain->Process( &fWorkWasDone );
        if ( err == NERR_Success && fWorkWasDone )
        {
            err = _lbGroups.RefreshNow();

            //
            //  Refresh any loaded extensions.
            //

            RefreshExtensions( QueryHwnd() );
        }
    }

    delete pdlgAlsPropMain;

    UnlockRefresh();

    return err;

}  // UM_ADMIN_APP::OnNewAlias


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnGroupProperties

    SYNOPSIS:   Called to bring up the Group Properties dialog

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        rustanl     19-Jul-1991     Created function skeleton
        jonn        11-Oct-1991     Enabled
        o-SimoP     27-Nov-1991     Added SetReadyToDie calls
        jonn        09-Mar-1992     Added ALIASPROP_DLG
********************************************************************/

APIERR UM_ADMIN_APP::OnGroupProperties( void )
{
    APIERR err = NERR_Success;

    UIASSERT( _lbGroups.QuerySelCount() == 1 );

    LockRefresh(); // now don't return before UnlockRefresh()!

    ADMIN_SELECTION sel( _lbGroups );
    if ( (err = sel.QueryError()) != NERR_Success )
    {
        return err;
    }

    PROP_DLG * pdlgGrpPropMain = NULL;

    // Assumes only one item can be selected

TRACETIMESTART;
#ifndef MINI_USER_MANAGER
    if ( ((GROUP_LBI *)(sel.QueryItem(0)))->IsAliasLBI() )
#endif // MINI_USER_MANAGER
        pdlgGrpPropMain = new EDIT_ALIASPROP_DLG( this,
                                                  this,
                                                  &_lbUsers,
                                                  QueryLocation(),
                                                  &sel );
#ifndef MINI_USER_MANAGER
    else
        pdlgGrpPropMain = new EDIT_GROUPPROP_DLG( this,
                                                  this,
                                                  &_lbUsers,
                                                  QueryLocation(),
                                                  &sel,
                            ( _lbGroups.QueryGroupRidsKnown()
                              ? ((GROUP_LBI *)(sel.QueryItem(0)))->QueryRID()
                              : 0 )
                                                  );
#endif // MINI_USER_MANAGER
TRACETIMEEND( "UM_ADMIN_APP::OnGroupProperties: dlg ctor " );

    if ( pdlgGrpPropMain == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // secondary constructor
    // Do not call Process() if this fails -- error already
    // reported
    //
TRACETIMESTART2( 1 );
    if ( (err == NERR_Success) && pdlgGrpPropMain->GetInfo() )
    {
TRACETIMEEND2( 1, "UM_ADMIN_APP::OnGroupProperties: GetInfo() " );
        // process dialog
        BOOL fWorkWasDone;
        err = pdlgGrpPropMain->Process( &fWorkWasDone );
        if ( err == NERR_Success && fWorkWasDone )
        {
            err = _lbGroups.RefreshNow();

            //
            //  Refresh any loaded extensions.
            //

            RefreshExtensions( QueryHwnd() );
        }
    }

    delete pdlgGrpPropMain;

    UnlockRefresh();

    return err;

}  // UM_ADMIN_APP::OnGroupProperties


ULONG UM_ADMIN_APP::QueryHelpContext( enum HELP_OPTIONS helpOptions )
{
    switch ( helpOptions )
    {
    case ADMIN_HELP_CONTENTS:
        return QueryHelpContents();
        break;
    case ADMIN_HELP_SEARCH:
        return QueryHelpSearch();
        break;
    case ADMIN_HELP_HOWTOUSE:
        return QueryHelpHowToUse();
        break;
    default:
        DBGEOL( "User Manager: UM_ADMIN_APP::QueryHelpContext, Unknown help menu command" );
        UIASSERT( FALSE );
        break;
    }
    return (0L);
}



/*******************************************************************

    NAME:       UM_ADMIN_APP::QueryHelpOffset

    SYNOPSIS:   Returns the focus based offset for help context

    ENTRY:      None

    EXIT:       UM_OFF_LANNT - if Full User Manager focused on Lanman NT
                UM_OFF_WINNT - if Full User Manager focused on Windows NT
                UM_OFF_DOWN  - if Full User Manager focused on LM 2.x
                UM_OFF_MINI  - if Mini User Manager

    NOTES:      This routine is used by the QueryHelpContext() methods
                within the User Manager to calculate an offset to add
                to the base help context for a given dialog.

    HISTORY:
        thomaspa     25-Aug-1992     Created

********************************************************************/
ULONG UM_ADMIN_APP::QueryHelpOffset( void ) const
{
#ifdef MINI_USER_MANAGER
    return UM_OFF_MINI;
#else
    if ( IsWinNTVariant() )
        return UM_OFF_WINNT;
    else if ( IsDownlevelVariant() )
        return UM_OFF_DOWN;
    else
        return UM_OFF_LANNT;

#endif // MINI_USER_MANAGER
}

#ifndef MINI_USER_MANAGER

/*******************************************************************

    NAME:       UM_ADMIN_APP::OnSetSelection

    SYNOPSIS:   Brings up the Select Users dialog

    ENTRY:      Assumes the group listbox does contain items

    NOTES:      The Select Users dialog used to be called the
                Set Selection dialog.  This influenced the name
                of this method and related names.

    HISTORY:
        rustanl     16-Aug-1991     Created

********************************************************************/

VOID UM_ADMIN_APP::OnSetSelection( void )
{
    UIASSERT( _lbGroups.QueryCount() > 0 );

    LockRefresh(); // now don't return before UnlockRefresh()!

    SET_SELECTION_DIALOG ssdlg( this,
                                QueryLocation(),
                                QueryAdminAuthority(),
                                &_lbUsers,
                                &_lbGroups );

    BOOL fChangedSelection;
    APIERR err = ssdlg.Process( &fChangedSelection );

    UnlockRefresh();

    if ( err != NERR_Success )
    {
        ::MsgPopup( this, err );
        return;
    }

    if ( fChangedSelection )
        _lbUsers.ClaimFocus();

}  // UM_ADMIN_APP::OnSetSelection

#endif // MINI_USER_MANAGER


/*******************************************************************

    NAME:          UM_ADMIN_APP::OnFocus

    SYNOPSIS:      Restores remembered focus
                   keyboard will work.

    ENTRY:         Object constructed

    EXIT:          Returns TRUE if it handled the message

    CODEWORK  Remove when/if restore-focus code ready in BLT

    CODEWORK       We should really track focus with OnFocus methods in
                   the listbox controls, but OnFocus is derived from
                   CLIENT_WINDOW rather than (properly) WINDOW, and is thus
                   not available to CONTROL_WINDOWs.

    HISTORY:
       jonn      11-Nov-1991     Created

********************************************************************/

BOOL UM_ADMIN_APP::OnFocus( const FOCUS_EVENT & event )
{
    ASSERT( _pctrlFocus != NULL );

    _pctrlFocus->ClaimFocus();

    return ADMIN_APP::OnFocus( event );
}


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnFocusChange

    SYNOPSIS:   Called when a listbox received a keystroke indicating
                that focus should be changed.

    ENTRY:      pusrmlbPrev -       Pointer to listbox that received the
                                    keystroke and that previously had focus.
                                    Must be &_lbUsers or &_lbGroups.

    EXIT:       *pusrmlbPrev no longer has the focus; instead, the other
                listbox has focus

    HISTORY:
        rustanl     12-Sep-1991     Created

********************************************************************/

VOID UM_ADMIN_APP::OnFocusChange( LISTBOX * plbPrev )
{
    UIASSERT( plbPrev == (LISTBOX *)&_lbUsers ||
              plbPrev == (LISTBOX *)&_lbGroups );

    LISTBOX * plbNew = (LISTBOX *)&_lbUsers;
    if ( plbPrev == (LISTBOX *)&_lbUsers )
        plbNew = (LISTBOX *)&_lbGroups;

    plbPrev->RemoveSelection();
    plbNew->ClaimFocus();
    _pctrlFocus = plbNew;

#ifdef WIN32
    //
    // Select item with initial caret
    // This only works on Win32
    //
    INT i = plbNew->QueryCaretIndex();
    TRACEEOL( "UM_ADMIN_APP::OnFocusChange(): caret on item " << i );
    if ( (i >= 0) && (i < plbNew->QueryCount()) )
    {
        plbNew->SelectItem( i, TRUE );
    }
#endif

}  // UM_ADMIN_APP::OnFocusChange


ULONG UM_ADMIN_APP::QueryHelpSearch( void ) const
{
    return HC_UM_SEARCH ;
}

ULONG UM_ADMIN_APP::QueryHelpHowToUse( void ) const
{
    return HC_UM_HOWTOUSE ;
}

ULONG UM_ADMIN_APP::QueryHelpContents( void ) const
{
    return HC_UM_CONTENTS ;
}



/*******************************************************************

    NAME:       UM_ADMIN_APP::OnRefresh

    SYNOPSIS:   Called to kick off an automatic refresh cycle

    HISTORY:
        rustanl     09-Sep-1991     Created

********************************************************************/

VOID UM_ADMIN_APP::OnRefresh()
{
    _lbUsers.KickOffRefresh();
    _lbGroups.KickOffRefresh();

}  // UM_ADMIN_APP::OnRefresh


/*******************************************************************

    NAME:       UM_ADMIN_APP::StopRefresh

    SYNOPSIS:   Called to force all automatic refresh cycles to
                terminate

    HISTORY:
        rustanl     09-Sep-1991     Created

********************************************************************/

VOID UM_ADMIN_APP::StopRefresh()
{
    _lbUsers.StopRefresh();
    _lbGroups.StopRefresh();

}  // UM_ADMIN_APP::StopRefresh


/*******************************************************************

    NAME:       UM_ADMIN_APP::OnRefreshNow

    SYNOPSIS:   Called to synchronously refresh the data in the main window

    ENTRY:      fClearFirst -       TRUE indicates that main window should
                                    be cleared before any refresh operation
                                    is done; FALSE indicates an incremental
                                    refresh that doesn't necessarily
                                    require first clearing the main window

    RETURNS:    An API return code, which is NERR_Success on success

    CODEWORK:   Most of this work could be done in SetNetworkFocus, since
                these values are unlikely to change without the user
                logging off.

    HISTORY:
        rustanl     09-Sep-1991     Created
        thomaspa    03-Apr-1992     Added construction of ADMIN_AUTHORITY
        jonn        07-Jun-1992     Cleanup to improve behavior on failure

********************************************************************/

APIERR UM_ADMIN_APP::OnRefreshNow( BOOL fClearFirst )
{

    LockRefresh(); // now don't return before UnlockRefresh()!

    // First Delete the old _padminauth and create a new one
    // Should this be in a virtual method which is called by
    // ADMIN_APP::SetNetworkFocus() ??

    delete _padminauth;
    _padminauth = NULL;

    APIERR err = NERR_Success;

    _fCanCreateUsers          = FALSE;
    _fCanCreateLocalGroups    = FALSE;
    _fCanCreateGlobalGroups   = FALSE;
    _fCanChangeAccountPolicy  = FALSE;
    _fCanChangeUserRights     = FALSE;
    _fCanChangeAuditing       = FALSE;
    _fCanChangeTrustedDomains = FALSE;

    if ( QueryTargetServerType() == UM_DOWNLEVEL )
    {
        // CODEWORK we could try to disable these too
        _fCanCreateUsers          = TRUE;
        _fCanCreateGlobalGroups   = TRUE;
        _fCanChangeAccountPolicy  = TRUE;
        // Obviously cannot run User Rights or Trusted Domains,
        // Yi-Hsin says Auditing won't work either.
    }
    else
    {
        // minimum authority to run [Mini-] User Manager

#if defined(DEBUG) && defined(TRACE)
    DWORD start = ::GetTickCount();
#endif

        _padminauth = new ADMIN_AUTHORITY(
                            QueryLocation().QueryServer(),
                            UM_ACCESS_ACCOUNT_DOMAIN,
                            UM_ACCESS_BUILTIN_DOMAIN,
                            UM_ACCESS_LSA_POLICY,
                            UM_ACCESS_SAM_SERVER );

#if defined(DEBUG) && defined(TRACE)
    DWORD finish = ::GetTickCount();
    TRACEEOL( "User Manager: OnRefreshNow: ADMIN_AUTHORITY::ctor() took " << finish-start << " ms" );
#endif

        if ( _padminauth == NULL )
            err = ERROR_NOT_ENOUGH_MEMORY;
        else
            err = _padminauth->QueryError();

        // CODEWORK the three following sections could be combined into one method

#if defined(DEBUG) && defined(TRACE)
    start = ::GetTickCount();
#endif

        // Determine whether user account creation allowed
        // JonN 1/19/96: DOMAIN_READ_PASSWORD_PARAMETERS is now required
        // to create users, we must claim this here for Account Operators
        // who will not get it below
        if ( err == NERR_Success )
        {
            _fCanCreateUsers = TRUE;
            err = _padminauth->UpgradeAccountDomain( DOMAIN_CREATE_USER );
            if (err == NERR_Success)
            {
                err = _padminauth->UpgradeAccountDomain(
                          DOMAIN_READ_PASSWORD_PARAMETERS
                      );
            }
            if (err == ERROR_ACCESS_DENIED)
            {
                DBGEOL( "User Manager: no permission to create users" );
                _fCanCreateUsers = FALSE;
                err = NERR_Success;
            }
        }

        // Determine whether local group creation allowed
        if ( err == NERR_Success )
        {
            _fCanCreateLocalGroups = TRUE;
            err = _padminauth->UpgradeAccountDomain( DOMAIN_CREATE_ALIAS );
            if (err == ERROR_ACCESS_DENIED)
            {
                DBGEOL( "User Manager: no permission to create local groups" );
                _fCanCreateLocalGroups = FALSE;
                err = NERR_Success;
            }
        }

#ifndef MINI_USER_MANAGER

        // Determine whether global group creation allowed
        if ( (err == NERR_Success) && DoShowGroups() )
        {
            _fCanCreateGlobalGroups = TRUE;
            err = _padminauth->UpgradeAccountDomain( DOMAIN_CREATE_GROUP );
            if (err == ERROR_ACCESS_DENIED)
            {
                DBGEOL( "User Manager: no permission to create global groups" );
                _fCanCreateGlobalGroups = FALSE;
                err = NERR_Success;
            }
        }

#endif // MINI_USER_MANAGER

        // Determine whether account policy change allowed
        /*
         * AnonChange is editable
         */
        if ( err == NERR_Success )
        {
            _fCanChangeAccountPolicy = TRUE;
            err = _padminauth->UpgradeAccountDomain(
                      DOMAIN_READ_PASSWORD_PARAMETERS
                    | DOMAIN_WRITE_PASSWORD_PARAMS
                    // | DOMAIN_WRITE_OTHER_PARAMETERS
                  );
            if (err == ERROR_ACCESS_DENIED)
            {
                DBGEOL( "User Manager: no permission to change account policy" );
                _fCanChangeAccountPolicy = FALSE;
                err = NERR_Success;
            }
        }

        // Determine whether user rights change allowed
        if ( err == NERR_Success )
        {
            _fCanChangeUserRights = TRUE;
            err = _padminauth->UpgradeLSAPolicy(   POLICY_VIEW_LOCAL_INFORMATION
                                                 | POLICY_CREATE_ACCOUNT );
            if (err == ERROR_ACCESS_DENIED)
            {
                DBGEOL( "User Manager: no permission to change user rights" );
                _fCanChangeUserRights = FALSE;
                err = NERR_Success;
            }
        }

        // Determine whether auditing change allowed
        if ( err == NERR_Success )
        {
            _fCanChangeAuditing = TRUE;
            err = _padminauth->UpgradeLSAPolicy(   POLICY_SET_AUDIT_REQUIREMENTS
                                                 | POLICY_VIEW_AUDIT_INFORMATION
                                                 | POLICY_AUDIT_LOG_ADMIN );
            if (err == ERROR_ACCESS_DENIED)
            {
                DBGEOL( "User Manager: no permission to change auditing" );
                _fCanChangeAuditing = FALSE;
                err = NERR_Success;
            }
        }

#ifndef MINI_USER_MANAGER

        // Determine whether trusted domain manipulation allowed
        if ( err == NERR_Success )
        {
            _fCanChangeTrustedDomains = TRUE;

            if (err == NERR_Success)
            {
                err = _padminauth->UpgradeSamServer( UM_TRUST_SAM_SERVER );
            }

            if (err == NERR_Success)
            {
                err = _padminauth->UpgradeLSAPolicy( UM_TRUST_LSA_POLICY );
            }

            if (err == NERR_Success)
            {
                err = _padminauth->UpgradeBuiltinDomain( UM_TRUST_BUILTIN_DOMAIN );
            }

            if (err == NERR_Success)
            {
                err = _padminauth->UpgradeAccountDomain( UM_TRUST_ACCOUNT_DOMAIN );
            }

            if (err == ERROR_ACCESS_DENIED)
            {
                DBGEOL( "User Manager: no permission to change trusted domains" );
                _fCanChangeTrustedDomains = FALSE;
                err = NERR_Success;
            }

#if defined(DEBUG) && defined(TRACE)
    finish = ::GetTickCount();
    TRACEEOL( "User Manager: OnRefreshNow: permission checks took " << finish-start << " ms" );
#endif

        }

        // Determine if FPNW or DSMN is installed
        // If any error occurs, assume that neither is installed
        // We check for LSA secret on target *and* that the needed
        // DLL is avail locally.
        if ( err == NERR_Success )
        {
            LSA_SECRET LSASecret (NCP_LSA_SECRET_KEY);

            if (  ( LoadNwsLibDll() != NERR_Success)  ||
                  ( LSASecret.QueryError() != NERR_Success)  ||
                  ( LSASecret.Open (*QueryAdminAuthority()->QueryLSAPolicy())
                        != NERR_Success))
            {
                _fIsNetWareInstalled = FALSE;
            }
            else
            {
                _fIsNetWareInstalled = TRUE;
            }
        }

        //
        //  The following assumes that the "View" menu is the 2nd submenu
        //  in user manager and the "Help" menu is the last submenu.
        //

        if ( _fIsNetWareInstalled && (_pmenuitemAllUsers == NULL ))
        {
            POPUP_MENU viewmenu( QueryAppMenu()->QuerySubMenu( 1 ));
            POPUP_MENU helpmenu( QueryAppMenu()->QuerySubMenu(
                                     QueryAppMenu()->QueryItemCount() - 1 ));

            RESOURCE_STR nlsAllUsers( IDS_MENU_NAME_ALL_USERS );
            RESOURCE_STR nlsNetWareUsers( IDS_MENU_NAME_NETWARE_USERS );
            RESOURCE_STR nlsNetWareHelp( IDS_MENU_NAME_NETWARE_HELP );

            if (  ((err = viewmenu.QueryError()) == NERR_Success )
               && ((err = helpmenu.QueryError()) == NERR_Success )
               && ((err = nlsAllUsers.QueryError()) == NERR_Success )
               && ((err = nlsNetWareUsers.QueryError()) == NERR_Success )
               && ((err = nlsNetWareHelp.QueryError()) == NERR_Success )
               )
            {
                // Insert "All Users" in the view menu
                err = viewmenu.Insert( nlsAllUsers.QueryPch(),
                                       3,
                                       IDM_VIEW_ALL_USERS,
                                       MF_BYPOSITION );
            }

            if ( err == NERR_Success )
            {
                // Insert "NetWare Compatible Users" in the view menu
                err = viewmenu.Insert( nlsNetWareUsers.QueryPch(),
                                       4,
                                       IDM_VIEW_NETWARE_USERS,
                                       MF_BYPOSITION );
            }

            if ( err == NERR_Success )
            {
                err = viewmenu.InsertSeparator( 5,
                                                MF_BYPOSITION );
            }

            if ( err == NERR_Success )
            {
                err = helpmenu.InsertSeparator( 3,
                                                MF_BYPOSITION );

            }

            if ( err == NERR_Success )
            {
                //  Insert the help item.
                err = helpmenu.Insert( nlsNetWareHelp.QueryPch(),
                                       4,
                                       IDM_HELP_NETWARE,
                                       MF_BYPOSITION );
            }

            if ( ( err == NERR_Success ) &&
                 ( _pmenuitemAllUsers = new MENUITEM( this, IDM_VIEW_ALL_USERS )) != NULL &&
                 ( _pmenuitemNetWareUsers = new MENUITEM( this, IDM_VIEW_NETWARE_USERS )) != NULL &&
                 ( err = _pmenuitemAllUsers->QueryError()) == NERR_Success &&
                 ( err = _pmenuitemNetWareUsers->QueryError()) == NERR_Success )
            {
                _pmenuitemAllUsers->SetCheck( TRUE );
                _pmenuitemNetWareUsers->SetCheck( FALSE );
                _ulViewAcctType = UM_VIEW_ALL_USERS;
            }
            else
            {
                err = err? err : ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else if ( !_fIsNetWareInstalled && ( _pmenuitemAllUsers != NULL ))
        {
            POPUP_MENU viewmenu( QueryAppMenu()->QuerySubMenu( 1 ));
            POPUP_MENU helpmenu( QueryAppMenu()->QuerySubMenu(
                                     QueryAppMenu()->QueryItemCount() - 1 ));

            if (  ((err = viewmenu.QueryError()) == NERR_Success )
               && ((err = helpmenu.QueryError()) == NERR_Success )
               // Separator
               && ((err = viewmenu.Remove( 5, MF_BYPOSITION )) == NERR_Success )
               // NetWare Users
               && ((err = viewmenu.Remove( 4, MF_BYPOSITION )) == NERR_Success )
               // All Users
               && ((err = viewmenu.Remove( 3, MF_BYPOSITION )) == NERR_Success )
               // Help Menu
               && ((err = helpmenu.Remove( 4, MF_BYPOSITION )) == NERR_Success )
               // Help Menu separator
               && ((err = helpmenu.Remove( 3, MF_BYPOSITION )) == NERR_Success )
               )
            {
                delete _pmenuitemAllUsers;
                _pmenuitemAllUsers = NULL;
                delete _pmenuitemNetWareUsers;
                _pmenuitemNetWareUsers = NULL;
                _ulViewAcctType = UM_VIEW_ALL_USERS;
                err = SetAdminCaption();
            }
        }

#endif // MINI_USER_MANAGER
    }

    if ( (err == NERR_Success) && fClearFirst )
    {

#if defined(DEBUG) && defined(TRACE)
        DWORD start = ::GetTickCount();
#endif

        if ( (err = _lbUsers.ZapListbox()) == NERR_Success )
        {
            _lbGroups.DeleteAllItems();
        }

#if defined(DEBUG) && defined(TRACE)
        DWORD finish = ::GetTickCount();
        TRACEEOL( "User Manager: OnRefreshNow: clear listboxes took " << finish-start << " ms" );
#endif

    }

    if ( err == NERR_Success )
    {
#if defined(DEBUG) && defined(TRACE)
        DWORD start = ::GetTickCount();
#endif

        err = _lbUsers.RefreshNow();

#if defined(DEBUG) && defined(TRACE)
        DWORD finish = ::GetTickCount();
        TRACEEOL( "User Manager: OnRefreshNow: user listbox refresh took " << finish-start << " ms" );
#endif

        if (fClearFirst && (_lbUsers.QueryCount() > 0) ) // always scroll to top on new focus
        {
            _lbUsers.RemoveSelection();
            _lbUsers.SelectItem( 0 );
            _lbUsers.SetTopIndex( 0 );
            _lbUsers.SetCaretIndex( 0 );
        }

    }

    if (err == NERR_Success)
    {
#if defined(DEBUG) && defined(TRACE)
        DWORD start = ::GetTickCount();
#endif

        err = _lbGroups.RefreshNow();

#if defined(DEBUG) && defined(TRACE)
        DWORD finish = ::GetTickCount();
        TRACEEOL( "User Manager: OnRefreshNow: group listbox refresh took " << finish-start << " ms" );
#endif

        if (fClearFirst) // always scroll to top on new focus
        {
            _lbGroups.RemoveSelection();
            _lbGroups.SetTopIndex( 0 );
            _lbGroups.SetCaretIndex( 0 );
        }
    }

    _lbUsers.ClaimFocus();

    UnlockRefresh();

    //
    // ADMIN_APP::OnRefreshMenuSel will refresh any loaded extensions.
    //
    //
    // RefreshExtensions( QueryHwnd() );

    return err;

}  // UM_ADMIN_APP::OnRefreshNow


/*******************************************************************

    NAME:      UM_ADMIN_APP::SetNetworkFocus

    SYNOPSIS:  Set the focus of the app

    ENTRY:     pchServDomain - the focus to set to

    NOTES:

    HISTORY:
        JonN       29-Jul-1992   Created
        JonN       19-Jan-1992   Added check for local focus

********************************************************************/

APIERR UM_ADMIN_APP::SetNetworkFocus( HWND hwndOwner,
                                      const TCHAR * pchServDomain,
                                      FOCUS_CACHE_SETTING setting )
{

    APIERR err = NERR_Success;

#ifdef    MINI_USER_MANAGER

#ifdef DEBUG
    if ( pchServDomain != NULL && *pchServDomain != TCH('\0') )
    {
        DBGEOL( "UM_ADMIN_APP::SetNetworkFocus: forcing pchServDomain to NULL" );
    }
#endif

    pchServDomain = NULL;

#else  // !MINI_USER_MANAGER

    DBGEOL( "UM_ADMIN_APP::SetNetworkFocus( \"" << pchServDomain << "\" )" );

    //
    // We first check whether we are setting focus to this machine
    // and this machine is in a workgroup.  If so, pchServDomain is the
    // name of this machine without the "\\\\", and we must put the "\\\\"
    // back.  This code was templated from srvmain.cxx.
    //

    NLS_STR nlsWhackComputerName( SZ("\\\\") );
    NLS_STR nlsDomainName;

    {
        NLS_STR nlsComputerName;

        if (   (err = nlsComputerName.QueryError()) != NERR_Success
            || (err = nlsWhackComputerName.QueryError()) != NERR_Success
            || (err = ::GetW32ComputerName( nlsComputerName )) != NERR_Success
            || (err = nlsWhackComputerName.Append( nlsComputerName )) != NERR_Success
           )
        {
            DBGEOL(   "UM_ADMIN_APP::SetNetworkFocus: computer name error "
                     << err );
        }
        else
        {
            TRACEEOL(   "UM_ADMIN_APP::SetNetworkFocus: computer name is \""
                     << nlsComputerName << "\"" );
        }

        if (err == NERR_Success)
        {
            ALIAS_STR nlsServDomain( pchServDomain );

            //
            // Check if focused on self
            //
            if( !::I_MNetComputerNameCompare( nlsWhackComputerName, nlsServDomain ) )
            {
                // focus set to local machine
                DBGEOL( "UM_ADMIN_APP::SetNetworkFocus: explicit focus to self" );
                pchServDomain = nlsWhackComputerName.QueryPch();
            }
            //
            // Check for default focus + local logon
            //
            else if ( nlsServDomain.strlen() == 0 )
            {
                //
                //  Retrieve the logon domain.
                //

                NLS_STR nlsUserName;
                if (   (err = nlsUserName.QueryError()) != NERR_Success
                    || (err = nlsDomainName.QueryError()) != NERR_Success
                    || (err = ::GetW32UserAndDomainName(
                                        nlsUserName,
                                        nlsDomainName )) != NERR_Success
                   )
                {
                    DBGEOL( "UM_ADMIN_APP::SetNetworkFocus: GetW32UserAndDomainName error " << err );
                }
                else if ( !::I_MNetComputerNameCompare(
                                nlsComputerName.QueryPch(),
                                nlsDomainName.QueryPch() ) )
                {
                    //
                    // user is logged on locally
                    //
                    DBGEOL( "UM_ADMIN_APP::SetNetworkFocus: no explicit focus, logged on locally" );
                    pchServDomain = nlsWhackComputerName.QueryPch();
                }
                else
                {
                    //
                    // user is logged on to a domain
                    //
                    DBGEOL( "UM_ADMIN_APP::SetNetworkFocus: no explicit focus, logged on to domain" );
                    pchServDomain = nlsDomainName.QueryPch();
                }
            }
        }
    }

    ASSERT( ( err != NERR_Success ) ||
            ( pchServDomain != NULL && *pchServDomain != TCH('\0') ) );

#endif // !MINI_USER_MANAGER

    if (err == NERR_Success)
    {
        err = UM_SetNetworkFocus( hwndOwner, pchServDomain, setting );
    }

#ifndef MINI_USER_MANAGER

#ifndef FAKE_LANMANNT_FOCUS

    if (   (err == NERR_Success)
        && (pchServDomain != NULL)
        && (pchServDomain[0] == TCH('\\'))
        && (pchServDomain[1] == TCH('\\'))
        && (_umtargetsvrtype == UM_LANMANNT)
       )
    {
#if defined(DEBUG) && defined(TRACE)
        DWORD start = ::GetTickCount();
#endif

        // determine the primary domain name
        // CODEWORK: It would be best if we could use just one API_SESSION
        // instead of this one and the one created by ADMIN_AUTHORITY in
        // OnRefreshNow().
        API_SESSION apisess( pchServDomain );
        LSA_POLICY lsapol( pchServDomain );
        LSA_PRIMARY_DOM_INFO_MEM lsaprim;
        NLS_STR nlsDomainName;
        APIERR err;
        if (   (err = lsapol.QueryError()) != NERR_Success
            || (err = lsaprim.QueryError()) != NERR_Success
            || (err = nlsDomainName.QueryError()) != NERR_Success
            || (err = lsapol.GetPrimaryDomain( &lsaprim )) != NERR_Success
            || (err = lsaprim.QueryName( &nlsDomainName )) != NERR_Success
           )
        {
            return err;
        }

        (void) ::MsgPopup( hwndOwner,
                           IERR_UM_FocusOnLanmanNt,
                           MPSEV_WARNING,
                           MP_OK,
                           pchServDomain,
                           nlsDomainName.QueryPch() );

        err = UM_SetNetworkFocus( hwndOwner, nlsDomainName.QueryPch(), setting );

#if defined(DEBUG) && defined(TRACE)
        DWORD finish = ::GetTickCount();
        TRACEEOL( "User Manager: SetNetworkFocus: focus type check took " << finish-start << " ms" );
#endif
    }
    else
    if (   (err == NERR_Success)
        && (pchServDomain != NULL)
        && (pchServDomain[0] == TCH('\\'))
        && (pchServDomain[1] == TCH('\\'))
        && (_umtargetsvrtype == UM_DOWNLEVEL)
       )
    {
        TRACEEOL( "UM_ADMIN_APP::SetNetworkFocus: checking for downlevel BDC" );

#if defined(DEBUG) && defined(TRACE)
        DWORD start = ::GetTickCount();
#endif

        SERVER_1 srv1( pchServDomain );
        if (   (err = srv1.QueryError()) != NERR_Success
            || (err = srv1.GetInfo()) != NERR_Success
           )
        {
            DBGEOL( "UM_ADMIN_APP::SetNetworkFocus: SERVER_1 error " << err );
            return err;
        }
        if ((srv1.QueryServerType() &
                (SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL)) != 0)
        {
            WKSTA_10 wk10( pchServDomain );
            if (   (err = wk10.QueryError()) != NERR_Success
                || (err = wk10.GetInfo()) != NERR_Success
               )
            {
                DBGEOL( "UM_ADMIN_APP::SetNetworkFocus: WKSTA_10 error " << err );
                return err;
            }

            const TCHAR * pchDomainName = wk10.QueryWkstaDomain();
            ASSERT( pchDomainName != NULL && pchDomainName[0] != TCH('\0') );
            (void) ::MsgPopup( hwndOwner,
                               IERR_UM_FocusOnDownlevelDC,
                               MPSEV_WARNING,
                               MP_OK,
                               pchServDomain,
                               pchDomainName );

            err = UM_SetNetworkFocus( hwndOwner, pchDomainName, setting );
        }

#if defined(DEBUG) && defined(TRACE)
        DWORD finish = ::GetTickCount();
        TRACEEOL( "User Manager: SetNetworkFocus: downlevel focus type check took " << finish-start << " ms" );
#endif

    }

#endif // FAKE_LANMANNT_FOCUS

#endif

    return err;
}

/*******************************************************************

    NAME:      UM_ADMIN_APP::UM_SetNetworkFocus

    SYNOPSIS:  Set the focus of the app

    ENTRY:     pchServDomain - the focus to set to

    NOTES:

    HISTORY:
        JonN       15-Jun-1992   Created
        JonN       19-Feb-1993   RAS-mode extensions

********************************************************************/

APIERR UM_ADMIN_APP::UM_SetNetworkFocus( HWND hwndOwner,
                                         const TCHAR * pchServDomain,
                                         FOCUS_CACHE_SETTING setting )
{
    APIERR err = _lbUsers.ZapListbox();

    if (err == NERR_Success)
        err = ADMIN_APP::SetNetworkFocus( hwndOwner, pchServDomain, setting );

    if ( err == NERR_Success )
    {
#if defined(DEBUG) && defined(TRACE)
        DWORD start = ::GetTickCount();
#endif

        // hydra
        // Default to "Citrix AppServer or Domain" and, if the network focus
        // is a computer name ("\\ prefix"), check to see if the focused
        // server is a Citrix AppServer.
        vfIsCitrixOrDomain = TRUE;

        if (   (pchServDomain != NULL)
            && (pchServDomain[0] == TCH('\\'))
            && (pchServDomain[1] == TCH('\\'))
           )
		{
			SERVER_INFO_101 *psi101;
			
			DWORD dwNetStatus = NetServerGetInfo( ( LPTSTR )pchServDomain , 101 , ( LPBYTE * )&psi101 );

			if( dwNetStatus == NERR_Success )
			{
				if( psi101 != NULL )
				{
					vfIsCitrixOrDomain = ( BOOL )( psi101->sv101_type & SV_TYPE_TERMINALSERVER );

					NetApiBufferFree( ( LPVOID )psi101 );
				}
			}
		}

        // if this is a Domain or Citrix AppServer, fetch the default user
        // configuration for the focused server.
        ULONG ulReturnLength;
        
        ZeroMemory( &_DefaultUserConfig , sizeof( USERCONFIG ) );

        if( vfIsCitrixOrDomain )
        {
            RegDefaultUserConfigQuery( (WCHAR *)QueryLocation().QueryServer(),
                                       &_DefaultUserConfig,
                                       sizeof(_DefaultUserConfig),
                                       &ulReturnLength );
        }

        // hydra end

        BOOL fIsNT;
        enum LOCATION_NT_TYPE locnttype;
        err = ((LOCATION &) QueryLocation()).CheckIfNT( &fIsNT, &locnttype );
        if ( err == NERR_Success )
        {
            if (!fIsNT)
                _umtargetsvrtype = UM_DOWNLEVEL;
            else
            {
                switch (locnttype)
                {
                case LOC_NT_TYPE_LANMANNT:
                    _umtargetsvrtype = UM_LANMANNT;
                    if ( !_fAllowNT5Admin )
                    {
                        WKSTA_10 wk10(((LOCATION &)QueryLocation()).QueryServer());

                        if (   (err = wk10.QueryError()) != NERR_Success
                            || (err = wk10.GetInfo()) != NERR_Success
                           )
                        {
                            DBGEOL( "UM_ADMIN_APP::SetNetworkFocus: WKSTA_10 error " << err );
                            break;
                        }
                        //
                        // Fail if focused on an NT 5 domain
                        //
                        if ( wk10.QueryMajorVer() >= 5 )
                        {
                            err = IERR_UM_FocusOnNT50Domain;
                        }
                    }
                    break;
                case LOC_NT_TYPE_WINDOWSNT:
                case LOC_NT_TYPE_SERVERNT:
                    _umtargetsvrtype = UM_WINDOWSNT;
                    if ( !_fAllowNT5Admin )
                    {
                        WKSTA_10 wk10(((LOCATION &)QueryLocation()).QueryServer());

                        if (   (err = wk10.QueryError()) != NERR_Success
                            || (err = wk10.GetInfo()) != NERR_Success
                           )
                        {
                            DBGEOL( "UM_ADMIN_APP::SetNetworkFocus: WKSTA_10 error " << err );
                            break;
                        }
                        //
                        // Fail if focused on an NT 5 domain
                        //
                        if ( wk10.QueryMajorVer() >= 5 )
                        {
                            err = IERR_UM_FocusOnNT50Domain;
                        }
                    }
                    break;
                case LOC_NT_TYPE_UNKNOWN:
                default:
                    DBGEOL( "User Manager: CheckIfNT(*,*) returned success but also" );
                    DBGEOL( "    an invalid LOG_NT_TYPE.  This should not happen!" );
                    UIASSERT( FALSE );
                    err = ERROR_GEN_FAILURE;
                    break;
                }
            }
        }

#if defined(DEBUG) && defined(TRACE)
        DWORD finish = ::GetTickCount();
        TRACEEOL( "User Manager: UM_SetNetworkFocus: CheckIfNt took " << finish-start << " ms" );
        TRACEEOL( "User Manager: UM_SetNetworkFocus: We shouldn't have to do this twice!" );
#endif
    }

#ifdef    MINI_USER_MANAGER

    if ( (err == NERR_Success) && (_umtargetsvrtype != UM_WINDOWSNT) )
        err = IERR_UM_FullUsrMgrOnWinNt; // CODEWORK not the right error

#else

#ifdef FAKE_LANMANNT_FOCUS
    _umtargetsvrtype = UM_LANMANNT;
#endif // FAKE_LANMANNT_FOCUS

#endif // MINI_USER_MANAGER

    SizeListboxes(); // just in case RAS-mode changed

    // hydra
    // If this is a WinFrame server but not a domain controller,
    // initialize the anonymous user list for change comparison
    // on new focus or exit.
    if ( vfIsCitrixOrDomain && !DoShowGroups() && pchServDomain)
        InitializeAnonymousUserCompareList( pchServDomain );
    //        ctxInitializeAnonymousUserCompareList( pchServDomain );
    // hydra end

    return err;
}


/*******************************************************************

    NAME:       UM_ADMIN_APP::SetAdminCaption

    SYNOPSIS:   Sets the correct caption of the main window

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        thomaspa 03-Aug-1992 Created from ADMIN_APP::SetAdminCaption().

********************************************************************/
APIERR UM_ADMIN_APP :: SetAdminCaption( VOID )
{
    NLS_STR nlsCaption( MAX_RES_STR_LEN );

    if( !nlsCaption )
    {
        return nlsCaption.QueryError();
    }
#ifdef MINI_USER_MANAGER
    APIERR err = nlsCaption.Load( IDS_CAPTION_FOCUS_MINI );

    if( err != NERR_Success )
    {
        return err;
    }
#else // MINI_USER_MANAGER
    const TCHAR  * pszFocus;
    RESOURCE_STR   nlsLocal( IDS_LOCAL_MACHINE );
    const LOCATION     & loc = QueryLocation();

    if( !nlsLocal )
    {
        return nlsLocal.QueryError();
    }

    if( loc.IsServer() )
    {
        pszFocus       = loc.QueryServer();

        if( pszFocus == NULL  )
        {
            pszFocus = nlsLocal.QueryPch();
        }
    }
    else
    {
        //
        //  A LOCATION object should either be a server or a domain.
        //
        UIASSERT( loc.IsDomain());

        pszFocus = loc.QueryDomain();
    }

    const ALIAS_STR nlsFocus( pszFocus );

    const NLS_STR *apnlsParams[2];
    apnlsParams[0] = &nlsFocus;
    apnlsParams[1] = NULL;

    APIERR err = nlsCaption.Load( IDS_CAPTION_FOCUS );

    if( err == NERR_Success )
    {
        err = nlsCaption.InsertParams( apnlsParams );
    }

    if( err != NERR_Success )
    {
        return err;
    }

    if ( QueryViewAcctType() != UM_VIEW_ALL_USERS )
    {
        RESOURCE_STR nlsFiltered( IDS_FILTERED );
        if (  ((err = nlsFiltered.QueryError()) != NERR_Success )
           || ((err = nlsCaption.Append( nlsFiltered )) != NERR_Success )
           )
        {
            return err;
        }
    }

#endif // MINI_USER_MANAGER

    SetText( nlsCaption );

    return NERR_Success;

}   // UM_ADMIN_APP :: SetAdminCaption



/*  Set up the root object of the User Tool application */

SET_ROOT_OBJECT( UM_ADMIN_APP,
                 IDRSRC_APP_BASE, IDRSRC_APP_LAST,
                 IDS_UI_APP_BASE, IDS_UI_APP_LAST );


/*******************************************************************

    NAME:       UM_ADMIN_APP::Fill_UMS_GETSEL

    SYNOPSIS:   Fills a UMS_GETSEL structure with the contents of a USER_LBI

    HISTORY:
        jonn    24-Nov-1992     created

********************************************************************/

VOID UM_ADMIN_APP::Fill_UMS_GETSEL( const USER_LBI * pulbi, UMS_GETSEL * pumsSel )
{
#ifndef UNICODE
    ASSERT( FALSE );
#endif

    ASSERT( pulbi != NULL   && pulbi->QueryError()   == NERR_Success );
    ASSERT( pumsSel != NULL );

    pumsSel->dwRID       = (DWORD) pulbi->QueryRID();
    pumsSel->dwSelType   = (pulbi->QueryIndex() == MAINUSRLB_NORMAL)
                                    ? UM_SELTYPE_NORMALUSER
                                    : UM_SELTYPE_REMOTEUSER;

    pumsSel->pchName = ((_nlsUMExtAccountName.CopyFrom(
                                           pulbi->QueryAccountPtr(),
                                           pulbi->QueryAccountCb() ))
                                 == NERR_Success)
                           ? (LPWSTR)_nlsUMExtAccountName.QueryPch()
                           : NULL;

    pumsSel->pchFullName = ((_nlsUMExtFullName.CopyFrom(
                                           pulbi->QueryFullNamePtr(),
                                           pulbi->QueryFullNameCb() ))
                                 == NERR_Success)
                           ? (LPWSTR)_nlsUMExtFullName.QueryPch()
                           : NULL;

    pumsSel->pchComment = ((_nlsUMExtComment.CopyFrom(
                                           pulbi->QueryCommentPtr(),
                                           pulbi->QueryCommentCb() ))
                                 == NERR_Success)
                           ? (LPWSTR)_nlsUMExtComment.QueryPch()
                           : NULL;

}


/*******************************************************************

    NAME:       UM_ADMIN_APP::Fill_UMS_GETSEL

    SYNOPSIS:   Fills a UMS_GETSEL structure with the contents of a GROUP_LBI

    HISTORY:
        jonn    24-Nov-1992     created

********************************************************************/

VOID UM_ADMIN_APP::Fill_UMS_GETSEL( const GROUP_LBI * pglbi, UMS_GETSEL * pumsSel )
{
#ifndef UNICODE
    ASSERT( FALSE );
#endif

    ASSERT( pglbi != NULL   && pglbi->QueryError()   == NERR_Success );
    ASSERT( pumsSel != NULL );

    pumsSel->dwRID       = 0; // we don't know this
    pumsSel->pchName     = (LPWSTR)(pglbi->QueryName());
    pumsSel->dwSelType   = (pglbi->IsAliasLBI())
                                    ? UM_SELTYPE_LOCALGROUP
                                    : UM_SELTYPE_GLOBALGROUP;
    pumsSel->pchFullName = NULL;
    pumsSel->pchComment  = (LPWSTR)(pglbi->QueryComment());
}

/*******************************************************************

    NAME:       UM_ADMIN_APP::NotifyCreateExtensions

    SYNOPSIS:   Notify loaded extensions of a successful user create

    HISTORY:
        jonn    23-Nov-1992     created

********************************************************************/

void UM_ADMIN_APP::NotifyCreateExtensions( HWND hwndParent,
                                           const USER_2 * puser2 )
{
#ifndef UNICODE
    ASSERT( FALSE );
#endif

    ASSERT( puser2 != NULL && puser2->QueryError() == NERR_Success );

    USRMGR_MENU_EXT_MGR * pUMExtMgr = (USRMGR_MENU_EXT_MGR *)QueryExtMgr();
    UMS_GETSEL umsSel;

    umsSel.dwRID       = (IsDownlevelVariant())
                                    ? 0L
                                    : ((const USER_3 *)puser2)->QueryUserId();
    umsSel.pchName     = (LPWSTR)(puser2->QueryName());
    umsSel.dwSelType   = (   IsDownlevelVariant()
                          || ((const USER_3 *)puser2)->QueryAccountType()
                                                == AccountType_Normal )
                                    ? UM_SELTYPE_NORMALUSER
                                    : UM_SELTYPE_REMOTEUSER;
    umsSel.pchFullName = (LPWSTR)(puser2->QueryFullName());
    umsSel.pchComment  = (LPWSTR)(puser2->QueryComment());

    if ( pUMExtMgr != NULL )
        pUMExtMgr->NotifyCreateExtensions( hwndParent, &umsSel );
}


/*******************************************************************

    NAME:       UM_ADMIN_APP::NotifyCreateExtensions

    SYNOPSIS:   Notify loaded extensions of a successful globalgroup create

    HISTORY:
        jonn    23-Nov-1992     created

********************************************************************/

void UM_ADMIN_APP::NotifyCreateExtensions( HWND hwndParent,
                                           const GROUP_1 * pgroup1 )
{
#ifndef UNICODE
    ASSERT( FALSE );
#endif

    ASSERT( pgroup1 != NULL && pgroup1->QueryError() == NERR_Success );

    USRMGR_MENU_EXT_MGR * pUMExtMgr = (USRMGR_MENU_EXT_MGR *)QueryExtMgr();
    UMS_GETSEL umsSel;

    umsSel.dwRID       = 0L;
    umsSel.pchName     = (LPWSTR)(pgroup1->QueryName());
    umsSel.dwSelType   = UM_SELTYPE_GLOBALGROUP;
    umsSel.pchFullName = NULL;
    umsSel.pchComment  = (LPWSTR)(pgroup1->QueryComment());

    if ( pUMExtMgr != NULL )
        pUMExtMgr->NotifyCreateExtensions( hwndParent, &umsSel );
}


/*******************************************************************

    NAME:       UM_ADMIN_APP::NotifyCreateExtensions

    SYNOPSIS:   Notify loaded extensions of a successful localgroup create

    HISTORY:
        jonn    23-Nov-1992     created

********************************************************************/

void UM_ADMIN_APP::NotifyCreateExtensions( HWND hwndParent,
                                           const NLS_STR & nlsAliasName,
                                           const NLS_STR & nlsComment )
{
#ifndef UNICODE
    ASSERT( FALSE );
#endif

    ASSERT(   nlsAliasName.QueryError() == NERR_Success
           && nlsComment.QueryError()   == NERR_Success );

    USRMGR_MENU_EXT_MGR * pUMExtMgr = (USRMGR_MENU_EXT_MGR *)QueryExtMgr();
    UMS_GETSEL umsSel;

    umsSel.dwRID       = 0L;
    umsSel.pchName     = (LPWSTR)(nlsAliasName.QueryPch());
    umsSel.dwSelType   = UM_SELTYPE_LOCALGROUP;
    umsSel.pchFullName = NULL;
    umsSel.pchComment  = (LPWSTR)nlsComment.QueryPch();

    if ( pUMExtMgr != NULL )
        pUMExtMgr->NotifyCreateExtensions( hwndParent, &umsSel );
}


/*******************************************************************

    NAME:       UM_ADMIN_APP::NotifyDeleteExtensions

    SYNOPSIS:   Notify loaded extensions of a successful user delete

    HISTORY:
        jonn    23-Nov-1992     created

********************************************************************/

void UM_ADMIN_APP::NotifyDeleteExtensions( HWND hwndParent,
                                           const USER_LBI * pulbi )
{
    USRMGR_MENU_EXT_MGR * pUMExtMgr = (USRMGR_MENU_EXT_MGR *)QueryExtMgr();
    UMS_GETSEL umsSel;

    Fill_UMS_GETSEL( pulbi, &umsSel );

    if ( pUMExtMgr != NULL )
        pUMExtMgr->NotifyDeleteExtensions( hwndParent, &umsSel );
}


/*******************************************************************

    NAME:       UM_ADMIN_APP::NotifyDeleteExtensions

    SYNOPSIS:   Notify loaded extensions of a successful group delete

    HISTORY:
        jonn    23-Nov-1992     created

********************************************************************/

void UM_ADMIN_APP::NotifyDeleteExtensions( HWND hwndParent,
                                           const GROUP_LBI * pglbi )
{
    USRMGR_MENU_EXT_MGR * pUMExtMgr = (USRMGR_MENU_EXT_MGR *)QueryExtMgr();
    UMS_GETSEL umsSel;

    Fill_UMS_GETSEL( pglbi, &umsSel );

    if ( pUMExtMgr != NULL )
        pUMExtMgr->NotifyDeleteExtensions( hwndParent, &umsSel );
}


/*******************************************************************

    NAME:       UM_ADMIN_APP::ConfirmNewObjectName

    SYNOPSIS:   Checks to make sure that the proposed name for a new
                user or group does not collide with the name of an
                existing buildin local group.  SAM and LSA allow us to
                create such a user or group, but we do not allow it here
                to avoid confusing the user.

    RETURN:     NERR_GroupExists if the name is the name of a local group
                other errors as appropriate

    NOTE:       We cannot guarantee that such a user or group will never
                be created as long as SAM and LSA allow it, but we do wish
                to minimize the likelihood.

    HISTORY:
        jonn    15-Jan-1993     created

********************************************************************/

APIERR UM_ADMIN_APP::ConfirmNewObjectName( const TCHAR * pszObjectName )
{
    APIERR err = NERR_Success;

    if ( !IsDownlevelVariant() )
    {
        SAM_RID_MEM samrm;
        SAM_SID_NAME_USE_MEM samsnum;

        if (   (err = samrm.QueryError()) == NERR_Success
            && (err = samsnum.QueryError()) == NERR_Success
            // don't save error code from this API call, errors here are OK
            && QueryAdminAuthority()->QueryBuiltinDomain()->TranslateNamesToRids(
                                     &pszObjectName,
                                     1,
                                     &samrm,
                                     &samsnum) == NERR_Success
        //
        // If we get an error looking it up, assume it is ok to try to add.
        // Otherwise, if the api is successful and gives us back a valid RID,
        // return telling the user the group already exists.
        // CODEWORK: should we check for other errors.
        //
            && samrm.QueryRID(0) != 0
           )
        {
            TRACEEOL( "UM_ADMIN_APP::ConfirmNewObjectName: conflict with builtin alias " << pszObjectName );
            err = NERR_GroupExists;
        }
    }

    return err;
}


/*******************************************************************

    NAME:       UM_ADMIN_APP::NotifyRenameExtensions

    SYNOPSIS:   Notify loaded extensions of a successful user rename

    HISTORY:
        jonn    23-Nov-1991     created

********************************************************************/

void UM_ADMIN_APP::NotifyRenameExtensions( HWND hwndParent,
                                           const USER_LBI * pulbi,
                                           const TCHAR * pchNewName )
{
    USRMGR_MENU_EXT_MGR * pUMExtMgr = (USRMGR_MENU_EXT_MGR *)QueryExtMgr();
    UMS_GETSEL umsSel;

    Fill_UMS_GETSEL( pulbi, &umsSel );

    if ( pUMExtMgr != NULL )
        pUMExtMgr->NotifyRenameExtensions( hwndParent, &umsSel, pchNewName );
}


/*******************************************************************

    NAME:       ::PingFocus

    SYNOPSIS:   Checks whether server of focus is reachable.

    RETURNS:    LanMan error code, NERR_Success iff the server is reachable.

    NOTES:      When a New User/Group dialog is requested, we first check
                whether the server in question is reachable.  This
                delays the appearance of the dialog, but protects the
                users from entering lengthy changes when the server is
                down and the changes will be lost (unless the server
                goes down while the dialog is active).

                Note that this is only necessary for New User/Group
                variants (excluding Copy variants), otherwise GetInfo
                will turn up this problem.

                We do not bother to ping the server in Mini-User
                Manager, since the server is not needed.

    HISTORY:
        jonn     02-Dec-1991     Created
        jonn     04-Jun-1992     Always succeeds for Mini-User Manager

********************************************************************/

APIERR PingFocus( const LOCATION & loc )
{

#ifndef MINI_USER_MANAGER

#if defined(DEBUG) && defined(TRACE)
        DWORD start = ::GetTickCount();
#endif

    SERVER_0 srv0( loc.QueryServer() );
    APIERR err = NERR_Success;
    if (   (err = srv0.QueryError()) != NERR_Success
        || (err = srv0.GetInfo()) != NERR_Success)
    {
        DBGEOL( "User Manager: PingFocus() failure " << err );
        return err;
    }

#if defined(DEBUG) && defined(TRACE)
        DWORD finish = ::GetTickCount();
        TRACEEOL( "User Manager: PingFocus took " << finish-start << " ms" );
#endif

#endif // MINI_USER_MANAGER

    return NERR_Success;

}  // ::PingFocus



/*************************************************************************

    NAME:       ::IsBlankPasswordAllowed

    SYNOPSIS:   Checks whether blank passwords are allowed

    INTERFACE:  pchServer              - server name
                pfBlankPasswordAllowed

    RETURNS:    error code

    USES:       USER_MODALS

    HISTORY:    JonN      13-Apr-1992     Created

**************************************************************************/

APIERR ReadBlankPasswordAllowed( const TCHAR * pchServer,
                                 BOOL * pfBlankPasswordAllowed )
{
    // pchServer may be NULL
    ASSERT( pfBlankPasswordAllowed != NULL );
    USER_MODALS umInfo( pchServer );
    APIERR err = umInfo.GetInfo();
    if ( err == NERR_Success )
    {
        *pfBlankPasswordAllowed = (umInfo.QueryMinPasswdLen() == 0);
    }

#ifdef DEBUG
    if ( err != NERR_Success )
    {
        DBGEOL( "::IsBlankPasswordAllowed: error = " << err );
    }
#endif // DEBUG

    return err;
}



/*************************************************************************

    NAME:       ::WriteBlankPasswordAllowed

    SYNOPSIS:   Changes whether blank passwords are allowed

    INTERFACE:  pchServer              - server name
                fBlankPasswordAllowed

    RETURNS:    error code

    USES:       USER_MODALS

    HISTORY:    JonN      13-Apr-1992     Created

**************************************************************************/

APIERR WriteBlankPasswordAllowed( const TCHAR * pchServer,
                                  BOOL fBlankPasswordAllowed )
{
    // pchServer may be NULL
    USER_MODALS umInfo( pchServer );
    APIERR err = umInfo.GetInfo();
    if (  err != NERR_Success ||
         (err = umInfo.SetMinPasswdLen( fBlankPasswordAllowed
                               ? 0
                               : MIN_PASS_LEN_DEFAULT )) != NERR_Success ||
         (err = umInfo.WriteInfo()) != NERR_Success )
    {
        DBGEOL( "::WriteBlankPasswordAllowed: error = " << err );
    }

    return err;
}


// USERPROP_DLG::OnCommand() has been moved to from userprop.cxx to
//  usrmain.cxx!  This allows allow MUM to avoid linking unnecessary
//  subproperty dialogs.
//  JonN 05/15/92


/*******************************************************************

    NAME:       USERPROP_DLG::OnCommand

    SYNOPSIS:   button handler

    ENTRY:      ce -            Notification event

    RETURNS:    TRUE if action was taken
                FALSE otherwise

    NOTES:      These buttons call up subdialogs.  These subdialogs are
                subclasses of PROP_DLG, so it should not be necessary to
                Process() them if GetInfo() fails.  However, for reasons
                unknown to BenG and myself, this does strange things.
                As a hack, we force an IDCANCEL into the queue so that
                the dialog will disappear immediately.

    HISTORY:
               JonN  17-Jul-1991    created
               JonN  28-Apr-1992    Enabled NT focus dialogs

********************************************************************/

BOOL USERPROP_DLG::OnCommand( const CONTROL_EVENT & ce )
{
    // created with NEW to avoid stack overflow
    USER_SUBPROP_DLG * psubpropDialog = NULL;

    APIERR err = ERROR_NOT_ENOUGH_MEMORY; // if dialog not allocated

    CID cid = ce.QueryCid();

    if (cid == IDUP_CB_ISNETWAREUSER)
    {
        // hydra
        if (_apgbButtons[7] != NULL)
            _apgbButtons[7]->Enable (_pcbIsNetWareUser->IsChecked());
        /* original code
        if (_apgbButtons[6] != NULL)
            _apgbButtons[6]->Enable (_pcbIsNetWareUser->IsChecked());
            */
        else
            _apgbButtons[3]->Enable (_pcbIsNetWareUser->IsChecked());
    }

    // hydra
    if ( (cid < IDUP_GB_1) || (cid > IDUP_GB_8) )
    /* original code
    if ( (cid < IDUP_GB_1) || (cid > IDUP_GB_7) )
    */
        return PROP_DLG::OnCommand( ce ) ;

    enum UM_SUBDIALOG_TYPE subdlgType = QuerySubdialogType(cid-IDUP_GB_1);

    switch ( subdlgType )
    {

#ifndef MINI_USER_MANAGER
    case UM_SUBDLG_DETAIL:
        switch (QueryTargetServerType())
        {
        case UM_LANMANNT:
        case UM_WINDOWSNT:
            psubpropDialog = new USERACCT_DLG_NT( this, _pulb );
            break;
        case UM_DOWNLEVEL:
            psubpropDialog = new USERACCT_DLG_DOWNLEVEL( this, _pulb );
            break;
        default:
            ASSERT( FALSE );
            break;
        }
        break;
#endif // MINI_USER_MANAGER

    case UM_SUBDLG_GROUPS:
        psubpropDialog = new USER_MEMB_DIALOG( this, _pulb );
        break;

#ifndef MINI_USER_MANAGER
    case UM_SUBDLG_HOURS:
        psubpropDialog = new USERLOGONHRS_DLG( this, _pulb );
        break;

    case UM_SUBDLG_VLW:
        psubpropDialog = new VLW_DIALOG( this, _pulb );
        break;

#endif // MINI_USER_MANAGER

    case UM_SUBDLG_DIALIN:
        psubpropDialog = new DIALIN_PROP_DLG( this, _pulb );
        break;

    case UM_SUBDLG_NCP:
        psubpropDialog = new NCP_DIALOG( this, _pulb );
        break;

    case UM_SUBDLG_PROFILES:
        switch (QueryTargetServerType())
        {
        case UM_LANMANNT:
        case UM_WINDOWSNT:
            psubpropDialog = new USERPROF_DLG_NT( this, _pulb );
            break;
#ifndef MINI_USER_MANAGER
        case UM_DOWNLEVEL:
            psubpropDialog = new USERPROF_DLG_DOWNLEVEL( this, _pulb );
            break;
#endif // MINI_USER_MANAGER
        default:
            ASSERT( FALSE );
            break;
        }
        break;

     // hydra
     /*
      * We use the unused 'Privileges' button to invoke Citrix User
      * Configuration editing.
      */
    case UM_SUBDLG_PRIVS:
        psubpropDialog = new UCEDIT_DLG( this, _pulb );
        break;
    // hydra end


    case UM_SUBDLG_NONE:
        return TRUE; // pressed button which is not defined for this focus

    default:
        ASSERT( FALSE ); // invalid value
        ::MsgPopup( this, ERROR_NOT_SUPPORTED );
        return TRUE;

    }

    if ( psubpropDialog != NULL )
    {
        err = NERR_Success;
        // CODEWORK should not Process() if GetInfo returns FALSE
        if ( psubpropDialog->GetInfo() )
            err = psubpropDialog->Process(); // Dismiss code not used
        delete psubpropDialog;
    }


    if ( err != NERR_Success )
        ::MsgPopup( this, err );

    return TRUE;

}// USERPROP_DLG::OnCommand


/*******************************************************************

    NAME:       UM_ADMIN_APP::SetRasMode

    SYNOPSIS:   Notify possible change in RAS mode

    HISTORY:
        jonn    19-Feb-1993     created

********************************************************************/

void UM_ADMIN_APP::SetRasMode( BOOL fRasMode )
{

#ifdef MINI_USER_MANAGER

    fRasMode = FALSE; // CODEWORK not the best way to kill RAS mode

#endif

    ADMIN_APP::SetRasMode( fRasMode );

#ifndef    MINI_USER_MANAGER

    SetDomainSources( fRasMode? BROWSE_LM2X_DOMAINS
                              : BROWSE_LOCAL_DOMAINS );

    SizeListboxes();

#endif // MINI_USER_MANAGER

}


/*******************************************************************

    NAME:       RASSELECT_DIALOG

    SYNOPSIS:   Ask for the name of one or more users or one group,
                then change the contents of the listboxes so the
                users or group are selected.

    ENTRY:      fAllowGlobalGroup       - allow global group selection
                fRenameUser             - Rename User variant, only
                                          allow user selection and change
                                          error messages accordingly
                fCopy                   - do not allow multiple user selection
                FindAccountsNT          - Check to make sure that the
                                          indicated users or group actually
                                          exists for NT focus
                FindAccountsDownlevel   - Check to make sure that the
                                          indicated users or group actually
                                          exists for downlevel focus
                ParseNames              - Parse a semicolon-delimited name
                                          list into individual names, and
                                          return in a STRLIST

    HISTORY:
        jonn    26-Feb-1993     created
        jonn    04-Apr-1993     multiple user selection

********************************************************************/

class RASSELECT_DIALOG : public DIALOG_WINDOW
{
private:
    NLS_STR _nlsName;
    SLT _sltText;
    SLE _sleName;
    ULONG _ulHelpTopic;
    UM_ADMIN_APP * _pumadminapp;
    BOOL _fAllowGlobalGroup;
    BOOL _fRenameUser;
    BOOL _fCopy;

#ifndef MINI_USER_MANAGER
    APIERR FindAccountsDownlevel( const TCHAR * const * ppchNames,
                                  ULONG cNames,
                                  SID_NAME_USE * psiduseAllParsedNames,
                                  const TCHAR * * ppchNameInError );
#endif
    APIERR FindAccountsNT(        const TCHAR * const * ppchNames,
                                  ULONG * aulRids,
                                  ULONG cNames,
                                  SID_NAME_USE * psiduseAllParsedNames,
                                  BOOL * pfBuiltinAlias,
                                  const TCHAR * * ppchNameInError );
    APIERR ParseNames( STRLIST ** ppstrlist, const TCHAR * pchNameList );

protected:
    virtual BOOL OnOK( void );
    virtual ULONG QueryHelpContext();

public:
    RASSELECT_DIALOG( HWND hwndOwner,
                      MSGID msgidTitle,
                      MSGID msgidText,
                      ULONG ulHelpTopic,
                      UM_ADMIN_APP * pumadminapp,
                      BOOL fAllowGlobalGroup,
                      BOOL fRenameUser,
                      BOOL fCopy );
    ~RASSELECT_DIALOG();
};

RASSELECT_DIALOG::RASSELECT_DIALOG( HWND hwndOwner,
                                    MSGID msgidTitle,
                                    MSGID msgidText,
                                    ULONG ulHelpTopic,
                                    UM_ADMIN_APP * pumadminapp,
                                    BOOL fAllowGlobalGroup,
                                    BOOL fRenameUser,
                                    BOOL fCopy )
    : DIALOG_WINDOW( IDD_RAS_SELECT, hwndOwner ),
      _sltText( this, IDC_RasSel_Text ),
      _sleName( this, IDC_RasSel_Edit ), // no limit, multiple selection
      _ulHelpTopic( ulHelpTopic ),
      _pumadminapp( pumadminapp ),
      _fAllowGlobalGroup( fAllowGlobalGroup ),
      _fRenameUser( fRenameUser ),
      _fCopy( fCopy )
{
    if ( QueryError() != NERR_Success )
        return;

    ASSERT( _pumadminapp != NULL && _pumadminapp->QueryError() == NERR_Success );

    RESOURCE_STR resstrTitle( msgidTitle );
    RESOURCE_STR resstrText( msgidText );
    APIERR err = NERR_Success;
    if (   (err = resstrTitle.QueryError()) != NERR_Success
        || (err = resstrText.QueryError()) != NERR_Success
       )
    {
        DBGEOL( "User Manager: RASSELECT_DIALOG: could not load title" );
        ReportError( err );
        return;
    }

    SetText( resstrTitle );
    _sltText.SetText( resstrText );
}

RASSELECT_DIALOG::~RASSELECT_DIALOG()
{
    // nothing
}

BOOL RASSELECT_DIALOG::OnOK( void )
{
    APIERR err = _sleName.QueryText( &_nlsName );

    STRLIST * pstrlistParsedNames = NULL;
    if (err == NERR_Success)
        err = ParseNames ( &pstrlistParsedNames, _nlsName.QueryPch() );
    ASSERT( err != NERR_Success || pstrlistParsedNames != NULL );

    const TCHAR * pchNameInError = NULL;
    BOOL fNoNames = FALSE;

    do // false loop
    {
        if (err != NERR_Success)
            break;

        UINT cNames = pstrlistParsedNames->QueryNumElem();
        if (cNames == 0)
        {
            fNoNames = TRUE; // no names to look up
            break;
        }

        if (cNames > 1)
        {
            if ( _fRenameUser )
            {
                err = IDS_RAS_CANT_RENAME_MULTIPLE;
                break;
            }
            else if ( _fCopy )
            {
                err = IDS_RAS_CANT_COPY_MULTIPLE;
                break;
            }
        }

        BUFFER bufferNames( cNames * sizeof(TCHAR *) );
        BUFFER bufferRids( cNames * sizeof(ULONG) );
        if (   (err = bufferNames.QueryError()) != NERR_Success
            || (err = bufferRids.QueryError()) != NERR_Success
           )
        {
            break;
        }

        const TCHAR * * apchNames = (const TCHAR * *) bufferNames.QueryPtr();
        ULONG * aulRids = (ULONG *) bufferRids.QueryPtr();
        SID_NAME_USE siduseAllParsedNames = SidTypeUser;
        BOOL fBuiltinAlias = FALSE;

        {
            ITER_STRLIST itersl( *pstrlistParsedNames );
            for (INT i = 0; i < (INT)cNames; i++)
            {
                NLS_STR * pnls = itersl.Next();
                ASSERT( pnls != NULL );
                apchNames[i] = pnls->QueryPch();
                aulRids[i] = 0;
            }
        }

#ifndef MINI_USER_MANAGER

        if ( _pumadminapp->IsDownlevelVariant() )
        {
            err = FindAccountsDownlevel( apchNames,
                                         cNames,
                                         &siduseAllParsedNames,
                                         &pchNameInError );
        }
        else

#endif // MINI_USER_MANAGER

        {

            err = FindAccountsNT( apchNames,
                                  aulRids,
                                  cNames,
                                  &siduseAllParsedNames,
                                  &fBuiltinAlias,
                                  &pchNameInError );

        }

        if (err != NERR_Success)
            break;

        switch (siduseAllParsedNames)
        {
        case SidTypeUser:
            ASSERT( !fBuiltinAlias );
            err = _pumadminapp->RasSelectUsers( apchNames, aulRids, cNames );
            break;
        case SidTypeGroup:
            ASSERT( !fBuiltinAlias );
            pchNameInError = apchNames[ 0 ];
#ifdef MINI_USER_MANAGER
            DBGEOL( "RASSELECT_DIALOG::OnOK: global group in MUM" );
            err = IDS_RAS_ACCOUNT_NOT_FOUND;
#else
            if (_fRenameUser)
            {
                err = IDS_RAS_CANT_RENAME_GROUP;
            }
            else if (!_fAllowGlobalGroup)
            {
                err = IDS_RAS_CANT_EDIT_GLOB_GRP;
            }
            else if (cNames > 1)
            {
                err = IDS_RAS_CANT_MIX_TYPES;
            }
            else
            {
                err = _pumadminapp->RasSelectGroup( apchNames[0], aulRids[0] );
            }
#endif
            break;
        case SidTypeAlias:
            pchNameInError = apchNames[ 0 ];
            if (_fRenameUser)
            {
                err = IDS_RAS_CANT_RENAME_GROUP;
            }
            else if (cNames > 1)
            {
                err = IDS_RAS_CANT_MIX_TYPES;
            }
            else
            {
                err = _pumadminapp->RasSelectAlias( apchNames[0], aulRids[0], fBuiltinAlias );
            }
            break;
        default:
            ASSERT( FALSE );
            err = IDS_RAS_CANT_MIX_TYPES;
            break;
        }

    } while (FALSE); // false loop

    switch (err)
    {
    case NERR_Success:
        if (fNoNames)
        {
            TRACEEOL( "RASSELECT_DIALOG::OnOK(): No names in STRLIST, ignoring OnOK" );
        }
        else
        {
            Dismiss( TRUE );
        }
        break;
    default:
        _sleName.SelectString();
        _sleName.ClaimFocus();
        ::MsgPopup( this, err, MPSEV_ERROR, 1, pchNameInError );
        break;
    }

    delete pstrlistParsedNames;

    return TRUE;
}

// make sure the correct type of object was used, and get the RID
// try both SAM domains
APIERR RASSELECT_DIALOG::FindAccountsNT( const TCHAR * const * apchNames,
                                         ULONG * aulRids,
                                         ULONG cNames,
                                         SID_NAME_USE * psiduseAllParsedNames,
                                         BOOL * pfBuiltinAlias,
                                         const TCHAR * * ppchNameInError )
{
    ASSERT(   apchNames != NULL && aulRids != NULL && cNames > 0
           && psiduseAllParsedNames != NULL && pfBuiltinAlias != NULL
           && ppchNameInError != NULL );

    APIERR err = NERR_Success;

    *pfBuiltinAlias = FALSE;
    *ppchNameInError = NULL;

    SAM_RID_MEM SAMRidMemAccounts ;
    SAM_RID_MEM SAMRidMemBuiltin ;
    SAM_SID_NAME_USE_MEM SAMSidUseAccounts ;
    SAM_SID_NAME_USE_MEM SAMSidUseBuiltin ;
    ADMIN_AUTHORITY * padminauth = (ADMIN_AUTHORITY *) _pumadminapp->QueryAdminAuthority();
    SAM_DOMAIN * psamdomAccount = padminauth->QueryAccountDomain();
    SAM_DOMAIN * psamdomBuiltin = padminauth->QueryBuiltinDomain();

    do // false loop
    {
        if ( (err = SAMRidMemAccounts.QueryError()) != NERR_Success ||
             (err = SAMRidMemBuiltin.QueryError()) != NERR_Success ||
             (err = SAMSidUseAccounts.QueryError()) != NERR_Success ||
             (err = SAMSidUseBuiltin.QueryError()) != NERR_Success
           )
        {
            TRACEEOL( "RASSELECT_DIALOG: initialization error " << err );
            break;
        }

        //
        // First, try to look up all the names in the Accounts database alone
        //
        err = psamdomAccount->TranslateNamesToRids(
          			apchNames,
          			cNames,
          			&SAMRidMemAccounts,
          			&SAMSidUseAccounts );

        BOOL fSomeFound = TRUE;
        BOOL fAllFound = TRUE;
        BOOL fAccountsLookupSucceeded = TRUE;
        INT iMissingName = 0;
        if (err == NERR_GroupNotFound) // none found
        {
            fSomeFound = FALSE;
            fAllFound = FALSE;
            fAccountsLookupSucceeded = FALSE;
            iMissingName = 0;
            err = NERR_Success;
        }
        else if (err != NERR_Success)
        {
            TRACEEOL( "RASSELECT_DIALOG: Accounts domain lookup error " << err );
            break;
        }
        else
        {
            // scan for names which were not found

            fSomeFound = FALSE;
            for ( INT iName = 0;
                  fAllFound && (iName < (INT)cNames);
                  iName++ )
            {
                if (SAMRidMemAccounts.QueryRID(iName) == 0)
                {
                    if (iMissingName < 0)
                        iMissingName = iName;
                    fAllFound = FALSE;
                }
                else
                {
                    fSomeFound = TRUE;
                }
            }
        }
        //
        // At this point, err == NERR_Success, and either fAllFound is TRUE,
        // or iMissingName is the index of a name not found in the
        // Accounts domain.
        //

        //
        // If at least one account was found in the Accounts domain, then
        // it doesn't matter how many are found in the Builtin domain
        //
        if (fSomeFound && !fAllFound)
        {
            err = IDS_RAS_CANT_MIX_TYPES;
            break;
        }

        //
        // If no accounts are in the Accounts database, see if the
        // accounts are in the Builtin domain
        //
        if ( !fAllFound )
        {
            err = psamdomBuiltin->TranslateNamesToRids(
              			apchNames,
              			cNames,
              			&SAMRidMemBuiltin,
              			&SAMSidUseBuiltin );

            fAllFound = TRUE;
            if (err == NERR_GroupNotFound) // none found
            {
                fAllFound = FALSE;
                // leave iMissingName at its current value
                err = NERR_Success;
            }
            else if (err != NERR_Success)
            {
                TRACEEOL( "RASSELECT_DIALOG: Builtin domain lookup error " << err );
                break;
            }
            else
            {
                // scan for names which were not found in either domain

                for ( iMissingName = 0;
                      fAllFound && (iMissingName < (INT)cNames);
                      iMissingName++ )
                {
                    if (   (   (!fAccountsLookupSucceeded)
                            || (SAMRidMemAccounts.QueryRID(iMissingName) == 0)
                           )
                        && SAMRidMemBuiltin.QueryRID(iMissingName) == 0 )
                    {
                        fAllFound = FALSE;
                        break;
                    }
                }
            }
        }

        if ( !fAllFound )
        {
            ASSERT( iMissingName >= 0 && iMissingName < (INT)cNames );
            *ppchNameInError = apchNames[ iMissingName ];
            err = IDS_RAS_ACCOUNT_NOT_FOUND;
            TRACEEOL( "RASSELECT_DIALOG: some account not found " << err );
            break;
        }

        //
        // All the names were found.  Make sure they are all of the same type.
        //

        if ( fAccountsLookupSucceeded && (SAMRidMemAccounts.QueryRID(0) != 0) )
        {
            *psiduseAllParsedNames = SAMSidUseAccounts.QueryUse(0);
            aulRids[0] = SAMRidMemAccounts.QueryRID(0);
        }
        else
        {
            *psiduseAllParsedNames = SAMSidUseBuiltin.QueryUse(0);
            ASSERT( *psiduseAllParsedNames == SidTypeAlias );
            aulRids[0] = SAMRidMemBuiltin.QueryRID(0);
            *pfBuiltinAlias = TRUE;
        }

        if ( cNames > 1 )
        {
            if ( *psiduseAllParsedNames != SidTypeUser )
            {
                err = IDS_RAS_CANT_MIX_TYPES;
                TRACEEOL( "RASSELECT_DIALOG: first of multiple accounts not a user account " << err );
                break;
            }

            INT iName;
            for ( iName = 1; iName < (INT)cNames; iName++ )
            {
                if ( (!fAccountsLookupSucceeded) || (SAMRidMemAccounts.QueryRID(iName) == 0) )
                {
                    err = IDS_RAS_CANT_MIX_TYPES;
                    TRACEEOL( "RASSELECT_DIALOG: subsequent account not in Accounts domain " << err );
                    break;
                }
                else if ( SAMSidUseAccounts.QueryUse(iName) != SidTypeUser )
                {
                    err = IDS_RAS_CANT_MIX_TYPES;
                    TRACEEOL( "RASSELECT_DIALOG: subsequent account not a user account " << err );
                    break;
                }
                else
                {
                    aulRids[iName] = SAMRidMemAccounts.QueryRID(iName);
                }
            }
        }

    } while (FALSE); // false loop

    return err;

}

#ifndef MINI_USER_MANAGER

APIERR RASSELECT_DIALOG::FindAccountsDownlevel( const TCHAR * const * apchNames,
                                                ULONG cNames,
                                                SID_NAME_USE * psiduseAllParsedNames,
                                                const TCHAR * * ppchNameInError )
{
    ASSERT(   apchNames != NULL && cNames > 0
           && psiduseAllParsedNames != NULL
           && ppchNameInError != NULL );

    APIERR err = NERR_Success;

    INT iName;
    for ( iName = 0; (err == NERR_Success) && (iName < (INT)cNames); iName++ )
    {
        const TCHAR * pchThisName = apchNames[ iName ];
        SID_NAME_USE siduseThisName = SidTypeUnknown;

        // USER_0 not implemented
        USER_11 user11( pchThisName, _pumadminapp->QueryLocation() );
        if ( (err = user11.QueryError()) == NERR_Success )
        {
            err = user11.GetInfo();
            if (err == NERR_Success)
            {
                siduseThisName = SidTypeUser;
            }
            else if ( err == NERR_UserNotFound )
            {
                // GROUP_0 not implemented
                GROUP_1 group1( pchThisName, _pumadminapp->QueryLocation() );
                if ( (err = group1.QueryError()) == NERR_Success )
                {
                    err = group1.GetInfo();
                    if (err == NERR_Success)
                    {
                        siduseThisName = SidTypeGroup;
                    }
                    else if (err == NERR_GroupNotFound)
                    {
                        err = IDS_RAS_ACCOUNT_NOT_FOUND;
                        *ppchNameInError = pchThisName;
                    }
                }
            }

            if ( err != NERR_Success )
            {
                TRACEEOL( "RASSELECT_DIALOG: error " << err << " on name " << pchThisName );
            }
            else if ( iName == 0 )
            {
                if ( siduseThisName != SidTypeUser && cNames > 1 )
                {
                    err = IDS_RAS_CANT_MIX_TYPES;
                    TRACEEOL( "RASSELECT_DIALOG: first of multiple accounts not a user account " << err );
                    break;
                }
                *psiduseAllParsedNames = siduseThisName;
            }
            else // iName > 0
            {
                if ( siduseThisName != SidTypeUser )
                {
                    err = IDS_RAS_CANT_MIX_TYPES;
                    TRACEEOL( "RASSELECT_DIALOG: subsequent account not a user account " << err );
                    break;
                }
            }

        }
    }

    return err;
}

#endif // MINI_USER_MANAGER


APIERR RASSELECT_DIALOG::ParseNames( STRLIST ** ppstrlist,
                                     const TCHAR * pchNameList )
{
    ASSERT( ppstrlist != NULL && pchNameList != NULL );

    APIERR err = NERR_Success;

    *ppstrlist = new STRLIST( pchNameList, RASSELECT_SEPARATOR );
    if ( ppstrlist == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ITER_STRLIST itersl( **ppstrlist );
    NLS_STR * pnls = itersl.Next();
    while ( pnls != NULL )
    {
        // ::TrimLeading() and ::TrimTrailing() are in slestrip.hxx
        if (   (err = ::TrimLeading( pnls, WHITE_SPACE )) != NERR_Success
            || (err = ::TrimTrailing( pnls, WHITE_SPACE )) != NERR_Success
           )
        {
            DBGEOL( "RASSEL: ::Trim error " << err );
            break;
        }

        //
        // Remove all empty strings from the STRLIST,
        // and suppress duplicates
        //
        BOOL fRemoveThisItem = (pnls->strlen() == 0);
        if (!fRemoveThisItem)
        {
            ITER_STRLIST itersl2( **ppstrlist );
            NLS_STR * pnls2;
            while ( (pnls2 = itersl2.Next()) != NULL )
            {
                if (pnls == pnls2) // pointer equality
                {
                    break;
                }
                else if (0 == pnls->_stricmp( *pnls2 )) // string equality
                {
                    fRemoveThisItem = TRUE;
                    break;
                }
            }
        }

        if (fRemoveThisItem)
        {
            NLS_STR * pnlsTemp = (*ppstrlist)->Remove( itersl );
            ASSERT( pnlsTemp != NULL );
            delete pnlsTemp;
            pnls = itersl.QueryProp(); // don't skip next item
        }
        else
        {
            pnls = itersl.Next();
        }
    }

    if (err != NERR_Success)
    {
        delete *ppstrlist;
        *ppstrlist = NULL;
    }

    return err;
}

ULONG RASSELECT_DIALOG::QueryHelpContext()
{
    return _ulHelpTopic;
}


/*******************************************************************

    NAME:       UM_ADMIN_APP::RasSelectUsers
                              RasSelectGroup
                              RasSelectAlias

    SYNOPSIS:   Change the contents of the listboxes so that user(s)/group
                is/are selected.

    HISTORY:
        jonn    26-Feb-1993     created

********************************************************************/

APIERR UM_ADMIN_APP::RasSelectUsers( const TCHAR * * apchNames,
                                     ULONG * aulRids,
                                     UINT nUsers )
{
    ASSERT( apchNames != NULL && aulRids != NULL );

    APIERR err = _lbUsers.ZapListbox();

    if (err == NERR_Success)
        _lbGroups.DeleteAllItems();

    INT i;
    for (i = 0; i < (INT)nUsers && err == NERR_Success; i++ )
    {
        ASSERT( apchNames[i] != NULL );
        USER_LBI * pulbi = new USER_LBI( apchNames[i],
                                         NULL,
                                         NULL,
                                         &_lbUsers,
                                         aulRids[i]
                                         );
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   pulbi == NULL
            || (err = pulbi->QueryError()) != NERR_Success
           )
        {
            delete pulbi;
        }
        else
        {
            INT iPos = _lbUsers.AddItem( pulbi );
            if (iPos < 0)
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                _lbUsers.SelectItem( iPos );
            }
        }
    }

    return err;
}


#ifndef MINI_USER_MANAGER
APIERR UM_ADMIN_APP::RasSelectGroup( const TCHAR * pchName,
                                     ULONG ulRid )
{
    UNREFERENCED( ulRid );

    ASSERT( pchName != NULL );

    APIERR err = _lbUsers.ZapListbox();

    if (err == NERR_Success)
    {
        _lbGroups.DeleteAllItems();

        GROUP_LBI * plbi = new GROUP_LBI( pchName,
                                          NULL );
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   plbi == NULL
            || (err = plbi->QueryError()) != NERR_Success
           )
        {
            delete plbi;
        }
        else
        {
            INT iPos = _lbGroups.AddItem( plbi );
            if (iPos < 0)
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                _lbGroups.SelectItem( iPos );
            }
        }
    }

    return err;
}
#endif // MINI_USER_MANAGER


APIERR UM_ADMIN_APP::RasSelectAlias( const TCHAR * pchName,
                                     ULONG ulRid,
                                     BOOL fBuiltIn )
{
    ASSERT( pchName != NULL );

    APIERR err = _lbUsers.ZapListbox();

    if (err == NERR_Success)
    {
        _lbGroups.DeleteAllItems();

        GROUP_LBI * plbi = new ALIAS_LBI( pchName,
                                          NULL,
                                          ulRid,
                                          fBuiltIn );
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   plbi == NULL
            || (err = plbi->QueryError()) != NERR_Success
           )
        {
            delete plbi;
        }
        else
        {
            INT iPos = _lbGroups.AddItem( plbi );
            if (iPos < 0)
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                _lbGroups.SelectItem( iPos );
            }
        }
    }

    return err;
}


/*******************************************************************

    NAME:       UM_ADMIN_APP::GetRasSelection

    SYNOPSIS:   Ask for the name of a user/group, then change the
                contents of the listboxes so that user/group is
                selected.

    ENTRY:      fAllowGlobalGroup       - allow global group selection
                fRenameUser             - Rename User variant, only
                                          sllow user selection and change
                                          error messages accordingly

    RETURNS:    APIERR  - error, or (APIERR)-1 if user hits Cancel.
                          Note that GetRasSelection displays error
                          messages where appropriate, so the caller
                          doesn't have to.

    HISTORY:
        jonn    26-Feb-1993     created

********************************************************************/

APIERR UM_ADMIN_APP::GetRasSelection( MSGID msgidTitle,
                                      MSGID msgidText,
                                      ULONG ulHelpContext,
                                      BOOL fAllowGlobalGroup,
                                      BOOL fRenameUser,
                                      BOOL fCopy )
{
    RASSELECT_DIALOG rasseldlg( QueryHwnd(),
                                msgidTitle,
                                msgidText,
                                ulHelpContext,
                                this,
                                fAllowGlobalGroup,
                                fRenameUser,
                                fCopy );
    APIERR err = NERR_Success;
    BOOL fOK = TRUE;
    if (   (err = rasseldlg.QueryError()) != NERR_Success
        || (err = rasseldlg.Process( &fOK )) != NERR_Success
       )
    {
        DBGEOL( "User Manager: GetRasSelection: processing error " << err );
    }

    if (err == NERR_Success)
    {
        if (!fOK)
        {
            TRACEEOL( "User Manager: W_GetRasName: cancel" );
            err = (APIERR)-1;
        }
    }
    else
    {
        ::MsgPopup( this, err );
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\usubprop.cxx ===
/**********************************************************************/
/**                Microsoft Windows NT                              **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    usubprop.cxx
    USER_SUBPROP_DLG class implementation

    FILE HISTORY:
	rustanl     28-Aug-1991     Created as hierarchy placeholder
	o-SimoP	    14-Oct-1991	    Added common control handling
				    for sub dialogs
    	o-SimoP	    11-Dec-1991	    Added USER_LISTBOX * to constructor
	JonN	    18-Dec-1991     Logon Hours code review changes part 2
	JonN	    30-Dec-1991     Work around LM2x bug in PerformOne()
	JonN	    01-Jan-1992     Changed W_MapPerformOneAPIError to
				    W_MapPerformOneError
				    Split PerformOne() into
				    I_PerformOneClone()/Write()
	o-SimoP	    01-Jan-1992	    CR changes, attended by BenG, JonN and I
        JonN        06-Mar-1992     Moved GetOne from subprop subclasses
	JonN	    28-Apr-1992     Added QueryUser3Ptr
*/


#include <ntincl.hxx>
extern "C"
{
    #include <ntsam.h>
}


#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_NETACCESS // for USER_PRIV_ manifests
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_SPIN_GROUP
#include <blt.hxx>

#include <uitrace.hxx>
#include <usrmain.hxx>
#include <usubprop.hxx>
#include <userprop.hxx>
#include <usrmgr.h>
#include <usrmgrrc.h>


/*******************************************************************

    NAME:	USER_SUBPROP_DLG::USER_SUBPROP_DLG

    SYNOPSIS:	USER_SUBPROP_DLG constructor

    ENTRY:	pupropdlgParent -	Pointer to parent window
		pszResourceName -	Name of dialog resource
		pulb		-	Pointer to main user lb

    HISTORY:
	rustanl     28-Aug-1991     Created
    	o-SimoP	    11-Dec-1991	    Added USER_LISTBOX * to constructor
********************************************************************/

USER_SUBPROP_DLG::USER_SUBPROP_DLG( USERPROP_DLG * pupropdlgParent,
				    const TCHAR *   pszResourceName,
				    const LAZY_USER_LISTBOX * pulb,
                                    BOOL fAnsiDialog )
    :	SUBPROP_DLG( pupropdlgParent, pszResourceName, fAnsiDialog ),
	_sltNameLabel( this, IDUP_ST_USER_LB ),
	_sltpLogonName( this, IDUP_ST_USER ),
	_plbLogonName( NULL ),
	_phidden( NULL )
{
    if ( QueryError() != NERR_Success )
	return;

    INT i = QueryObjectCount();
    RESOURCE_STR resstr( i > 1 ? IDS_LABEL_USERS : IDS_LABEL_USER );
    APIERR err = resstr.QueryError();
    if( err != NERR_Success )
    {
	ReportError( err );
	return;
    }
    _sltNameLabel.SetText( resstr );

    err = ERROR_NOT_ENOUGH_MEMORY;
    if ( i > 1 )
    {
	_sltpLogonName.Show( FALSE );
	_plbLogonName = new USER2_LISTBOX( this, IDUP_LB_USERS, pulb );
	if(   _plbLogonName == NULL
	   || (err = _plbLogonName->QueryError() ) != NERR_Success )
	{
	    ReportError( err );
	    return;
	}
    }
    else
    {	
	_phidden = new HIDDEN_CONTROL( this, IDUP_LB_USERS );
	if(    _phidden == NULL
	    || (err = _phidden->QueryError())!= NERR_Success )
	{
	    ReportError( err );
	    return;
	}
    }

}  // USER_SUBPROP_DLG::USER_SUBPROP_DLG


/*******************************************************************

    NAME:	USER_SUBPROP_DLG::~USER_SUBPROP_DLG

    SYNOPSIS:	USER_SUBPROP_DLG destructor

    HISTORY:
	rustanl     28-Aug-1991     Created

********************************************************************/

USER_SUBPROP_DLG::~USER_SUBPROP_DLG()
{
    delete _phidden;
    _phidden = NULL;
    delete _plbLogonName;
    _plbLogonName = NULL;

}  // USER_SUBPROP_DLG::~USER_SUBPROP_DLG


/*******************************************************************

    NAME:       USER_SUBPROP_DLG::GetOne

    SYNOPSIS:   Loads information on one user

    ENTRY:	iObject   -	the index of the object to load

    		perrMsg  -	pointer to error message, that
				is only used when this function
				return value is not NERR_Success

    RETURNS:	An error code which is NERR_Success on success.		

    HISTORY:
    	JonN	06-Mar-1992	Moved up from subclasses

********************************************************************/

APIERR USER_SUBPROP_DLG::GetOne(
	UINT		iObject,
	APIERR *	perrMsg
	)
{
    *perrMsg = IDS_UMGetOneFailure;
    return W_LMOBJtoMembers( iObject );
}  // USER_SUBPROP_DLG::GetOne


/*******************************************************************

    NAME:	USER_SUBPROP_DLG::QueryUser2Ptr

    SYNOPSIS:   Accessor to the NEW_LM_OBJ arrays

    ENTRY:	iObject	  -	index to object

    RETURNS:	pointer to USER_2 object

    HISTORY:
    	o-SimoP        19-Sep-1991     Created

********************************************************************/

USER_2 * USER_SUBPROP_DLG::QueryUser2Ptr( UINT iObject )
{
    return QueryParent()->QueryUser2Ptr( iObject );
}


/*******************************************************************

    NAME:	USER_SUBPROP_DLG::QueryUser3Ptr

    SYNOPSIS:   Accessor to the NEW_LM_OBJ arrays.
                Should only be used when focus is on an NT server.

    ENTRY:	iObject	  -	index to object

    RETURNS:	pointer to USER_3 object

    HISTORY:
    	JonN           28-Apr-1992     Created

********************************************************************/

USER_3 * USER_SUBPROP_DLG::QueryUser3Ptr( UINT iObject )
{
    return QueryParent()->QueryUser3Ptr( iObject );
}

/*******************************************************************

    NAME:	USER_SUBPROP_DLG::SetUser2Ptr

    SYNOPSIS:   Accessor to the NEW_LM_OBJ arrays

    ENTRY:	iObject	  -	index to object, to be replaced (and
    				deleted) by

    		puser2New -	pointer to object to replace previous
				object in index

    HISTORY:
    	o-SimoP		19-Sep-1991     Created

********************************************************************/

VOID USER_SUBPROP_DLG::SetUser2Ptr( UINT iObject, USER_2 * puser2New )
{
    QueryParent()->SetUser2Ptr( iObject, puser2New );
}


/*******************************************************************

    NAME:	USER_SUBPROP_DLG::QueryUserMembPtr

    SYNOPSIS:   Accessor to the NEW_LM_OBJ arrays

    ENTRY:	iObject	  -	index to object

    RETURNS:	pointer to USER_MEMB obj

    HISTORY:
    	o-SimoP        19-Sep-1991     Created

********************************************************************/

USER_MEMB * USER_SUBPROP_DLG::QueryUserMembPtr( UINT iObject )
{
    return QueryParent()->QueryUserMembPtr( iObject );
}


/*******************************************************************

    NAME:	USER_SUBPROP_DLG::SetUserMembPtr

    SYNOPSIS:   Accessor to the NEW_LM_OBJ arrays

    ENTRY:	iObject	  -	index to object, to be replaced (and
    				deleted) by

    		pusermembNew -	pointer to object to replace previous
				object in index

    HISTORY:
    	o-SimoP        19-Sep-1991     Created

********************************************************************/

VOID USER_SUBPROP_DLG::SetUserMembPtr( UINT iObject, USER_MEMB * pusermembNew )
{
    QueryParent()->SetUserMembPtr( iObject, pusermembNew );
}



/*******************************************************************

    NAME:	USER_SUBPROP_DLG::QueryAccountsSamRidMemPtr

    SYNOPSIS:   Accessor to the SAM_RID_MEM array

    ENTRY:	iObject	  -	index to object

    RETURNS:	pointer to SAM_RID_MEM obj

    HISTORY:
    	thomaspa        28-Apr-1992     Created

********************************************************************/

SAM_RID_MEM * USER_SUBPROP_DLG::QueryAccountsSamRidMemPtr( UINT iObject )
{
    return QueryParent()->QueryAccountsSamRidMemPtr( iObject );
}


/*******************************************************************

    NAME:	USER_SUBPROP_DLG::SetAccountsSamRidMemPtr

    SYNOPSIS:   Accessor to the SAM_RID_MEM array

    ENTRY:	iObject	  -	index to object, to be replaced (and
    				deleted) by

    		psamrmNew -	pointer to object to replace previous
				object in index

    HISTORY:
    	Thomaspa        28-Apr-1992     Created

********************************************************************/

VOID USER_SUBPROP_DLG::SetAccountsSamRidMemPtr( UINT iObject, SAM_RID_MEM * psamrmNew )
{
    QueryParent()->SetAccountsSamRidMemPtr( iObject, psamrmNew );
}


/*******************************************************************

    NAME:	USER_SUBPROP_DLG::QueryBuiltinSamRidMemPtr

    SYNOPSIS:   Accessor to the SAM_RID_MEM array

    ENTRY:	iObject	  -	index to object

    RETURNS:	pointer to SAM_RID_MEM obj

    HISTORY:
    	thomaspa        28-Apr-1992     Created

********************************************************************/

SAM_RID_MEM * USER_SUBPROP_DLG::QueryBuiltinSamRidMemPtr( UINT iObject )
{
    return QueryParent()->QueryBuiltinSamRidMemPtr( iObject );
}


/*******************************************************************

    NAME:	USER_SUBPROP_DLG::SetBuiltinSamRidMemPtr

    SYNOPSIS:   Accessor to the SAM_RID_MEM array

    ENTRY:	iObject	  -	index to object, to be replaced (and
    				deleted) by

    		psamrmNew -	pointer to object to replace previous
				object in index

    HISTORY:
    	Thomaspa        28-Apr-1992     Created

********************************************************************/

VOID USER_SUBPROP_DLG::SetBuiltinSamRidMemPtr( UINT iObject, SAM_RID_MEM * psamrmNew )
{
    QueryParent()->SetBuiltinSamRidMemPtr( iObject, psamrmNew );
}


/*******************************************************************

    NAME:       USER_SUBPROP_DLG::InitControls

    SYNOPSIS:   Initializes the controls maintained by USER_SUBPROP_DLG,
		according to the values in the class data members.
			
    RETURNS:	An error code which is NERR_Success on success.

    HISTORY:
    	o-SimoP        08-Oct-1991     Created

********************************************************************/

APIERR USER_SUBPROP_DLG::InitControls()
{
    APIERR err;

    if ( QueryObjectCount() == 1 )
    {
        NLS_STR nls;

	// CODEWORK:  Forming the qualified name should be done by a
	// common routine in NT_ACCOUNTS_UTILITY.
	if ( IsNewVariant() )
	{
	    NLS_STR nlsFullName;
	    NEW_USERPROP_DLG * pNewUserProp = (NEW_USERPROP_DLG *)QueryParent();

	    err = pNewUserProp->_sleLogonName.QueryText( &nls );
	    if ( err == NERR_Success
		&& (err = nls.QueryError()) == NERR_Success
		&& (err = pNewUserProp->_sleFullName.QueryText( &nlsFullName ))
			== NERR_Success
		&& (err = nlsFullName.QueryError()) == NERR_Success
		&& nlsFullName.QueryPch() != NULL
		&& *nlsFullName.QueryPch() )
	    {
	        nls += SZ(" (");
	        err = nls.QueryError();

	        if( err == NERR_Success )
	        {
	            nls += nlsFullName;
	            err = nls.QueryError();
                }
	        if( err == NERR_Success )
	        {
	            nls += SZ(")");
	            err = nls.QueryError();
                }
	    }
	}
	else
	{
	    USER_2 * puser2 = QueryUser2Ptr( 0 );  //first
	    nls = puser2->QueryName();
	    err = nls.QueryError();

	    if ( err == NERR_Success
		&& puser2->QueryFullName() != NULL
		&& *puser2->QueryFullName() )
	    {
	        nls += SZ(" (");
	        err = nls.QueryError();

	        if( err == NERR_Success )
	        {
	            nls += puser2->QueryFullName();
	            err = nls.QueryError();
                }
	        if( err == NERR_Success )
	        {
	            nls += SZ(")");
	            err = nls.QueryError();
                }
	    }

	}
	if( err == NERR_Success )
	    _sltpLogonName.SetText( nls );
    }
    else
    {
	err = _plbLogonName->Fill();
    }

    return err;

} // USER_SUBPROP_DLG::InitControls


/*******************************************************************

    NAME:       USER_SUBPROP_DLG::W_MembersToLMOBJ

    SYNOPSIS:	Loads class data members into the USER_2 object

    ENTRY:	Pointer to a USER_2 to be modified

    RETURNS:	error code

    NOTES:	If some fields were different for multiply-selected
    		objects, the initial contents of the edit fields
		contained only a default value.  In this case, we only
		want to change the LMOBJ if the value of the edit field
		has changed.  This is also important for "new" variants,
		where PerformOne will not always copy the object and
		work with the copy.

    NOTES:	Note that the LMOBJ is not changed if the current
		contents of the edit field are the same as the
		initial contents.

    HISTORY:
	       o-SimoP 20-Sep-1991   copied from USER_SUBPROP_DLG

********************************************************************/

APIERR USER_SUBPROP_DLG::W_MembersToLMOBJ(
	USER_2 *	puser2,
	USER_MEMB *	pusermemb
	)
{
    UNREFERENCED( puser2 );
    UNREFERENCED( pusermemb );
    return NERR_Success;
}



/*******************************************************************

    NAME:       USER_SUBPROP_DLG::W_DialogToMembers

    SYNOPSIS:	Loads data from dialog into class data members

    RETURNS:	error message (not necessarily an error code)

    HISTORY:
	       o-SimoP 20-Sep-1991   copied from USER_SUBPROP_DLG

********************************************************************/

APIERR USER_SUBPROP_DLG::W_DialogToMembers(
	)
{
    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_SUBPROP_DLG::W_LMOBJtoMembers

    SYNOPSIS:	Loads class data members from initial data

    ENTRY:	Index of user to examine.  W_LMOBJToMembers expects to be
		called once for each user, starting from index 0.

    RETURNS:	error code

    NOTES:	This API takes a UINT rather than a USER_2 * because it
		must be able to recognize the first user.

    HISTORY:
	       o-SimoP 20-Sep-1991   copied from USER_SUBPROP_DLG

********************************************************************/

APIERR USER_SUBPROP_DLG::W_LMOBJtoMembers(
	UINT		iObject
	)
{
    UNREFERENCED( iObject );
    return NERR_Success;
}



/*******************************************************************

    NAME:       USER_SUBPROP_DLG::W_MapPerformOneError

    SYNOPSIS:	Checks whether the error maps to a specific control
		and/or a more specific message.  Each level checks for
		errors specific to edit fields it maintains.  There
		are no errors associated with an invalid comment, so
		this level does nothing.

    ENTRY:      Error returned from PerformOne()

    RETURNS:	Error to be displayed to user

    HISTORY:
	       o-SimoP 20-Sep-1991   copied from USER_SUBPROP_DLG

********************************************************************/

MSGID USER_SUBPROP_DLG::W_MapPerformOneError(
	APIERR err
	)
{
    return err;
}


/*******************************************************************

    NAME:       USER_SUBPROP_DLG::ChangesUser2Ptr

    SYNOPSIS:	Checks whether W_MembersToLMOBJ changes the USER_2
		for this object.

    ENTRY:	index to object

    RETURNS:	TRUE iff USER_2 is changed

    HISTORY:
	JonN	18-Dec-1991   created

********************************************************************/

BOOL USER_SUBPROP_DLG::ChangesUser2Ptr( UINT iObject )
{
    UNREFERENCED( iObject );
    return FALSE;
}


/*******************************************************************

    NAME:       USER_SUBPROP_DLG::ChangesUserMembPtr

    SYNOPSIS:	Checks whether W_MembersToLMOBJ changes the USER_MEMB
		for this object.

    ENTRY:	index to object

    RETURNS:	TRUE iff USER_MEMB is changed

    HISTORY:
	JonN	18-Dec-1991   created

********************************************************************/

BOOL USER_SUBPROP_DLG::ChangesUserMembPtr( UINT iObject )
{
    UNREFERENCED( iObject );
    return FALSE;
}


/*******************************************************************

    NAME:	USER_SUBPROP_DLG::OnOK

    SYNOPSIS:   OK button handler

    HISTORY:
        JonN        06-Mar-1992     moved from subclasses
********************************************************************/

BOOL USER_SUBPROP_DLG::OnOK(void)
{
    APIERR err = W_DialogToMembers();

    switch( err )
    {
    case NERR_Success:
	break;
	
    case IERR_CANCEL_NO_ERROR:
        return TRUE;

    default:
	::MsgPopup( this, err );
	return TRUE;
    }

    if ( PerformSeries() )
	Dismiss(); // Dismiss code not used
    return TRUE;

} // USER_SUBPROP_DLG::OnOK


/*******************************************************************

    NAME:       USER_SUBPROP_DLG::PerformOne
	
    SYNOPSIS:	PERFORMER::PerformSeries calls this

    ENTRY:	iObject  -	index of the object to save

    		perrMsg  -	pointer to error message, that
				is only used when this function
				return value is not NERR_Success
					
		pfWorkWasDone - indicates whether any UAS changes were
				successfully written out.  This
				may return TRUE even if the PerformOne
				action as a whole failed (i.e. PerformOne
				returned other than NERR_Success).
					
    RETURNS:	An error code which is NERR_Success on success.

    NOTES:	This PerformOne() is intended to work with all User
    		Properties subproperty dialogs.  It uses virtuals
		ChangesUser2Ptr() and ChangesUserMembPtr() to tell it which
		of these objects to clone and replace.

    HISTORY:
    JonN        18-Dec-1991     Created
    JonN	31-Dec-1991	Workaround for LM2x InvalParam bug

********************************************************************/

APIERR USER_SUBPROP_DLG::PerformOne(
	UINT		iObject,
	APIERR *	perrMsg,
	BOOL *		pfWorkWasDone
	)
{

    UIASSERT( iObject < QueryObjectCount() );
    UIASSERT( (!IsNewVariant()) || (iObject == 0) );
    UIASSERT( (perrMsg != NULL) && (pfWorkWasDone != NULL) );

    UITRACE( SZ("USER_SUBPROP_DLG::PerformOne : ") );
    UITRACE( QueryObjectName( iObject ) );
    UITRACE( SZ("\n\r") );

    *perrMsg = IDS_UMEditFailure;
    *pfWorkWasDone = FALSE;

    BOOL fChangesUser2Ptr = ChangesUser2Ptr( iObject );
    BOOL fChangesUserMembPtr = ChangesUserMembPtr( iObject );

    USER_2 * puser2New = NULL;
    USER_MEMB * pusermembNew = NULL;

    APIERR err = QueryParent()->I_PerformOne_Clone(
			iObject,
			(fChangesUser2Ptr) ? &puser2New : NULL,
			(fChangesUserMembPtr) ? &pusermembNew : NULL );

    if ( err == NERR_Success )
    {
	err = W_MembersToLMOBJ( puser2New, pusermembNew );
	if ( err != NERR_Success )
	{
	    delete puser2New;
	    puser2New = NULL;
	    delete pusermembNew;
	    pusermembNew = NULL;

	}
    }

    if ( err == NERR_Success )
    {
	if ( IsNewVariant() )
	{
	    if ( fChangesUser2Ptr )
		SetUser2Ptr( iObject, puser2New );
	    if ( fChangesUserMembPtr )
		SetUserMembPtr( iObject, pusermembNew );
	}
	else
	{
	    err = QueryParent()->I_PerformOne_Write(
			iObject,
			puser2New,
			pusermembNew,
			pfWorkWasDone,
                        this );
	    if ( err != NERR_Success )
	        err = W_MapPerformOneError( err );
	}
    }

    UITRACE( SZ("USERSUBPROP_DLG::PerformOne returns ") );
    UITRACENUM( (LONG)err );
    UITRACE( SZ("\n\r") );

    return err;

} // USER_SUBPROP_DLG::PerformOne
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\vlw.cxx ===
/**********************************************************************/
/**                          Microsoft Windows NT                       **/
/**          Copyright(c) Microsoft Corp., 1991                      **/
/**********************************************************************/

/*
    vlw.cxx


    FILE HISTORY:
    o-SimoP 14-May-1991 Created
        now it is assumed that there is account for user
        so the case of new user is not handled ( not any more )
    o-SimoP         10-Oct-1991         modified to inherit from USER_SUBPROP_DLG
    o-SimoP         15-Oct-1991         Code Review changes, attended by JimH, JonN
                                    TerryK and I
    terryk        10-Nov-1991        change I_NetXXX to I_MNetXXX
    o-SimoP     03-Dec-1991     _sltCanLogOnFrom added
    JonN        18-Dec-1991        Logon Hours code review changes part 2
    JonN        06-Mar-1992     Moved GetOne from subprop subclasses
    JonN        09-Sep-1992     Added SLT array
    CongpaY     01-Oct-1993     Added NetWare support.
*/

#include <ntincl.hxx>
extern "C"
{
    #include <ntsam.h>
}

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_ICANON
#define INCL_NETLIB
#define INCL_NETACCESS // for UF_NORMAL_ACCOUNT etc in ntuser.hxx
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

extern "C"
{
    #include <mnet.h>
    #include <umhelpc.h>
}

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#include <uitrace.hxx>
#include <uiassert.hxx>
#include <bltmsgp.hxx>
#include <usrmgrrc.h>
#include <vlw.hxx>
#include <nwlb.hxx>
#include <security.hxx>
#include <nwuser.hxx>

const TCHAR * const_pszSep = SZ(",");

#define MAX_NW_LOGON_FROM 16

//
// BEGIN MEMBER FUNCTIONS
//


/*******************************************************************

    NAME:        VLW_DIALOG::VLW_DIALOG

    SYNOPSIS:   Constructor for Valid Logon Workstations dialog

    ENTRY:        puserpropdlgParent - pointer to parent properties
                                     dialog

    HISTORY:
        o-simoP     14-May-1991     Created
            o-SimoP     07-Oct-1991            changes due to multiple users
            o-SimoP     03-Dec-1991            _sltCanLogOnFrom added
            JonN        02-Jul-1992            _sltCanLogOnFrom removed (use radio buttons)
********************************************************************/

VLW_DIALOG::VLW_DIALOG(
        USERPROP_DLG * puserpropdlgParent,
        const LAZY_USER_LISTBOX * pulb
        ) : USER_SUBPROP_DLG(
                puserpropdlgParent,
                MAKEINTRESOURCE(puserpropdlgParent->IsNetWareInstalled()? IDD_VLWDLG : IDD_NO_NETWARE_VLWDLG),
                pulb,

// kkbugfix
                FALSE                  // Use Unicode form of dialog to
                                       // canonicalize the computernames
                ),        
    _fIndeterminateWksta( FALSE ),
    _fIndetNowWksta( FALSE ),
    _nlsWkstaNames(),
    _mgrpMaster( this, IDVLW_RB_WORKS_ALL, 2 ),
    _pushbuttonAdd (this, IDVLW_ADD),
    _pushbuttonRemove (this, IDVLW_REMOVE),
    _fIndeterminateWkstaNW( FALSE ),
    _fIndetNowWkstaNW( FALSE ),
    _nlsWkstaNamesNW(),
    _mgrpMasterNW (this, IDVLW_RB_WORKS_ALL_NW, 2),
    _lbNW (this, IDVLW_LB_ADDRESS),
    _sltNetworkAddr (this, IDVLW_SLT_NETWORKADDR),
    _sltNodeAddr (this, IDVLW_SLT_NODEADDR),
    _fIsNetWareInstalled (puserpropdlgParent->IsNetWareInstalled()),
    _fIsNetWareChecked ( puserpropdlgParent->IsNetWareInstalled() ?
                         puserpropdlgParent->IsNetWareChecked() : FALSE)
{
    for( UINT i = 0; i < NUMBER_OF_SLE; i++ )
    {
        _apsleArray[i] = NULL;
        _apsltArray[i] = NULL;
    }

    APIERR err = QueryError();
    if( err != NERR_Success )
        return;

    if( ((err = _nlsWkstaNames.QueryError()) != NERR_Success ) ||
        ((err = _nlsWkstaNamesNW.QueryError()) != NERR_Success ))
    {
        ReportError( err );
        return;
    }

    for( i = 0; i < NUMBER_OF_SLE; i++ )
    {
        _apsleArray[i] = new SLE_STRIP( this, IDVLW_SLE_WORKS_1 + i, MAX_PATH );
        _apsltArray[i] = new SLT(       this, IDVLW_SLT_WORKS_1 + i );
        err = ERROR_NOT_ENOUGH_MEMORY;
        if(   _apsleArray[i] == NULL
           || _apsltArray[i] == NULL
           || (err = _apsleArray[i]->QueryError()) != NERR_Success
           || (err = _apsltArray[i]->QueryError()) != NERR_Success
          )
        {
            ReportError( err );
            return;
        }
    }

}// VLW_DIALOG::VLW_DIALOG


/*******************************************************************

    NAME:        VLW_DIALOG::~VLW_DIALOG

    SYNOPSIS:   Destructor for Valid Logon Workstations dialog

    HISTORY:
            o-SimoP        15-Oct-1991        created
********************************************************************/
VLW_DIALOG::~VLW_DIALOG()
{
    for( UINT i = 0; i < NUMBER_OF_SLE; i++ )
    {
        delete _apsleArray[i];
        delete _apsltArray[i];
    }

}// VLW_DIALOG::~VLW_DIALOG


/*******************************************************************

    NAME:       VLW_DIALOG::W_LMOBJtoMembers

    SYNOPSIS:        Loads class data members from initial data

    ENTRY:        Index of user to examine.  W_LMOBJToMembers expects to be
                called once for each user, starting from index 0.

    RETURNS:        error code

    HISTORY:
            o-SimoP        07-Oct-1991        created

********************************************************************/

APIERR VLW_DIALOG::W_LMOBJtoMembers(
        UINT                iObject
        )
{

    USER_2 * puser2 = QueryUser2Ptr( iObject );
    UIASSERT( puser2 != NULL );
    APIERR err = NERR_Success;

    if ( iObject == 0 ) // first object
    {
        _fIndeterminateWksta = FALSE;
        _fIndeterminateWkstaNW = FALSE;

        if (((err = _nlsWkstaNames.CopyFrom( puser2->QueryWorkstations())) != NERR_Success) ||
            (_fIsNetWareInstalled &&
             ((err = QueryUserNWPtr(iObject)->QueryNWWorkstations(&_nlsWkstaNamesNW)) != NERR_Success)))
        {
            return err;
        }
    }
    else        // iObject > 0
    {
        if ( !_fIndeterminateWksta )
        {
        // CODEWORK the order isn't checked...

        //
        // We should use I_NetNameCompare here, instead of settling for a
        // simple string comparison.
        //
            if ( _nlsWkstaNames._stricmp( puser2->QueryWorkstations() ) != 0 )
                _fIndeterminateWksta = TRUE;
        }

        if ( _fIsNetWareInstalled && !_fIndeterminateWkstaNW )
        {
            NLS_STR nlsTmp;
            if (((err = nlsTmp.QueryError()) != NERR_Success) ||
                ((err = QueryUserNWPtr(iObject)->QueryNWWorkstations(&nlsTmp)) != NERR_Success) )
            {
                return err;
            }

            if ( _nlsWkstaNamesNW._stricmp(nlsTmp) != 0 )
                _fIndeterminateWkstaNW = TRUE;
        }
    }

    return USER_SUBPROP_DLG::W_LMOBJtoMembers( iObject );
        
} // VLW_DIALOG::W_LMOBJtoMembers


/*******************************************************************

    NAME:       VLW_DIALOG::InitControls

    SYNOPSIS:   Initializes the controls maintained by VLW_DIALOG,
                according to the values in the class data members.
                        
    RETURNS:        An error code which is NERR_Success on success.

    HISTORY:
            o-SimoP        07-Oct-1991        created
********************************************************************/

APIERR VLW_DIALOG::InitControls()
{
    APIERR err = NERR_Success ;
    if( QueryObjectCount() > 1 )
    {
        RESOURCE_STR rstrAnywhere( IDS_VLW_USERS_ANYWHERE_TEXT );
        RESOURCE_STR rstrSelected( IDS_VLW_USERS_SELECTED_TEXT );
        if ( ((err = rstrAnywhere.QueryError()) != NERR_Success) ||
             ((err = rstrSelected.QueryError()) != NERR_Success) )
        {
            return err;
        }
        _mgrpMaster[IDVLW_RB_WORKS_ALL]->SetText( rstrAnywhere );
        _mgrpMaster[IDVLW_RB_WORKS_SELECTED]->SetText( rstrSelected );
    }

    if( !_fIndeterminateWksta )
    {
        if( _nlsWkstaNames.strlen() != 0 )
        {
            FillFields( _nlsWkstaNames.QueryPch() );
            _mgrpMaster.SetSelection( IDVLW_RB_WORKS_SELECTED );
        RADIO_BUTTON * pradioSelectedWkstas =
                                _mgrpMaster[ IDVLW_RB_WORKS_SELECTED ];
        if ( pradioSelectedWkstas == NULL )
        {
            UIASSERT( FALSE );
        }
        else
        {
            SetDialogFocus( *pradioSelectedWkstas );
        }
    }
    else
           _mgrpMaster.SetSelection( IDVLW_RB_WORKS_ALL );

    }

    for( UINT i=0; i < NUMBER_OF_SLE; i++ )
    {
        if ( NERR_Success != (err =
            _mgrpMaster.AddAssociation( IDVLW_RB_WORKS_SELECTED, _apsleArray[i] )) )
        {
        break;
        }
        if ( NERR_Success != (err =
            _mgrpMaster.AddAssociation( IDVLW_RB_WORKS_SELECTED, _apsltArray[i] )) )
        {
        break;
        }
    }

    if (_fIsNetWareInstalled)
    {
        if (!_fIsNetWareChecked)
        {
            _mgrpMasterNW.Enable (FALSE);
            _sltNetworkAddr.Enable (FALSE);
            _sltNodeAddr.Enable (FALSE);
            _pushbuttonAdd.Enable (FALSE);
            _pushbuttonRemove.Enable (FALSE);
        }
        else
        {

            if( QueryObjectCount() > 1 )
            {
            RESOURCE_STR rstrAnywhereNW( IDS_VLW_USERS_ANYWHERE_NW_TEXT );
                RESOURCE_STR rstrSelectedNW( IDS_VLW_USERS_SELECTED_NW_TEXT );
                if ( ((err = rstrAnywhereNW.QueryError()) != NERR_Success) ||
                     ((err = rstrSelectedNW.QueryError()) != NERR_Success) )
                {
                    return err;
                }
                _mgrpMasterNW[IDVLW_RB_WORKS_ALL_NW]->SetText( rstrAnywhereNW );
                _mgrpMasterNW[IDVLW_RB_WORKS_SELECTED_NW]->SetText( rstrSelectedNW );
            }

            if( !_fIndeterminateWkstaNW )
            {
                if( _nlsWkstaNamesNW.strlen() != 0 )
                {
                    if ((err = FillListBox( _nlsWkstaNamesNW)) != NERR_Success)
                    {
                        return err;
                    }

                    _mgrpMasterNW.SetSelection( IDVLW_RB_WORKS_SELECTED_NW );
                }
                else
                   _mgrpMasterNW.SetSelection( IDVLW_RB_WORKS_ALL_NW );

            }

            if (((err = _mgrpMasterNW.AddAssociation (IDVLW_RB_WORKS_SELECTED_NW, &_lbNW)) != NERR_Success)||
                ((err = _mgrpMasterNW.AddAssociation (IDVLW_RB_WORKS_SELECTED_NW, &_sltNetworkAddr)) != NERR_Success)||
                ((err = _mgrpMasterNW.AddAssociation (IDVLW_RB_WORKS_SELECTED_NW, &_sltNodeAddr)) != NERR_Success) ||
                ((err = _mgrpMasterNW.AddAssociation (IDVLW_RB_WORKS_SELECTED_NW, &_pushbuttonAdd)) != NERR_Success) ||
                ((err = _mgrpMasterNW.AddAssociation (IDVLW_RB_WORKS_SELECTED_NW, &_pushbuttonRemove)) != NERR_Success) )
            {
                return err;
            }

            if (_lbNW.QueryCount() == 0)
            {
                _pushbuttonRemove.Enable(FALSE);
            }
        }
    }

    return (err == NERR_Success) ? USER_SUBPROP_DLG::InitControls() : err;

} // VLW_DIALOG::InitControls


/*******************************************************************

    NAME:        VLW_DIALOG::OnOK

    SYNOPSIS:   OK button handler

    HISTORY:
        simo            16-May-1991     created
            o-SimoP            07-Oct-1991            changes due to multiple users        
********************************************************************/

BOOL VLW_DIALOG::OnOK(void)
{
    APIERR err = W_DialogToMembers();
    switch( err )
    {
    case NERR_Success:
        if ( PerformSeries() )
            Dismiss(); // Dismiss code not used
        break;

    case MSG_VLW_NO_GOOD_NAMES: // the name in sle isn't ok
        {
            NLS_STR nls;
            _psleFirstBadName->QueryText( &nls );
            if( (err = nls.QueryError()) != NERR_Success )
            {
                ::MsgPopup( this, err );
                break;
            }
            ::MsgPopup(
                    this,
                    MSG_VLW_NO_GOOD_NAMES,
                    MPSEV_ERROR,
                    MP_OK,
                    nls.QueryPch() );
            _psleFirstBadName->ClaimFocus();
            _psleFirstBadName->SelectString();
            break;
        }
        
    case MSG_VLW_GIVE_NAMES: // all sle's are empty
        ::MsgPopup( this, MSG_VLW_GIVE_NAMES );
        _apsleArray[0]->ClaimFocus();
        break;
        
    default:
        ::MsgPopup( this, err );
        break;
    }

    return TRUE;

}   // VLW_DIALOG::OnOK


/*******************************************************************

    NAME:       VLW_DIALOG::W_DialogToMembers

    SYNOPSIS:        Loads data from dialog into class data members

    RETURNS:        error message (not necessarily an error code)

    HISTORY:
            o-SimoP        07-Oct-1991        created
********************************************************************/

APIERR VLW_DIALOG::W_DialogToMembers()
{
    APIERR err = NERR_Success;
    switch( _mgrpMaster.QuerySelection() )
    {
    case RG_NO_SEL:
        _fIndetNowWksta = TRUE;
        break;
    case IDVLW_RB_WORKS_ALL:
        _nlsWkstaNames = NULL;
        _fIndetNowWksta = FALSE;
        break;
    case IDVLW_RB_WORKS_SELECTED:
        _nlsWkstaNames = NULL;
        if( (err = CheckNames()) != NERR_Success )
                break;
        if( err == NERR_Success )
        {
            if( _nlsWkstaNames.strlen() != 0 )
            {
                err = RemoveDuplicates();
            }
            else
            {
                err = MSG_VLW_GIVE_NAMES;
            }
        }
        _fIndetNowWksta = FALSE;
        break;
    }

    TRACEEOL(   "VLW_DIALOG::MembersToLMOBJ: _nlsWkstaNames == \""
             << _nlsWkstaNames << "\"" );

    if (_fIsNetWareInstalled)
    {
        switch( _mgrpMasterNW.QuerySelection() )
        {
        case RG_NO_SEL:
            _fIndetNowWkstaNW = TRUE;
                break;
        case IDVLW_RB_WORKS_ALL_NW:
                _nlsWkstaNamesNW = NULL;
                _fIndetNowWkstaNW = FALSE;
            break;
        case IDVLW_RB_WORKS_SELECTED_NW:
            _nlsWkstaNamesNW = NULL;
            err = _lbNW.QueryWkstaNamesNW (&_nlsWkstaNamesNW);
                _fIndetNowWkstaNW = FALSE;
            break;
        }
    }

    return (err == NERR_Success) ? USER_SUBPROP_DLG::W_DialogToMembers() : err;
} // VLW_DIALOG::W_DialogToMembers


/*******************************************************************

    NAME:       VLW_DIALOG::ChangesUser2Ptr

    SYNOPSIS:        Checks whether W_MembersToLMOBJ changes the USER_2
                for this object.

    ENTRY:        index to object

    RETURNS:        TRUE iff USER_2 is changed

    HISTORY:
        JonN        18-Dec-1991   created

********************************************************************/

BOOL VLW_DIALOG::ChangesUser2Ptr( UINT iObject )
{
    UNREFERENCED( iObject );
    return TRUE;
}


/*******************************************************************

    NAME:       VLW_DIALOG::W_MembersToLMOBJ

    SYNOPSIS:        Loads class data members into the USER_2 object

    ENTRY:        puser2                - pointer to a USER_2 to be modified
        
                pusermemb        - pointer to a USER_MEMB to be modified
                        
    RETURNS:        error code

    NOTES:        If some fields were different for multiply-selected
                    objects, the initial contents of the edit fields
                contained only a default value.  In this case, we only
                want to change the LMOBJ if the value of the edit field
                has changed.  This is also important for "new" variants,
                where PerformOne will not always copy the object and
                work with the copy.

    HISTORY:
            o-SimoP        07-Oct-1991        created
********************************************************************/

APIERR VLW_DIALOG::W_MembersToLMOBJ(
        USER_2 *        puser2,
        USER_MEMB *        pusermemb )
{
    APIERR err;

    if ( !_fIndetNowWksta )
    {
        err = puser2->SetWorkstations( _nlsWkstaNames.QueryPch() );
        if( err != NERR_Success )
            return err;
    }

    if ( _fIsNetWareInstalled && !_fIndetNowWkstaNW )
    {
        err = ((USER_NW *)puser2)->SetNWWorkstations( _nlsWkstaNamesNW.QueryPch(), TRUE );
        if( err != NERR_Success )
            return err;
    }

    return USER_SUBPROP_DLG::W_MembersToLMOBJ( puser2, pusermemb );

}// VLW_DIALOG::W_MembersToLMOBJ


/*******************************************************************

    NAME:        VLW_DIALOG::FillFields

    SYNOPSIS:   Fills SLE fields

    ENTRY:        pszWorkStations - pointer to workstations names

    HISTORY:
               simo  16-May-1991    created

********************************************************************/
void VLW_DIALOG::FillFields(
    const TCHAR *pszWorkStations )
{
    TRACEEOL(   "VLW_DIALOG::FillFields: _nlsWkstaNames == \""
             << _nlsWkstaNames << "\"" );

    STRLIST strlist( pszWorkStations, const_pszSep );
    ITER_STRLIST istr( strlist );
    NLS_STR *pnlsWS;
    UINT i = 0;
    while( ((pnlsWS = istr()) != NULL) && (i < NUMBER_OF_SLE) )
    {
        _apsleArray[i++]->SetText( pnlsWS->QueryPch() );
        TRACEEOL( "\tFillFields: " << pnlsWS->QueryPch() );
    }

}  // VLW_DIALOG::FillFields


/*******************************************************************

    NAME:        VLW_DIALOG::FillListBox

    SYNOPSIS:   Fills the listbox

    ENTRY:        pszWorkStations - pointer to workstations names

    HISTORY:
               CongpaY  1-Oct-1993    created

********************************************************************/
APIERR VLW_DIALOG::FillListBox(
    const NLS_STR & nlsWkstaNamesNW )
{
    ISTR istrStart (nlsWkstaNamesNW);
    ISTR istrEnd (nlsWkstaNamesNW);
    istrEnd += NETWORKSIZE;

    // Check if we pass the end of the string. istr stop at the last point of the string
    // if we increment it too much.
    if ((*nlsWkstaNamesNW.QueryPch(istrStart) == TCH('\0')) &&
        (*nlsWkstaNamesNW.QueryPch(istrEnd) == TCH('\0')) )
    {
        return NERR_Success;
    }

    NLS_STR nlsNetworkAddr;
    NLS_STR nlsNodeAddr;
    NLS_STR * pnlsAddr;

    APIERR err = NERR_Success;

    while(TRUE)
    {
        pnlsAddr = nlsWkstaNamesNW.QuerySubStr(istrStart, istrEnd);
        if (pnlsAddr == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            err = nlsNetworkAddr.CopyFrom (*pnlsAddr);
            delete pnlsAddr;
        }

        if (err != NERR_Success)
        {
            break;
        }

        istrStart += NETWORKSIZE;
        istrEnd += NODESIZE;

        if ((*nlsWkstaNamesNW.QueryPch(istrStart) == TCH('\0')) &&
            (*nlsWkstaNamesNW.QueryPch(istrEnd) == TCH('\0')) )
        {
            break;
        }

        pnlsAddr = nlsWkstaNamesNW.QuerySubStr(istrStart, istrEnd);
        if (pnlsAddr == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            err = nlsNodeAddr.CopyFrom (*pnlsAddr);
            delete pnlsAddr;
        }

        if ((err != NERR_Success) ||
            ((err = _lbNW.AddNWAddr (nlsNetworkAddr, nlsNodeAddr)) != NERR_Success))
        {
            break;
        }

        istrStart += NODESIZE;
        istrEnd += NETWORKSIZE;

        if ((*nlsWkstaNamesNW.QueryPch(istrStart) == TCH('\0')) &&
            (*nlsWkstaNamesNW.QueryPch(istrEnd) == TCH('\0')) )
        {
            break;
        }
    }

    if (_lbNW.QueryCount() >= MAX_NW_LOGON_FROM)
    {
        _pushbuttonAdd.Enable(FALSE);
    }

    return err;

}  // VLW_DIALOG::FillListBox

/*******************************************************************

    NAME:        VLW_DIALOG::CheckNames

    SYNOPSIS:        Checks is the wksta names valid

    RETURNS:        An error code which is NERR_Success on success.
        
    HISTORY:
        simo            17-May-1991     created
            o-SimoP            07-Oct-1991            changes due to multiple users        
********************************************************************/
APIERR VLW_DIALOG::CheckNames()
{
    APIERR err = NERR_Success;
    BOOL fFound = FALSE;
    for( UINT i = 0; i < NUMBER_OF_SLE; i++ )
    {
        if( _apsleArray[i]->QueryTextLength() != 0 )
        {
            STACK_NLS_STR( nlsTemp, MAX_PATH );
            if( (err = _apsleArray[i]->QueryText( &nlsTemp )) == NERR_Success )
            {


                ISTR istr(nlsTemp); // Remove the preceding backslashes
                ISTR istrSecond = istr;
                ++istrSecond;

                if (   (nlsTemp.QueryChar(istr) == TCH('\\'))
                    && (nlsTemp.QueryChar(istrSecond) == TCH('\\')) )
                {
                    ++istrSecond;
                    nlsTemp.DelSubStr(istr, istrSecond);
                }


                if( NERR_Success != ::I_MNetNameValidate(
                    NULL,
                    nlsTemp.QueryPch(),
                    NAMETYPE_COMPUTER,
                    0L ) )
                {
                    _psleFirstBadName = _apsleArray[i];
                    err = MSG_VLW_NO_GOOD_NAMES;
                }
                else
                {
                    if( fFound )
                        _nlsWkstaNames += const_pszSep;
                    else
                        fFound = TRUE;
                    _nlsWkstaNames += nlsTemp;
                    err = _nlsWkstaNames.QueryError();
                }
            }
            if( err != NERR_Success )
                break;
        }
    }

    return err;

} // VLW_DIALOG::CheckNames


/*******************************************************************

    NAME:        VLW_DIALOG::RemoveDuplicates

    SYNOPSIS:        Removes duplicates from workstation list

    HISTORY:
        o-SimoP  3-Oct-1991    created

********************************************************************/

APIERR VLW_DIALOG::RemoveDuplicates()
{
    STRLIST strlOrg( _nlsWkstaNames.QueryPch(), const_pszSep );
    ITER_STRLIST iterstrOrg( strlOrg );
    NLS_STR *pnls = iterstrOrg.Next();

    if( pnls == NULL )
        return NERR_Success;        // OK only one name

        // this doesn't need deallocation; strlOrg does it
    STRLIST strlNoDup( FALSE );
    strlNoDup.Add( pnls );

    ITER_STRLIST iterstrNoDup( strlNoDup );
    NLS_STR *pnlsNoDup;
    BOOL fFound = FALSE;

    while( (pnls = iterstrOrg.Next()) != NULL )
    {
        iterstrNoDup.Reset();
        fFound = FALSE;        
        while( (pnlsNoDup = iterstrNoDup.Next()) != NULL )
        {
            if( !::I_MNetComputerNameCompare( *pnls, *pnlsNoDup ) )
            {
                fFound = TRUE;
                break;
            }
        }
        if( !fFound )
            strlNoDup.Append( pnls );
    }

    iterstrNoDup.Reset();
    pnls = iterstrNoDup();
    NLS_STR nls( *pnls );
    APIERR err = nls.QueryError();
    if( err != NERR_Success )
        return err;

    while( (pnls = iterstrNoDup.Next()) != NULL )
    {
        nls += const_pszSep;
        nls += *pnls;
    }
    if( (err = nls.QueryError()) != NERR_Success )
        return err;

    return _nlsWkstaNames.CopyFrom( nls );

}// VLW_DIALOG::RemoveDuplicates


/*******************************************************************

    NAME:       VLW_DIALOG::OnCommand

    SYNOPSIS:   button handler

    RETURNS:    TRUE is action is taken
                FALSE otherwise

    NOTE:       handle the "Add.." and "Remove" buttons.

    HISTORY:
               CongpaY  4-Oct-1993    created

********************************************************************/
BOOL VLW_DIALOG::OnCommand (const CONTROL_EVENT & ce)
{
    switch (ce.QueryCid())
    {
    case IDVLW_ADD:
    {
        APIERR err;

        ADD_DIALOG * pdlg = new ADD_DIALOG ((OWNER_WINDOW *) this,
                                            &_lbNW);

        err = (pdlg == NULL)? ERROR_NOT_ENOUGH_MEMORY :
                              pdlg->Process();
        if (err != NERR_Success)
        {
            ::MsgPopup (this, err);
        }

        delete pdlg;

        INT n = _lbNW.QueryCount();
        if (n == 1)
        {
            _pushbuttonRemove.Enable(TRUE);
        }
        else if (n >= MAX_NW_LOGON_FROM)
        {
            _pushbuttonAdd.Enable(FALSE);
        }

        return TRUE;
    }
    case IDVLW_REMOVE:
    {
        UIASSERT (_lbNW.QueryCount() != 0);

        INT iSelect = _lbNW.QueryCurrentItem();

        UIASSERT (iSelect >= 0);

        _lbNW.RemoveItem();

        INT n = _lbNW.QueryCount();

        if (n == 0)
        {
            _pushbuttonRemove.Enable(FALSE);
        }
        else
        {
            _lbNW.SelectItem ( (iSelect >= n)? n-1 : iSelect);
        }

        if (n < MAX_NW_LOGON_FROM)
        {
            _pushbuttonAdd.Enable(TRUE);
        }

        return TRUE;
    }
    }
    return USER_SUBPROP_DLG::OnCommand (ce);
}

/*******************************************************************

    NAME:       VLW_DIALOG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG - The help context for this dialog.

    HISTORY:
               o-SimoP  4-Oct-1991    created

********************************************************************/

ULONG VLW_DIALOG::QueryHelpContext( void )
{

    return HC_UM_WORKSTATIONS_LANNT + QueryHelpOffset();

}// VLW_DIALOG :: QueryHelpContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\acctypes.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1990		**/ 
/*****************************************************************/ 
/****  ACCTYPES.H  *****  Definition Module for BACKACC/RESTACC Utility
 *
 *	BACKACC/RESTACC
 *
 *	This file was compiled from LTYPES.H and DEFS.H originally in
 *	the UI\ACCUTIL\ACCUTIL directory.  This file is referenced by
 *	both the acc utilities and the LM 2.1 setup program.
 *
 *	History:
 *		April 9, 1991	thomaspa	created from ltypes.h and defs.h
 */


#define FILEHDR		0x08111961	/* All File created by backacc
                                           start with this header.
                                           ATTENTION when change FILEHEADER
					   controll his size and eventually
					   change HEADERSIZE definition 
					   in ltypes.h                 */

#define NINDEX		64		/* # MAX in index_table        */

#define MAX_KEY_LEN	24              /* Dimension of a key */
#define MAX_LIST        0x01400         /* # max in list  */
#define MAXDYNBUFFER	20		/* # buffer of BUFFILE size */



#define VOL_LABEL_SIZE	64		/* Max size of a volume label */
					/* There is no def about how long 
					   should be this label. Normally
					   it is 11 characters */
#define K32BYTE 	0x8000
#define K64BYTE		0xFFFF
#define BYTE256		0x0100
#define BUFLEN		K64BYTE
#define BUFFILE		K32BYTE
#define MAXMSGLEN	256

#define WBSL		0
#define NOBSL		1

/* define file attribute */
#define NORMAL		0x0000
#define R_ONLY		0x0001
#define HIDDEN		0x0002
#define SYSTEM		0x0004
#define SUBDIR		0x0010
#define ARCHIV		0x0020

#define ALL		HIDDEN + SYSTEM + SUBDIR
#define NOSUBDIR	HIDDEN + SYSTEM

#define YES		1		/* Yes state for PromptFlag */
#define NO		2		/* No state for PromptFlag */


/* buffer to pass to DoQFSInfo  */

struct label_buf {
	ULONG	ulVSN;
	UCHAR	cbVolLabel;
	UCHAR	VolLabel[VOL_LABEL_SIZE+1];
};

/* heeader of backacc/restacc file */

struct backacc_header {
	ULONG	back_id;
	UCHAR	vol_name[VOL_LABEL_SIZE + 1];
	USHORT  nindex;
	USHORT 	nentries;
	USHORT 	level;
	ULONG	nresource;
}; 

#define HEADERSIZE	sizeof(struct backacc_header)

struct resource_info {
	USHORT namelen;
	USHORT  acc1_attr;
	USHORT  acc1_count;
	UCHAR  name[MAXPATHLEN];
};

#define RESHDRLEN	6

struct index {
	UCHAR key [MAX_KEY_LEN];
	ULONG offset;
};

#define HEADER 	HEADERSIZE + NINDEX * sizeof(struct index)

struct list {
	struct list *next;
	struct list *prev;
	struct resource_info *ptr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\xlate\citrix.h ===
/*******************************************************************************
*
*  CITRIX.H
*
*     This module contains Citrix specific resource IDs.
*
*  Copyright Citrix Systems Inc. 1994
*
*  Author: Butch Davis
*
*  $Log:   N:\nt\private\net\ui\admin\user\xlate\citrix\VCS\citrix.h  $
*  
*     Rev 1.7   13 Jan 1998 09:26:34   donm
*  removed encryption settings
*  
*     Rev 1.6   11 Mar 1997 13:59:10   butchd
*  MS changed IDHELP to IDHELPBLT for NT 4.0
*  
*     Rev 1.5   16 Jul 1996 16:53:46   TOMA
*  force client lpt to def
*  
*     Rev 1.4   18 Jun 1996 14:12:42   bradp
*  4.0 Merge
*  
*     Rev 1.3   21 Nov 1995 14:36:26   billm
*  CPR 404, Added NWLogon configuration dialog
*  
*     Rev 1.2   18 May 1995 17:55:36   butchd
*  update
*  
*     Rev 1.1   07 Dec 1994 17:46:36   butchd
*  update
*
*******************************************************************************/


/*
 * These are to keep DLGEDIT.EXE happy when editing the CTXDLGS dialog(s) during
 * development.  They are properly defined in other USRMGR includes for build.
 */
#ifndef IDHELPBLT
#define IDHELPBLT                       3
#endif
#ifndef IDUP_ST_USER
#define IDUP_ST_USER                    4
#endif
#ifndef IDUP_ST_USER_LB
#define IDUP_ST_USER_LB                 5
#endif 
#ifndef IDUP_LB_USERS
#define IDUP_LB_USERS                   6
#endif
#ifndef IDUP_ST_USERS_FIRST_COL
#define IDUP_ST_USERS_FIRST_COL         7
#endif
#ifndef IDUP_ST_USERS_SECOND_COL
#define IDUP_ST_USERS_SECOND_COL        8
#endif
#ifndef IDS_UMAPP_BASE
#define IDS_UMAPP_BASE                  3000
#endif

/*
 * User Configuration dialog IDs
 */
#define IDC_UCE_ALLOWLOGON              2201
#define IDL_UCE_TIMEOUTS                2202
#define IDL_UCE_CONNECTION              2203
#define IDC_UCE_CONNECTION              2204
#define IDC_UCE_CONNECTION_NONE         2205
#define IDL_UCE_DISCONNECTION           2206
#define IDC_UCE_DISCONNECTION           2207
#define IDC_UCE_DISCONNECTION_NONE      2208
#define IDL_UCE_IDLE                    2209
#define IDC_UCE_IDLE                    2210
#define IDC_UCE_IDLE_NONE               2211
#define IDL_UCE_INITIALPROGRAM          2212
#define IDL_UCE_INITIALPROGRAM_COMMANDLINE1 2213
#define IDC_UCE_INITIALPROGRAM_COMMANDLINE 2214
#define IDL_UCE_INITIALPROGRAM_WORKINGDIRECTORY1 2215
#define IDC_UCE_INITIALPROGRAM_WORKINGDIRECTORY 2216
#define IDC_UCE_INITIALPROGRAM_INHERIT  2217
#define IDL_UCE_CLIENTDEVICES           2218
#define IDC_UCE_CLIENTDEVICES_DRIVES    2219
#define IDC_UCE_CLIENTDEVICES_PRINTERS  2220
#define IDL_UCE_BROKEN1                 2221
#define IDC_UCE_BROKEN                  2222
#define IDL_UCE_BROKEN2                 2223
#define IDL_UCE_RECONNECT1              2224
#define IDC_UCE_RECONNECT               2225
#define IDL_UCE_CALLBACK                2226
#define IDC_UCE_CALLBACK                2227
#define IDL_UCE_PHONENUMBER             2228
#define IDC_UCE_PHONENUMBER             2229
#define IDL_UCE_SHADOW                  2230
#define IDC_UCE_SHADOW                  2231
#define IDC_UCE_KEYBOARD                2232
#define IDC_UCE_NWLOGON                 2233
#define IDD_USER_CONFIG_EDIT            2234

/*
 * User Configuration dialog list box string IDs
 */
#define IDS_UCE_DIALOG_BASE             (IDS_UMAPP_BASE+400)
#define IDS_UCE_BROKEN_DISCONNECT       (IDS_UCE_DIALOG_BASE+0)
#define IDS_UCE_BROKEN_RESET            (IDS_UCE_DIALOG_BASE+1)
#define IDS_UCE_RECONNECT_ANY           (IDS_UCE_DIALOG_BASE+2)
#define IDS_UCE_RECONNECT_PREVIOUS      (IDS_UCE_DIALOG_BASE+3)
#define IDS_UCE_CALLBACK_DISABLE        (IDS_UCE_DIALOG_BASE+4)
#define IDS_UCE_CALLBACK_ROVING         (IDS_UCE_DIALOG_BASE+5)
#define IDS_UCE_CALLBACK_FIXED          (IDS_UCE_DIALOG_BASE+6)
#define IDS_UCE_SHADOW_DISABLE          (IDS_UCE_DIALOG_BASE+7)
#define IDS_UCE_SHADOW_INPUT_NOTIFY     (IDS_UCE_DIALOG_BASE+8)
#define IDS_UCE_SHADOW_INPUT_NONOTIFY   (IDS_UCE_DIALOG_BASE+9)
#define IDS_UCE_SHADOW_NOINPUT_NOTIFY   (IDS_UCE_DIALOG_BASE+10)
#define IDS_UCE_SHADOW_NOINPUT_NONOTIFY (IDS_UCE_DIALOG_BASE+11)

/*
 * User Configuration dialog error strings
 */
#define IERR_UCE_ERROR_MESSAGE_BASE             (IDS_UMAPP_BASE+420)
#define IERR_UCE_InvalidConnectionTimeout       (IERR_UCE_ERROR_MESSAGE_BASE+0)
#define IERR_UCE_InvalidDisconnectionTimeout    (IERR_UCE_ERROR_MESSAGE_BASE+1)
#define IERR_UCE_InvalidIdleTimeout             (IERR_UCE_ERROR_MESSAGE_BASE+2)

/*
 * NWLogon User Configuration dialog IDs
 */
#define IDD_USER_NWLOGON_EDIT       2300
#define IDL_NW_ADMIN_USERNAME       2301
#define IDL_NW_ADMIN_PASSWORD       2302
#define IDL_NW_ADMIN_CONFIRM_PW     2303
#define IDL_NW_SERVERNAME           2304
#define IDC_NW_SERVERNAME           2305
#define IDC_NW_ADMIN_USERNAME       2306
#define IDC_NW_ADMIN_PASSWORD       2307
#define IDC_NW_ADMIN_CONFIRM_PW     2308

/*
 * NWLogon User Configuration dialog error strings
 */
#define IERR_NW_ERROR_MESSAGE_BASE              (IDS_UMAPP_BASE+440)
#define IERR_NW_UserID_Not_Admin                (IERR_NW_ERROR_MESSAGE_BASE+0)
#define IDC_UCE_CLIENTDEVICES_FORCEPRTDEF 2242
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\applibrc.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    applibrc.h
    APPLIB resource header file.

    This file defines and coordinates the resource IDs of all resources
    used by APPLIB components.

    APPLIB reserves for its own use all resource IDs above 15000, inclusive,
    but less than 20000 (where the BLT range begins).  All clients of APPLIB
    therefore should use IDs of less than 15000.

    FILE HISTORY:
        beng        21-Feb-1992 Created
        beng        04-Aug-1992 Added user browser definitions

        jonn    29-Jul-1992 Changed domain bitmap IDs
*/

#ifndef _APPLIBRC_H_
#define _APPLIBRC_H_

#include "uimsg.h"

/*
 * string IDs
 */
#define IDS_APPLIB_DOMAINS      (IDS_UI_APPLIB_BASE+0)
#define IDS_APPLIB_SERVERS      (IDS_UI_APPLIB_BASE+1)
#define IDS_APPLIB_DOM_AND_SRV  (IDS_UI_APPLIB_BASE+2)
#define IDS_APPLIB_NO_SELECTION (IDS_UI_APPLIB_BASE+3)
#define IDS_APPLIB_WORKING_TEXT (IDS_UI_APPLIB_BASE+4)

//
//   User browser error messages
//
#define IDS_CANT_BROWSE_DOMAINS              (IDS_UI_APPLIB_BASE+5)
#define IDS_CANT_BROWSE_DOMAIN		     (IDS_UI_APPLIB_BASE+20)
#define IDS_CANT_FIND_ACCOUNT		     (IDS_UI_APPLIB_BASE+21)
#define IDS_GETTING_DOMAIN_INFO 	     (IDS_UI_APPLIB_BASE+22)
#define IDS_WONT_GET_DOMAIN_INFO 	     (IDS_UI_APPLIB_BASE+23)

#define IDS_CANT_ADD_USERS		     (IDS_UI_APPLIB_BASE+40)
#define IDS_CANT_ADD_GROUPS		     (IDS_UI_APPLIB_BASE+41)
#define IDS_CANT_ADD_ALIASES		     (IDS_UI_APPLIB_BASE+42)
#define IDS_CANT_ADD_WELL_KNOWN_GROUPS	     (IDS_UI_APPLIB_BASE+43)
#define IDS_WKSTA_OR_BROWSER_NOT_STARTED     (IDS_UI_APPLIB_BASE+44)

/*
 * This error message is used when the user browser Localgroup Membership
 * dialog tries to load the membership of a globalgroup in that localgroup,
 * but the globalgroup was not in the dropdown list of domains in the main
 * User Browser dialog.  This can happen e.g. if a new trusted domain is
 * added while the User Browser dialog is running.
 */
#define IDS_CANT_BROWSE_GLOBAL_GROUP         (IDS_UI_APPLIB_BASE+7)

/*  Message used when prompting for a known DC.
 */
#define IDS_APPLIB_PROMPT_FOR_ANY_DC         (IDS_UI_APPLIB_BASE+8)
#define IDS_APPLIB_PROMPT_DC_INVALID_SERVER  (IDS_UI_APPLIB_BASE+9)

/* Message used when the Find Accounts dialog cannot find any matches
 */
#define IDS_APPLIB_NO_MATCHES                (IDS_UI_APPLIB_BASE+10)

/* Well known Sid comment manifests used in the userbrowser
 */
#define IDS_USRBROWS_EVERYONE_SID_COMMENT    (IDS_UI_APPLIB_BASE+11)
#define IDS_USRBROWS_REMOTE_SID_COMMENT      (IDS_UI_APPLIB_BASE+13)
#define IDS_USRBROWS_INTERACTIVE_SID_COMMENT (IDS_UI_APPLIB_BASE+15)
#define IDS_USRBROWS_CREATOR_SID_COMMENT     (IDS_UI_APPLIB_BASE+17)
#define IDS_USRBROWS_SYSTEM_SID_COMMENT      (IDS_UI_APPLIB_BASE+18)
#define IDS_USRBROWS_RESTRICTED_SID_COMMENT  (IDS_UI_APPLIB_BASE+19)

/* caption for userbrows dialog */
#define IDS_USRBROWS_ADD_USER                (IDS_UI_APPLIB_BASE+25)
#define IDS_USRBROWS_ADD_USERS               (IDS_UI_APPLIB_BASE+26)
#define IDS_USRBROWS_ADD_GROUP               (IDS_UI_APPLIB_BASE+27)
#define IDS_USRBROWS_ADD_GROUPS              (IDS_UI_APPLIB_BASE+28)
#define IDS_USRBROWS_ADD_USERS_AND_GROUPS    (IDS_UI_APPLIB_BASE+29)
#define IDS_USRBROWS_ADD_USER_OR_GROUP       (IDS_UI_APPLIB_BASE+30)


/*
 * This error message indicates that the Global Group Membership dialog
 * is not available for the Domain Users global group.
 * This is disallowed because the Domain Users global group contains
 * workstation, server and interdomain trust accounts, which are not
 * exposed to the user.
 */
#define IDS_USRBROWS_CANT_SHOW_DOMAIN_USERS  (IDS_UI_APPLIB_BASE+35)

/* Strings used in the Set Focus dialog */
#define IDS_SETFOCUS_SERVER_SLOW             (IDS_UI_APPLIB_BASE+36)
#define IDS_SETFOCUS_SERVER_FAST             (IDS_UI_APPLIB_BASE+37)
#define IDS_SETFOCUS_DOMAIN_SLOW             (IDS_UI_APPLIB_BASE+38)
#define IDS_SETFOCUS_DOMAIN_FAST             (IDS_UI_APPLIB_BASE+39)


/*
 * define other IDs
 */
#define BASE_APPLIB_IDD         15000
#define IDD_SETFOCUS_DLG        15001
#define IDD_SELECTCOMPUTER_DLG  15002
#define IDD_SELECTDOMAIN_DLG    15003
#define IDD_PASSWORD_DLG	15004
#define IDD_CANCEL_TASK 	15018

#define BASE_APPLIB_BMID          16000
#define BMID_DOMAIN_EXPANDED      16001
#define BMID_DOMAIN_NOT_EXPANDED  16002
#define BMID_DOMAIN_CANNOT_EXPAND 16003
#define BMID_ENTERPRISE           16004
#define BMID_SERVER               16005

/* For the User Browser */
#define DMID_GROUP                  15010
#define DMID_USER                   15011
#define DMID_ALIAS                  15012
#define DMID_UNKNOWN                15013
#define DMID_SYSTEM                 15014
#define DMID_REMOTE                 15015
#define DMID_WORLD                  15016
#define DMID_CREATOR_OWNER          15017
#define DMID_NETWORK                15018
#define DMID_INTERACTIVE            15019
#define DMID_RESTRICTED             15021

#define DMID_DELETEDACCOUNT         15024

#define IDD_USRBROWS_DLG            15005
#define IDD_SINGLE_USRBROWS_DLG     15006
#define IDD_SED_USRBROWS_DLG        15007
#define IDD_PROMPT_FOR_ANY_DC_DLG   15008

#define IDD_LGRPBROWS_DLG           15020
#define IDD_GGRPBROWS_DLG           15021
#define IDD_LGRPBROWS_1SEL_DLG      15022
#define IDD_GGRPBROWS_1SEL_DLG      15023

#define IDD_BROWS_FIND_ACCOUNT      15030
#define IDD_BROWS_FIND_ACCOUNT_1SEL 15031

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\bltrc.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltrc.h
    BLT resource header file.

    This file defines and coordinates the resource IDs of all resources
    used by BLT components.

    BLT reserves for its own use all resource IDs above 20000, inclusive.
    All clients of BLT therefore should use IDs of less than 20000.

    FILE HISTORY:
        terryk  08-Apr-91   created
        terryk  10-Jul-91   Add SPIN_SSN_ADD_ZERO and IDS_K -> IDS_TB
        terryk  19-Jul-91   Add GB_3D as style for GRAPHICAL_BUTTON_WITH_DISABLE
        beng    20-Feb-1992 Add BASE_BLT_IDD for global dialogs
        beng    21-Feb-1992 BASE_APPLIB_IDD reloc'd to applibrc.h;
                            bltstyle.h split off for custom control styles
                            resource ID namespace partitioned
        chuckc  26-Feb-1992 converted string base to use <uimsg.h>
        beng    05-Mar-1992 Added ID_CURS_BLT_TIMEx
        beng    29-Mar-1992 Change IDHC_MSG_TO_HELP to numeric resource ID
        beng    04-Aug-1992 Added BMIDs for arrow-button bitmaps
        jonn    25-Aug-1992 Added IDs for new MsgPopup form
        jonn    22-Oct-1993 Added splitter-bar cursor
*/

#ifndef _BLTRC_H_
#define _BLTRC_H_

// Style bits for BLT custom controls.

#include "bltstyle.h"
#include "uimsg.h"


// Base for all BLT global dialogs.
// NOTE - rc 3.20/1.252.1 doesn't perform math on DIALOG statements.
//
#define BASE_BLT_IDD            20000
#define IDD_BLT_HELPMSG         20001

// Cursor IDs for the default TIME_CURSOR object.
//
#define ID_CURS_BLT_TIME0       21000
#define ID_CURS_BLT_TIME1       21001
#define ID_CURS_BLT_TIME2       21002
#define ID_CURS_BLT_TIME3       21003
#define ID_CURS_BLT_TIME4       21004
#define ID_CURS_BLT_TIME5       21005
#define ID_CURS_BLT_TIME6       21006
#define ID_CURS_BLT_TIME7       21007

#define ID_CURS_BLT_VSPLIT      21008


// Base for all BLT strings.
//
#define BASE_BLT_IDS            (IDS_UI_BLT_BASE)

/* The following strings currently live in bltmsgp.dlg
 */
#define IDS_BLT_TEXT_MSGP       (BASE_BLT_IDS+1)  // Strings to display when we
#define IDS_BLT_CAPT_MSGP       (BASE_BLT_IDS+2)  // run out of memory or resources
                                                  // (loaded at startup time by InitMsgPopup)
#define IDS_BLT_OutOfMemory     (BASE_BLT_IDS+3)  // BLT out of memory error message
#define IDS_BLT_WinHelpError    (BASE_BLT_IDS+4)  // BLT can't load win help error


#define IDS_BLT_30_WinHelpFile  (BASE_BLT_IDS+5)  // Win 3.0 help file name
#define IDS_BLT_31_WinHelpFile  (BASE_BLT_IDS+6)  // Win 3.1 & greater Help file name

#define IDS_BLT_DOSERROR_MSGP   (BASE_BLT_IDS+8)
#define IDS_BLT_NETERROR_MSGP   (BASE_BLT_IDS+9)
#define IDS_BLT_WINNET_ERROR_MSGP (BASE_BLT_IDS+10)

#define IDS_BLT_ELLIPSIS_TEXT   ( BASE_BLT_IDS + 11 )

#define IDS_BLT_NTSTATUS_ERROR_MSGP (BASE_BLT_IDS+12)

#define IDS_BLT_SB_SLENUM_OUTRANGE  ( BASE_BLT_IDS + 18 )

#define IDS_DAY_TOO_BIG         ( BASE_BLT_IDS + 22 )
#define IDS_FEBRUARY_LEAP       ( BASE_BLT_IDS + 23 )
#define IDS_FEBRUARY_NOT_LEAP   ( BASE_BLT_IDS + 24 )

#define IDS_MONTH               ( BASE_BLT_IDS + 25 )
#define IDS_DAY                 ( BASE_BLT_IDS + 26 )
#define IDS_YEAR                ( BASE_BLT_IDS + 27 )
#define IDS_HOUR                ( BASE_BLT_IDS + 28 )
#define IDS_MIN                 ( BASE_BLT_IDS + 29 )
#define IDS_SEC                 ( BASE_BLT_IDS + 30 )

#define IDS_K                   ( BASE_BLT_IDS + 36 )
#define IDS_MB                  ( BASE_BLT_IDS + 37 )
#define IDS_GB                  ( BASE_BLT_IDS + 38 )
#define IDS_TB                  ( BASE_BLT_IDS + 39 )

#define IDS_FIELD               ( BASE_BLT_IDS + 40 )

#define IDS_BLT_FMT_SYS_error   ( BASE_BLT_IDS + 41 )
#define IDS_BLT_FMT_NET_error   ( BASE_BLT_IDS + 42 )
#define IDS_BLT_FMT_other_error ( BASE_BLT_IDS + 43 )

#define IDS_BLT_UNKNOWN_ERROR   ( BASE_BLT_IDS + 44 )

#define IDS_FIXED_TYPEFACE_NAME ( BASE_BLT_IDS + 45 )

/* MsgPopup manifests
 */
#define IDHELPBLT           (80)
#define IDC_MSGPOPUPICON    (81)        // Icon control ID on message popup dialog
#define IDC_MSGPOPUPTEXT    (82)        // Static message text in message box
#define IDHC_MSG_TO_HELP    22000       // Name of Help context lookup table

#define BMID_UP             20000
#define BMID_UP_INV         20001
#define BMID_UP_DIS         20002
#define BMID_DOWN           20003
#define BMID_DOWN_INV       20004
#define BMID_DOWN_DIS       20005
#define BMID_LEFT           20006
#define BMID_LEFT_INV       20007
#define BMID_RIGHT          20008
#define BMID_RIGHT_INV      20009


#endif // _BLTRC_H_ - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\bltstyle.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltstyle.h
    Style bits for BLT custom controls

    This file defines and coordinates the style bits of all BLT custom
    controls.

    FILE HISTORY:
        beng    21-Feb-1992 Separated from bltrc.h
*/

#ifndef _BLTSTYLE_H_
#define _BLTSTYLE_H_

// if defined, the SPIN_SLE_NUM will add zero in front of the number to
// be display. The number of zero is equal to the length of the max output
// number - the current number's length
//
#define SPIN_SSN_ADD_ZERO   0x1000L

// if the style is defined, the GRAPHICAL_BUTTON_WITH_DISABLE will be 3D.
// otherwise, it will be 2 d.
//
#define GB_3D               0x1000L


#endif // _BLTSTYLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\declspec.h ===
//
//  DECLSPEC.H:  Define the DLL_BASED and DLL_CLASS manifests for
//               DLL export/import decoration
//

//  BUGBUG:  Temporarily DISABLED until __declspec works better
//
//  If a fixed header files is needed, define _DECLSPEC_WORKS_ and this 
//  header file will work correctly.
//
#if !defined(_DECLSPEC_WORKS_)
#if !defined(_DECLSPEC_H_)

#define _DECLSPEC_H_

//   Create benign definitions for __declspec macros.
#define DLL_TEMPLATE
#define DLL_CLASS class
#define DLL_BASED

#endif
#endif

#if !defined(_DECLSPEC_H_)

#define _DECLSPEC_H_

//
//  DECLSPEC.H:  Define the DLL_BASED and DLL_CLASS manifests for
//               DLL export/import decoration
//
//   This file is based upon the following macro definitions:
//
//        _CFRONT_PASS_     defined in MAKEFILE.DEF for CFRONT preprocessing;
//
//        _cplusplus        defined for all C++ compilation;
//
//        NETUI_DLL         defined in $(UI)\COMMON\SRC\DLLRULES.MK, which is
//                          included by all components which live in NETUI DLLs.
//
//        DLL_BASED_DEFEAT  optional manifest that suppresses __declspec;
//
//  This file generates two definitions:
//
//        DLL_BASED         which indicates that the external function, data item
//                          or class lives in a NETUI DLL; expands to nothing,
//                          "_declspec(dllimport)", or "_declspec(dllexport)"
//                          depending upon the manifest above.
//
//        DLL_CLASS         which expands to "class", "class _declspec(dllimport)",
//                          or "class _declspec(dllexport)" depending on the
//                          manifests above.
//
//        DLL_TEMPLATE      expands to nothing outside of the DLLs; expands to
//                          DLL_BASED inside the DLLs.   In other words, the standard
//                          template is local to the defining link scope.  To
//                          declare a template as "dllimport", another set of
//                          macros exists which allows direct specification of the
//                          desired decoration.
//

#if defined(_CFRONT_PASS_)
  #define DLL_BASED_DEFEAT
#endif

  //  Define DLL_BASED for all compiles

#if defined(DLL_BASED_DEFEAT)
  //  If CFront, no decoration allowed
  #define DLL_BASED
#else
  #if defined(NETUI_DLL)
    // If C8 and inside DLL, export stuff
    #define DLL_BASED __declspec(dllexport)
  #else
    // If C8 and inside DLL, import stuff
    #define DLL_BASED __declspec(dllimport)
  #endif
#endif

  //  If C++, define the DLL_CLASS and DLL_TEMPLATE macros

#if defined(__cplusplus)

  #if defined(DLL_BASED_DEFEAT)
    //  If CFRONT, no decoration allowed
    #define DLL_CLASS class
    #define DLL_TEMPLATE
  #else
    #define DLL_CLASS class DLL_BASED
    #if defined(NETUI_DLL)
      //  Templates expanded in the DLL are exported
      #define DLL_TEMPLATE DLL_BASED
    #else
      #define DLL_TEMPLATE
    #endif
  #endif

#endif

#endif  //  !_DECLSPEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\bltcons.h ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    bltcons.h
    BLT constants

    FILE HISTORY:
    Rustan M. Leino   21-Nov-1990   Created
    Johnl	      12-Feb-1991   Added MsgPopup manifests
    rustanl	      19-Feb-1991   Added COL_WIDTH manifests
    Johnl	       5-Mar-1991   Removed DMID stuff

*/


/*  The following manifests are for drawing listbox items.
 */

//  number of pixels within a listbox column that are unused to separate
//  columns
#define DISP_TBL_COLUMN_DELIM_SIZE	(2)

//  width of a display map in pixels
#define COL_WIDTH_DM			( 16 + DISP_TBL_COLUMN_DELIM_SIZE )

//  width of a wide display map in pixels
#define COL_WIDTH_WIDE_DM		( 32 + DISP_TBL_COLUMN_DELIM_SIZE )

//  The width of the last column always streches to the right edge of the
//  listbox.  The client should, as a good programmer, still fill in
//  the last column width specified in the array of column widths passed
//  to the DISPLAY_TABLE constructor.  Rather than that the client pulls
//  up some number from a hat, he can assign the following manifest.  The
//  manifest is defined as 0, but could actually be assigned any number
//  (except negative ones, because no column width should be negative).
//  AWAP stands for As Wide As Possible.
#define COL_WIDTH_AWAP			( 0 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\focusdlg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    focusdlg.h
    Header file for focus dialog IDC values.

    FILE HISTORY:
        terryk  18-Nov-1991 Created
        beng    20-Feb-1992 Uses BASE_APPLIB_IDD
        beng    21-Feb-1992 Uses applibrc.h
*/

#ifndef _FOCUSDLG_H_
#define _FOCUSDLG_H_

#include "applibrc.h"

#define IDC_FOCUS_PATH      104
#define IDC_DOMAIN_LB       106
#define IDC_SEL_LB_TITLE    107
#define IDC_BOUNDARY        108
#define IDC_LINK            109
#define IDC_SLE_GETINFO     110
#define IDC_LINK_MESSAGE    111

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\lmobjrc.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmobjrc.h
    LMOBJ resource header file.

    This file defines and coordinates the resource IDs of all resources
    used by LMOBJ components.

    LMOBJ reserves for its own use all resource IDs above 15000, inclusive,
    but less than 20000 (where the BLT range begins).  All clients of APPLIB
    therefore should use IDs of less than 15000.

    FILE HISTORY:
        thomaspa    9-July-1992 Created
*/

#ifndef _LMOBJRC_H_
#define _LMOBJRC_H_

#include "uimsg.h"

/*
 * string IDs
 */
#define IDS_LMOBJ_SIDUNKNOWN	(IDS_UI_LMOBJ_BASE+0)
#define IDS_LMOBJ_SIDDELETED	(IDS_UI_LMOBJ_BASE+1)

//
// JonN 9/20/96
// NETUI2.DLL keeps these strings on behalf of PROFEXT.DLL.
//
#define IDS_PROFEXT_NOADAPTERS	(IDS_UI_LMOBJ_BASE+2)
#define IDS_PROFEXT_ERROR	(IDS_UI_LMOBJ_BASE+3)
#define IDS_CFGMGR32_BASE   (IDS_UI_LMOBJ_BASE+10)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\lmuicmn.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmuicmn.h
    Definitions for the common LMUI libraries

    This file must remain C-includable.

    FILE HISTORY:
        beng        30-Jul-1992 Created
*/

extern "C"
{
    // BLT corresponds to the module handle for lmuicmn0.dll,
    // which contains (or attempts to contain) all the GUI components.

    extern HMODULE hmodBlt;

    // BASE corresponds to the module handle for lmuicmn1.dll,
    // which contains LMOBJ, the registry classes, etc.

    extern HMODULE hmodBase;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\domenum.h ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    domenum.h
    This file contains the bitflags used to control the BROWSE_DOMAIN_ENUM
    domain enumerator.


    FILE HISTORY:
        KeithMo     22-Jul-1992     Created.

*/

#ifndef _DOMENUM_H
#define _DOMENUM_H


#define BROWSE_LOGON_DOMAIN         0x00000001
#define BROWSE_WKSTA_DOMAIN         0x00000002
#define BROWSE_OTHER_DOMAINS        0x00000004
#define BROWSE_TRUSTING_DOMAINS     0x00000008
#define BROWSE_WORKGROUP_DOMAINS    0x00000010


//
//  Some handy combinations of flags.
//

//
//  BROWSE_LM2X_DOMAINS will return only the domains available
//  from a LanMan 2.x workstation.  This returns just the logon,
//  workstation, and other domains.
//

#define BROWSE_LM2X_DOMAINS         ( BROWSE_LOGON_DOMAIN       | \
                                      BROWSE_WKSTA_DOMAIN       | \
                                      BROWSE_OTHER_DOMAINS )

//
//  BROWSE_LOCAL_DOMAINS will return only the domains available
//  to the local machine.  This returns the logon, workstation,
//  and other, plus the domains that trust "us".
//

#define BROWSE_LOCAL_DOMAINS        ( BROWSE_LM2X_DOMAINS       | \
                                      BROWSE_TRUSTING_DOMAINS )

//
//  BROWSE_ALL_DOMAINS is a conglomeration of all potential domain
//  sources available to the domain enumerator.
//

#define BROWSE_ALL_DOMAINS          ( BROWSE_LOCAL_DOMAINS      | \
                                      BROWSE_WORKGROUP_DOMAINS )

//
//  BROWSE_RESERVED contains the reserved bits in the domain enumerator
//  control flags.  Nobody should be passing in any of these bits.
//

#define BROWSE_RESERVED             ( ~BROWSE_ALL_DOMAINS )


#endif  // _DOMENUM_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\lmuidbcs.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/

/*
    lmuidbcs.h

    FILE HISTORY:
        JonN        11-Sep-1995     Created

*/



#ifndef _LMUIDBCS_H_
#define _LMUIDBCS_H_

BOOL NETUI_IsDBCS();

#endif  // _LMUIDBCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\locheap2.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

#ifndef WINDOWS
#error "Only use these APIs under Windows!"
#endif

/****************************************************************************\

	LOCHEAP2.h
	Local-heap management helper routines

	These utility routines provide access to Windows local heaps in
	segments other than DS (the data segment).  They are exactly
	like the LocalInit, LocalAlloc, LocalFree, LocalLock, 
	LocalUnlock, Local handle and LocalSize APIs, except that they
	act on the heap in segment wHeapDS instead of the heap in DS.

	These routines are used primarily by the heap management system
	(see heap.cxx).  They are also used by the
	HEAP_HANDLE/ELEMENT_HANDLE module (see loclheap.hxx).

	USAGE:

	HANDLE hGlobal = GlobalAlloc( GMEM_MOVEABLE, 1024 );
	if ( !hGlobal )
	    error();

	LPSTR lpGlobal = GlobalLock( hGlobal );
	if ( !lpGlobal )
	    error();

	{
	    if ( !DoLocalInit( hGlobal, 1024 ) )
	        error();

	    HANDLE hLocal = DoLocalAlloc( HIWORD(lpGlobal), 128 );
	    if ( !hLocal )
		error();

	    LPSTR lpLocal = DoLocalLock( HIWORD(lpGlobal), hLocal );
	    if ( !lpLocal )
		error();

	    {
		HANDLE hLocal2 = DoLocalHandle(
			HIWORD(lpGlobal), LOWORD(lpLocal) );
		if (hLocal2 != hLocal)
		    error();

		WORD wSize = DoLocalSize( HIWORD(lpGlobal), hLocal );
	        if ( !wSize )
		    error();
	    }

	    DoLocalUnlock( HIWORD(lpGlobal), hLocal );

	    if ( DoLocalFree( HIWORD(lpGlobal), hLocal ) )
		error();
	}

	GlobalUnlock( hGlobal );

	GlobalFree( hGlobal );


	FILE HISTORY:

	jonn	24-Jan-1991	Created
	jonn	21-Mar-1991	Code review changes from 2/20/91 (attended
				by JonN, RustanL, ?)

\****************************************************************************/


#ifndef _LOCHEAP2_H_
#define _LOCHEAP2_H_


BOOL DoLocalInit(WORD wHeapDS, WORD wBytes);

HANDLE DoLocalAlloc(WORD wHeapDS, WORD wFlags, WORD wBytes);

HANDLE DoLocalFree(WORD wHeapDS, HANDLE handleFree);

LPSTR DoLocalLock(WORD wHeapDS, HANDLE handleLocal);

VOID DoLocalUnlock(WORD wHeapDS, HANDLE handleLocal);

HANDLE DoLocalHandle(WORD wHeapDS, WORD wMem);

WORD DoLocalSize(WORD wHeapDS, HANDLE handleLocal);


#endif // _LOCHEAP2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\lmuiwarn.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmuiwarn.hxx:

        This file contains #pragmas which suppress warnings
        we deem to be unnecessary.

        History:

            DavidHov    9/24/93     Created
                                    Disabled C4003: not enough parameters
                                            for preprocessor macro
                                    Disabled C4355: 'this' used in base
                                            member initializer.

*/

#if !defined(_LMUIWARN_HXX_)
#  define _LMUIWARN_HXX_
#  if !defined(_CFRONT_PASS_)
#     pragma warning( disable: 4003 4355 )
#  endif  // !_CFRONT_PASS_
#endif  // _LMUIWARN_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\mnet32.h ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    mnet32.h
    <Single line synopsis>

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
	KeithMo	    13-Oct-1991	Created from DanHi's private port1632.h.
	terryk	    21-Oct-1991	change SERVER_INFO and USER_LOGON
	terryk	    31-Oct-1991	add use_info_2
	Yi-HsinS     5-Feb-1992	add the missing ae_resaccess
*/


#ifndef _MNET32_H_
#define _MNET32_H_


//
//  The following items are necessary under Windows NT.  These
//  were ripped off from DanHi's PORT1632.H.
//

#ifdef WIN32

// #define LPWSTR			LPSTR	    // Until proven otherwise...

 #define MAXPATHLEN		MAX_PATH

 #define WORKBUFSIZE		4096
 #define MAXWORKSTATIONS	8

 //
 // Temporary hacks.
 //

 #define AE_GENERIC		AE_GENERIC_TYPE
 #define GRP1_PARMNUM_COMMENT	GROUP_COMMENT_PARMNUM

 //
 // End of temporary hacks.
 //
 // (Wishful thinking, eh?)
 //

 #define MAXPREFERREDLENGTH	MAX_PREFERRED_LENGTH

 //
 // The naming convention for structures is different in NT than in LM 2.x.
 //

 #define audit_entry		_AUDIT_ENTRY
 #define ae_srvstatus		_AE_SRVSTATUS
 #define ae_sesslogon		_AE_SESSLOGON
 #define ae_sesslogoff		_AE_SESSLOGOFF
 #define ae_sesspwerr		_AE_SESSPWERR
 #define ae_connstart		_AE_CONNSTART
 #define ae_connstop		_AE_CONNSTOP
 #define ae_connrej		_AE_CONNREJ
 #define ae_resaccess		_AE_RESACCESS
 #define ae_resaccess2		_AE_RESACCESS
 
 #define ae_ra2_compname	ae_ra_compname
 #define ae_ra2_username	ae_ra_username
 #define ae_ra2_resname		ae_ra_resname
 #define ae_ra2_operation	ae_ra_operation
 #define ae_ra2_returncode	ae_ra_returncode
 #define ae_ra2_restype		ae_ra_restype
 #define ae_ra2_fileid		ae_ra_fileid
 
 #define ae_resaccessrej	_AE_RESACCESSREJ
 #define ae_closefile		_AE_CLOSEFILE
 #define ae_servicestat		_AE_SERVICESTAT
 #define ae_aclmod		_AE_ACLMOD
 #define ae_uasmod		_AE_UASMOD
 #define ae_netlogon		_AE_NETLOGON
 #define ae_netlogoff		_AE_NETLOGOFF
 #define ae_acclim		_AE_ACCLIM
 #define ae_lockout             _AE_LOCKOUT
 #define ae_generic		_AE_GENERIC
 #define error_log		_ERROR_LOG
 #define user_info_0		_USER_INFO_0
 #define user_info_1		_USER_INFO_1
 #define user_info_2		_USER_INFO_2
 #define user_info_10		_USER_INFO_10
 #define user_info_11		_USER_INFO_11
 #define user_modals_info_0	_USER_MODALS_INFO_0
 #define user_modals_info_1	_USER_MODALS_INFO_1
 #define user_logon_req_1	_USER_LOGON_REQ_1
 #define user_logon_info_0	_USER_LOGON_INFO_0
 // WIN32BUGBUG
 // should be INFO_1
 #define user_logon_info_1	_USER_LOGON_INFO_2
 #define user_logon_info_2	_USER_LOGON_INFO_2
 #define user_logoff_req_1	_USER_LOGOFF_REQ_1
 #define user_logoff_info_1	_USER_LOGOFF_INFO_1
 #define group_info_0		_GROUP_INFO_0
 #define group_info_1		_GROUP_INFO_1
 #define group_users_info_0	_GROUP_USERS_INFO_0
 #define access_list		_ACCESS_LIST
 #define access_info_0		_ACCESS_INFO_0
 #define access_info_1		_ACCESS_INFO_1
 #define chardev_info_0		_CHARDEV_INFO_0
 #define chardev_info_1		_CHARDEV_INFO_1
 #define chardevQ_info_0	_CHARDEVQ_INFO_0
 #define chardevQ_info_1	_CHARDEVQ_INFO_1
 #define msg_info_0		_MSG_INFO_0
 #define msg_info_1		_MSG_INFO_1
 #define statistics_info_0	_STATISTICS_INFO_0
 #define stat_workstation_0	_STAT_WORKSTATION_0
 #define stat_server_0		_STAT_SERVER_0
 #define service_info_0		_SERVICE_INFO_0
 #define service_info_1		_SERVICE_INFO_1
 #define service_info_2		_SERVICE_INFO_2
 #define share_info_0		_SHARE_INFO_0
 #define share_info_1		_SHARE_INFO_1
 #define share_info_2		_SHARE_INFO_2
 #define session_info_0		_SESSION_INFO_0
 #define session_info_1		_SESSION_INFO_1
 #define session_info_2		_SESSION_INFO_2
 #define session_info_10	_SESSION_INFO_10
 #define connection_info_0	_CONNECTION_INFO_0
 #define connection_info_1	_CONNECTION_INFO_1
 #define file_info_0		_FILE_INFO_0
 #define file_info_1		_FILE_INFO_1
 #define file_info_2		_FILE_INFO_2
 #define file_info_3		_FILE_INFO_3
 #define res_file_enum_2	_RES_FILE_ENUM_2
 #define res_file_enum_2	_RES_FILE_ENUM_2
 #define use_info_0		_USE_INFO_0
 #define use_info_1		_USE_INFO_1
 #define use_info_2		_USE_INFO_2
 #define time_of_day_info	_TIME_OF_DAY_INFO
 
 //
 // Macros to support old style resume keys.
 //

 typedef DWORD		FRK;
 #define FRK_INIT(x)	(x) = 0

#endif	// WIN32


#endif	// _MNET32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\mbcs.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MBCS.H

Abstract:

    Contains mapping functions which transform Unicode strings
    (used by the NT Net APIs) into MBCS strings (used by the
    command-line interface program).

    Prototypes.  See MBCS.C.

Author:

    Ben Goetter     (beng)  26-Aug-1991

Environment:

    User Mode - Win32

Revision History:

    26-Aug-1991     beng
        Created

--*/


/*

The SAVEARGS structure holds the client-supplied field values which
the mapping layer has replaced, so that it may restore them before
returning the buffer to the client.  (The client may wish to reuse
the buffer, and so may expect the previous contents to remain invariant
across calls.  In particular, clients may replace single parameters,
such as passwords deemed incorrect, and try to call again with the
remaining structure left alone.)

An instance of SAVEARGS is accessed but twice in its lifetime: once
when it is built and once when it is freed.

*/

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _MXSAVEARG // mxsav
{
    UINT    offThis;     // offset of this arg within buffer, in bytes
    LPSTR   pszOriginal; // original value of arg
} MXSAVEARG;

typedef struct _MXSAVELIST // mxsavlst
{
    INT         cmxsav; // number of elements in vector
    MXSAVEARG * pmxsav; // pointer to first element in vector
} MXSAVELIST;



// Function prototypes

DLL_BASED
UINT MxAllocUnicode(       LPSTR         pszAscii,
                           LPWSTR *      ppwszUnicode );

DLL_BASED
VOID MxFreeUnicode(        LPWSTR        pwszUnicodeAllocated );

DLL_BASED
UINT MxAllocUnicodeVector( LPSTR *       ppszAscii,
                           LPWSTR *      ppwszUnicode,
                           UINT          c );

DLL_BASED
VOID MxFreeUnicodeVector(  LPWSTR *      ppwsz,
                           UINT          cpwsz );

DLL_BASED
UINT MxAllocUnicodeBuffer( LPBYTE        pbAscii,
                           LPWCH *       ppwchUnicode,
                           UINT          cbAscii );

#define MxFreeUnicodeBuffer(buf) (MxFreeUnicode((LPWSTR)(buf)))

#define MxUnicodeBufferSize(size) (sizeof(WCHAR)/sizeof(CHAR)*(size))

DLL_BASED
UINT MxAsciifyInplace(     LPWSTR        pwszUnicode );

DLL_BASED
UINT MxAllocSaveargs(      UINT          cmxsav,
                           MXSAVELIST ** ppmxsavlst );

DLL_BASED
VOID MxFreeSaveargs(       MXSAVELIST *  ppmxsavlst );

DLL_BASED
UINT MxJoinSaveargs(       MXSAVELIST *  pmxsavlstMain,
                           MXSAVELIST *  pmxsavlstAux,
                           UINT          dbAuxFixup,
                           MXSAVELIST ** ppmxsavlstOut );

DLL_BASED
UINT MxMapParameters(      UINT          cParam,
                           LPWSTR*       ppwszUnicode,
                           ... );

DLL_BASED
UINT MxMapClientBuffer(    BYTE *        pbInput,
                           MXSAVELIST ** ppmxsavlst,
                           UINT          cRecords,
                           CHAR *        pszDesc );

DLL_BASED
UINT MxMapClientBufferAux( BYTE *        pbInput,
                           CHAR *        pszDesc,
                           BYTE *        pbInputAux,
                           UINT          cRecordsAux,
                           CHAR *        pszDescAux,
                           MXSAVELIST ** ppmxsavlst );

DLL_BASED
VOID MxRestoreClientBuffer(BYTE *        pbBuffer,
                           MXSAVELIST *  pmxsavlst );

DLL_BASED
UINT MxMapSetinfoBuffer(   BYTE * *      ppbInput,
                           MXSAVELIST ** ppmxsavlst,
                           CHAR *        pszDesc,
                           CHAR *        pszRealDesc,
                           UINT          nField );

DLL_BASED
UINT MxRestoreSetinfoBuffer( BYTE * *     ppbBuffer,
                             MXSAVELIST * pmxsavlst,
                             CHAR *       pszDesc,
                             UINT         nField );

DLL_BASED
UINT MxAsciifyRpcBuffer(     BYTE *      pbInput,
                             DWORD       cRecords,
                             CHAR *      pszDesc );

DLL_BASED
UINT MxAsciifyRpcBufferAux(  BYTE *      pbInput,
                             CHAR *      pszDesc,
                             BYTE *      pbInputAux,
                             DWORD       cRecordsAux,
                             CHAR *      pszDescAux );

DLL_BASED
UINT MxAsciifyRpcEnumBufferAux( BYTE *  pbInput,
                                DWORD   cRecords,
                                CHAR *  pszDesc,
                                CHAR *  pszDescAux );

DLL_BASED
UINT MxCalcNewInfoFromOldParm( UINT nLevelOld,
                               UINT nParmnumOld );

// These macros are used by all the functions which use the canonicalization
// routines. They are used to optionally translate Ascii to Unicode, without
// asking for more memory if no conversion is necessary.

#ifdef UNICODE

#define MxAllocTString(pszAscii, pptszTString) \
    MxAllocUnicode((pszAscii), (pptszTString))
#define MxFreeTString(ptszTString) \
    MxFreeUnicode((ptszTString))

#else

#define MxAllocTString(pszAscii, pptszTString) \
    ((*(pptszTString) = (pszAscii)), 0)
#define MxFreeTString(ptszTString)

#endif

DLL_BASED
UINT MxMapStringsToTStrings(      UINT          cStrings,
                                  ... );

DLL_BASED
UINT MxFreeTStrings(              UINT          cStrings,
                                  ... );

#ifdef __cplusplus
}       // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\lmuitype.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmuitype.h
    Basic types (int, char, etc.) for LM UI apps

    Sad, but true: OS/2 and Windows don't agree on basic type
    definitions such as pointer-to-char, etc.  This file attempts
    to strike a compromise between both camps (and hence will
    certainly please nobody).

    There are incompatibilities with both OS/2 and Win in this file:

    .  OS/2 expects all its "Ptype" definitions to be FAR;
       hence including this file and os2.h in a small- or medium-
       model program will break API prototypes.  However, as only
       Windows programs need default near data, this probably will
       never bite us.

    .  A couple of OS/2 PM definitions - ODPOINT, VioPresentationSpace -
       seem to use TCHAR as a signed quantity, where we use TCHAR as
       unsigned always, for consistency with PCH/PSZ and good NLS
       behavior.

    .  OS/2 BOOL is USHORT, where on Win it is INT.

    .  Most of the Win basic types hardcode near-data assumptions
       in their "Ptype" definitions.  We define those pointers as
       default-data-model; this does not break API definitions only
       because those definitions prototypes use the LP or NP forms.

    Two auxiliary sed scripts excise these definitions from windows.h
    and os2def.h, in order to avoid conflicts.  See $(UI)\common\hack.


    FILE HISTORY
        beng        05-Feb-1991 Added this file to $(UI)\common\h
        beng        15-Mar-1991 Added UNREFERENCED macro
        beng        21-Mar-1991 Added WCHAR type
        beng        18-Apr-1991 Added APIERR type
        beng        26-Apr-1991 Removed PB, IB, CB types
        jonn        12-Sep-1991 Changes to support WIN32
        jonn        29-Sep-1991 More changes to support WIN32
        beng        07-Oct-1991 Added MSGID
        KeithMo     08-Oct-1991 Changed APIERR from USHORT to UINT
        beng        09-Oct-1991 Further Win32 work - incorporate ptypes%d
        beng        14-Oct-1991 ptypes relocated to lmui.hxx
        jonn        19-Oct-1991 Added LPTSTR
        jonn        20-Oct-1991 Added SZ(), removed LPTSTR
        beng        23-Oct-1991 WORD now unsigned short; CCH_INT for Win32
        beng        19-Nov-1991 APIERR delta (pacify paranoid NT compiler)
        jonn        09-Dec-1991 updated windows.h
        jonn        26-Dec-1991 Fixed compiler warning from MAKEINTRESOURCE
        jonn        04-Jan-1992 MIPS build is large-model
        beng        22-Feb-1992 CHAR->TCHAR; merge winnt types
        beng        18-Mar-1992 Fix HFILE on NT (thanks David)
        beng        28-Mar-1992 Fix SZ def'n, add TCH
        KeithMo     01-Apr-1992 Null out cdecl & _cdecl under MIPS.
        beng        01-Apr-1992 Fix HFILE on NT, for sure this time
        beng        01-Jul-1992 Emasculated Win32 version to use system defns
        KeithMo     25-Aug-1992 #define MSGID instead of typedef (warnings...)
*/

#if !defined(_LMUITYPE_H_)
#define _LMUITYPE_H_

#define NOBASICTYPES /* this to override windows.h, os2def.h basic types */

#ifndef NULL
#define NULL            0
#endif

#define VOID            void

// These keywords do not apply to NT builds
//
#if defined(WIN32)
// FAR, NEAR, PASCAL already supplied
#define CDECL
#define LOADDS
#define _LOADDS
#define _EXPORT
#define MFARPROC ULONG_PTR
#if defined(_MIPS_) || defined(_PPC_)
#define cdecl
#define _cdecl
#endif  // MIPS
#else
#define NEAR            _near
#define FAR             _far
#define PASCAL          _pascal
#define CDECL           _cdecl
#define LOADDS          _loadds
#define _LOADDS         _loadds
#define _EXPORT         _export
#define MFARPROC        FARPROC
#endif // WIN32

// TCHAR is the "transmutable char" type of NT.
// SZ is netui's transmutable text macro.  TEXT is its NT equivalent.
//
#if !defined(WIN32)
#if defined(UNICODE)
#define TCHAR           WCHAR
#define SZ(quote)       (WCHAR*)L##quote
#define TCH(quote)      L##quote
#define TEXT(quote)     L##quote
#else
#define TCHAR           CHAR
#define SZ(quote)       quote
#define TCH(quote)      quote
#define TEXT(quote)     quote
#endif
#else
#if defined(UNICODE)
#define SZ(quote)       (WCHAR*)L##quote
#define TCH(quote)      L##quote
#else
#define SZ(quote)       quote
#define TCH(quote)      quote
#endif
#endif


// The basics
//
// CHAR is defined with a macro so that the compiler can init a static
// array of it with a static string.
//

#if defined(WIN32)

// These are typedef'ed by winnt.h iff VOID is not defined
#define CHAR char
typedef short           SHORT;
typedef long            LONG;
// typedef unsigned int    UINT;

#else

typedef unsigned short  WCHAR;
typedef int             INT;
typedef short           SHORT;
typedef long            LONG;
typedef unsigned int    UINT;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;
typedef int             BOOL;
# define FALSE 0
# define TRUE  1
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned long   DWORD;

typedef CHAR *          PCHAR;
typedef INT *           PINT;
typedef UINT *          PUINT;
typedef USHORT *        PUSHORT;
typedef ULONG *         PULONG;
typedef BOOL *          PBOOL;
typedef BYTE *          PBYTE;
typedef WORD *          PWORD;
typedef DWORD *         PDWORD;

typedef VOID *          PVOID;
typedef LONG *          PLONG;
typedef SHORT *         PSHORT;

/* Added for NT builds */

typedef float           FLOAT;
typedef FLOAT *         PFLOAT;
typedef BOOL FAR *      LPBOOL;


// Note: Glock says "f682: signed not implemented.0"  NT's C++ does not
// implement "signed", so remove it to prevent compiler warnings.
//
#if defined(__cplusplus)
extern void * operator new ( size_t sz, void * pv ) ;
typedef char            SCHAR;
#else
# if defined(WIN32)
typedef char            SCHAR;
# else
typedef signed char     SCHAR;
# endif
#endif


/* OS/2 style definitions (for OS/2 API prototypes) - DO NOT USE! */

typedef USHORT          SEL;
typedef SEL *           PSEL;

typedef unsigned char   UCHAR;
typedef UCHAR *         PUCHAR;

typedef CHAR *          PSZ;
typedef CHAR *          PCH;

typedef int (PASCAL FAR  *PFN)();
typedef int (PASCAL NEAR *NPFN)();
typedef PFN FAR *         PPFN;

#define EXPENTRY PASCAL FAR LOADDS
#define APIENTRY PASCAL FAR

typedef unsigned short  SHANDLE;    // defining these here makes the sed pass
typedef void FAR *      LHANDLE;    //  over os2def.h very much simpler

#if defined(WIN32)
typedef UINT            HFILE;
#else
typedef SHANDLE         HFILE;
#endif
typedef HFILE FAR *     PHFILE;


/* OS/2 LM style definitions (for LAN Manager prototypes) - DO NOT USE! */

typedef const CHAR *    CPSZ;  // BUGBUG: bad Hungarian


/* Windows style definitions (for Win API prototypes only) */

typedef CHAR *          PSTR;
typedef WCHAR *         PWSTR;
typedef WCHAR *         PWCH;


/* NEAR and FAR versions (for Windows prototypes) */

// These definitions use preprocessor macros so that Glockenspiel
// can see type equivalence between (e.g.) LPSTR and PCHAR.  They
// elide NEAR and FAR where possible to reduce complaints from its
// flat-model-only (ha!) C++.  So it's all Glock's fault, as always.

// CODEWORK This will break X86 16-bit build
// #if (defined(M_I86SM) || defined(M_I86MM))
#if !defined(_MIPS_) && !defined(_PPC_)
#define NPTSTR          TCHAR *
#define LPTSTR          TCHAR FAR *
#define NPSTR           CHAR *
#define LPSTR           CHAR FAR *
#define NPWSTR          WCHAR *
#define LPWSTR          WCHAR FAR *
#define NPBYTE          BYTE *
#define LPBYTE          BYTE FAR *
#define NPINT           INT *
#define LPINT           INT FAR *
#define NPWORD          WORD *
#define LPWORD          WORD FAR *
#define NPLONG          LONG *
#define LPLONG          LONG FAR *
#define NPDWORD         DWORD *
#define LPDWORD         DWORD FAR *
#define NPVOID          VOID *
#define LPVOID          VOID FAR *
// #elif (defined(M_I86CM) || defined(M_I86LM) || defined(MIPS))
#else
#define NPTSTR          TCHAR NEAR *
#define LPTSTR          TCHAR *
#define NPSTR           CHAR NEAR *
#define LPSTR           CHAR *
#define NPWSTR          WCHAR NEAR *
#define LPWSTR          WCHAR *
#define NPBYTE          BYTE NEAR *
#define LPBYTE          BYTE *
#define NPINT           INT NEAR *
#define LPINT           INT *
#define NPWORD          WORD NEAR *
#define LPWORD          WORD *
#define NPLONG          LONG NEAR *
#define LPLONG          LONG *
#define NPDWORD         DWORD NEAR *
#define LPDWORD         DWORD *
#define NPVOID          VOID NEAR *
#define LPVOID          VOID *
// #else
// #error Memory model unknown - no recognized M_I86xM symbol defined
#endif

#define LPCSTR          const CHAR *


/* Useful helper macros */

#define MAKEP(sel, off) ((PVOID)MAKEULONG(off, sel))

#define SELECTOROF(p)   (((PUSHORT)&(p))[1])
#define OFFSETOF(p)     (((PUSHORT)&(p))[0])

#define MAKEULONG(l, h) ((ULONG)(((USHORT)(l)) | ((ULONG)((USHORT)(h))) << 16))
#define MAKELONG(l, h)  ((LONG)MAKEULONG(l, h))

#define MAKELP(sel, off) ((void *)MAKELONG((off),(sel)))
#define FIELDOFFSET(type, field)  ((int)(&((type NEAR*)1)->field)-1)

#define MAKEUSHORT(l, h) (((USHORT)(l)) | ((USHORT)(h)) << 8)
#define MAKESHORT(l, h)  ((SHORT)MAKEUSHORT(l, h))

#define LOBYTE(w)       LOUCHAR(w)
#define HIBYTE(w)       HIUCHAR(w)
#define LOUCHAR(w)      ((UCHAR)(USHORT)(w))
#define HIUCHAR(w)      ((UCHAR)(((USHORT)(w) >> 8) & 0xff))
#define LOUSHORT(l)     ((USHORT)(ULONG)(l))
#define HIUSHORT(l)     ((USHORT)(((ULONG)(l) >> 16) & 0xffff))

#define LOWORD LOUSHORT
#define HIWORD HIUSHORT

#endif // !WIN32


/* NETUI private types */

/* Error type - what the system APIs return.

   On Win32, this is defined as signed long, in order to pacify the
   compiler, which complains when you assign a long constant
   to an unsigned int (never mind that they're the same size). */

#if defined(WIN32)
typedef LONG    APIERR; // err
#else
typedef UINT    APIERR; // err
#endif // WIN32

/* String resource ID type */

#define MSGID   APIERR

//-ckm #if defined(WIN32)
//-ckm typedef unsigned int   MSGID;  // msg
//-ckm #else
//-ckm typedef UINT           MSGID;  // msg
//-ckm #endif // WIN32

/* Silence the compiler for unreferenced formals. */

#define UNREFERENCED(x) ((void)(x))


/* These define buffer sizes (in TCHAR, no terminators) for rendering
   signed integers into strings, decimal format. */

#define CCH_SHORT   6
#define CCH_LONG    11
#if defined(WIN32)
#define CCH_INT     11
#else
#define CCH_INT     6
#endif
#define CCH_INT64   21

#endif // _LMUITYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\mnettype.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    mnettype.h
    <Single line synopsis>

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
        JonN        22-Oct-1991 Split from mnet.h
        KeithMo     29-Oct-1991 Added HLOG_INIT.
        KeithMo     25-Aug-1992 Removed bogus typedefs & #defines.

*/


#ifndef _MNETTYPE_H_
#define _MNETTYPE_H_


//
//  These items vary depending on WIN16/WIN32.  These were ripped-off
//  from ptypes[16|32].h and plan[16|32].h.
//
//  Note that we assume that if WIN32 is *not* defined, then
//  we're building for a 16-bit environment, either DOS Win16
//  or OS/2.
//

#ifdef WIN32

 #ifndef COPYTOARRAY
  #define COPYTOARRAY(pDest, pSource)     (pDest) = (pSource)
 #endif

#else   // !WIN32

 #ifndef COPYTOARRAY
  #define COPYTOARRAY(pDest, pSource)     strcpyf((pDest), (pSource))
 #endif

 //
 //  We need this so we can kludge together a
 //  MNetWkstaUserEnum for the 16-bit side of the world.
 //

 typedef struct _WKSTA_USER_INFO_1 {
     TCHAR FAR * wkui1_username;
     TCHAR FAR * wkui1_logon_domain;
     TCHAR FAR * wkui1_logon_server;
 } WKSTA_USER_INFO_1, *PWKSTA_USER_INFO_1, *LPWKSTA_USER_INFO_1;


#endif  // WIN32


#if defined( INCL_NETAUDIT ) || defined( INCL_NETERRORLOG )

//
//  This macro is defined here just because LanMan (and NT)
//  audit/error log handle initialization is SOOOO gross.
//
//  Note that this macro currently depends on the actual
//  field names of the HLOG structure.  We may need to
//  change this in the future...
//

#define HLOG_INIT(x)    if( 1 )                                             \
                        {                                                   \
                            (x).time       = 0;                             \
                            (x).last_flags = 0;                             \
                            (x).offset     = -1;                            \
                            (x).rec_offset = -1;                            \
                        }                                                   \
                            else

#endif  // INCL_NETAUDIT || INCL_NETERRORLOG


#endif  // _MNETTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\mnet.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    mnet.h
    <Single line synopsis>

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
        KeithMo     13-Oct-1991 Created from DanHi's private port1632.h.
        JonN        22-Oct-1991 Split off mnettype.h
        KeithMo     28-Oct-1991 Changed to "sane" typedefs.
        KeithMo     30-Oct-1991 Added MNetApiBufferReAlloc and
                                MNetApiBufferSize, removed obsolete
                                MNetAuditOpen() and MNetErrorLogOpen() API.
        KeithMo     25-Feb-1992 Added NetReplXxx APIs.
        KeithMo     08-Feb-1993 Added I_MNetComputerNameCompare API.

        CongpaY     10-March-1993 Add IsNetSlow.
*/


#ifndef _MNET_H_
#define _MNET_H_


#include "mnettype.h"

#define NAMETYPE_COMMENT   500

#ifdef __cplusplus
extern "C" {
#endif

//
//  API buffer manipulation.
//

DLL_BASED
BYTE FAR * MNetApiBufferAlloc(
        UINT               cbBuffer );

DLL_BASED
VOID MNetApiBufferFree(
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetApiBufferReAlloc(
        BYTE FAR        ** ppbBuffer,
        UINT               cbBuffer );

DLL_BASED
APIERR MNetApiBufferSize(
        BYTE FAR         * pbBuffer,
        UINT FAR         * pcbBuffer );


//
//  Internal API.
//

DLL_BASED
APIERR I_MNetNameCanonicalize(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath,
        TCHAR FAR        * pszOutput,
        UINT               cbOutput,
        UINT               NameType,
        ULONG              flFlags );

DLL_BASED
APIERR I_MNetNameCompare(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath1,
        const TCHAR FAR  * pszPath2,
        UINT               NameType,
        ULONG              flFlags );

DLL_BASED
APIERR I_MNetNameValidate(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszName,
        UINT               NameType,
        ULONG              flFlags );

DLL_BASED
APIERR I_MNetPathCanonicalize(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath,
        TCHAR FAR        * pszOutput,
        UINT               cbOutput,
        const TCHAR FAR  * pszPrefix,
        ULONG FAR        * pflPathType,
        ULONG              flFlags );

DLL_BASED
APIERR I_MNetPathCompare(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath1,
        const TCHAR FAR  * pszPath2,
        ULONG              flPathType,
        ULONG              flFlags );

DLL_BASED
APIERR I_MNetPathType(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath,
        ULONG FAR        * pflPathType,
        ULONG              flFlags );

DLL_BASED
INT I_MNetComputerNameCompare(
        const TCHAR FAR  * pszComputer1,
        const TCHAR FAR  * pszComputer2 );


//
//  BUGBUG!
//
//  This API is pretty bogus, but 16-bit SrvMgr needs it,
//  so here it is.  Handling this API correctly under NT
//  will be a real challenge.
//

DLL_BASED
APIERR MDosPrintQEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppBuffer,
        UINT FAR         * pcEntriesRead );


//
//  Access API.
//

#ifdef  INCL_NETACCESS

DLL_BASED
APIERR MNetAccessAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer );

DLL_BASED
APIERR MNetAccessCheck(
        TCHAR FAR        * pszReserved,
        TCHAR FAR        * pszUserName,
        TCHAR FAR        * pszResource,
        UINT               Operation,
        UINT FAR         * pResult );

DLL_BASED
APIERR MNetAccessDel(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszResource );

DLL_BASED
APIERR MNetAccessEnum(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszBasePath,
        UINT               fRecursive,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetAccessGetInfo(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszResource,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetAccessGetUserPerms(
        TCHAR FAR        * pszServer,
        TCHAR FAR        * pszUgName,
        TCHAR FAR        * pszResource,
        UINT FAR         * pPerms );

DLL_BASED
APIERR MNetAccessSetInfo(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszResource,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               ParmNum );

#endif  // INCL_NETACCESS


//
//  Alert API.
//

#ifdef INCL_NETALERT

DLL_BASED
APIERR MNetAlertRaise(
        const TCHAR FAR  * pszEvent,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        ULONG              ulTimeout );

DLL_BASED
APIERR MNetAlertStart(
        const TCHAR FAR  * pszEvent,
        const TCHAR FAR  * pszRecipient,
        UINT               cbMaxData );

DLL_BASED
APIERR MNetAlertStop(
        const TCHAR FAR  * pszEvent,
        const TCHAR FAR  * pszRecipient );

#endif  // INCL_NETALERT


//
//  Audit API.
//

#ifdef INCL_NETAUDIT

DLL_BASED
APIERR MNetAuditClear(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszBackupFile,
        TCHAR FAR        * pszService );

DLL_BASED
APIERR MNetAuditRead(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszService,
        HLOG FAR         * phAuditLog,
        ULONG              ulOffset,
        UINT FAR         * pReserved2,
        ULONG              ulReserved3,
        ULONG              flOffset,
        BYTE FAR        ** ppbBuffer,
        ULONG              ulMaxPreferred,
        UINT FAR         * pcbReturned,
        UINT FAR         * pcbTotalAvail );

DLL_BASED
APIERR MNetAuditWrite(
        UINT               Type,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        TCHAR FAR        * pszService,
        TCHAR FAR        * pszReserved );

#endif  // INCL_NETAUDIT


//
//  NetBIOS API.
//

#ifdef INCL_NETBIOS

struct ncb;         // forward declaration

DLL_BASED
APIERR MNetBiosClose(
        UINT               hDevName,
        UINT               Reserved );

DLL_BASED
APIERR MNetBiosEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** pbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetBiosGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszNetBiosName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetBiosOpen(
        TCHAR FAR        * pszDevName,
        TCHAR FAR        * pszReserved,
        UINT               OpenOpt,
        UINT FAR         * phDevName );

DLL_BASED
APIERR MNetBiosSubmit(
        UINT               hDevName,
        UINT               NcbOpt,
        struct ncb FAR   * pNCB );

#endif  // INCL_NETBIOS


//
//  CharDev API.
//

#ifdef INCL_NETCHARDEV

DLL_BASED
APIERR MNetCharDevControl(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDevName,
        UINT               OpCode );

DLL_BASED
APIERR MNetCharDevEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetCharDevGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDevName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetCharDevQEnum(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszUserName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetCharDevQGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszQueueName,
        const TCHAR FAR  * pszUserName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetCharDevQPurge(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszQueueName );

DLL_BASED
APIERR MNetCharDevQPurgeSelf(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszQueueName,
        const TCHAR FAR  * pszComputerName );

DLL_BASED
APIERR MNetCharDevQSetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszQueueName,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               ParmNum );

#endif  // INCL_NETCHARDEV


//
// Configuration API.
//

#ifdef INCL_NETCONFIG

DLL_BASED
APIERR MNetConfigGet(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszReserved,
        const TCHAR FAR  * pszComponent,
        const TCHAR FAR  * pszParameter,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetConfigGetAll(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszReserved,
        const TCHAR FAR  * pszComponent,
        BYTE FAR        ** ppbBuffer);

DLL_BASED
APIERR MNetConfigSet(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszComponent,
        const TCHAR FAR  * pszKey,
        const TCHAR FAR  * pszData );

#endif  // INCL_NETCONFIG


//
// Connection API.
//

#ifdef INCL_NETCONNECTION

DLL_BASED
APIERR MNetConnectionEnum(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszQualifier,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

#endif  // INCL_NETCONNECTION


//
// Domain API.
//

#ifdef INCL_NETDOMAIN

DLL_BASED
APIERR MNetGetDCName(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDomain,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetLogonEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR I_MNetLogonControl(
        const TCHAR FAR  * pszServer,
        ULONG              FunctionCode,
        ULONG              Level,
        BYTE FAR        ** ppbBuffer );

#endif  // INCL_NETDOMAIN


//
// ErrorLog API.
//

#ifdef INCL_NETERRORLOG

DLL_BASED
APIERR MNetErrorLogClear(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszBackupFile,
        TCHAR FAR        * pszReserved );

DLL_BASED
APIERR MNetErrorLogRead(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszReserved1,
        HLOG FAR         * phErrorLog,
        ULONG              ulOffset,
        UINT FAR         * pReserved2,
        ULONG              ulReserved3,
        ULONG              flOffset,
        BYTE FAR        ** ppbBuffer,
        ULONG              ulMaxPreferred,
        UINT FAR         * pcbReturned,
        UINT FAR         * pcbTotalAvail );

DLL_BASED
APIERR MNetErrorLogWrite(
        TCHAR FAR        * pszReserved1,
        UINT               Code,
        const TCHAR FAR  * pszComponent,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        const TCHAR FAR  * pszStrBuf,
        UINT               cStrBuf,
        TCHAR FAR        * pszReserved2 );

#endif  // INCL_NETERRORLOG


//
// File API.
//

#ifdef INCL_NETFILE

DLL_BASED
APIERR MNetFileClose(
        const TCHAR FAR  * pszServer,
        ULONG              ulFileId );

DLL_BASED
APIERR MNetFileEnum(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszBasePath,
        const TCHAR FAR  * pszUserName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        ULONG              ulMaxPreferred,
        UINT FAR         * pcEntriesRead,
        UINT FAR         * pcTotalAvail,
        VOID FAR         * pResumeKey );

DLL_BASED
APIERR MNetFileGetInfo(
        const TCHAR FAR  * pszServer,
        ULONG              ulFileId,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

#endif  // INCL_NETFILE


//
// Group API.
//

#ifdef INCL_NETGROUP

DLL_BASED
APIERR MNetGroupAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer );

DLL_BASED
APIERR MNetGroupAddUser(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszGroupName,
        TCHAR FAR        * pszUserName );

DLL_BASED
APIERR MNetGroupDel(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszGroupName );

DLL_BASED
APIERR MNetGroupDelUser(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszGroupName,
        TCHAR FAR        * pszUserName );

DLL_BASED
APIERR MNetGroupEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetGroupGetInfo(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszGroupName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetGroupGetUsers(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszGroupName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetGroupSetInfo(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszGroupName,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               ParmNum );

DLL_BASED
APIERR MNetGroupSetUsers(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszGroupName,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               cEntries );

DLL_BASED
APIERR MNetLocalGroupAddMember(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszGroupName,
        PSID               psidMember );

#endif  // INCL_NETGROUP


//
// Handle API.
//

#ifdef INCL_NETHANDLE

DLL_BASED
APIERR MNetHandleGetInfo(
        UINT               hHandle,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetHandleSetInfo(
        UINT               hHandle,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               ParmNum );

#endif  // INCL_NETHANDLE


//
// Message API.
//

#ifdef INCL_NETMESSAGE

DLL_BASED
APIERR MNetMessageBufferSend(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszRecipient,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer );

DLL_BASED
APIERR MNetMessageFileSend(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszRecipient,
        TCHAR FAR        * pszFileSpec );

DLL_BASED
APIERR MNetMessageLogFileGet(
        const TCHAR FAR  * pszServer,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pfsEnabled );

DLL_BASED
APIERR MNetMessageLogFileSet(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszFileSpec,
        UINT               fsEnabled );

DLL_BASED
APIERR MNetMessageNameAdd(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszMessageName,
        UINT               fsFwdAction );

DLL_BASED
APIERR MNetMessageNameDel(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszMessageName,
        UINT               fsFwdAction );

DLL_BASED
APIERR MNetMessageNameEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetMessageNameFwd(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszMessageName,
        const TCHAR FAR  * pszForwardName,
        UINT               fsDelFwdName );

DLL_BASED
APIERR MNetMessageNameGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszMessageName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetMessageNameUnFwd(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszMessageName );

#endif  // INCL_NETMESSAGE


//
// Remote API.
//

#ifdef INCL_NETREMUTIL

DLL_BASED
APIERR MNetRemoteCopy(
        const TCHAR FAR  * pszSourcePath,
        const TCHAR FAR  * pszDestPath,
        const TCHAR FAR  * pszSourcePasswd,
        const TCHAR FAR  * pszDestPasswd,
        UINT               fsOpen,
        UINT               fsCopy,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetRemoteMove(
        const TCHAR FAR  * pszSourcePath,
        const TCHAR FAR  * pszDestPath,
        const TCHAR FAR  * pszSourcePasswd,
        const TCHAR FAR  * pszDestPasswd,
        UINT               fsOpen,
        UINT               fsMove,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetRemoteTOD(
        const TCHAR FAR  * pszServer,
        BYTE FAR        ** ppbBuffer );

#endif  // INCL_NETREMUTIL


//
//  Replicator API.
//

#ifdef INCL_NETREPL

DLL_BASED
APIERR MNetReplGetInfo(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetReplSetInfo(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer );

DLL_BASED
APIERR MNetReplExportDirAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer );

DLL_BASED
APIERR MNetReplExportDirDel(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory );

DLL_BASED
APIERR MNetReplExportDirEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetReplExportDirGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetReplExportDirSetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Level,
        BYTE FAR         * pbBuffer );

DLL_BASED
APIERR MNetReplExportDirLock(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory );

DLL_BASED
APIERR MNetReplExportDirUnlock(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Force );

DLL_BASED
APIERR MNetReplImportDirAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer );

DLL_BASED
APIERR MNetReplImportDirDel(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory );

DLL_BASED
APIERR MNetReplImportDirEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetReplImportDirGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetReplImportDirLock(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory );

DLL_BASED
APIERR MNetReplImportDirUnlock(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Force );

#endif  // INCL_NETREPL


//
// Server API.
//

#ifdef INCL_NETSERVER

DLL_BASED
APIERR MNetServerAdminCommand(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszCommand,
        UINT FAR         * psResult,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT FAR         * pcbReturned,
        UINT FAR         * pcbTotalAvail );

DLL_BASED
APIERR MNetServerDiskEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetServerEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead,
        ULONG              flServerType,
        TCHAR FAR        * pszDomain );

DLL_BASED
APIERR MNetServerGetInfo(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetServerSetInfo(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               ParmNum );

#endif  // INCL_NETSERVER


//
// Service API.
//

#ifdef INCL_NETSERVICE

DLL_BASED
APIERR MNetServiceControl(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszService,
        UINT               OpCode,
        UINT               Arg,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetServiceEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetServiceGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszService,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetServiceInstall(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszService,
        const TCHAR FAR  * pszCmdArgs,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetServiceStatus(
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer );

#endif  // INCL_NETSERVICE


//
// Session API.
//

#ifdef INCL_NETSESSION

DLL_BASED
APIERR MNetSessionDel(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszClientName,
        const TCHAR FAR  * pszUserName );

DLL_BASED
APIERR MNetSessionEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetSessionGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszClientName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

#endif  // INCL_NETSESSION


//
// Share API.
//

#ifdef INCL_NETSHARE

DLL_BASED
APIERR MNetShareAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer );

DLL_BASED
APIERR MNetShareCheck(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDeviceName,
        UINT FAR         * pType );

DLL_BASED
APIERR MNetShareDel(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszNetName,
        UINT               Reserved );

DLL_BASED
APIERR MNetShareDelSticky(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszNetName,
        UINT               Reserved );

DLL_BASED
APIERR MNetShareEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetShareEnumSticky(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetShareGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszNetName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetShareSetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszNetName,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               ParmNum );

#endif  // INCL_NETSHARE


//
// Statistics API.
//

#ifdef INCL_NETSTATS

DLL_BASED
APIERR MNetStatisticsClear(
        const TCHAR FAR  * pszServer );

DLL_BASED
APIERR MNetStatisticsGet(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszService,
        ULONG              ulReserved,
        UINT               Level,
        ULONG              flOptions,
        BYTE FAR        ** ppbBuffer );

#endif  // INCL_NETSTATS


//
// Use API.
//

#ifdef INCL_NETUSE

DLL_BASED
APIERR MNetUseAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer );

DLL_BASED
APIERR MNetUseDel(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDeviceName,
        UINT               Force );

DLL_BASED
APIERR MNetUseEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetUseGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszUseName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

#endif  // INCL_NETUSE


//
// User API.
//

#ifdef INCL_NETUSER

DLL_BASED
APIERR MNetUserAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer );

DLL_BASED
APIERR MNetUserDel(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszUserName );

DLL_BASED
APIERR MNetUserEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        UINT               Filter,
        BYTE FAR        ** ppbBuffer,
        ULONG              ulMaxPreferred,
        UINT FAR         * pcEntriesRead,
        UINT FAR         * pcTotalEntries,
        VOID FAR         * pResumeKey );

DLL_BASED
APIERR MNetUserGetGroups(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszUserName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetUserGetInfo(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszUserName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetUserModalsGet(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetUserModalsSet(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               ParmNum );

DLL_BASED
APIERR MNetUserPasswordSet(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszUserName,
        TCHAR FAR        * pszOldPassword,
        TCHAR FAR        * pszNewPassword );

DLL_BASED
APIERR MNetUserSetGroups(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszUserName,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               cEntries );

DLL_BASED
APIERR MNetUserSetInfo(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszUserName,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               ParmNum );

DLL_BASED
APIERR MNetUserValidate(
        TCHAR FAR        * pszReserved1,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT               Reserved2 );

#endif  // INCL_NETUSER


//
// Workstation API.
//

#ifdef INCL_NETWKSTA

DLL_BASED
APIERR MNetWkstaGetInfo(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetWkstaSetInfo(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer );

DLL_BASED
APIERR MNetWkstaSetUID(
        TCHAR FAR        * pszReserved,
        TCHAR FAR        * pszDomain,
        TCHAR FAR        * pszUserName,
        TCHAR FAR        * pszPassword,
        TCHAR FAR        * pszParms,
        UINT               LogoffForce,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT FAR         * pcbTotalAvail );

DLL_BASED
APIERR MNetWkstaUserEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetWkstaUserGetInfo(
        const TCHAR FAR  * pszReserved, // Must Be Zero
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

#endif  // INCL_NETWKSTA

DLL_BASED
APIERR IsSlowTransport (
        const TCHAR FAR  * pszServer,
        BOOL FAR         * pfSlowTransport );

#ifdef __cplusplus
}
#endif

#endif  // _MNET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\newprof.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990,1991          **/
/********************************************************************/

/*
    newprof.h
    C-language wrappers for ini-file-handling classes


    FILE HISTORY:
    10/11/90  jonn	created
    01/10/91  jonn	removed PSHORT, PUSHORT
    01/27/91  jonn	changed from CFGFILE, added UserProfileInit/Free
    02/02/91  jonn	added UserProfileWrite/Clear, removed Confirm, 
  			redefined Set.
    02/04/91  jonn	added cpszUsername param to Query, Enum, Set
    03/08/91  chuckc	added UserPreferenceXXX() calls. 
    04/16/91  jonn	added USERPREF_CONFIRMATION and USERPREF_ADMINMENUS
    05/08/91  jonn	Added canonicalization of netnames, canonicalize
  			on read
    05/28/91  jonn	Restructured to allow preferences in LMUSER.INI
*/

#ifndef _NEWPROF_H_
#define _NEWPROF_H_

/****************************************************************************

    MODULE: NewProf.h

    PURPOSE: Handles low-level manipulation of user preference files

    FUNCTIONS:

	UserPreferenceRead() - Reads the preferences from permanent storage
			    into a file image, for future UserPreference or
			    UserPref calls.
	UserPreferenceWrite() - Writes the preferences from a file image
			    into permanent storage.
	UserPreferenceFree() - Frees memory claimed by a file image.

	UserPrefStringQuery() - queries a single user preference string.
	UserPrefStringSet() - saves a single user preference string.
			    It is generally advisable to immediately precede
			    this call with UserPreferenceRead, and to
			    immediately follow it with UserPreferenceSet.

	UserPrefBoolQuery() - queries a single user preference bool value.
	UserPrefBoolSet() - saves a single user preference bool value.
			    Same usage recommendations as UserPrefStringSet.

	UserPrefProfileQuery() - Returns one device connection from a file
			    image.
	UserPrefProfileEnum() - Lists all device connections in a file image.
	UserPrefProfileSet() - Changes a device connection in a file image.
			    Same usage recommendations as UserPrefStringSet.
	UserPrefProfileTrim() - Trims all components in a file image
			    which are not relevant to device connections.


    COMMENTS:

      These APIs are wrappers to the C++ INI-file handling classes defined
      in newprof.hxx.  Most clients will prefer to use the wrapper APIs,
      including all C clients.  These wrapper APIs provide almost all
      the functionality of the C++ APIs.  The C++ APIs are more subject to
      change with changing implementation (NT configuration manager, DS)
      than are these C-language wrappers.

      UserPreference routines:

	Under LM21, these routines read and write the local LMUSER.INI.
	These sticky values are therefore all local to the workstation;
	this mechanism is not intended for values associated with a user.

	Under LM30, the preferences in LMUSER.INI will only be used if the
	preferences stored in the DS (NT Configuration Manager?) are
	unavailable.  Some preferences, such as default username, will be
	stored in LMUSER.INI regardless.

	UserPreferenceRead returns a PFILEIMAGE which the UserPreference APIs
	can interpret as an image of the LMUSER.INI file.  This PFILEIMAGE
	must be passed through to UserPreferenceWrite and to the
	UserPrefProfile, UserPrefBool etc. APIs.  When this image is no
	longer needed, it should be freed with UserPreferenceFree.

	Remember that a user may be logged on from several different
	machines, and that the cached profile is not automatically
	updated.  When the profile is to be changed in permanent
	storage, it is generally advisable to reread the profile from
	permanent storage with UserPreferenceRead, make the change in the
	cache with UserPrefBoolSet (et al), and immediately rewrite the
	profile with UserPreferenceWrite; this reduces the chance that
	another user's changes will be lost.

	When successful, these APIs return NERR_Success (0).  The following
	are the error codes returned by the UserPref APIs:

	NERR_CfgCompNotFound: the specified component is not in the file
	NERR_CfgParamNotFound: the specified parameter is not in the file,
		or it is in the file but is not valid for a parameter of
		this type.
	NERR_InvalidDevice: bad devicename argument
	ERROR_BAD_NET_NAME: bad remotename argument
	ERROR_NOT_ENOUGH_MEMORY:  lack of global memory
	other file read and file write errors


      UserPref routines:

	These routines read and write one particular type of sticky
	values.  For example, the UserPrefProfile APIs read and write
	device profile entries, while UserPrefBool APis read and write
	boolean-valued entries.  Client programs must still read the file
	image first with UserPreferenceRead, save the changes with
	UserPreferenceWrite, and free the file image with UserPreferenceFree.

	Use UserPrefProfileTrim when you intend to keep the file image
	around for a long time (e.g. in a cache), and are not iterested
	in entries other than device connections.  Do not write such a
	trimmed file image, you will lose the other entries!

	Use UserPrefStringSet(pfileimage,usKey,NULL) to remove both
	string-valued parameters and boolean-valued parameters.


    CAVEATS:

	These routines take PSZ and CPSZ buffers because these are
	explicitly far for C programs (in particular lui\profile.c), but
	do not generate errors under C++.


****************************************************************************/



/* returncodes: */



/* global macros */
#include <newprofc.h>


/* typedefs: */

typedef PVOID PFILEIMAGE;
typedef PFILEIMAGE FAR * PPFILEIMAGE;


/* functions: */


/*************************************************************************

    NAME:	UserPreferenceRead

    SYNOPSIS:	UserPreferenceRead attempts to read the user's profile from
    		permanent storage (<cpszLanroot>\LMUSER.INI for LM21).
		It returns a PFILEIMAGE which serves as a "file image" for use
		of the other APIs.

    INTERFACE:  UserPreferenceRead( ppFileImage )
		ppFileImage - returns pointer to a file image.

		Return values are:
		NERR_Success
		ERROR_NOT_ENOUGH_MEMORY
		errors in NetWkstaGetInfo[1]
		file read errors

    USES:	Use to obtain a file image for use in the UserPref APIs.

    NOTES:	Currently, the values are stored in LANMAN.INI, and hence
		each value is per machine.

		Use UserPreferenceFree to release the file image when
		it is no longer needed.

    		Some users may choose to ignore ERROR_FILE_NOT_FOUND.
		The file image must be freed regardless of the return
		code.

    HISTORY:
 	jonn	10/11/90	Created
 	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI
	jonn	06/26/91	No longer takes LANROOT parameter

**************************************************************************/

APIERR UserPreferenceRead(
	PPFILEIMAGE ppFileImage
	) ;



/*************************************************************************

    NAME:	UserPreferenceWrite

    SYNOPSIS:	UserPreferenceWrite attempts to write the user's profile
		back to permanent storage.

    INTERFACE:  UserPreferenceWrite( pFileImage )
		pFileImage - a file image originally obtained from
			UserPreferenceRead.

		Return values are:
		NERR_Success
		ERROR_NOT_ENOUGH_MEMORY
		file write errors

    USES:	Use to write out changes to the preferences in a file image.

    HISTORY:
 	jonn	10/11/90	Created
 	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI
	jonn	06/26/91	No longer takes LANROOT parameter

**************************************************************************/

APIERR UserPreferenceWrite(
	PFILEIMAGE pFileImage
	) ;



/*************************************************************************

    NAME:	UserPreferenceFree

    SYNOPSIS:	UserPreferenceFree releases a file image.

    INTERFACE:  UserPreferenceFree( pFileImage )
		pFileImage - a file image originally obtained from
			UserPreferenceRead.

    RETURNS:	NERR_Success

    USES:	Use when a file image is no longer needed.  File images
    		use a considerable amount of memory, so be sure to free
		them.

    NOTES:	It is permitted to free a null file image pointer.

    CAVEATS:	Do not use the file image after it has been freed.

    HISTORY:
 	jonn	10/11/90	Created
 	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI

**************************************************************************/

APIERR UserPreferenceFree(
	PFILEIMAGE pFileImage
	) ;


/*************************************************************************

    NAME:	UserPrefStringQuery

    SYNOPSIS:	Queries a user preference (i.e. remembered string).

    INTERFACE:  UserPrefStringQuery( pFileImage, usKey, pszBuffer, cbBuffer )
		pFileImage - as obtained from UserPreferenceRead
		usKey 	 - will indicate which value we want, as defined
			   in newprofc.h.
		pszBuffer - pointer to buffer that will receive value
		cbBuffer - size of buffer in bytes

		return values are:
		NERR_Success
		NERR_CfgCompNotFound
		NERR_CfgParamNotFound
		ERROR_INVALID_PARAMETER: bad usKey
		NERR_BufTooSmall
		ERROR_NOT_ENOUGH_MEMORY

    USES:	Use to recall string-valued parameters, normally things
    		like default logon name.  Do not use for boolean-valued
		parameters -- for those, use UserPrefBool instead.

    NOTES:	Currently, the values are stored in LANMAN.INI, and hence
		each value is per machine.

		A buffer of size MAXPATHLEN+1 is guaranteed to be large enough.

    HISTORY:
	chuckc	03/07/91	Created
	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI

**************************************************************************/

APIERR UserPrefStringQuery( PFILEIMAGE      pFileImage,
			    USHORT     usKey,
		            PSZ        pszBuffer,
			    USHORT     cbBuffer) ;


/*************************************************************************

    NAME:	UserPrefStringSet

    SYNOPSIS:	Sets a user preference (i.e. remembered string).

    INTERFACE:  UserPrefStringSet( pFileImage, usKey, pszValue )
		pFileImage - as obtained from UserPreferenceRead
		usKey 	 - will indicate which value we want, as defined
			   in newprofc.h.
		pszValue - pointer to null-terminated string to be remembered

		return values are:
		NERR_Success
		ERROR_INVALID_PARAMETER: bad usKey
		ERROR_NOT_ENOUGH_MEMORY

    USES:	Use to create or change string-valued parameters,
		normally things like default logon name, etc.  Do not use
		for boolean-valued parameters -- for those, use UserPrefBool
		instead.

    CAVEATS:	Note that this API only modifies the file image; you must
		call UserPreferenceWrite to save the change in permanent
		storage.

    NOTES:	Currently, the values are stored in LANMAN.INI, and hence
		each value is per machine.

		Also used to delete boolean-valued parameters.

    HISTORY:
	chuckc	03/07/91	Created
	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI

**************************************************************************/

APIERR UserPrefStringSet( PFILEIMAGE pFileImage,
			  USHORT     usKey,
		          CPSZ       cpszValue) ;


/*************************************************************************

    NAME:	UserPrefBoolQuery

    SYNOPSIS:	Queries a boolean user preference

    INTERFACE:  UserPrefBoolQuery( pFileImage, usKey, pfValue )
		pFileImage - as obtained from UserPreferenceRead
		usKey 	 - will indicate which value we want, as defined
			   in newprofc.h.
		pfValue  - pointer to BOOL that will contain value

		return values as UserPrefStringQuery

    USES:	as UserPrefStringQuery for boolean-valued parameters

    CAVEATS:	as UserPrefStringQuery for boolean-valued parameters

    NOTES:	as UserPrefStringQuery for boolean-valued parameters
		We take USERPREF_YES to be true, USERPREF_NO to be false
		(case-insensitive); other values are invalid.

		os2def.h defines PBOOL as BOOL FAR *.

    HISTORY:
	chuckc	03/07/91	Created
	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI

**************************************************************************/

APIERR UserPrefBoolQuery(	PFILEIMAGE pFileImage,
				USHORT     usKey,
			        PBOOL      pfValue) ;


/*************************************************************************

    NAME:	UserPrefBoolSet

    SYNOPSIS:	Sets a boolean user preference

    INTERFACE:  UserPrefBoolSet( pFileImage, usKey, fValue )
		pFileImage - as obtained from UserPreferenceRead
		usKey 	 - will indicate which value we want, as defined
			   in newprofc.h.
		fValue   - BOOL value, true or false

		return values as UserPrefStringSet

    USES:	as UserPrefStringSet for boolean-valued parameters

    CAVEATS:	as UserPrefStringSet for boolean-valued parameters

    NOTES:	as UserPrefStringSet for boolean-valued parameters
		We write USERPREF_YES for TRUE, USERPREF_NO for FALSE.

		Use UserPrefStringSet to delete boolean-valued parameters.

    HISTORY:
	chuckc	03/07/91	Created
	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI

**************************************************************************/

APIERR UserPrefBoolSet( PFILEIMAGE pFileImage,
			USHORT     usKey,
		        BOOL       fValue) ;


/*************************************************************************

    NAME:	UserPrefProfileQuery

    SYNOPSIS:	Queries a device-connection user preference

    INTERFACE:  UserPrefProfileQuery( pFileImage, cpszDeviceName,
			pszBuffer, cbBuffer, psAsgType, pusResType )
		pFileImage - as obtained from UserPreferenceRead
		cpszDeviceName - indicates which device we want
		pszBuffer   - buffer into which to store remote name
		cbBuffer - length of buffer in bytes
		psAsgType   - returns asgType of remote device
		pusResType   - returns resType of remote device

		return values as UserPrefStringQuery
		ERROR_INVALID_PARAMETER: bad cpszDeviceName

    USES:	as UserPrefStringQuery for device-connection parameters

		psAsgType returns the device type as in use_info_1 or
		(LM30) use_info_2 fields ui1_asg_type or (LM30) ui2_asg_type.
		pusResType returns the device name type (e.g. UNC, alias, DFS,
		DS) as in the use_info_2 ui1_res_type field.  Either of these
		parameters may be passed as NULL by programs which do not
		care about those return values.

    CAVEATS:	as UserPrefStringQuery for device-connection parameters

		Note that it is the caller's reponsibility to deal with
		the case where the user is not logged on and should therefore
		see no unavailable connections.

    NOTES:	as UserPrefStringQuery for device-connection parameters

    		os2def.h defines PSHORT and PUSHORT as explicitly FAR.

    HISTORY:
	chuckc	03/07/91	Created
	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI

**************************************************************************/

APIERR UserPrefProfileQuery(
	PFILEIMAGE  pFileImage,
	CPSZ   cpszDeviceName,
	PSZ    pszBuffer,      // returns UNC, alias or domain name
	USHORT cbBuffer,       // length of above buffer in bytes
	PSHORT psAsgType,      // as ui1_asg_type / ui2_asg_type
                               // ignored if NULL
	PUSHORT pusResType     // ignore / as ui2_res_type
                               // ignored if NULL
	) ;



/*************************************************************************

    NAME:	UserPrefProfileEnum

    SYNOPSIS:	Lists all device-connection user preferences

    INTERFACE:  UserPrefProfileEnum( pFileImage, pszBuffer, cbBuffer );
		pFileImage - as obtained from UserPreferenceRead
		pszBuffer   - buffer into which to store list of device names
		cbBuffer - length of buffer in bytes

		return values are:
		ERROR_NOT_ENOUGH_MEMORY
		NERR_BufTooSmall

    USES:	Returns a list of all devices for which the file image
    		lists a connection, separated by nulls, with a null-null at
		the end.  For example, "LPT1:\0D:\0F:\0" (don't forget the
		extra '\0' implicit in "" strings)

    CAVEATS:	Note that it is the caller's reponsibility to deal with
		the case where the user is not logged on and should therefore
		see no unavailable connections.

    HISTORY:
	chuckc	03/07/91	Created
	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI

**************************************************************************/

APIERR UserPrefProfileEnum(
	PFILEIMAGE  pFileImage,
	PSZ    pszBuffer,       // returns NULL-NULL list of device names
	USHORT cbBuffer         // length of above buffer in bytes
	) ;



/*************************************************************************

    NAME:	UserPrefProfileSet

    SYNOPSIS:	Sets a device-connection user preference

    INTERFACE:  UserPrefProfileSet( pFileImage, cpszDeviceName,
			cpszRemoteName, sAsgType, usResType )
		pFileImage - as obtained from UserPreferenceRead
		cpszDeviceName - Device to associate with remote resource
		cpszRemoteName - name of remote resource (UNCname for LM21)
				 Use NULL to delete entries
		sAsgType - asgType of remote device
		usResType - resType of remote device (ignored for LM21)

		return values as UserPrefStringSet
		ERROR_INVALID_PARAMETER: bad cpszDeviceName

    USES:	as UserPrefStringSet for device-connection parameters

    CAVEATS:	as UserPrefStringSet for device-connection parameters

		The user is expected to ensure that usResType corresponds
		to the type of the remote resource, and that device
		pszDeviceName can be connected to a resource of that type.

		Note that it is the caller's reponsibility to deal with
		the case where the user is not logged on and should therefore
		see no unavailable connections.

    NOTES:	as UserPrefStringSet for device-connection parameters

		LM21 programs should pass 0 for usResType

		Pass cpszRemoteName==NULL to delete device-connection
		parameters.

    HISTORY:
	chuckc	03/07/91	Created
	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI

**************************************************************************/

APIERR UserPrefProfileSet(
	PFILEIMAGE  pFileImage,
	CPSZ   cpszDeviceName,
	CPSZ   cpszRemoteName,
	short  sAsgType,		// as ui1_asg_type / ui2_asg_type
	unsigned short usResType	// as ui2_res_type
	) ;


/*************************************************************************

    NAME:	UserPrefProfileTrim

    SYNOPSIS:	Trims an file image to contain only device-connection
		components.

    INTERFACE:  UserPrefProfileTrim( pFileImage )
		pFileImage - as obtained from UserPreferenceRead

    USES:	This is meant for use where a "cache" of device
    		connection parameters will be held for a long time.

    RETURNS:	NERR_NOT_ENOUGH_MEMORY
		Does not fail if component not found

    CAVEATS:	Do not write a trimmed file image -- this will destroy all
		parameters which are not device connections!

    NOTES:	Free the file image if this API fails.

    HISTORY:
	jonn	06/26/91	Created

**************************************************************************/

APIERR UserPrefProfileTrim(
	PFILEIMAGE  pFileImage
	) ;

#endif // _NEWPROF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\passdlg.h ===
/*****************************************************************/  
/**		     Microsoft Windows NT			**/ 
/**	       Copyright(c) Microsoft Corp., 1991 		**/
/*****************************************************************/ 

/*
 *  passdlg.h
 *  This manifests are used by the RESOURCE_PASSWORD_DIALOG
 *
 *  History:
 *  	Yi-HsinS	8/15/91		Created
 *
 */

#ifndef _PASSDLG_H_
#define _PASSDLG_H_

#include "applibrc.h"

#define IDPW_PASSWORD    	    	200
#define IDPW_RESOURCE               	201 


/* 
 * Help Context
 */

#define HC_RESOURCE_PASSWORD_DIALOG	6000

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\newprofc.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990,1991          **/
/********************************************************************/

/*
    newprof.h
    Constants for ini-file-handling module

    These constants are needed by both newprof.h and newprof.hxx clients.

    FILE STATUS:
    06/04/91  jonn	Created
*/

#ifndef _NEWPROFC_H_
#define _NEWPROFC_H_

/****************************************************************************

    MODULE: NewProfC.h

    PURPOSE: Constants and macros for the C and C++ version of the
	user preference module.

    FUNCTIONS:

    COMMENTS:

****************************************************************************/



/* returncodes: */



/* global macros */
#define PROFILE_DEFAULTFILE    "LMUSER.INI" // this is not internationalized.

#define USERPREF_MAX	256		// arbitrary limit to ease mem alloc

#define USERPREF_YES	"yes"		// this is not internationalized.
#define USERPREF_NO	"no"		// ditto

#define USERPREF_NONE			0	// no such value
#define USERPREF_AUTOLOGON		0x1	// auto logon
#define USERPREF_AUTORESTORE		0x2	// auto restore profile
#define USERPREF_SAVECONNECTIONS	0x3	// auto save connections
#define USERPREF_USERNAME		0x4	// user name
#define USERPREF_CONFIRMATION		0x5	// confirm actions?
#define USERPREF_ADMINMENUS		0x6	// Admin menus (PrintMgr)


#endif // _NEWPROFC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\uidomain.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    uidomain.h
    Header file for PROMPT_FOR_ANY_DC dialog ID values.

    FILE HISTORY:
        KeithMo 31-Aug-1992 Created.
*/

#ifndef _UIDOMAIN_H_
#define _UIDOMAIN_H_

#include "applibrc.h"

#define IDPDC_MESSAGE           200
#define IDPDC_SERVER_LABEL      201
#define IDPDC_SERVER            202

#endif  // _UIDOMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\spl_wnt.h ===
/*
 *	Windows/Network Interface
 *	Copyright (C) Microsoft 1989
 *
 *	Print Manager Administration APIs
 *	for later inclusion into WINNET.H once they settle down
 *
 *	JONN 4/19/91	Trimmed out unnecessary stuff
 *	JONN 5/3/91	Added type WNETERR
 */


/*
    Codes for WNetPrintMgrSelNotify's "type" variable, indicating
    what's selected:  a queue, a job, or nothing.
*/

#define WNPMSEL_NOTHING	0
#define WNPMSEL_QUEUE	1
#define WNPMSEL_JOB	2

#define PRIORITY        10		/* menu uses 10, 11, 12, 13 */
#define ABOUT	       24
#define EXIT            25
#define PRINT_LOG       28
#define NETWORK         29
#define HELP_NDEX       30
#define HELP_MOUSE      31
#define HELP_KEYBOARD   32
#define HELP_HELP       33
#define HELP_COMMANDS   34
#define HELP_PROCEDURES 35

#define SHOW_TIME   51
#define SHOW_SIZE   52
#define SHOW_DETAIL 53
#define UPDATE      54
#define SHOW_LOCAL  55
#define SHOW_NET    56
#define SHOW_QUEUE  57
#define SHOW_OTHER  58

#define ALERT_ALWAYS	100
#define ALERT_FLASH	101
#define ALERT_IGNORE	102

#define PM_REFRESH	WM_USER + 100  // BUGBUG: Need to define proper manifest
#define PM_SELQUEUE	WM_USER + 101
#define PM_QUERYSEL	WM_USER + 102

typedef struct _wnpmsel {	/* structure returned by PM_QUERYSEL */
    WORD wJobID;
    char szQueueName [260];
} WNPMSEL, far *LPWNPMSEL;

#define IDM_PROPERTIES		202
#define IDM_CHANGE_MENUS    	212

/*
 *	added JONN 2/26/91
 *	Print Manager Extensions
 */

typedef struct _queuestruct2
{
    WORD pq2Name;		/* offset to queue name */
    WORD pq2Comment;		/* offset to queue comment */
    WORD pq2Driver;		/* offset to driver name */
    WORD pq2Status;		/* status flags */
    WORD pq2Jobcount;		/* number of jobs in this queue */    

} QUEUESTRUCT2, FAR *LPQS2;

#define QNAME(buf,qs)	((LPSTR)(buf) + (qs).pq2Name)
#define QCOMMENT(buf,qs) ((LPSTR)(buf) + (qs).pq2Comment)
#define QDRIVER(buf,qs)	((LPSTR)(buf) + (qs).pq2Driver)

typedef struct _jobstruct2 {
	WORD	pj2Id;		// job ID
	WORD	pj2Username;	// name of owner (offset to string)
//	WORD	pj2Parms;
	WORD	pj2Position;	// 0-based position in queue
	WORD	pj2Status;	// status flags (WNPRJ_XXXXX)
	DWORD	pj2Submitted;
	DWORD	pj2Size;	// size of job in bytes
//	WORD	pj2Copies;
	WORD	pj2Comment;	// comment/app name (offset to string)
	WORD	pj2Document;	// document name (offset to string)
	WORD	pj2StatusText;	// verbose status (offset to string)
	WORD	pj2PrinterName;	// name of port job is printing on (offs to str)
} JOBSTRUCT2;

typedef JOBSTRUCT2 far * LPJOBSTRUCT2;

#define JOBNAME(buf,job)	((LPSTR)(buf) + (job).pj2Username)
#define JOBCOMMENT(buf,job)	((LPSTR)(buf) + (job).pj2Comment)
#define JOBDOCUMENT(buf,job)	((LPSTR)(buf) + (job).pj2Document)
#define JOBSTATUS(buf,job)	((LPSTR)(buf) + (job).pj2StatusText)
#define JOBPRINTER(buf,job)	((LPSTR)(buf) + (job).pj2PrinterName)

/*
 * Type WNETERR distinguishes WN_ error codes from other WORD
 * values.  Added JONN 5/3/91
 */
typedef WORD WNETERR;

// new Print Manager Extensions APIs
extern void far pascal WNetPrintMgrSelNotify (BYTE, LPQS2, LPQS2,
	LPJOBSTRUCT2, LPJOBSTRUCT2, LPWORD, LPSTR, WORD);
extern WNETERR far pascal WNetPrintMgrPrinterEnum (LPSTR lpszQueueName,
	LPSTR lpBuffer, LPWORD pcbBuffer, LPWORD cAvail, WORD usLevel);
extern WNETERR far pascal WNetPrintMgrChangeMenus(HWND, HANDLE FAR *, BOOL FAR *);
extern WNETERR far pascal WNetPrintMgrCommand (HWND, WORD);
extern void far pascal WNetPrintMgrExiting (void);
extern BOOL far pascal WNetPrintMgrExtHelp (DWORD);
extern void far pascal WNetPrintMgrMoveJob (HWND, LPSTR, WORD, int);

// new values for WNetGetCaps()
#define WNNC_PRINTMGREXT		0x000B
// returns extensions version number, re: GetVersion(),
//   or 0 if not supported

// QUEUESTRUCT2.pq2Status and .pq2Jobcount for WNetPrintMgrPrinterEnum[2]
#define WNQ_UNKNOWN -1

#define WNPRS_CANPAUSE	0x0001
#define WNPRS_CANRESUME	0x0002
#define WNPRS_CANDELETE	0x0004
#define WNPRS_CANMOVE	0x0008

// help contexts, were previously in sphelp.h
#define IDH_HELPFIRST		5000
#define IDH_SYSMENU	(IDH_HELPFIRST + 2000)
#define IDH_MBFIRST	(IDH_HELPFIRST + 2001)
#define IDH_MBLAST	(IDH_HELPFIRST + 2099)
#define IDH_DLGFIRST	(IDH_HELPFIRST + 3000)


#define IDH_PRIORITY	(IDH_HELPFIRST + PRIORITY )
#define IDH_PRIORITY1 	(IDH_HELPFIRST + PRIORITY + 1)
#define IDH_PRIORITY2 	(IDH_HELPFIRST + PRIORITY + 2)
#define IDH_ABOUT	(IDH_HELPFIRST + ABOUT	)
#define IDH_EXIT 	(IDH_HELPFIRST + EXIT)
#define IDH_NETWORK 	(IDH_HELPFIRST + NETWORK)
#define IDH_HELP_NDEX 	(IDH_HELPFIRST + HELP_NDEX)
#define IDH_HELP_MOUSE 	(IDH_HELPFIRST + HELP_MOUSE)
#define IDH_HELP_KEYBOARD 	(IDH_HELPFIRST + HELP_KEYBOARD)
#define IDH_HELP_HELP 	(IDH_HELPFIRST + HELP_HELP)
#define IDH_HELP_COMMANDS 	(IDH_HELPFIRST + HELP_COMMANDS)
#define IDH_HELP_PROCEDURES 	(IDH_HELPFIRST + HELP_PROCEDURES)
#define IDH_SHOW_TIME 	(IDH_HELPFIRST + SHOW_TIME)
#define IDH_SHOW_SIZE 	(IDH_HELPFIRST + SHOW_SIZE)
#define IDH_UPDATE 	(IDH_HELPFIRST + UPDATE)
#define IDH_SHOW_QUEUE 	(IDH_HELPFIRST + SHOW_QUEUE)
#define IDH_SHOW_OTHER 	(IDH_HELPFIRST + SHOW_OTHER)
#define IDH_ALERT_ALWAYS 	(IDH_HELPFIRST + ALERT_ALWAYS)
#define IDH_ALERT_FLASH 	(IDH_HELPFIRST + ALERT_FLASH)
#define IDH_ALERT_IGNORE 	(IDH_HELPFIRST + ALERT_IGNORE)


// was in spoolids.h

#define IDS_A_BASE	4096

/* also used as button IDs */
#define ID_ABORT	4
#define ID_PAUSE	2
#define ID_RESUME	3
#define ID_EXPLAIN	5
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\uigenhlp.h ===
/********************************************************/
/*               Microsoft Windows NT                   */
/*       Copyright(c) Microsoft Corp., 1990, 1991       */
/********************************************************/

/*
    uigenhlp.h

    This file contains the ranges for help contexts that live
    in the general range. they will live in network.hlp

    FILE HISTORY:
        ChuckC       04-01-93    created

*/


#ifndef _UIGENHLP_H_
#define _UIGENHLP_H_

#include <uihelp.h>

#define HC_GENHELP_BROWSE              (HC_UI_GENHELP_BASE+0)
#define HC_GENHELP_BROWSESERVERS       (HC_UI_GENHELP_BASE+1)

#endif  // _UIGENHLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\uierr.h ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    uierr.h
    Replacement bseerr.h

    This file redirects bseerr.h to winerror.h.  BSEERR.H is an OS/2
    include file for which WINERROR.H is the nearest equivalent.  The
    directory containing this file should only be on the include path for NT.


    FILE HISTORY:
        jonn        12-Sep-1991     Added to $(UI)\common\h\nt
        KeithMo     12-Dec-1992     Moved to common\h, renamed to uierr.h.

*/

#include <winerror.h>

// BUGBUG BUGBUG We shouldn't be using this error code, but
// collect\maskmap.cxx uses it

#define ERROR_NO_ITEMS                  93 /* no items to operate upon        */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\uihelp.h ===
/********************************************************/
/*               Microsoft Windows NT                   */
/*       Copyright(c) Microsoft Corp., 1990, 1991       */
/********************************************************/

/*
    uihelp.h
    This file contains the ranges for ALL UI help contexts.

    FILE HISTORY:
        KeithMo     04-Aug-1992     Created.

*/


#ifndef _UIHELP_H_
#define _UIHELP_H_


//
//  The mother of all help contexts.
//

#define  HC_UI_BASE     7000


//
//  The following help context ranges are defined
//  for the various NETUI modules (LMUICMN0, LMUICMN1,
//  NTLANMAN, MPRUI, etc).
//
//  All help contexts < 7000 are reserved for APIERR mapping.
//
//  Note that ACLEDIT does not need a range;  it receives
//  a set of help contexts from the invoker.
//

#define HC_UI_LMUICMN0_BASE     (HC_UI_BASE+0)
#define HC_UI_LMUICMN0_LAST     (HC_UI_BASE+1999)

#define HC_UI_LMUICMN1_BASE     (HC_UI_BASE+2000)
#define HC_UI_LMUICMN1_LAST     (HC_UI_BASE+3999)

#define HC_UI_MPR_BASE          (HC_UI_BASE+4000)
#define HC_UI_MPR_LAST          (HC_UI_BASE+5999)

#define HC_UI_SETUP_BASE        (HC_UI_BASE+8000)
#define HC_UI_SETUP_LAST        (HC_UI_BASE+9999)

#define HC_UI_SHELL_BASE        (HC_UI_BASE+10000)
#define HC_UI_SHELL_LAST        (HC_UI_BASE+11999)

#define HC_UI_USRMGR_BASE       (HC_UI_BASE+14000)
#define HC_UI_USRMGR_LAST       (HC_UI_BASE+15999)

#define HC_UI_EVTVWR_BASE       (HC_UI_BASE+16000)
#define HC_UI_EVTVWR_LAST       (HC_UI_BASE+17999)

#define HC_UI_RASMAC_BASE       (HC_UI_BASE+18000)
#define HC_UI_RASMAC_LAST       (HC_UI_BASE+19999)

#define HC_UI_GENHELP_BASE      (HC_UI_BASE+20000)
#define HC_UI_GENHELP_LAST      (HC_UI_BASE+20999)

#define HC_UI_RPLMGR_BASE       (HC_UI_BASE+21000)
#define HC_UI_RPLMGR_LAST       (HC_UI_BASE+21999)



//
//  Help contexts for all NetUI Control Panel Applets
//  must be >= 40000.  Keeping the contexts >= 40000
//  will prevent context collisions with the other
//  Control Panel Applets.
//
//  As stated in SHELL\CONTROL\MAIN\CPHELP.H, NetUI has
//  reserved the help context range from 40000 - 59999.
//  This should give us plenty of breathing room for
//  any future applets we may create.
//

#define HC_UI_NCPA_BASE         (HC_UI_BASE+34000)
#define HC_UI_NCPA_LAST         (HC_UI_BASE+35999)

#define HC_UI_SRVMGR_BASE       (HC_UI_BASE+36000)
#define HC_UI_SRVMGR_LAST       (HC_UI_BASE+37999)

#define HC_UI_UPS_BASE          (HC_UI_BASE+38000)
#define HC_UI_UPS_LAST          (HC_UI_BASE+39999)

#define HC_UI_FTPMGR_BASE       (HC_UI_BASE+40000)
#define HC_UI_FTPMGR_LAST       (HC_UI_BASE+41999)

#define HC_UI_IPX_BASE       (HC_UI_BASE+42000)
#define HC_UI_IPX_LAST       (HC_UI_BASE+42999)

#define HC_UI_TCP_BASE       (HC_UI_BASE+43000)
#define HC_UI_TCP_LAST       (HC_UI_BASE+43999)

#define HC_UI_RESERVED1_BASE       (HC_UI_BASE+44000)
#define HC_UI_RESERVED1_LAST       (HC_UI_BASE+44999)

#define HC_UI_RESERVED2_BASE       (HC_UI_BASE+45000)
#define HC_UI_RESERVED2_LAST       (HC_UI_BASE+45999)

#define HC_UI_RESERVED3_BASE       (HC_UI_BASE+46000)
#define HC_UI_RESERVED3_LAST       (HC_UI_BASE+46999)

#endif  // _UIHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\uilmini.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    uilmini.h

Abstract:

    This file maps the LM 2.x include file name to the appropriate NT include
    file name, and does any other mapping required by this include file.

Author:

    Dan Hinsley (danhi) 8-Jun-1991

    Jon Newman (jonn) 19-Oct-1991:  added LMI_COMP_FILESRV, LMI_PARM_F_REMARK

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

--*/
#define LMI_PARM_S_FILESRV              "server"
#define LMI_COMP_SERVICE        "services"
#define LMI_COMP_VERSION                "version"
#define LMI_PARM_V_LAN_MANAGER          "lan_manager"


#define LMI_COMP_FILESRV        "server"
#define LMI_PARM_F_REMARK               "srvcomment"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\smx.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    smx.h
    This file contains the common messages, manifests, types, and
    structures used by Server Manager Extensions.

    NOTE:  You must include windows.h and lmcons.h *before* this file.


    FILE HISTORY:
        KeithMo     19-Oct-1992     Created, version 1.2+ of SMX spec.
        KeithMo     07-Dec-1992     Conform with version 1.6 of SMX spec.
        JonN        16-May-1996     Added GETSERVERSEL2 and GETCURFOCUS2

*/



#ifndef _SMX_H_
#define _SMX_H_



//
//  This is the maximum length allowed for an extension menu item.
//

#define MENU_TEXT_LEN                   50



//
//  This is the current version number of the extension interface.
//  Version 0 is the original version (NT 3.x).
//  Version 1 supports GETSERVERSEL2 and GETCURFOCUS2 (NT 4.x).
//

#define SME_VERSION                     1



//
//  These are the messages sent from the extension to the
//  Server Manager application.
//
//      SM_GETSELCOUNT
//
//              Purpose - Retrieves the number of selected items in
//                        the specified listbox.
//
//              wParam  - Listbox index.  This 0-based index specifies
//                        the listbox to query.  For the Server Manager,
//                        this must always be zero.
//
//              lParam  - Points to an SMS_GETSELCOUNT structure.
//
//              Returns - TRUE  if successful, FALSE if unsuccessful.
//
//
//      SM_GETSERVERSEL[A][2]
//                        New clients should use version 2 when
//                        SMS_LOADMENU.dwVersion is 1 or greater.
//
//              Purpose - Retrieves a particular selection.
//
//              wParam  - Selection index.  This 0-based index specifies
//                        the selected item to query.  This is useful
//                        for muliple-select listboxes.  Since the Server
//                        manager uses a single-select listbox, this
//                        value must always be zero.
//
//              lParam  - Points to an SMS_GETSERVERSEL[AW] structure.
//
//              Returns - TRUE  if successful, FALSE if unsuccessful.
//
//      SM_GETCURFOCUS[AW][2]
//
//              Purpose - Retrieves the current application focus.
//                        New clients should use version 2 when
//                        SMS_LOADMENU.dwVersion is 1 or greater.
//
//              wParam  - Must be zero.
//
//              lParam  - Points to a SMS_GETCURFOCUS structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      SM_GETOPTIONS
//
//              Purpose - Retrieves the current option settings
//
//              wParam  - Must be zero.
//
//              lParam  - Points to a SMS_GETOPTIONS structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//

#define SM_GETSELCOUNT                  (WM_USER + 1000)
#define SM_GETSERVERSELA                (WM_USER + 1001)
#define SM_GETSERVERSELW                (WM_USER + 1002)
#define SM_GETCURFOCUSA                 (WM_USER + 1003)
#define SM_GETCURFOCUSW                 (WM_USER + 1004)
#define SM_GETOPTIONS                   (WM_USER + 1005)
#define SM_GETSERVERSEL2A               (WM_USER + 1006)
#define SM_GETSERVERSEL2W               (WM_USER + 1007)
#define SM_GETCURFOCUS2A                (WM_USER + 1008)
#define SM_GETCURFOCUS2W                (WM_USER + 1009)

#ifdef UNICODE
#define SM_GETSERVERSEL                 SM_GETSERVERSELW
#define SM_GETCURFOCUS                  SM_GETCURFOCUSW
#define SM_GETSERVERSEL2                SM_GETSERVERSEL2W
#define SM_GETCURFOCUS2                 SM_GETCURFOCUS2W
#else   // !UNICODE
#define SM_GETSERVERSEL                 SM_GETSERVERSELA
#define SM_GETCURFOCUS                  SM_GETCURFOCUSA
#define SM_GETSERVERSEL2                SM_GETSERVERSEL2A
#define SM_GETCURFOCUS2                 SM_GETCURFOCUS2A
#endif  // UNICODE



//
//  These structures are used when the extension is
//  communicating with the application.
//


//
//  The SMS_LOADMENU[AW] structure is passed to the extension's
//  SMELoadMenu[AW] entrypoint when the extension is loaded.
//
//      dwVersion       - On entry to SMELoadMenu[AW], this will
//                        contain the maximum extension version
//                        supported by the Server Manager.  If the
//                        extension supports a lower version, it
//                        should set this field appropriately before
//                        returning.  The Server Manager will use
//                        the returned value to determine the
//                        capabilities of the extension.
//
//                        Version 0 is the original version (NT 3.x).
//                        Version 1 supports GETSERVERSEL2 and GETCURFOCUS2.
//
//      szMenuName      - The name of the menu item that is to appear
//                        in the app's main menu.  This value will also
//                        appear in the "Help On Extensions" submene and
//                        the "View" menu.
//
//      hMenu           - A valid HMENU for the popup-menu to be inserted
//                        into the app's main menu.  Ownership of this
//                        handle transfers to the Server Manager.  The
//                        extension should *not* destroy this handle.
//
//      szHelpFileName  - The name of the help file associated with this
//                        extension.  This file will be used for the
//                        "Help On Extensions" menu.  This will also be
//                        used when the user presses [F1] while the
//                        extension's menu is dropped.
//
//      dwServerType    - A bitmask containing the appropriate server type
//                        bit associated with the extension.  It is
//                        assumed that each extension will be associated
//                        with a unique server type.  For example,
//                        SV_TYPE_WFW represents Windows for Workgroups
//                        servers.
//
//      dwMenuDelta     - The Server Manager will apply this delta
//                        to each menu ID present in hMenu.  This is
//                        to prevent conflicts with other extension's
//                        menu IDs.
//

typedef struct _SMS_LOADMENUA
{
    DWORD       dwVersion;
    CHAR        szMenuName[MENU_TEXT_LEN + 1];
    HMENU       hMenu;
    CHAR        szHelpFileName[MAX_PATH];
    DWORD       dwServerType;
    DWORD       dwMenuDelta;

} SMS_LOADMENUA, * PSMS_LOADMENUA;

typedef struct _SMS_LOADMENUW
{
    DWORD       dwVersion;
    WCHAR       szMenuName[MENU_TEXT_LEN + 1];
    HMENU       hMenu;
    WCHAR       szHelpFileName[MAX_PATH];
    DWORD       dwServerType;
    DWORD       dwMenuDelta;

} SMS_LOADMENUW, * PSMS_LOADMENUW;

#ifdef UNICODE
#define SMS_LOADMENU                    SMS_LOADMENUW
#define PSMS_LOADMENU                   PSMS_LOADMENUW
#else   // !UNICODE
#define SMS_LOADMENU                    SMS_LOADMENUA
#define PSMS_LOADMENU                   PSMS_LOADMENUA
#endif  // UNICODE


//
//  The SMS_GETSERVERSEL[AW][2] structure is filled in by the
//  Server Manager when it handles SM_GETSERVERSEL[AW][2] messages.
//  This is used to return the current selection to the extension.
//
//  SMS_GETSERVERSEL is outdated due to the change in server name length,
//  use SMS_GETSERVERSEL2 when SMS_LOADMENU.dwVersion is 1 or greater.
//
//      szServerName    - Will receive the UNC name of the selected
//                        server.
//
//      dwServerType    - Will receive the server type mask associated
//                        with the server.  This field may be 0 if
//                        the type is unknown.
//

typedef struct _SMS_GETSERVERSELA
{
    CHAR        szServerName[UNCLEN+1];
    DWORD       dwServerType;

} SMS_GETSERVERSELA, * PSMS_GETSERVERSELA;

typedef struct _SMS_GETSERVERSELW
{
    WCHAR       szServerName[UNCLEN+1];
    DWORD       dwServerType;

} SMS_GETSERVERSELW, * PSMS_GETSERVERSELW;

typedef struct _SMS_GETSERVERSEL2A
{
    CHAR        szServerName[MAX_PATH];
    DWORD       dwServerType;

} SMS_GETSERVERSEL2A, * PSMS_GETSERVERSEL2A;

typedef struct _SMS_GETSERVERSEL2W
{
    WCHAR       szServerName[MAX_PATH];
    DWORD       dwServerType;

} SMS_GETSERVERSEL2W, * PSMS_GETSERVERSEL2W;

#ifdef UNICODE
#define SMS_GETSERVERSEL                SMS_GETSERVERSELW
#define PSMS_GETSERVERSEL               PSMS_GETSERVERSELW
#define SMS_GETSERVERSEL2               SMS_GETSERVERSEL2W
#define PSMS_GETSERVERSEL2              PSMS_GETSERVERSEL2W
#else   // !UNICODE
#define SMS_GETSERVERSEL                SMS_GETSERVERSELA
#define PSMS_GETSERVERSEL               PSMS_GETSERVERSELA
#define SMS_GETSERVERSEL2               SMS_GETSERVERSEL2A
#define PSMS_GETSERVERSEL2              PSMS_GETSERVERSEL2A
#endif  // UNICODE


//
//  The SMS_GETSELCOUNT structure is filled in by the Server Manager
//  when it handles the SM_GETSELCOUNT message.  This is used to
//  return the number of selected items to the extension.  In the
//  current implementation, this will be either 0 (empty listbox)
//  or 1 (single selection).
//
//      dwItems         - The number of selected items in the listbox.
//

typedef struct _SMS_GETSELCOUNT
{
    DWORD       dwItems;
} SMS_GETSELCOUNT, * PSMS_GETSELCOUNT;


//
//  The SMS_GETCURFOCUS[AW][2] structure is filled in by the Server Manager
//  when it handles the SM_GETCURFOCUS[2] message.  This is used to
//  return the current focus of the User Manager application.
//
//  SMS_GETCURFOCUS is outdated due to the change in server name length,
//  use SMS_GETCURFOCUS2 when SMS_LOADMENU.dwVersion is 1 or greater.
//
//      szFocus         - The domain name or server name of the current
//                        focus.  Server names can be distinguished
//                        by the leading backslashes, or by dwFocusType.
//
//      dwFocusType     - This is the type of focus, either
//                        SM_FOCUS_TYPE_NT_DOMAIN
//                        SM_FOCUS_TYPE_LM_DOMAIN
//                        SM_FOCUS_TYPE_UNKNOWN_DOMAIN
//                        SM_FOCUS_TYPE_NT_SERVER
//                        SM_FOCUS_TYPE_LM_SERVER
//                        SM_FOCUS_TYPE_WFW_SERVER
//                        SM_FOCUS_TYPE_UNKNOWN_SERVER
//

#define SM_FOCUS_TYPE_NT_DOMAIN         1
#define SM_FOCUS_TYPE_LM_DOMAIN         2
#define SM_FOCUS_TYPE_UNKNOWN_DOMAIN    3
#define SM_FOCUS_TYPE_NT_SERVER         4
#define SM_FOCUS_TYPE_LM_SERVER         5
#define SM_FOCUS_TYPE_WFW_SERVER        6
#define SM_FOCUS_TYPE_UNKNOWN_SERVER    7

typedef struct _SMS_GETCURFOCUSA
{
    CHAR        szFocus[UNCLEN+1];
    DWORD       dwFocusType;

} SMS_GETCURFOCUSA, * PSMS_GETCURFOCUSA;

typedef struct _SMS_GETCURFOCUSW
{
    WCHAR       szFocus[UNCLEN+1];
    DWORD       dwFocusType;

} SMS_GETCURFOCUSW, * PSMS_GETCURFOCUSW;

typedef struct _SMS_GETCURFOCUS2A
{
    CHAR        szFocus[MAX_PATH];
    DWORD       dwFocusType;

} SMS_GETCURFOCUS2A, * PSMS_GETCURFOCUS2A;

typedef struct _SMS_GETCURFOCUS2W
{
    WCHAR       szFocus[MAX_PATH];
    DWORD       dwFocusType;

} SMS_GETCURFOCUS2W, * PSMS_GETCURFOCUS2W;

#ifdef UNICODE
#define SMS_GETCURFOCUS             SMS_GETCURFOCUSW
#define PSMS_GETCURFOCUS            PSMS_GETCURFOCUSW
#define SMS_GETCURFOCUS2            SMS_GETCURFOCUS2W
#define PSMS_GETCURFOCUS2           PSMS_GETCURFOCUS2W
#else   // UNICODE
#define SMS_GETCURFOCUS             SMS_GETCURFOCUSA
#define PSMS_GETCURFOCUS            PSMS_GETCURFOCUSA
#define SMS_GETCURFOCUS2            SMS_GETCURFOCUS2A
#define PSMS_GETCURFOCUS2           PSMS_GETCURFOCUS2A
#endif  // UNICODE


//
//  The SMS_GETOPTIONS structure is filled in by the Server Manager
//  when it handles the SM_GETOPTIONS message.  This is used to
//  return the current option settings of the Server Manager
//  application.
//
//      fSaveSettingsOnExit     - Should Server Manager settings be saved
//                                on exit?
//
//      fConfirmation           - Should permanent and/or dangerous
//                                actions be confirmed?  In the current
//                                Server Manager implementation, this
//                                will always be TRUE.
//

typedef struct _SMS_GETOPTIONS
{
    BOOL        fSaveSettingsOnExit;
    BOOL        fConfirmation;

} SMS_GETOPTIONS, * PSMS_GETOPTIONS;


//
//  The SMS_VALIDATE[AW] structure is passed between the Server Manager
//  application and the extension to validate a particular "alien"
//  (non-LANMan) server.
//
//      pszServer       - The (UNC) name of the server to validate.  This
//                        is filled in by the Server Manager.
//
//      pszType         - The type string to display in the Server Manager's
//                        main window.  This is filled in by the extension.
//
//      pszComment      - The comment to display in the Server Manager's
//                        main window.  This is filled in by the extension.
//

typedef struct _SMS_VALIDATEA
{
    const CHAR * pszServer;
    CHAR       * pszType;
    CHAR       * pszComment;

} SMS_VALIDATEA, * PSMS_VALIDATEA;

typedef struct _SMS_VALIDATEW
{
    const WCHAR * pszServer;
    WCHAR       * pszType;
    WCHAR       * pszComment;

} SMS_VALIDATEW, * PSMS_VALIDATEW;

#ifdef UNICODE
#define SMS_VALIDATE                SMS_VALIDATEW
#define PSMS_VALIDATE               PSMS_VALIDATEW
#else   // UNICODE
#define SMS_VALIDATE                SMS_VALIDATEA
#define PSMS_VALIDATE               PSMS_VALIDATEA
#endif  // UNICODE



//
//  These are the names of the extension entrypoints.
//

#define SZ_SME_UNLOADMENU               "SMEUnloadMenu"
#define SZ_SME_INITIALIZEMENU           "SMEInitializeMenu"
#define SZ_SME_REFRESH                  "SMERefresh"
#define SZ_SME_MENUACTION               "SMEMenuAction"

#define SZ_SME_LOADMENUW                "SMELoadMenuW"
#define SZ_SME_GETEXTENDEDERRORSTRINGW  "SMEGetExtendedErrorStringW"
#define SZ_SME_VALIDATEW                "SMEValidateW"

#define SZ_SME_LOADMENUA                "SMELoadMenuA"
#define SZ_SME_GETEXTENDEDERRORSTRINGA  "SMEGetExtendedErrorStringA"
#define SZ_SME_VALIDATEA                "SMEValidateA"

#ifdef UNICODE
#define SZ_SME_LOADMENU                 SZ_SME_LOADMENUW
#define SZ_SME_GETEXTENDEDERRORSTRING   SZ_SME_GETEXTENDEDERRORSTRINGW
#define SZ_SME_VALIDATE                 SZ_SME_VALIDATEW
#else   // !UNICODE
#define SZ_SME_LOADMENU                 SZ_SME_LOADMENUA
#define SZ_SME_GETEXTENDEDERRORSTRING   SZ_SME_GETEXTENDEDERRORSTRINGA
#define SZ_SME_VALIDATE                 SZ_SME_VALIDATEA
#endif  // UNICODE



//
//  Typedefs for the extension entrypoints.
//

typedef DWORD (PASCAL * PSMX_LOADMENU)( HWND          hWnd,
                                        PSMS_LOADMENU psmsload );

typedef LPTSTR (PASCAL * PSMX_GETEXTENDEDERRORSTRING)( VOID );

typedef VOID (PASCAL * PSMX_UNLOADMENU)( VOID );

typedef VOID (PASCAL * PSMX_INITIALIZEMENU)( VOID );

typedef VOID (PASCAL * PSMX_REFRESH)( HWND hwndParent );

typedef VOID (PASCAL * PSMX_MENUACTION)( HWND hwndParent, DWORD dwEventId );

typedef BOOL (PASCAL * PSMX_VALIDATE)( PSMS_VALIDATE psmsvalidate );



//
//  Prototypes for the extension entrypoints.
//

DWORD PASCAL SMELoadMenuA( HWND           hWnd,
                           PSMS_LOADMENUA psmsload );

DWORD PASCAL SMELoadMenuW( HWND           hWnd,
                           PSMS_LOADMENUW psmsload );

LPSTR  PASCAL SMEGetExtendedErrorStringA( VOID );

LPWSTR PASCAL SMEGetExtendedErrorStringW( VOID );

VOID PASCAL SMEUnloadMenu( VOID );

VOID PASCAL SMEInitializeMenu( VOID );

VOID PASCAL SMERefresh( HWND hwndParent );

VOID PASCAL SMEMenuAction( HWND hwndParent, DWORD dwEventId );

BOOL PASCAL SMEValidateA( PSMS_VALIDATEA psmsValidate );

BOOL PASCAL SMEValidateW( PSMS_VALIDATEW psmsValidate );



#endif  // _SMX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\uiprof.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  10/11/90  jonn      created
 *  01/10/91  jonn      removed PSHORT, PUSHORT
 *  01/27/91  jonn      changed from CFGFILE, added UserProfileInit/Free
 *  02/02/91  jonn      added UserProfileWrite/Clear, removed Confirm,
 *                      redefined Set.
 *  02/04/91  jonn      added cpszUsername param to Query, Enum, Set
 *  03/08/91  chuckc    added UserPreferenceXXX() calls.
 *  04/16/91  jonn      added USERPREF_CONFIRMATION and USERPREF_ADMINMENUS
 *  05/08/91  jonn      Added canonicalization of netnames, canonicalize
 *                      on read
 *  06-Apr-92 beng      Nuked PSZ and CPSZ types (Unicode pass)
 */

/****************************************************************************

    MODULE: UIProf.h

    PURPOSE: Handles low-level manipulation of user profile files
             Handles user preferences (saved info)

    FUNCTIONS:

        UserProfileInit() - Initializes the user profile module.  The
                            cached profile is initially empty.
        UserProfileFree() - Frees memory used by the user profile module.
        UserProfileRead() - Caches the profile for the specified user from
                            permanent storage into a global data structure,
                            for future UserProfileQuery/Enum calls.
                            Call with NULL to clear the cached profile.
        UserProfileWrite() - Writes the cached profile into permanent storage.
        UserProfileQuery() - Returns one entry from the cached profile.
        UserProfileEnum() - Lists all entries in the cached profile.
        UserProfileSet() - Changes the cached profile.  It is generally
                            advisable to immediately precede this call with
                            UserProfileRead, and immediately follow it with
                            UserProfileWrite.


        UserPreferenceQuery() - queries a single user preference string.
        UserPreferenceSet() - saves a single user preference string.
        UserPreferenceQueryBool() - queries a user preference bool value.
        UserPreferenceSetBool() - saves a user preference bool value.

    COMMENTS:


      UserProfile routines:

        Under LM30, the profile in $(LANROOT) will only be used if the
        profile stored in the DS is unavailable.

        Be sure to cache a user's profile before calling
        UserProfileQuery, UserProfileEnum or UserProfileSet.  These
        routines will fail if no profile is currently cached.

        The cpszUsername argument is handled differently from different
        APIs.  UserProfileRead and UserProfileWrite use it to specify the
        user profile to read or write.  UserProfileRead will also remember
        the last username in a static variable whether the call succeeds
        or not.  Null or empty user names clear the stored profile in
        UserProfileRead, and return NERR_BadUsername in
        UserProfileWrite.
        UserProfileQuery, Enum and Set compare cpszUsername with the
        last username remembered by UserProfileRead.  If UserProfileRead
        has never been called, or if it was last called with a different
        username (NULL and empty string are equivalent), these calls
        fail with ERROR_GEN_FAILURE.  In this way, you can use the
        cpszUsername parameter to check whether the correct profile is
        loaded, or you can use it to check whether your module has just
        started and should perform the initial UserProfileRead.  Note that
        UserProfileRead(NULL) will prevent the ERROR_GEN_FAILURE return
        code when cpszUsername==NULL.

        Remember that a user may be logged on from several different
        machines, and that the cached profile is not automatically
        updated.  When the profile is to be changed in permanent
        storage, it is generally advisable to reread the profile from
        permanent storage with UserProfileRead, make the change in the
        cache with userProfileSet, and immediately rewrite the profile
        with UserProfileWrite; this reduces the chance that another
        user's changes will be lost.

        When successful, the UserProfile APIs return NO_ERROR (0).  The
        following are the error codes returned by the UserProfile APIs:

        NERR_BadUsername: bad username argument
        NERR_InvalidDevice: bad devicename argument
        ERROR_BAD_NETPATH: bad lanroot argument
        ERROR_BAD_NET_NAME: bad remotename argument
        NERR_UseNotFound: the specified device is not listed in the profile
        ERROR_NOT_ENOUGH_MEMORY:  lack of global memory or overfull profile
        ERROR_GET_FAILURE:  username mismatch
        ERROR_FILE_NOT_FOUND: any file read error
        ERROR_WRITE_FAULT: any file write error

        BUGBUG  We must determine correct behavior when no user is logged on.
        BUGBUG  Do we return ERROR_GEN_FAILURE?  NO_ERROR?  what?


      User preferences routines:

        These routines read and write sticky values in some section
        of the local LANMAN.INI.  These sticky values are therefore
        all local to the workstation;  this mechanism is not intended
        for values associated with a user.  Unlike the UserProfile
        routines, these routines do not cache any data.


****************************************************************************/



/* returncodes: */



/* global macros */
#define PROFILE_DEFAULTFILE    "LMUSER.INI"

#define USERPREF_MAX    256             // arbitrary limit to ease mem alloc

#define USERPREF_YES    "yes"           // this is not internationalized.
#define USERPREF_NO     "no"            // ditto

#define USERPREF_NONE                   0       // no such value
#define USERPREF_AUTOLOGON              0x1     // auto logon
#define USERPREF_AUTORESTORE            0x2     // auto restore profile
#define USERPREF_SAVECONNECTIONS        0x3     // auto save connections
#define USERPREF_USERNAME               0x4     // user name
#define USERPREF_CONFIRMATION           0x5     // confirm actions?
#define USERPREF_ADMINMENUS             0x6     // Admin menus (PrintMgr)

#ifdef __cplusplus
extern "C" {
#endif

/* functions: */


/*
 * UserProfileInit prepares the profile library.  This API must be
 * called exactly once, and before any other UserProfile APIs.
 *
 * error returns:
 * ERROR_NOT_ENOUGH_MEMORY
 */
USHORT UserProfileInit( void
        );



/*
 * UserProfileFree releases memory claimed by the profile library.
 * Do not call UserProfileFree unless the profile library is initialized.
 * After UserProfileFree, the only permissible UserProfile call is
 * userProfileInit.
 *
 * error returns:
 * <none>
 */
USHORT UserProfileFree( void
        );



/*
 * UserProfileRead attempt to cache the user's profile as stored in
 * permanent storage (<cpszLanroot>\LMUSER.INI, or the DS for LM30).
 *
 * Call with cpszUsername==NULL or cpszUsername=="" to clear cached profile.
 * In this case, cpszLanroot is ignored.
 *
 * UserProfileRead updates the username associated with the current
 * profile, for use by UserProfileQuery/Enum/Set.
 *
 * error returns:
 * NERR_BadUsername
 * ERROR_BAD_NETPATH
 * ERROR_NOT_ENOUGH_MEMORY: includes "profile full" state
 * ERROR_FILE_NOT_FOUND
 */
USHORT UserProfileRead(
        const TCHAR *  pszUsername,
        const TCHAR *  pszLanroot
        );



/*
 * UserProfileWrite attempts to write the user's profile back to
 * permanent storage (<cpszLanroot>\LMUSER.INI, or the DS for LM30).
 *
 * error returns:
 * NERR_BadUsername
 * ERROR_BAD_NETPATH
 * ERROR_NOT_ENOUGH_MEMORY
 * ERROR_WRITE_FAULT
 */
USHORT UserProfileWrite(
        const TCHAR *  pszUsername,
        const TCHAR *  pszLanroot
        );



/*
 * psAsgType returns the device type as in use_info_1 or (LM30) use_info_2
 *   fields ui1_asg_type or (LM30) ui2_asg_type.  pusResType returns
 *   the device name type (e.g. UNC, alias, DFS, DS) as in the
 *   use_info_2 ui1_res_type field.  Either of these parameters may be
 *   passed as NULL by programs which do not care about the return value.
 *
 * cpszUsername is used to confirm that the cached profile is for the
 * named user.  Pass NULL to accept any cached profile (but still
 * reject if UserProfileRead has not been called).
 *
 * error returns:
 * ERROR_GEN_FAILURE: cached profile is not for the named user
 * NERR_BadUsername
 * NERR_InvalidDevice
 * NERR_UseNotFound
 * ERROR_NOT_ENOUGH_MEMORY
 * ERROR_INSUFFICIENT_BUFFER
 */
USHORT UserProfileQuery(
        const TCHAR *   pszUsername,
        const TCHAR *   pszDeviceName,
        TCHAR *    pszBuffer,      // returns UNC, alias or domain name
        USHORT usBufferSize,   // length of above buffer
        short far * psAsgType,      // as ui1_asg_type / ui2_asg_type
                               // ignored if NULL
        unsigned short far * pusResType     // ignore / as ui2_res_type
                               // ignored if NULL
        );



/*
 * Returns a list of all devices for which the cached profile lists a
 * connection, separated by nulls, with a null-null at the end.
 * For example, "LPT1:\0D:\0F:\0" (don't forget the extra '\0'
 * implicit in "" strings)
 *
 * cpszUsername is used to confirm that the cached profile is for the
 * named user.  Pass NULL to accept any cached profile (but still
 * reject if UserProfileRead has not been called).
 *
 * error returns:
 * NERR_BadUsername
 * ERROR_NOT_ENOUGH_MEMORY
 * ERROR_INSUFFICIENT_BUFFER
 */
USHORT UserProfileEnum(
        const TCHAR *   pszUsername,
        TCHAR *    pszBuffer,       // returns NULL-NULL list of device names
        USHORT usBufferSize     // length of above buffer
        );



/*
 * Changes the cached profile.  Follow this call with a call to
 *   UserProfileWrite to write the profile to permanent storage.
 *
 * The user is expected to ensure that usResType corresponds to
 * the type of the remote resource, and that device pszDeviceName
 * can be connected to a resource of that type.
 *
 * Does not canonicalize cpszCanonRemoteName, caller must do this
 *
 * cpszUsername is used to confirm that the cached profile is for the
 * named user.  Pass NULL to accept any cached profile (but still
 * reject if no user profile is cached).
 *
 * error returns:
 * ERROR_GEN_FAILURE: cached profile is not for the named user
 * NERR_InvalidDevice: bad cpszDeviceName
 * ERROR_BAD_NET_NAME: bad cpszRemoteName
 * ERROR_NOT_ENOUGH_MEMORY: includes "profile full" state
 */
USHORT UserProfileSet(
        const TCHAR *   pszUsername,
        const TCHAR *   pszDeviceName,
        const TCHAR *   pszRemoteName,
        short  sAsgType,     // as ui2_asg_type
        unsigned short usResType     // as ui2_res_type
        );


/*************************************************************************

    NAME:       UserPreferenceQuery

    SYNOPSIS:   Queries a user preference (ie remembered string).

    INTERFACE:  UserPreferenceQuery( usKey, pchValue, cbLen )
                usKey    - will indicate which value we want, as defined
                           in uiprof.h.
                pchValue - pointer to buffer that will receive value
                cbLen    - size of buffer

                return value is NERR_Success, ERROR_INAVALID_PARAMETER,
                or NetConfigGet2 error.

    USES:       Use to recall values saved by UserPrefenceSet(), normally
                things like default logon name, etc.

    CAVEATS:

    NOTES:      Currently, the values are stored in LANMAN.INI, and hence
                each value is per machine.

    HISTORY:
        chuckc   7-Mar-1991     Created

**************************************************************************/

USHORT UserPreferenceQuery( USHORT     usKey,
                            TCHAR FAR * pchValue,
                            USHORT     cbLen);

/*************************************************************************

    NAME:       UserPreferenceSet

    SYNOPSIS:   Sets a user preference (remembers a string).

    INTERFACE:  UserPreferenceSet( usKey, pchValue )
                usKey    - will indicate which value we want, as defined
                           in uiprof.h.
                pchValue - pointer to null terminates string to be remembered

                return value is NERR_Success, ERROR_INAVALID_PARAMETER,
                or NetConfigSet error.

    USES:       Use to save values to be retrieved by UserPrefenceQuery(),
                normally things like default logon name, etc.

    CAVEATS:

    NOTES:      Currently, the values are stored in LANMAN.INI, and hence
                each value is per machine.

    HISTORY:
        chuckc   7-Mar-1991     Created

**************************************************************************/

USHORT UserPreferenceSet( USHORT     usKey,
                          TCHAR FAR * pchValue);

/*************************************************************************

    NAME:       UserPreferenceQueryBool

    SYNOPSIS:   Queries a BOOL a user preference (remembered flag).

    INTERFACE:  UserPreferenceQueryBool( usKey, pfValue )
                usKey    - will indicate which value we want, as defined
                           in uiprof.h.
                pfValue  - pointer to BOOL that will contain value

                return value is NERR_Success, ERROR_INAVALID_PARAMETER,
                or UserPreferenceQuery error.

    USES:       Use to retrieve flags set by by UserPrefenceSetBool(),
                normally things like auto logon, etc.

    CAVEATS:

    NOTES:      Currently, the values are stored in LANMAN.INI, and hence
                each value is per machine. This func calls
                UserPreferenceQuery(), taking "yes" or "YES" to be
                true, "no" or "NO" to be false.

    HISTORY:
        chuckc   7-Mar-1991     Created

**************************************************************************/


USHORT UserPreferenceQueryBool( USHORT     usKey,
                                BOOL FAR * pfValue) ;

/*************************************************************************

    NAME:       UserPreferenceSetBool

    SYNOPSIS:   Sets a user preference flag

    INTERFACE:  UserPreferenceSetBool( usKey, fValue )
                usKey    - will indicate which value we want, as defined
                           in uiprof.h.
                fValue   - BOOL value, true or false

                return value is NERR_Success, ERROR_INAVALID_PARAMETER,
                or UserPreferenceSet error.

    USES:       Use to save values to be retrieved by UserPrefenceQueryBool(),
                normally flags like autologon, etc.

    CAVEATS:

    NOTES:      Currently, the values are stored in LANMAN.INI, and hence
                each value is per machine. This func calls
                UserPreferenceSet(), taking "yes" or "YES" to be
                true, "no" or "NO" to be false.
                We also restrict values to length of < USERPREF_MAX.

    HISTORY:
        chuckc   7-Mar-1991     Created

**************************************************************************/

USHORT UserPreferenceSetBool( USHORT     usKey,
                              BOOL       fValue);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\uimsg.h ===
/********************************************************/
/*               Microsoft Windows NT                   */
/*       Copyright(c) Microsoft Corp., 1990, 1991       */
/********************************************************/

/*
 * uimsg.h
 * Defines the ranges for ALL UI messages
 *
 * It also contains messages that are common across apps
 * but not in the NERR or BASE error ranges.
 *
 * FILE HISTORY:
 *      beng        05-Aug-1992 Dllization
 */

#ifndef _UIMSG_H_
#define _UIMSG_H_

/*
 * NOTE below is based on MAX_NERR currently being 3000.
 * we dont include NETERR.H and define in terms of MAX_NERR because
 * this file goes thru RC. 7000 is chosen since its past all
 * the NERR and APPERR and a couple of thousand beyond for safety.
 */
#define IDS_UI_BASE       7000


// Ranges for partitioning the IDS namespace.
// The ordering of these ranges is significant, since BLT can only
// associate a single range with a hmod on which to locate a string.

// These strings all reside on hmodCommon0

#define IDS_UI_COMMON_BASE      (IDS_UI_BASE+0)
#define IDS_UI_COMMON_LAST      (IDS_UI_BASE+999)

#define IDS_UI_BLT_BASE         (IDS_UI_BASE+1000)
#define IDS_UI_BLT_LAST         (IDS_UI_BASE+1999)

#define IDS_UI_APPLIB_BASE      (IDS_UI_BASE+2000)
#define IDS_UI_APPLIB_LAST      (IDS_UI_BASE+2899)

#define IDS_UI_MISC_BASE        (IDS_UI_BASE+3000)
#define IDS_UI_MISC_LAST        (IDS_UI_BASE+3999)

// These strings each have their own module

#define IDS_UI_ACLEDIT_BASE     (IDS_UI_BASE+4000)
#define IDS_UI_ACLEDIT_LAST     (IDS_UI_BASE+4999)

#define IDS_UI_MPR_BASE         (IDS_UI_BASE+5000)
#define IDS_UI_MPR_LAST         (IDS_UI_BASE+5999)

#define IDS_UI_NCPA_BASE        (IDS_UI_BASE+6000)
#define IDS_UI_NCPA_LAST        (IDS_UI_BASE+6999)

#define IDS_UI_SETUP_BASE       (IDS_UI_BASE+7000)
#define IDS_UI_SETUP_LAST       (IDS_UI_BASE+7999)

#define IDS_UI_SHELL_BASE       (IDS_UI_BASE+8000)
#define IDS_UI_SHELL_LAST       (IDS_UI_BASE+8999)

#define IDS_UI_IPX_BASE         (IDS_UI_BASE+9000)
#define IDS_UI_IPX_LAST         (IDS_UI_BASE+9999)

#define IDS_UI_TCP_BASE         (IDS_UI_BASE+10000)
#define IDS_UI_TCP_LAST         (IDS_UI_BASE+10999)

#define IDS_UI_FTPMGR_BASE      (IDS_UI_BASE+16000)
#define IDS_UI_FTPMGR_LAST      (IDS_UI_BASE+16999)

#define IDS_UI_RESERVED1_BASE      (IDS_UI_BASE+17000)
#define IDS_UI_RESERVED1_LAST      (IDS_UI_BASE+17999)

#define IDS_UI_RESERVED2_BASE      (IDS_UI_BASE+18000)
#define IDS_UI_RESERVED2_LAST      (IDS_UI_BASE+18999)

// These strings all reside on the application hmodule, for now

#define IDS_UI_LMOBJ_BASE       (IDS_UI_BASE+9900)
#define IDS_UI_LMOBJ_LAST       (IDS_UI_BASE+9999)

#define IDS_UI_PROFILE_BASE     (IDS_UI_BASE+10000)
#define IDS_UI_PROFILE_LAST     (IDS_UI_BASE+10999)

#define IDS_UI_ADMIN_BASE       (IDS_UI_BASE+11000)
#define IDS_UI_ADMIN_LAST       (IDS_UI_BASE+11999)

#define IDS_UI_SRVMGR_BASE      (IDS_UI_BASE+12000)
#define IDS_UI_SRVMGR_LAST      (IDS_UI_BASE+12999)

#define IDS_UI_USRMGR_BASE      (IDS_UI_BASE+13000)
#define IDS_UI_USRMGR_LAST      (IDS_UI_BASE+13999)

#define IDS_UI_EVTVWR_BASE      (IDS_UI_BASE+14000)
#define IDS_UI_EVTVWR_LAST      (IDS_UI_BASE+14999)

#define IDS_UI_RASMAC_BASE      (IDS_UI_BASE+15000)
#define IDS_UI_RASMAC_LAST      (IDS_UI_BASE+15999)

// Use these manifests when constructing the application

#define IDS_UI_APP_BASE         (IDS_UI_LMOBJ_BASE)
#define IDS_UI_APP_LAST         (IDS_UI_RASMAC_LAST)

/*------------------------------------------------------------------------*/

/*
 * use this range, which is the top half of COMMON for strings like YES/NO
 */
#define  IDS_UI_YES             (IDS_UI_COMMON_BASE+0)
#define  IDS_UI_NO              (IDS_UI_COMMON_BASE+1)

/*
 * Read/Write/Create/Execute/Delete/Change_attrib/Change_Perm must be
 * contiguous msg ids, and IDS_UI_READ must be have the first msg id and
 * IDS_UI_CHANGE_PERM must have the last msg id.
 */
#define  IDS_UI_READ            (IDS_UI_COMMON_BASE+2)
#define  IDS_UI_WRITE           (IDS_UI_COMMON_BASE+3)
#define  IDS_UI_CREATE          (IDS_UI_COMMON_BASE+4)
#define  IDS_UI_EXECUTE         (IDS_UI_COMMON_BASE+5)
#define  IDS_UI_DELETE          (IDS_UI_COMMON_BASE+6)
#define  IDS_UI_CHANGE_ATTRIB   (IDS_UI_COMMON_BASE+7)
#define  IDS_UI_CHANGE_PERM     (IDS_UI_COMMON_BASE+8)

#define  IDS_UI_NOTAVAIL        (IDS_UI_COMMON_BASE+9)
#define  IDS_UI_UNKNOWN         (IDS_UI_COMMON_BASE+10)

#define  IDS_UI_NONE            (IDS_UI_COMMON_BASE+11)
#define  IDS_UI_ERROR           (IDS_UI_COMMON_BASE+12)
#define  IDS_UI_WARNING         (IDS_UI_COMMON_BASE+13)
#define  IDS_UI_INFORMATION     (IDS_UI_COMMON_BASE+14)
#define  IDS_UI_AUDIT_SUCCESS   (IDS_UI_COMMON_BASE+15)
#define  IDS_UI_AUDIT_FAILURE   (IDS_UI_COMMON_BASE+16)
#define  IDS_UI_DEFAULT_DESC    (IDS_UI_COMMON_BASE+17)

#define  IDS_UI_NA              (IDS_UI_COMMON_BASE+18)
/*
 * use this range, which is the bottom half of COMMON for longer strings
 */
#define  IDS_UI_CLOSE_FILE      (IDS_UI_COMMON_BASE+500)
#define  IDS_UI_CLOSE_ALL       (IDS_UI_COMMON_BASE+501)
#define  IDS_UI_CLOSE_WARN      (IDS_UI_COMMON_BASE+502)
#define  IDS_UI_CLOSE_LOSE_DATA (IDS_UI_COMMON_BASE+503)

#define  IDS_UI_LOG_RECORD_CORRUPT  (IDS_UI_COMMON_BASE+504)

#endif  // _UIMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\uinetlib.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    uinetlib.h
    Replacement netlib.h

    This file redirects netlib.h to string.h.  NETLIB.H is a LANMAN
    include file for which STRING.H is the nearest equivalent.  The
    directory containing this file should only be on the include path for NT.

    We place several macros here to allow the "f" variants to be used.

    FILE HISTORY:
        jonn        12-Sep-1991 Added to $(UI)\common\h\nt
        beng        22-Oct-1991 Patch for NT c runtimes
        beng        09-Mar-1992 Add Unicode versions
        beng        28-Mar-1992 More Unicode versions
        beng        07-May-1992 Use correct wcs include and names
        KeithMo     12-Dec-1992 Moved to common\h, renamed to uinetlib.h
                                to avoid conflict with net\inc\netlib.h.
        jonn        25-Mar-1993 ITG special sort
        jonn        02-Feb-1994 Added NETUI_strncmp2 and NETUI_strnicmp2
*/

#ifndef NETUI_UINETLIB
#define NETUI_UINETLIB

#if defined(__cplusplus)
extern "C"
{
#endif

void  InitCompareParam( void );
DWORD QueryStdCompareParam( void );
DWORD QueryNocaseCompareParam( void );
DWORD QueryUserDefaultLCID( void ); // actually an LCID

DLL_BASED
INT NETUI_strcmp( const WCHAR * pchString1, const WCHAR * pchString2 );
DLL_BASED
INT NETUI_stricmp( const WCHAR * pchString1, const WCHAR * pchString2 );
DLL_BASED
INT NETUI_strncmp( const WCHAR * pchString1, const WCHAR * pchString2, INT cch );
DLL_BASED
INT NETUI_strnicmp( const WCHAR * pchString1, const WCHAR * pchString2, INT cch );

/*
    NETUI_strncmp2 and NETUI_strncmp2 allow you to compare two strings
    of fixed but different lengths.  This is important where the strings
    might compare '-', and cutting "X-Y" to "X-" might have undesirable
    effects on sort order without SORT_STRINGSORT (see ::CompareStringW).

    BEWARE of using NETUI_strncmp and NETUI_strnicmp without understanding
    this behavior!  The same applies to strncmp() and strnicmp().
*/

DLL_BASED
INT NETUI_strncmp2( const WCHAR * pchString1, INT cch1,
                    const WCHAR * pchString2, INT cch2 );
DLL_BASED
INT NETUI_strnicmp2( const WCHAR * pchString1, INT cch1,
                     const WCHAR * pchString2, INT cch2 );


#define memcmpf memcmp
#define memcpyf memcpy
#define memmovef memmove
#define memsetf memset

#if defined(UNICODE)
#define strcatf wcscat
#define strchrf wcschr
#define strcmpf(x,y) NETUI_strcmp(x,y)
#define stricmpf(x,y) NETUI_stricmp(x,y)
#define strcpyf wcscpy
#define strcspnf wcscspn
#define strlenf wcslen
#define strlwrf _wcslwr
#define strncatf wcsncat
#define strncmpf(x,y,n) NETUI_strncmp(x,y,n)
#define strnicmpf(x,y,n) NETUI_strnicmp(x,y,n)
#define strncpyf wcsncpy
#define strpbrkf wcspbrk
#define strrchrf wcsrchr
#define strrevf _wcsrev
#define strspnf wcsspn
#define strstrf wcsstr
//#define strtokf strtok - This function is not available under Unicode
#define struprf _wcsupr
#else
#define strcatf strcat
#define strchrf strchr
#define strcmpf strcmp
#define stricmpf _stricmp
#define strcpyf strcpy
#define strcspnf strcspn
#define strlenf strlen
#define strlwrf _strlwr
#define strncatf strncat
#define strncmpf strncmp
#define strnicmpf _strnicmp
#define strncpyf strncpy
#define strpbrkf strpbrk
#define strrchrf strrchr
#define strrevf _strrev
#define strspnf strspn
#define strstrf strstr
#define strtokf strtok
#define struprf _strupr
#endif

#define nprintf printf

#if defined(__cplusplus)
}
#endif

#if defined(UNICODE)
#include <wchar.h>
#else
#include <string.h>
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\uirsrc.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    uirsrc.h
    Resource header file coordination

    This file defines and coordinates the resource IDs of all resources.

    FILE HISTORY:
        beng        05-Aug-1992 Created
*/

#ifndef _UIRSRC_H_
#define _UIRSRC_H_


#define IDRSRC_APP_BASE     1
#define IDRSRC_APP_LAST     4999

#define IDRSRC_NCPA_BASE    6000
#define IDRSRC_NCPA_LAST    6999

#define IDRSRC_MPRUI_BASE   7000
#define IDRSRC_MPRUI_LAST   7999

#define IDRSRC_SHELL_BASE   8000
#define IDRSRC_SHELL_LAST   8999

#define IDRSRC_RESERVED1_BASE  9000
#define IDRSRC_RESERVED1_LAST  9199

#define IDRSRC_RESERVED2_BASE  9200
#define IDRSRC_RESERVED2_LAST  9399

#define IDRSRC_ACLEDIT_BASE 10000
#define IDRSRC_ACLEDIT_LAST 10999

#define IDRSRC_RASMAC_BASE 11000
#define IDRSRC_RASMAC_LAST 11999

#define IDRSRC_FTPMGR_BASE  12000
#define IDRSRC_FTPMGR_LAST  12999

#define IDRSRC_IPX_BASE  13000
#define IDRSRC_IPX_LAST  13999

#define IDRSRC_TCP_BASE  14000
#define IDRSRC_TCP_LAST  14999

#define IDRSRC_COMMON_BASE  15000


#endif // _UIRSRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\wintimrc.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    wintimrc.h
    IDS constants for the WINTIME.RC date/time resource file

    FILE HISTORY:
        terryk      ??-???-???? Created
        beng        21-Feb-1992 Moved codes out of everybody's way
        beng        05-Aug-1992 Moved codes into correct range
*/

#ifndef _WINTIMRC_H_
#define _WINTIMRC_H_

#define  IDS_WINTIME_BASE       IDS_UI_MISC_BASE+500

#define  WINTIME_DAY_LENGTH         12  /* maximum length of a day name   */
#define  WINTIME_SHORT_DAY_LENGTH   4   /* max length of a short day name */
#define  WINTIME_MONTH_LENGTH       12  /* length of a long month name    */
#define  WINTIME_SHORT_MONTH_LENGTH 4   /* max length of a short month    */

#define  IDS_SUNDAY             (IDS_WINTIME_BASE+24)
#define  IDS_MONDAY             (IDS_WINTIME_BASE+25)
#define  IDS_TUESDAY            (IDS_WINTIME_BASE+26)
#define  IDS_WEDNESDAY          (IDS_WINTIME_BASE+27)
#define  IDS_THURSDAY           (IDS_WINTIME_BASE+28)
#define  IDS_FRIDAY             (IDS_WINTIME_BASE+29)
#define  IDS_SATURDAY           (IDS_WINTIME_BASE+30)
#define  IDS_SUNDAY_SHORT       (IDS_WINTIME_BASE+31)
#define  IDS_MONDAY_SHORT       (IDS_WINTIME_BASE+32)
#define  IDS_TUESDAY_SHORT      (IDS_WINTIME_BASE+33)
#define  IDS_WEDNESDAY_SHORT    (IDS_WINTIME_BASE+34)
#define  IDS_THURSDAY_SHORT     (IDS_WINTIME_BASE+35)
#define  IDS_FRIDAY_SHORT       (IDS_WINTIME_BASE+36)
#define  IDS_SATURDAY_SHORT     (IDS_WINTIME_BASE+37)
#define  IDS_JANUARY            (IDS_WINTIME_BASE+40)
#define  IDS_FEBURARY           (IDS_WINTIME_BASE+41)
#define  IDS_MARCH              (IDS_WINTIME_BASE+42)
#define  IDS_APRIL              (IDS_WINTIME_BASE+43)
#define  IDS_MAY                (IDS_WINTIME_BASE+44)
#define  IDS_JUNE               (IDS_WINTIME_BASE+45)
#define  IDS_JULY               (IDS_WINTIME_BASE+46)
#define  IDS_AUGUST             (IDS_WINTIME_BASE+47)
#define  IDS_SEPTEMBER          (IDS_WINTIME_BASE+48)
#define  IDS_OCTOBER            (IDS_WINTIME_BASE+49)
#define  IDS_NOVEMBER           (IDS_WINTIME_BASE+50)
#define  IDS_DECEMBER           (IDS_WINTIME_BASE+51)
#define  IDS_JANUARY_SHORT      (IDS_WINTIME_BASE+56)
#define  IDS_FEBURARY_SHORT     (IDS_WINTIME_BASE+57)
#define  IDS_MARCH_SHORT        (IDS_WINTIME_BASE+58)
#define  IDS_APRIL_SHORT        (IDS_WINTIME_BASE+59)
#define  IDS_MAY_SHORT          (IDS_WINTIME_BASE+60)
#define  IDS_JUNE_SHORT         (IDS_WINTIME_BASE+61)
#define  IDS_JULY_SHORT         (IDS_WINTIME_BASE+62)
#define  IDS_AUGUST_SHORT       (IDS_WINTIME_BASE+63)
#define  IDS_SEPTEMBER_SHORT    (IDS_WINTIME_BASE+64)
#define  IDS_OCTOBER_SHORT      (IDS_WINTIME_BASE+65)
#define  IDS_NOVEMBER_SHORT     (IDS_WINTIME_BASE+66)
#define  IDS_DECEMBER_SHORT     (IDS_WINTIME_BASE+67)
#define  IDS_SESSION_DURATION   (IDS_WINTIME_BASE+68)

#endif // end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\umx.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    umx.h
    This file contains the common messages, manifests, types, and
    structures used by User Manager Extensions.

    NOTE:  You must include windows.h and lmcons.h *before* this file.


    FILE HISTORY:
        JonN        19-Nov-1992     Created, templated from SMX spec
        JonN        16-May-1996     Added GETCURFOCUS2

*/



#ifndef _UMX_H_
#define _UMX_H_



//
//  This is the maximum length allowed for an extension menu item.
//

#define UME_MENU_TEXT_LEN               50



//
//  This is the current version number of the extension interface.
//  Version 0 is the original version (NT 3.x).
//  Version 1 supports GETCURFOCUS2 (NT 4.x).
//

#define UME_VERSION                     1


//
//  These are the two listboxes in the User Manager main window.
//

#define UMS_LISTBOX_USERS               0
#define UMS_LISTBOX_GROUPS              1


//
//  These are the messages sent from the extension to the
//  User Manager application.
//
//      UM_GETSELCOUNT
//
//              Purpose - Retrieves the number of selected items in
//                        the specified listbox.
//
//              wParam  - Listbox index.  This 0-based index specifies
//                        the listbox to query.  For the User Manager,
//                        this may be either UMS_LISTBOX_USERS or
//                        UMS_LISTBOX_GROUPS.
//
//              lParam  - Points to a UMS_GETSELCOUNT structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      UM_GETUSERSEL[AW]
//
//              Purpose - Retrieves a particular selection.
//
//              wParam  - Selection index.  This 0-based index specifies
//                        the selected item to query.  This is used here
//                        since the Users listbox is multiple-select.
//
//              lParam  - Points to a UMS_GETSEL[AW] structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      UM_GETGROUPSEL[AW]
//
//              Purpose - Retrieves a particular selection.
//
//              wParam  - Selection index.  This 0-based index specifies
//                        the selected item to query.  This is useful
//                        for muliple-select listboxes.  Since the Groups
//                        listbox is single-select, this value must always
//                        be zero.
//
//              lParam  - Points to a UMS_GETSEL[AW] structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      UM_GETCURFOCUS[AW][2]
//
//              Purpose - Retrieves the current application focus.
//                        New clients should use version 2 when
//                        UMS_LOADMENU.dwVersion is 1 or greater.
//
//              wParam  - Must be zero.
//
//              lParam  - Points to a UMS_GETCURFOCUS[2] structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      UM_GETOPTIONS[2]
//
//              Purpose - Retrieves the current option settings
//
//              wParam  - Must be zero.
//
//              lParam  - Points to a UMS_GETOPTIONS[2] structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//

#define UM_GETSELCOUNT                  (WM_USER + 1000)
#define UM_GETUSERSELA                  (WM_USER + 1001)
#define UM_GETUSERSELW                  (WM_USER + 1002)
#define UM_GETGROUPSELA                 (WM_USER + 1003)
#define UM_GETGROUPSELW                 (WM_USER + 1004)
#define UM_GETCURFOCUSA                 (WM_USER + 1005)
#define UM_GETCURFOCUSW                 (WM_USER + 1006)
#define UM_GETOPTIONS                   (WM_USER + 1007)
#define UM_GETOPTIONS2                  (WM_USER + 1008)
#define UM_GETCURFOCUS2A                (WM_USER + 1009)
#define UM_GETCURFOCUS2W                (WM_USER + 1010)

#ifdef UNICODE
#define UM_GETUSERSEL                 UM_GETUSERSELW
#define UM_GETGROUPSEL                UM_GETGROUPSELW
#define UM_GETCURFOCUS                UM_GETCURFOCUSW
#define UM_GETCURFOCUS2               UM_GETCURFOCUS2W
#else   // !UNICODE
#define UM_GETUSERSEL                 UM_GETUSERSELA
#define UM_GETGROUPSEL                UM_GETGROUPSELA
#define UM_GETCURFOCUS                UM_GETCURFOCUSA
#define UM_GETCURFOCUS2               UM_GETCURFOCUS2A
#endif  // UNICODE



//
//  These structures are used when the extension is
//  communicating with the application.
//


//
//  The UMS_LOADMENU[AW] structure is passed to the extension's
//  UMELoadMenu[AW] entrypoint when the extension is loaded.
//
//      dwVersion       - On entry to UMELoadMenu[AW], this will
//                        contain the maximum extension version
//                        supported by the User Manager.  If the
//                        extension supports a lower version, it
//                        should set this field appropriately before
//                        returning.  The User Manager will use
//                        the returned value to determine the
//                        capabilities of the extension.
//
//                        Version 0 is the original version (NT 3.x).
//                        Version 1 supports GETCURFOCUS2.
//
//      szMenuName      - The name of the menu item that is to appear
//                        in the app's main menu.  This value will also
//                        appear in the "Help On Extensions" submene and
//                        the "View" menu.
//
//      hMenu           - A valid HMENU for the popup-menu to be inserted
//                        into the app's main menu.  Ownership of this
//                        handle transfers to the User Manager.  The
//                        extension should *not* destroy this handle.
//
//      szHelpFileName  - The name of the help file associated with this
//                        extension.  This file will be used for the
//                        "Help On Extensions" menu.  This will also be
//                        used when the user presses [F1] while the
//                        extension's menu is dropped.
//
//      dwMenuDelta     - The User Manager will apply this delta
//                        to each menu ID present in hMenu.  This is
//                        to prevent conflicts with other extension's
//                        menu IDs.
//

typedef struct _UMS_LOADMENUA
{
    DWORD       dwVersion;
    CHAR        szMenuName[UME_MENU_TEXT_LEN + 1];
    HMENU       hMenu;
    CHAR        szHelpFileName[MAX_PATH];
    DWORD       dwMenuDelta;

} UMS_LOADMENUA, * PUMS_LOADMENUA;

typedef struct _UMS_LOADMENUW
{
    DWORD       dwVersion;
    WCHAR       szMenuName[UME_MENU_TEXT_LEN + 1];
    HMENU       hMenu;
    WCHAR       szHelpFileName[MAX_PATH];
    DWORD       dwMenuDelta;

} UMS_LOADMENUW, * PUMS_LOADMENUW;

#ifdef UNICODE
#define UMS_LOADMENU                    UMS_LOADMENUW
#define PUMS_LOADMENU                   PUMS_LOADMENUW
#else   // !UNICODE
#define UMS_LOADMENU                    UMS_LOADMENUA
#define PUMS_LOADMENU                   PUMS_LOADMENUA
#endif  // UNICODE

#define UM_SELTYPE_USER     0x10
#define UM_SELTYPE_NORMALUSER   0x1 | UM_SELTYPE_USER
#define UM_SELTYPE_REMOTEUSER   0x2 | UM_SELTYPE_USER
#define UM_SELTYPE_GROUP    0x20
#define UM_SELTYPE_LOCALGROUP   0x4 | UM_SELTYPE_GROUP
#define UM_SELTYPE_GLOBALGROUP  0x8 | UM_SELTYPE_GROUP


//
//  The UMS_GETSEL[AW] structure is filled in by the User Manager
//  when it handles UM_GETUSERSEL[AW] or UM_GETGROUPSEL[AW] messages.
//  This is used to return the current selection to the extension.
//  Note that this structure contains pointers.  The extension should not
//  assume that these pointers will be valid forever, instead the
//  extension should promptly copy these strings and use the copies.
//
//      dwRID         - The RID of the item.  Note that the RID is not
//                      valid when the UMS_GETSEL describes a group.
//
//      pchName       - Will receive the name of the selected account.
//
//      dwSelType     - Will receive the account type mask associated
//                      with the account.
//
//      pchName       - Will receive the fullname of the selected account.
//                      Note that groups do not have fullnames.
//
//      pchComment    - Will receive the comment of the selected account.
//

typedef struct _UMS_GETSELA
{
    DWORD       dwRID;
    LPSTR       pchName;
    DWORD       dwSelType;
    LPSTR       pchFullName;
    LPSTR       pchComment;

} UMS_GETSELA, * PUMS_GETSELA;

typedef struct _UMS_GETSELW
{
    DWORD       dwRID;
    LPWSTR      pchName;
    DWORD       dwSelType;
    LPWSTR      pchFullName;
    LPWSTR      pchComment;

} UMS_GETSELW, * PUMS_GETSELW;

#ifdef UNICODE
#define UMS_GETSEL                  UMS_GETSELW
#define PUMS_GETSEL                 PUMS_GETSELW
#else   // !UNICODE
#define UMS_GETSEL                  UMS_GETSELA
#define PUMS_GETSEL                 PUMS_GETSELA
#endif  // UNICODE


//
//  The UMS_GETSELCOUNT structure is filled in by the User Manager
//  when it handles the UM_GETSELCOUNT message.  This is used to
//  return the number of selected items to the extension.  This could
//  be more than 1 for the user listbox.
//
//      dwItems         - The number of selected items in the listbox.
//

typedef struct _UMS_GETSELCOUNT
{
    DWORD       dwItems;
} UMS_GETSELCOUNT, * PUMS_GETSELCOUNT;


//
//  The UMS_GETCURFOCUS structure is filled in by the User Manager
//  when it handles the UM_GETCURFOCUS message.  This is used to
//  return the current focus of the User Manager application.
//
//  UMS_GETCURFOCUS is outdated due to the change in server name length,
//  use UMS_GETCURFOCUS2 when SMS_LOADMENU.dwVersion is 1 or greater.
//
//      szFocus         - The domain name or server name of the current
//                        focus.  Server names can be distinguished
//                        by the leading backslashes, or by dwFocusType.
//
//      dwFocusType     - This is the type of focus, either
//                        UM_FOCUS_TYPE_DOMAIN (and szFocus is a domain name)
//                        UM_FOCUS_TYPE_WINNT  (and szFocus is a server name)
//                        UM_FOCUS_TYPE_LM     (and szFocus is a server name)
//                        UM_FOCUS_TYPE_UNKNOWN
//
//      szFocusPDC      - This is the PDC of the domain of focus, and is valid
//                        only if focus is set to UM_FOCUS_TYPE_DOMAIN.
//
//      psidFocus       - This points to the SID of the domain of focus.  It
//                        may be NULL.  Note that this pointer will not be
//                        valid forever, the extension should copy the SID
//                        immediately if it intends to use it.
//

#define UM_FOCUS_TYPE_DOMAIN    1
#define UM_FOCUS_TYPE_WINNT     2
#define UM_FOCUS_TYPE_LM        3
#define UM_FOCUS_TYPE_UNKNOWN   4

typedef struct _UMS_GETCURFOCUSA
{
    CHAR        szFocus[UNCLEN+1];
    DWORD       dwFocusType;
    CHAR        szFocusPDC[UNCLEN+1];
    PVOID       psidFocus;  // actually a SID pointer
} UMS_GETCURFOCUSA, * PUMS_GETCURFOCUSA;

typedef struct _UMS_GETCURFOCUSW
{
    WCHAR       szFocus[UNCLEN+1];
    DWORD       dwFocusType;
    WCHAR       szFocusPDC[UNCLEN+1];
    PVOID       psidFocus;  // actually a SID pointer
} UMS_GETCURFOCUSW, * PUMS_GETCURFOCUSW;

typedef struct _UMS_GETCURFOCUS2A
{
    CHAR        szFocus[MAX_PATH];
    DWORD       dwFocusType;
    CHAR        szFocusPDC[MAX_PATH];
    PVOID       psidFocus;  // actually a SID pointer
} UMS_GETCURFOCUS2A, * PUMS_GETCURFOCUS2A;

typedef struct _UMS_GETCURFOCUS2W
{
    WCHAR       szFocus[MAX_PATH];
    DWORD       dwFocusType;
    WCHAR       szFocusPDC[MAX_PATH];
    PVOID       psidFocus;  // actually a SID pointer
} UMS_GETCURFOCUS2W, * PUMS_GETCURFOCUS2W;

#ifdef UNICODE
#define UMS_GETCURFOCUS             UMS_GETCURFOCUSW
#define PUMS_GETCURFOCUS            PUMS_GETCURFOCUSW
#define UMS_GETCURFOCUS2            UMS_GETCURFOCUS2W
#define PUMS_GETCURFOCUS2           PUMS_GETCURFOCUS2W
#else   // UNICODE
#define UMS_GETCURFOCUS             UMS_GETCURFOCUSA
#define PUMS_GETCURFOCUS            PUMS_GETCURFOCUSA
#define UMS_GETCURFOCUS2            UMS_GETCURFOCUS2A
#define PUMS_GETCURFOCUS2           PUMS_GETCURFOCUS2A
#endif  // UNICODE


//
//  The UMS_GETOPTIONS[2] structure is filled in by the User Manager
//  when it handles the UM_GETOPTIONS[2] message.  This is used to
//  return the current option settings of the User Manager application.
//
//      fSaveSettingsOnExit - Should User Manager settings be saved on exit?
//
//      fConfirmation   - Should permanent and/or dangerous actions be
//                        confirmed?
//
//      fSortByFullName - Should the main user listbox be sorted by
//                        fullname rather than by user name?
//
//      fMiniUserManager - (UMS_GETOPTIONS2 only) Is this the User Manager
//                         rather than the User Manager for Domains?
//
//      fLowSpeedConnection - (UMS_GETOPTIONS2 only) Is the User Manager
//                            optimized for use across a slow network link?
//

typedef struct _UMS_GETOPTIONS
{
    BOOL        fSaveSettingsOnExit;
    BOOL        fConfirmation;
    BOOL        fSortByFullName;
} UMS_GETOPTIONS, * PUMS_GETOPTIONS;

typedef struct _UMS_GETOPTIONS2
{
    BOOL        fSaveSettingsOnExit;
    BOOL        fConfirmation;
    BOOL        fSortByFullName;
    BOOL        fMiniUserManager;
    BOOL        fLowSpeedConnection;
} UMS_GETOPTIONS2, * PUMS_GETOPTIONS2;




//
//  These are the names of the extension entrypoints.
//

#define SZ_UME_UNLOADMENU               "UMEUnloadMenu"
#define SZ_UME_INITIALIZEMENU           "UMEInitializeMenu"
#define SZ_UME_REFRESH                  "UMERefresh"
#define SZ_UME_MENUACTION               "UMEMenuAction"

#define SZ_UME_LOADMENUW                "UMELoadMenuW"
#define SZ_UME_GETEXTENDEDERRORSTRINGW  "UMEGetExtendedErrorStringW"
#define SZ_UME_CREATEW                  "UMECreateW"
#define SZ_UME_DELETEW                  "UMEDeleteW"
#define SZ_UME_RENAMEW                  "UMERenameW"

#define SZ_UME_LOADMENUA                "UMELoadMenuA"
#define SZ_UME_GETEXTENDEDERRORSTRINGA  "UMEGetExtendedErrorStringA"
#define SZ_UME_CREATEA                  "UMECreateA"
#define SZ_UME_DELETEA                  "UMEDeleteA"
#define SZ_UME_RENAMEA                  "UMERenameA"

#ifdef UNICODE
#define SZ_UME_LOADMENU                 SZ_UME_LOADMENUW
#define SZ_UME_GETEXTENDEDERRORSTRING   SZ_UME_GETEXTENDEDERRORSTRINGW
#define SZ_UME_CREATE                   SZ_UME_CREATEW
#define SZ_UME_DELETE                   SZ_UME_DELETEW
#define SZ_UME_RENAME                   SZ_UME_RENAMEW
#else   // !UNICODE
#define SZ_UME_LOADMENU                 SZ_UME_LOADMENUA
#define SZ_UME_GETEXTENDEDERRORSTRING   SZ_UME_GETEXTENDEDERRORSTRINGA
#define SZ_UME_CREATE                   SZ_UME_CREATEA
#define SZ_UME_DELETE                   SZ_UME_DELETEA
#define SZ_UME_RENAME                   SZ_UME_RENAMEA
#endif  // UNICODE



//
//  Typedefs for the extension entrypoints.
//

typedef DWORD (PASCAL * PUMX_LOADMENUW)( HWND          hWnd,
                                         PUMS_LOADMENUW pumsload );
typedef DWORD (PASCAL * PUMX_LOADMENUA)( HWND          hWnd,
                                         PUMS_LOADMENUA pumsload );

typedef LPWSTR (PASCAL * PUMX_GETEXTENDEDERRORSTRINGW)( VOID );
typedef LPSTR  (PASCAL * PUMX_GETEXTENDEDERRORSTRINGA)( VOID );

typedef VOID (PASCAL * PUMX_UNLOADMENU)( VOID );

typedef VOID (PASCAL * PUMX_INITIALIZEMENU)( VOID );

typedef VOID (PASCAL * PUMX_REFRESH)( HWND hwndParent );

typedef VOID (PASCAL * PUMX_MENUACTION)( HWND  hwndParent,
                                         DWORD dwEventId );

typedef VOID (PASCAL * PUMX_CREATEW)( HWND hwndParent,
                                      PUMS_GETSELW pumsSelection );
typedef VOID (PASCAL * PUMX_CREATEA)( HWND hwndParent,
                                      PUMS_GETSELA pumsSelection );

typedef VOID (PASCAL * PUMX_DELETEW)( HWND hwndParent,
                                      PUMS_GETSELW pumsSelection );
typedef VOID (PASCAL * PUMX_DELETEA)( HWND hwndParent,
                                      PUMS_GETSELA pumsSelection );

typedef VOID (PASCAL * PUMX_RENAMEW)( HWND hwndParent,
                                      PUMS_GETSELW pumsSelection,
                                      LPWSTR       pchNewName    );
typedef VOID (PASCAL * PUMX_RENAMEA)( HWND hwndParent,
                                      PUMS_GETSELA pumsSelection,
                                      LPSTR        pchNewName    );


#ifdef  UNICODE
#define PUMX_LOADMENU                   PUMX_LOADMENUW
#define PUMX_GETEXTENDEDERRORSTRING     PUMX_GETEXTENDEDERRORSTRINGW
#define PUMX_CREATE                     PUMX_CREATEW
#define PUMX_DELETE                     PUMX_DELETEW
#define PUMX_RENAME                     PUMX_RENAMEW
#else   // !UNICODE
#define PUMX_LOADMENU                   PUMX_LOADMENUA
#define PUMX_GETEXTENDEDERRORSTRING     PUMX_GETEXTENDEDERRORSTRINGA
#define PUMX_CREATE                     PUMX_CREATEA
#define PUMX_DELETE                     PUMX_DELETEA
#define PUMX_RENAME                     PUMX_RENAMEA
#endif  // UNICODE



//
//  Prototypes for the extension entrypoints.
//

DWORD PASCAL UMELoadMenuA( HWND           hwndMessage,
                           PUMS_LOADMENUA pumsload );

DWORD PASCAL UMELoadMenuW( HWND           hwndMessage,
                           PUMS_LOADMENUW pumsload );

LPSTR  PASCAL UMEGetExtendedErrorStringA( VOID );

LPWSTR PASCAL UMEGetExtendedErrorStringW( VOID );

VOID PASCAL UMEUnloadMenu( VOID );

VOID PASCAL UMEInitializeMenu( VOID );

VOID PASCAL UMERefresh( HWND hwndParent );

VOID PASCAL UMEMenuAction( HWND hwndParent,
                           DWORD dwEventId );

VOID PASCAL UMECreateA( HWND hwndParent,
                        PUMS_GETSELA pumsSelection );
VOID PASCAL UMECreateW( HWND hwndParent,
                        PUMS_GETSELW pumsSelection );

VOID PASCAL UMEDeleteA( HWND hwndParent,
                        PUMS_GETSELA pumsSelection );
VOID PASCAL UMEDeleteW( HWND hwndParent,
                        PUMS_GETSELW pumsSelection );

VOID PASCAL UMERenameA( HWND hwndParent,
                        PUMS_GETSELA pumsSelection,
                        LPSTR pchNewName );
VOID PASCAL UMERenameW( HWND hwndParent,
                        PUMS_GETSELW pumsSelection,
                        LPWSTR pchNewName );


#endif  // _UMX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\vcpphelp.h ===
//  BUGBUG:  This helper file makes VC++ work with its standard includes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\winnet.h ===
/*
 *	Windows/Network Interface
 *	Copyright (C) Microsoft 1989
 *
 *	Standard WINNET Driver Header File, spec version 3.10
 *						 rev. 3.10.05 ;Internal
 */


typedef WORD far * LPWORD;


/*
 *	SPOOLING - CONTROLLING JOBS
 */

#define WNJ_NULL_JOBID  0


WORD FAR PASCAL WNetOpenJob(LPSTR,LPSTR,WORD,LPINT);
WORD FAR PASCAL WNetCloseJob(WORD,LPINT,LPSTR);
WORD FAR PASCAL WNetWriteJob(HANDLE,LPSTR,LPINT);
WORD FAR PASCAL WNetAbortJob(WORD,LPSTR);
WORD FAR PASCAL WNetHoldJob(LPSTR,WORD);
WORD FAR PASCAL WNetReleaseJob(LPSTR,WORD);
WORD FAR PASCAL WNetCancelJob(LPSTR,WORD);
WORD FAR PASCAL WNetSetJobCopies(LPSTR,WORD,WORD);

/*
 *	SPOOLING - QUEUE AND JOB INFO
 */

typedef struct _queuestruct	{
	WORD	pqName;
	WORD	pqComment;
	WORD	pqStatus;
	WORD	pqJobcount;
	WORD	pqPrinters;
} QUEUESTRUCT;

typedef QUEUESTRUCT far * LPQUEUESTRUCT;

#define WNPRQ_ACTIVE	0x0
#define WNPRQ_PAUSE	0x1
#define WNPRQ_ERROR	0x2
#define WNPRQ_PENDING	0x3
#define WNPRQ_PROBLEM	0x4


typedef struct _jobstruct 	{
	WORD	pjId;
	WORD	pjUsername;
	WORD	pjParms;
	WORD	pjPosition;
	WORD	pjStatus;
	DWORD	pjSubmitted;
	DWORD	pjSize;
	WORD	pjCopies;
	WORD	pjComment;
} JOBSTRUCT;

typedef JOBSTRUCT far * LPJOBSTRUCT;

#define WNPRJ_QSTATUS		0x0007
#define  WNPRJ_QS_QUEUED		0x0000
#define  WNPRJ_QS_PAUSED		0x0001
#define  WNPRJ_QS_SPOOLING		0x0002
#define  WNPRJ_QS_PRINTING		0x0003
#define WNPRJ_DEVSTATUS 	0x0FF8
#define  WNPRJ_DS_COMPLETE		0x0008
#define  WNPRJ_DS_INTERV		0x0010
#define  WNPRJ_DS_ERROR 		0x0020
#define  WNPRJ_DS_DESTOFFLINE		0x0040
#define  WNPRJ_DS_DESTPAUSED		0x0080
#define  WNPRJ_DS_NOTIFY		0x0100
#define  WNPRJ_DS_DESTNOPAPER		0x0200
#define  WNPRJ_DS_DESTFORMCHG		0x0400
#define  WNPRJ_DS_DESTCRTCHG		0x0800
#define  WNPRJ_DS_DESTPENCHG  		0x1000

#define SP_QUEUECHANGED 	0x0500


WORD FAR PASCAL WNetWatchQueue(HWND,LPSTR,LPSTR,WORD);
WORD FAR PASCAL WNetUnwatchQueue(LPSTR);
WORD FAR PASCAL WNetLockQueueData(LPSTR,LPSTR,LPQUEUESTRUCT FAR *);
WORD FAR PASCAL WNetUnlockQueueData(LPSTR);


/*
 *	CONNECTIONS
 */

WORD FAR PASCAL WNetAddConnection(LPSTR,LPSTR,LPSTR);
WORD FAR PASCAL WNetCancelConnection(LPSTR,BOOL);
WORD FAR PASCAL WNetGetConnection(LPSTR,LPSTR,LPWORD);
WORD FAR PASCAL WNetRestoreConnection(HWND,LPSTR);

/*
 *	CAPABILITIES
 */

#define WNNC_SPEC_VERSION		0x0001

#define WNNC_NET_TYPE			0x0002
#define  WNNC_NET_NONE				0x0000
#define  WNNC_NET_MSNet 			0x0100
#define  WNNC_NET_LanMan			0x0200
#define  WNNC_NET_NetWare			0x0300
#define  WNNC_NET_Vines 			0x0400

#define WNNC_DRIVER_VERSION		0x0003

#define WNNC_USER			0x0004
#define  WNNC_USR_GetUser			0x0001

#define WNNC_CONNECTION 		0x0006
#define  WNNC_CON_AddConnection 		0x0001
#define  WNNC_CON_CancelConnection		0x0002
#define  WNNC_CON_GetConnections		0x0004
#define  WNNC_CON_AutoConnect			0x0008
#define  WNNC_CON_BrowseDialog			0x0010
#define  WNNC_CON_RestoreConnection		0x0020

#define WNNC_PRINTING			0x0007
#define  WNNC_PRT_OpenJob			0x0002
#define  WNNC_PRT_CloseJob			0x0004
#define  WNNC_PRT_HoldJob			0x0010
#define  WNNC_PRT_ReleaseJob			0x0020
#define  WNNC_PRT_CancelJob			0x0040
#define  WNNC_PRT_SetJobCopies			0x0080
#define  WNNC_PRT_WatchQueue			0x0100
#define  WNNC_PRT_UnwatchQueue			0x0200
#define  WNNC_PRT_LockQueueData 		0x0400
#define  WNNC_PRT_UnlockQueueData		0x0800
#define  WNNC_PRT_ChangeMsg			0x1000
#define  WNNC_PRT_AbortJob			0x2000
#define  WNNC_PRT_NoArbitraryLock		0x4000
#define  WNNC_PRT_WriteJob			0x8000

#define WNNC_DIALOG			0x0008
#define  WNNC_DLG_DeviceMode			0x0001
#define  WNNC_DLG_BrowseDialog			0x0002
#define  WNNC_DLG_ConnectDialog 		0x0004
#define  WNNC_DLG_DisconnectDialog		0x0008
#define  WNNC_DLG_ViewQueueDialog		0x0010
#define  WNNC_DLG_PropertyDialog		0x0020
#define  WNNC_DLG_ConnectionDialog		0x0040

#define WNNC_ADMIN			0x0009
#define  WNNC_ADM_GetDirectoryType		0x0001
#define  WNNC_ADM_DirectoryNotify		0x0002
#define  WNNC_ADM_LongNames			0x0004

#define WNNC_ERROR			0x000A
#define  WNNC_ERR_GetError			0x0001
#define  WNNC_ERR_GetErrorText			0x0002


WORD FAR PASCAL WNetGetCaps(WORD);

/*
 *	OTHER
 */

WORD FAR PASCAL WNetGetUser(LPSTR,LPINT);

/*
 *	BROWSE DIALOG
 */

#define WNBD_CONN_UNKNOWN	0x0
#define WNBD_CONN_DISKTREE	0x1
#define WNBD_CONN_PRINTQ	0x3
#define WNBD_MAX_LENGTH		0x80	// path length, includes the NULL

#define WNTYPE_DRIVE		1
#define WNTYPE_FILE		2
#define WNTYPE_PRINTER		3
#define WNTYPE_COMM		4

#define WNPS_FILE		0
#define WNPS_DIR		1
#define WNPS_MULT		2

WORD FAR PASCAL WNetDeviceMode(HWND);
WORD FAR PASCAL WNetBrowseDialog(HWND,WORD,LPSTR);
WORD FAR PASCAL WNetConnectDialog(HWND,WORD);
WORD FAR PASCAL WNetDisconnectDialog(HWND,WORD);
WORD FAR PASCAL WNetConnectionDialog(HWND,WORD);
WORD FAR PASCAL WNetViewQueueDialog(HWND,LPSTR);
WORD FAR PASCAL WNetPropertyDialog(HWND hwndParent, WORD iButton, WORD nPropSel, LPSTR lpszName, WORD nType);
WORD FAR PASCAL WNetGetPropertyText(WORD iButton, WORD nPropSel, LPSTR lpszName, LPSTR lpszButtonName, WORD cbButtonName, WORD nType);

/*
 *	ADMIN
 */

#define WNDT_NORMAL   0
#define WNDT_NETWORK  1

#define WNDN_MKDIR  1
#define WNDN_RMDIR  2
#define WNDN_MVDIR  3

WORD FAR PASCAL WNetGetDirectoryType(LPSTR,LPINT);
WORD FAR PASCAL WNetDirectoryNotify(HWND,LPSTR,WORD);

/*
 *	ERRORS
 */

WORD FAR PASCAL WNetGetError(LPINT);
WORD FAR PASCAL WNetGetErrorText(WORD,LPSTR,LPINT);


/*
 *	STATUS CODES
 */

/* General */

#define WN_SUCCESS			0x0000
#define WN_NOT_SUPPORTED		0x0001
#define WN_NET_ERROR			0x0002
#define WN_MORE_DATA			0x0003
#define WN_BAD_POINTER			0x0004
#define WN_BAD_VALUE			0x0005
#define WN_BAD_PASSWORD 		0x0006
#define WN_ACCESS_DENIED		0x0007
#define WN_FUNCTION_BUSY		0x0008
#define WN_WINDOWS_ERROR		0x0009
#define WN_BAD_USER			0x000A
#define WN_OUT_OF_MEMORY		0x000B
#define WN_CANCEL			0x000C
#define WN_CONTINUE			0x000D

/* Connection */

#define WN_NOT_CONNECTED		0x0030
#define WN_OPEN_FILES			0x0031
#define WN_BAD_NETNAME			0x0032
#define WN_BAD_LOCALNAME		0x0033
#define WN_ALREADY_CONNECTED		0x0034
#define WN_DEVICE_ERROR 		0x0035
#define WN_CONNECTION_CLOSED		0x0036

/* Printing */

#define WN_BAD_JOBID			0x0040
#define WN_JOB_NOT_FOUND		0x0041
#define WN_JOB_NOT_HELD 		0x0042
#define WN_BAD_QUEUE			0x0043
#define WN_BAD_FILE_HANDLE		0x0044
#define WN_CANT_SET_COPIES		0x0045
#define WN_ALREADY_LOCKED		0x0046

#define WN_NO_ERROR			0x0050

/* stuff in user, not driver, for shell apps ;Internal */
WORD FAR PASCAL WNetErrorText(WORD,LPSTR,WORD); /* ;Internal */

#ifdef LFN

/* this is the data structure returned from LFNFindFirst and
 * LFNFindNext.  The last field, achName, is variable length.  The size
 * of the name in that field is given by cchName, plus 1 for the zero
 * terminator.
 */
typedef struct _filefindbuf2
  {
    WORD fdateCreation;
    WORD ftimeCreation;
    WORD fdateLastAccess;
    WORD ftimeLastAccess;
    WORD fdateLastWrite;
    WORD ftimeLastWrite;
    DWORD cbFile;
    DWORD cbFileAlloc;
    WORD attr;
    DWORD cbList;
    BYTE cchName;
    BYTE achName[1];
  } FILEFINDBUF2, FAR * PFILEFINDBUF2;

typedef BOOL (FAR PASCAL *PQUERYPROC)( void );

WORD FAR PASCAL LFNFindFirst(LPSTR,WORD,LPINT,LPINT,WORD,PFILEFINDBUF2);
WORD FAR PASCAL LFNFindNext(HANDLE,LPINT,WORD,PFILEFINDBUF2);
WORD FAR PASCAL LFNFindClose(HANDLE);
WORD FAR PASCAL LFNGetAttribute(LPSTR,LPINT);
WORD FAR PASCAL LFNSetAttribute(LPSTR,WORD);
WORD FAR PASCAL LFNCopy(LPSTR,LPSTR,PQUERYPROC);
WORD FAR PASCAL LFNMove(LPSTR,LPSTR);
WORD FAR PASCAL LFNDelete(LPSTR);
WORD FAR PASCAL LFNMKDir(LPSTR);
WORD FAR PASCAL LFNRMDir(LPSTR);
WORD FAR PASCAL LFNGetVolumeLabel(WORD,LPSTR);
WORD FAR PASCAL LFNSetVolumeLabel(WORD,LPSTR);
WORD FAR PASCAL LFNParse(LPSTR,LPSTR,LPSTR);
WORD FAR PASCAL LFNVolumeType(WORD,LPINT);

/* return values from LFNParse
 */
#define FILE_83_CI		0
#define FILE_83_CS		1
#define FILE_LONG		2

/* volumes types from LFNVolumeType
 */
#define VOLUME_STANDARD 	0
#define VOLUME_LONGNAMES	1

/* error code return values
 */
#define ERROR_SUCCESS		0

// will add others later, == DOS int 21h error codes.

// this error code causes a call to WNetGetError, WNetGetErrorText
// to get the error text.
#define ERROR_NETWORKSPECIFIC	0xFFFF

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\hack\npwnet.h ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    npwnet.h
	define the mapping between WNetXXX and NPXXX

    FILE HISTORY:
	terryk	11-Nov-91	Created
	terryk	10-Dec-91	Added WNetAddConnection2
	terryk	03-Jan-92	Remove GetError and GetErrorText

*/

#undef     WNetOpenJob
#undef     WNetCloseJob
#undef     WNetAbortJob
#undef     WNetHoldJob
#undef     WNetReleaseJob
#undef     WNetCancelJob
#undef     WNetSetjobCopies
#undef     WNetWatchQueue
#undef     WNetUnwatchQueue
#undef     WNetLockQueueData
#undef     WNetUnlockQueueData
#undef     WNetGetConnection
#undef     WNetGetCaps
#undef     WNetDeviceMode
#undef     WNetBrowseDialog
#undef     WNetGetUser
#undef     WNetAddConnection2
#undef     WNetAddConnection
#undef     WNetCancelConnection
#undef     WNetRestoreConnection
#undef     WNetConnectDialog
#undef     WNetDisconnectDialog
#undef     WNetConnectionDialog
#undef     WNetPropertyDialog
#undef     WNetGetDirectoryType
#undef     WNetDirectoryNotify
#undef     WNetGetPropertyText
#undef	    WNetOpenEnum
#undef	    WNetEnumResource
#undef     WNetCloseEnum
#undef     WNetGetHackText

#define     WNetOpenJob               NPOpenJob              
#define     WNetCloseJob              NPCloseJob             
#define     WNetAbortJob              NPAbortJob             
#define     WNetHoldJob               NPHoldJob              
#define     WNetReleaseJob            NPReleaseJob           
#define     WNetCancelJob             NPCancelJob            
#define     WNetSetjobCopies          NPSetjobCopies         
#define     WNetWatchQueue            NPWatchQueue           
#define     WNetUnwatchQueue          NPUnwatchQueue         
#define     WNetLockQueueData         NPLockQueueData        
#define     WNetUnlockQueueData       NPUnlockQueueData      
#define     WNetGetConnection         NPGetConnection        
#define     WNetGetCaps               NPGetCaps              
#define     WNetDeviceMode            NPDeviceMode           
#define     WNetBrowseDialog          NPBrowseDialog         
#define     WNetGetUser               NPGetUser              
#define     WNetAddConnection2        NPAddConnection2        
#define     WNetAddConnection         NPAddConnection        
#define     WNetCancelConnection      NPCancelConnection     
#define     WNetRestoreConnection     NPRestoreConnection    
#define     WNetConnectDialog	      NPConnectDialog	     
#define     WNetDisconnectDialog      NPDisconnectDialog     
#define     WNetConnectionDialog      NPConnectionDialog     
#define     WNetPropertyDialog	      NPPropertyDialog	     
#define     WNetGetDirectoryType      NPGetDirectoryType     
#define     WNetDirectoryNotify       NPDirectoryNotify      
#define     WNetGetPropertyText       NPGetPropertyText      
#define	    WNetOpenEnum	      NPOpenEnum	     
#define	    WNetEnumResource	      NPEnumResource	     
#define     WNetCloseEnum	      NPCloseEnum	     
#define	    WNetGetHackText	      NPGetHackText


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\hack\mprerr.h ===
/**********************************************************************/
/**			  Microsoft Windows NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    wnerr.hxx
	Functions prototype for WNetGetError and WNetGetErrorText.

	This is a temporary file. It will be deleted after MPR layer is
	completed.

    FILE HISTORY:
	terryk	03-Jan-1991	Created

*/

#ifndef	_MPRERR_H_
#define	_MPRERR_H_

UINT FAR PASCAL WNetGetError(LPUINT);
UINT FAR PASCAL WNetGetErrorText(UINT,LPSTR,LPUINT);

#endif	// _MPRERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\hack\mprwnet.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    mprwnet.h
    This is a temporary file for MPR layer. It should be deleted
    after the layer is completed.

    FILE HISTORY:
        terryk          03-Jan-1992     Created
        beng            02-Apr-1992     Unicode fixes

*/

#ifndef _MPRWNET_H_
#define _MPRWNET_H_

UINT FAR PASCAL WNetGetCaps(UINT);
UINT FAR PASCAL WNetBrowseDialog(HWND,UINT,LPTSTR);
UINT FAR PASCAL WNetDisconnectDialog(HWND,UINT);
UINT FAR PASCAL WNetConnectDialog(HWND,UINT);
UINT FAR PASCAL WNetPropertyDialog(HWND hwndParent, UINT iButton, UINT nPropSel, LPTSTR lpszName, UINT nType);
UINT FAR PASCAL WNetGetPropertyText(UINT iButton, UINT nPropSel, LPTSTR lpszName, LPTSTR lpszButtonName, UINT cbButtonName, UINT nType);

#endif  // _MPRWNET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\wnet16.h ===
/********************************************************/
/*               Microsoft Windows NT                   */
/*       Copyright(c) Microsoft Corp., 1990, 1991       */
/********************************************************/

/*
 * uimsg.h
 *
 * Defines the prototypes for misc functions in mprui.dll and
 * ntlanman.dll used to support the thunked 16bit wfwnet.drv.
 *
 * Note that all prototypes here end with A0. The A denotes ANSI,
 * as opposed to Unicode while the 0 means its even before 1 (since
 * this is for WFW support.
 *
 * FILE HISTORY:
 *      ChuckC (Chuck Y Chan)    3/28/93       Created
 */

#ifndef _WNET16_H_
#define _WNET16_H_

#include <mpr.h>

#ifdef __cplusplus
extern "C" {
#endif

DWORD ServerBrowseDialogA0(
    HWND    hwnd,
    CHAR   *pchBuffer,
    DWORD   cchBufSize) ;

DWORD BrowseDialogA0(
    HWND    hwnd,
    DWORD   nType,
    CHAR   *pszName,
    DWORD   cchBufSize) ;

DWORD ShareAsDialogA0(
    HWND    hwnd,
    DWORD   nType,
    CHAR    *pszPath) ;

DWORD StopShareDialogA0(
    HWND    hwnd,
    DWORD   nType,
    CHAR    *pszPath) ;

DWORD RestoreConnectionA0(
    HWND    hwnd,
    CHAR    *pszName) ;

#ifdef __cplusplus
}
#endif

#endif  // _WNET16_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\wnet1632.h ===
/**********************************************************************/
/**			  Microsoft Windows NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    WNet1632.h

    This file allows WNet clients to be singled sourced for Win16 and Win32.

    FILE HISTORY:
	Johnl	30-Oct-1991	Created
	terryk	07-Nov-1991	undef WNetGetUser
	terryk	18-Nov-1991	add npwnet.h 
	terryk	03-Jan-1992	MPR conversion
	terryk	06-Jan-1992	add mprwnet.h mprerr.h

*/

#ifndef _WNET1632_H_
#define _WNET1632_H_

#ifndef WIN32
/* The following make the Winnet32.h NT-ese friendly to our 16 bit friends.
 */
    #define IN
    #define OUT
    #define LPTSTR   LPSTR

    /* Include the 16 bit winnet driver, note that we have hacked out all of
     * the functionality between this file and Winnet32.h.
     */
    #include <winnet16.h>

    // not in winnet32.h
    /*  This manifest existed in winnet.h but not in winnet32.h and 
	npapi.h.
    */

#endif

// This will cover up the WNetCloseEnum in winnet32.h and use the 
// one in npapi.h
#define	WNetCloseEnum		DWORDWNetCloseEnum
#define	WNetConnectionDialog	DWORDWNetConnectionDialog
#include <winnetwk.h>
#undef WNetCloseEnum
#undef WNetConnectionDialog

// include the npapi.h
#define	LPDWORD	PUINT
#define	DWORD	UINT
#ifdef WIN32
    #define LPUINT	PUINT
    #include <npwnet.h>
    #include <npapi.h>
#else
    #undef 	WNetAddConnection
    #undef 	WNetAddConnection2
    #undef 	WNetCancelConnection
    #undef 	WNetGetConnection
    #undef 	WNetOpenEnum
    #undef 	WNetEnumResource
    #undef 	WNetGetUser
    #undef 	WNetGetLastError

    #include	<mprerr.h>
    #include	<mprwnet.h>

    // 16 bits version
    #define     NPGetConnection         WNetGetConnection        
    #define     NPGetCaps               WNetGetCaps              
    #define     NPDeviceMode            WNetDeviceMode           
    //#define     NPGetUser               WNetGetUser              
    //#define     NPAddConnection         WNetAddConnection        
    #define     NPCancelConnection      WNetCancelConnection     
    #define     NPPropertyDialog	WNetPropertyDialog	     
    #define     NPGetDirectoryType      WNetGetDirectoryType     
    #define     NPDirectoryNotify       WNetDirectoryNotify      
    #define     NPGetPropertyText       WNetGetPropertyText      
    #define	NPOpenEnum	      	WNetOpenEnum	     
    #define	NPEnumResource	  	WNetEnumResource	     
    #define     NPCloseEnum	        WNetCloseEnum	     
    #include <npapi.h>

    // Use the old WNetAddConnection conversion
    UINT APIENTRY WNetAddConnection( LPSTR, LPSTR, LPSTR );
    UINT APIENTRY WNetRestoreConnection( HWND, LPSTR );
    // Skip the DWORD WNetConnectionDialog in winnet32.h
    UINT APIENTRY WNetConnectionDialog( HWND, UINT );
#endif
#undef	DWORD
#undef	LPDWORD

#ifndef WIN32
    #undef WNetGetUser
    /* There are error codes the Win32 network driver supports that the
     * Win16 driver doesn't
     */
    #undef  WN_NO_NETWORK
    #undef  WN_NO_NET_OR_BAD_PATH

    /* The following are defined in both
     */
    //#undef  WN_BAD_HANDLE
    //#undef  WN_NO_MORE_ENTRIES
#endif

#endif // _WNET1632_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\hack\os2def.h ===
// do not edit: generated from system headerfile

// basic type and macro definitions elided; see lmuitype.h
#ifndef NOBASICTYPES

/***************************************************************************\
*
* Module Name: OS2DEF.H
*
* OS/2 Common Definitions file
*
* Copyright (c) 1987-1990, Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/

#define OS2DEF_INCLUDED

/* XLATOFF */
#define PASCAL	pascal
#define FAR	far
#define NEAR	near
#define VOID	void
/* XLATON */

typedef unsigned short SHANDLE;
typedef void far      *LHANDLE;

/* XLATOFF */
#define EXPENTRY pascal far _loadds
#define APIENTRY pascal far

/* Backwards compatability with 1.1 */
#define CALLBACK pascal far _loadds

#define CHAR	char		/* ch  */
#define SHORT	short		/* s   */
#define LONG	long		/* l   */
#ifndef INCL_SAADEFS
#define INT	int		/* i   */
#endif /* !INCL_SAADEFS */
/* XLATON */

typedef unsigned char UCHAR;	/* uch */
typedef unsigned short USHORT;	/* us  */
typedef unsigned long ULONG;	/* ul  */
#ifndef INCL_SAADEFS
typedef unsigned int  UINT;	/* ui  */
#endif /* !INCL_SAADEFS */

typedef unsigned char BYTE;	/* b   */

/* define NULL pointer value */
/* Echo the format of the ifdefs that stdio.h uses */

#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#else
#if (defined(M_I86L) || defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))
#define  NULL	 0L
#else
#define  NULL	 0
#endif
#endif

typedef SHANDLE HFILE;		/* hf */
typedef HFILE far *PHFILE;

typedef unsigned char far  *PSZ;
typedef unsigned char near *NPSZ;

typedef unsigned char far  *PCH;
typedef unsigned char near *NPCH;

typedef int   (pascal far  *PFN)();
typedef int   (pascal near *NPFN)();
typedef PFN far *PPFN;

typedef BYTE   FAR  *PBYTE;
typedef BYTE   near *NPBYTE;

typedef CHAR   FAR *PCHAR;
typedef SHORT  FAR *PSHORT;
typedef LONG   FAR *PLONG;
#ifndef INCL_SAADEFS
typedef INT    FAR *PINT;
#endif /* !INCL_SAADEFS */

typedef UCHAR  FAR *PUCHAR;
typedef USHORT FAR *PUSHORT;
typedef ULONG  FAR *PULONG;
#ifndef INCL_SAADEFS
typedef UINT   FAR *PUINT;
#endif /* !INCL_SAADEFS */

typedef VOID   FAR *PVOID;

typedef unsigned short BOOL;	/* f   */
typedef BOOL FAR *PBOOL;

#ifndef TRUE
#define TRUE    1
#endif

#ifndef FALSE
#define FALSE   0
#endif

#ifndef INCL_SAADEFS
typedef unsigned short SEL;	/* sel */
typedef SEL FAR *PSEL;

/*** Useful Helper Macros */

/* Create untyped far pointer from selector and offset */
#define MAKEP(sel, off) 	((PVOID)MAKEULONG(off, sel))

/* Extract selector or offset from far pointer */
#define SELECTOROF(p)		(((PUSHORT)&(p))[1])
#define OFFSETOF(p)		(((PUSHORT)&(p))[0])
#endif  /* !INCL_SAADEFS */

/* Cast any variable to an instance of the specified type. */
#define MAKETYPE(v, type)	(*((type far *)&v))

/* Calculate the byte offset of a field in a structure of type type. */
#define FIELDOFFSET(type, field)    ((SHORT)&(((type *)0)->field))

/* Combine l & h to form a 32 bit quantity. */
#define MAKEULONG(l, h) ((ULONG)(((USHORT)(l)) | ((ULONG)((USHORT)(h))) << 16))
#define MAKELONG(l, h)	((LONG)MAKEULONG(l, h))

/* Combine l & h to form a 16 bit quantity. */
#define MAKEUSHORT(l, h) (((USHORT)(l)) | ((USHORT)(h)) << 8)
#define MAKESHORT(l, h)  ((SHORT)MAKEUSHORT(l, h))

/* Extract high and low order parts of 16 and 32 bit quantity */
#define LOBYTE(w)	LOUCHAR(w)
#define HIBYTE(w)	HIUCHAR(w)
#define LOUCHAR(w)	((UCHAR)(USHORT)(w))
#define HIUCHAR(w)	((UCHAR)(((USHORT)(w) >> 8) & 0xff))
#define LOUSHORT(l)	((USHORT)(ULONG)(l))
#define HIUSHORT(l)	((USHORT)(((ULONG)(l) >> 16) & 0xffff))

#endif // NOBASICTYPES
/*** Common Error definitions ****/

typedef ULONG ERRORID;	/* errid */
typedef ERRORID FAR *PERRORID;

/* Combine severity and error code to produce ERRORID */
#define MAKEERRORID(sev, error) (ERRORID)(MAKEULONG((error), (sev)))
/* Extract error number from an errorid */
#define ERRORIDERROR(errid)	       (LOUSHORT(errid))
/* Extract severity from an errorid */
#define ERRORIDSEV(errid)	       (HIUSHORT(errid))

/* Severity codes */
#define SEVERITY_NOERROR	0x0000
#define SEVERITY_WARNING	0x0004
#define SEVERITY_ERROR		0x0008
#define SEVERITY_SEVERE 	0x000C
#define SEVERITY_UNRECOVERABLE	0x0010

/* Base component error values */

#define WINERR_BASE		0x1000	/* Window Manager		   */
#define GPIERR_BASE		0x2000	/* Graphics Presentation Interface */
#define DEVERR_BASE		0x3000	/* Device Manager		   */
#define SPLERR_BASE		0x4000	/* Spooler			   */

/*** Common types used across components */

/*** Common DOS types */

typedef USHORT	  HMODULE;	/* hmod */
typedef HMODULE FAR *PHMODULE;

#ifndef INCL_SAADEFS
typedef USHORT	  PID;		/* pid	*/
typedef PID FAR *PPID;

typedef USHORT	  TID;		/* tid	*/
typedef TID FAR *PTID;

typedef VOID FAR *HSEM; 	/* hsem */
typedef HSEM FAR *PHSEM;
#endif  /* !INCL_SAADEFS */

/*** Common SUP types */

typedef LHANDLE   HAB;		/* hab	*/
typedef HAB FAR *PHAB;

/*** Common GPI/DEV types */

typedef LHANDLE   HPS;		/* hps	*/
typedef HPS FAR *PHPS;

typedef LHANDLE   HDC;		/* hdc	*/
typedef HDC FAR *PHDC;

typedef LHANDLE   HRGN; 	/* hrgn */
typedef HRGN FAR *PHRGN;

typedef LHANDLE   HBITMAP;	/* hbm	*/
typedef HBITMAP FAR *PHBITMAP;

typedef LHANDLE   HMF;		/* hmf	*/
typedef HMF FAR *PHMF;

typedef LONG	 COLOR; 	/* clr	*/
typedef COLOR FAR *PCOLOR;

typedef struct _POINTL {	/* ptl	*/
	LONG	x;
	LONG	y;
} POINTL;
typedef POINTL  FAR  *PPOINTL;
typedef POINTL  near *NPPOINTL;

typedef struct _POINTS {	/* pts */
	SHORT	x;
	SHORT	y;
} POINTS;
typedef POINTS FAR *PPOINTS;

typedef struct _RECTL { 	/* rcl */
	LONG	xLeft;
	LONG	yBottom;
	LONG	xRight;
	LONG	yTop;
} RECTL;
typedef RECTL FAR  *PRECTL;
typedef RECTL near *NPRECTL;

typedef CHAR STR8[8];		/* str8 */
typedef STR8 FAR *PSTR8;

/*** common DEV/SPL types */

/* structure for Device Driver data */

typedef struct _DRIVDATA {	/* driv */
	LONG	cb;
	LONG	lVersion;
	CHAR	szDeviceName[32];
	CHAR	abGeneralData[1];
} DRIVDATA;
typedef DRIVDATA far *PDRIVDATA;

/* array indices for array parameter for DevOpenDC, SplQmOpen or SplQpOpen */

#define ADDRESS 	0
#ifndef INCL_SAADEFS
#define DRIVER_NAME	1
#define DRIVER_DATA	2
#define DATA_TYPE	3
#define COMMENT 	4
#define PROC_NAME	5
#define PROC_PARAMS	6
#define SPL_PARAMS	7
#define NETWORK_PARAMS	8
#endif  /* !INCL_SAADEFS */

/* structure definition as an alternative of the array parameter */

typedef struct _DEVOPENSTRUC { /* dop */
	PSZ	  pszLogAddress;
	PSZ	  pszDriverName;
	PDRIVDATA pdriv;
	PSZ	  pszDataType;
	PSZ	  pszComment;
	PSZ	  pszQueueProcName;
	PSZ	  pszQueueProcParams;
	PSZ	  pszSpoolerParams;
	PSZ	  pszNetworkParams;
} DEVOPENSTRUC;
typedef DEVOPENSTRUC FAR *PDEVOPENSTRUC;

/*** common AVIO/GPI types */

/* values of fsSelection field of FATTRS structure */
#define FATTR_SEL_ITALIC	0x0001
#define FATTR_SEL_UNDERSCORE	0x0002
#define FATTR_SEL_OUTLINE	0x0008		/* Hollow Outline Font */
#define FATTR_SEL_STRIKEOUT	0x0010
#define FATTR_SEL_BOLD		0x0020

/* values of fsType field of FATTRS structure */
#define FATTR_TYPE_KERNING	0x0004
#define FATTR_TYPE_MBCS 	0x0008
#define FATTR_TYPE_DBCS 	0x0010
#define FATTR_TYPE_ANTIALIASED	0x0020

/* values of fsFontUse field of FATTRS structure */
#define FATTR_FONTUSE_NOMIX         0x0002
#define FATTR_FONTUSE_OUTLINE       0x0004
#define FATTR_FONTUSE_TRANSFORMABLE 0x0008


/* size for fields in the font structures */

#define FACESIZE 32

/* font struct for Vio/GpiCreateLogFont */

typedef struct _FATTRS {	/* fat */
	USHORT	usRecordLength;
	USHORT	fsSelection;
	LONG	lMatch;
	CHAR	szFacename[FACESIZE];
	USHORT	idRegistry;
	USHORT	usCodePage;
	LONG	lMaxBaselineExt;
	LONG	lAveCharWidth;
	USHORT	fsType;
	USHORT	fsFontUse;
} FATTRS;
typedef FATTRS far *PFATTRS;

/* values of fsType field of FONTMETRICS structure */
#define FM_TYPE_FIXED		0x0001
#define FM_TYPE_LICENSED	0x0002
#define FM_TYPE_KERNING 	0x0004
#define FM_TYPE_DBCS		0x0010
#define FM_TYPE_MBCS		0x0018
#define FM_TYPE_64K		0x8000

/* values of fsDefn field of FONTMETRICS structure */
#define FM_DEFN_OUTLINE 	0x0001
#define FM_DEFN_GENERIC 	0x8000

/* values of fsSelection field of FONTMETRICS structure */
#define FM_SEL_ITALIC		0x0001
#define FM_SEL_UNDERSCORE	0x0002
#define FM_SEL_NEGATIVE 	0x0004
#define FM_SEL_OUTLINE		0x0008		/* Hollow Outline Font */
#define FM_SEL_STRIKEOUT	0x0010
#define FM_SEL_BOLD		0x0020

/* values of fsCapabilities field of FONTMETRICS structure */
#define FM_CAP_NOMIX		0x0001

/* font metrics returned by GpiQueryFonts and others */

typedef struct _FONTMETRICS {	/* fm */
	CHAR	szFamilyname[FACESIZE];
	CHAR	szFacename[FACESIZE];
	USHORT	idRegistry;
	USHORT	usCodePage;
	LONG	lEmHeight;
	LONG	lXHeight;
	LONG	lMaxAscender;
	LONG	lMaxDescender;
	LONG	lLowerCaseAscent;
	LONG	lLowerCaseDescent;
	LONG	lInternalLeading;
	LONG	lExternalLeading;
	LONG	lAveCharWidth;
	LONG	lMaxCharInc;
	LONG	lEmInc;
	LONG	lMaxBaselineExt;
	SHORT	sCharSlope;
	SHORT	sInlineDir;
	SHORT	sCharRot;
	USHORT	usWeightClass;
	USHORT	usWidthClass;
	SHORT	sXDeviceRes;
	SHORT	sYDeviceRes;
	SHORT	sFirstChar;
	SHORT	sLastChar;
	SHORT	sDefaultChar;
	SHORT	sBreakChar;
	SHORT	sNominalPointSize;
	SHORT	sMinimumPointSize;
	SHORT	sMaximumPointSize;
	USHORT	fsType;
	USHORT	fsDefn;
	USHORT	fsSelection;
	USHORT	fsCapabilities;
	LONG	lSubscriptXSize;
	LONG	lSubscriptYSize;
	LONG	lSubscriptXOffset;
	LONG	lSubscriptYOffset;
	LONG	lSuperscriptXSize;
	LONG	lSuperscriptYSize;
	LONG	lSuperscriptXOffset;
	LONG	lSuperscriptYOffset;
	LONG	lUnderscoreSize;
	LONG	lUnderscorePosition;
	LONG	lStrikeoutSize;
	LONG	lStrikeoutPosition;
	SHORT	sKerningPairs;
	SHORT	sFamilyClass;
	LONG	lMatch;
} FONTMETRICS;
typedef FONTMETRICS far *PFONTMETRICS;

/*** Common WIN types */

typedef LHANDLE HWND;		/* hwnd */
typedef HWND FAR *PHWND;

typedef struct _WRECT { 	/* wrc */
	SHORT	xLeft;
	SHORT	dummy1;
	SHORT	yBottom;
	SHORT	dummy2;
	SHORT	xRight;
	SHORT	dummy3;
	SHORT	yTop;
	SHORT	dummy4;
} WRECT;
typedef WRECT FAR *PWRECT;
typedef WRECT near *NPWRECT;

typedef struct _WPOINT {	/* wpt */
	SHORT	x;
	SHORT	dummy1;
	SHORT	y;
	SHORT	dummy2;
} WPOINT;
typedef WPOINT FAR *PWPOINT;
typedef WPOINT near *NPWPOINT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\h\wnintrn.h ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1990		     **/
/**********************************************************************/

#ifndef _WNINTRN_H_
#define _WNINTRN_H_

/*
    wnintrn.h
    LANMAN.DRV APIs for internal use only

    LANMAN.DRV implements a set of APIs defined in winnet.h, and exports
    these for use by the Windows Shell (File Manager, Print Manager
    etc.)  These APIs are standard between all network drivers.  However,
    there is also a range of ordinals reserved for internal use.
    These ordinals provide entry points to LANMAN.DRV which are used
    by other LanMan programs such as the logon application,
    the administrative tools, etc.  This header file provides
    prototypes for these internal APIs.



    I_AutoLogon

    Offers the user an opportunity to log on if not already logged on.
        Does nothing if user is already logged on.

    PARAMETERS:
    HWND hParent -- Parent window handle for the parent to the
	logon dialog.  NULL is acceptable if none is available.
    const char FAR *pszAppName -- Name of the application requesting
	the logon dialog, for use in constructing the dialog caption.
	NULL is acceptable here.
    BOOL fPrompt -- If TRUE and user is not logged on, logon dialog
	is preceded by a popup asking if the user wishes to log on.
	If FALSE and user is not logged on, we proceed straight to
	the logon dialog.
    BOOL FAR *pfLoggedOn -- TRUE is returned here if the user was logged on
	by I_AutoLogon.  This may be different from the return value,
	since *pfLoggedOn is FALSE if the user was already logged on.
	Pass pfLoggedOn==NULL if the caller doesn't care.

    RETURN VALUES:
    TRUE -- user is logged on when call completes, either because
	the user was already logged on, or because the user was
        logged on by this call.
    FALSE -- user is not logged on when call completes.


    I_ChangePassword

    Offers the user an "Change Password" dialog box, with which the user
    can change his/her own password, or someone else's.

    PARAMETERS:
    HWND hParent -- Parent window handle.

    FILE HISTORY:

    jonn	11-Feb-1991	Renamed from autolgon.hxx
				Merged in chpass.h
    jonn	30-Apr-1991	Added pszAppName parameter
    terryk	18-Nov-1991	Added I_SystemFocusDialog
    terryk	26-Nov-1991	Added comment
    JohnL	22-Apr-1992	Moved the system focus dialog out to uiexport.h

*/

#ifdef __cplusplus
extern "C" {
#endif

BOOL FAR PASCAL I_AutoLogon(
	HWND hParent,
	const TCHAR FAR *pszAppName,
	BOOL fPrompt,
	BOOL FAR *pfLoggedOn
	);

APIERR FAR PASCAL I_ChangePassword ( HWND hParent );

#ifdef __cplusplus
}
#endif

/* Include the I_SystemFocusDialog definition
 */

#include <uiexport.h>

#endif	//  _WNINTRN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\hack\winnet.h ===
// do not edit: generated from system headerfile


/*
 *	Windows/Network Interface
 *	Copyright (C) Microsoft 1989
 *
 *	Standard WINNET Driver Header File, spec version 3.10
 *						 rev. 3.10.05 ;Internal
 */


// basic type and macro definitions elided; see lmuitype.h
#ifndef NOBASICTYPES
typedef WORD far * LPWORD;
#endif // NOBASICTYPES


/*
 *	SPOOLING - CONTROLLING JOBS
 */

#define WNJ_NULL_JOBID  0


WORD FAR PASCAL WNetOpenJob(LPSTR,LPSTR,WORD,LPINT);
WORD FAR PASCAL WNetCloseJob(WORD,LPINT,LPSTR);
WORD FAR PASCAL WNetWriteJob(HANDLE,LPSTR,LPINT);
WORD FAR PASCAL WNetAbortJob(WORD,LPSTR);
WORD FAR PASCAL WNetHoldJob(LPSTR,WORD);
WORD FAR PASCAL WNetReleaseJob(LPSTR,WORD);
WORD FAR PASCAL WNetCancelJob(LPSTR,WORD);
WORD FAR PASCAL WNetSetJobCopies(LPSTR,WORD,WORD);

/*
 *	SPOOLING - QUEUE AND JOB INFO
 */

typedef struct _queuestruct	{
	WORD	pqName;
	WORD	pqComment;
	WORD	pqStatus;
	WORD	pqJobcount;
	WORD	pqPrinters;
} QUEUESTRUCT;

typedef QUEUESTRUCT far * LPQUEUESTRUCT;

#define WNPRQ_ACTIVE	0x0
#define WNPRQ_PAUSE	0x1
#define WNPRQ_ERROR	0x2
#define WNPRQ_PENDING	0x3
#define WNPRQ_PROBLEM	0x4


typedef struct _jobstruct 	{
	WORD	pjId;
	WORD	pjUsername;
	WORD	pjParms;
	WORD	pjPosition;
	WORD	pjStatus;
	DWORD	pjSubmitted;
	DWORD	pjSize;
	WORD	pjCopies;
	WORD	pjComment;
} JOBSTRUCT;

typedef JOBSTRUCT far * LPJOBSTRUCT;

#define WNPRJ_QSTATUS		0x0007
#define  WNPRJ_QS_QUEUED		0x0000
#define  WNPRJ_QS_PAUSED		0x0001
#define  WNPRJ_QS_SPOOLING		0x0002
#define  WNPRJ_QS_PRINTING		0x0003
#define WNPRJ_DEVSTATUS 	0x0FF8
#define  WNPRJ_DS_COMPLETE		0x0008
#define  WNPRJ_DS_INTERV		0x0010
#define  WNPRJ_DS_ERROR 		0x0020
#define  WNPRJ_DS_DESTOFFLINE		0x0040
#define  WNPRJ_DS_DESTPAUSED		0x0080
#define  WNPRJ_DS_NOTIFY		0x0100
#define  WNPRJ_DS_DESTNOPAPER		0x0200
#define  WNPRJ_DS_DESTFORMCHG		0x0400
#define  WNPRJ_DS_DESTCRTCHG		0x0800
#define  WNPRJ_DS_DESTPENCHG  		0x1000

#define SP_QUEUECHANGED 	0x0500


WORD FAR PASCAL WNetWatchQueue(HWND,LPSTR,LPSTR,WORD);
WORD FAR PASCAL WNetUnwatchQueue(LPSTR);
WORD FAR PASCAL WNetLockQueueData(LPSTR,LPSTR,LPQUEUESTRUCT FAR *);
WORD FAR PASCAL WNetUnlockQueueData(LPSTR);


/*
 *	CONNECTIONS
 */

WORD FAR PASCAL WNetAddConnection(LPSTR,LPSTR,LPSTR);
WORD FAR PASCAL WNetCancelConnection(LPSTR,BOOL);
WORD FAR PASCAL WNetGetConnection(LPSTR,LPSTR,LPWORD);
WORD FAR PASCAL WNetRestoreConnection(HWND,LPSTR);

/*
 *	CAPABILITIES
 */

#define WNNC_SPEC_VERSION		0x0001

#define WNNC_NET_TYPE			0x0002
#define  WNNC_NET_NONE				0x0000
#define  WNNC_NET_MSNet 			0x0100
#define  WNNC_NET_LanMan			0x0200
#define  WNNC_NET_NetWare			0x0300
#define  WNNC_NET_Vines 			0x0400

#define WNNC_DRIVER_VERSION		0x0003

#define WNNC_USER			0x0004
#define  WNNC_USR_GetUser			0x0001

#define WNNC_CONNECTION 		0x0006
#define  WNNC_CON_AddConnection 		0x0001
#define  WNNC_CON_CancelConnection		0x0002
#define  WNNC_CON_GetConnections		0x0004
#define  WNNC_CON_AutoConnect			0x0008
#define  WNNC_CON_BrowseDialog			0x0010
#define  WNNC_CON_RestoreConnection		0x0020

#define WNNC_PRINTING			0x0007
#define  WNNC_PRT_OpenJob			0x0002
#define  WNNC_PRT_CloseJob			0x0004
#define  WNNC_PRT_HoldJob			0x0010
#define  WNNC_PRT_ReleaseJob			0x0020
#define  WNNC_PRT_CancelJob			0x0040
#define  WNNC_PRT_SetJobCopies			0x0080
#define  WNNC_PRT_WatchQueue			0x0100
#define  WNNC_PRT_UnwatchQueue			0x0200
#define  WNNC_PRT_LockQueueData 		0x0400
#define  WNNC_PRT_UnlockQueueData		0x0800
#define  WNNC_PRT_ChangeMsg			0x1000
#define  WNNC_PRT_AbortJob			0x2000
#define  WNNC_PRT_NoArbitraryLock		0x4000
#define  WNNC_PRT_WriteJob			0x8000

#define WNNC_DIALOG			0x0008
#define  WNNC_DLG_DeviceMode			0x0001
#define  WNNC_DLG_BrowseDialog			0x0002
#define  WNNC_DLG_ConnectDialog 		0x0004
#define  WNNC_DLG_DisconnectDialog		0x0008
#define  WNNC_DLG_ViewQueueDialog		0x0010
#define  WNNC_DLG_PropertyDialog		0x0020
#define  WNNC_DLG_ConnectionDialog		0x0040

#define WNNC_ADMIN			0x0009
#define  WNNC_ADM_GetDirectoryType		0x0001
#define  WNNC_ADM_DirectoryNotify		0x0002
#define  WNNC_ADM_LongNames			0x0004

#define WNNC_ERROR			0x000A
#define  WNNC_ERR_GetError			0x0001
#define  WNNC_ERR_GetErrorText			0x0002


WORD FAR PASCAL WNetGetCaps(WORD);

/*
 *	OTHER
 */

WORD FAR PASCAL WNetGetUser(LPSTR,LPINT);

/*
 *	BROWSE DIALOG
 */

#define WNBD_CONN_UNKNOWN	0x0
#define WNBD_CONN_DISKTREE	0x1
#define WNBD_CONN_PRINTQ	0x3
#define WNBD_MAX_LENGTH		0x80	// path length, includes the NULL

#define WNTYPE_DRIVE		1
#define WNTYPE_FILE		2
#define WNTYPE_PRINTER		3
#define WNTYPE_COMM		4

#define WNPS_FILE		0
#define WNPS_DIR		1
#define WNPS_MULT		2

WORD FAR PASCAL WNetDeviceMode(HWND);
WORD FAR PASCAL WNetBrowseDialog(HWND,WORD,LPSTR);
WORD FAR PASCAL WNetConnectDialog(HWND,WORD);
WORD FAR PASCAL WNetDisconnectDialog(HWND,WORD);
WORD FAR PASCAL WNetConnectionDialog(HWND,WORD);
WORD FAR PASCAL WNetViewQueueDialog(HWND,LPSTR);
WORD FAR PASCAL WNetPropertyDialog(HWND hwndParent, WORD iButton, WORD nPropSel, LPSTR lpszName, WORD nType);
WORD FAR PASCAL WNetGetPropertyText(WORD iButton, WORD nPropSel, LPSTR lpszName, LPSTR lpszButtonName, WORD cbButtonName, WORD nType);

/*
 *	ADMIN
 */

#define WNDT_NORMAL   0
#define WNDT_NETWORK  1

#define WNDN_MKDIR  1
#define WNDN_RMDIR  2
#define WNDN_MVDIR  3

WORD FAR PASCAL WNetGetDirectoryType(LPSTR,LPINT);
WORD FAR PASCAL WNetDirectoryNotify(HWND,LPSTR,WORD);

/*
 *	ERRORS
 */

WORD FAR PASCAL WNetGetError(LPINT);
WORD FAR PASCAL WNetGetErrorText(WORD,LPSTR,LPINT);


/*
 *	STATUS CODES
 */

/* General */

#define WN_SUCCESS			0x0000
#define WN_NOT_SUPPORTED		0x0001
#define WN_NET_ERROR			0x0002
#define WN_MORE_DATA			0x0003
#define WN_BAD_POINTER			0x0004
#define WN_BAD_VALUE			0x0005
#define WN_BAD_PASSWORD 		0x0006
#define WN_ACCESS_DENIED		0x0007
#define WN_FUNCTION_BUSY		0x0008
#define WN_WINDOWS_ERROR		0x0009
#define WN_BAD_USER			0x000A
#define WN_OUT_OF_MEMORY		0x000B
#define WN_CANCEL			0x000C
#define WN_CONTINUE			0x000D

/* Connection */

#define WN_NOT_CONNECTED		0x0030
#define WN_OPEN_FILES			0x0031
#define WN_BAD_NETNAME			0x0032
#define WN_BAD_LOCALNAME		0x0033
#define WN_ALREADY_CONNECTED		0x0034
#define WN_DEVICE_ERROR 		0x0035
#define WN_CONNECTION_CLOSED		0x0036

/* Printing */

#define WN_BAD_JOBID			0x0040
#define WN_JOB_NOT_FOUND		0x0041
#define WN_JOB_NOT_HELD 		0x0042
#define WN_BAD_QUEUE			0x0043
#define WN_BAD_FILE_HANDLE		0x0044
#define WN_CANT_SET_COPIES		0x0045
#define WN_ALREADY_LOCKED		0x0046

#define WN_NO_ERROR			0x0050

/* stuff in user, not driver, for shell apps ;Internal */
WORD FAR PASCAL WNetErrorText(WORD,LPSTR,WORD); /* ;Internal */

#ifdef LFN

/* this is the data structure returned from LFNFindFirst and
 * LFNFindNext.  The last field, achName, is variable length.  The size
 * of the name in that field is given by cchName, plus 1 for the zero
 * terminator.
 */
typedef struct _filefindbuf2
  {
    WORD fdateCreation;
    WORD ftimeCreation;
    WORD fdateLastAccess;
    WORD ftimeLastAccess;
    WORD fdateLastWrite;
    WORD ftimeLastWrite;
    DWORD cbFile;
    DWORD cbFileAlloc;
    WORD attr;
    DWORD cbList;
    BYTE cchName;
    BYTE achName[1];
  } FILEFINDBUF2, FAR * PFILEFINDBUF2;

typedef BOOL (FAR PASCAL *PQUERYPROC)( void );

WORD FAR PASCAL LFNFindFirst(LPSTR,WORD,LPINT,LPINT,WORD,PFILEFINDBUF2);
WORD FAR PASCAL LFNFindNext(HANDLE,LPINT,WORD,PFILEFINDBUF2);
WORD FAR PASCAL LFNFindClose(HANDLE);
WORD FAR PASCAL LFNGetAttribute(LPSTR,LPINT);
WORD FAR PASCAL LFNSetAttribute(LPSTR,WORD);
WORD FAR PASCAL LFNCopy(LPSTR,LPSTR,PQUERYPROC);
WORD FAR PASCAL LFNMove(LPSTR,LPSTR);
WORD FAR PASCAL LFNDelete(LPSTR);
WORD FAR PASCAL LFNMKDir(LPSTR);
WORD FAR PASCAL LFNRMDir(LPSTR);
WORD FAR PASCAL LFNGetVolumeLabel(WORD,LPSTR);
WORD FAR PASCAL LFNSetVolumeLabel(WORD,LPSTR);
WORD FAR PASCAL LFNParse(LPSTR,LPSTR,LPSTR);
WORD FAR PASCAL LFNVolumeType(WORD,LPINT);

/* return values from LFNParse
 */
#define FILE_83_CI		0
#define FILE_83_CS		1
#define FILE_LONG		2

/* volumes types from LFNVolumeType
 */
#define VOLUME_STANDARD 	0
#define VOLUME_LONGNAMES	1

/* error code return values
 */
#define ERROR_SUCCESS		0

// will add others later, == DOS int 21h error codes.

// this error code causes a call to WNetGetError, WNetGetErrorText
// to get the error text.
#define ERROR_NETWORKSPECIFIC	0xFFFF

#endif

typedef struct _NETRESOURCE 
{
    DWORD dwScope;
    DWORD dwType;
    DWORD dwDisplayType;
    DWORD dwUsage;
    LPSTR lpLocalName;
    LPSTR lpRemoteName;
    LPSTR lpComment;
    LPSTR lpProvider;
} NETRESOURCE, *LPNETRESOURCE;

enum 
{
    Resource_CONNECTED,
    Resource_GLOBALNET
};

enum ENUMTYPE
{
    NET_USE,
    NET_SERVER,
    NET_SHARE
};

#define	ResourceType_DISK		0x01
#define	ResourceType_PRINT		0x02

#define ResourceUsage_UNDEFINE		0x00
#define ResourceUsage_CONNECTABLE	0x01
#define ResourceUsage_CONTAINER		0x02

#define WN_BAD_HANDLE			0x0060
#define WN_NO_MORE_ENTRIES		0x0061

DWORD FAR PASCAL WNetOpenEnum( DWORD dwScope, DWORD dwType, DWORD dwUsage,
    LPNETRESOURCE lpNetResource, HANDLE * lphEnum );
DWORD FAR PASCAL WNetEnumResource( HANDLE hEnum, LPDWORD lpcCount,
    LPVOID lpBuffer, DWORD cbBuffer );
DWORD FAR PASCAL WNetCloseEnum( HANDLE hEnum );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\hack\winnet16.h ===
/*
 *	Windows/Network Interface
 *	Copyright (C) Microsoft 1989
 *
 *	Standard WINNET Driver Header File, spec version 3.10
 *						 rev. 3.10.05 ;Internal
 *
 *	Note: This file has been modified to not include the 16 bit only
 *	portions under win32 and to not duplicate the functions
 *	contained in winnet32.h.
 */


// basic type and macro definitions elided; see lmuitype.h
#ifndef NOBASICTYPES
typedef WORD far * LPWORD;
#endif // NOBASICTYPES

#ifndef _WNET1632_H_
#error Do not include this file directly, include it through WNet1632.h
#endif //_WNET1632_H_

#ifndef WIN32
/*
 *	SPOOLING - CONTROLLING JOBS
 */

// BUGBUG
// we should move this one to somewhere
typedef UINT FAR * LPUINT ;

#define WNJ_NULL_JOBID  0


WORD FAR PASCAL WNetOpenJob(LPSTR,LPSTR,WORD,LPINT);
WORD FAR PASCAL WNetCloseJob(WORD,LPINT,LPSTR);
WORD FAR PASCAL WNetWriteJob(HANDLE,LPSTR,LPINT);
WORD FAR PASCAL WNetAbortJob(WORD,LPSTR);
WORD FAR PASCAL WNetHoldJob(LPSTR,WORD);
WORD FAR PASCAL WNetReleaseJob(LPSTR,WORD);
WORD FAR PASCAL WNetCancelJob(LPSTR,WORD);
WORD FAR PASCAL WNetSetJobCopies(LPSTR,WORD,WORD);

/*
 *	SPOOLING - QUEUE AND JOB INFO
 */

typedef struct _queuestruct	{
	WORD	pqName;
	WORD	pqComment;
	WORD	pqStatus;
	WORD	pqJobcount;
	WORD	pqPrinters;
} QUEUESTRUCT;

typedef QUEUESTRUCT far * LPQUEUESTRUCT;

#define WNPRQ_ACTIVE	0x0
#define WNPRQ_PAUSE	0x1
#define WNPRQ_ERROR	0x2
#define WNPRQ_PENDING	0x3
#define WNPRQ_PROBLEM	0x4


typedef struct _jobstruct 	{
	WORD	pjId;
	WORD	pjUsername;
	WORD	pjParms;
	WORD	pjPosition;
	WORD	pjStatus;
	DWORD	pjSubmitted;
	DWORD	pjSize;
	WORD	pjCopies;
	WORD	pjComment;
} JOBSTRUCT;

typedef JOBSTRUCT far * LPJOBSTRUCT;

#define WNPRJ_QSTATUS		0x0007
#define  WNPRJ_QS_QUEUED		0x0000
#define  WNPRJ_QS_PAUSED		0x0001
#define  WNPRJ_QS_SPOOLING		0x0002
#define  WNPRJ_QS_PRINTING		0x0003
#define WNPRJ_DEVSTATUS 	0x0FF8
#define  WNPRJ_DS_COMPLETE		0x0008
#define  WNPRJ_DS_INTERV		0x0010
#define  WNPRJ_DS_ERROR 		0x0020
#define  WNPRJ_DS_DESTOFFLINE		0x0040
#define  WNPRJ_DS_DESTPAUSED		0x0080
#define  WNPRJ_DS_NOTIFY		0x0100
#define  WNPRJ_DS_DESTNOPAPER		0x0200
#define  WNPRJ_DS_DESTFORMCHG		0x0400
#define  WNPRJ_DS_DESTCRTCHG		0x0800
#define  WNPRJ_DS_DESTPENCHG  		0x1000

#define SP_QUEUECHANGED 	0x0500


WORD FAR PASCAL WNetWatchQueue(HWND,LPSTR,LPSTR,WORD);
WORD FAR PASCAL WNetUnwatchQueue(LPSTR);
WORD FAR PASCAL WNetLockQueueData(LPSTR,LPSTR,LPQUEUESTRUCT FAR *);
WORD FAR PASCAL WNetUnlockQueueData(LPSTR);

#define WNNC_PRINTING			0x0007
#define  WNNC_PRT_OpenJob			0x0002
#define  WNNC_PRT_CloseJob			0x0004
#define  WNNC_PRT_HoldJob			0x0010
#define  WNNC_PRT_ReleaseJob			0x0020
#define  WNNC_PRT_CancelJob			0x0040
#define  WNNC_PRT_SetJobCopies			0x0080
#define  WNNC_PRT_WatchQueue			0x0100
#define  WNNC_PRT_UnwatchQueue			0x0200
#define  WNNC_PRT_LockQueueData 		0x0400
#define  WNNC_PRT_UnlockQueueData		0x0800
#define  WNNC_PRT_ChangeMsg			0x1000
#define  WNNC_PRT_AbortJob			0x2000
#define  WNNC_PRT_NoArbitraryLock		0x4000
#define  WNNC_PRT_WriteJob			0x8000
#endif

/*
 *	OTHER
 */

UINT FAR PASCAL WNetGetUser(LPSTR,LPUINT);

#ifndef WIN32
/* Printing */

#define WN_BAD_JOBID			0x0040
#define WN_JOB_NOT_FOUND		0x0041
#define WN_JOB_NOT_HELD 		0x0042
#define WN_BAD_QUEUE			0x0043
#define WN_BAD_FILE_HANDLE		0x0044
#define WN_CANT_SET_COPIES		0x0045
#define WN_ALREADY_LOCKED		0x0046

#endif //!WIN32


#if defined( LFN ) && !defined( WIN32 )

/* this is the data structure returned from LFNFindFirst and
 * LFNFindNext.  The last field, achName, is variable length.  The size
 * of the name in that field is given by cchName, plus 1 for the zero
 * terminator.
 */
typedef struct _filefindbuf2
  {
    WORD fdateCreation;
    WORD ftimeCreation;
    WORD fdateLastAccess;
    WORD ftimeLastAccess;
    WORD fdateLastWrite;
    WORD ftimeLastWrite;
    DWORD cbFile;
    DWORD cbFileAlloc;
    WORD attr;
    DWORD cbList;
    BYTE cchName;
    BYTE achName[1];
  } FILEFINDBUF2, FAR * PFILEFINDBUF2;

typedef BOOL (FAR PASCAL *PQUERYPROC)( void );

WORD FAR PASCAL LFNFindFirst(LPSTR,WORD,LPINT,LPINT,WORD,PFILEFINDBUF2);
WORD FAR PASCAL LFNFindNext(HANDLE,LPINT,WORD,PFILEFINDBUF2);
WORD FAR PASCAL LFNFindClose(HANDLE);
WORD FAR PASCAL LFNGetAttribute(LPSTR,LPINT);
WORD FAR PASCAL LFNSetAttribute(LPSTR,WORD);
WORD FAR PASCAL LFNCopy(LPSTR,LPSTR,PQUERYPROC);
WORD FAR PASCAL LFNMove(LPSTR,LPSTR);
WORD FAR PASCAL LFNDelete(LPSTR);
WORD FAR PASCAL LFNMKDir(LPSTR);
WORD FAR PASCAL LFNRMDir(LPSTR);
WORD FAR PASCAL LFNGetVolumeLabel(WORD,LPSTR);
WORD FAR PASCAL LFNSetVolumeLabel(WORD,LPSTR);
WORD FAR PASCAL LFNParse(LPSTR,LPSTR,LPSTR);
WORD FAR PASCAL LFNVolumeType(WORD,LPINT);

/* return values from LFNParse
 */
#define FILE_83_CI		0
#define FILE_83_CS		1
#define FILE_LONG		2

/* volumes types from LFNVolumeType
 */
#define VOLUME_STANDARD 	0
#define VOLUME_LONGNAMES	1

/* error code return values
 */
#define ERROR_SUCCESS		0

// will add others later, == DOS int 21h error codes.

// this error code causes a call to WNetGetError, WNetGetErrorText
// to get the error text.
#define ERROR_NETWORKSPECIFIC	0xFFFF

#endif	// LFN && !WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\hack\dos\pwin16.h ===
/*****************************************************************************\
* PWIN16.H - PORTABILITY MAPPING HEADER FILE
*
* This file provides macros to map portable windows code to its 16 bit form.
\*****************************************************************************/

/*-----------------------------------USER------------------------------------*/
 
DWORD FAR PASCAL     MGetLastError(VOID);
DWORD FAR PASCAL     MSendMsgEM_GETSEL(HWND hDlg, INT FAR *piStart, INT FAR *piEnd);

/* HELPER MACROS */

#define MAPVALUE(v16, v32)              (v16)
#define MAPTYPE(v16, v32)               v16
#define MAKEMPOINT(l)                   (*((MPOINT FAR *)&(l)))
#define MPOINT2POINT(mpt, pt)           (pt = *(POINT FAR *)&(mpt))
#define POINT2MPOINT(pt, mpt)           (mpt = *(MPOINT FAR *)&(pt))
#define LONG2POINT(l, pt)               ((pt).x = (INT)LOWORD(l), (pt).y = (INT)HIWORD(l))

#define GETWINDOWUINT(hwnd, index)      (UINT)GetWindowWord(hwnd, index)
#define SETWINDOWUINT(hwnd, index, ui)  (UINT)SetWindowWord(hwnd, index, (WORD)(ui))
#define SETCLASSUINT(hwnd, index, ui)   (UINT)SetClassWord(hwnd, index, (WORD)(ui))
#define GETCLASSUINT(hwnd, index)       (UINT)GetClassWord(hwnd, index)

#define GETCBCLSEXTRA(hwnd)             GETCLASSUINT(hwnd, GCW_CBCLSEXTRA)
#define SETCBCLSEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCW_CBCLSEXTRA, cb)
#define GETCBWNDEXTRA(hwnd)             GETCLASSUINT(hwnd, GCW_CBWNDEXTRA)     
#define SETCBWNDEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCW_CBWNDEXTRA, cb) 
#define GETCLASSBRBACKGROUND(hwnd)      (HBRUSH)GETCLASSUINT(hwnd, GCW_HBRBACKGROUND)
#define SETCLASSBRBACKGROUND(hwnd, h)   (HBRUSH)SETCLASSUINT(hwnd, GCW_HBRBACKGROUND, h)
#define GETCLASSCURSOR(hwnd)            (HCURSOR)GETCLASSUINT(hwnd, GCW_HCURSOR)
#define SETCLASSCURSOR(hwnd, h)         (HCURSOR)SETCLASSUINT(hwnd, GCW_HCURSOR, h)
#define GETCLASSHMODULE(hwnd)           (HMODULE)GETCLASSUINT(hwnd, GCW_HMODULE)            
#define SETCLASSHMODULE(hwnd, h)        (HMODULE)SETCLASSUINT(hwnd, GCW_HMODULE, h) 
#define GETCLASSICON(hwnd)              (HICON)GETCLASSUINT((hwnd), GCW_HICON)
#define SETCLASSICON(hwnd, h)           (HICON)SETCLASSUINT((hwnd), GCW_HICON, h)
#define GETCLASSSTYLE(hwnd)             GETCLASSUINT((hwnd), GCW_STYLE)            
#define SETCLASSSTYLE(hwnd, style)      SETCLASSUINT((hwnd), GCW_STYLE, style) 
#define GETHWNDINSTANCE(hwnd)           (HMODULE)GETWINDOWUINT((hwnd), GWW_HINSTANCE)
#define SETHWNDINSTANCE(hwnd, h)        (HMODULE)SETWINDOWUINT((hwnd), GWW_HINSTANCE, h)
#define GETHWNDPARENT(hwnd)             (HWND)GETWINDOWUINT((hwnd), GWW_HWNDPARENT)
#define SETHWNDPARENT(hwnd, h)          (HWND)SETWINDOWUINT((hwnd), GWW_HWNDPARENT, h)
#define GETWINDOWID(hwnd)               GETWINDOWUINT((hwnd), GWW_ID)            
#define SETWINDOWID(hwnd, id)           SETWINDOWUINT((hwnd), GWW_ID, id) 

/* USER API */

#define MDlgDirSelect(hDlg, lpstr, nLength, nIDListBox) \
            DlgDirSelect(hDlg, lpstr, nIDListBox)
            
#define MDlgDirSelectCOMBOBOX(hDlg, lpstr, nLength, nIDComboBox) \
            DlgDirSelectComboBox(hDlg, lpstr, nIDComboBox)

#define MMain(hInst, hPrevInst, lpCmdLine, nCmdShow) \
   INT PASCAL WinMain(HANDLE hInst, HANDLE hPrevInst, LPSTR lpCmdLine, \
   INT nCmdShow) {  \
   INT _argc;       \
   TCHAR **_argv;    

/* USER MESSAGES: */

#define GET_WPARAM(wp, lp)                      (wp)
#define GET_LPARAM(wp, lp)                      (lp)

#define WM_CTLCOLORMSGBOX       0x0132
#define WM_CTLCOLOREDIT         0x0133
#define WM_CTLCOLORLISTBOX      0x0134
#define WM_CTLCOLORBTN          0x0135
#define WM_CTLCOLORDLG          0x0136
#define WM_CTLCOLORSCROLLBAR    0x0137
#define WM_CTLCOLORSTATIC       0x0138

#define GET_WM_ACTIVATE_STATE(wp, lp)               (wp)
#define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)          (BOOL)HIWORD(lp)
#define GET_WM_ACTIVATE_HWND(wp, lp)                (HWND)LOWORD(lp)
#define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)   \
        (WPARAM)(s), MAKELONG(hwnd, fmin)
    
#define GET_WM_CHARTOITEM_CHAR(wp, lp)              (TCHAR)(wp)
#define GET_WM_CHARTOITEM_POS(wp, lp)               HIWORD(lp)
#define GET_WM_CHARTOITEM_HWND(wp, lp)              (HWND)LOWORD(lp)
#define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd) \
        (WPARAM)(ch), MAKELONG(hwnd, pos)
  
#define GET_WM_COMMAND_ID(wp, lp)                   (wp)
#define GET_WM_COMMAND_HWND(wp, lp)                 (HWND)LOWORD(lp)
#define GET_WM_COMMAND_CMD(wp, lp)                  HIWORD(lp)
#define GET_WM_COMMAND_MPS(id, hwnd, cmd)    \
        (WPARAM)(id), MAKELONG(hwnd, cmd)
     
#define GET_WM_CTLCOLOR_HDC(wp, lp, msg)            (HDC)(wp)
#define GET_WM_CTLCOLOR_HWND(wp, lp, msg)           (HWND)LOWORD(lp)
#define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)           HIWORD(lp)
#define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type) \
        (WPARAM)(hdc), MAKELONG(hwnd, type)
     
#define GET_WM_MENUSELECT_CMD(wp, lp)               (wp)            
#define GET_WM_MENUSELECT_FLAGS(wp, lp)             LOWORD(lp)
#define GET_WM_MENUSELECT_HMENU(wp, lp)             (HMENU)HIWORD(lp)
#define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)  \
        (WPARAM)(cmd), MAKELONG(f, hmenu)
  
// Note: the following are for interpreting MDIclient to MDI child messages.
#define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (BOOL)(wp)         
#define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
#define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)
// Note: the following is for sending to the MDI client window.
#define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA)\
        (WPARAM)(hwndA), 0
 
#define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW) 0, MAKELONG(hmenuF, hmenuW)
  
#define GET_WM_MENUCHAR_CHAR(wp, lp)                (TCHAR)(wp)
#define GET_WM_MENUCHAR_HMENU(wp, lp)               (HMENU)LOWORD(lp)
#define GET_WM_MENUCHAR_FMENU(wp, lp)               (BOOL)HIWORD(lp)
#define GET_WM_MENUCHAR_MPS(ch, hmenu, f)    \
        (WPARAM)(ch), MAKELONG(hmenu, f)
    
#define GET_WM_PARENTNOTIFY_MSG(wp, lp)             (wp)
#define GET_WM_PARENTNOTIFY_ID(wp, lp)              HIWORD(lp)
#define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)       (HWND)LOWORD(lp)
#define GET_WM_PARENTNOTIFY_X(wp, lp)               (INT)LOWORD(lp)
#define GET_WM_PARENTNOTIFY_Y(wp, lp)               (INT)HIWORD(lp)
#define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd) \
        (WPARAM)(msg), MAKELONG(hwnd, id)
#define GET_WM_PARENTNOTIFY2_MPS(msg, x, y) \
        (WPARAM)(msg), MAKELONG(x, y)

#define GET_WM_VKEYTOITEM_CODE(wp, lp)              (wp)
#define GET_WM_VKEYTOITEM_ITEM(wp, lp)              (INT)HIWORD(lp)
#define GET_WM_VKEYTOITEM_HWND(wp, lp)              (HWND)LOWORD(lp)
#define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) \
        (WPARAM)(code), MAKELONG(hwnd, item)

#define GET_EM_SETSEL_START(wp, lp)                 LOWORD(lp)
#define GET_EM_SETSEL_END(wp, lp)                   HIWORD(lp)
#define GET_EM_SETSEL_MPS(iStart, iEnd) \
        0, MAKELONG(iStart, iEnd)
      
#define GET_EM_LINESCROLL_MPS(vert, horz)     \
        0, MAKELONG(vert, horz)
  
#define GET_WM_HSCROLL_CODE(wp, lp)                 (wp)
#define GET_WM_HSCROLL_POS(wp, lp)                  LOWORD(lp)
#define GET_WM_HSCROLL_HWND(wp, lp)                 (HWND)HIWORD(lp)
#define GET_WM_HSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)(code), MAKELONG(pos, hwnd)
     
#define GET_WM_VSCROLL_CODE(wp, lp)                 (wp)
#define GET_WM_VSCROLL_POS(wp, lp)                  LOWORD(lp)
#define GET_WM_VSCROLL_HWND(wp, lp)                 (HWND)HIWORD(lp)
#define GET_WM_VSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)(code), MAKELONG(pos, hwnd)
                                      
#define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)       (HWND)LOWORD(lp)
     
#define DDEFREE(msg, lp)

#define GET_WM_DDE_ACK_STATUS(wp, lp)               LOWORD(lp)
#define GET_WM_DDE_ACK_ITEM(wp, lp)                 (ATOM)HIWORD(lp)
#define MPostWM_DDE_ACK(hTo, hFrom, wStatus, aItem) \
        PostMessage(hTo, WM_DDE_ACK, (WPARAM)hFrom, MAKELONG(wStatus, aItem))

#define GET_WM_DDE_ADVISE_HOPTIONS(wp, lp)          (HANDLE)LOWORD(lp)
#define GET_WM_DDE_ADVISE_ITEM(wp, lp)              (ATOM)HIWORD(lp)
#define MPostWM_DDE_ADVISE(hTo, hFrom, hOptions, aItem) \
        PostMessage(hTo, WM_DDE_ADVISE, (WPARAM)hFrom, MAKELONG(hOptions, aItem))
  
#define GET_WM_DDE_DATA_HDATA(wp, lp)               (HANDLE)LOWORD(lp)
#define GET_WM_DDE_DATA_ITEM(wp, lp)                (ATOM)HIWORD(lp)
#define MPostWM_DDE_DATA(hTo, hFrom, hData, aItem) \
        PostMessage(hTo, WM_DDE_DATA, (WPARAM)hFrom, MAKELONG(hData, aItem))
  
#define GET_WM_DDE_EXECUTE_HDATA(wp, lp)            (HANDLE)HIWORD(lp)
#define MPostWM_DDE_EXECUTE(hTo, hFrom, hDataExec) \
        PostMessage(hTo, WM_DDE_EXECUTE, (WPARAM)hFrom, MAKELONG(0, hDataExec))
  
#define GET_WM_DDE_POKE_HDATA(wp, lp)               (HANDLE)LOWORD(lp)
#define GET_WM_DDE_POKE_ITEM(wp, lp)                (ATOM)HIWORD(lp)
#define MPostWM_DDE_POKE(hTo, hFrom, hData, aItem) \
        PostMessage(hTo, WM_DDE_POKE, (WPARAM)hFrom, MAKELONG(hData, aItem))
    
#define GET_WM_DDE_EXECACK_STATUS(wp, lp)           (WORD)LOWORD(lp)
#define GET_WM_DDE_EXECACK_HDATA(wp, lp)            (HANDLE)HIWORD(lp)
#define MPostWM_DDE_EXECACK(hTo, hFrom, hCommands, wStatus) \
        PostMessage(hTo, WM_DDE_ACK, (WPARAM)hFrom, MAKELONG(wStatus, hCommands))
    
#define GET_WM_DDE_REQUEST_FORMAT(wp, lp)           (ATOM)LOWORD(lp)
#define GET_WM_DDE_REQUEST_ITEM(wp, lp)             (ATOM)HIWORD(lp)
#define MPostWM_DDE_REQUEST(hTo, hFrom, fmt, aItem) \
        PostMessage(hTo, WM_DDE_REQUEST, (WPARAM)hFrom, MAKELONG(fmt, aItem))

#define GET_WM_DDE_UNADVISE_FORMAT(wp, lp)          (ATOM)LOWORD(lp)
#define GET_WM_DDE_UNADVISE_ITEM(wp, lp)            (ATOM)HIWORD(lp)
#define MPostWM_DDE_UNADVISE(hTo, hFrom, fmt, aItem) \
        PostMessage(hTo, WM_DDE_UNADVISE, (WPARAM)hFrom, MAKELONG(fmt, aItem))
        
#define MPostWM_DDE_TERMINATE(hTo, hFrom) \
        PostMessage(hTo, WM_DDE_TERMINATE, (WPARAM)hFrom, 0)

/*-----------------------------------GDI-------------------------------------*/

BOOL  FAR PASCAL     MGetAspectRatioFilter(HDC hdc, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetBitmapDimension(HANDLE hBitmap, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetBrushOrg(HDC hdc, INT FAR * px, INT FAR * py);
BOOL  FAR PASCAL     MGetCurrentPosition(HDC hdc, INT FAR * px, INT FAR * py);
BOOL  FAR PASCAL     MGetTextExtent(HDC hdc, LPSTR lpstr, INT cnt, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetViewportExt(HDC hdc, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetViewportOrg(HDC hdc, INT FAR * px, INT FAR * py);
BOOL  FAR PASCAL     MGetWindowExt(HDC hdc, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetWindowOrg(HDC hdc, INT FAR * px, INT FAR * py);

// n.b. i sliced the casts to void off of these

#define MCreateDiscardableBitmap CreateDiscardableBitmap
#define MMoveTo 		 MoveTo
#define MOffsetViewportOrg	 OffsetViewportOrg
#define MOffsetWindowOrg	 OffsetWindowOrg
#define MScaleViewportExt	 ScaleViewportExt
#define MScaleWindowExt 	 ScaleWindowExt
#define MSetBitmapDimension	 SetBitmapDimension
#define MSetBrushOrg		 SetBrushOrg
#define MSetViewportExt 	 SetViewportExt
#define MSetViewportOrg 	 SetViewportOrg
#define MSetWindowExt		 SetWindowtExt
#define MSetWindowOrg		 SetWindowOrg
#define MUnrealizeObject         UnrealizeObject


/*-------------------------------------DEV-----------------------------------*/

#if 0 // BUGBUG - DEVMODE not defined in Win16 GDI
DWORD FAR PASCAL     MDeviceCapabilities(LPSTR lpDriverName,
    LPSTR lpDeviceName, LPSTR lpPort, WORD2DWORD nIndex, LPSTR lpOutput,
    LPDEVMODE lpDevMode);
BOOL  FAR PASCAL     MDeviceMode(HWND hWnd, LPSTR lpDriverName,
    LPSTR lpDeviceName, LPSTR lpOutput);
WORD2DWORD FAR PASCAL    MExtDeviceMode(HWND hWnd,LPSTR lpDriverName,
    LPDEVMODE lpDevModeOutput, LPSTR lpDeviceName, LPSTR lpPort,
    LPDEVMODE lpDevModeInput, LPSTR lpProfile, WORD2DWORD flMode);
#endif
    
/*-----------------------------------KERNEL----------------------------------*/

HANDLE FAR PASCAL   MLoadLibrary(LPSTR lpszFilename);
BOOL FAR PASCAL MDeleteFile(LPSTR lpPathName);

#define DLLMEM_MOVEABLE         LMEM_MOVEABLE
#define DLLMEM_ZEROINIT         LMEM_ZEROINIT 
#define GETMAJORVERSION(x)      LOBYTE(x)
#define GETMINORVERSION(x)      HIBYTE(x)

#define MCATCHBUF               CATCHBUF
#define LPMCATCHBUF             LPCATCHBUF

/* FUNCTION MAPPINGS */

#define MLocalInit               LocalInit
#define MLockData(dummy)         LockData(dummy)
#define MUnlockData(dummy)       UnlockData(dummy)
#define MDllSharedAlloc          LocalAlloc
#define MDllSharedFlags          LocalFlags
#define MDllSharedFree           LocalFree
#define MDllSharedHandle         LocalHandle
#define MDllSharedLock           LocalLock 
#define MDllSharedRealloc        LocalReAlloc
#define MDllSharedSize           LocalSize
#define MDllSharedUnlock         LocalUnlock
#define MFreeDOSEnvironment(p)   TRUE
#define MGetCurrentTask          GetCurrentTask
#define MGetDOSEnvironment       GetDOSEnvironment
#define MGetDriveType            GetDriveType
#define MGetMetaFileBits         GetMetaFileBits
#define MGetModuleUsage          GetModuleUsage
#define MGetTempDrive            GetTempDrive
#define MGetTempFileName         GetTempFileName
#define MGetWinFlags             GetWinFlags
#define MOpenComm                (HFILE)OpenComm
#define MSetCommState(fh, lpDCB) SetCommState(lpDCB)
#define MReadComm                ReadComm
#define MWriteComm               WriteComm
#define MCloseComm               CloseComm
#define MOpenFile                (HFILE)OpenFile
#define MSetMetaFileBits         SetMetaFileBits
#define MThrow                   Throw
#define MCatch                   Catch
#define M_lclose                 _lclose
#define M_lcreat                 (HFILE)_lcreat
#define M_llseek                 _llseek
#define M_lopen                  (HFILE)_lopen
#define M_lread                  _lread
#define M_lwrite                 _lwrite
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\hack\dos\pwintype.h ===
/*****************************************************************************\
* PTYPES16.H - PORTABILITY MAPPING HEADER FILE
*
* This file provides typedefs for portable 16/32 bit code.
\*****************************************************************************/

/* TEMPORARY FIXES: */

#ifndef CCHDEVICENAME
//#include <drivinit.h>
#endif

#define ERROR_GETADDR_FAILED     0x8001
#define ERROR_ALLOCATION_FAILURE 0x8002

#define INITWINDOWS()

/* TYPES: */

/* The types which conflict with our definitions, I withdraw.
   Others I convert to manifests to reduce Glock's confusion. */

#define WORD2DWORD	WORD
#define CHARPARM	char
#define SHORTPARM	INT
#define VERSION 	WORD
#define HMF		HANDLE
#define PDLLMEM 	WORD
#define CHAR2ULONG	char
#define USHORT2ULONG	USHORT
#define SHORT2ULONG	SHORT
#define INT2DWORD	INT
#define INT2WORD	INT
#define BYTE2WORD	BYTE
#define MPOINT		POINT
#define HINSTANCE	HANDLE
#define HMODULE 	HANDLE

#define WNDPROC 	FARPROC
#define PROC		FARPROC
#define HUGE_T		huge

#define HFILE2INT(h, flags)     (INT)(h)
#define INT2HFILE(i)            (HFILE)(i)
#define DUPHFILE(h)             (HFILE)dup((INT)(h))
#define MGLOBALPTR(p)           HIWORD((LONG)p)

/* PRAGMAS */

#define _LOADDS _loadds
#define _EXPORT _export
                       
/* New additions */

#define MFARPROC	FARPROC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\hack\dos\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Defines the structs and unions used for the direct DOS interface
*	routines; includes macros to access the segment and offset
*	values of far pointers, so that they may be used by the routines; and
*	provides function prototypes for direct DOS interface functions.
*
****/


#ifndef _REGS_DEFINED

/* word registers */

struct WORDREGS {
	unsigned int ax;
	unsigned int bx;
	unsigned int cx;
	unsigned int dx;
	unsigned int si;
	unsigned int di;
	unsigned int cflag;
	};


/* byte registers */

struct BYTEREGS {
	unsigned char al, ah;
	unsigned char bl, bh;
	unsigned char cl, ch;
	unsigned char dl, dh;
	};


/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union REGS {
	struct WORDREGS x;
	struct BYTEREGS h;
	};


/* segment registers */

struct SREGS {
	unsigned int es;
	unsigned int cs;
	unsigned int ss;
	unsigned int ds;
	};

#define _REGS_DEFINED

#endif

// BUGBUG
// Glock dont like the use of the keyword class, remove temporarily
//
//#ifndef _DOSERROR_DEFINED
//
//struct DOSERROR {
//	int exterror;
//	char class;
//	char action;
//	char locus;
//	};
//
//#define _DOSERROR_DEFINED
//
// 
// #endif


/* _dos_findfirst structure */

#ifndef _FIND_T_DEFINED

struct find_t {
	char reserved[21];
	char attrib;
	unsigned wr_time;
	unsigned wr_date;
	long size;
	char name[13];
	};

#define _FIND_T_DEFINED

#endif


/* _dos_getdate/_dossetdate and _dos_gettime/_dos_settime structures */

#ifndef _DATETIME_T_DEFINED

struct dosdate_t {
	unsigned char day;		/* 1-31 */
	unsigned char month;		/* 1-12 */
	unsigned int year;		/* 1980-2099 */
	unsigned char dayofweek;	/* 0-6, 0=Sunday */
	};

struct dostime_t {
	unsigned char hour;	/* 0-23 */
	unsigned char minute;	/* 0-59 */
	unsigned char second;	/* 0-59 */
	unsigned char hsecond;	/* 0-99 */
	};

#define _DATETIME_T_DEFINED

#endif


/* _dos_getdiskfree structure */

#ifndef _DISKFREE_T_DEFINED

struct diskfree_t {
	unsigned total_clusters;
	unsigned avail_clusters;
	unsigned sectors_per_cluster;
	unsigned bytes_per_sector;
	};

#define _DISKFREE_T_DEFINED

#endif


/* manifest constants for _hardresume result parameter */

#define _HARDERR_IGNORE 	0	/* Ignore the error */
#define _HARDERR_RETRY		1	/* Retry the operation */
#define _HARDERR_ABORT		2	/* Abort program issuing Interrupt 23h */
#define _HARDERR_FAIL		3	/* Fail the system call in progress */
					/* _HARDERR_FAIL is not supported on DOS 2.x */

/* File attribute constants */

#define _A_NORMAL	0x00	/* Normal file - No read/write restrictions */
#define _A_RDONLY	0x01	/* Read only file */
#define _A_HIDDEN	0x02	/* Hidden file */
#define _A_SYSTEM	0x04	/* System file */
#define _A_VOLID	0x08	/* Volume ID file */
#define _A_SUBDIR	0x10	/* Subdirectory */
#define _A_ARCH 	0x20	/* Archive file */

/* macros to break C "far" pointers into their segment and offset components
 */

#define FP_SEG(fp) (*((unsigned _far *)&(fp)+1))
#define FP_OFF(fp) (*((unsigned _far *)&(fp)))


/* external variable declarations */

extern unsigned int _near _cdecl _osversion;


/* function prototypes */

#ifndef _MT
int _cdecl bdos(int, unsigned int, unsigned int);
void _cdecl _chain_intr(void (_cdecl _interrupt _far *)());
void _cdecl _disable(void);
unsigned _cdecl _dos_allocmem(unsigned, unsigned *);
unsigned _cdecl _dos_close(int);
unsigned _cdecl _dos_creat(const char *, unsigned, int *);
unsigned _cdecl _dos_creatnew(const char *, unsigned, int *);
unsigned _cdecl _dos_findfirst(const char *, unsigned, struct find_t *);
unsigned _cdecl _dos_findnext(struct find_t *);
unsigned _cdecl _dos_freemem(unsigned);
void _cdecl _dos_getdate(struct dosdate_t *);
void _cdecl _dos_getdrive(unsigned *);
unsigned _cdecl _dos_getdiskfree(unsigned, struct diskfree_t *);
unsigned _cdecl _dos_getfileattr(const char *, unsigned *);
unsigned _cdecl _dos_getftime(int, unsigned *, unsigned *);
void _cdecl _dos_gettime(struct dostime_t *);
void (_cdecl _interrupt _far * _cdecl _dos_getvect(unsigned))();
void _cdecl _dos_keep(unsigned, unsigned);
unsigned _cdecl _dos_open(const char *, unsigned, int *);
unsigned _cdecl _dos_read(int, void _far *, unsigned, unsigned *);
unsigned _cdecl _dos_setblock(unsigned, unsigned, unsigned *);
unsigned _cdecl _dos_setdate(struct dosdate_t *);
void _cdecl _dos_setdrive(unsigned, unsigned *);
unsigned _cdecl _dos_setfileattr(const char *, unsigned);
unsigned _cdecl _dos_setftime(int, unsigned, unsigned);
unsigned _cdecl _dos_settime(struct dostime_t *);
void _cdecl _dos_setvect(unsigned, void (_cdecl _interrupt _far *)());
unsigned _cdecl _dos_write(int, const void _far *, unsigned, unsigned *);
int _cdecl dosexterr(struct DOSERROR *);
void _cdecl _enable(void);
void _cdecl _harderr(void (_far *)());
void _cdecl _hardresume(int);
void _cdecl _hardretn(int);
int _cdecl intdos(union REGS *, union REGS *);
int _cdecl intdosx(union REGS *, union REGS *, struct SREGS *);
int _cdecl int86(int, union REGS *, union REGS *);
int _cdecl int86x(int, union REGS *, union REGS *, struct SREGS *);
#endif /* _MT */

void _cdecl segread(struct SREGS *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\hack\dos\pwin.h ===
#include <pwin16.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\hack\dos\windows.h ===
/*****************************************************************************\
*                                                                             *
*  WINDOWS.H - Windows APIs, types, and definitions                           *
*                                                                             *
*              Version 3.10 BETA III                                          *
*                                                                             *
*******************************************************************************
*
* The following symbols control inclusion of various parts of this file:
*
*  WINVER            - Windows version number (0x030a).  To exclude
*                      definitions introduced in versions 3.1 (or above)
*                      #define WINVER 0x0300 before #including windows.h
*
*  #define:	       To prevent inclusion of:
*
*  NOGDICAPMASKS     - CC_*, LC_*, PC_*, CP_*, TC_*, RC_
*  NOVIRTUALKEYCODES - VK_*
*  NOWINMESSAGES     - WM_*, EM_*, LB_*, CB_*
*  NOWINSTYLES	     - WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
*  NOSYSMETRICS      - SM_*
*  NOMENUS	     - MF_*
*  NOICONS	     - IDI_*
*  NOKEYSTATES	     - MK_*
*  NOSYSCOMMANDS     - SC_*
*  NORASTEROPS	     - Binary and Tertiary raster ops
*  NOSHOWWINDOW      - SW_*
*  NOATOM	     - Atom Manager routines
*  NOCLIPBOARD	     - Clipboard routines
*  NOCOLOR	     - Screen colors
*  NOCTLMGR	     - Control and Dialog routines
*  NODRAWTEXT	     - DrawText() and DT_*
*  NOGDI	     - All GDI defines and routines
*  NOKERNEL	     - All KERNEL defines and routines
*  NOUSER	     - All USER defines and routines
*  NOMB 	     - MB_* and MessageBox()
*  NOLOGERROR        - LogError()/LogParamError() definitions
*  NOMEMMGR	     - GMEM_*, LMEM_*, GHND, LHND, associated routines
*  NOMETAFILE	     - typedef METAFILEPICT
*  NOMINMAX	     - Macros min(a,b) and max(a,b)
*  NOMSG	     - typedef MSG and associated routines
*  NOOEMRESOURCE     - OEM Resource values
*  NOOPENFILE	     - OpenFile(), OemToAnsi, AnsiToOem, and OF_*
*  NOSCROLL	     - SB_* and scrolling routines
*  NOSOUND	     - Sound driver routines
*  NOTEXTMETRIC      - typedef TEXTMETRIC and associated routines
*  NOWH 	     - SetWindowsHook and WH_*
*  NOWINOFFSETS      - GWL_*, GCL_*, associated routines
*  NOHELP	     - Help engine interface.
*  NOPROFILER	     - Profiler interface.
*  NODEFERWINDOWPOS  - DeferWindowPos routines
*  NODRIVERS	     - Installable driver defines
*  NOCOMM            - Communications driver stuff
*  NODBCS	     - DBCS support stuff.
*  NOSYSTEMPARAMSINFO- SystemParametersInfo (SPI_*)
*  NOSCALABLEFONT    - Scalable font prototypes and data structures
*  NOGDIOBJ	     - GDI objects including pens, brushes and logfonts.
*  NOBITMAP	     - GDI bitmaps
*
\****************************************************************************/

#ifndef _INC_WINDOWS
#define _INC_WINDOWS    /* #defined if windows.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* If WINVER is not defined, assume version 3.1 */
#ifndef WINVER
#define WINVER  0x030a
#endif

#ifdef RC_INVOKED
/* Don't include definitions that RC.EXE can't parse */
#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NODBCS
#define NOSYSTEMPARAMSINFO
#define NOCOMM
#define NOOEMRESOURCE
#endif /* RC_INVOKED */

/* Handle OEMRESOURCE for 3.0 compatibility */
#if (WINVER < 0x030a)
#define NOOEMRESOURCE
#ifdef OEMRESOURCE
#undef NOOEMRESOURCE
#endif
#endif

/******* Common definitions and typedefs ***********************************/

// basic type and macro definintions elided; see lmuitype.h
#ifndef NOBASICTYPES

#define VOID		    void

#define FAR                 _far
#define NEAR		    _near
#define PASCAL		    _pascal
#define CDECL		    _cdecl

#endif // NOBASICTYPES

#define WINAPI              _far _pascal
#define CALLBACK            _far _pascal

/****** Simple types & common helper macros *********************************/

// basic type and macro definintions elided; see lmuitype.h
#ifndef NOBASICTYPES

typedef int		    BOOL;
#define FALSE		    0
#define TRUE		    1

typedef unsigned char	    BYTE;
typedef unsigned short      WORD;
typedef unsigned long       DWORD;

typedef unsigned int	    UINT;

#ifdef STRICT
typedef signed long	    LONG;
#else
#define LONG long
#endif

#define LOBYTE(w)	    ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((UINT)(w) >> 8) & 0xFF))

#define LOWORD(l)           ((WORD)(DWORD)(l))
#define HIWORD(l)           ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))

#define MAKELONG(low, high) ((LONG)(((WORD)(low)) | ((DWORD)((WORD)(high))) << 16))

#ifndef NOMINMAX
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif
#endif  /* NOMINMAX */

#endif // NOBASICTYPES

/* Types use for passing & returning polymorphic values */
typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

#define MAKELPARAM(low, high)	((LPARAM)MAKELONG(low, high))
#define MAKELRESULT(low, high)	((LRESULT)MAKELONG(low, high))

/****** Common pointer types ************************************************/

// basic type and macro definintions elided; see lmuitype.h
#ifndef NOBASICTYPES

#ifndef NULL
#define NULL		    0
#endif

typedef char NEAR*          PSTR;
typedef char NEAR*          NPSTR;


typedef char FAR*           LPSTR;
typedef const char FAR*     LPCSTR;

typedef BYTE NEAR*	    PBYTE;
typedef BYTE FAR*	    LPBYTE;

typedef int NEAR*	    PINT;
typedef int FAR*	    LPINT;

typedef WORD NEAR*          PWORD;
typedef WORD FAR*           LPWORD;

typedef long NEAR*	    PLONG;
typedef long FAR*	    LPLONG;

typedef DWORD NEAR*         PDWORD;
typedef DWORD FAR*          LPDWORD;

typedef void FAR*           LPVOID;

#define MAKELP(sel, off)    ((void FAR*)MAKELONG((off), (sel)))
#define SELECTOROF(lp)      HIWORD(lp)
#define OFFSETOF(lp)        LOWORD(lp)

#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)

#endif // NOBASICTYPES

/****** Common handle types *************************************************/

#ifdef STRICT
typedef void NEAR*              HANDLE;
#define DECLARE_HANDLE(name)    typedef struct name##__ NEAR* name
#else	    /* STRICT */
typedef UINT                    HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name
#endif	    /* !STRICT */

typedef HANDLE* 	    PHANDLE;
typedef HANDLE NEAR*	    SPHANDLE;
typedef HANDLE FAR*	    LPHANDLE;

typedef HANDLE		    HGLOBAL;
typedef HANDLE		    HLOCAL;

typedef HANDLE		    GLOBALHANDLE;
typedef HANDLE		    LOCALHANDLE;

typedef UINT                ATOM;

#ifdef STRICT
typedef void (CALLBACK*     FARPROC)(void);
typedef void (NEAR PASCAL*  NEARPROC)(void);
#else
typedef int (CALLBACK*      FARPROC)();
typedef int (NEAR PASCAL*   NEARPROC)();
#endif

DECLARE_HANDLE(HSTR);

/****** KERNEL typedefs, structures, and functions **************************/

DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;  /* HMODULEs can be used in place of HINSTANCEs */

#ifndef NOKERNEL

/****** Application entry point function ************************************/

#ifdef STRICT
int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
#endif

/****** System Information **************************************************/

DWORD   WINAPI GetVersion(void);

DWORD   WINAPI GetFreeSpace(UINT);
UINT    WINAPI GetCurrentPDB(void);

UINT    WINAPI GetWindowsDirectory(LPSTR, UINT);
UINT    WINAPI GetSystemDirectory(LPSTR, UINT);

#if (WINVER >= 0x030a)
UINT    WINAPI GetFreeSystemResources(UINT);
#endif

DWORD   WINAPI GetWinFlags(void);

#define WF_PMODE	0x0001
#define WF_CPU286	0x0002
#define WF_CPU386	0x0004
#define WF_CPU486	0x0008
#define WF_STANDARD	0x0010
#define WF_WIN286	0x0010
#define WF_ENHANCED	0x0020
#define WF_WIN386	0x0020
#define WF_CPU086	0x0040
#define WF_CPU186	0x0080
#define WF_LARGEFRAME	0x0100
#define WF_SMALLFRAME	0x0200
#define WF_80x87	0x0400
#define WF_PAGING	0x0800
#define WF_WLO          0x8000
	   		   
LPSTR   WINAPI GetDOSEnvironment(void);

DWORD   WINAPI GetCurrentTime(void);
DWORD   WINAPI GetTickCount(void);
DWORD   WINAPI GetTimerResolution(void);

/****** Error handling ******************************************************/

#if (WINVER >= 0x030a)

#ifndef NOLOGERROR

void WINAPI LogError(UINT err, void FAR* lpInfo);
void WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING		0x8000
#define ERR_PARAM		0x4000

#define ERR_SIZE_MASK		0x3000
#define ERR_BYTE                0x1000
#define ERR_WORD                0x2000
#define ERR_DWORD               0x3000

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE           0x6001
#define ERR_BAD_FLAGS           0x6002
#define ERR_BAD_INDEX           0x6003
#define ERR_BAD_DVALUE		0x7004
#define ERR_BAD_DFLAGS		0x7005
#define ERR_BAD_DINDEX		0x7006
#define ERR_BAD_PTR		0x7007
#define ERR_BAD_FUNC_PTR	0x7008
#define ERR_BAD_SELECTOR        0x6009
#define ERR_BAD_STRING_PTR	0x700a
#define ERR_BAD_HANDLE          0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS		0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069


/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001
#define ERR_GREALLOC            0x0002
#define ERR_GLOCK               0x0003
#define ERR_LALLOC              0x0004
#define ERR_LREALLOC            0x0005
#define ERR_LLOCK               0x0006
#define ERR_ALLOCRES            0x0007
#define ERR_LOCKRES             0x0008
#define ERR_LOADMODULE          0x0009

/* USER errors */
#define ERR_CREATEDLG           0x0040
#define ERR_CREATEDLG2          0x0041
#define ERR_REGISTERCLASS       0x0042
#define ERR_DCBUSY              0x0043
#define ERR_CREATEWND           0x0044
#define ERR_STRUCEXTRA          0x0045
#define ERR_LOADSTR             0x0046
#define ERR_LOADMENU            0x0047
#define ERR_NESTEDBEGINPAINT    0x0048
#define ERR_BADINDEX            0x0049
#define ERR_CREATEMENU          0x004a

/* GDI errors */
#define ERR_CREATEDC            0x0080
#define ERR_CREATEMETA          0x0081
#define ERR_DELOBJSELECTED      0x0082
#define ERR_SELBITMAP           0x0083

#endif  /* NOLOGERROR */
#endif  /* WINVER >= 0x030a */

void    WINAPI FatalExit(int);
void    WINAPI FatalAppExit(UINT, LPCSTR);

BOOL    WINAPI ExitWindows(DWORD dwReturnCode, UINT wReserved);

#define EW_RESTARTWINDOWS 0x42
#if (WINVER >= 0x030a)
#define EW_REBOOTSYSTEM   0x43

BOOL    WINAPI ExitWindowsExec(LPCSTR, LPCSTR);
#endif /* WINVER >= 0x030a */

void    WINAPI DebugBreak(void);
void    WINAPI OutputDebugString(LPCSTR);

/* SetErrorMode() constants */
#define SEM_FAILCRITICALERRORS  0x0001
#define SEM_NOGPFAULTERRORBOX   0x0002
#define SEM_NOOPENFILEERRORBOX  0x8000

UINT    WINAPI SetErrorMode(UINT);

/****** Pointer validation **************************************************/

#if (WINVER >= 0x030a)

BOOL    WINAPI IsBadReadPtr(const void FAR* lp, UINT cb);
BOOL    WINAPI IsBadWritePtr(void FAR* lp, UINT cb);
BOOL    WINAPI IsBadHugeReadPtr(const void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadHugeWritePtr(void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadCodePtr(FARPROC lpfn);
BOOL    WINAPI IsBadStringPtr(const void FAR* lpsz, UINT cchMax);

#endif  /* WINVER >= 0x030a */

/****** Profiling support ***************************************************/

#ifndef NOPROFILER

int     WINAPI ProfInsChk(void);
void    WINAPI ProfSetup(int,int);
void    WINAPI ProfSampRate(int,int);
void    WINAPI ProfStart(void);
void    WINAPI ProfStop(void);
void    WINAPI ProfClear(void);
void    WINAPI ProfFlush(void);
void    WINAPI ProfFinish(void);

#endif /* NOPROFILER */

/****** Catch/Throw and stack management ************************************/

typedef UINT CATCHBUF[9];
typedef UINT FAR* LPCATCHBUF;

int     WINAPI Catch(UINT FAR*);
void    WINAPI Throw(const UINT FAR*, int);

void    WINAPI SwitchStackBack(void);
void    WINAPI SwitchStackTo(UINT, UINT, UINT);

/****** Module Management ***************************************************/

#define HINSTANCE_ERROR ((HINSTANCE)32)


HINSTANCE   WINAPI LoadModule(LPCSTR, LPVOID);
BOOL        WINAPI FreeModule(HINSTANCE);

HINSTANCE   WINAPI LoadLibrary(LPCSTR);
void        WINAPI FreeLibrary(HINSTANCE);

UINT    WINAPI WinExec(LPCSTR, UINT);

HMODULE WINAPI GetModuleHandle(LPCSTR);

int     WINAPI GetModuleUsage(HINSTANCE);
int     WINAPI GetModuleFileName(HINSTANCE, LPSTR, int);

FARPROC WINAPI GetProcAddress(HINSTANCE, LPCSTR);

int     WINAPI GetInstanceData(HINSTANCE, BYTE*, int);

HGLOBAL WINAPI GetCodeHandle(FARPROC);


typedef struct tagSEGINFO
{
    UINT offSegment;
    UINT cbSegment;
    UINT flags;
    UINT cbAlloc;
    HGLOBAL h;
    UINT alignShift;
    UINT reserved[2];
} SEGINFO;
typedef SEGINFO FAR* LPSEGINFO;

void    WINAPI GetCodeInfo(FARPROC lpProc, SEGINFO FAR* lpSegInfo);

FARPROC WINAPI MakeProcInstance(FARPROC, HINSTANCE);
void    WINAPI FreeProcInstance(FARPROC);

LONG    WINAPI SetSwapAreaSize(UINT);
void    WINAPI SwapRecording(UINT);
void    WINAPI ValidateCodeSegments(void);

/* Windows Exit Procedure flag values */
#define	WEP_SYSTEM_EXIT	1
#define	WEP_FREE_DLL	0

/****** Task Management *****************************************************/

#endif	/* NOKERNEL */

DECLARE_HANDLE(HTASK);

#ifndef NOKERNEL

UINT    WINAPI GetNumTasks(void);

#if (WINVER >= 0x030a)
BOOL    WINAPI IsTask(HTASK);
#endif

HTASK   WINAPI GetCurrentTask(void);

void    WINAPI Yield(void);
void    WINAPI DirectedYield(HTASK);

/****** Global memory management ********************************************/

#ifndef NOMEMMGR

/* Global Memory Flags */

#define GMEM_FIXED	    0x0000
#define GMEM_MOVEABLE	    0x0002
#define GMEM_NOCOMPACT	    0x0010
#define GMEM_NODISCARD	    0x0020
#define GMEM_ZEROINIT	    0x0040
#define GMEM_MODIFY	    0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE	    0x2000
#define GMEM_DDESHARE	    0x2000
#define GMEM_NOTIFY	    0x4000
#define GMEM_LOWER	    GMEM_NOT_BANKED

#define GHND		    (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR		    (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalDiscard(h)    GlobalReAlloc(h, 0L, GMEM_MOVEABLE)

HGLOBAL WINAPI GlobalAlloc(UINT, DWORD);
HGLOBAL WINAPI GlobalReAlloc(HGLOBAL, DWORD, UINT);
HGLOBAL WINAPI GlobalFree(HGLOBAL);

DWORD   WINAPI GlobalDosAlloc(DWORD);
UINT    WINAPI GlobalDosFree(UINT);

#ifdef STRICT
void FAR* WINAPI GlobalLock(HGLOBAL);
#else
char FAR* WINAPI GlobalLock(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnlock(HGLOBAL);

DWORD   WINAPI GlobalSize(HGLOBAL);
DWORD   WINAPI GlobalHandle(UINT);

/* GlobalFlags return flags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED	    0x4000
#define GMEM_LOCKCOUNT	    0x00FF
UINT    WINAPI GlobalFlags(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI GlobalWire(HGLOBAL);
#else
char FAR* WINAPI GlobalWire(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnWire(HGLOBAL);

UINT    WINAPI GlobalPageLock(HGLOBAL);
UINT    WINAPI GlobalPageUnlock(HGLOBAL);

void    WINAPI GlobalFix(HGLOBAL);
BOOL    WINAPI GlobalUnfix(HGLOBAL);

HGLOBAL WINAPI GlobalLRUNewest(HGLOBAL);
HGLOBAL WINAPI GlobalLRUOldest(HGLOBAL);

DWORD   WINAPI GlobalCompact(DWORD);

#ifdef STRICT
typedef BOOL (CALLBACK* GNOTIFYPROC)(HGLOBAL);
#else
typedef FARPROC GNOTIFYPROC;
#endif

void    WINAPI GlobalNotify(GNOTIFYPROC);

HGLOBAL WINAPI LockSegment(UINT);
BOOL    WINAPI UnlockSegment(UINT);

#define LockData(dummy)     LockSegment((UINT)-1)
#define UnlockData(dummy)   UnlockSegment((UINT)-1)

UINT    WINAPI AllocSelector(UINT);
UINT    WINAPI FreeSelector(UINT);
UINT    WINAPI AllocDStoCSAlias(UINT);
UINT    WINAPI ChangeSelector(UINT sourceSel, UINT destSel);
DWORD   WINAPI GetSelectorBase(UINT);
UINT    WINAPI SetSelectorBase(UINT, DWORD);
DWORD   WINAPI GetSelectorLimit(UINT);
UINT    WINAPI SetSelectorLimit(UINT, DWORD);

void    WINAPI LimitEmsPages(DWORD);

void    WINAPI ValidateFreeSpaces(void);

/* Low system memory notification message */
#define WM_COMPACTING       0x0041

/***** Local Memory Management */

/* Local Memory Flags */
#define LMEM_FIXED	    0x0000
#define LMEM_MOVEABLE	    0x0002
#define LMEM_NOCOMPACT	    0x0010
#define LMEM_NODISCARD	    0x0020
#define LMEM_ZEROINIT	    0x0040
#define LMEM_MODIFY	    0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LHND		    (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR		    (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND	    (LMEM_MOVEABLE)
#define NONZEROLPTR	    (LMEM_FIXED)


#define LocalDiscard(h)     LocalReAlloc(h, 0, LMEM_MOVEABLE)


HLOCAL  WINAPI LocalAlloc(UINT, UINT);
HLOCAL  WINAPI LocalReAlloc(HLOCAL, UINT, UINT);
HLOCAL  WINAPI LocalFree(HLOCAL);

#ifdef STRICT
void NEAR* WINAPI LocalLock(HLOCAL);
#else
char NEAR* WINAPI LocalLock(HLOCAL);
#endif

BOOL    WINAPI LocalUnlock(HLOCAL);

UINT    WINAPI LocalSize(HLOCAL);
#ifdef STRICT
HLOCAL  WINAPI LocalHandle(void NEAR*);
#else
HLOCAL  WINAPI LocalHandle(UINT);
#endif

/* LocalFlags return flags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED	    0x4000
#define LMEM_LOCKCOUNT	    0x00FF

UINT    WINAPI LocalFlags(HLOCAL);

BOOL    WINAPI LocalInit(UINT, UINT, UINT);
UINT    WINAPI LocalCompact(UINT);
UINT    WINAPI LocalShrink(HLOCAL, UINT);

#endif /* NOMEMMGR */

/****** File I/O ************************************************************/

#ifndef NOLFILEIO

// basic type and macro definintions elided; see lmuitype.h
#ifndef NOBASICTYPES

typedef int HFILE;      /* Polymorphic with C runtime file handle type */

#endif // NOBASICTYPES

#define HFILE_ERROR ((HFILE)-1)

#ifndef NOOPENFILE

/* OpenFile() Structure */
typedef struct tagOFSTRUCT
{
    BYTE cBytes;
    BYTE fFixedDisk;
    UINT nErrCode;
    BYTE reserved[4];
    BYTE szPathName[128];
} OFSTRUCT;
typedef OFSTRUCT*       POFSTRUCT;
typedef OFSTRUCT NEAR* NPOFSTRUCT;
typedef OFSTRUCT FAR*  LPOFSTRUCT;

/* OpenFile() Flags */
#define OF_READ 	    0x0000
#define OF_WRITE	    0x0001
#define OF_READWRITE	    0x0002
#define OF_SHARE_COMPAT	    0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE	    0x0100
#define OF_DELETE	    0x0200
#define OF_VERIFY	    0x0400      /* Used with OF_REOPEN */
#define OF_SEARCH	    0x0400	/* Used without OF_REOPEN */
#define OF_CANCEL	    0x0800
#define OF_CREATE	    0x1000
#define OF_PROMPT	    0x2000
#define OF_EXIST	    0x4000
#define OF_REOPEN	    0x8000

HFILE   WINAPI OpenFile(LPCSTR, OFSTRUCT FAR*, UINT);

#endif /* NOOPENFILE */

/* _lopen() flags */
#define READ	    0
#define WRITE       1
#define READ_WRITE  2

HFILE   WINAPI _lopen(LPCSTR, int);
HFILE   WINAPI _lcreat(LPCSTR, int);

HFILE   WINAPI _lclose(HFILE);

LONG    WINAPI _llseek(HFILE, LONG, int);

UINT    WINAPI _lread(HFILE, void _huge*, UINT);
UINT    WINAPI _lwrite(HFILE, const void _huge*, UINT);


#endif	/* NOLFILEIO */

/* GetTempFileName() Flags */
#define TF_FORCEDRIVE	    (BYTE)0x80

int     WINAPI GetTempFileName(BYTE, LPCSTR, UINT, LPSTR);
BYTE    WINAPI GetTempDrive(char);

/* GetDriveType return values */
#define DRIVE_REMOVABLE 2
#define DRIVE_FIXED     3
#define DRIVE_REMOTE    4
UINT    WINAPI GetDriveType(int);

UINT    WINAPI SetHandleCount(UINT);

#ifdef OVERRIDDEN_BY_WINNET_H

/****** Network support *****************************************************/
UINT WINAPI WNetAddConnection(LPSTR, LPSTR, LPSTR);
UINT WINAPI WNetGetConnection(LPSTR, LPSTR, UINT FAR*);
UINT WINAPI WNetCancelConnection(LPSTR, BOOL);
/* Errors */
#define WN_SUCCESS			0x0000
#define WN_NOT_SUPPORTED		0x0001
#define WN_NET_ERROR			0x0002
#define WN_MORE_DATA			0x0003
#define WN_BAD_POINTER			0x0004
#define WN_BAD_VALUE			0x0005
#define WN_BAD_PASSWORD                 0x0006
#define WN_ACCESS_DENIED		0x0007
#define WN_FUNCTION_BUSY		0x0008
#define WN_WINDOWS_ERROR		0x0009
#define WN_BAD_USER			0x000A
#define WN_OUT_OF_MEMORY		0x000B
#define WN_CANCEL			0x000C
#define WN_CONTINUE			0x000D

/* Connection errors */
#define WN_NOT_CONNECTED		0x0030
#define WN_OPEN_FILES			0x0031
#define WN_BAD_NETNAME			0x0032
#define WN_BAD_LOCALNAME		0x0033
#define WN_ALREADY_CONNECTED		0x0034
#define WN_DEVICE_ERROR 		0x0035
#define WN_CONNECTION_CLOSED		0x0036

#endif // OVERRIDDEN_BY_WINNET_H

/****** Resource Management *************************************************/

DECLARE_HANDLE(HRSRC);

HRSRC   WINAPI FindResource(HINSTANCE, LPCSTR, LPCSTR);
HGLOBAL WINAPI LoadResource(HINSTANCE, HRSRC);
BOOL    WINAPI FreeResource(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI LockResource(HGLOBAL);
#else
char FAR* WINAPI LockResource(HGLOBAL);
#endif

#define     UnlockResource(h)	    GlobalUnlock(h)

DWORD   WINAPI SizeofResource(HINSTANCE, HRSRC);

int     WINAPI AccessResource(HINSTANCE, HRSRC);

HGLOBAL WINAPI AllocResource(HINSTANCE, HRSRC, DWORD);

#ifdef STRICT
typedef HGLOBAL (CALLBACK* RSRCHDLRPROC)(HGLOBAL, HINSTANCE, HRSRC);
#else
typedef FARPROC RSRCHDLRPROC;
#endif

RSRCHDLRPROC WINAPI SetResourceHandler(HINSTANCE, LPCSTR, RSRCHDLRPROC);

#define MAKEINTRESOURCE(i)  ((LPCSTR)MAKELP(NULL, (i)))

#ifndef NORESOURCE

/* Predefined Resource Types */
#define RT_CURSOR	    MAKEINTRESOURCE(1)
#define RT_BITMAP	    MAKEINTRESOURCE(2)
#define RT_ICON 	    MAKEINTRESOURCE(3)
#define RT_MENU 	    MAKEINTRESOURCE(4)
#define RT_DIALOG	    MAKEINTRESOURCE(5)
#define RT_STRING	    MAKEINTRESOURCE(6)
#define RT_FONTDIR	    MAKEINTRESOURCE(7)
#define RT_FONT 	    MAKEINTRESOURCE(8)
#define RT_ACCELERATOR	    MAKEINTRESOURCE(9)
#define RT_RCDATA	    MAKEINTRESOURCE(10)

#define RT_GROUP_CURSOR     MAKEINTRESOURCE(12)
#define RT_GROUP_ICON	    MAKEINTRESOURCE(14)

#endif /* NORESOURCE */

#ifdef OEMRESOURCE

/* OEM Resource Ordinal Numbers */
#define OBM_CLOSE	    32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#if (WINVER >= 0x030a)
#define OBM_UPARROWI	    32737
#define OBM_DNARROWI	    32736
#define OBM_RGARROWI	    32735
#define OBM_LFARROWI	    32734
#endif /* WINVER >= 0x030a */

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL	    32512
#define OCR_IBEAM	    32513
#define OCR_WAIT	    32514
#define OCR_CROSS	    32515
#define OCR_UP		    32516
#define OCR_SIZE	    32640
#define OCR_ICON	    32641
#define OCR_SIZENWSE	    32642
#define OCR_SIZENESW	    32643
#define OCR_SIZEWE	    32644
#define OCR_SIZENS	    32645
#define OCR_SIZEALL	    32646
#define OCR_ICOCUR	    32647

#define OIC_SAMPLE	    32512
#define OIC_HAND	    32513
#define OIC_QUES	    32514
#define OIC_BANG	    32515
#define OIC_NOTE	    32516

#endif /* OEMRESOURCE */

/****** Atom Management *****************************************************/

#define MAKEINTATOM(i)	    ((LPCSTR)MAKELP(NULL, (i)))

#ifndef NOATOM

BOOL    WINAPI InitAtomTable(int);
ATOM    WINAPI AddAtom(LPCSTR);
ATOM    WINAPI DeleteAtom(ATOM);
ATOM    WINAPI FindAtom(LPCSTR);
UINT    WINAPI GetAtomName(ATOM, LPSTR, int);
ATOM    WINAPI GlobalAddAtom(LPCSTR);
ATOM    WINAPI GlobalDeleteAtom(ATOM);
ATOM    WINAPI GlobalFindAtom(LPCSTR);
UINT    WINAPI GlobalGetAtomName(ATOM, LPSTR, int);
HLOCAL  WINAPI GetAtomHandle(ATOM);

#endif /* NOATOM */

/****** WIN.INI Support *****************************************************/

/* User Profile Routines */
UINT    WINAPI GetProfileInt(LPCSTR, LPCSTR, int);
int     WINAPI GetProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int);
BOOL    WINAPI WriteProfileString(LPCSTR, LPCSTR, LPCSTR);

UINT    WINAPI GetPrivateProfileInt(LPCSTR, LPCSTR, int, LPCSTR);
int     WINAPI GetPrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int, LPCSTR);
BOOL    WINAPI WritePrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPCSTR);

#define WM_WININICHANGE	    0x001A

/****** International & Char Translation Support ****************************/

void    WINAPI AnsiToOem(const char _huge*, char _huge*);
void    WINAPI OemToAnsi(const char _huge*, char _huge*);

void    WINAPI AnsiToOemBuff(LPCSTR, LPSTR, UINT);
void    WINAPI OemToAnsiBuff(LPCSTR, LPSTR, UINT);

LPSTR   WINAPI AnsiNext(LPCSTR);
LPSTR   WINAPI AnsiPrev(LPCSTR, LPCSTR);

LPSTR   WINAPI AnsiUpper(LPSTR);
LPSTR   WINAPI AnsiLower(LPSTR);

UINT    WINAPI AnsiUpperBuff(LPSTR, UINT);
UINT    WINAPI AnsiLowerBuff(LPSTR, UINT);


#ifndef  NOLANGUAGE
BOOL    WINAPI IsCharAlpha(char);
BOOL    WINAPI IsCharAlphaNumeric(char);
BOOL    WINAPI IsCharUpper(char);
BOOL    WINAPI IsCharLower(char);
#endif

#ifndef NOLSTRING
int     WINAPI lstrcmp(LPCSTR, LPCSTR);
int     WINAPI lstrcmpi(LPCSTR, LPCSTR);
LPSTR   WINAPI lstrcpy(LPSTR, LPCSTR);
LPSTR   WINAPI lstrcat(LPSTR, LPCSTR);
int     WINAPI lstrlen(LPCSTR);
#endif	/* NOLSTRING */

#if (WINVER >= 0x030a)
#ifndef NODBCS
BOOL    WINAPI IsDBCSLeadByte(BYTE);
#endif	/* NODBCS */
#endif  /* WINVER >= 0x030a */

int     WINAPI LoadString(HINSTANCE, UINT, LPSTR, int);

/****** Keyboard Driver Functions *******************************************/

#ifndef	NOKEYBOARDINFO

DWORD   WINAPI OemKeyScan(UINT);
UINT    WINAPI VkKeyScan(UINT);
int     WINAPI GetKeyboardType(int);
UINT    WINAPI MapVirtualKey(UINT, UINT);
int     WINAPI GetKBCodePage(void);
int     WINAPI GetKeyNameText(LONG, LPSTR, int);
int     WINAPI ToAscii(UINT wVirtKey, UINT wScanCode, BYTE FAR* lpKeyState, DWORD FAR* lpChar, UINT wFlags);

#endif

#endif /* NOKERNEL */

/****** GDI typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HDC);

#ifndef NOGDI

#ifdef STRICT
typedef void NEAR* HGDIOBJ;
#else
DECLARE_HANDLE(HGDIOBJ);
#endif

#endif	/* NOGDI */

DECLARE_HANDLE(HBITMAP);
DECLARE_HANDLE(HPEN);
DECLARE_HANDLE(HBRUSH);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HPALETTE);
DECLARE_HANDLE(HFONT);

typedef struct tagRECT
{
    int left;
    int top;
    int right;
    int bottom;
} RECT;
typedef RECT*      PRECT;
typedef RECT NEAR* NPRECT;
typedef RECT FAR*  LPRECT;

typedef struct tagPOINT
{
    int x;
    int y;
} POINT;
typedef POINT*       PPOINT;
typedef POINT NEAR* NPPOINT;
typedef POINT FAR*  LPPOINT;

#if (WINVER >= 0x030a)
typedef struct tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;
typedef SIZE NEAR* NPSIZE;
typedef SIZE FAR*  LPSIZE;
#endif  /* WINVER >= 0x030a */

#define MAKEPOINT(l)	    (*((POINT FAR*)&(l)))

#ifndef NOGDI

/****** DC Management *******************************************************/

HDC     WINAPI CreateDC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateIC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateCompatibleDC(HDC);

BOOL    WINAPI DeleteDC(HDC);

DWORD   WINAPI GetDCOrg(HDC);

int     WINAPI SaveDC(HDC);
BOOL    WINAPI RestoreDC(HDC, int);

int     WINAPI SetEnvironment(LPCSTR, const void FAR*, UINT);
int     WINAPI GetEnvironment(LPCSTR, void FAR*, UINT);

int     WINAPI MulDiv(int, int, int);

#if (WINVER >= 0x030a)
/* Drawing bounds accumulation APIs */
UINT    WINAPI SetBoundsRect(HDC hDC, const RECT FAR* lprcBounds, UINT flags);
UINT    WINAPI GetBoundsRect(HDC hDC, RECT FAR* lprcBounds, UINT flags);

#define DCB_RESET       0x0001
#define DCB_ACCUMULATE  0x0002
#define DCB_DIRTY	DCB_ACCUMULATE
#define DCB_SET 	(DCB_RESET | DCB_ACCUMULATE)
#define DCB_ENABLE      0x0004
#define DCB_DISABLE     0x0008

#endif  /* WINVER >= 0x030a */

/****** Device Capabilities *************************************************/

int WINAPI GetDeviceCaps(HDC, int);

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0
#define TECHNOLOGY    2
#define HORZSIZE      4
#define VERTSIZE      6
#define HORZRES       8
#define VERTRES       10
#define BITSPIXEL     12
#define PLANES        14
#define NUMBRUSHES    16
#define NUMPENS       18
#define NUMMARKERS    20
#define NUMFONTS      22
#define NUMCOLORS     24
#define PDEVICESIZE   26
#define CURVECAPS     28
#define LINECAPS      30
#define POLYGONALCAPS 32
#define TEXTCAPS      34
#define CLIPCAPS      36
#define RASTERCAPS    38
#define ASPECTX       40
#define ASPECTY       42
#define ASPECTXY      44

#define LOGPIXELSX    88
#define LOGPIXELSY    90

#define SIZEPALETTE  104
#define NUMRESERVED  106
#define COLORRES     108

#ifndef NOGDICAPMASKS

/* GetDeviceCaps() return value masks */

/* TECHNOLOGY */
#define DT_PLOTTER          0
#define DT_RASDISPLAY       1
#define DT_RASPRINTER       2
#define DT_RASCAMERA        3
#define DT_CHARSTREAM       4
#define DT_METAFILE         5
#define DT_DISPFILE         6

/* CURVECAPS */
#define CC_NONE             0x0000
#define CC_CIRCLES          0x0001
#define CC_PIE              0x0002
#define CC_CHORD            0x0004
#define CC_ELLIPSES         0x0008
#define CC_WIDE             0x0010
#define CC_STYLED           0x0020
#define CC_WIDESTYLED       0x0040
#define CC_INTERIORS        0x0080
#define CC_ROUNDRECT        0x0100

/* LINECAPS */
#define LC_NONE             0x0000
#define LC_POLYLINE         0x0002
#define LC_MARKER           0x0004
#define LC_POLYMARKER       0x0008
#define LC_WIDE             0x0010
#define LC_STYLED           0x0020
#define LC_WIDESTYLED       0x0040
#define LC_INTERIORS        0x0080

/* POLYGONALCAPS */
#define PC_NONE             0x0000
#define PC_POLYGON          0x0001
#define PC_RECTANGLE        0x0002
#define PC_WINDPOLYGON      0x0004
#define PC_SCANLINE         0x0008
#define PC_WIDE             0x0010
#define PC_STYLED           0x0020
#define PC_WIDESTYLED       0x0040
#define PC_INTERIORS        0x0080

/* TEXTCAPS */
#define TC_OP_CHARACTER     0x0001
#define TC_OP_STROKE        0x0002
#define TC_CP_STROKE        0x0004
#define TC_CR_90            0x0008
#define TC_CR_ANY           0x0010
#define TC_SF_X_YINDEP      0x0020
#define TC_SA_DOUBLE        0x0040
#define TC_SA_INTEGER       0x0080
#define TC_SA_CONTIN        0x0100
#define TC_EA_DOUBLE        0x0200
#define TC_IA_ABLE          0x0400
#define TC_UA_ABLE          0x0800
#define TC_SO_ABLE          0x1000
#define TC_RA_ABLE          0x2000
#define TC_VA_ABLE          0x4000
#define TC_RESERVED         0x8000

/* CLIPCAPS */
#define CP_NONE             0x0000
#define CP_RECTANGLE        0x0001
#define CP_REGION           0x0002

/* RASTERCAPS */
#define RC_NONE
#define RC_BITBLT           0x0001
#define RC_BANDING          0x0002
#define RC_SCALING          0x0004
#define RC_BITMAP64         0x0008
#define RC_GDI20_OUTPUT     0x0010
#define RC_GDI20_STATE      0x0020
#define RC_SAVEBITMAP       0x0040
#define RC_DI_BITMAP        0x0080
#define RC_PALETTE          0x0100
#define RC_DIBTODEV         0x0200
#define RC_BIGFONT          0x0400
#define RC_STRETCHBLT       0x0800
#define RC_FLOODFILL        0x1000
#define RC_STRETCHDIB       0x2000
#define RC_OP_DX_OUTPUT     0x4000
#define RC_DEVBITS          0x8000

#endif /* NOGDICAPMASKS */

/****** Coordinate transformation support ***********************************/

int     WINAPI SetMapMode(HDC, int);
int     WINAPI GetMapMode(HDC);

/* Map modes */
#define MM_TEXT		    1
#define MM_LOMETRIC	    2
#define MM_HIMETRIC	    3
#define MM_LOENGLISH	    4
#define MM_HIENGLISH	    5
#define MM_TWIPS	    6
#define MM_ISOTROPIC	    7
#define MM_ANISOTROPIC	    8

DWORD   WINAPI SetWindowOrg(HDC, int, int);
DWORD   WINAPI GetWindowOrg(HDC);
BOOL    WINAPI SetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetWindowOrgEx(HDC, POINT FAR*);

DWORD   WINAPI SetWindowExt(HDC, int, int);
DWORD   WINAPI GetWindowExt(HDC);
#if (WINVER >= 0x030a)
BOOL    WINAPI SetWindowExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetWindowExtEx(HDC, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
DWORD   WINAPI OffsetWindowOrg(HDC, int, int);
BOOL    WINAPI OffsetWindowOrgEx(HDC, int, int, POINT FAR*);

DWORD   WINAPI ScaleWindowExt(HDC, int, int, int, int);
#if (WINVER >= 0x030a)
BOOL    WINAPI ScaleWindowExtEx(HDC, int, int, int, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
DWORD   WINAPI SetViewportOrg(HDC, int, int);
DWORD   WINAPI GetViewportOrg(HDC);
#if (WINVER >= 0x030a)
BOOL    WINAPI SetViewportExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetViewportExtEx(HDC, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
DWORD   WINAPI SetViewportExt(HDC, int, int);
DWORD   WINAPI GetViewportExt(HDC);
BOOL    WINAPI SetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetViewportOrgEx(HDC, POINT FAR*);

DWORD   WINAPI OffsetViewportOrg(HDC, int, int);
BOOL    WINAPI OffsetViewportOrgEx(HDC, int, int, POINT FAR*);

DWORD   WINAPI ScaleViewportExt(HDC, int, int, int, int);
#if (WINVER >= 0x030a)
BOOL    WINAPI ScaleViewportExtEx(HDC, int, int, int, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
BOOL    WINAPI DPtoLP(HDC, POINT FAR*, int);
BOOL    WINAPI LPtoDP(HDC, POINT FAR*, int);


/* Coordinate Modes */
#define ABSOLUTE    1
#define RELATIVE    2

/****** Color support *******************************************************/

typedef DWORD COLORREF;

#define RGB(r,g,b)          ((COLORREF)(((BYTE)(r)|((WORD)(g)<<8))|(((DWORD)(BYTE)(b))<<16)))

#define GetRValue(rgb)	    ((BYTE)(rgb))
#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)	    ((BYTE)((rgb)>>16))

COLORREF WINAPI GetNearestColor(HDC, COLORREF);

#ifndef NOCOLOR

COLORREF WINAPI GetSysColor(int);
void    WINAPI SetSysColors(int, const int FAR*, const COLORREF FAR*);

#define COLOR_SCROLLBAR		   0
#define COLOR_BACKGROUND	   1
#define COLOR_ACTIVECAPTION	   2
#define COLOR_INACTIVECAPTION	   3
#define COLOR_MENU		   4
#define COLOR_WINDOW		   5
#define COLOR_WINDOWFRAME	   6
#define COLOR_MENUTEXT		   7
#define COLOR_WINDOWTEXT	   8
#define COLOR_CAPTIONTEXT  	   9
#define COLOR_ACTIVEBORDER	  10
#define COLOR_INACTIVEBORDER	  11
#define COLOR_APPWORKSPACE	  12
#define COLOR_HIGHLIGHT		  13
#define COLOR_HIGHLIGHTTEXT	  14
#define COLOR_BTNFACE             15
#define COLOR_BTNSHADOW           16
#define COLOR_GRAYTEXT            17
#define COLOR_BTNTEXT		  18
#if (WINVER >= 0x030a)
#define COLOR_INACTIVECAPTIONTEXT 19
#define COLOR_BTNHIGHLIGHT        20
#endif  /* WINVER >= 0x030a */

#endif /* NOCOLOR */

#define WM_SYSCOLORCHANGE   0x0015

/****** GDI Object Support **************************************************/

#ifndef NOGDIOBJ

HGDIOBJ WINAPI GetStockObject(int);

BOOL    WINAPI IsGDIObject(HGDIOBJ);

BOOL    WINAPI DeleteObject(HGDIOBJ);
HGDIOBJ WINAPI SelectObject(HDC, HGDIOBJ);
int     WINAPI GetObject(HGDIOBJ, int, void FAR*);
BOOL    WINAPI UnrealizeObject(HGDIOBJ);

#ifdef STRICT
typedef (CALLBACK* GOBJENUMPROC)(void FAR*, LPARAM);
#else
typedef FARPROC GOBJENUMPROC;
#endif

#ifdef STRICT
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPARAM);
#else
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPSTR);
#endif

/* Object types for EnumObjects() */
#define OBJ_PEN 	    1
#define OBJ_BRUSH	    2

/****** Pen support *********************************************************/

/* Logical Pen */
typedef struct tagLOGPEN
{
    UINT    lopnStyle;
    POINT   lopnWidth;
    COLORREF lopnColor;
} LOGPEN;
typedef LOGPEN*       PLOGPEN;
typedef LOGPEN NEAR* NPLOGPEN;
typedef LOGPEN FAR*  LPLOGPEN;

/* Pen Styles */
#define PS_SOLID	    0
#define PS_DASH             1
#define PS_DOT              2
#define PS_DASHDOT          3
#define PS_DASHDOTDOT       4
#define PS_NULL 	    5
#define PS_INSIDEFRAME 	    6

HPEN    WINAPI CreatePen(int, int, COLORREF);
HPEN    WINAPI CreatePenIndirect(LOGPEN FAR*);

/* Stock pens for use with GetStockObject(); */
#define WHITE_PEN	    6
#define BLACK_PEN	    7
#define NULL_PEN	    8

/****** Brush support *******************************************************/

/* Brush Styles */
#define BS_SOLID	    0
#define BS_NULL		    1
#define BS_HOLLOW	    BS_NULL
#define BS_HATCHED	    2
#define BS_PATTERN	    3
#define BS_INDEXED	    4
#define	BS_DIBPATTERN	    5

/* Hatch Styles */
#define HS_HORIZONTAL       0
#define HS_VERTICAL         1
#define HS_FDIAGONAL        2
#define HS_BDIAGONAL        3
#define HS_CROSS            4
#define HS_DIAGCROSS        5

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
{
    UINT     lbStyle;
    COLORREF lbColor;
    int      lbHatch;
} LOGBRUSH;
typedef LOGBRUSH*       PLOGBRUSH;
typedef LOGBRUSH NEAR* NPLOGBRUSH;
typedef LOGBRUSH FAR*  LPLOGBRUSH;

typedef LOGBRUSH	    PATTERN;
typedef PATTERN*       PPATTERN;
typedef PATTERN NEAR* NPPATTERN;
typedef PATTERN FAR*  LPPATTERN;

HBRUSH  WINAPI CreateSolidBrush(COLORREF);
HBRUSH  WINAPI CreateHatchBrush(int, COLORREF);
HBRUSH  WINAPI CreatePatternBrush(HBITMAP);
HBRUSH  WINAPI CreateDIBPatternBrush(HGLOBAL, UINT);
HBRUSH  WINAPI CreateBrushIndirect(LOGBRUSH FAR*);

/* Stock brushes for use with GetStockObject() */
#define WHITE_BRUSH	    0
#define LTGRAY_BRUSH	    1
#define GRAY_BRUSH	    2
#define DKGRAY_BRUSH	    3
#define BLACK_BRUSH	    4
#define NULL_BRUSH	    5
#define HOLLOW_BRUSH	    NULL_BRUSH

DWORD   WINAPI SetBrushOrg(HDC, int, int);
DWORD   WINAPI GetBrushOrg(HDC);

BOOL    WINAPI GetBrushOrgEx(HDC, POINT FAR*);
#endif	/* NOGDIOBJ */

/****** Region support ******************************************************/

HRGN    WINAPI CreateRectRgn(int, int, int, int);
HRGN    WINAPI CreateRectRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgn(int, int, int, int);
HRGN    WINAPI CreatePolygonRgn(const POINT FAR*, int, int);
HRGN    WINAPI CreatePolyPolygonRgn(const POINT FAR*, const int FAR*, int, int);
HRGN    WINAPI CreateRoundRectRgn(int, int, int, int, int, int);

/* Region type flags */
#define ERROR		    0
#define NULLREGION	    1
#define SIMPLEREGION	    2
#define COMPLEXREGION	    3

void    WINAPI SetRectRgn(HRGN, int, int, int, int);

int     WINAPI CombineRgn(HRGN, HRGN, HRGN, int);

/* CombineRgn() command values */
#define RGN_AND 	    1
#define RGN_OR		    2
#define RGN_XOR 	    3
#define RGN_DIFF	    4
#define RGN_COPY	    5

BOOL    WINAPI EqualRgn(HRGN, HRGN);
int     WINAPI OffsetRgn(HRGN, int, int);

int     WINAPI GetRgnBox(HRGN, RECT FAR*);

#if (WINVER < 0x030a)
#define RectInRegion RectInRegionOld
#endif
BOOL    WINAPI RectInRegion(HRGN, const RECT FAR*);
BOOL    WINAPI PtInRegion(HRGN, int, int);

/****** Color palette Support ************************************************/

#define PALETTERGB(r,g,b)   (0x02000000L | RGB(r,g,b))
#define PALETTEINDEX(i)     ((COLORREF)(0x01000000L | (DWORD)(WORD)(i)))

typedef struct tagPALETTEENTRY
{
    BYTE    peRed;
    BYTE    peGreen;
    BYTE    peBlue;
    BYTE    peFlags;
} PALETTEENTRY;
typedef PALETTEENTRY FAR* LPPALETTEENTRY;

/* Palette entry flags */
#define PC_RESERVED	0x01	/* palette index used for animation */
#define PC_EXPLICIT	0x02	/* palette index is explicit to device */
#define	PC_NOCOLLAPSE	0x04	/* do not match color to system palette */

/* Logical Palette */
typedef struct tagLOGPALETTE
{
    WORD    palVersion;
    WORD    palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE;
typedef LOGPALETTE*       PLOGPALETTE;
typedef LOGPALETTE NEAR* NPLOGPALETTE;
typedef LOGPALETTE FAR*  LPLOGPALETTE;

HPALETTE WINAPI CreatePalette(const LOGPALETTE FAR*);

HPALETTE WINAPI SelectPalette(HDC, HPALETTE, BOOL);

UINT    WINAPI RealizePalette(HDC);

int     WINAPI UpdateColors(HDC);
void    WINAPI AnimatePalette(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);

UINT    WINAPI SetPaletteEntries(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);
UINT    WINAPI GetPaletteEntries(HPALETTE, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetNearestPaletteIndex(HPALETTE, COLORREF);

BOOL    WINAPI ResizePalette(HPALETTE, UINT);

UINT    WINAPI GetSystemPaletteEntries(HDC, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetSystemPaletteUse(HDC);
UINT    WINAPI SetSystemPaletteUse(HDC, UINT);

/* Get/SetSystemPaletteUse() values */
#define	SYSPAL_STATIC	1
#define	SYSPAL_NOSTATIC 2

/* Palette window messages */
#define WM_QUERYNEWPALETTE  0x030F
#define WM_PALETTEISCHANGING 0x0310
#define WM_PALETTECHANGED   0x0311

/****** Clipping support *****************************************************/

int     WINAPI SelectClipRgn(HDC, HRGN);
int     WINAPI GetClipBox(HDC, RECT FAR*);

int     WINAPI IntersectClipRect(HDC, int, int, int, int);
int     WINAPI OffsetClipRgn(HDC, int, int);
int     WINAPI ExcludeClipRect(HDC, int, int, int, int);

BOOL    WINAPI PtVisible(HDC, int, int);
#if (WINVER < 0x030a)
#define RectVisible RectVisibleOld
#endif
BOOL    WINAPI RectVisible(HDC, const RECT FAR*);



/****** General drawing support ********************************************/

DWORD   WINAPI MoveTo(HDC, int, int);
BOOL    WINAPI MoveToEx(HDC, int, int, POINT FAR*);
DWORD   WINAPI GetCurrentPosition(HDC);
BOOL    WINAPI GetCurrentPositionEx(HDC, POINT FAR*);

BOOL    WINAPI LineTo(HDC, int, int);
BOOL    WINAPI Polyline(HDC, const POINT FAR*, int);

#ifdef STRICT
typedef void (CALLBACK* LINEDDAPROC)(int, int, LPARAM);
#else
typedef FARPROC LINEDDAPROC;
#endif

void    WINAPI LineDDA(int, int, int, int, LINEDDAPROC, LPARAM);

BOOL    WINAPI Rectangle(HDC, int, int, int, int);
BOOL    WINAPI RoundRect(HDC, int, int, int, int, int, int);

BOOL    WINAPI Ellipse(HDC, int, int, int, int);
BOOL    WINAPI Arc(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Chord(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Pie(HDC, int, int, int, int, int, int, int, int);

BOOL    WINAPI Polygon(HDC, const POINT FAR*, int);
BOOL    WINAPI PolyPolygon(HDC, const POINT FAR*, int FAR*, int);

/* PolyFill Modes */
#define ALTERNATE   1
#define WINDING     2

int     WINAPI SetPolyFillMode(HDC, int);
int     WINAPI GetPolyFillMode(HDC);

BOOL    WINAPI FloodFill(HDC, int, int, COLORREF);
BOOL    WINAPI ExtFloodFill(HDC, int, int, COLORREF, UINT);

/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1

BOOL    WINAPI FillRgn(HDC, HRGN, HBRUSH);
BOOL    WINAPI FrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL    WINAPI InvertRgn(HDC, HRGN);
BOOL    WINAPI PaintRgn(HDC, HRGN);

/* Rectangle output routines */
int     WINAPI FillRect(HDC, const RECT FAR*, HBRUSH);
int     WINAPI FrameRect(HDC, const RECT FAR*, HBRUSH);
void    WINAPI InvertRect(HDC, const RECT FAR*);

void    WINAPI DrawFocusRect(HDC, const RECT FAR*);


/****** Text support ********************************************************/

BOOL    WINAPI TextOut(HDC, int, int, LPCSTR, int);
LONG    WINAPI TabbedTextOut(HDC, int, int, LPCSTR, int, int, int FAR*, int);
BOOL    WINAPI ExtTextOut(HDC, int, int, UINT, const RECT FAR*, LPCSTR, UINT, int FAR*);

#define ETO_GRAYED	0x0001
#define ETO_OPAQUE	0x0002
#define ETO_CLIPPED	0x0004

DWORD   WINAPI GetTextExtent(HDC, LPCSTR, int);
DWORD   WINAPI GetTabbedTextExtent(HDC, LPCSTR, int, int, int FAR*);

#if (WINVER >= 0x030a)
DWORD   WINAPI GetTextExtentEx(HDC, LPCSTR, int, int, int FAR*, int FAR*);
BOOL    WINAPI GetTextExtentPoint(HDC, LPCSTR, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

/* DrawText() Format Flags */
#ifndef NODRAWTEXT
#define DT_TOP		    0x0000
#define DT_LEFT 	    0x0000
#define DT_CENTER	    0x0001
#define DT_RIGHT	    0x0002
#define DT_VCENTER	    0x0004
#define DT_BOTTOM	    0x0008
#define DT_WORDBREAK        0x0010
#define DT_SINGLELINE	    0x0020
#define DT_EXPANDTABS	    0x0040
#define DT_TABSTOP	    0x0080
#define DT_NOCLIP	    0x0100
#define DT_EXTERNALLEADING  0x0200
#define DT_CALCRECT	    0x0400
#define DT_NOPREFIX	    0x0800
#define DT_INTERNAL	    0x1000

int     WINAPI DrawText(HDC, LPCSTR, int, RECT FAR*, UINT);
#endif /* NODRAWTEXT */

#ifdef STRICT
typedef BOOL (CALLBACK* GRAYSTRINGPROC)(HDC, LPARAM, int);
#else
typedef FARPROC GRAYSTRINGPROC;
#endif

BOOL    WINAPI GrayString(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);

BOOL    WINAPI GetCharWidth(HDC, UINT, UINT, int FAR*);

COLORREF WINAPI SetTextColor(HDC, COLORREF);
COLORREF WINAPI GetTextColor(HDC);

COLORREF WINAPI SetBkColor(HDC, COLORREF);
COLORREF WINAPI GetBkColor(HDC);

int     WINAPI SetBkMode(HDC, int);
int     WINAPI GetBkMode(HDC);

/* Background Modes */
#define TRANSPARENT     1
#define OPAQUE          2
#define TRANSPARENT1    3

UINT    WINAPI SetTextAlign(HDC, UINT);
UINT    WINAPI GetTextAlign(HDC);

/* Text Alignment Options */
#define TA_NOUPDATECP		     0x0000
#define TA_UPDATECP		     0x0001
#define TA_LEFT 		     0x0000
#define TA_RIGHT		     0x0002
#define TA_CENTER		     0x0006
#define TA_TOP			     0x0000
#define TA_BOTTOM		     0x0008
#define TA_BASELINE		     0x0018

int     WINAPI SetTextCharacterExtra(HDC, int);
int     WINAPI GetTextCharacterExtra(HDC);

int     WINAPI SetTextJustification(HDC, int, int);

/****** Font support ********************************************************/

#ifndef NOGDIOBJ
/* Logical Font */
#define LF_FACESIZE	    32
typedef struct tagLOGFONT
{
    int     lfHeight;
    int     lfWidth;
    int     lfEscapement;
    int     lfOrientation;
    int     lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    BYTE    lfFaceName[LF_FACESIZE];
} LOGFONT;
typedef LOGFONT*       PLOGFONT;
typedef LOGFONT NEAR* NPLOGFONT;
typedef LOGFONT FAR*  LPLOGFONT;

/* weight values */
#define FW_DONTCARE	    0
#define FW_THIN 	    100
#define FW_EXTRALIGHT	    200
#define FW_LIGHT	    300
#define FW_NORMAL	    400
#define FW_MEDIUM	    500
#define FW_SEMIBOLD	    600
#define FW_BOLD 	    700
#define FW_EXTRABOLD	    800
#define FW_HEAVY	    900

#define FW_ULTRALIGHT	    FW_EXTRALIGHT
#define FW_REGULAR	    FW_NORMAL
#define FW_DEMIBOLD	    FW_SEMIBOLD
#define FW_ULTRABOLD	    FW_EXTRABOLD
#define FW_BLACK	    FW_HEAVY

/* CharSet values */
#define ANSI_CHARSET        0
#define DEFAULT_CHARSET     1
#define SYMBOL_CHARSET      2
#define SHIFTJIS_CHARSET    128
#define OEM_CHARSET         255

/* OutPrecision values */
#define OUT_DEFAULT_PRECIS	0
#define OUT_STRING_PRECIS	1
#define OUT_CHARACTER_PRECIS	2
#define OUT_STROKE_PRECIS	3
#define OUT_TT_PRECIS		4
#define OUT_DEVICE_PRECIS	5
#define OUT_RASTER_PRECIS	6
#define OUT_TT_ONLY_PRECIS	7

/* ClipPrecision values */
#define CLIP_DEFAULT_PRECIS	0
#define CLIP_CHARACTER_PRECIS	1
#define CLIP_STROKE_PRECIS	2
#define CLIP_MASK		0x0F
#define CLIP_LH_ANGLES		0x10
#define CLIP_TT_ALWAYS		0x20
#define CLIP_EMBEDDED		0x80

/* Quality values */
#define DEFAULT_QUALITY     0
#define DRAFT_QUALITY       1
#define PROOF_QUALITY       2

/* PitchAndFamily pitch values (low 4 bits) */
#define DEFAULT_PITCH       0x00
#define FIXED_PITCH         0x01
#define VARIABLE_PITCH      0x02

/* PitchAndFamily family values (high 4 bits) */
#define FF_DONTCARE         0x00
#define FF_ROMAN            0x10
#define FF_SWISS            0x20
#define FF_MODERN           0x30
#define FF_SCRIPT           0x40
#define FF_DECORATIVE       0x50

HFONT   WINAPI CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPCSTR);
HFONT   WINAPI CreateFontIndirect(const LOGFONT FAR*);

/* Stock fonts for use with GetStockObject() */
#define OEM_FIXED_FONT	    10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT	    12
#define SYSTEM_FONT	    13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16


DWORD   WINAPI SetMapperFlags(HDC, DWORD);
#define ASPECT_FILTERING	     0x00000001L

int     WINAPI AddFontResource(LPCSTR);
BOOL    WINAPI RemoveFontResource(LPCSTR);

#define WM_FONTCHANGE	    0x001D

DWORD   WINAPI GetAspectRatioFilter(HDC);
#if (WINVER >= 0x030a)
BOOL    WINAPI GetAspectRatioFilterEx(HDC, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
int     WINAPI GetTextFace(HDC, int, LPSTR);

#endif	/* NOGDIOBJ */

#ifndef NOSCALABLEFONT

/*  GDI scalable font WINAPI prototypes and data structures: */

typedef struct tagPANOSE  /* panose */
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE;

#ifndef NOTEXTMETRIC

typedef struct tagTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
} TEXTMETRIC;
typedef TEXTMETRIC*       PTEXTMETRIC;
typedef TEXTMETRIC NEAR* NPTEXTMETRIC;
typedef TEXTMETRIC FAR*  LPTEXTMETRIC;

typedef struct tagNEWTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRIC;
typedef NEWTEXTMETRIC*       PNEWTEXTMETRIC;
typedef NEWTEXTMETRIC NEAR* NPNEWTEXTMETRIC;
typedef NEWTEXTMETRIC FAR*  LPNEWTEXTMETRIC;

/* ntmFlags field flags */
#define NTM_REGULAR	0x00000040L
#define NTM_BOLD	0x00000020L
#define NTM_ITALIC	0x00000001L

typedef struct tagOUTLINETEXTMETRIC
{
    UINT    otmSize;
    TEXTMETRIC otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
    UINT    otmsCharSlopeRise;
    UINT    otmsCharSlopeRun;
/*  DWORD   otmItalicAngle; */
    UINT    otmEMSquare;
    UINT    otmAscent;
    UINT    otmDescent;
    UINT    otmLineGap;
    UINT    otmsXHeight;
    UINT    otmsCapEmHeight;
    RECT    otmrcFontBox;
    UINT    otmMacAscent;
    UINT    otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
    UINT    otmsStrikeoutPosition;
    UINT    otmsUnderscoreSize;
    UINT    otmsUnderscorePosition;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRIC;
typedef OUTLINETEXTMETRIC FAR* LPOUTLINETEXTMETRIC;

BOOL    WINAPI GetTextMetrics(HDC, LPTEXTMETRIC);
WORD	WINAPI GetOutlineTextMetrics(HDC, UINT, LPOUTLINETEXTMETRIC);

#ifdef STRICT
typedef int (CALLBACK* FONTENUMPROC)(LPLOGFONT, LPTEXTMETRIC, int, LPARAM);
#else
typedef FARPROC FONTENUMPROC;
#endif

#ifdef STRICT
int     WINAPI EnumFonts(HDC, LPCSTR, FONTENUMPROC, LPARAM);
int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPARAM);
#else
int     WINAPI EnumFonts(HDC, LPCSTR, FONTENUMPROC, LPSTR);
int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPSTR);
#endif

/* EnumFonts font type values */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0X0002
#define TRUETYPE_FONTTYPE   0x0004

#endif /* NOTEXTMETRIC */

DWORD   WINAPI GetFontData(HDC, DWORD, DWORD, void FAR*, DWORD);
BOOL	WINAPI CreateScalableFontResource(UINT, LPCSTR, LPCSTR, LPCSTR);

typedef struct tagGLYPHMETRICS
{
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    int     gmCellIncX;
    int     gmCellIncY;
} GLYPHMETRICS;
typedef GLYPHMETRICS FAR* LPGLYPHMETRICS;

typedef struct tagFIXED
{
    UINT    fract;
    int     value;
} FIXED;

typedef struct tagMAT2
{
    FIXED  eM11;
    FIXED  eM12;
    FIXED  eM21;
    FIXED  eM22;
} MAT2;
typedef MAT2 FAR* LPMAT2;

DWORD   WINAPI GetGlyphOutline(HDC, UINT, UINT, LPGLYPHMETRICS, DWORD, POINT FAR*, LPMAT2);

/* GetGlyphOutline constants */
#define GGO_BITMAP         1
#define GGO_NATIVE         2

#define TT_POLYGON_TYPE   24

#define TT_PRIM_LINE       1
#define TT_PRIM_QSPLINE    2

typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, FAR* LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    UINT    wType;
    UINT    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, FAR* LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, FAR* LPTTPOLYGONHEADER;

typedef UINT FAR* LPFONTDIR;

typedef struct tagABC
{
    int   abcA;
    UINT  abcB;
    int   abcC;
} ABC;
typedef ABC FAR* LPABC;

BOOL    WINAPI GetCharABCWidths(HDC, UINT, UINT, LPABC);

typedef struct tagRASTERIZER_STATUS
{
    int   nSize;
    int   wFlags;
    int   nLanguageID;
} RASTERIZER_STATUS;
typedef RASTERIZER_STATUS FAR* LPRASTERIZER_STATUS;

/* bits defined in wFlags of RASTERIZER_STATUS */
#define TT_AVAILABLE	0x0001
#define TT_ENABLED	0x0002

BOOL    WINAPI GetRasterizerCaps(LPRASTERIZER_STATUS, int);

#endif /* NOSCALABLEFONT */

/****** Bitmap support ******************************************************/

#ifndef NOBITMAP
typedef struct tagBITMAP
{
    int     bmType;
    int     bmWidth;
    int     bmHeight;
    int     bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    void FAR* bmBits;
} BITMAP;
typedef BITMAP*       PBITMAP;
typedef BITMAP NEAR* NPBITMAP;
typedef BITMAP FAR*  LPBITMAP;

/* Bitmap Header structures */
typedef struct tagRGBTRIPLE
{
    BYTE    rgbtBlue;
    BYTE    rgbtGreen;
    BYTE    rgbtRed;
} RGBTRIPLE;
typedef RGBTRIPLE FAR* LPRGBTRIPLE;

typedef struct tagRGBQUAD
{
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER
{
    DWORD   bcSize;
    short   bcWidth;
    short   bcHeight;
    WORD    bcPlanes;
    WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER*      PBITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR* LPBITMAPCOREHEADER;

typedef struct tagBITMAPINFOHEADER
{
    DWORD   biSize;
    LONG    biWidth;
    LONG    biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biCompression;
    DWORD   biSizeImage;
    LONG    biXPelsPerMeter;
    LONG    biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
} BITMAPINFOHEADER;
typedef BITMAPINFOHEADER*      PBITMAPINFOHEADER;
typedef BITMAPINFOHEADER FAR* LPBITMAPINFOHEADER;

/* constants for the biCompression field */
#define BI_RGB      0L
#define BI_RLE8     1L
#define BI_RLE4     2L

typedef struct tagBITMAPINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD	     bmiColors[1];
} BITMAPINFO;
typedef BITMAPINFO*     PBITMAPINFO;
typedef BITMAPINFO FAR* LPBITMAPINFO;

typedef struct tagBITMAPCOREINFO
{
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE	     bmciColors[1];
} BITMAPCOREINFO;
typedef BITMAPCOREINFO*      PBITMAPCOREINFO;
typedef BITMAPCOREINFO FAR* LPBITMAPCOREINFO;

typedef struct tagBITMAPFILEHEADER
{
    UINT    bfType;
    DWORD   bfSize;
    UINT    bfReserved1;
    UINT    bfReserved2;
    DWORD   bfOffBits;
} BITMAPFILEHEADER;
typedef BITMAPFILEHEADER*      PBITMAPFILEHEADER;
typedef BITMAPFILEHEADER FAR* LPBITMAPFILEHEADER;


HBITMAP WINAPI CreateBitmap(int, int, UINT, UINT, const void FAR*);
HBITMAP WINAPI CreateBitmapIndirect(BITMAP FAR* );
HBITMAP WINAPI CreateCompatibleBitmap(HDC, int, int);
HBITMAP WINAPI CreateDiscardableBitmap(HDC, int, int);
HBITMAP WINAPI CreateDIBitmap(HDC, BITMAPINFOHEADER FAR*, DWORD, const void FAR*, BITMAPINFO FAR*, UINT);

HBITMAP WINAPI LoadBitmap(HINSTANCE, LPCSTR);

/* DIB color table identifiers */
#define DIB_RGB_COLORS  0
#define DIB_PAL_COLORS  1

/* constants for CreateDIBitmap */
#define CBM_INIT        0x00000004L
#endif	/* NOBITMAP */

#ifndef NORASTEROPS

/* Binary raster ops */
#define R2_BLACK            1
#define R2_NOTMERGEPEN      2
#define R2_MASKNOTPEN       3
#define R2_NOTCOPYPEN       4
#define R2_MASKPENNOT       5
#define R2_NOT              6
#define R2_XORPEN           7
#define R2_NOTMASKPEN       8
#define R2_MASKPEN          9
#define R2_NOTXORPEN        10
#define R2_NOP              11
#define R2_MERGENOTPEN      12
#define R2_COPYPEN          13
#define R2_MERGEPENNOT      14
#define R2_MERGEPEN         15
#define R2_WHITE            16

/* Ternary raster operations */
#define SRCCOPY             0x00CC0020L
#define SRCPAINT            0x00EE0086L
#define SRCAND              0x008800C6L
#define SRCINVERT           0x00660046L
#define SRCERASE            0x00440328L
#define NOTSRCCOPY          0x00330008L
#define NOTSRCERASE         0x001100A6L
#define MERGECOPY           0x00C000CAL
#define MERGEPAINT          0x00BB0226L
#define PATCOPY             0x00F00021L
#define PATPAINT            0x00FB0A09L
#define PATINVERT           0x005A0049L
#define DSTINVERT           0x00550009L
#define BLACKNESS           0x00000042L
#define WHITENESS           0x00FF0062L

#endif /* NORASTEROPS */

#ifndef NOBITMAP
BOOL    WINAPI BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);

BOOL    WINAPI PatBlt(HDC, int, int, int, int, DWORD);

BOOL    WINAPI StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
int     WINAPI StretchDIBits(HDC, int, int, int, int, int,
                        int, int, int, const void FAR*, LPBITMAPINFO, UINT, DWORD);

COLORREF WINAPI SetPixel(HDC, int, int, COLORREF);
COLORREF WINAPI GetPixel(HDC, int, int);

/* StretchBlt() Modes */
#define BLACKONWHITE	1
#define WHITEONBLACK	2
#define COLORONCOLOR	3

/* new StretchBlt() Modes (simpler names) */
#define STRETCH_ANDSCANS        1
#define STRETCH_ORSCANS         2
#define STRETCH_DELETESCANS     3

int     WINAPI SetStretchBltMode(HDC, int);
int     WINAPI GetStretchBltMode(HDC);

DWORD   WINAPI SetBitmapDimension(HBITMAP, int, int);
DWORD   WINAPI GetBitmapDimension(HBITMAP);
#if (WINVER >= 0x030a)
BOOL    WINAPI SetBitmapDimensionEx(HBITMAP, int, int, SIZE FAR*);
BOOL    WINAPI GetBitmapDimensionEx(HBITMAP, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
int     WINAPI SetROP2(HDC, int);
int     WINAPI GetROP2(HDC);

LONG    WINAPI SetBitmapBits(HBITMAP, DWORD, const void FAR*);
LONG    WINAPI GetBitmapBits(HBITMAP, LONG, void FAR*);

int     WINAPI SetDIBits(HDC, HBITMAP, UINT, UINT, const void FAR*, BITMAPINFO FAR*, UINT);
int     WINAPI GetDIBits(HDC, HBITMAP, UINT, UINT, void FAR*, BITMAPINFO FAR*, UINT);

int     WINAPI SetDIBitsToDevice(HDC, int, int, int, int, int, int, UINT, UINT,
                    void FAR*, BITMAPINFO FAR*, UINT);
#endif	/* NOBITMAP */

/****** Metafile support ****************************************************/

#ifndef NOMETAFILE

DECLARE_HANDLE(HMETAFILE);

HDC     WINAPI CreateMetaFile(LPCSTR);
HMETAFILE WINAPI CloseMetaFile(HDC);

HMETAFILE WINAPI GetMetaFile(LPCSTR);
BOOL      WINAPI DeleteMetaFile(HMETAFILE);
HMETAFILE WINAPI CopyMetaFile(HMETAFILE, LPCSTR);

BOOL    WINAPI PlayMetaFile(HDC, HMETAFILE);

HGLOBAL WINAPI GetMetaFileBits(HMETAFILE);
HGLOBAL WINAPI SetMetaFileBits(HMETAFILE);
HGLOBAL WINAPI SetMetaFileBitsBetter(HMETAFILE);

/* Clipboard Metafile Picture Structure */
typedef struct tagMETAFILEPICT
{
    int     mm;
    int     xExt;
    int     yExt;
    HMETAFILE hMF;
} METAFILEPICT;
typedef METAFILEPICT FAR* LPMETAFILEPICT;

typedef struct tagMETAHEADER
{
    UINT    mtType;
    UINT    mtHeaderSize;
    UINT    mtVersion;
    DWORD   mtSize;
    UINT    mtNoObjects;
    DWORD   mtMaxRecord;
    UINT    mtNoParameters;
} METAHEADER;

typedef struct tagHANDLETABLE
{
    HGDIOBJ objectHandle[1];
} HANDLETABLE;
typedef HANDLETABLE*      PHANDLETABLE;
typedef HANDLETABLE FAR* LPHANDLETABLE;

typedef struct tagMETARECORD
{
    DWORD   rdSize;
    UINT    rdFunction;
    UINT    rdParm[1];
} METARECORD;
typedef METARECORD*      PMETARECORD;
typedef METARECORD FAR* LPMETARECORD;

/* Metafile Functions */
#define META_SETBKCOLOR		     0x0201
#define META_SETBKMODE		     0x0102
#define META_SETMAPMODE		     0x0103
#define META_SETROP2		     0x0104
#define META_SETRELABS		     0x0105
#define META_SETPOLYFILLMODE	     0x0106
#define META_SETSTRETCHBLTMODE	     0x0107
#define META_SETTEXTCHAREXTRA	     0x0108
#define META_SETTEXTCOLOR	     0x0209
#define META_SETTEXTJUSTIFICATION    0x020A
#define META_SETWINDOWORG	     0x020B
#define META_SETWINDOWEXT	     0x020C
#define META_SETVIEWPORTORG	     0x020D
#define META_SETVIEWPORTEXT	     0x020E
#define META_OFFSETWINDOWORG	     0x020F
#define META_SCALEWINDOWEXT	     0x0410
#define META_OFFSETVIEWPORTORG	     0x0211
#define META_SCALEVIEWPORTEXT	     0x0412
#define META_LINETO		     0x0213
#define META_MOVETO		     0x0214
#define META_EXCLUDECLIPRECT	     0x0415
#define META_INTERSECTCLIPRECT	     0x0416
#define META_ARC		     0x0817
#define META_ELLIPSE		     0x0418
#define META_FLOODFILL		     0x0419
#define META_PIE		     0x081A
#define META_RECTANGLE		     0x041B
#define META_ROUNDRECT		     0x061C
#define META_PATBLT		     0x061D
#define META_SAVEDC		     0x001E
#define META_SETPIXEL		     0x041F
#define META_OFFSETCLIPRGN	     0x0220
#define META_TEXTOUT		     0x0521
#define META_BITBLT		     0x0922
#define META_STRETCHBLT		     0x0B23
#define META_POLYGON		     0x0324
#define META_POLYLINE		     0x0325
#define META_ESCAPE		     0x0626
#define META_RESTOREDC		     0x0127
#define META_FILLREGION		     0x0228
#define META_FRAMEREGION	     0x0429
#define META_INVERTREGION	     0x012A
#define META_PAINTREGION	     0x012B
#define META_SELECTCLIPREGION	     0x012C
#define META_SELECTOBJECT	     0x012D
#define META_SETTEXTALIGN	     0x012E
#define META_DRAWTEXT		     0x062F

#define	META_CHORD		     0x0830
#define	META_SETMAPPERFLAGS	     0x0231
#define	META_EXTTEXTOUT		     0x0a32 
#define	META_SETDIBTODEV	     0x0d33
#define	META_SELECTPALETTE	     0x0234
#define	META_REALIZEPALETTE	     0x0035
#define	META_ANIMATEPALETTE	     0x0436
#define	META_SETPALENTRIES	     0x0037
#define	META_POLYPOLYGON	     0x0538
#define	META_RESIZEPALETTE	     0x0139

#define	META_DIBBITBLT		     0x0940
#define	META_DIBSTRETCHBLT	     0x0b41
#define	META_DIBCREATEPATTERNBRUSH   0x0142
#define	META_STRETCHDIB		     0x0f43

#define META_EXTFLOODFILL	     0x0548

#define META_RESETDC		     0x014C
#define META_STARTDOC		     0x014D
#define META_STARTPAGE		     0x004F
#define META_ENDPAGE		     0x0050
#define META_ABORTDOC		     0x0052
#define META_ENDDOC		     0x005E

#define	META_DELETEOBJECT	     0x01f0

#define	META_CREATEPALETTE	     0x00f7
#define META_CREATEBRUSH	     0x00F8
#define META_CREATEPATTERNBRUSH	     0x01F9
#define META_CREATEPENINDIRECT	     0x02FA
#define META_CREATEFONTINDIRECT	     0x02FB
#define META_CREATEBRUSHINDIRECT     0x02FC
#define META_CREATEBITMAPINDIRECT    0x02FD
#define META_CREATEBITMAP	     0x06FE
#define META_CREATEREGION	     0x06FF

void    WINAPI PlayMetaFileRecord(HDC, HANDLETABLE FAR*, METARECORD FAR*, UINT);

#ifdef STRICT
typedef int (CALLBACK* MFENUMPROC)(HDC, HANDLETABLE FAR*, METARECORD FAR*, int, LPARAM);
#else
typedef FARPROC MFENUMPROC;
#endif

BOOL    WINAPI EnumMetaFile(HDC, HLOCAL, MFENUMPROC, LPARAM);

#endif /* NOMETAFILE */

/****** Printing support ****************************************************/

typedef struct
{
    int     cbSize;
    LPCSTR  lpszDocName;
    LPCSTR  lpszOutput;
}   DOCINFO;
typedef DOCINFO FAR* LPDOCINFO;

int     WINAPI StartDoc(HDC, DOCINFO FAR*);
int     WINAPI StartPage(HDC);
int     WINAPI EndPage(HDC);
int     WINAPI EndDoc(HDC);
int     WINAPI AbortDoc(HDC);

#ifdef STRICT
typedef BOOL (CALLBACK* ABORTPROC)(HDC, int);
#else
typedef FARPROC ABORTPROC;
#endif

int     WINAPI SetAbortProc(HDC, ABORTPROC);

HANDLE  WINAPI SpoolFile(LPSTR, LPSTR, LPSTR, LPSTR);
BOOL    WINAPI QueryAbort(HDC, int);

/* Spooler Error Codes */
#define SP_NOTREPORTED		     0x4000
#define SP_ERROR		     (-1)
#define SP_APPABORT		     (-2)
#define SP_USERABORT		     (-3)
#define SP_OUTOFDISK		     (-4)
#define SP_OUTOFMEMORY		     (-5)

#define PR_JOBSTATUS		     0x0000

#endif   /* NOGDI  */

/* Spooler status notification message */
#define WM_SPOOLERSTATUS	    0x002A

#ifndef NOGDI

/******* GDI Escape support *************************************************/

int     WINAPI Escape(HDC, int, int, LPCSTR, void FAR*);

/* GDI Escapes */
#define NEWFRAME		     1
#define ABORTDOC		     2
#define NEXTBAND		     3
#define SETCOLORTABLE		     4
#define GETCOLORTABLE		     5
#define FLUSHOUTPUT		     6
#define DRAFTMODE		     7
#define QUERYESCSUPPORT 	     8
#define SETABORTPROC		     9
#define STARTDOC		     10
#define ENDDOC			     11
#define GETPHYSPAGESIZE 	     12
#define GETPRINTINGOFFSET	     13
#define GETSCALINGFACTOR	     14
#define MFCOMMENT		     15
#define GETPENWIDTH		     16
#define SETCOPYCOUNT		     17
#define SELECTPAPERSOURCE	     18
#define DEVICEDATA		     19
#define PASSTHROUGH		     19
#define GETTECHNOLGY		     20
#define GETTECHNOLOGY		     20
#define SETENDCAP		     21
#define SETLINEJOIN		     22
#define SETMITERLIMIT		     23
#define BANDINFO		     24
#define DRAWPATTERNRECT 	     25
#define GETVECTORPENSIZE	     26
#define GETVECTORBRUSHSIZE	     27
#define ENABLEDUPLEX		     28
#define GETSETPAPERBINS 	     29
#define GETSETPRINTORIENT	     30
#define ENUMPAPERBINS		     31
#define SETDIBSCALING		     32
#define EPSPRINTING        	     33
#define ENUMPAPERMETRICS   	     34
#define GETSETPAPERMETRICS 	     35
#define POSTSCRIPT_DATA		     37
#define POSTSCRIPT_IGNORE	     38
#define MOUSETRAILS		     39

#define GETEXTENDEDTEXTMETRICS	     256
#define GETEXTENTTABLE		     257
#define GETPAIRKERNTABLE	     258
#define GETTRACKKERNTABLE	     259
#define EXTTEXTOUT		     512
#define ENABLERELATIVEWIDTHS	     768
#define ENABLEPAIRKERNING	     769
#define SETKERNTRACK		     770
#define SETALLJUSTVALUES	     771
#define SETCHARSET		     772

#define STRETCHBLT		     2048

#define GETSETSCREENPARAMS           3072

#define BEGIN_PATH		     4096
#define CLIP_TO_PATH		     4097
#define END_PATH		     4098
#define EXT_DEVICE_CAPS		     4099
#define RESTORE_CTM		     4100
#define SAVE_CTM	             4101
#define SET_ARC_DIRECTION	     4102
#define SET_BACKGROUND_COLOR	     4103
#define SET_POLY_MODE		     4104
#define SET_SCREEN_ANGLE	     4105
#define SET_SPREAD		     4106
#define TRANSFORM_CTM		     4107
#define SET_CLIP_BOX		     4108
#define SET_BOUNDS                   4109

#endif /* NOGDI */

/****** USER typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HWND);

#ifndef NOUSER

DECLARE_HANDLE(HMENU);

DECLARE_HANDLE(HICON);
typedef HICON HCURSOR;	    /* HICONs & HCURSORs are polymorphic */

/****** System Metrics *******************************************************/

#ifndef NOSYSMETRICS

int WINAPI GetSystemMetrics(int);

/* GetSystemMetrics() codes */
#define SM_CXSCREEN	     0
#define SM_CYSCREEN	     1
#define SM_CXVSCROLL	     2
#define SM_CYHSCROLL	     3
#define SM_CYCAPTION	     4
#define SM_CXBORDER	     5
#define SM_CYBORDER	     6
#define SM_CXDLGFRAME	     7
#define SM_CYDLGFRAME	     8
#define SM_CYVTHUMB	     9
#define SM_CXHTHUMB	     10
#define SM_CXICON	     11
#define SM_CYICON	     12
#define SM_CXCURSOR	     13
#define SM_CYCURSOR	     14
#define SM_CYMENU	     15
#define SM_CXFULLSCREEN      16
#define SM_CYFULLSCREEN      17
#define SM_CYKANJIWINDOW     18
#define SM_MOUSEPRESENT      19
#define SM_CYVSCROLL	     20
#define SM_CXHSCROLL	     21
#define SM_DEBUG	     22
#define SM_SWAPBUTTON	     23
#define SM_RESERVED1	     24
#define SM_RESERVED2	     25
#define SM_RESERVED3	     26
#define SM_RESERVED4	     27
#define SM_CXMIN	     28
#define SM_CYMIN	     29
#define SM_CXSIZE	     30
#define SM_CYSIZE	     31
#define SM_CXFRAME	     32
#define SM_CYFRAME	     33
#define SM_CXMINTRACK	     34
#define SM_CYMINTRACK	     35

#if (WINVER >= 0x030a)
#define SM_CXDOUBLECLK       36
#define SM_CYDOUBLECLK       37
#define SM_CXICONSPACING     38
#define SM_CYICONSPACING     39
#define SM_MENUDROPALIGNMENT 40
#define SM_PENWINDOWS        41
#define SM_DBCSENABLED       42
#endif /* WINVER >= 0x030a */

#define SM_CMETRICS	     43

#endif /* NOSYSMETRICS */

UINT    WINAPI GetDoubleClickTime(void);
void    WINAPI SetDoubleClickTime(UINT);

#define WM_DEVMODECHANGE    0x001B
#define WM_TIMECHANGE	    0x001E

/****** System Parameters support ********************************************/

#if (WINVER >= 0x030a)
#ifndef NOSYSTEMPARAMSINFO

BOOL    WINAPI SystemParametersInfo(UINT, UINT, VOID FAR*, UINT);

#define SPI_GETBEEP		    1
#define SPI_SETBEEP		    2
#define SPI_GETMOUSE		    3
#define SPI_SETMOUSE		    4
#define SPI_GETBORDER		    5
#define SPI_SETBORDER		    6
#define SPI_GETKEYBOARDSPEED	    10
#define SPI_SETKEYBOARDSPEED	    11
#define SPI_LANGDRIVER		    12
#define SPI_ICONHORIZONTALSPACING   13
#define SPI_GETSCREENSAVETIMEOUT    14
#define SPI_SETSCREENSAVETIMEOUT    15
#define SPI_GETSCREENSAVEACTIVE     16
#define SPI_SETSCREENSAVEACTIVE     17
#define SPI_GETGRIDGRANULARITY	    18
#define SPI_SETGRIDGRANULARITY	    19
#define SPI_SETDESKWALLPAPER	    20
#define SPI_SETDESKPATTERN	    21
#define SPI_GETKEYBOARDDELAY	    22
#define SPI_SETKEYBOARDDELAY	    23
#define SPI_ICONVERTICALSPACING     24
#define SPI_GETICONTITLEWRAP	    25
#define SPI_SETICONTITLEWRAP	    26
#define SPI_GETMENUDROPALIGNMENT    27
#define SPI_SETMENUDROPALIGNMENT    28
#define SPI_SETDOUBLECLKWIDTH	    29
#define SPI_SETDOUBLECLKHEIGHT	    30
#define SPI_GETICONTITLELOGFONT     31
#define SPI_SETDOUBLECLICKTIME	    32
#define SPI_SETMOUSEBUTTONSWAP	    33
#define SPI_SETICONTITLELOGFONT     34
#define SPI_GETFASTTASKSWITCH       35
#define SPI_SETFASTTASKSWITCH       36

/* SystemParametersInfo flags */
#define SPIF_UPDATEINIFILE	    0x0001
#define SPIF_SENDWININICHANGE	    0x0002

#endif  /* NOSYSTEMPARAMSINFO  */
#endif  /* WINVER >= 0x030a */

/****** Rectangle support ****************************************************/

void    WINAPI SetRect(RECT FAR*, int, int, int, int);
void    WINAPI SetRectEmpty(RECT FAR*);

void    WINAPI CopyRect(RECT FAR*, const RECT FAR*);

BOOL    WINAPI IsRectEmpty(const RECT FAR*);

BOOL    WINAPI EqualRect(const RECT FAR*, const RECT FAR*);

BOOL    WINAPI IntersectRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI UnionRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI SubtractRect(RECT FAR*, const RECT FAR*, const RECT FAR*);

void    WINAPI OffsetRect(RECT FAR*, int, int);
void    WINAPI InflateRect(RECT FAR*, int, int);

BOOL    WINAPI PtInRect(const RECT FAR*, POINT);

/****** Window message support ***********************************************/

UINT WINAPI RegisterWindowMessage(LPCSTR);

#define WM_NULL		    0x0000

/* NOTE: All messages below 0x0400 are RESERVED by Windows */
#define WM_USER		    0x0400

#ifndef NOMSG

/* Queued message structure */
typedef struct tagMSG
{
    HWND	hwnd;
    UINT        message;
    WPARAM	wParam;
    LPARAM	lParam;
    DWORD       time;
    POINT	pt;
} MSG;
typedef MSG* PMSG;
typedef MSG NEAR* NPMSG;
typedef MSG FAR* LPMSG;

BOOL    WINAPI GetMessage(MSG FAR*, HWND, UINT, UINT);
BOOL    WINAPI PeekMessage(MSG FAR*, HWND, UINT, UINT, UINT);

/* PeekMessage() options */
#define PM_NOREMOVE	0x0000
#define PM_REMOVE	0x0001
#define PM_NOYIELD	0x0002

void    WINAPI WaitMessage(void);

DWORD   WINAPI GetMessagePos(void);
LONG    WINAPI GetMessageTime(void);
#if (WINVER >= 0x030a)
LONG    WINAPI GetMessageExtraInfo(void);
#endif /* WINVER >= 0x030a */

BOOL    WINAPI TranslateMessage(const MSG FAR*);
LONG    WINAPI DispatchMessage(const MSG FAR*);

BOOL    WINAPI SetMessageQueue(int);

BOOL    WINAPI GetInputState(void);

#if (WINVER >= 0x030a)
DWORD   WINAPI GetQueueStatus(UINT flags);

/* GetQueueStatus flags */
#define QS_KEY		0x0001
#define QS_MOUSEMOVE	0x0002
#define QS_MOUSEBUTTON	0x0004
#define QS_MOUSE	(QS_MOUSEMOVE | QS_MOUSEBUTTON)
#define QS_POSTMESSAGE	0x0008
#define QS_TIMER	0x0010
#define QS_PAINT	0x0020
#define QS_SENDMESSAGE	0x0040

#define QS_ALLINPUT     0x007f
#endif  /* WINVER >= 0x030a */

#endif   /* NOMSG */

BOOL    WINAPI PostMessage(HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI SendMessage(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG

BOOL    WINAPI PostAppMessage(HTASK, UINT, WPARAM, LPARAM);

void    WINAPI ReplyMessage(LRESULT);
BOOL    WINAPI InSendMessage(void);

/* Special HWND value for use with PostMessage() and SendMessage() */
#define HWND_BROADCAST	((HWND)0xffff)

BOOL WINAPI CallMsgFilter(MSG FAR*, int);

#define WH_GETMESSAGE	    3

#define WH_CALLWNDPROC	    4

#define WH_MSGFILTER	    (-1)
#define WH_SYSMSGFILTER	    6

/* CallMsgFilter() and WH_SYS/MSGFILTER context codes */
#define MSGF_DIALOGBOX		 0
#define MSGF_MENU		 2
#define MSGF_MOVE		 3
#define MSGF_SIZE		 4
#define MSGF_SCROLLBAR		 5
#define MSGF_NEXTWINDOW 	 6
#define MSGF_MAINLOOP            8
#define MSGF_USER                4096
#endif /* NOMSG */

/* Standard window messages */
/* PenWindows specific messages */
#define WM_PENWINFIRST	    0x0380
#define WM_PENWINLAST	    0x038F

/* Coalescing messages */
#define WM_COALESCE_FIRST   0x0390
#define WM_COALESCE_LAST    0x039F


#if (WINVER >= 0x030a)
/****** Power management ****************************************************/
#define WM_POWER	    0x0048

/* wParam for WM_POWER window message and DRV_POWER driver notification */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITIALRESUME   3
#endif  /* WINVER >= 0x030a */

/****** Application termination *********************************************/

#define WM_QUERYENDSESSION  0x0011
#define WM_ENDSESSION	    0x0016

#define WM_QUIT		    0x0012

void    WINAPI PostQuitMessage(int);

#define WM_SYSTEMERROR	    0x0017

/****** Window class management *********************************************/

#ifdef STRICT
typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);
#else
typedef FARPROC WNDPROC;
#endif

typedef struct tagWNDCLASS
{
    UINT        style;
#ifdef STRICT
    WNDPROC	lpfnWndProc;
#else
    LRESULT     (CALLBACK* lpfnWndProc)();
#endif
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE	hInstance;
    HICON	hIcon;
    HCURSOR	hCursor;
    HBRUSH	hbrBackground;
    LPCSTR	lpszMenuName;
    LPCSTR	lpszClassName;
} WNDCLASS;
typedef WNDCLASS* PWNDCLASS;
typedef WNDCLASS NEAR* NPWNDCLASS;
typedef WNDCLASS FAR* LPWNDCLASS;

ATOM    WINAPI RegisterClass(const WNDCLASS FAR*);
BOOL    WINAPI UnregisterClass(LPCSTR, HINSTANCE);

BOOL    WINAPI GetClassInfo(HINSTANCE, LPCSTR, WNDCLASS FAR*);
int     WINAPI GetClassName(HWND, LPSTR, int);

#ifndef NOWINSTYLES

/* Class styles */
#define CS_VREDRAW	    0x0001
#define CS_HREDRAW	    0x0002

#define CS_OWNDC	    0x0020
#define CS_CLASSDC	    0x0040
#define CS_PARENTDC	    0x0080

#define CS_SAVEBITS	    0x0800

#define CS_DBLCLKS	    0x0008

#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000

#define CS_NOCLOSE	    0x0200

#define CS_KEYCVTWINDOW     0x0004
#define CS_NOKEYCVT	    0x0100

#define CS_GLOBALCLASS	    0x4000
#endif	/* NOWINSTYLES */

#ifndef NOWINOFFSETS

#ifdef STRICT
WPARAM  WINAPI GetClassWord(HWND, int);
WPARAM  WINAPI SetClassWord(HWND, int, WPARAM);
LPARAM  WINAPI GetClassLong(HWND, int);
LPARAM  WINAPI SetClassLong(HWND, int, LPARAM);
#else
UINT    WINAPI GetClassWord(HWND, int);
UINT    WINAPI SetClassWord(HWND, int, UINT);
LONG    WINAPI GetClassLong(HWND, int);
LONG    WINAPI SetClassLong(HWND, int, LONG);
#endif

/* Class field offsets for GetClassLong() and GetClassWord() */
#define GCL_MENUNAME	    (-8)
#define GCW_HBRBACKGROUND   (-10)
#define GCW_HCURSOR	    (-12)
#define GCW_HICON	    (-14)
#define GCW_HMODULE	    (-16)
#define GCW_CBWNDEXTRA	    (-18)
#define GCW_CBCLSEXTRA	    (-20)
#define GCL_WNDPROC	    (-24)
#define GCW_STYLE	    (-26)

#if (WINVER >= 0x030a)
#define GCW_ATOM            (-32)
#endif

#endif	/* NOWINOFFSETS */

/****** Window creation/destroy *********************************************/

/* Window Styles */
#ifndef NOWINSTYLES

/* Basic window types */
#define WS_OVERLAPPED	    0x00000000L
#define WS_POPUP	    0x80000000L
#define WS_CHILD	    0x40000000L

/* Clipping styles */
#define WS_CLIPSIBLINGS     0x04000000L
#define WS_CLIPCHILDREN     0x02000000L

/* Generic window states */
#define WS_VISIBLE	    0x10000000L
#define WS_DISABLED	    0x08000000L

/* Main window states */
#define WS_MINIMIZE	    0x20000000L
#define WS_MAXIMIZE	    0x01000000L

/* Main window styles */
#define WS_CAPTION	    0x00C00000L     /* WS_BORDER | WS_DLGFRAME	*/
#define WS_BORDER	    0x00800000L
#define WS_DLGFRAME	    0x00400000L
#define WS_VSCROLL	    0x00200000L
#define WS_HSCROLL	    0x00100000L
#define WS_SYSMENU	    0x00080000L
#define WS_THICKFRAME	    0x00040000L
#define WS_MINIMIZEBOX	    0x00020000L
#define WS_MAXIMIZEBOX	    0x00010000L

/* Control window styles */
#define WS_GROUP	    0x00020000L
#define WS_TABSTOP	    0x00010000L

/* Common Window Styles */
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW	    (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW	    (WS_CHILD)

/* Extended Window Styles */
#define WS_EX_DLGMODALFRAME  0x00000001L
#define WS_EX_NOPARENTNOTIFY 0x00000004L

#if (WINVER >= 0x030a)
#define WS_EX_TOPMOST	     0x00000008L
#define WS_EX_ACCEPTFILES    0x00000010L
#define WS_EX_TRANSPARENT    0x00000020L
#endif /* WINVER >= 0x030a */

/* Obsolete style names */
#define WS_TILED	    WS_OVERLAPPED
#define WS_ICONIC	    WS_MINIMIZE
#define WS_SIZEBOX	    WS_THICKFRAME
#define WS_TILEDWINDOW	    WS_OVERLAPPEDWINDOW


#endif /* NOWINSTYLES */

/* Special value for CreateWindow, et al. */
#define HWND_DESKTOP	    ((HWND)NULL)

BOOL    WINAPI IsWindow(HWND);

HWND    WINAPI CreateWindowEx(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);
HWND    WINAPI CreateWindow(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);

#define WM_CREATE	    0x0001
#define WM_NCCREATE	    0x0081

/* WM_CREATE/WM_NCCREATE lParam struct */
typedef struct tagCREATESTRUCT
{
    void FAR* lpCreateParams;
    HINSTANCE hInstance;
    HMENU     hMenu;
    HWND      hwndParent;
    int       cy;
    int       cx;
    int       y;
    int       x;
    LONG      style;
    LPCSTR    lpszName;
    LPCSTR    lpszClass;
    DWORD     dwExStyle;
} CREATESTRUCT;
typedef CREATESTRUCT FAR* LPCREATESTRUCT;

BOOL    WINAPI DestroyWindow(HWND);

#define WM_DESTROY	    0x0002
#define WM_NCDESTROY	    0x0082

/* Basic window attributes */

HTASK   WINAPI GetWindowTask(HWND);

BOOL    WINAPI IsChild(HWND, HWND);

HWND    WINAPI GetParent(HWND);
HWND    WINAPI SetParent(HWND, HWND);

BOOL    WINAPI IsWindowVisible(HWND);

BOOL    WINAPI ShowWindow(HWND, int);


#ifndef NOSHOWWINDOW

#define SW_HIDE		    0
#define SW_SHOWNORMAL	    1
#define SW_NORMAL	    1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE	    3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW		    5
#define SW_MINIMIZE	    6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA	    8
#define SW_RESTORE          9

/* Obsolete ShowWindow() command names */
#define HIDE_WINDOW	    0
#define SHOW_OPENWINDOW     1
#define SHOW_ICONWINDOW     2
#define SHOW_FULLSCREEN     3
#define SHOW_OPENNOACTIVATE 4

#define WM_SHOWWINDOW	    0x0018

/* WM_SHOWWINDOW wParam codes */
#define SW_PARENTCLOSING    1
#define SW_OTHERMAXIMIZED   2
#define SW_PARENTOPENING    3
#define SW_OTHERRESTORED    4

/* Obsolete constant names */
#define SW_OTHERZOOM	    SW_OTHERMAXIMIZED
#define SW_OTHERUNZOOM	    SW_OTHERRESTORED
#endif	/* NOSHOWWINDOW */

#define WM_SETREDRAW	    0x000B

/* Enabled state */
BOOL    WINAPI EnableWindow(HWND,BOOL);
BOOL    WINAPI IsWindowEnabled(HWND);

#define WM_ENABLE	    0x000A

/* Window text */
void    WINAPI SetWindowText(HWND, LPCSTR);
int     WINAPI GetWindowText(HWND, LPSTR, int);
int     WINAPI GetWindowTextLength(HWND);

#define WM_SETTEXT	    0x000C
#define WM_GETTEXT	    0x000D
#define WM_GETTEXTLENGTH    0x000E

/* Window words */
WORD    WINAPI GetWindowWord(HWND, int);
WORD    WINAPI SetWindowWord(HWND, int, WORD);
LONG    WINAPI GetWindowLong(HWND, int);
LONG    WINAPI SetWindowLong(HWND, int, LONG);

/* Window field offsets for GetWindowLong() and GetWindowWord() */
#ifndef NOWINOFFSETS
#define GWL_WNDPROC	    (-4)
#define GWW_HINSTANCE	    (-6)
#define GWW_HWNDPARENT	    (-8)
#define GWW_ID		    (-12)
#define GWL_STYLE	    (-16)
#define GWL_EXSTYLE	    (-20)
#endif /* NOWINOFFSETS */

/****** Window size, position, Z-order, and visibility **********************/

#define CW_USEDEFAULT	    ((int)0x8000)

void    WINAPI GetClientRect(HWND, RECT FAR*);
void    WINAPI GetWindowRect(HWND, RECT FAR*);


#if (WINVER >= 0x030a)
typedef struct tagWINDOWPLACEMENT
{
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT     *PWINDOWPLACEMENT;
typedef WINDOWPLACEMENT FAR* LPWINDOWPLACEMENT;

BOOL    WINAPI GetWindowPlacement(HWND, WINDOWPLACEMENT FAR*);
BOOL    WINAPI SetWindowPlacement(HWND, WINDOWPLACEMENT FAR*);
#endif /* WINVER >= 0x030a */


BOOL    WINAPI SetWindowPos(HWND, HWND, int, int, int, int, UINT);

/* SetWindowPos() and WINDOWPOS flags */
#define SWP_NOSIZE	    0x0001
#define SWP_NOMOVE	    0x0002
#define SWP_NOZORDER	    0x0004
#define SWP_NOREDRAW	    0x0008
#define SWP_NOACTIVATE	    0x0010
#define SWP_FRAMECHANGED    0x0020  /* The frame changed: send WM_NCCALCSIZE */
#define SWP_SHOWWINDOW	    0x0040
#define SWP_HIDEWINDOW	    0x0080
#define SWP_NOCOPYBITS	    0x0100
#define SWP_NOOWNERZORDER   0x0200  /* Don't do owner Z ordering */

#define SWP_DRAWFRAME	    SWP_FRAMECHANGED
#define SWP_NOREPOSITION    SWP_NOOWNERZORDER


/* SetWindowPos() hwndInsertAfter field values */
#define HWND_TOP	    ((HWND)NULL)
#define HWND_BOTTOM	    ((HWND)1)
#define HWND_TOPMOST        ((HWND)-1)
#define HWND_NOTOPMOST      ((HWND)-2)

#ifndef NODEFERWINDOWPOS

DECLARE_HANDLE(HDWP);

HDWP    WINAPI BeginDeferWindowPos(int);
HDWP    WINAPI DeferWindowPos(HDWP, HWND, HWND, int, int, int, int, UINT);
BOOL    WINAPI EndDeferWindowPos(HDWP);

#endif /* NODEFERWINDOWPOS */

BOOL    WINAPI MoveWindow(HWND, int, int, int, int, BOOL);
BOOL    WINAPI BringWindowToTop(HWND);

#if (WINVER >= 0x030a)

#define WM_WINDOWPOSCHANGING 0x0046
#define WM_WINDOWPOSCHANGED 0x0047

/* WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam */
typedef struct tagWINDOWPOS
{
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS;
typedef WINDOWPOS FAR* LPWINDOWPOS;
#endif /* WINVER >= 0x030a */

#define WM_MOVE		    0x0003
#define WM_SIZE		    0x0005

/* WM_SIZE message wParam values */
#define SIZE_RESTORED	    0
#define SIZE_MINIMIZED	    1
#define SIZE_MAXIMIZED	    2
#define SIZE_MAXSHOW	    3
#define SIZE_MAXHIDE	    4

/* Obsolete constant names */
#define SIZENORMAL	    SIZE_RESTORED
#define SIZEICONIC	    SIZE_MINIMIZED
#define SIZEFULLSCREEN	    SIZE_MAXIMIZED
#define SIZEZOOMSHOW	    SIZE_MAXSHOW
#define SIZEZOOMHIDE	    SIZE_MAXHIDE

/****** Window proc implementation & subclassing support *********************/

LRESULT WINAPI DefWindowProc(HWND, UINT, WPARAM, LPARAM);

LRESULT WINAPI CallWindowProc(WNDPROC, HWND, UINT, WPARAM, LPARAM);

/****** Main window support **************************************************/

void    WINAPI AdjustWindowRect(RECT FAR*, DWORD, BOOL);
void    WINAPI AdjustWindowRectEx(RECT FAR*, DWORD, BOOL, DWORD);

#define WM_QUERYOPEN	    0x0013
#define WM_CLOSE	    0x0010

/* Struct pointed to by WM_GETMINMAXINFO lParam */
typedef struct tagMINMAXINFO
{
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO;
#define WM_GETMINMAXINFO    0x0024


BOOL    WINAPI FlashWindow(HWND, BOOL);

void    WINAPI ShowOwnedPopups(HWND, BOOL);

/* Obsolete functions */
BOOL    WINAPI OpenIcon(HWND);
void    WINAPI CloseWindow(HWND);
BOOL    WINAPI AnyPopup(void);
BOOL    WINAPI IsIconic(HWND);
BOOL    WINAPI IsZoomed(HWND);

/****** Window coordinate mapping and hit-testing ***************************/

void    WINAPI ClientToScreen(HWND, POINT FAR*);
void    WINAPI ScreenToClient(HWND, POINT FAR*);

#if (WINVER >= 0x030a)
void    WINAPI MapWindowPoints(HWND hwndFrom, HWND hwndTo, POINT FAR* lppt, UINT cpt);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI WindowFromPoint(POINT);
HWND    WINAPI ChildWindowFromPoint(HWND, POINT);

/****** Window query and enumeration ****************************************/

HWND    WINAPI GetDesktopWindow(void);

HWND    WINAPI FindWindow(LPCSTR, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND, LPARAM);
#else
typedef FARPROC WNDENUMPROC;
#endif

BOOL    WINAPI EnumWindows(WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumChildWindows(HWND, WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumTaskWindows(HTASK, WNDENUMPROC, LPARAM);

HWND    WINAPI GetTopWindow(HWND);

HWND    WINAPI GetWindow(HWND, UINT);
HWND    WINAPI GetNextWindow(HWND, UINT);

/* GetWindow() constants */
#define GW_HWNDFIRST	0
#define GW_HWNDLAST	1
#define GW_HWNDNEXT	2
#define GW_HWNDPREV	3
#define GW_OWNER	4
#define GW_CHILD	5


/****** Window property support *********************************************/

BOOL    WINAPI SetProp(HWND, LPCSTR, HANDLE);
HANDLE  WINAPI GetProp(HWND, LPCSTR);
HANDLE  WINAPI RemoveProp(HWND, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* PROPENUMPROC)(HWND, LPCSTR, HANDLE);
#else
typedef FARPROC PROPENUMPROC;
#endif

int     WINAPI EnumProps(HWND, PROPENUMPROC);

/****** Window drawing support **********************************************/

HDC     WINAPI GetDC(HWND);
int     WINAPI ReleaseDC(HWND, HDC);

HDC     WINAPI GetWindowDC(HWND);

#if (WINVER >= 0x030a)
HDC     WINAPI GetDCEx(register HWND hwnd, HRGN hrgnClip, DWORD flags);

#define DCX_WINDOW	    0x00000001L
#define DCX_CACHE	    0x00000002L
#define DCX_NORESETATTRS    0x00000004L
#define DCX_CLIPCHILDREN    0x00000008L
#define DCX_CLIPSIBLINGS    0x00000010L
#define DCX_PARENTCLIP	    0x00000020L

#define DCX_EXCLUDERGN	    0x00000040L
#define DCX_INTERSECTRGN    0x00000080L


#define DCX_LOCKWINDOWUPDATE 0x00000400L


#define DCX_USESTYLE	    0x00010000L
#define DCX_NORECOMPUTE     0x00100000L
#define DCX_VALIDATE	    0x00200000L

#endif  /* WINVER >= 0x030a */

/****** Window repainting ***************************************************/

#define WM_PAINT	    0x000F
#define WM_ERASEBKGND	    0x0014
#define WM_ICONERASEBKGND   0x0027

/* BeginPaint() return structure */
typedef struct tagPAINTSTRUCT
{
    HDC 	hdc;
    BOOL	fErase;
    RECT	rcPaint;
    BOOL	fRestore;
    BOOL	fIncUpdate;
    BYTE	rgbReserved[16];
} PAINTSTRUCT;
typedef PAINTSTRUCT* PPAINTSTRUCT;
typedef PAINTSTRUCT NEAR* NPPAINTSTRUCT;
typedef PAINTSTRUCT FAR* LPPAINTSTRUCT;

HDC     WINAPI BeginPaint(HWND, PAINTSTRUCT FAR*);
void    WINAPI EndPaint(HWND, const PAINTSTRUCT FAR*);

void    WINAPI UpdateWindow(HWND);

int     WINAPI ExcludeUpdateRgn(HDC, HWND);

#if (WINVER >= 0x030a)
BOOL    WINAPI LockWindowUpdate(HWND hwndLock);
#endif

BOOL    WINAPI GetUpdateRect(HWND, RECT FAR*, BOOL);
int     WINAPI GetUpdateRgn(HWND, HRGN, BOOL);

void    WINAPI InvalidateRect(HWND, const RECT FAR*, BOOL);
void    WINAPI ValidateRect(HWND, const RECT FAR*);

void    WINAPI InvalidateRgn(HWND, HRGN, BOOL);
void    WINAPI ValidateRgn(HWND, HRGN);

#if (WINVER >= 0x030a)
BOOL    WINAPI RedrawWindow(HWND hwnd, const RECT FAR* lprcUpdate, HRGN hrgnUpdate, UINT flags);

#define RDW_INVALIDATE		0x0001
#define RDW_INTERNALPAINT	0x0002
#define RDW_ERASE		0x0004

#define RDW_VALIDATE		0x0008
#define RDW_NOINTERNALPAINT	0x0010
#define RDW_NOERASE		0x0020

#define RDW_NOCHILDREN		0x0040
#define RDW_ALLCHILDREN 	0x0080

#define RDW_UPDATENOW		0x0100
#define RDW_ERASENOW		0x0200

#define RDW_FRAME               0x0400
#define RDW_NOFRAME             0x0800

#endif /* WINVER >= 0x030a */

/****** Window scrolling ****************************************************/

void    WINAPI ScrollWindow(HWND, int, int, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI ScrollDC(HDC, int, int, const RECT FAR*, const RECT FAR*, HRGN, RECT FAR*);

#if (WINVER >= 0x030a)

int     WINAPI ScrollWindowEx(HWND hwnd, int dx, int dy,
                const RECT FAR* prcScroll, const RECT FAR* prcClip,
                HRGN hrgnUpdate, RECT FAR* prcUpdate, UINT flags);

#define SW_SCROLLCHILDREN   0x0001
#define SW_INVALIDATE       0x0002
#define SW_ERASE            0x0004


#endif /* WINVER >= 0x030a */

/****** Non-client window area management ************************************/

#define WM_NCPAINT	    0x0085

#define WM_NCCALCSIZE	    0x0083

#if (WINVER >= 0x030a)
/* WM_NCCALCSIZE return flags */
#define WVR_ALIGNTOP	    0x0010
#define WVR_ALIGNLEFT	    0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT	    0x0080
#define WVR_HREDRAW	    0x0100
#define WVR_VREDRAW	    0x0200
#define WVR_REDRAW	    (WVR_HREDRAW | WVR_VREDRAW)
#define WVR_VALIDRECTS	    0x0400


/* WM_NCCALCSIZE parameter structure */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT	   rgrc[3];
    WINDOWPOS FAR* lppos;
} NCCALCSIZE_PARAMS;
#else   /* WINVER >= 0x030a */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[2];
} NCCALCSIZE_PARAMS;
#endif  /* WINVER >= 0x030a */
typedef NCCALCSIZE_PARAMS FAR* LPNCCALCSIZE_PARAMS;

#define WM_NCHITTEST	    0x0084

/* WM_NCHITTEST return codes */
#define HTERROR 	    (-2)
#define HTTRANSPARENT	    (-1)
#define HTNOWHERE	    0
#define HTCLIENT	    1
#define HTCAPTION	    2
#define HTSYSMENU	    3
#define HTSIZE		    4
#define HTMENU		    5
#define HTHSCROLL	    6
#define HTVSCROLL	    7
#define HTMINBUTTON	    8
#define HTMAXBUTTON	    9
#define HTLEFT		    10
#define HTRIGHT 	    11
#define HTTOP		    12
#define HTTOPLEFT	    13
#define HTTOPRIGHT	    14
#define HTBOTTOM	    15
#define HTBOTTOMLEFT	    16
#define HTBOTTOMRIGHT	    17
#define HTBORDER	    18
#define HTGROWBOX	    HTSIZE
#define HTREDUCE	    HTMINBUTTON
#define HTZOOM		    HTMAXBUTTON

/****** Drag-and-drop support ***********************************************/

#define WM_QUERYDRAGICON    0x0037
#define WM_DROPFILES	    0x0233

/****** Window activation ***************************************************/

HWND    WINAPI SetActiveWindow(HWND);
HWND    WINAPI GetActiveWindow(void);

HWND    WINAPI GetLastActivePopup(HWND);

/* WM_ACTIVATE state values */
#define WA_INACTIVE	    0
#define WA_ACTIVE	    1
#define WA_CLICKACTIVE	    2

#define WM_ACTIVATE	    0x0006
#define WM_ACTIVATEAPP	    0x001C
#define WM_NCACTIVATE	    0x0086

/****** Keyboard input support **********************************************/

HWND    WINAPI SetFocus(HWND);
HWND    WINAPI GetFocus(void);

int     WINAPI GetKeyState(int);
int     WINAPI GetAsyncKeyState(int);

void    WINAPI GetKeyboardState(BYTE FAR* );
void    WINAPI SetKeyboardState(BYTE FAR* );

#define WM_SETFOCUS	    0x0007
#define WM_KILLFOCUS	    0x0008

#define WM_KEYDOWN	    0x0100
#define WM_KEYUP	    0x0101

#define WM_CHAR		    0x0102
#define WM_DEADCHAR	    0x0103

#define WM_SYSKEYDOWN	    0x0104
#define WM_SYSKEYUP	    0x0105

#define WM_SYSCHAR	    0x0106
#define WM_SYSDEADCHAR	    0x0107


/* Keyboard message range */
#define WM_KEYFIRST	    0x0100
#define WM_KEYLAST	    0x0108

/* WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags */
#define KF_EXTENDED	    0x0100
#define KF_DLGMODE	    0x0800
#define KF_MENUMODE	    0x1000
#define KF_ALTDOWN	    0x2000
#define KF_REPEAT	    0x4000
#define KF_UP		    0x8000

/* Virtual key codes */
#ifndef NOVIRTUALKEYCODES
#define VK_LBUTTON	    0x01
#define VK_RBUTTON	    0x02
#define VK_CANCEL	    0x03
#define VK_MBUTTON          0x04
#define VK_BACK 	    0x08
#define VK_TAB		    0x09
#define VK_CLEAR	    0x0C
#define VK_RETURN	    0x0D
#define VK_SHIFT	    0x10
#define VK_CONTROL	    0x11
#define VK_MENU 	    0x12
#define VK_PAUSE	    0x13
#define VK_CAPITAL	    0x14
#define VK_ESCAPE	    0x1B
#define VK_SPACE	    0x20
#define VK_PRIOR	    0x21
#define VK_NEXT 	    0x22
#define VK_END		    0x23
#define VK_HOME 	    0x24
#define VK_LEFT 	    0x25
#define VK_UP		    0x26
#define VK_RIGHT	    0x27
#define VK_DOWN 	    0x28
#define VK_SELECT	    0x29
#define VK_PRINT	    0x2A
#define VK_EXECUTE	    0x2B
#define VK_SNAPSHOT	    0x2C
#define VK_INSERT	    0x2D
#define VK_DELETE	    0x2E
#define VK_HELP 	    0x2F
#define VK_NUMPAD0	    0x60
#define VK_NUMPAD1	    0x61
#define VK_NUMPAD2	    0x62
#define VK_NUMPAD3	    0x63
#define VK_NUMPAD4	    0x64
#define VK_NUMPAD5	    0x65
#define VK_NUMPAD6	    0x66
#define VK_NUMPAD7	    0x67
#define VK_NUMPAD8	    0x68
#define VK_NUMPAD9	    0x69
#define VK_MULTIPLY	    0x6A
#define VK_ADD		    0x6B
#define VK_SEPARATOR	    0x6C
#define VK_SUBTRACT	    0x6D
#define VK_DECIMAL	    0x6E
#define VK_DIVIDE	    0x6F
#define VK_F1		    0x70
#define VK_F2		    0x71
#define VK_F3		    0x72
#define VK_F4		    0x73
#define VK_F5		    0x74
#define VK_F6		    0x75
#define VK_F7		    0x76
#define VK_F8		    0x77
#define VK_F9		    0x78
#define VK_F10		    0x79
#define VK_F11		    0x7A
#define VK_F12		    0x7B
#define VK_F13		    0x7C
#define VK_F14		    0x7D
#define VK_F15		    0x7E
#define VK_F16		    0x7F
#define VK_F17		    0x80
#define VK_F18		    0x81
#define VK_F19		    0x82
#define VK_F20		    0x83
#define VK_F21		    0x84
#define VK_F22		    0x85
#define VK_F23		    0x86
#define VK_F24		    0x87
#define VK_NUMLOCK	    0x90
#define VK_SCROLL           0x91

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' */

#endif /* NOVIRTUALKEYCODES */


/* SetWindowsHook() keyboard hook */
#define WH_KEYBOARD	    2

/****** Mouse input support *************************************************/

HWND    WINAPI SetCapture(HWND);
void    WINAPI ReleaseCapture(void);
HWND    WINAPI GetCapture(void);

BOOL    WINAPI SwapMouseButton(BOOL);

/* Mouse input messages */
#define WM_MOUSEMOVE	    0x0200
#define WM_LBUTTONDOWN	    0x0201
#define WM_LBUTTONUP	    0x0202
#define WM_LBUTTONDBLCLK    0x0203
#define WM_RBUTTONDOWN	    0x0204
#define WM_RBUTTONUP	    0x0205
#define WM_RBUTTONDBLCLK    0x0206
#define WM_MBUTTONDOWN	    0x0207
#define WM_MBUTTONUP	    0x0208
#define WM_MBUTTONDBLCLK    0x0209

/* Mouse input message range */
#define WM_MOUSEFIRST	    0x0200
#define WM_MOUSELAST	    0x0209

/* Mouse message wParam key states */
#ifndef NOKEYSTATES
#define MK_LBUTTON	    0x0001
#define MK_RBUTTON	    0x0002
#define MK_SHIFT	    0x0004
#define MK_CONTROL	    0x0008
#define MK_MBUTTON	    0x0010
#endif /* NOKEYSTATES */

/* Non-client mouse messages */
#define WM_NCMOUSEMOVE	    0x00A0
#define WM_NCLBUTTONDOWN    0x00A1
#define WM_NCLBUTTONUP	    0x00A2
#define WM_NCLBUTTONDBLCLK  0x00A3
#define WM_NCRBUTTONDOWN    0x00A4
#define WM_NCRBUTTONUP	    0x00A5
#define WM_NCRBUTTONDBLCLK  0x00A6
#define WM_NCMBUTTONDOWN    0x00A7
#define WM_NCMBUTTONUP	    0x00A8
#define WM_NCMBUTTONDBLCLK  0x00A9

/* Mouse click activation support */
#define WM_MOUSEACTIVATE    0x0021

/* WM_MOUSEACTIVATE return codes */
#define MA_ACTIVATE	    1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE	    3
#if (WINVER >= 0x030a)
#define MA_NOACTIVATEANDEAT 4
#endif /* WINVER >= 0x030a */

/* SetWindowsHook() mouse hook */
#ifndef NOWH
#define WH_MOUSE	    7

typedef struct tagMOUSEHOOKSTRUCT
{
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT;
typedef MOUSEHOOKSTRUCT  FAR* LPMOUSEHOOKSTRUCT;
#endif	/* NOWH */

/****** Mode control ********************************************************/

#define WM_CANCELMODE	    0x001F

/****** System modal window support *****************************************/

HWND    WINAPI GetSysModalWindow(void);
HWND    WINAPI SetSysModalWindow(HWND);

/****** Timer support *******************************************************/

#ifdef STRICT
typedef void (CALLBACK* TIMERPROC)(HWND, UINT, UINT, DWORD);
#else
typedef FARPROC TIMERPROC;
#endif

UINT    WINAPI SetTimer(HWND, UINT, UINT, TIMERPROC);

BOOL    WINAPI KillTimer(HWND, UINT);

#define WM_TIMER	    0x0113

/****** Accelerator support *************************************************/

DECLARE_HANDLE(HACCEL);

HACCEL  WINAPI LoadAccelerators(HINSTANCE, LPCSTR);

#ifndef NOMSG
int     WINAPI TranslateAccelerator(HWND, HACCEL, MSG FAR*);
#endif

/****** Menu support ********************************************************/

#ifndef NOMENUS

/* Menu template header */
typedef struct 
{
    UINT    versionNumber;
    UINT    offset;
} MENUITEMTEMPLATEHEADER;

/* Menu template item struct */
typedef struct
{
    UINT    mtOption;
    UINT    mtID;
    LPSTR   mtString;
} MENUITEMTEMPLATE;

#if (WINVER >= 0x030a)
BOOL    WINAPI IsMenu(HMENU);
#endif /* WINVER >= 0x030a */

HMENU   WINAPI CreateMenu(void);
HMENU   WINAPI CreatePopupMenu(void);
HMENU   WINAPI LoadMenu(HINSTANCE, LPCSTR);
HMENU   WINAPI LoadMenuIndirect(const void FAR*);

BOOL    WINAPI DestroyMenu(HMENU);

HMENU   WINAPI GetMenu(HWND);
BOOL    WINAPI SetMenu(HWND, HMENU);

HMENU   WINAPI GetSystemMenu(HWND, BOOL);

void    WINAPI DrawMenuBar(HWND);

BOOL    WINAPI HiliteMenuItem(HWND, HMENU, UINT, UINT);

BOOL    WINAPI InsertMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI AppendMenu(HMENU, UINT, UINT, LPCSTR);
BOOL    WINAPI ModifyMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI RemoveMenu(HMENU, UINT, UINT);
BOOL    WINAPI DeleteMenu(HMENU, UINT, UINT);

BOOL    WINAPI ChangeMenu(HMENU, UINT, LPCSTR, UINT, UINT);

#define MF_INSERT	    0x0000
#define MF_CHANGE	    0x0080
#define MF_APPEND	    0x0100
#define MF_DELETE	    0x0200
#define MF_REMOVE	    0x1000

/* Menu flags for Add/Check/EnableMenuItem() */
#define MF_BYCOMMAND	    0x0000
#define MF_BYPOSITION	    0x0400

#define MF_SEPARATOR	    0x0800

#define MF_ENABLED	    0x0000
#define MF_GRAYED	    0x0001
#define MF_DISABLED	    0x0002

#define MF_UNCHECKED	    0x0000
#define MF_CHECKED	    0x0008
#define MF_USECHECKBITMAPS  0x0200

#define MF_STRING	    0x0000
#define MF_BITMAP	    0x0004
#define MF_OWNERDRAW	    0x0100

#define MF_POPUP	    0x0010
#define MF_MENUBARBREAK     0x0020
#define MF_MENUBREAK	    0x0040

#define MF_UNHILITE	    0x0000
#define MF_HILITE	    0x0080

#define MF_SYSMENU	    0x2000
#define MF_HELP 	    0x4000
#define MF_MOUSESELECT	    0x8000


#define MF_END		    0x0080  /* Only valid in menu resource templates */

BOOL    WINAPI EnableMenuItem(HMENU, UINT, UINT);
BOOL    WINAPI CheckMenuItem(HMENU, UINT, UINT);

HMENU   WINAPI GetSubMenu(HMENU, int);

int     WINAPI GetMenuItemCount(HMENU);
UINT    WINAPI GetMenuItemID(HMENU, int);

int     WINAPI GetMenuString(HMENU, UINT, LPSTR, int, UINT);
UINT    WINAPI GetMenuState(HMENU, UINT, UINT);

BOOL    WINAPI SetMenuItemBitmaps(HMENU, UINT, UINT, HBITMAP, HBITMAP);
DWORD   WINAPI GetMenuCheckMarkDimensions(void);

BOOL    WINAPI TrackPopupMenu(HMENU, UINT, int, int, int, HWND, const RECT FAR*);

/* Flags for TrackPopupMenu */
#define TPM_LEFTBUTTON  0x0000
#if (WINVER >= 0x030a)
#define TPM_RIGHTBUTTON 0x0002
#define TPM_LEFTALIGN   0x0000
#define TPM_CENTERALIGN 0x0004
#define TPM_RIGHTALIGN  0x0008
#endif /* WINVER >= 0x030a */

#endif  /* NOMENUS */

/* Menu messages */
#define WM_INITMENU	    0x0116
#define WM_INITMENUPOPUP    0x0117

#ifndef NOMENUS

#define WM_MENUSELECT	    0x011F
#define WM_MENUCHAR	    0x0120

#endif /* NOMENUS */

/* Menu and control command messages */
#define WM_COMMAND	    0x0111

/****** Scroll bar support **************************************************/

#ifndef NOSCROLL

#define WM_HSCROLL	    0x0114
#define WM_VSCROLL	    0x0115

/* WM_H/VSCROLL commands */
#define SB_LINEUP	    0
#define SB_LINELEFT	    0
#define SB_LINEDOWN	    1
#define SB_LINERIGHT	    1
#define SB_PAGEUP	    2
#define SB_PAGELEFT	    2
#define SB_PAGEDOWN	    3
#define SB_PAGERIGHT	    3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK	    5
#define SB_TOP		    6
#define SB_LEFT 	    6
#define SB_BOTTOM	    7
#define SB_RIGHT	    7
#define SB_ENDSCROLL	    8

/* Scroll bar selection constants */
#define SB_HORZ		    0
#define SB_VERT		    1
#define SB_CTL		    2
#define SB_BOTH		    3

int     WINAPI SetScrollPos(HWND, int, int, BOOL);
int     WINAPI GetScrollPos(HWND, int);
void    WINAPI SetScrollRange(HWND, int, int, int, BOOL);
void    WINAPI GetScrollRange(HWND, int, int FAR*, int FAR*);
void    WINAPI ShowScrollBar(HWND, int, BOOL);
BOOL    WINAPI EnableScrollBar(HWND, int, UINT);

/* EnableScrollBar() flags */
#define ESB_ENABLE_BOTH     0x0000
#define ESB_DISABLE_BOTH    0x0003

#define ESB_DISABLE_LEFT    0x0001
#define ESB_DISBALE_RIGHT   0x0002

#define ESB_DISABLE_UP      0x0001
#define ESB_DISABLE_DOWN    0x0002

#define ESB_DISABLE_LTUP    ESB_DISABLE_LEFT
#define ESB_DISABLE_RTDN    ESB_DISABLE_RIGHT

#endif  /* NOSCROLL */

/******* Clipboard manager **************************************************/

#ifndef NOCLIPBOARD

/* Predefined Clipboard Formats */
#define CF_TEXT 	     1
#define CF_BITMAP	     2
#define CF_METAFILEPICT      3
#define CF_SYLK 	     4
#define CF_DIF		     5
#define CF_TIFF 	     6
#define CF_OEMTEXT	     7
#define CF_DIB		     8
#define CF_PALETTE	     9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT	    0x0081
#define CF_DSPBITMAP	    0x0082
#define CF_DSPMETAFILEPICT  0x0083

/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST	    0x02FF

/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST	    0x0300
#define CF_GDIOBJLAST	    0x03FF

/* Clipboard Manager Functions */
BOOL    WINAPI OpenClipboard(HWND);
BOOL    WINAPI CloseClipboard(void);
BOOL    WINAPI EmptyClipboard(void);

#if (WINVER >= 0x030a)
HWND    WINAPI GetOpenClipboardWindow(void);
#endif /* WINVER >= 0x030a */

HWND    WINAPI GetClipboardOwner(void);

HWND    WINAPI SetClipboardViewer(HWND);
HWND    WINAPI GetClipboardViewer(void);

HANDLE  WINAPI SetClipboardData(UINT, HANDLE);
HANDLE  WINAPI GetClipboardData(UINT);

BOOL    WINAPI IsClipboardFormatAvailable(UINT);
int     WINAPI GetPriorityClipboardFormat(UINT FAR*, int);

UINT    WINAPI RegisterClipboardFormat(LPCSTR);
int     WINAPI CountClipboardFormats(void);
UINT    WINAPI EnumClipboardFormats(UINT);
int     WINAPI GetClipboardFormatName(UINT, LPSTR, int);

BOOL    WINAPI ChangeClipboardChain(HWND, HWND);

/* Clipboard command messages */
#define WM_CUT		    0x0300
#define WM_COPY		    0x0301
#define WM_PASTE	    0x0302
#define WM_CLEAR	    0x0303
#define WM_UNDO		    0x0304

/* Clipboard owner messages */
#define WM_RENDERFORMAT	    0x0305
#define WM_RENDERALLFORMATS 0x0306
#define WM_DESTROYCLIPBOARD 0x0307

/* Clipboard viewer messages */
#define WM_DRAWCLIPBOARD    0x0308
#define WM_PAINTCLIPBOARD   0x0309
#define WM_SIZECLIPBOARD    0x030B
#define WM_VSCROLLCLIPBOARD 0x030A
#define WM_HSCROLLCLIPBOARD 0x030E
#define WM_ASKCBFORMATNAME  0x030C
#define WM_CHANGECBCHAIN    0x030D

#endif /* NOCLIPBOARD */

/****** Mouse cursor support *************************************************/

HCURSOR WINAPI LoadCursor(HINSTANCE, LPCSTR);
HCURSOR WINAPI CreateCursor(HINSTANCE, int, int, int, int, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI CopyCursor(HINSTANCE, HCURSOR);
#endif /* WINVER >= 0x030a */

int     WINAPI ShowCursor(BOOL);

void    WINAPI SetCursorPos(int, int);
void    WINAPI GetCursorPos(POINT FAR*);

HCURSOR WINAPI SetCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI GetCursor(void);
#endif /* WINVER >= 0x030a */

void    WINAPI ClipCursor(const RECT FAR*);
#if (WINVER >= 0x030a)
void    WINAPI GetClipCursor(RECT FAR*);
#endif

/* Standard cursor resource IDs */
#define IDC_ARROW	    MAKEINTRESOURCE(32512)
#define IDC_IBEAM	    MAKEINTRESOURCE(32513)
#define IDC_WAIT	    MAKEINTRESOURCE(32514)
#define IDC_CROSS	    MAKEINTRESOURCE(32515)
#define IDC_UPARROW	    MAKEINTRESOURCE(32516)
#define IDC_SIZE	    MAKEINTRESOURCE(32640)
#define IDC_ICON	    MAKEINTRESOURCE(32641)
#define IDC_SIZENWSE	    MAKEINTRESOURCE(32642)
#define IDC_SIZENESW	    MAKEINTRESOURCE(32643)
#define IDC_SIZEWE	    MAKEINTRESOURCE(32644)
#define IDC_SIZENS	    MAKEINTRESOURCE(32645)

#define WM_SETCURSOR	    0x0020

/****** Icon support *********************************************************/

HICON   WINAPI LoadIcon(HINSTANCE, LPCSTR);
HICON   WINAPI CreateIcon(HINSTANCE, int, int, BYTE, BYTE, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyIcon(HICON);

#if (WINVER >= 0x030a)
HICON   WINAPI CopyIcon(HINSTANCE, HICON);
#endif /* WINVER >= 0x030a */

BOOL    WINAPI DrawIcon(HDC, int, int, HICON);

#ifndef NOICONS

/* Standard icon resource IDs */
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND	    MAKEINTRESOURCE(32513)
#define IDI_QUESTION	    MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK	    MAKEINTRESOURCE(32516)

#endif /* NOICONS */

/****** Message Box support *************************************************/

#ifndef NOMB

int     WINAPI MessageBox(HWND, LPCSTR, LPCSTR, UINT);
void    WINAPI MessageBeep(UINT);

#define MB_OK		    0x0000
#define MB_OKCANCEL	    0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL	    0x0003
#define MB_YESNO	    0x0004
#define MB_RETRYCANCEL	    0x0005
#define MB_TYPEMASK	    0x000F

#define MB_ICONHAND	    0x0010
#define MB_ICONQUESTION	    0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK     0x0040
#define MB_ICONMASK	    0x00F0

#define MB_ICONINFORMATION  MB_ICONASTERISK
#define MB_ICONSTOP         MB_ICONHAND

#define MB_DEFBUTTON1	    0x0000
#define MB_DEFBUTTON2	    0x0100
#define MB_DEFBUTTON3	    0x0200
#define MB_DEFMASK	    0x0F00

#define MB_APPLMODAL	    0x0000
#define MB_SYSTEMMODAL	    0x1000
#define MB_TASKMODAL	    0x2000

#define MB_NOFOCUS	    0x8000



#endif /* NOMB */

/****** Caret support ********************************************************/

void    WINAPI CreateCaret(HWND, HBITMAP, int, int);
void    WINAPI DestroyCaret(void);

void    WINAPI SetCaretPos(int, int);
void    WINAPI GetCaretPos(POINT FAR*);

void    WINAPI HideCaret(HWND);
void    WINAPI ShowCaret(HWND);

UINT    WINAPI GetCaretBlinkTime(void);
void    WINAPI SetCaretBlinkTime(UINT);

/****** WM_SYSCOMMAND support ***********************************************/

#define WM_SYSCOMMAND	0x0112

#ifndef NOSYSCOMMANDS

/* System Menu Command Values */
#define SC_SIZE		0xF000
#define SC_MOVE		0xF010
#define SC_MINIMIZE	0xF020
#define SC_MAXIMIZE	0xF030
#define SC_NEXTWINDOW	0xF040
#define SC_PREVWINDOW	0xF050
#define SC_CLOSE	0xF060
#define SC_VSCROLL	0xF070
#define SC_HSCROLL	0xF080
#define SC_MOUSEMENU	0xF090
#define SC_KEYMENU	0xF100
#define SC_ARRANGE	0xF110
#define SC_RESTORE	0xF120
#define SC_TASKLIST	0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

/* Obsolete names */
#define SC_ICON		SC_MINIMIZE
#define SC_ZOOM 	SC_MAXIMIZE

/* SC_HOTKEY support messages */
#define WM_SETHOTKEY	0x0032
#define WM_GETHOTKEY	0x0033

#endif /* NOSYSCOMMANDS */

/****** MDI Support *********************************************************/

#ifndef NOMDI

/* CreateWindow lpParams structure for creating MDI client */
typedef struct tagCLIENTCREATESTRUCT
{
    HANDLE hWindowMenu;
    UINT   idFirstChild;
} CLIENTCREATESTRUCT;
typedef CLIENTCREATESTRUCT FAR* LPCLIENTCREATESTRUCT;

/* MDI client style bits */
#if (WINVER >= 0x030a)
#define MDIS_ALLCHILDSTYLES 0x0001
#endif  /* WINVER >= 0x030a */

/* MDI messages */
#define WM_MDICREATE	    0x0220
#define WM_MDIDESTROY	    0x0221
#define WM_MDIACTIVATE	    0x0222
#define WM_MDIRESTORE	    0x0223
#define WM_MDINEXT	    0x0224
#define WM_MDIMAXIMIZE	    0x0225
#define WM_MDITILE	    0x0226
#define WM_MDICASCADE	    0x0227
#define WM_MDIICONARRANGE   0x0228
#define WM_MDIGETACTIVE     0x0229
#define WM_MDISETMENU	    0x0230

/* WM_MDICREATE message structure */
typedef struct tagMDICREATESTRUCT
{
    LPCSTR  szClass;
    LPCSTR  szTitle;
    HINSTANCE hOwner;
    int     x;
    int     y;
    int     cx;
    int     cy;
    DWORD   style;
    LPARAM  lParam;
} MDICREATESTRUCT;
typedef MDICREATESTRUCT FAR*  LPMDICREATESTRUCT;

#if (WINVER >= 0x030a)
/* wParam values for WM_MDITILE and WM_MDICASCADE messages. */
#define MDITILE_VERTICAL	0x0000
#define MDITILE_HORIZONTAL	0x0001
#define MDITILE_SKIPDISABLED	0x0002
#endif /* WINVER >= 0x030a */

#define WM_CHILDACTIVATE    0x0022

LRESULT WINAPI DefFrameProc(HWND, HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI DefMDIChildProc(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG
BOOL    WINAPI TranslateMDISysAccel(HWND, MSG FAR*);
#endif

UINT    WINAPI ArrangeIconicWindows(HWND);

#endif /* NOMDI */

/****** Dialog and Control Management ***************************************/

#ifndef NOCTLMGR

/* Dialog window class */
#define WC_DIALOG	(MAKEINTATOM(0x8002))

/* cbWndExtra bytes needed by dialog manager for dialog classes */
#define DLGWINDOWEXTRA	30

/* Dialog styles */
#define DS_ABSALIGN	    0x01L
#define DS_SYSMODAL	    0x02L
#define DS_LOCALEDIT        0x20L
#define DS_SETFONT          0x40L
#define DS_MODALFRAME       0x80L
#define DS_NOIDLEMSG        0x100L

/* Dialog messages */
#define DM_GETDEFID	    (WM_USER+0)
#define DM_SETDEFID	    (WM_USER+1)

/* Returned in HIWORD() of DM_GETDEFID result if msg is supported */
#define DC_HASDEFID	    0x534B

#endif /* NOCTLMGR */

/* Dialog notification messages */
#define WM_INITDIALOG	    0x0110
#define WM_NEXTDLGCTL	    0x0028

#define WM_PARENTNOTIFY     0x0210

#define WM_ENTERIDLE	    0x0121


#ifndef NOCTLMGR

#ifdef STRICT
typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
#else
typedef FARPROC DLGPROC;
#endif

/* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows */
#define DWL_MSGRESULT	0
#define DWL_DLGPROC	4
#define DWL_USER	8

#ifndef NOMSG
BOOL    WINAPI IsDialogMessage(HWND, MSG FAR*);
#endif

LRESULT WINAPI DefDlgProc(HWND, UINT, WPARAM, LPARAM);

HWND    WINAPI CreateDialog(HINSTANCE, LPCSTR, HWND, DLGPROC);
HWND    WINAPI CreateDialogIndirect(HINSTANCE, const void FAR*, HWND, DLGPROC);
HWND    WINAPI CreateDialogParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
HWND    WINAPI CreateDialogIndirectParam(HINSTANCE, const void FAR*, HWND, DLGPROC, LPARAM);

int     WINAPI DialogBox(HINSTANCE, LPCSTR, HWND, DLGPROC);
int     WINAPI DialogBoxIndirect(HINSTANCE, HGLOBAL, HWND, DLGPROC);
int     WINAPI DialogBoxParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
int     WINAPI DialogBoxIndirectParam(HINSTANCE, HGLOBAL, HWND, DLGPROC, LPARAM);

void    WINAPI EndDialog(HWND, int);

int     WINAPI GetDlgCtrlID(HWND);
HWND    WINAPI GetDlgItem(HWND, int);
LRESULT WINAPI SendDlgItemMessage(HWND, int, UINT, WPARAM, LPARAM);

void    WINAPI SetDlgItemInt(HWND, int, UINT, BOOL);
UINT    WINAPI GetDlgItemInt(HWND, int, BOOL FAR* , BOOL);

void    WINAPI SetDlgItemText(HWND, int, LPCSTR);
int     WINAPI GetDlgItemText(HWND, int, LPSTR, int);

void    WINAPI CheckDlgButton(HWND, int, UINT);
void    WINAPI CheckRadioButton(HWND, int, int, int);
UINT    WINAPI IsDlgButtonChecked(HWND, int);

HWND    WINAPI GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND    WINAPI GetNextDlgTabItem(HWND, HWND, BOOL);

void    WINAPI MapDialogRect(HWND, RECT FAR*);
DWORD   WINAPI GetDialogBaseUnits(void);

#define WM_GETDLGCODE	    0x0087

/* dialog codes */
#define DLGC_WANTARROWS     0x0001
#define DLGC_WANTTAB        0x0002
#define DLGC_WANTALLKEYS    0x0004
#define DLGC_WANTMESSAGE    0x0004
#define DLGC_HASSETSEL      0x0008
#define DLGC_DEFPUSHBUTTON  0x0010
#define DLGC_UNDEFPUSHBUTTON 0x0020
#define DLGC_RADIOBUTTON    0x0040
#define DLGC_WANTCHARS      0x0080
#define DLGC_STATIC         0x0100
#define DLGC_BUTTON         0x2000

#define WM_CTLCOLOR	    0x0019

/* WM_CTLCOLOR control IDs */
#define CTLCOLOR_MSGBOX     0
#define CTLCOLOR_EDIT	    1
#define CTLCOLOR_LISTBOX    2
#define CTLCOLOR_BTN	    3
#define CTLCOLOR_DLG	    4
#define CTLCOLOR_SCROLLBAR  5
#define CTLCOLOR_STATIC     6

#define WM_SETFONT          0x0030
#define WM_GETFONT	    0x0031

#endif /* NOCTLMGR */

/* Standard dialog button IDs */
#define IDOK		    1
#define IDCANCEL	    2
#define IDABORT 	    3
#define IDRETRY 	    4
#define IDIGNORE	    5
#define IDYES		    6
#define IDNO		    7

/****** Owner draw control support ******************************************/

/* Owner draw control types */
#define ODT_MENU	1
#define ODT_LISTBOX	2
#define ODT_COMBOBOX	3
#define ODT_BUTTON	4

/* Owner draw actions */
#define ODA_DRAWENTIRE	0x0001
#define ODA_SELECT	0x0002
#define ODA_FOCUS	0x0004

/* Owner draw state */
#define ODS_SELECTED	0x0001
#define ODS_GRAYED	0x0002
#define ODS_DISABLED	0x0004
#define ODS_CHECKED	0x0008
#define ODS_FOCUS	0x0010

#define WM_DRAWITEM         0x002B

typedef struct tagDRAWITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND	hwndItem;
    HDC		hDC;
    RECT	rcItem;
    DWORD       itemData;
} DRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT NEAR* PDRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT FAR* LPDRAWITEMSTRUCT;

#define WM_MEASUREITEM      0x002C

typedef struct tagMEASUREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemWidth;
    UINT        itemHeight;
    DWORD       itemData;
} MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT NEAR* PMEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT FAR* LPMEASUREITEMSTRUCT;

#define WM_DELETEITEM       0x002D

typedef struct tagDELETEITEMSTRUCT
{
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    DWORD      itemData;
} DELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT NEAR* PDELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT FAR* LPDELETEITEMSTRUCT;

#define WM_COMPAREITEM	    0x0039

typedef struct tagCOMPAREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    HWND	hwndItem;
    UINT        itemID1;
    DWORD       itemData1;
    UINT        itemID2;
    DWORD       itemData2;
} COMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT NEAR* PCOMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT FAR* LPCOMPAREITEMSTRUCT;

/****** Static control ******************************************************/

#ifndef NOCTLMGR

/* Static Control Styles */
#define SS_LEFT 	    0x00000000L
#define SS_CENTER	    0x00000001L
#define SS_RIGHT	    0x00000002L
#define SS_ICON 	    0x00000003L
#define SS_BLACKRECT	    0x00000004L
#define SS_GRAYRECT	    0x00000005L
#define SS_WHITERECT	    0x00000006L
#define SS_BLACKFRAME	    0x00000007L
#define SS_GRAYFRAME	    0x00000008L
#define SS_WHITEFRAME	    0x00000009L
#define SS_SIMPLE	    0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL
#define SS_NOPREFIX         0x00000080L

#if (WINVER >= 0x030a)
#ifndef NOWINMESSAGES
/* Static Control Mesages */
#define STM_SETICON	    (WM_USER+0)
#define STM_GETICON	    (WM_USER+1)
#endif /* NOWINMESSAGES */
#endif /* WINVER >= 0x030a */

#endif /* NOCTLMGR */

/****** Button control *****************************************************/

#ifndef NOCTLMGR

/* Button Control Styles */
#define BS_PUSHBUTTON	    0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX	    0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON	    0x00000004L
#define BS_3STATE	    0x00000005L
#define BS_AUTO3STATE	    0x00000006L
#define BS_GROUPBOX	    0x00000007L
#define BS_USERBUTTON	    0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW	    0x0000000BL
#define BS_LEFTTEXT	    0x00000020L

/* Button Control Messages  */
#define BM_GETCHECK	    (WM_USER+0)
#define BM_SETCHECK	    (WM_USER+1)
#define BM_GETSTATE	    (WM_USER+2)
#define BM_SETSTATE	    (WM_USER+3)
#define BM_SETSTYLE	    (WM_USER+4)

/* User Button Notification Codes */
#define BN_CLICKED	    0
#define BN_PAINT	    1
#define BN_HILITE	    2
#define BN_UNHILITE	    3
#define BN_DISABLE	    4
#define BN_DOUBLECLICKED    5

#endif /* NOCTLMGR */

/****** Edit control *******************************************************/

#ifndef NOCTLMGR

/* Edit control styles */
#ifndef NOWINSTYLES
#define ES_LEFT 	    0x00000000L
#define ES_CENTER	    0x00000001L
#define ES_RIGHT	    0x00000002L
#define ES_MULTILINE	    0x00000004L
#define ES_UPPERCASE	    0x00000008L
#define ES_LOWERCASE	    0x00000010L
#define ES_PASSWORD         0x00000020L
#define ES_AUTOVSCROLL	    0x00000040L
#define ES_AUTOHSCROLL	    0x00000080L
#define ES_NOHIDESEL	    0x00000100L
#define ES_OEMCONVERT	    0x00000400L
#if (WINVER >= 0x030a)
#define ES_READONLY	    0x00000800L
#define ES_WANTRETURN       0x00001000L
#endif  /* WINVER >= 0x030a */
#endif /* NOWINSTYLES */

/* Edit control messages */
#ifndef NOWINMESSAGES
#define EM_GETSEL	        (WM_USER+0)
#define EM_SETSEL	        (WM_USER+1)
#define EM_GETRECT	        (WM_USER+2)
#define EM_SETRECT	        (WM_USER+3)
#define EM_SETRECTNP	        (WM_USER+4)
#define EM_LINESCROLL	        (WM_USER+6)
#define EM_GETMODIFY	        (WM_USER+8)
#define EM_SETMODIFY	        (WM_USER+9)
#define EM_GETLINECOUNT         (WM_USER+10)
#define EM_LINEINDEX	        (WM_USER+11)
#define EM_SETHANDLE	        (WM_USER+12)
#define EM_GETHANDLE	        (WM_USER+13)
#define EM_GETTHUMB	        (WM_USER+14)
#define EM_LINELENGTH	        (WM_USER+17)
#define EM_REPLACESEL	        (WM_USER+18)
#define EM_SETFONT	        (WM_USER+19)
#define EM_GETLINE	        (WM_USER+20)
#define EM_LIMITTEXT	        (WM_USER+21)
#define EM_CANUNDO	        (WM_USER+22)
#define EM_UNDO 	        (WM_USER+23)
#define EM_FMTLINES	        (WM_USER+24)
#define EM_LINEFROMCHAR         (WM_USER+25)
#define EM_SETWORDBREAK         (WM_USER+26)    /* NOT IMPLEMENTED: use EM_SETWORDBREAK */
#define EM_SETTABSTOPS	        (WM_USER+27)
#define EM_SETPASSWORDCHAR      (WM_USER+28)
#define EM_EMPTYUNDOBUFFER      (WM_USER+29)
#if (WINVER >= 0x030a)
#define EM_GETFIRSTVISIBLELINE	(WM_USER+30)
#define EM_SETREADONLY	        (WM_USER+31)
#define EM_SETWORDBREAKPROC     (WM_USER+32)
#define EM_GETWORDBREAKPROC     (WM_USER+33)
#define EM_GETPASSWORDCHAR      (WM_USER+34)
#endif /* WINVER >= 0x030a */
#endif /* NOWINMESSAGES */


#if (WINVER >= 0x030a)

typedef int   (CALLBACK* EDITWORDBREAKPROC)(LPSTR lpch, int ichCurrent, int cch, int code);

/* EDITWORDBREAKPROC code values */
#define WB_LEFT		   0
#define WB_RIGHT	   1
#define WB_ISDELIMITER     2
#endif

/* Edit control notification codes */
#define EN_SETFOCUS	    0x0100
#define EN_KILLFOCUS	    0x0200
#define EN_CHANGE	    0x0300
#define EN_UPDATE	    0x0400
#define EN_ERRSPACE	    0x0500
#define EN_MAXTEXT	    0x0501
#define EN_HSCROLL	    0x0601
#define EN_VSCROLL	    0x0602

#endif /* NOCTLMGR */

/****** Scroll bar control *************************************************/
/* Also see scrolling support */

#ifndef NOCTLMGR

#ifndef NOWINSTYLES

/* Scroll bar styles */
#define SBS_HORZ		    0x0000L
#define SBS_VERT		    0x0001L
#define SBS_TOPALIGN		    0x0002L
#define SBS_LEFTALIGN		    0x0002L
#define SBS_BOTTOMALIGN		    0x0004L
#define SBS_RIGHTALIGN		    0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN	    0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX		    0x0008L

#endif /* NOWINSTYLES */

#endif /* NOCTLMGR */

/****** Listbox control ****************************************************/

#ifndef NOCTLMGR

/* Listbox styles */
#ifndef NOWINSTYLES
#define LBS_NOTIFY	      0x0001L
#define LBS_SORT	      0x0002L
#define LBS_NOREDRAW	      0x0004L
#define LBS_MULTIPLESEL       0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL	      0x0800L
#if (WINVER >= 0x030a)
#define LBS_DISABLENOSCROLL   0x1000L
#endif /* WINVER >= 0x030a */
#define LBS_STANDARD	      (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
#endif /* NOWINSTYLES */

/* Listbox messages */
#ifndef NOWINMESSAGES
#define LB_ADDSTRING	       (WM_USER+1)
#define LB_INSERTSTRING        (WM_USER+2)
#define LB_DELETESTRING        (WM_USER+3)
#define LB_RESETCONTENT        (WM_USER+5)
#define LB_SETSEL	       (WM_USER+6)
#define LB_SETCURSEL	       (WM_USER+7)
#define LB_GETSEL	       (WM_USER+8)
#define LB_GETCURSEL	       (WM_USER+9)
#define LB_GETTEXT	       (WM_USER+10)
#define LB_GETTEXTLEN	       (WM_USER+11)
#define LB_GETCOUNT	       (WM_USER+12)
#define LB_SELECTSTRING        (WM_USER+13)
#define LB_DIR		       (WM_USER+14)
#define LB_GETTOPINDEX	       (WM_USER+15)
#define LB_FINDSTRING	       (WM_USER+16)
#define LB_GETSELCOUNT	       (WM_USER+17)
#define LB_GETSELITEMS	       (WM_USER+18)
#define LB_SETTABSTOPS         (WM_USER+19)
#define LB_GETHORIZONTALEXTENT (WM_USER+20)
#define LB_SETHORIZONTALEXTENT (WM_USER+21)
#define LB_SETCOLUMNWIDTH      (WM_USER+22)
#define LB_SETTOPINDEX	       (WM_USER+24)
#define LB_GETITEMRECT	       (WM_USER+25)
#define LB_GETITEMDATA         (WM_USER+26)
#define LB_SETITEMDATA         (WM_USER+27)
#define LB_SELITEMRANGE        (WM_USER+28)
#define LB_SETCARETINDEX       (WM_USER+31)
#define LB_GETCARETINDEX       (WM_USER+32)

#if (WINVER >= 0x030a)
#define LB_SETITEMHEIGHT       (WM_USER+33)
#define LB_GETITEMHEIGHT       (WM_USER+34)
#endif  /* WINVER >= 0x030a */

#endif /* NOWINMESSAGES */

/* Listbox notification codes */
#define LBN_ERRSPACE	    (-2)
#define LBN_SELCHANGE	    1
#define LBN_DBLCLK	    2
#define LBN_SELCANCEL       3
#define LBN_SETFOCUS        4
#define LBN_KILLFOCUS       5

/* Listbox notification messages */
#define WM_VKEYTOITEM       0x002E
#define WM_CHARTOITEM       0x002F

/* Listbox message return values */
#define LB_OKAY 	    0
#define LB_ERR		    (-1)
#define LB_ERRSPACE	    (-2)

#define LB_CTLCODE	    0L

/****** Dialog directory support ********************************************/

int     WINAPI DlgDirList(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelect(HWND, LPSTR, int);

int     WINAPI DlgDirListComboBox(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelectComboBox(HWND, LPSTR, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI DlgDirSelectEx(HWND, LPSTR, int, int);
BOOL    WINAPI DlgDirSelectComboBoxEx(HWND, LPSTR, int, int);
#endif


/* DlgDirList, DlgDirListComboBox flags values */
#define DDL_READWRITE       0x0000
#define DDL_READONLY        0x0001
#define DDL_HIDDEN          0x0002
#define DDL_SYSTEM          0x0004
#define DDL_DIRECTORY	    0x0010
#define DDL_ARCHIVE	    0x0020

#define DDL_POSTMSGS	    0x2000
#define DDL_DRIVES	    0x4000
#define DDL_EXCLUSIVE	    0x8000

#endif /* NOCTLMGR */

/****** Combo box control **************************************************/

#ifndef NOCTLMGR

/* Combo box styles */
#ifndef NOWINSTYLES
#define CBS_SIMPLE	      0x0001L
#define CBS_DROPDOWN	      0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_OEMCONVERT        0x0080L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L
#define CBS_NOINTEGRALHEIGHT  0x0400L
#if (WINVER >= 0x030a)
#define CBS_DISABLENOSCROLL   0x0800L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Combo box messages */
#ifndef NOWINMESSAGES
#define CB_GETEDITSEL	         (WM_USER+0)
#define CB_LIMITTEXT	         (WM_USER+1)
#define CB_SETEDITSEL	         (WM_USER+2)
#define CB_ADDSTRING	         (WM_USER+3)
#define CB_DELETESTRING	         (WM_USER+4)
#define CB_DIR                   (WM_USER+5)
#define CB_GETCOUNT	         (WM_USER+6)
#define CB_GETCURSEL	         (WM_USER+7)
#define CB_GETLBTEXT	         (WM_USER+8)
#define CB_GETLBTEXTLEN	         (WM_USER+9)
#define CB_INSERTSTRING          (WM_USER+10)
#define CB_RESETCONTENT	         (WM_USER+11)
#define CB_FINDSTRING	         (WM_USER+12)
#define CB_SELECTSTRING	         (WM_USER+13)
#define CB_SETCURSEL	         (WM_USER+14)
#define CB_SHOWDROPDOWN          (WM_USER+15)
#define CB_GETITEMDATA           (WM_USER+16)
#define CB_SETITEMDATA           (WM_USER+17)
#if (WINVER >= 0x030a)
#define CB_GETDROPPEDCONTROLRECT (WM_USER+18)
#define CB_SETITEMHEIGHT         (WM_USER+19)
#define CB_GETITEMHEIGHT         (WM_USER+20)
#define CB_SETEXTENDEDUI         (WM_USER+21)
#define CB_GETEXTENDEDUI         (WM_USER+22)
#define CB_GETDROPPEDSTATE       (WM_USER+23)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINMESSAGES */

/* Combo box notification codes */
#define CBN_ERRSPACE	    (-1)
#define CBN_SELCHANGE	    1
#define CBN_DBLCLK	    2
#define CBN_SETFOCUS	    3
#define CBN_KILLFOCUS	    4
#define CBN_EDITCHANGE      5
#define CBN_EDITUPDATE      6
#define CBN_DROPDOWN        7
#if (WINVER >= 0x030a)
#define CBN_CLOSEUP         8
#define CBN_SELENDOK        9
#define CBN_SELENDCANCEL    10
#endif /* WINVER >= 0x030a */

/* Combo box message return values */
#define CB_OKAY 	    0
#define CB_ERR		    (-1)
#define CB_ERRSPACE	    (-2)

#endif	/* NOCTLMGR */

/******* Windows hook support **********************************************/

#ifndef NOWH

typedef DWORD HHOOK;

#ifdef STRICT
typedef LRESULT (CALLBACK* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
#else
typedef FARPROC HOOKPROC;
#endif

#ifdef STRICT
HHOOK   WINAPI SetWindowsHook(int, HOOKPROC);
DWORD   WINAPI DefHookProc(int, UINT, DWORD, HHOOK FAR* );
#else
HOOKPROC WINAPI SetWindowsHook(int, HOOKPROC);
DWORD   WINAPI DefHookProc(int, UINT, DWORD, HOOKPROC FAR* );
#endif
BOOL    WINAPI UnhookWindowsHook(int, HOOKPROC);

#if (WINVER >= 0x030a)

HHOOK   WINAPI SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hInstance, HTASK hTask);
BOOL    WINAPI UnhookWindowsHookEx(HHOOK hHook);
LRESULT WINAPI CallNextHookEx(HHOOK hHook, int code, WPARAM wParam, LPARAM lParam);

#endif  /* WINVER >= 0x030a */


/* Standard hook code */
#define HC_ACTION	    0

/* Obsolete hook codes (NO LONGER SUPPORTED) */
#define HC_GETLPLPFN	    (-3)
#define HC_LPLPFNNEXT	    (-2)
#define HC_LPFNNEXT	    (-1)

#endif	/* NOWH */

/****** Computer-based-training (CBT) support *******************************/

#define WM_QUEUESYNC        0x0023

#ifndef NOWH

/* SetWindowsHook() code */
#define WH_CBT		    5

#define HCBT_MOVESIZE	    0
#define HCBT_MINMAX	    1
#define HCBT_QS 	    2
#define HCBT_CREATEWND	    3
#define HCBT_DESTROYWND	    4
#define HCBT_ACTIVATE	    5
#define HCBT_CLICKSKIPPED   6
#define HCBT_KEYSKIPPED     7
#define HCBT_SYSCOMMAND	    8
#define HCBT_SETFOCUS	    9

#if (WINVER >= 0x030a)
/* HCBT_CREATEWND parameters pointed to by lParam */
typedef struct tagCBT_CREATEWND
{
    CREATESTRUCT FAR* lpcs;
    HWND    hwndInsertAfter;
} CBT_CREATEWND;
typedef CBT_CREATEWND FAR* LPCBT_CREATEWND;

/* HCBT_ACTIVATE structure pointed to by lParam */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT;

#endif  /* WINVER >= 0x030a */
#endif	/* NOWH */

/****** Hardware hook support ***********************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
#define WH_HARDWARE	    8

typedef struct tagHARDWAREHOOKSTRUCT
{
    HWND    hWnd;
    UINT    wMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT;
#endif /* WINVER >= 0x030a */
#endif /* NOWH */

/****** Shell support *******************************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
/* SetWindowsHook() Shell hook code */
#define WH_SHELL           10

#define HSHELL_WINDOWCREATED       1
#define HSHELL_WINDOWDESTROYED     2
#define HSHELL_ACTIVATESHELLWINDOW 3

#endif /* WINVER >= 0x030a */
#endif /* NOWH */

/****** Journalling support *************************************************/

#ifndef NOWH
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1

/* Journalling hook codes */
#define HC_GETNEXT	    1
#define HC_SKIP 	    2
#define HC_NOREMOVE	    3
#define HC_NOREM	    HC_NOREMOVE
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF	    5

/* Journalling message structure */
typedef struct tagEVENTMSG
{
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD   time;
} EVENTMSG;
typedef EVENTMSG *PEVENTMSG;                    
typedef EVENTMSG NEAR* NPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSG;

BOOL    WINAPI EnableHardwareInput(BOOL);

#endif	/* NOWH */


/****** Debugger support ****************************************************/

#if (WINVER >= 0x030a)
/* SetWindowsHook debug hook support */
#define WH_DEBUG	    9

typedef struct tagDEBUGHOOKINFO
{
    HMODULE	hModuleHook;
    LPARAM	reserved;
    LPARAM	lParam;
    WPARAM	wParam;
    int         code;
} DEBUGHOOKINFO;
typedef DEBUGHOOKINFO FAR* LPDEBUGHOOKINFO;

#ifndef NOMSG
BOOL WINAPI QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg);
#endif  /* NOMSG */

BOOL WINAPI LockInput(HANDLE h1, HWND hwndInput, BOOL fLock);

LONG WINAPI GetSystemDebugState(void);
/* Flags returned by GetSystemDebugState. 
 */
#define SDS_MENU        0x0001
#define SDS_SYSMODAL    0x0002
#define SDS_NOTASKQUEUE 0x0004
#define SDS_DIALOG      0x0008
#define SDS_TASKLOCKED  0x0010
#endif  /* WINVER >= 0x030a */


/****** Help support ********************************************************/

#ifndef NOHELP

BOOL WINAPI WinHelp(HWND hwndMain, LPCSTR lpszHelp, UINT usCommand, DWORD ulData);

/* WinHelp() commands */
#define HELP_CONTEXT      0x0001
#define HELP_QUIT         0x0002
#define HELP_INDEX        0x0003
#define HELP_CONTENTS     0x0003
#define HELP_HELPONHELP   0x0004
#define HELP_SETINDEX     0x0005
#define HELP_SETCONTENTS  0x0005
#define HELP_CONTEXTPOPUP 0x0008
#define HELP_FORCEFILE    0x0009
#define HELP_KEY          0x0101
#define HELP_COMMAND      0x0102
#define HELP_PARTIALKEY   0x0105
#define HELP_MULTIKEY     0x0201
#define HELP_SETWINPOS    0x0203

typedef struct tagMULTIKEYHELP
{
    UINT    mkSize;
    BYTE    mkKeylist;
    BYTE    szKeyphrase[1];
} MULTIKEYHELP;


typedef struct
{
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    char rgchMember[2];
} HELPWININFO;
typedef HELPWININFO NEAR* PHELPWININFO;
typedef HELPWININFO FAR* LPHELPWININFO;

#endif /* NOHELP */

/****** Sound support ******************************************************/

#ifndef NOSOUND

int     WINAPI OpenSound(void);
void    WINAPI CloseSound(void);

int     WINAPI StartSound(void);
int     WINAPI StopSound(void);

int     WINAPI SetVoiceQueueSize(int, int);
int     WINAPI SetVoiceNote(int, int, int, int);
int     WINAPI SetVoiceAccent(int, int, int, int, int);
int     WINAPI SetVoiceEnvelope(int, int, int);
int     WINAPI SetVoiceSound(int, DWORD, int);

int     WINAPI SetVoiceThreshold(int, int);
int FAR* WINAPI GetThresholdEvent(void);
int     WINAPI GetThresholdStatus(void);

int     WINAPI SetSoundNoise(int, int);

/* SetSoundNoise() Sources */
#define S_PERIOD512   0
#define S_PERIOD1024  1
#define S_PERIOD2048  2
#define S_PERIODVOICE 3
#define S_WHITE512    4
#define S_WHITE1024   5
#define S_WHITE2048   6
#define S_WHITEVOICE  7

int     WINAPI WaitSoundState(int);

/* WaitSoundState() constants */
#define S_QUEUEEMPTY	    0
#define S_THRESHOLD	    1
#define S_ALLTHRESHOLD	    2

int     WINAPI SyncAllVoices(void);
int     WINAPI CountVoiceNotes(int);

/* Accent Modes */
#define S_NORMAL      0
#define S_LEGATO      1
#define S_STACCATO    2

/* Error return values */
#define S_SERDVNA     (-1)
#define S_SEROFM      (-2)
#define S_SERMACT     (-3)
#define S_SERQFUL     (-4)
#define S_SERBDNT     (-5)
#define S_SERDLN      (-6)
#define S_SERDCC      (-7)
#define S_SERDTP      (-8)
#define S_SERDVL      (-9)
#define S_SERDMD      (-10)
#define S_SERDSH      (-11)
#define S_SERDPT      (-12)
#define S_SERDFQ      (-13)
#define S_SERDDR      (-14)
#define S_SERDSR      (-15)
#define S_SERDST      (-16)

#endif /* NOSOUND */

/****** Comm support ******************************************************/

#ifndef NOCOMM

#define NOPARITY	    0
#define ODDPARITY	    1
#define EVENPARITY	    2
#define MARKPARITY	    3
#define SPACEPARITY	    4

#define ONESTOPBIT	    0
#define ONE5STOPBITS	    1
#define TWOSTOPBITS	    2

#define IGNORE              0
#define INFINITE            0xFFFF

/* Error Flags */
#define CE_RXOVER           0x0001
#define CE_OVERRUN          0x0002
#define CE_RXPARITY         0x0004
#define CE_FRAME            0x0008
#define CE_BREAK            0x0010
#define CE_CTSTO            0x0020
#define CE_DSRTO            0x0040
#define CE_RLSDTO           0x0080
#define CE_TXFULL           0x0100
#define CE_PTO              0x0200
#define CE_IOE              0x0400
#define CE_DNS              0x0800
#define CE_OOP              0x1000
#define CE_MODE             0x8000

#define IE_BADID            (-1)
#define IE_OPEN             (-2)
#define IE_NOPEN            (-3)
#define IE_MEMORY           (-4)
#define IE_DEFAULT          (-5)
#define IE_HARDWARE         (-10)
#define IE_BYTESIZE         (-11)
#define IE_BAUDRATE         (-12)

/* Events */
#define EV_RXCHAR           0x0001
#define EV_RXFLAG           0x0002
#define EV_TXEMPTY          0x0004
#define EV_CTS              0x0008
#define EV_DSR              0x0010
#define EV_RLSD             0x0020
#define EV_BREAK            0x0040
#define EV_ERR              0x0080
#define EV_RING             0x0100
#define EV_PERR             0x0200
#define EV_CTSS             0x0400
#define EV_DSRS             0x0800
#define EV_RLSDS            0x1000
#define EV_RingTe           0x2000
#define EV_RINGTE	    EV_RingTe

/* Escape Functions */
#define SETXOFF             1
#define SETXON              2
#define SETRTS              3
#define CLRRTS              4
#define SETDTR              5
#define CLRDTR              6
#define RESETDEV            7

#define LPTx                0x80

#if (WINVER >= 0x030a)

/* new escape functions */
#define GETMAXLPT           8
#define GETMAXCOM           9
#define GETBASEIRQ          10

/* Comm Baud Rate indices */
#define CBR_110	     0xFF10
#define CBR_300      0xFF11
#define CBR_600      0xFF12
#define CBR_1200     0xFF13
#define CBR_2400     0xFF14
#define CBR_4800     0xFF15
#define CBR_9600     0xFF16
#define CBR_14400    0xFF17
#define CBR_19200    0xFF18
#define CBR_38400    0xFF1B
#define CBR_56000    0xFF1F
#define CBR_128000   0xFF23
#define CBR_256000   0xFF27

/* notifications passed in low word of lParam on WM_COMMNOTIFY messages */
#define CN_RECEIVE  0x01
#define CN_TRANSMIT 0x02
#define CN_EVENT    0x04

#endif /* WINVER >= 0x030a */

typedef struct tagDCB
{
    BYTE Id;
    UINT BaudRate;
    BYTE ByteSize;
    BYTE Parity;
    BYTE StopBits;
    UINT RlsTimeout;
    UINT CtsTimeout;
    UINT DsrTimeout;

    UINT fBinary        :1;
    UINT fRtsDisable    :1;
    UINT fParity        :1;
    UINT fOutxCtsFlow   :1;
    UINT fOutxDsrFlow   :1;
    UINT fDummy         :2;
    UINT fDtrDisable    :1;

    UINT fOutX          :1;
    UINT fInX           :1;
    UINT fPeChar        :1;
    UINT fNull          :1;
    UINT fChEvt         :1;
    UINT fDtrflow       :1;
    UINT fRtsflow       :1;
    UINT fDummy2        :1;

    char XonChar;
    char XoffChar;
    UINT XonLim;
    UINT XoffLim;
    char PeChar;
    char EofChar;
    char EvtChar;
    UINT TxDelay;
} DCB;
typedef DCB FAR* LPDCB;

typedef struct tagCOMSTAT
{
    UINT fCtsHold  :1;
    UINT fDsrHold  :1;
    UINT fRlsdHold :1;
    UINT fXoffHold :1;
    UINT fXoffSent :1;
    UINT fEof      :1;
    UINT fTxim     :1;

    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

int     WINAPI BuildCommDCB(LPCSTR, DCB FAR*);

int     WINAPI OpenComm(LPCSTR, UINT, UINT);
int     WINAPI CloseComm(int);

int     WINAPI ReadComm(int, void FAR*, int);
int     WINAPI WriteComm(int, const void FAR*, int);
int     WINAPI UngetCommChar(int, char);
int     WINAPI FlushComm(int, int);
int     WINAPI TransmitCommChar(int, char);

int     WINAPI SetCommState(const DCB FAR*);
int     WINAPI GetCommState(int, DCB FAR*);
int     WINAPI GetCommError(int, COMSTAT FAR* );

int     WINAPI SetCommBreak(int);
int     WINAPI ClearCommBreak(int);

UINT FAR* WINAPI SetCommEventMask(int, UINT);
UINT    WINAPI GetCommEventMask(int, int);

LONG    WINAPI EscapeCommFunction(int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI EnableCommNotification(int, HWND, int, int);

#define WM_COMMNOTIFY		0x0044
#endif  /* WINVER >= 0x030a */

#endif /* NOCOMM */

/****** String formatting support *******************************************/

int     WINAPI wvsprintf(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams);

int	FAR CDECL wsprintf(LPSTR lpszOut, LPCSTR lpszFmt, ...);


/****** Driver support ******************************************************/

#if (WINVER >= 0x030a)

#ifndef NODRIVERS

DECLARE_HANDLE(HDRVR);

/* Driver messages */
#define DRV_LOAD		0x0001
#define DRV_ENABLE		0x0002
#define DRV_OPEN		0x0003
#define DRV_CLOSE		0x0004
#define DRV_DISABLE		0x0005
#define DRV_FREE		0x0006
#define DRV_CONFIGURE		0x0007
#define DRV_QUERYCONFIGURE	0x0008
#define DRV_INSTALL		0x0009
#define DRV_REMOVE		0x000A
#define DRV_EXITSESSION         0x000B
#define DRV_EXITAPPLICATION     0x000C
#define DRV_POWER		0x000F

#define DRV_RESERVED		0x0800
#define DRV_USER		0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO
{
    DWORD   dwDCISize;
    LPSTR   lpszDCISectionName;
    LPSTR   lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO NEAR* PDRVCONFIGINFO;
typedef DRVCONFIGINFO FAR* LPDRVCONFIGINFO;

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL		0x0000
#define DRVCNF_OK		0x0001
#define DRVCNF_RESTART		0x0002

/* Supported lParam1 of DRV_EXITAPPLICATION notification */
#define DRVEA_NORMALEXIT            0x0001
#define DRVEA_ABNORMALEXIT          0x0002

LRESULT WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID, UINT message, LPARAM lParam1, LPARAM lParam2);

HDRVR   WINAPI OpenDriver(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT WINAPI CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);

LRESULT WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2);

HINSTANCE WINAPI GetDriverModuleHandle(HDRVR hDriver);

HDRVR   WINAPI GetNextDriver(HDRVR, DWORD);

/* GetNextDriver flags */
#define GND_FIRSTINSTANCEONLY	0x00000001
#define GND_REVERSE		0x00000002

typedef struct tagDRIVERINFOSTRUCT
{
    UINT    length;
    HDRVR   hDriver;
    HINSTANCE hModule;
    char    szAliasName[128];
} DRIVERINFOSTRUCT;
typedef DRIVERINFOSTRUCT FAR* LPDRIVERINFOSTRUCT;

BOOL    WINAPI GetDriverInfo(HDRVR, DRIVERINFOSTRUCT FAR*);

#endif /* !NODRIVERS */
#endif /* WINVER >= 0x030a */
#endif /* NOUSER */


#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_WINDOWS */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\hack\dos\lmrepl.h ===
////////////////////////////////////////////////////////////////////////////////
//
//	W A R N I N G ! ! !      D A N G E R ! ! !      W A R N I N G ! ! !
//
//
//	THIS FILE EXISTS ONLY TO ALLOW THE 16-BIT ADMIN APPS TO BUILD.
//	THESE API (NetReplXxx) DO NOT YET EXIST UNDER WIN16.  THIS IS
//	A VERY UGLY HACK, THUS THIS FILE EXISTS IN THE COMMON\HACK\DOS
//	DIRECTORY.
//
//
//	FILE HISTORY:
//
//		KeithMo	    28-Feb-1992	    Copied here from PUBLIC\SDK\INC,
//					    added conditional #defines for
//					    IN, OUT, and OPTIONAL.
//
//
//	W A R N I N G ! ! !      D A N G E R ! ! !      W A R N I N G ! ! !
//
////////////////////////////////////////////////////////////////////////////////

#ifndef IN
#define IN
#endif
#ifndef OUT
#define OUT
#endif
#ifndef OPTIONAL
#define OPTIONAL
#endif

/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    LmRepl.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the replicator APIs.

Author:

    John Rogers (JohnRo) 17-Dec-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include LmCons.h before this file.

Revision History:

    17-Dec-1991 JohnRo
        Created from RitaW's replicator API spec.
    26-Dec-1991 JohnRo
        Added REPL_EDIR_INFO_2 and subsetted REPL_EDIR_INFO_1.
        Added INFOLEVEL equates.
        Changed values of REPL_EXTENT_FILE and REPL_EXTENT_TREE.
    07-Jan-1992 JohnRo
        Corrected typedef name (LPREPL_INFO_100 s.b. LPREPL_INFO_0).
    24-Jan-1992 JohnRo
        Changed to use LPTSTR etc.
    27-Feb-1992 JohnRo
        Changed state not started to state never replicated.

--*/

#ifndef _LMREPL_
#define _LMREPL_

//
// Replicator Configuration APIs
//

#define REPL_ROLE_EXPORT        1
#define REPL_ROLE_IMPORT        2
#define REPL_ROLE_BOTH          3


#define REPL_INTERVAL_INFOLEVEL         (PARMNUM_BASE_INFOLEVEL + 0)
#define REPL_PULSE_INFOLEVEL            (PARMNUM_BASE_INFOLEVEL + 1)
#define REPL_GUARDTIME_INFOLEVEL        (PARMNUM_BASE_INFOLEVEL + 2)
#define REPL_RANDOM_INFOLEVEL           (PARMNUM_BASE_INFOLEVEL + 3)


typedef struct _REPL_INFO_0 {
    DWORD          rp0_role;
    LPTSTR         rp0_exportpath;
    LPTSTR         rp0_exportlist;
    LPTSTR         rp0_importpath;
    LPTSTR         rp0_importlist;
    LPTSTR         rp0_logonusername;
    DWORD          rp0_interval;
    DWORD          rp0_pulse;
    DWORD          rp0_guardtime;
    DWORD          rp0_random;
} REPL_INFO_0, *PREPL_INFO_0, *LPREPL_INFO_0;

typedef struct _REPL_INFO_1000 {
    DWORD          rp1000_interval;
} REPL_INFO_1000, *PREPL_INFO_1000, *LPREPL_INFO_1000;

typedef struct _REPL_INFO_1001 {
    DWORD          rp1001_pulse;
} REPL_INFO_1001, *PREPL_INFO_1001, *LPREPL_INFO_1001;

typedef struct _REPL_INFO_1002 {
    DWORD          rp1002_guardtime;
} REPL_INFO_1002, *PREPL_INFO_1002, *LPREPL_INFO_1002;

typedef struct _REPL_INFO_1003 {
    DWORD          rp1003_random;
} REPL_INFO_1003, *PREPL_INFO_1003, *LPREPL_INFO_1003;


NET_API_STATUS NET_API_FUNCTION
NetReplGetInfo (
    IN LPTSTR servername OPTIONAL,
    IN DWORD level,
    OUT LPBYTE * bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetReplSetInfo (
    IN LPTSTR servername OPTIONAL,
    IN DWORD level,
    IN LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );


//
// Replicator Export Directory APIs
//

#define REPL_INTEGRITY_FILE     1
#define REPL_INTEGRITY_TREE     2


#define REPL_EXTENT_FILE        1
#define REPL_EXTENT_TREE        2


#define REPL_EXPORT_INTEGRITY_INFOLEVEL (PARMNUM_BASE_INFOLEVEL + 0)
#define REPL_EXPORT_EXTENT_INFOLEVEL    (PARMNUM_BASE_INFOLEVEL + 1)


typedef struct _REPL_EDIR_INFO_0 {
    LPTSTR         rped0_dirname;
} REPL_EDIR_INFO_0, *PREPL_EDIR_INFO_0, *LPREPL_EDIR_INFO_0;

typedef struct _REPL_EDIR_INFO_1 {
    LPTSTR         rped1_dirname;
    DWORD          rped1_integrity;
    DWORD          rped1_extent;
} REPL_EDIR_INFO_1, *PREPL_EDIR_INFO_1, *LPREPL_EDIR_INFO_1;

typedef struct _REPL_EDIR_INFO_2 {
    LPTSTR         rped2_dirname;
    DWORD          rped2_integrity;
    DWORD          rped2_extent;
    DWORD          rped2_lockcount;
    DWORD          rped2_locktime;
} REPL_EDIR_INFO_2, *PREPL_EDIR_INFO_2, *LPREPL_EDIR_INFO_2;

typedef struct _REPL_EDIR_INFO_1000 {
    DWORD          rped1000_integrity;
} REPL_EDIR_INFO_1000, *PREPL_EDIR_INFO_1000, *LPREPL_EDIR_INFO_1000;

typedef struct _REPL_EDIR_INFO_1001 {
    DWORD          rped1001_extent;
} REPL_EDIR_INFO_1001, *PREPL_EDIR_INFO_1001, *LPREPL_EDIR_INFO_1001;


NET_API_STATUS NET_API_FUNCTION
NetReplExportDirAdd (
    IN LPTSTR servername OPTIONAL,
    IN DWORD level,
    IN LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirDel (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirEnum (
    IN LPTSTR servername OPTIONAL,
    IN DWORD level,
    OUT LPBYTE * bufptr,
    IN DWORD prefmaxlen,
    OUT LPDWORD entriesread,
    OUT LPDWORD totalentries,
    IN OUT LPDWORD resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirGetInfo (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname,
    IN DWORD level,
    OUT LPBYTE * bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirSetInfo (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname,
    IN DWORD level,
    IN LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirLock (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirUnlock (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname,
    IN DWORD unlockforce
    );


#define REPL_UNLOCK_NOFORCE     0
#define REPL_UNLOCK_FORCE       1


//
// Replicator Import Directory APIs
//


typedef struct _REPL_IDIR_INFO_0 {
    LPTSTR         rpid0_dirname;
} REPL_IDIR_INFO_0, *PREPL_IDIR_INFO_0, *LPREPL_IDIR_INFO_0;

typedef struct _REPL_IDIR_INFO_1 {
    LPTSTR         rpid1_dirname;
    DWORD          rpid1_state;
    LPTSTR         rpid1_mastername;
    DWORD          rpid1_last_update_time;
    DWORD          rpid1_lockcount;
    DWORD          rpid1_locktime;
} REPL_IDIR_INFO_1, *PREPL_IDIR_INFO_1, *LPREPL_IDIR_INFO_1;


NET_API_STATUS NET_API_FUNCTION
NetReplImportDirAdd (
    IN LPTSTR servername OPTIONAL,
    IN DWORD level,
    IN LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirDel (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirEnum (
    IN LPTSTR servername OPTIONAL,
    IN DWORD level,
    OUT LPBYTE * bufptr,
    IN DWORD prefmaxlen,
    OUT LPDWORD entriesread,
    OUT LPDWORD totalentries,
    IN OUT LPDWORD resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirGetInfo (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname,
    IN DWORD level,
    OUT LPBYTE * bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirLock (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname
    );


NET_API_STATUS NET_API_FUNCTION
NetReplImportDirUnlock (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname,
    IN DWORD unlockforce
    );


#define REPL_STATE_OK                   0
#define REPL_STATE_NO_MASTER            1
#define REPL_STATE_NO_SYNC              2
#define REPL_STATE_NEVER_REPLICATED     3


#endif //_LMREPL_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\auditchk.cxx ===
/**********************************************************************/
/**	      Microsoft Windows NT				     **/
/**	   Copyright(c) Microsoft Corp., 1991			     **/
/**********************************************************************/

/*
    auditchk.cxx

    This file contains the implementation for the audit checkboxes.

    FILE HISTORY:
	Johnl	06-Sep-1991 Created

*/

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:	AUDIT_CHECKBOXES::AUDIT_CHECKBOXES

    SYNOPSIS:	Constructor for the AUDIT_CHECKBOXES class

    ENTRY:  cidSLTAuditName - CID of SLT that represents the name of this
		    audit set
	    cidCheckSuccess - CID of Success checkbox
	    cidCheckFailed  - CID of Failed checkbox
	    nlsAuditName    - Name of this audit set (SLT set to this)
	    bitMask	- Bitflags that represent this audit set

    NOTES:  We enable and show the checkboxes (doesn't matter if already
	    enabled or displayed).  This allows for variable numbers of
	    checkboxes and having the unused checkboxes default to hidden.

    HISTORY:
	Johnl	9-Sep-1991  Created

********************************************************************/

AUDIT_CHECKBOXES::AUDIT_CHECKBOXES( OWNER_WINDOW * powin,
		   CID	 cidSLTAuditName,
		   CID	 cidCheckSuccess,
		   CID	 cidCheckFailed,
		   const NLS_STR  & nlsAuditName,
		   const BITFIELD & bitMask )
    : _sltAuditName( powin, cidSLTAuditName ),
      _fcheckSuccess( powin, cidCheckSuccess ),
      _fcheckFailed ( powin, cidCheckFailed ),
      _bitMask( bitMask )
{
    APIERR err ;
    if ( (err = _sltAuditName.QueryError())  ||
	 (err = _fcheckSuccess.QueryError()) ||
	 (err = _fcheckFailed.QueryError() ) ||
	 (err = _bitMask.QueryError() )  )
    {
	ReportError( err ) ;
	return ;
    }

    _fcheckSuccess.Enable( TRUE ) ;
    _fcheckFailed.Enable( TRUE ) ;
    _fcheckSuccess.Show( TRUE ) ;
    _fcheckFailed.Show( TRUE ) ;

    _sltAuditName.SetText( nlsAuditName ) ;
}

AUDIT_CHECKBOXES::~AUDIT_CHECKBOXES()
{
	/* Nothing to do... */
}

/*******************************************************************

    NAME:	AUDIT_CHECKBOXES::Enable

    SYNOPSIS:	Enables or disables the checkboxes in this audit checkbox
		pair.  The checks are also removed.

    ENTRY:	fEnable - TRUE if enabling, FALSE if disabling

    NOTES:	When disabled, the checks will be removed, when renabled,
		they checks will *not* be restored.

    HISTORY:
	Johnl	22-Nov-1991	Created

********************************************************************/

void AUDIT_CHECKBOXES::Enable( BOOL fEnable, BOOL fClear )
{
    if ( fClear )
    {
	_fcheckSuccess.SetCheck( FALSE ) ;
	_fcheckFailed.SetCheck( FALSE ) ;
    }

    _fcheckSuccess.Enable( fEnable ) ;
    _fcheckFailed.Enable( fEnable ) ;
    _sltAuditName.Enable( fEnable ) ;
}


/*******************************************************************

    NAME:	SET_OF_AUDIT_CATEGORIES::SET_OF_AUDIT_CATEGORIES

    SYNOPSIS:	Constructor for SET_OF_AUDIT_CATEGORIES class

    ENTRY:
		pbitsSuccess, pbitsFailed - Default values to initialize
		    the checkboxes to.	If NULL, then all of the
		    checkboxes default to being in the unchecked state.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	30-Sep-1991	Created

********************************************************************/

SET_OF_AUDIT_CATEGORIES::SET_OF_AUDIT_CATEGORIES( OWNER_WINDOW * powin,
			 CID	    cidSLTBase,
			 CID	    cidCheckSuccessBase,
			 CID	    cidCheckFailedBase,
			 MASK_MAP * pmaskmapAuditInfo,
			 BITFIELD * pbitsSuccess,
			 BITFIELD * pbitsFailed,
                         INT        nID    )
    : _pAuditCheckboxes( NULL ),
      _cUsedAuditCheckboxes( 0 ),
      _pOwnerWindow( powin ),
      _cidSLTBase( cidSLTBase ),
      _cidSuccessCheckboxBase( cidCheckSuccessBase ),
      _cidFailedCheckboxBase( cidCheckFailedBase ),
      _nID( nID )
{
    if ( QueryError() )
	return ;

    if ( pmaskmapAuditInfo == NULL ||
	 (pmaskmapAuditInfo->QueryCount() < 1) )
    {
	UIASSERT(!SZ("Can't be NULL and must be more then one item in mask map") ) ;
	ReportError( ERROR_INVALID_PARAMETER ) ;
	return ;
    }

    _pAuditCheckboxes = (AUDIT_CHECKBOXES *) new BYTE[sizeof( AUDIT_CHECKBOXES )*pmaskmapAuditInfo->QueryCount()] ;
    if ( _pAuditCheckboxes == NULL )
    {
	ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
	return ;
    }

    APIERR err = SetCheckBoxNames( pmaskmapAuditInfo ) ;
    if ( err != NERR_Success )
    {
	ReportError( err ) ;
	return ;
    }

    if ( pbitsSuccess != NULL && pbitsFailed != NULL )
    {
	err = ApplyPermissionsToCheckBoxes( pbitsSuccess, pbitsFailed ) ;
	if ( err != NERR_Success )
	{
	    ReportError( err ) ;
	    return ;
	}
    }
}

SET_OF_AUDIT_CATEGORIES::~SET_OF_AUDIT_CATEGORIES()
{
    //
    //  UPDATED for C++ 2.0: this code used to read:
    //     delete [_cUsedAuditCheckboxes] _pAuditCheckboxes ;
    //  which is INVALID for a user-constructed vector.
    //

    for ( INT i = 0 ; i < _cUsedAuditCheckboxes ; i++ )
    {
        _pAuditCheckboxes[i].AUDIT_CHECKBOXES::~AUDIT_CHECKBOXES() ;
    }
    delete (void *) _pAuditCheckboxes ;

    _pAuditCheckboxes = NULL ;
    _cUsedAuditCheckboxes = 0 ;
}

/*******************************************************************

	NAME:	    SET_OF_AUDIT_CATEGRORIES::SetCheckBoxNames

	SYNOPSIS:   Constructs each audit checkbox set and sets the permissions
		    accordingly

	ENTRY:	    pAccessMap - Pointer to the MASK_MAP the ACCESS_PERMISSION
			is using

	EXIT:	    Each used dialog will have its name set and be enabled
		    and visible.  The _cUsedAuditCheckboxes will be set to the
		    number of checkboxes that were successfully constructed.

	RETURNS:    An APIERR if an error occurred

	NOTES:	    This is a *construction* method (i.e., meant to be called
		    from the constructor).

	HISTORY:
	    Johnl   30-Sep-1991 Created

********************************************************************/

APIERR SET_OF_AUDIT_CATEGORIES::SetCheckBoxNames( MASK_MAP * pAccessMaskMap )
{
    BOOL fMoreData ;
    BOOL fFromBeginning = TRUE ;
    NLS_STR nlsSpecialPermName( 40 ) ;
    BITFIELD bitMask( (ULONG) 0 ) ;
    APIERR err ;
    AUDIT_CHECKBOXES * pcheckTemp = _pAuditCheckboxes ;

    /* Loop through all of the special permission names and construct
     * each checkbox with the permission name and assocated bitmap.
     */
    while ( ( err = pAccessMaskMap->EnumStrings( &nlsSpecialPermName,
				                 &fMoreData,
			                         &fFromBeginning,
				                 _nID ) ) == NERR_Success
	    && fMoreData
          )
    {
	err = pAccessMaskMap->StringToBits( nlsSpecialPermName,
					    &bitMask,
					    _nID ) ;
	if ( err != NERR_Success )
		return err ;

	new (pcheckTemp)
                         AUDIT_CHECKBOXES( QueryOwnerWindow(),
					   QuerySLTBaseCID() + _cUsedAuditCheckboxes,
					   QuerySuccessBaseCID() + _cUsedAuditCheckboxes,
					   QueryFailedBaseCID() + _cUsedAuditCheckboxes,
					   nlsSpecialPermName,
					   bitMask ) ;

	if ( pcheckTemp->QueryError() != NERR_Success )
		return pcheckTemp->QueryError() ;

	_cUsedAuditCheckboxes++ ;
	pcheckTemp++ ;
    }

    if ( err != NERR_Success )
    {
      return err ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SET_OF_AUDIT_CATEGORIES::ApplyPermissionsToCheckBoxes

    SYNOPSIS:	This method checks all of the checkboxes that have the
		same bits set as the passed bitfields.

    ENTRY:	pbitsSuccess, pbitsFailed - Pointer to bitfields which contains
		    the checkmark criteria.

    EXIT:	All appropriate checkboxes will be selected or deselected
		as appropriate.

    RETURNS:	NERR_Success if successful

    NOTES:

    HISTORY:
	Johnl	30-Aug-1991	Created

********************************************************************/

APIERR SET_OF_AUDIT_CATEGORIES::ApplyPermissionsToCheckBoxes( BITFIELD * pbitsSuccess,
							      BITFIELD * pbitsFailed  )
{
    APIERR err = NERR_Success ;

    for ( int i = 0 ; i < QueryCount() ; i++ )
    {
	BITFIELD bitSTemp( *pbitsSuccess ) ;
	BITFIELD bitFTemp( *pbitsFailed ) ;

	if ( (err = bitSTemp.QueryError()) ||
	     (err = bitFTemp.QueryError())  )
	{
	    return err ;
	}

	/* Mask out all of the bits except for the ones we care about then
	 * check the box if the masks are equal.
	 */
	bitSTemp &= *QueryAuditCheckBox(i)->QueryMask() ;
	QueryAuditCheckBox(i)->CheckSuccess( *QueryAuditCheckBox(i)->QueryMask() == bitSTemp ) ;

	bitFTemp &= *QueryAuditCheckBox(i)->QueryMask() ;
	QueryAuditCheckBox(i)->CheckFailed( *QueryAuditCheckBox(i)->QueryMask() == bitFTemp ) ;
    }

    return NERR_Success ;
}


/*******************************************************************

    NAME:	SET_OF_AUDIT_CATEGORIES::QueryUserSelectedBits

    SYNOPSIS:	Builds a bitfield by examining all of the selected
		checkboxes and the associated bitfields.

    ENTRY:	pbitsSuccess, pbitsFailed - Pointer to bitfield that will
		receive the built bitfield.

    NOTES:	We resize the bits so they match the size of the audit bitmaps

    HISTORY:
	Johnl	30-Sep-1991 Created

********************************************************************/

APIERR SET_OF_AUDIT_CATEGORIES::QueryUserSelectedBits( BITFIELD * pbitsSuccess, BITFIELD * pbitsFailed )
{
    UIASSERT( pbitsSuccess != NULL ) ;
    UIASSERT( pbitsFailed != NULL ) ;
    APIERR err ;
    if ( (err = pbitsSuccess->Resize( QueryAuditCheckBox(0)->QueryMask()->QueryCount())) ||
	 (err = pbitsFailed->Resize( QueryAuditCheckBox(0)->QueryMask()->QueryCount()))   )
    {
	return err ;
    }

    pbitsSuccess->SetAllBits( OFF ) ;
    pbitsFailed->SetAllBits( OFF ) ;

    for ( INT i = 0 ; i < QueryCount() ; i++ )
    {
	if ( QueryAuditCheckBox(i)->IsSuccessChecked() )
	    *pbitsSuccess |= *QueryAuditCheckBox(i)->QueryMask() ;

	if ( QueryAuditCheckBox(i)->IsFailedChecked() )
	    *pbitsFailed |= *QueryAuditCheckBox(i)->QueryMask() ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SET_OF_AUDIT_CATEGORIES::Enable

    SYNOPSIS:	Enables or disables all of the audit checkboxes in this
		set of audit categories

    ENTRY:	fEnable - TRUE if the checkboxes should be enabled, FALSE
		    otherwise
		fClear - TRUE if the checkbox should be cleared prior to
		    enable/disable

    NOTES:

    HISTORY:
	Johnl	22-Nov-1991	Created

********************************************************************/

void SET_OF_AUDIT_CATEGORIES::Enable( BOOL fEnable, BOOL fClear )
{
    for ( INT i = 0 ; i < QueryCount() ; i++ )
	QueryAuditCheckBox(i)->Enable( fEnable, fClear ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\browmemb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    BrowMemb.cxx

    This file contains the implementation for the Group Membership
    subdialogs of the User Browser dialog.

    FILE HISTORY:
        JonN        20-Oct-1992 Created

    CODEWORK Single selection is not yet implemented (filed as Pr4 bug)
*/

#include "pchapplb.hxx"   // Precompiled header

#include "browmemb.hxx"


DECLARE_SLIST_OF(OS_SID) ;
DEFINE_SLIST_OF(OS_SID) ;

/*******************************************************************

    NAME:       NT_GROUP_BROWSER_DIALOG::NT_GROUP_BROWSER_DIALOG

    SYNOPSIS:   Constructor for the base group browser dialog

    ENTRY:      pszDlgName           - Resource name of the dialog
                                        (supplied for possible derivation).
                hwndOwner            - Owner hwnd
                pdlgUserBrowser      - Pointer to the User Browser dialog at
                                        the heart of this.  This is usually
                                        hwndOwner, but isn't if the user
                                        presses "&Members" in a Local Group
                                        Browser dialog.
                pszDomainDisplayName - used to build the group name in the SLT.
                pszGroupName         - used to build the group name in the SLT.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        JonN        20-Oct-1992 Created

********************************************************************/

NT_GROUP_BROWSER_DIALOG::NT_GROUP_BROWSER_DIALOG(
                        const TCHAR *            pszDlgName,
                        HWND                     hwndOwner,
                        NT_USER_BROWSER_DIALOG * pdlgUserBrowser,
                        const TCHAR *            pszDomainDisplayName,
                        const TCHAR *            pszGroupName )
    : DIALOG_WINDOW             ( pszDlgName, hwndOwner ),
      _buttonOK                 ( this, IDOK ),
      _sltGroupText             ( this, SLT_SHOW_BROWSEGROUP ),
      _pdlgUserBrowser          ( pdlgUserBrowser ),
      _pdlgSourceDialog         ( this ),
      _lbAccounts               ( this, LB_ACCOUNTS )
{
    ASSERT( pdlgUserBrowser != NULL && pszGroupName != NULL );

    if ( QueryError() )
        return ;

    NLS_STR nlsGroupText;
    NLS_STR nlsQualifiedGroupName;
    ALIAS_STR nlsDomainDisplayName( pszDomainDisplayName );
    ALIAS_STR nlsGroupName( pszGroupName );

    APIERR err;
    if (   (err = nlsGroupText.QueryError()) != NERR_Success
        || (err = nlsQualifiedGroupName.QueryError()) != NERR_Success
        || (err = NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                        &nlsQualifiedGroupName,
                        nlsGroupName,
                        nlsDomainDisplayName )) != NERR_Success // always qualify
        || (err = _sltGroupText.QueryText( &nlsGroupText )) != NERR_Success
        || (err = nlsGroupText.InsertParams( nlsQualifiedGroupName )) != NERR_Success
       )
    {
        ReportError( err );
        return;
    }

    _sltGroupText.SetText( nlsGroupText );

}

NT_GROUP_BROWSER_DIALOG::~NT_GROUP_BROWSER_DIALOG()
{
    if ( this != _pdlgSourceDialog )
        delete _pdlgSourceDialog;
    _pdlgSourceDialog = NULL ;
}


/*******************************************************************

    NAME:       NT_GROUP_BROWSER_DIALOG::QueryHelpFile

    SYNOPSIS:   Returns the help file name to use for this instance of
                dialog

    NOTES:

    HISTORY:
        JonN        20-Oct-1992 Created

********************************************************************/

const TCHAR * NT_GROUP_BROWSER_DIALOG::QueryHelpFile( ULONG ulHelpContext )
{
    return _pdlgUserBrowser->QueryHelpFile( ulHelpContext );
}


/*******************************************************************

    NAME:       NT_GROUP_BROWSER_DIALOG::OnCommand

    SYNOPSIS:   Typical OnCommand for this dialog, we catch pressing
                the Members button and changing the selection in the
                listbox

    EXIT:

    RETURNS:

    NOTES:	The Members button is enabled any time a single group
                is selected in the listbox.

    HISTORY:
        JonN    04-Nov-1992     Created
********************************************************************/

BOOL NT_GROUP_BROWSER_DIALOG::OnCommand( const CONTROL_EVENT & event )
{
    APIERR err = NERR_Success ;

    switch ( event.QueryCid() )
    {
    case LB_ACCOUNTS:
	switch ( event.QueryCode() )
	{

	// case LBN_SELCHANGE:
        // default:
	//     break ;

	case LBN_DBLCLK:
            return OnOK() ; // no need to redefine this virtual here
	}
        UpdateButtonState() ;
	break ;

    default:
        return DIALOG_WINDOW::OnCommand( event ) ;
    }

    return TRUE ;
}


/*******************************************************************

    NAME:       NT_GROUP_BROWSER_DIALOG::UpdateButtonState

    SYNOPSIS:   Changes the state of the Add button

    EXIT:

    RETURNS:

    NOTES:	The Members button is enabled any time a single group
                is selected in the listbox.

    HISTORY:
        JonN    04-Nov-1992     Created
********************************************************************/
void NT_GROUP_BROWSER_DIALOG::UpdateButtonState( void )
{
    BOOL fSelection = ( _lbAccounts.QuerySelCount() != 0 );
    if (fSelection)
	_buttonOK.MakeDefault() ;
    else
    {
        // sets default to nothing, method as recommended by Ian James
        WPARAM styleNew = _buttonOK.QueryStyle();
        styleNew = (styleNew & ~BS_DEFPUSHBUTTON) | BS_PUSHBUTTON;
        (void) _buttonOK.Command( BM_SETSTYLE,
                                  styleNew,
                                  TRUE ); // TRUE -> redraw button
    }
}


/*******************************************************************

    NAME:       NT_LOCALGROUP_BROWSER_DIALOG::NT_LOCALGROUP_BROWSER_DIALOG

    SYNOPSIS:   Constructor for the Local Group browser dialog

                hwndOwner            - Owner hwnd
                pdlgUserBrowser      - User Browser dialog which started this
                pszDomainDisplayName - name of display containing localgroup
                pszGroupName         - qualified groupname
                possidGroup          - SID of localgroup
                psamdomGroup         - SAM_DOMAIN containing localgroup
                psamdomTarget        - Accounts SAM_DOMAIN where the resource lives.
                plsapolTarget        - LSA handle where the resource lives.
                pszServerTarget      - Name of server (in "\\server" form)
                                        the resource lives on.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        JonN        20-Oct-1992 Created

********************************************************************/

NT_LOCALGROUP_BROWSER_DIALOG::NT_LOCALGROUP_BROWSER_DIALOG(
                        HWND                     hwndOwner,
                        NT_USER_BROWSER_DIALOG * pdlgUserBrowser,
                        const TCHAR *            pszDomainDisplayName,
                        const TCHAR *            pszGroupName,
                        const OS_SID *           possidGroup,
                        const SAM_DOMAIN *       psamdomGroup,
                        const SAM_DOMAIN *       psamdomTarget,
                              LSA_POLICY *       plsapolTarget,
                        const TCHAR *            pszServerTarget )
    : NT_GROUP_BROWSER_DIALOG   ( (pdlgUserBrowser->IsSingleSelection())
                                    ? MAKEINTRESOURCE(IDD_LGRPBROWS_1SEL_DLG)
                                    : MAKEINTRESOURCE(IDD_LGRPBROWS_DLG),
                                  hwndOwner,
                                  pdlgUserBrowser,
                                  pszDomainDisplayName,
                                  pszGroupName ),
      _buttonMembers   ( this, USR_BUTTON_MEMBERS ),
      _psamdomTarget   ( psamdomTarget ),
      _plsapolTarget   ( plsapolTarget ),
      _pszServerTarget ( pszServerTarget )
{
    if ( QueryError() )
        return ;

    AUTO_CURSOR cursHourGlass;

    APIERR err = _lbAccounts.FillLocalGroupMembers( possidGroup,
                                                    psamdomGroup,
                                                    psamdomTarget,
                                                    plsapolTarget,
                                                    pszServerTarget );
    if (err != NERR_Success)
    {
        TRACEEOL( "USRBROWS: BROWMEMB: Could not fill listbox: " << err );
        ReportError( err );
        return;
    }

    _lbAccounts.Invalidate( TRUE ) ;
    UpdateButtonState() ;
}

NT_LOCALGROUP_BROWSER_DIALOG::~NT_LOCALGROUP_BROWSER_DIALOG()
{
}


/*******************************************************************

    NAME:       NT_LOCALGROUP_BROWSER_DIALOG::QueryHelpContext

    SYNOPSIS:   Typical help context query for this dialog

    HISTORY:
        JonN        20-Oct-1992 Created

********************************************************************/

ULONG NT_LOCALGROUP_BROWSER_DIALOG::QueryHelpContext( void )
{
    ULONG ulHelpContextLocalMembership =
         QueryUserBrowserDialog()->QueryHelpContextLocalMembership();

    if ( ulHelpContextLocalMembership == 0 )
    {
        ulHelpContextLocalMembership =
            QueryUserBrowserDialog()->QueryHelpContext()
            + USRBROWS_HELP_OFFSET_LOCALGROUP;
    }

    return ulHelpContextLocalMembership;
}


/*******************************************************************

    NAME:       NT_LOCALGROUP_BROWSER_DIALOG::OnCommand

    SYNOPSIS:   Typical OnCommand for this dialog, we catch pressing
                the Members button.

    EXIT:

    RETURNS:

    NOTES:	The Members button is enabled any time a single group
                is selected in the listbox.

    HISTORY:
        JonN    04-Nov-1992     Created
********************************************************************/

BOOL NT_LOCALGROUP_BROWSER_DIALOG::OnCommand( const CONTROL_EVENT & event )
{
    switch ( event.QueryCid() )
    {
    case USR_BUTTON_MEMBERS:
        {
	    APIERR err = OnMembers() ;
            if (err != NERR_Success)
                MsgPopup( this, err );

	     UpdateButtonState() ;
        }
	break ;

    default:
        return NT_GROUP_BROWSER_DIALOG::OnCommand( event ) ;
    }

    return TRUE ;
}


/*******************************************************************

    NAME:       NT_LOCALGROUP_BROWSER_DIALOG::OnMembers

    SYNOPSIS:   Handles the "Members" button

    NOTES:

    HISTORY:
        JonN        26-Oct-1992 Created

********************************************************************/

APIERR NT_LOCALGROUP_BROWSER_DIALOG::OnMembers( void )
{
    APIERR err = NERR_Success;

    if (_lbAccounts.QuerySelCount() != 1)
    {
        UIASSERT( FALSE );
        return ERROR_GEN_FAILURE;
    }
    USER_BROWSER_LBI * pgblbi = (USER_BROWSER_LBI*) _lbAccounts.QueryItem() ;
    if (pgblbi == NULL)
    {
        UIASSERT( FALSE );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ASSERT ( pgblbi->QueryType() == SidTypeGroup ) ;

    NT_GLOBALGROUP_BROWSER_DIALOG * pntggbdlg = new NT_GLOBALGROUP_BROWSER_DIALOG(
                        this->QueryHwnd(),
                        QueryUserBrowserDialog(),
                        pgblbi->QueryDomainName(),
                        pgblbi->QueryAccountName(),
                        pgblbi->QueryOSSID(),
                        _psamdomTarget,
                        _plsapolTarget,
                        _pszServerTarget );
    BOOL fShouldAdd;
    err = ERROR_NOT_ENOUGH_MEMORY;
    if (   (pntggbdlg == NULL)
        || (err = pntggbdlg->QueryError()) != NERR_Success
        || (err = pntggbdlg->Process( &fShouldAdd )) != NERR_Success
       )
    {
        return err;
    }

    if (fShouldAdd)
    {
        //
        // If the user clicked "Add" but didn't select any users, we want
        // to add the global group.  If we set the source dialog to pntggbdlg
        // but none of its listbox items are selected, the caller will add
        // the local group instead.  Therefore, we only set the source dialog
        // if at least one item is selected.  Otherwise, "this" remains
        // the source dialog and the global group will be added.
        //
        if (pntggbdlg->QuerySourceListbox()->QuerySelCount() > 0)
        {
            SetSourceDialog( pntggbdlg );
        }
        Dismiss( TRUE );
    }
    else
    {
        delete pntggbdlg;
        pntggbdlg = NULL;
    }

    return NERR_Success;
}



/*******************************************************************

    NAME:       NT_LOCALGROUP_BROWSER_DIALOG::UpdateButtonState

    SYNOPSIS:   Changes the state of the Members button

    EXIT:

    RETURNS:

    NOTES:	The Members button is enabled any time a single group
                is selected in the listbox.

    HISTORY:
        JonN    04-Nov-1992     Created
********************************************************************/
void NT_LOCALGROUP_BROWSER_DIALOG::UpdateButtonState( void )
{
    _buttonMembers.Enable( _lbAccounts.IsSelectionExpandableGroup() );

    NT_GROUP_BROWSER_DIALOG::UpdateButtonState();
}


/*******************************************************************

    NAME:       NT_GLOBALGROUP_BROWSER_DIALOG::NT_GLOBALGROUP_BROWSER_DIALOG

    SYNOPSIS:   Constructor for the Global Group browser dialog

    ENTRY:
                hwndOwner            - Owner hwnd
                pdlgUserBrowser      - User Browser dialog which started this
                pszDomainDisplayName - name of display containing globalgroup
                pszGroupName         - qualified groupname
                possidGroup          - SID of globalgroup
                psamdomGroup         - SAM_DOMAIN containing globalgroup
                psamdomTarget        - Accounts SAM_DOMAIN where the resource lives.
                plsapolTarget        - LSA handle where the resource lives.
                pszServerTarget      - Name of server (in "\\server" form)
                                        the resource lives on.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        JonN        29-Oct-1992 Created

********************************************************************/

NT_GLOBALGROUP_BROWSER_DIALOG::NT_GLOBALGROUP_BROWSER_DIALOG(
                        HWND            hwndOwner,
                        NT_USER_BROWSER_DIALOG * pdlgUserBrowser,
                        const TCHAR * pszDomainDisplayName,
                        const TCHAR * pszGroupName,
                        const OS_SID * possidGroup,
                        const SAM_DOMAIN * psamdomTarget,
                              LSA_POLICY * plsapolTarget,
                        const TCHAR * pszServerTarget )
    : NT_GROUP_BROWSER_DIALOG   ( (pdlgUserBrowser->IsSingleSelection())
                                    ? MAKEINTRESOURCE(IDD_GGRPBROWS_1SEL_DLG)
                                    : MAKEINTRESOURCE(IDD_GGRPBROWS_DLG),
                                  hwndOwner,
                                  pdlgUserBrowser,
                                  pszDomainDisplayName,
                                  pszGroupName )
{
    if ( QueryError() )
        return ;

    AUTO_CURSOR cursHourGlass;

    BROWSER_DOMAIN * pbrowdom = NULL;
    APIERR err = NERR_Success;

    {
        OS_SID ossidGroupDomain( possidGroup->QueryPSID(), (BOOL)TRUE );
        ULONG ulLastSubAuthority;
        if (   (err = ossidGroupDomain.QueryError()) != NERR_Success
            || (err = ossidGroupDomain.TrimLastSubAuthority( &ulLastSubAuthority )) != NERR_Success
            || (err = ((ulLastSubAuthority == DOMAIN_GROUP_RID_USERS)
                                ? IDS_USRBROWS_CANT_SHOW_DOMAIN_USERS
                                : NERR_Success )) != NERR_Success
           )
        {
            ReportError( err );
            return;
        }

        // groups are never in builtin domain
        pbrowdom = pdlgUserBrowser->FindDomain( &ossidGroupDomain );
    }

    if ( pbrowdom == NULL )
    {
        // bad domain
        ReportError( IDS_CANT_BROWSE_GLOBAL_GROUP );
        return;
    }

    if ( !pbrowdom->IsInitialized() )
    {
	err = pbrowdom->GetDomainInfo( pdlgUserBrowser );
        if (err != NERR_Success)
        {
            TRACEEOL( "User Browser: error " << err << " in GetDomainInfo()" );
            ReportError( err );
            return;
        }
    }

    err = pbrowdom->WaitForAdminAuthority();
    if (err != NERR_Success)
    {
        TRACEEOL( "User Browser: error " << err << " in WaitForAdminAuthority()" );
        ReportError( err );
        return;
    }

    if(   pbrowdom->QueryAdminAuthority() == NULL
       || pbrowdom->QueryAccountDomain() == NULL
       || pbrowdom->QueryAccountDomain()->QueryError() != NERR_Success )
    {
        err = pbrowdom->QueryErrorLoadingAuthority();
        ASSERT( err != NERR_Success );
        TRACEEOL( "User Browser: error " << err << ", no ADMIN_AUTHORITY " );
        ReportError( err );
        return;
    }

    ASSERT(   pbrowdom->QueryAccountDomain() != NULL
           && pbrowdom->QueryAccountDomain()->QueryError() == NERR_Success );

    err = _lbAccounts.FillGlobalGroupMembers( possidGroup,
                                              pbrowdom->QueryAccountDomain(),
                                              psamdomTarget,
                                              plsapolTarget,
                                              pszServerTarget );
    if (err != NERR_Success)
    {
        TRACEEOL( "USRBROWS: BROWMEMB: Could not fill listbox: " << err );
        ReportError( err );
        return;
    }

    _lbAccounts.Invalidate( TRUE ) ;
    UpdateButtonState() ;

}

NT_GLOBALGROUP_BROWSER_DIALOG::~NT_GLOBALGROUP_BROWSER_DIALOG()
{
}


/*******************************************************************

    NAME:       NT_GLOBALGROUP_BROWSER_DIALOG::QueryHelpContext

    SYNOPSIS:   Typical help context query for this dialog

    HISTORY:
        JonN        20-Oct-1992 Created

********************************************************************/

ULONG NT_GLOBALGROUP_BROWSER_DIALOG::QueryHelpContext( void )
{
    ULONG ulHelpContextGlobalMembership =
          QueryUserBrowserDialog()->QueryHelpContextGlobalMembership();

    if ( ulHelpContextGlobalMembership == 0 )
    {
        ulHelpContextGlobalMembership =
            QueryUserBrowserDialog()->QueryHelpContext()
            + USRBROWS_HELP_OFFSET_GLOBALGROUP;
    }

    return ulHelpContextGlobalMembership;
}


/*************************************************************************

    NAME:	NT_GROUP_BROWSER_LB

    SYNOPSIS:   This listbox lists the contents of a local or global group

    INTERFACE:

    PARENT:     USER_BROWSER_LB

    CAVEATS:

    NOTES:

    HISTORY:
	JonN 	20-Oct-1992	Created

**************************************************************************/

NT_GROUP_BROWSER_LB::NT_GROUP_BROWSER_LB( OWNER_WINDOW * powin,
                                          CID cid )
    : USER_BROWSER_LB ( powin, cid ),
      _lbicache()
{
    if ( QueryError() )
	return ;

    APIERR err ;
    if ( (err = _lbicache.QueryError()) )
    {
	ReportError( err ) ;
	return ;
    }

    //
    //	This is where the LBIs will be stored
    //
    SetCurrentCache( &_lbicache ) ;
}

NT_GROUP_BROWSER_LB::~NT_GROUP_BROWSER_LB()
{
    /* Nothing to do */
}



/*******************************************************************

    NAME:       NT_GROUP_BROWSER_LB::FillLocalGroupMembers

    SYNOPSIS:   Adds LBIs corresponding to members of a local group

    NOTES:      psamdomGroup is the domain the group is in
                psamdomTarget is the domain of focus (may be NULL)

    HISTORY:
        JonN        20-Oct-1992 Created

********************************************************************/

APIERR NT_GROUP_BROWSER_LB::FillLocalGroupMembers(
                        const OS_SID *     possidGroup,
                        const SAM_DOMAIN * psamdomGroup,
                        const SAM_DOMAIN * psamdomTarget,
                              LSA_POLICY * plsapolTarget,
                        const TCHAR *      pszServerTarget )
{
    UIASSERT( possidGroup  != NULL  && possidGroup->QueryError()   == NERR_Success );
    UIASSERT( psamdomGroup  != NULL && psamdomGroup->QueryError()  == NERR_Success );
    UNREFERENCED( psamdomTarget );
    UIASSERT( plsapolTarget != NULL && plsapolTarget->QueryError() == NERR_Success );

    APIERR err = NERR_Success;
    PULONG pulRID;

    // Determine localgroup RID

    // CODEWORK We need an OS_SID::QueryRID method
    if (   (err = possidGroup->QueryLastSubAuthority( &pulRID )) != NERR_Success
       )
    {
        TRACEEOL( "USRBROWS: BROWMEMB: Could not determine localgroup RID: " << err );
        return err;
    }

    // Determine localgroup membership

    SAM_ALIAS samalias( *psamdomGroup, *pulRID, ALIAS_LIST_MEMBERS );
    SAM_SID_MEM samsm;

    if (   (err = samalias.QueryError()) != NERR_Success
        || (err = samsm.QueryError()) != NERR_Success
        || (err = samalias.GetMembers( &samsm )) != NERR_Success
       )
    {
        TRACEEOL( "USRBROWS: BROWMEMB: Could not determine localgroup membership: " << err );
        return err;
    }

    if (samsm.QueryCount() == 0)
        return NERR_Success;

    return Fill( samsm.QueryPtr(),
                 samsm.QueryCount(),
                 NULL,
                 plsapolTarget,
                 pszServerTarget );
}


/*******************************************************************

    NAME:       NT_GROUP_BROWSER_LB::FillGlobalGroupMembers

    SYNOPSIS:   Adds LBIs corresponding to members of a global group

    NOTES:      psamdomGroup is the domain the group is in
                psamdomTarget is the domain of focus

    HISTORY:
        JonN        20-Oct-1992 Created

********************************************************************/

APIERR NT_GROUP_BROWSER_LB::FillGlobalGroupMembers(
                        const OS_SID *     possidGroup,
                        const SAM_DOMAIN * psamdomGroup,
                        const SAM_DOMAIN * psamdomTarget,
                              LSA_POLICY * plsapolTarget,
                        const TCHAR *      pszServerTarget )
{
    UIASSERT( possidGroup   != NULL && possidGroup->QueryError()   == NERR_Success );
    UIASSERT( psamdomGroup  != NULL && psamdomGroup->QueryError()  == NERR_Success );
    UIASSERT( psamdomTarget != NULL && psamdomTarget->QueryError() == NERR_Success );
    UIASSERT( plsapolTarget != NULL && plsapolTarget->QueryError() == NERR_Success );

    APIERR err = NERR_Success;
    PULONG pulRID;

    // Determine globalgroup RID

    if (   (err = possidGroup->QueryLastSubAuthority( &pulRID )) != NERR_Success
       )
    {
        TRACEEOL( "USRBROWS: BROWMEMB: Could not determine globalgroup RID: " << err );
        return err;
    }

    // Determine globalgroup membership

    SAM_GROUP samgroup( *psamdomGroup, *pulRID, GROUP_LIST_MEMBERS );
    SAM_RID_MEM samrm;

    if (   (err = samgroup.QueryError()) != NERR_Success
        || (err = samrm.QueryError()) != NERR_Success
        || (err = samgroup.GetMembers( &samrm )) != NERR_Success
       )
    {
        TRACEEOL( "USRBROWS: BROWMEMB: Could not determine globalgroup membership: " << err );
        return err;
    }

    if (samrm.QueryCount() == 0)
        return NERR_Success;

    // Build list of SIDS for members of globalgroup.  Each SID is a copy
    // of the globalgroup SID with a changed RID.

    ULONG cMembers = samrm.QueryCount();
    BUFFER bufPOSSID( (UINT) (sizeof(PVOID) * cMembers) );
    BUFFER bufPSID  ( (UINT) (sizeof(PVOID) * cMembers) );

    OS_SID ossidTemp( possidGroup->QueryPSID(), (BOOL)TRUE );
    PULONG pulRIDTemp;

    if (   (err = bufPOSSID.QueryError()) != NERR_Success
        || (err = bufPSID.QueryError()) != NERR_Success
        || (err = ossidTemp.QueryError()) != NERR_Success
        || (err = ossidTemp.QueryLastSubAuthority( &pulRIDTemp )) != NERR_Success
       )
    {
        TRACEEOL( "USRBROWS: BROWMEMB: Could not allocate memory: " << err );
        return err;
    }

    OS_SID ** ppossid = (OS_SID **) bufPOSSID.QueryPtr();
    PSID * ppsid = (PSID *) bufPSID.QueryPtr();

    for (ULONG i = 0; i < cMembers; i++)
    {
        ppossid[i] = NULL;
        ppsid[i] = NULL;
    }

    for (i = 0; (err == NERR_Success) && (i < cMembers); i++)
    {
        // Change the RID in ossidTemp
        *pulRIDTemp = samrm.QueryRID(i);

        // Make a copy of ossidTemp and store it in the array
        ppossid[i] = new OS_SID( ossidTemp.QueryPSID(), (BOOL)TRUE );

        if ( ppossid[i] == NULL )
            err = ERROR_NOT_ENOUGH_MEMORY;
        else if ( (err = ppossid[i]->QueryError()) == NERR_Success )
            ppsid[i] = ppossid[i]->QueryPSID();
    }

    // now don't return until the OS_SIDs are freed

    if (err == NERR_Success)
    {
        err = Fill( ppsid,
                    cMembers,
                    psamdomTarget,
                    plsapolTarget,
                    pszServerTarget );
    }
    else
    {
        TRACEEOL( "USRBROWS: BROWMEMB: Could not allocate SIDs: " << err );
    }

    for (i = 0; i < cMembers; i++)
    {
        delete ppossid[i];
        ppossid[i] = NULL;
    }

    return err;
}


/*******************************************************************

    NAME:       NT_GROUP_BROWSER_LB::Fill

    SYNOPSIS:   Adds LBIs corresponding to listed SIDs

    NOTES:      If psamdomTarget is NULL then all names are qualified

    HISTORY:
        JonN        20-Oct-1992 Created

********************************************************************/

APIERR NT_GROUP_BROWSER_LB::Fill( const PSID *	     apsidMembers,
                                  ULONG              cMembers,
                                  const SAM_DOMAIN * psamdomTarget,
                                        LSA_POLICY * plsapolTarget,
                                  const TCHAR *      pszServerTarget )
{
    APIERR err = ::CreateLBIsFromSids(
				 apsidMembers,
				 cMembers,
                                 ( (psamdomTarget == NULL)
                                        ? NULL
				        : psamdomTarget->QueryPSID() ),
				 plsapolTarget,
				 pszServerTarget,
				 this,
				 NULL ) ;

    SetCount( QueryCurrentCache()->QueryCount() ) ;
    return err ;
}

/*******************************************************************

    NAME:	::CreateLBIsFromSids

    SYNOPSIS:	Helper routine that converts an array of sids to LBIs.	Will
		add to either the passed listbox pointer or the array of
		paplbi

    NOTES:	If publb is not NULL, the LBIs are added to publb.  If paplbi
		if not NULL, the LBIs are added to paplbi.

    HISTORY:
	Johnl	12-Dec-1992	Broke off from NT_GROUP_BROWSER_LB::Fill

********************************************************************/

APIERR CreateLBIsFromSids( const PSID *       apsidMembers,
			   ULONG	      cMembers,
			   const PSID	      psidSamDomainTarget,
				 LSA_POLICY * plsapolTarget,
			   const TCHAR *      pszServerTarget,
			   USER_BROWSER_LB *  publb,
			   SLIST_OF(USER_BROWSER_LBI) * psllbi )
{
    UIASSERT( plsapolTarget != NULL && plsapolTarget->QueryError() == NERR_Success );

    if (cMembers == 0)
        return NERR_Success;

    BUFFER bufUserFlags( (UINT) (sizeof(ULONG)        * cMembers) );
    BUFFER bufSidUse   ( (UINT) (sizeof(SID_NAME_USE) * cMembers) );
    STRLIST strlistQualifiedNames;
    STRLIST strlistAccountNames;
    STRLIST strlistFullNames;
    STRLIST strlistComments;
    STRLIST strlistDomainNames;

    APIERR err = NERR_Success;
    if (   (err = bufUserFlags.QueryError()) != NERR_Success
        || (err = bufSidUse.QueryError()) != NERR_Success
        || (err = NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames(
                        *plsapolTarget,
			psidSamDomainTarget,
                        apsidMembers,
                        cMembers,
                        TRUE,                       // fFullNames
                        &strlistQualifiedNames,
                        (ULONG *) bufUserFlags.QueryPtr(),
                        (SID_NAME_USE *) bufSidUse.QueryPtr(),
                        NULL,                       // perrNonFatal
                        pszServerTarget, // used for:  NetUserGetInfo[2]
                                         //            qualifying name
                        &strlistAccountNames,
                        &strlistFullNames,
                        &strlistComments,
                        &strlistDomainNames )) != NERR_Success
       )
    {
	TRACEEOL( "USRBROWS: CreateLBIsFromSids: Could not get account information: " << err );
        return err;
    }

    ITER_STRLIST iterQualifiedNames( strlistQualifiedNames );
    ITER_STRLIST iterAccountNames  ( strlistAccountNames   );
    ITER_STRLIST iterFullNames     ( strlistFullNames      );
    ITER_STRLIST iterComments      ( strlistComments       );
    ITER_STRLIST iterDomainNames   ( strlistDomainNames    );
    NLS_STR *    pnlsQualifiedName;
    NLS_STR *    pnlsAccountName;
    NLS_STR *    pnlsFullName;
    NLS_STR *    pnlsComment;
    NLS_STR *    pnlsDomainName;

    for ( ULONG i = 0; i < cMembers; i++ )
    {
        // We must have at least as many strings as SIDs
        REQUIRE( (pnlsQualifiedName = iterQualifiedNames.Next()) != NULL );
        REQUIRE( (pnlsAccountName   = iterAccountNames.Next())   != NULL );
        REQUIRE( (pnlsFullName      = iterFullNames.Next())      != NULL );
        REQUIRE( (pnlsComment       = iterComments.Next())       != NULL );
        REQUIRE( (pnlsDomainName    = iterDomainNames.Next())    != NULL );

        USER_BROWSER_LBI * pntublbi = new USER_BROWSER_LBI(
                pnlsAccountName   ? pnlsAccountName->QueryPch()   : NULL,
                pnlsFullName      ? pnlsFullName->QueryPch()      : NULL,
                pnlsQualifiedName ? pnlsQualifiedName->QueryPch() : NULL,
                pnlsComment       ? pnlsComment->QueryPch()       : NULL,
                pnlsDomainName    ? pnlsDomainName->QueryPch()    : NULL,
                apsidMembers[i],
                UI_SID_Invalid,
                ((SID_NAME_USE *)(bufSidUse.QueryPtr()))[i],
                ((ULONG *)(bufUserFlags.QueryPtr()))[i] );

        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   pntublbi == NULL
            || (err = pntublbi->QueryError()) != NERR_Success
           )
        {
            delete pntublbi;
            TRACEEOL( "USRBROWS: BROWMEMB: Could not create LBI: " << err );
            return err;
        }

	//
	//  Add to the listbox or the cache
	//
	if ( publb != NULL )
	{
	    if ( publb->AddItem( pntublbi ) < 0 )
	    {
		// Will be deleted by AddItem in case of error
		TRACEEOL( "USRBROWS: BROWMEMB: Could not add LBI" );
		return ERROR_NOT_ENOUGH_MEMORY;
	    }
	}
	else if ( psllbi != NULL )
	{
	    if ( err = psllbi->Append( pntublbi ))
	    {
		delete pntublbi ;
		return err ;
	    }
	}
	else
	{
	    UIASSERT(FALSE) ;
	}
    }

    // We should not have more strings than SIDs
    ASSERT( (pnlsQualifiedName = iterQualifiedNames.Next()) == NULL );
    ASSERT( (pnlsAccountName   = iterAccountNames.Next())   == NULL );
    ASSERT( (pnlsFullName      = iterFullNames.Next())      == NULL );
    ASSERT( (pnlsComment       = iterComments.Next())       == NULL );
    ASSERT( (pnlsDomainName    = iterDomainNames.Next())    == NULL );

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\devcb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    devcb.cxx
    BLT device combo and domain combo definitions

    FILE HISTORY:
        rustanl     28-Nov-1990 Created
        beng        11-Feb-1991 Uses lmui.hxx
        rustanl     20-Mar-1991 Added cbMaxLen parameter to DOMAIN_COMBO ct
        rustanl     21-Mar-1991 Folded in code review changes from
                                CR on 20-Mar-1991 attended by
                                JimH, GregJ, Hui-LiCh, RustanL.
        beng        14-May-1991 Exploded blt.hxx into components
        beng        22-Sep-1991 Relocated from BLT into Applib
        terryk      07-Oct-1991 type changes for NT

*/

#include "pchapplb.hxx"   // Precompiled header


/***********************************************************************

    NAME:       DEVICE_COMBO::DEVICE_COMBO

    SYNOPSIS:   Fills a combo box with devices (spec'd by parms).
                Selects first item in combo.

    ENTRY:
       powin             Pointer to owner window
       cid               ID of control
       lmodevType        Indicates which type of device (e.g., disk, printer)
       devusage  Indicates which particular devices go into the
                       combo box (e.g., devices currently available for
                       new connections)
    EXIT:

    NOTES:
       The DEVICE_COMBO control should not use the CBS_SORT style.  Instead,
       the control will insert the devices in the correct order.

    HISTORY:
        rustanl     28-Nov-1990 Created
        beng        31-Jul-1991 Error reporting changed
        beng        05-Oct-1991 Win32 conversion

***********************************************************************/

DEVICE_COMBO::DEVICE_COMBO( OWNER_WINDOW * powin,
                            CID cid,
                            LMO_DEVICE lmodevType,
                            LMO_DEV_USAGE devusage )
    : COMBOBOX( powin, cid ),
      _lmodevType( lmodevType ),
      _devusage( devusage ),
      _fDefSelLast( devusage == LMO_DEV_ALLDEVICES_DEFZ )
{
    if (QueryError())
        return;

    if ( _devusage == LMO_DEV_ALLDEVICES_DEFZ )
    {
        _devusage = LMO_DEV_ALLDEVICES;
    }

    //  Fill devices
    APIERR err = FillDevices();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/**********************************************************************

    NAME:       DEVICE_COMBO::FillDevices

    SYNOPSIS:   Appends the names of the devices to the combo.

    ENTRY:      NONE

    RETURN:     Error value, which is NERR_Success on success.

    NOTES:
        Private member.

    HISTORY:
        rustanl     28-Nov-1990 Created
        beng        05-Oct-1991 Win32 conversion

**********************************************************************/

APIERR DEVICE_COMBO::FillDevices()
{
    ITER_DEVICE idev( _lmodevType, _devusage );

    INT cDevsAdded = 0;
    const TCHAR * pszDev;
    while ( ( pszDev = idev()) != NULL )
    {
        if ( AddItem( pszDev ) < 0 )
            return ERROR_NOT_ENOUGH_MEMORY;

        cDevsAdded++;
    }

    //  Finally, select the first item, unless no items were inserted
    if ( cDevsAdded > 0 )
    {
        SelectItem( _fDefSelLast ? cDevsAdded - 1 : 0 );
    }

    return NERR_Success;
}


/**********************************************************************

    NAME:       DEVICE_COMBO::Refresh

    SYNOPSIS:   This method refreshes the contents of the combo box.
                Then, it selects first item in the list, if any, or
		the last device depending on _fDefSelLast.

    RETURN:     An error value, which is NERR_Success on success.

    HISTORY:
        rustanl     28-Nov-1990 Created
        rustanl     26-Mar-1991 Changed how new selection is made
        beng        05-Oct-1991 Win32 conversion

**********************************************************************/

APIERR DEVICE_COMBO::Refresh()
{
    SetRedraw( FALSE );

    DeleteAllItems();

    //  Add the devices.  Keep the error for below.  Note, that the
    //  code in between is always executed regardless of the success
    //  of FillDevices.
    APIERR err = FillDevices();

    //  Set new selection
    if ( QueryCount() > 0 )
        SelectItem( _fDefSelLast ? QueryCount() - 1 : 0 );

    SetRedraw( TRUE );
    Invalidate( TRUE );

    return err;
}


/**********************************************************************

    NAME:       DEVICE_COMBO::QueryDevice

    SYNOPSIS:   Returns the currently selected device name.

    ENTRY:
       pnlsDevice        Pointer to NLS_STR object.  To be safe, an owner
                       alloc'd NLS_STR should be able to accomodate of string
                       of length DEVLEN.

    RETURN:     An error value, which is NERR_Success on success.

    NOTES:
       QueryTextItem( NLS_STR ) could be used to retrieve the device
       name, but since the length of the device is know, QueryItemText(
       TCHAR, USHORT ) is used instead for efficiency.

    HISTORY:
        rustanl     28-Nov-1990 Created
        beng        05-Oct-1991 Win32 conversion

**********************************************************************/

APIERR DEVICE_COMBO::QueryDevice( NLS_STR * pnlsDevice ) const
{
    UIASSERT( pnlsDevice != NULL );

    INT i = QueryCurrentItem();
    if ( i < 0 )
    {
        //  No item is selected.  The combo had better be empty.
        UIASSERT( QueryCount() == 0 );
        *pnlsDevice = SZ("");
        return NERR_Success;
    }

    TCHAR szDevice[ DEVLEN + 1 ];

    REQUIRE( QueryItemText( szDevice, sizeof(szDevice), i ) == NERR_Success );

    *pnlsDevice = szDevice;

    return pnlsDevice->QueryError();
}


/**********************************************************************

    NAME:       DEVICE_COMBO::DeleteCurrentDeviceName

    SYNOPSIS:   Removes the currently selected device from the combo box.
                It then selects the first item in the list, if any.

    ENTRY:      NONE

    RETURN:     NONE

    NOTES:

    HISTORY:
        rustanl     28-Nov-1990     Created

***********************************************************************/

VOID DEVICE_COMBO::DeleteCurrentDeviceName()
{
    INT i = QueryCurrentItem();
    if ( i < 0 )
    {
        //  There is no selection.  The combo box had better be empty.
        UIASSERT( QueryCount() == 0 );
        return;
    }

    RemoveSelection();
    if ( DeleteItem( i ) > 0)
    {
        //  There are items left in the combo; thus, select the first item
        SelectItem( 0 );
    }
}


/**********************************************************************

    NAME:       DOMAIN_COMBO::DOMAIN_COMBO

    SYNOPSIS:   Differs from parent only in contents of combo.

    ENTRY:
       powin             Pointer to owner window
       cid               ID of control
       fsDomains Specifies which domains are to be inserted into
                       the list.  This value is a bit array and may contain
                       any of the following values OR'd together:
                                  DOMCB_PRIM_DOMAIN
                                  DOMCB_LOGON_DOMAIN
                                  DOMCB_OTHER_DOMAINS
                                  DOMCB_DS_DOMAINS
       cbMaxLen  Text size limit.  Should be 0 for dropdown lists,
                       and is normally DNLEN for dropdown combos.

    EXIT:

    NOTES:
       The DOMAIN_COMBO should use the CBS_SORT style to sort the domains.

    HISTORY:
        rustanl     28-Nov-1990 Created
        beng        31-Jul-1991 Error reporting changed
        beng        05-Oct-1991 Partial Win32 conversion
        beng        29-Mar-1992 Remove odious PCH type

**********************************************************************/

DOMAIN_COMBO::DOMAIN_COMBO( OWNER_WINDOW * powin,
                            CID cid,
                            UINT fsDomains,
                            UINT cbMaxLen )
    : COMBOBOX( powin, cid, cbMaxLen )
{
    UIASSERT( ! ( fsDomains & ~( DOMCB_PRIM_DOMAIN | DOMCB_LOGON_DOMAIN |
                                 DOMCB_OTHER_DOMAINS | DOMCB_DS_DOMAINS )));

    if (QueryError())
        return;

    WKSTA_10 wksta10;
    APIERR usErr = wksta10.GetInfo();
    if ( usErr != NERR_Success )
    {
        ReportError( usErr );
        return;
    }

    //  Add wksta domain if requested
    if ( fsDomains & DOMCB_PRIM_DOMAIN )
    {
        const TCHAR * psz = wksta10.QueryWkstaDomain();

        //  Note.  Wksta must be started since GetInfo worked; thus, there
        //  must be a wksta domain
        UIASSERT( psz != NULL && ::strlenf( psz ) > 0 );

        if ( AddItemIdemp( psz ) < 0 )
        {
            ReportError( ERROR_NOT_ENOUGH_MEMORY );
            return;
        }
    }

    //  Add logon domain if requested and the user is logged
    if ( fsDomains & DOMCB_LOGON_DOMAIN )
    {
        const TCHAR * psz = wksta10.QueryLogonDomain();
        if ( psz != NULL && ::strlenf( psz ) > 0 &&
             AddItemIdemp( psz ) < 0 )
        {
            ReportError( ERROR_NOT_ENOUGH_MEMORY );
            return;
        }
    }

    //  Add other domains, if requested
    if ( fsDomains & DOMCB_OTHER_DOMAINS )
    {
        //  QueryOtherDomains returns pointer to STRLIST
        STRLIST * pslOtherDomains = wksta10.QueryOtherDomains();

        //  declare iterator for STRLIST
        ITER_STRLIST islOtherDomains( *pslOtherDomains );

        NLS_STR * pnls;
        while ( ( pnls = islOtherDomains()) != NULL )
        {
            if ( AddItemIdemp( pnls->QueryPch()) < 0 )
            {
                ReportError( ERROR_NOT_ENOUGH_MEMORY );
                return;
            }
        }
    }

    if ( fsDomains & DOMCB_DS_DOMAINS )
    {
        //  Add the domains listed in the DS.
        //  CODEWORK.  Not yet implemented (Thor time frame).
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\cncltask.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
 *  openfile.cxx
 *	This module contains the code for the Task cancel dialog
 *
 *
 *  FILE HISTORY:
 *	Johnl	21-Oct-1992	Created
 *
 */

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:	CANCEL_TASK_DIALOG::CANCEL_TASK_DIALOG

    SYNOPSIS:	Constructor for cancel task dialog

    ENTRY:	hwndParent - Parent window handle
		idDialog   - Dialog resource to use
		pszDlgTitle - Title of this dialog
		ulContext   - User supplied context that will be passed
			      to DoOneItem callout
		msgidErrorMsg - Error message (w/ insert strings) to display
				when DoOneItem returns an error.

    NOTES:	If we fail to construct because we couldn't get a timer,
		then we will call DoOneItem repeatedly until we are told
		to quit (i.e., no time slicing).

    HISTORY:
	Johnl	21-Oct-1992	Created

********************************************************************/

CANCEL_TASK_DIALOG::CANCEL_TASK_DIALOG( UINT  idDialog,
					HWND  hwndParent,
					const TCHAR * pszDlgTitle,
					ULONG_PTR ulContext,
                    MSGID msgidErrorMsg,
                    ELLIPSIS_STYLE style )
    : DIALOG_WINDOW( idDialog,
		     hwndParent ),
      _ulContext( ulContext ),
      _msgidErrorMsg( msgidErrorMsg ),
      _sltStatusText( this, SLT_STATUS_TEXT, style ),
      _idTimer	    ( 0 ),
      _fInTimer     ( FALSE ),
      _fDone	    ( FALSE )
{
    if ( QueryError() )
	return ;

    if ( pszDlgTitle != NULL )
    {
	SetText( pszDlgTitle ) ;
    }

    //
    //	If we can't get a timer then the MayRun method will loop through
    //	each time slice.
    //
    _idTimer = ::SetTimer( QueryHwnd(),
	                   CANCEL_TASK_TIMER_ID,
	                   CANCEL_TASK_TIMER_INTERVAL,
	                   NULL ) ;
}


CANCEL_TASK_DIALOG::~CANCEL_TASK_DIALOG()
{
    if ( _idTimer != 0 )
	::KillTimer( QueryHwnd(), _idTimer ) ;

    _idTimer = 0 ;
}


/*******************************************************************

    NAME:	CANCEL_TASK_DIALOG::DoOneItem

    SYNOPSIS:	Default virtual, does nothing

    NOTES:

    HISTORY:
	Johnl	21-Oct-1992	Created

********************************************************************/

APIERR CANCEL_TASK_DIALOG::DoOneItem( ULONG_PTR   ulContext,
				      BOOL  * pfContinue,
                                      BOOL  * pfDisplayError,
                                      MSGID * pmsgidAlternateError )
{
    UNREFERENCED( ulContext ) ;
    UIASSERT( FALSE ) ;
    *pfContinue = FALSE ;
    *pfDisplayError = TRUE ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:	CANCEL_TASK_DIALOG::OnTimer

    SYNOPSIS:	Calls each task slice

    NOTES:	This method maybe called without being in response to a
		timer message.

		Note that the timer will keep pinging away at us even if
		there is an error message up.  Thus the IsInTimer method
		acts as a semaphore to keep us from being re-entrant.

		We use QueryRobustHwnd for message popups because we may
		be called w/o ever appearing

    HISTORY:
	Johnl	21-Oct-1992	Created

********************************************************************/

BOOL CANCEL_TASK_DIALOG::OnTimer( const TIMER_EVENT & )
{
    if ( IsInTimer() || IsFinished() )
	return TRUE ;
    SetInTimer( TRUE ) ;

    APIERR err ;
    APIERR errOnDoOneItem ;
    MSGID  msgidError = 0 ;
    BOOL fContinue = FALSE ;
    BOOL fDisplayError = TRUE ;

    if ( (errOnDoOneItem = DoOneItem( _ulContext,
                                      &fContinue,
                                      &fDisplayError,
                                      &msgidError )) &&
	 fDisplayError )
    {
	RESOURCE_STR nlsError( errOnDoOneItem ) ;
	NLS_STR      nlsObjectName ;
	APIERR	     errTmp ;

	if ( (errTmp = nlsError.Load( errOnDoOneItem )))
	{
	    DEC_STR decStr( (ULONG) errOnDoOneItem ) ;
	    if ( (errTmp = decStr.QueryError()) ||
		 (errTmp = nlsError.CopyFrom( decStr )) )
	    {
		::MsgPopup( this->QueryRobustHwnd(), (MSGID) errTmp ) ;
		SetInTimer( FALSE ) ;
		return TRUE ;
	    }
	}

	if ( (err = nlsObjectName.QueryError())        ||
	     (err = nlsError.QueryError())	       ||
	     (err = QueryObjectName( &nlsObjectName ))	 )
	{
	    ::MsgPopup( this->QueryRobustHwnd(), (MSGID) err ) ;
	    SetInTimer( FALSE ) ;
	    return TRUE ;
	}

	switch ( ::MsgPopup( this->QueryRobustHwnd(),
                             msgidError ? msgidError : _msgidErrorMsg,
			     MPSEV_WARNING,
			     MP_YESNO,
			     nlsError,
			     nlsObjectName ))
	{
	case IDYES:
	    break ;

	case IDNO:
	default:
	    Dismiss( FALSE ) ;
	    _fDone = TRUE ;
	    break ;
	}
    }

    if ( !fContinue )
    {
	Dismiss( TRUE ) ;
	_fDone = TRUE ;
    }

    SetInTimer( FALSE ) ;
    return TRUE ;
}


/*******************************************************************

    NAME:	CANCEL_TASK_DIALOG::QueryObjectName

    SYNOPSIS:	Gets the object name to use for messages

    ENTRY:	pnlsObjName - NLS_STR to receive the object name

    RETURNS:	NERR_Success if succesful, error code otherwise

    NOTES:	This method defaults to getting what's in the status SLT

    HISTORY:
	Johnl	21-Oct-1992	Created

********************************************************************/

APIERR CANCEL_TASK_DIALOG::QueryObjectName( NLS_STR *pnlsObjName )
{
    return  _sltStatusText.QueryText( pnlsObjName ) ;
}

/*******************************************************************

    NAME:	CANCEL_TASK_DIALOG::MayRun

    SYNOPSIS:	If we failed to get the timer, then loop here and
		forget about time slicing.  The dialog won't come up.

    RETURNS:	FALSE indicating the dialog shouldn't come up

    NOTES:

    HISTORY:
	Johnl	22-Oct-1992	Created

********************************************************************/

BOOL CANCEL_TASK_DIALOG::MayRun( void )
{
    if ( _idTimer == 0 )
    {
	AUTO_CURSOR niftycursor ;
	TIMER_EVENT teDummy( 0, 0, 0 ) ;
	while ( !IsFinished() )
	{
	    OnTimer( teDummy ) ;
	}
	return FALSE ;
    }

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\makefile.inc ===
# @@ COPY_RIGHT_HERE
# @@ ROADMAP :: The Rules.mk for the product-wide header files

#
# Pls record ALL changes here with reason!
#
# jonn, 10/22/91.  Created from BenG's template.
#
# jonn, 10/23/91.  Minor update.
#
#       This makefile-inclusion handles combining multiple libraries
#       into one target directory.  It uses the following macros:
#       $(NTTARGETFILES): define in SOURCES, should include comblib
#       $(COMBINE_SOURCELIBS): define in MAKEFILE.INC
#       $(COMBINE_TARGETLIB): define in MAKEFILE.INC
#       A sample SOURCES and MAKEFILE.INC might look like this:
#
#       sources:
#       TARGETPATH=obj
#       TARGETNAME=intermed3
#       TARGETTYPE=LIBRARY
#       ...
#       NTTARGETFILES=comblib
#
#       makefile.inc:
#       COMBINE_SOURCELIBS=..\foo\$(O)\intermed1.lib \
#                          ..\bar\$(O)\intermed2.lib \
#                          $(O)\intermed3.lib
#       COMBINE_TARGETLIB=..\..\..\lib\*\finallib.lib
#       !include <comblib.mk>
#


!IF $(386) && ("$(COMBINE_TARGETLIB)" != "")
COMBINE_386_DSTLIB=$(COMBINE_TARGETLIB:*=i386)
$(COMBINE_386_DSTLIB): $(COMBINE_SOURCELIBS:*=i386)
    @echo Combining libraries...
    lib -out:$@ $(**)
!ENDIF

!IF $(AMD64) && ("$(COMBINE_TARGETLIB)" != "")
COMBINE_AMD64_DSTLIB=$(COMBINE_TARGETLIB:*=amd64)
$(COMBINE_AMD64_DSTLIB): $(COMBINE_SOURCELIBS:*=amd64)
    @echo Combining libraries...
    lib -out:$@ $(**)
!ENDIF

!IF $(IA64) && ("$(COMBINE_TARGETLIB)" != "")
COMBINE_IA64_DSTLIB=$(COMBINE_TARGETLIB:*=ia64)
$(COMBINE_IA64_DSTLIB): $(COMBINE_SOURCELIBS:*=ia64)
    @echo Combining libraries...
    lib -out:$@ $(**)
!ENDIF

comblib: $(COMBINE_386_DSTLIB)   \
	 $(COMBINE_AMD64_DSTLIB) \
	 $(COMBINE_IA64_DSTLIB)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\bmpblock.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    BmpBlock.cxx

    Block containing bitmaps for subject listboxes


    FILE HISTORY:
        JonN        04-Oct-1993 Created

*/

#include "pchapplb.hxx"   // Precompiled header

#include <bmpblock.hxx>


/*************************************************************************

    NAME:       SUBJECT_BITMAP_BLOCK

    SYNOPSIS:   This listbox lists users, groups, aliases and well known SIDs.

    INTERFACE:

    PARENT:     BLT_LISTBOX_HAW

    USES:       DISPLAY_MAP

    CAVEATS:

    NOTES:

    HISTORY:
        JonN        04-Oct-1993 Created

**************************************************************************/

SUBJECT_BITMAP_BLOCK::SUBJECT_BITMAP_BLOCK()
    : BASE              ( ),
      _dmiddteAlias          ( DMID_ALIAS ),
      _dmiddteGroup          ( DMID_GROUP ),
      _dmiddteUser           ( DMID_USER ),
      _dmiddteUnknown        ( DMID_UNKNOWN ),
      _dmiddteRemote         ( DMID_REMOTE ),
      _dmiddteWorld          ( DMID_WORLD ),
      _dmiddteCreatorOwner   ( DMID_CREATOR_OWNER ),
      _dmiddteSystem         ( DMID_SYSTEM ),
      _dmiddteNetwork        ( DMID_NETWORK ),
      _dmiddteInteractive    ( DMID_INTERACTIVE ),
      _dmiddteRestricted     ( DMID_RESTRICTED ),
      _dmiddteDeletedAccount ( DMID_DELETEDACCOUNT )
{
    APIERR err = NERR_Success ;

    if ( (err = _dmiddteAlias.QueryError())    ||
         (err = _dmiddteGroup.QueryError())    ||
         (err = _dmiddteUser.QueryError())     ||
         (err = _dmiddteUnknown.QueryError())  ||
         (err = _dmiddteRemote.QueryError())   ||
         (err = _dmiddteWorld.QueryError())    ||
         (err = _dmiddteCreatorOwner.QueryError()) ||
         (err = _dmiddteSystem.QueryError()) ||
         (err = _dmiddteNetwork.QueryError()) ||
         (err = _dmiddteInteractive.QueryError()) ||
         (err = _dmiddteRestricted.QueryError()) ||
         (err = _dmiddteDeletedAccount.QueryError())
       )
    {
        DBGEOL( "SUBJECT_BITMAP_BLOCK::ctor error " << err );
        ReportError( err ) ;
        return ;
    }
}

SUBJECT_BITMAP_BLOCK::~SUBJECT_BITMAP_BLOCK()
{
    // nothing to do here
}

/*******************************************************************

    NAME:       SUBJECT_BITMAP_BLOCK::QueryDisplayMap

    SYNOPSIS:   Retrieves the correct display map

    INTERFACE:  sidtype: pass a SID_NAME_USE here
                uisid:   pass an enum UI_SystemSid here, only
                         relevant for sidtype==SidTypeWellKnownGroup
                fRemoteUser: only relevant for sidtype==SidTypeUser

    RETURNS:    Pointer to the appropriate display map

    NOTES:

    HISTORY:
        JonN        04-Oct-1993 Created

********************************************************************/

DMID_DTE * SUBJECT_BITMAP_BLOCK::QueryDmDte( INT sidtype,
                                             INT uisid,
                                             BOOL fRemoteUser )
{
    DMID_DTE * pdmap = NULL ;

    switch ( (SID_NAME_USE)sidtype )
    {
    case SidTypeUser:
        if ( fRemoteUser )
        {
            pdmap = &_dmiddteRemote ;
        }
        else
        {
            pdmap = &_dmiddteUser ;
        }
        break ;

    case SidTypeWellKnownGroup:
        {
            switch ( (enum UI_SystemSid)uisid )
            {
            case UI_SID_World:
                pdmap = &_dmiddteWorld ;
                break ;

            case UI_SID_CreatorOwner:
                pdmap = &_dmiddteCreatorOwner ;
                break ;

            case UI_SID_System:
                pdmap = &_dmiddteSystem ;
                break ;

            case UI_SID_Network:
                pdmap = &_dmiddteNetwork ;
                break ;

            case UI_SID_Interactive:
                pdmap = &_dmiddteInteractive ;
                break ;

            case UI_SID_Restricted:
                pdmap = &_dmiddteRestricted ;
                break ;

            case UI_SID_Invalid:
            default:
                DBGEOL(   "SUBJECT_BITMAP_BLOCK::QueryDisplayMap: unknown UISysSid "
                       << uisid );
                pdmap = &_dmiddteGroup ;
                break ;
            }
            break ;
        }

    case SidTypeGroup:
        pdmap = &_dmiddteGroup ;
        break ;

    case SidTypeAlias:
        pdmap = &_dmiddteAlias ;
        break ;

    case SidTypeDeletedAccount:
        pdmap = &_dmiddteDeletedAccount ;
        break ;

    case SidTypeUnknown:
    case SidTypeInvalid:
        pdmap = &_dmiddteUnknown ;
        break ;

    case SidTypeDomain:
    default:
        /* We shouldn't ever get here
         */
        DBGEOL(   "SUBJECT_BITMAP_BLOCK::QueryDisplayMap: unknown sidtype "
               << sidtype );
        ASSERT( FALSE ) ;
        pdmap = &_dmiddteUnknown ;
        break ;
    }

    ASSERT( pdmap != NULL );

    return pdmap ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\ellipsis.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ellipsis.cxx

    This file contains all the ellipsis related classes.
    There are: BASE_ELLIPSIS
               CONSOLE_ELLIPSIS
               WIN_ELLIPSIS
               SLT_ELLIPSIS
               STR_DTE_ELLIPSIS

    Ellipsis text:    // put dot dot in the left, center or right
                       // handside of the string if the string is too
                       // long
        ELLIPSIS_NONE
        ELLIPSIS_LEFT
        ELLIPSIS_CENTER
        ELLIPSIS_RIGHT
        ELLIPSIS_PATH

    FILE HISTORY:
        terryk      21-Mar-1991 creation
        terryk      28-Mar-1991 change it to SLTP
        terryk       2-Apr-1991 add double ampersands
        terryk       3-Apr-1991 add the SLTP_DOT_PATH
        terryk       4-Apr-1991 code review changed
        terryk       5-Apr-1991 SLTP_DOUBLE_AMPERSANDS deleted
        terryk      16-Apr-1991 second code review changed
                                attend: johnl jonn gregj rustanl
        beng        14-May-1991 Exploded blt.hxx into components
        terryk      12-Jun-1991 Add column header type.
        terryk      18-Jul-1991 fix the cchGuess out of range bug
        terryk      01-Aug-1991 Change GetClientRect.
        beng        18-Sep-1991 Cleaned up error reporting
        beng        17-Oct-1991 Moved into APPLIB
        beng        25-Oct-1991 Remove static global ctors
        congpay     05-Apr-1993 Changed from SLTPLUS class to ellipsis classes.
*/

#include "pchapplb.hxx"   // Precompiled header

DEFINE_MI2_NEWBASE (SLT_ELLIPSIS, SLT, WIN_ELLIPSIS);

// Set up the global Ellipsis Text string

static NLS_STR * pnlsEllipsisText = NULL;
static INT       nCount = 0;

/**********************************************************************

    NAME:       BASE_ELLIPSIS::Init

    SYNOPSIS:   Initialize the ellipsis text string by loading it from
                the resource file.

    RETURNS:    Error code, 0 if successful

    NOTES:      set the ellipsistext member within the class

    HISTORY:
        terryk      26-Apr-1991 creation
        beng        18-Sep-1991 Renamed; returns error code
        beng        25-Oct-1991 Remove global static ctor

**********************************************************************/

APIERR BASE_ELLIPSIS::Init()
{
    nCount++;

    // Load the standard Ellipsis Text String from the resource file
    if (::pnlsEllipsisText == NULL)
    {
        ::pnlsEllipsisText = new RESOURCE_STR( IDS_BLT_ELLIPSIS_TEXT );
    }

    if (::pnlsEllipsisText == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    return ::pnlsEllipsisText->QueryError();
}


/**********************************************************************

    NAME:       BASE_ELLIPSIS::Term

    SYNOPSIS:   Release the internal string

    NOTES:      Call global object destrcutor to delete the internal string

    HISTORY:
        terryk      29-Apr-1991 creation
        beng        18-Sep-1991 Renamed
        beng        25-Oct-1991 Remove global static dtor

**********************************************************************/

VOID BASE_ELLIPSIS::Term()
{
    if( nCount > 0 )
    {
        if( --nCount == 0 )
        {
            delete ::pnlsEllipsisText;
            ::pnlsEllipsisText = NULL;
        }
    }
}


/**********************************************************************

    NAME:       BASE_ELLIPSIS::BASE_ELLIPSIS

    SYNOPSIS:   constructor

    ENTRY:      INT - nStyle
                   can be either one of the 5 styles:
                      ELLIPSIS_NONE
                      ELLIPSIS_LEFT
                      ELLIPSIS_CENTER
                      ELLIPSIS_RIGHT
                      ELLIPSIS_PATH

    NOTES:      The default setting is
                      ELLIPSIS_NONE.

    HISTORY:
        terryk      24-Mar-91   Creation
        terryk      16-Apr-91   Code Review changed
        beng        17-May-1991 Added app-window constructor
        beng        18-Sep-1991 Refined error reporting
        beng        30-Apr-1992 Bug in WINDOW::QueryText usage
        congpay     05-Apr-1993 Changed from SLTPLUS class to BASE_ELLIPSIS class.

**********************************************************************/

BASE_ELLIPSIS::BASE_ELLIPSIS( ELLIPSIS_STYLE nStyle )
    :_nStyle( nStyle ),
     _nlsOriginalStr()
{
    APIERR err = _nlsOriginalStr.QueryError();

    if (err != NERR_Success)
    {
        ReportError(err);
        return;
    }
}

/**********************************************************************

    NAME:       BASE_ELLIPSIS::IsValidStyle

    SYNOPSIS:   check the incoming Style flag is correct or not

    ENTRY:      ELLIPSIS_STYLE - style to be checked

    RETURN:     BOOL to indicate whether the style is valid or not

    NOTES:      Currently, the style must be one of the ELLIPSIS type.

    HISTORY:
        terryk      3-Apr-1991  creation
        terryk      16-Apr-1991 change it to case statement

**********************************************************************/

BOOL BASE_ELLIPSIS::IsValidStyle ( const ELLIPSIS_STYLE nStyle ) const
{
   // we have 5 ellipsis text styles, check whether he ask for something else
    switch ( nStyle )
    {
    case ELLIPSIS_NONE:
    case ELLIPSIS_LEFT:
    case ELLIPSIS_CENTER:
    case ELLIPSIS_RIGHT:
    case ELLIPSIS_PATH:
        return TRUE;
    default:
        return FALSE;
    }
}

/**********************************************************************

    NAME:       BASE_ELLIPSIS::SetEllipsis

    SYNOPSIS:   It will put an ellipsis text within the string
                if the string is too long.

    ENTRY:

    RETURN:  error code from the converting routine.

    NOTES:

    HISTORY:
        terryk      27-Mar-1991 Created
        beng        18-Sep-1991 Refined error reporting
        beng        04-Oct-1991 Win32 conversion
        beng        30-Apr-1992 Use NLS_STR::CopyFrom

**********************************************************************/

APIERR BASE_ELLIPSIS::SetEllipsis(NLS_STR * pnlsStr )
{
    if (!*pnlsStr)
        return pnlsStr->QueryError();

    _nlsOriginalStr.CopyFrom(*pnlsStr);

    if ( !_nlsOriginalStr )
        return _nlsOriginalStr.QueryError();

    if (QueryStrLen (*pnlsStr) > QueryLimit())
    {
        switch ( _nStyle )
        {
        case ELLIPSIS_LEFT:
            return SetEllipsisLeft(pnlsStr);

        case ELLIPSIS_CENTER:
            return SetEllipsisCenter(pnlsStr);

        case ELLIPSIS_RIGHT:
            return SetEllipsisRight(pnlsStr);

        case ELLIPSIS_PATH:
            return SetEllipsisPath(pnlsStr);

        case ELLIPSIS_NONE:
        default:
            break;
        }
    }

    return NERR_Success;
}

APIERR BASE_ELLIPSIS::SetEllipsis (TCHAR * lpStr)
{
    ASSERT (lpStr);

    NLS_STR nlsTemp(lpStr);

    if ( !nlsTemp )
        return nlsTemp.QueryError();

    APIERR err = SetEllipsis (&nlsTemp);

    if (err == NERR_Success)
    {
        ::strcpyf (lpStr, nlsTemp.QueryPch());
    }

    return err;
}

/**********************************************************************

    NAME:       BASE_ELLIPSIS::QueryText

    SYNOPSIS:   Returns the original non-ellipsis text of the control.

    ENTRY:
       pszBuffer    A pointer to a buffer, where the text
                    will be copied.

       cbBufSize    The size of this buffer.  The window text
                    copied to the buffer will be truncated if
                    the buffer is not big enough (including the
                    trailing NUL), in which case the function will
                    return ERROR_MORE_DATA.
         or

       pnls         A pointer to a NLS_STR to hold the results

    EXIT:       If psz+cb, psz buffer now contains the text.
                If pnls, the string has endured assignment.

    RETURNS:    0 if successful,
                ERROR_MORE_DATA if had to truncate string to fit in
                    user-supplied buffer.
                Otherwise, some error code.

    HISTORY:
        terryk      27-Mar-1991     Created
        beng        23-May-1991     Changed return type
        beng        30-Apr-1992     Unicode fixes

**********************************************************************/

APIERR BASE_ELLIPSIS::QueryText( TCHAR * pszBuffer, UINT cbBufSize ) const
{
    ASSERT (pszBuffer);

    if ( !_nlsOriginalStr )
        return _nlsOriginalStr.QueryError();

    // I would use CopyTo, but want to preserve the truncating
    // behavior of WINDOW::QueryText.

    UINT cch = (cbBufSize/sizeof(TCHAR)) - 1;

    ::strncpyf( pszBuffer, _nlsOriginalStr.QueryPch() , cch );
    pszBuffer[cch] = TCH('\0');

    if (_nlsOriginalStr.strlen() > (cbBufSize - 1)) // truncated? check bytes
        return ERROR_MORE_DATA;
    else
        return NERR_Success;
}

APIERR BASE_ELLIPSIS::QueryText( NLS_STR * pnls ) const
{
    if (pnls == NULL)
        return ERROR_INVALID_PARAMETER;

    if ( !_nlsOriginalStr )
        return _nlsOriginalStr.QueryError();

    return pnls->CopyFrom( _nlsOriginalStr );
}


/**********************************************************************

    NAME:       BASE_ELLIPSIS::QueryTextLength

    SYNOPSIS:   Returns the length of the text in the control.

    RETURNS:    The length, in actual characters (as opposed to the
                byte-characters of strlen), of the window text.

    NOTE:       The length returned is that of the *original text*,
                not the mangled version displayed.

    HISTORY:
        terryk      27-Mar-1991     Created
        beng        12-Jun-1991     Changed return type
        beng        30-Apr-1992     Fix Unicode bug

**********************************************************************/

INT BASE_ELLIPSIS::QueryTextLength() const
{
    if ( !_nlsOriginalStr )
        return 0;

    return _nlsOriginalStr.QueryTextLength();
}

/*******************************************************************

    NAME:       BASE_ELLIPSIS::QueryTextSize

    SYNOPSIS:   Returns the byte count of the text,
                including the terminating character

    RETURNS:    Count of bytes

    NOTES:      The count returned is that sufficient to duplicate
                the original text.

    HISTORY:
        beng        12-Jun-1991     Created
        beng        30-Apr-1992     Fix Unicode bug

********************************************************************/

INT BASE_ELLIPSIS::QueryTextSize() const
{
    if ( !_nlsOriginalStr )
        return 0;

    return _nlsOriginalStr.QueryTextSize();
}


/**********************************************************************

    NAME:       BASE_ELLIPSIS::SetStyle

    SYNOPSIS:   set the display style

    ENTRY:      ELLIPSIS_STYLE flStyle - the display style.
                It will be any one of the following 5 styles:
                   ELLIPSIS_NONE
                   ELLIPSIS_LEFT
                   ELLIPSIS_CENTER
                   ELLIPSIS_RIGHT
                   ELLIPSIS_PATH

    EXIT:       set the internal style

    NOTES:

    HISTORY:
        terryk      27-Mar-1991 creation

**********************************************************************/

VOID BASE_ELLIPSIS::SetStyle( const ELLIPSIS_STYLE nStyle )
{
    UIASSERT( IsValidStyle( nStyle ));

    _nStyle = nStyle;
}

/**********************************************************************

    NAME:       BASE_ELLIPSIS::QueryOriginalStr()

    SYNOPSIS:   return the original string.

    RETURN:

    HISTORY:
        congpay      05-Apr-1993 creation

**********************************************************************/

NLS_STR BASE_ELLIPSIS::QueryOriginalStr() const
{
    return _nlsOriginalStr;
}

/**********************************************************************

    NAME:       BASE_ELLIPSIS::SetOriginalStr()

    SYNOPSIS:

    RETURN:

    HISTORY:
        congpay      05-Apr-1993 creation

**********************************************************************/

APIERR BASE_ELLIPSIS::SetOriginalStr(const TCHAR * psz)
{
    return (_nlsOriginalStr.CopyFrom(psz));
}

/**********************************************************************

    NAME:       BASE_ELLIPSIS::QueryStyle

    SYNOPSIS:   return the current style for display method

    RETURN:     the style of display method

    HISTORY:
        terryk      27-Mar-1991 creation

**********************************************************************/

ELLIPSIS_STYLE  BASE_ELLIPSIS::QueryStyle() const
{
    return _nStyle;
}

/**********************************************************************

    NAME:       BASE_ELLIPSIS::SetEllipsisRight

    SYNOPSIS:   Add the ellipsis text string in the right hand side
                of the given string and delete a character one by one
                until the string can fit into the given window rectangle.

    ENTRY:

    EXIT:       Fix the pnls, so it fits into the rectangle box.

    HISTORY:
        terryk      8-Apr-1991  creation
        terryk      16-Apr-1991 add the Ellipsis text first before
                                delete any character
        beng        18-Sep-1991 Changed return type; refined error handling
        beng        30-Apr-1992 Fixed some signed vs. unsigned

**********************************************************************/

APIERR BASE_ELLIPSIS::SetEllipsisRight( NLS_STR * pnls )
{
    if (!*pnls)
        return pnls->QueryError();

    pnls->strcat( *::pnlsEllipsisText );
    if (!*pnls)
        return pnls->QueryError();

    // Guess the minimal number of characters to be deleted
    INT dxStringSize = QueryStrLen ( *pnls ) ;
    INT dxRectSize = QueryLimit () ;

    UINT cchNumChar = pnls->QueryNumChar();
    UINT cchGuess = (dxRectSize >= dxStringSize)
                   ? 0
                   : (dxStringSize - dxRectSize) / QueryMaxCharWidth();
    if (cchGuess > cchNumChar)
        cchGuess = cchNumChar;

    UINT cchEllipsisText = ::pnlsEllipsisText->QueryNumChar();

    // set the deleted substring start and end position
    ISTR istrSubStrStart( *pnls );
    ISTR istrSubStrEnd( *pnls );

    istrSubStrStart += cchNumChar - cchEllipsisText - cchGuess;
    istrSubStrEnd += cchNumChar - cchEllipsisText;

    pnls->DelSubStr( istrSubStrStart, istrSubStrEnd );
    if (!*pnls)
        return pnls->QueryError();

    cchNumChar = pnls->QueryNumChar();

    // decrease a character from the end of the string
    // until the string fit into the rectangle

    while (( QueryStrLen( *pnls )) > dxRectSize )
    {
        // Check window size for proper ellipsis
        ASSERT((cchNumChar - cchEllipsisText - 1) > 0);

        if ( ( cchNumChar - cchEllipsisText - 1 ) <= 0 )
            break;

        istrSubStrStart.Reset();
        istrSubStrStart += cchNumChar - cchEllipsisText - 1;

        istrSubStrEnd.Reset();
        istrSubStrEnd += cchNumChar - cchEllipsisText ;

        pnls->DelSubStr( istrSubStrStart, istrSubStrEnd );
        if (!*pnls)
            return pnls->QueryError();

        cchNumChar--;

        ASSERT( cchNumChar > 0 );
    }

    return pnls->QueryError();
}


/**********************************************************************

    NAME:       BASE_ELLIPSIS::SetEllipsisLeft

    SYNOPSIS:   Add the ellipsis text string in the left hand side
                of the given string and delete a character one by one
                until the string can fit into the given window rectangle.

    ENTRY:      pnls       - the original string

    EXIT:       Fix the string, so it fix into the rectangle

    HISTORY:
        terryk      8-Apr-1991  creation
        beng        18-Sep-1991 Changed return type; refined error handling
        beng        30-Apr-1992 Fixed some signed vs. unsigned

**********************************************************************/

APIERR BASE_ELLIPSIS::SetEllipsisLeft (NLS_STR * pnls)
{
    if (!*pnls)
        return pnls->QueryError();

    ISTR istrSubStrStart( *pnls );

    // Insert the Ellipsis Text String
    pnls->InsertStr( *::pnlsEllipsisText, istrSubStrStart );
    if (!*pnls)
        return pnls->QueryError();

    // Guess the minimal number of characters to be deleted
    INT dxStringSize = QueryStrLen( *pnls );
    INT dxRectSize = QueryLimit();

    UINT cchNumChar = pnls->QueryNumChar();
    UINT cchGuess = (dxRectSize >= dxStringSize)
                   ? 0
                   : (dxStringSize - dxRectSize) / QueryMaxCharWidth();
    if (cchGuess > cchNumChar)
        cchGuess = cchNumChar;

    UINT cchEllipsisText = ::pnlsEllipsisText->QueryNumChar();

    istrSubStrStart.Reset();
    istrSubStrStart += cchEllipsisText ;

    ISTR istrSubStrEnd ( *pnls );

    istrSubStrEnd += cchEllipsisText + cchGuess ;

    // delete the minimal number of character within the string in order
    // to fit the reset of the string in the window
    pnls->DelSubStr( istrSubStrStart, istrSubStrEnd );
    if (!*pnls)
        return pnls->QueryError();

    // keep delete the first character of the string until the string
    // fits into the rectangle

    while ( QueryStrLen( *pnls ) > dxRectSize )
    {
        // Check window size for proper ellipsis
        ASSERT( pnls->QueryNumChar() > 0 );

        if ( pnls->QueryNumChar() == 0 )
            break;

        istrSubStrStart.Reset();
        istrSubStrStart += cchEllipsisText;

        istrSubStrEnd.Reset();
        istrSubStrEnd += cchEllipsisText + 1;

        pnls->DelSubStr( istrSubStrStart, istrSubStrEnd );
        if (!*pnls)
            return pnls->QueryError();
    }

    return pnls->QueryError();
}


/**********************************************************************

    NAME:       BASE_ELLIPSIS::SetEllipsisPath

    SYNOPSIS:   Add the ellipsis text string in the left hand side
                of the given string and delete a character one by one
                until the string can fit into the given window rectangle.
                We will treate the string as a Path and try to keep some
                important imformation within the string, i.e. the header
                of the string, "c:", "\\", "c:\"...

    ENTRY:      pnls       - the original string

    EXIT:       Modified the string, so it fits into the rectangle

    HISTORY:
        terryk      8-Apr-1991  creation
        beng        18-Sep-1991 Changed return type; refined error handling
        beng        30-Apr-1992 Fixed some signed vs. unsigned

**********************************************************************/

APIERR BASE_ELLIPSIS::SetEllipsisPath ( NLS_STR * pnls )
{
    if (!*pnls)
        return pnls->QueryError();

    ULONG ulPathType;

    APIERR err = ::I_MNetPathType( NULL, pnls->QueryPch(), &ulPathType, 0 ) ;


    if ( err != NERR_Success )
    {
        // if it is not a valid path, leave it alone and don't modify it.
        return err;
    }

    UINT cchHeaderSize = 0;

    // find the header part of the string and advance the substring's
    // starting position

    switch( ulPathType )
    {
    case ITYPE_UNC:
    case ITYPE_UNC_WC:
    case ITYPE_UNC_SYS_SEM:
    case ITYPE_UNC_SYS_SHMEM:
    case ITYPE_UNC_SYS_MSLOT:
    case ITYPE_UNC_SYS_PIPE:
    case ITYPE_UNC_COMPNAME:        // \\computername\....
    case ITYPE_PATH_RELD:           // c:foo\bar
    case ITYPE_PATH_RELD_WC:        // c:foo\bar\*.h
        // keep the first 2 characters
        cchHeaderSize += 2;
        break;

    case ITYPE_PATH_ABSND:          // \foo\bar
    case ITYPE_PATH_ABSND_WC:       // \foo\bar\*.c
    case ITYPE_PATH_SYS_MSLOT:      // \mailslot\foo
    case ITYPE_PATH_SYS_SEM:        // \sem\bar
    case ITYPE_PATH_SYS_PIPE:       // \pipe\smokers
    case ITYPE_PATH_SYS_SHMEM:      // \sharemem\mine
    case ITYPE_PATH_SYS_COMM:       // \comm\unist\plot
    case ITYPE_PATH_SYS_PRINT:      // \print\it\all\now
        // keep the first character
        cchHeaderSize ++;
        break;

    case ITYPE_PATH_ABSD:               // c:\foo\bar
    case ITYPE_PATH_ABSD_WC:        // c:\foo\george.*
        // keep the first 3 characters
        cchHeaderSize += 3;
        break;

    case ITYPE_PATH_RELND:          // foo\bar
    case ITYPE_PATH_RELND_WC:       // foo\?.?
    case ITYPE_DEVICE_DISK:         // d:
    case ITYPE_DEVICE_LPT:          // lpt1:
    case ITYPE_DEVICE_COM:          // com9
    default:
        // don't keep any header character
        break;
    }

    // guess the minimal number of characters to be deleted
    INT dxStringSize = QueryStrLen( *pnls );
    INT dxRectSize = QueryLimit();
    UINT cchNumChar = pnls->QueryNumChar();
    INT dxBloat = dxStringSize + QueryStrLen( *::pnlsEllipsisText );
    UINT cchGuess = (dxRectSize >= dxBloat)
                    ? 0
                    : (dxBloat - dxRectSize) / QueryMaxCharWidth();
    if (cchGuess > cchNumChar)
        cchGuess = cchNumChar;

    UINT cchEllipsisText = ::pnlsEllipsisText->QueryNumChar();

    ISTR istrSubStrStart( *pnls );
    ISTR istrSubStrEnd( *pnls );

    istrSubStrStart += cchHeaderSize ;
    istrSubStrEnd += cchHeaderSize + cchGuess ;

    // keep track of the last deleted character
    ISTR istrLastDelChar( *pnls );
    istrLastDelChar += cchHeaderSize + cchGuess - 1;

    WCHAR chLastDelChar = pnls->QueryChar( istrLastDelChar );

    // replace the minimal number of characters to be deleted with the
    // Ellipsis Text

    pnls->ReplSubStr( *::pnlsEllipsisText, istrSubStrStart, istrSubStrEnd );
    if (!*pnls)
        return pnls->QueryError();

    // Delete a character one at a time and stop when we can fit the string
    // within the window or we cannot del anymore character

    while( QueryStrLen( *pnls ) > dxRectSize )
    {
        // Check window size for proper ellipsis
        ASSERT( pnls->QueryNumChar() > ( cchEllipsisText + cchHeaderSize ) );

        if ( pnls->QueryNumChar() <= ( cchEllipsisText + cchHeaderSize ))
            break;

        istrSubStrStart.Reset();
        istrSubStrStart += cchEllipsisText + cchHeaderSize ;

        istrSubStrEnd = istrSubStrStart;
        ++istrSubStrEnd;

        // keep track of the last deleted character
        chLastDelChar = pnls->QueryChar( istrSubStrStart );

        pnls->DelSubStr( istrSubStrStart, istrSubStrEnd );
        if (!*pnls)
            return pnls->QueryError();
    }

    // move back one position and check whether the current position
    // is the beginning of a directory name or a '\'

    istrSubStrStart.Reset();
    istrSubStrStart += cchHeaderSize + cchEllipsisText ;

    if ( chLastDelChar != TCH('\\') )
    {
        // if we cut somewhere within a directory name, delete everything
        // until we see the next '\'
        // for example c:\....\abcdef\xyz
        // if we are on '\' or 'a' position, we have no problem
        // if we hit either 'b' 'c' 'd' 'e' 'f', we need to delete all the
        // characters up to but not include the next '\'
        // the result string will be c:\...\xyz

        istrSubStrEnd.Reset();

        if ( pnls->strchr( &istrSubStrEnd, TCH('\\'), istrSubStrStart ))
            pnls->DelSubStr( istrSubStrStart, istrSubStrEnd );
    }

    return pnls->QueryError();

}


/**********************************************************************

    NAME:       BASE_ELLIPSIS::SetEllipsisCenter

    SYNOPSIS:   Add the ellipsis text string in the center
                of the given string and delete a character one by one
                until the string can fit into the given window rectangle.

    ENTRY:      pnls       - the original string

    EXIT:       fix the string so it fit into the rectangle

    HISTORY:
        terryk      08-Apr-1991 creation
        terryk      18-Jul-1991 fix the cchGuess out of range bug.
        beng        18-Sep-1991 Changed return type; refined error handling
        beng        30-Apr-1992 Fixed some signed vs. unsigned

**********************************************************************/

APIERR BASE_ELLIPSIS::SetEllipsisCenter( NLS_STR * pnls )
{
    if (!*pnls)
        return pnls->QueryError();

    // divide the given string into 2 parts
    UINT cchNumLogicalChar = pnls->QueryNumChar();
    UINT ichCenter = cchNumLogicalChar / 2;

    // get the minimal number of character to be deleted
    INT dxStringSize = QueryStrLen( *pnls );
    INT dxRectSize = QueryLimit();
    INT dxBloat = dxStringSize + QueryStrLen( *::pnlsEllipsisText );
    UINT cchGuess = (dxRectSize >= dxBloat)
                    ? 0
                    : (dxBloat - dxRectSize) / QueryMaxCharWidth();
    if (cchGuess > cchNumLogicalChar)
        cchGuess = cchNumLogicalChar;

    UINT cchEllipsisText = ::pnlsEllipsisText->QueryNumChar();

    // divide the guess number into 2 and reduce the size of the 2 part
    // given string.

    UINT cchFirstPart = ( cchNumLogicalChar - cchGuess ) / 2;
    UINT cchSecPart = cchNumLogicalChar - cchFirstPart;

    ISTR istrSubStrStart( *pnls );
    ISTR istrSubStrEnd( *pnls );

    istrSubStrStart += cchFirstPart;
    istrSubStrEnd += cchNumLogicalChar - cchSecPart;

    // replace the minimal number of characters with the EllipsisText

    pnls->ReplSubStr( *::pnlsEllipsisText, istrSubStrStart, istrSubStrEnd );
    if (!*pnls)
        return pnls->QueryError();

    cchNumLogicalChar = pnls->QueryNumChar();

    ISTR istrStrStart( *pnls );
    ISTR istrStrEnd( *pnls );
    ISTR istrTempPos ( *pnls );

    INT dxFirstPart;
    INT dxSecPart;

    while ( QueryStrLen( *pnls ) > dxRectSize )
    {
        ASSERT(cchNumLogicalChar > 0);

        if ( cchNumLogicalChar == 0 )
            break;

        // divide the string into 2 part, keep delete a character from the
        // end of the first string, or the beginning of the second string
        // until the modified string can fit into the rectangle

        // reset all the string iterators

        istrStrStart.Reset();

        istrStrEnd.Reset();
        istrStrEnd += cchNumLogicalChar;

        istrSubStrStart.Reset();
        istrSubStrStart += cchFirstPart;

        istrSubStrEnd.Reset();
        istrSubStrEnd += cchNumLogicalChar - cchSecPart - 1;


        // determine which part of the string should we deleted

        dxFirstPart = QueryStrLen( pnls->QueryPch(),
                                         istrSubStrStart - istrStrStart );
        dxSecPart = QueryStrLen( pnls->QueryPch(istrSubStrEnd),
                                       istrStrEnd - istrSubStrEnd );

        if ( dxFirstPart > dxSecPart )
        {
            cchFirstPart--;
            ASSERT( cchFirstPart > 0 );

            istrSubStrStart.Reset();
            istrSubStrStart += cchFirstPart;
            istrTempPos = istrSubStrStart;
            ++istrTempPos;

            pnls->DelSubStr( istrSubStrStart, istrTempPos );
        }
        else
        {
            cchSecPart--;
            ASSERT( cchSecPart > 0 );

            istrTempPos.Reset();
            istrTempPos += cchNumLogicalChar - cchSecPart - 1;
            istrSubStrEnd = istrTempPos;
            ++istrSubStrEnd;

            pnls->DelSubStr( istrTempPos, istrSubStrEnd );
        }
        if (!*pnls)
            return pnls->QueryError();

        cchNumLogicalChar = pnls->QueryNumChar();
    }

    return pnls->QueryError();
}

/**********************************************************************

    NAME:       CONSOLE_ELLIPSIS::CONSOLE_ELLIPSIS

    SYNOPSIS:   constructor

    ENTRY:

    NOTES:

    HISTORY:
        congpay     06-Apr-1993 created.

**********************************************************************/

CONSOLE_ELLIPSIS::CONSOLE_ELLIPSIS( ELLIPSIS_STYLE nStyle,
                                    INT            nLimit)
    :BASE_ELLIPSIS ( nStyle ),
     _nLimit(nLimit)
{
}

/**********************************************************************

    NAME:       CONSOLE_ELLIPSIS::QueryStrLen

    SYNOPSIS:

    ENTRY:

    NOTES:

    HISTORY:
        congpay     06-Apr-1993 created.

**********************************************************************/

INT CONSOLE_ELLIPSIS::QueryStrLen( NLS_STR nlsStr)
{
    return (nlsStr.strlen());
}

INT CONSOLE_ELLIPSIS::QueryStrLen( const TCHAR * lpStr, INT nIstr)
{
    UNREFERENCED (lpStr);
    return (nIstr);
}
/**********************************************************************

    NAME:       CONSOLE_ELLIPSIS::QueryLimit

    SYNOPSIS:

    ENTRY:

    NOTES:

    HISTORY:
        congpay     06-Apr-1993 created.

**********************************************************************/

CONSOLE_ELLIPSIS::QueryLimit()
{
    return (_nLimit);
}

/**********************************************************************

    NAME:       CONSOLE_ELLIPSIS::QueryMaxCharWidth()

    SYNOPSIS:

    ENTRY:

    NOTES:

    HISTORY:
        congpay     06-Apr-1993 created.

**********************************************************************/

INT CONSOLE_ELLIPSIS::QueryMaxCharWidth( )
{
    return(1);
}

/**********************************************************************

    NAME:       CONSOLE_ELLIPSIS::SetSize

    SYNOPSIS:

    ENTRY:

    NOTES:

    HISTORY:
        congpay     06-Apr-1993 created.

**********************************************************************/

void CONSOLE_ELLIPSIS::SetSize( INT nLimit)
{
    _nLimit = nLimit;
}

/**********************************************************************

    NAME:       WIN_ELLIPSIS::WIN_ELLIPSIS

    SYNOPSIS:   constructor

    ENTRY:

    NOTES:

    HISTORY:
        congpay     06-Apr-1993 created.

**********************************************************************/

WIN_ELLIPSIS::WIN_ELLIPSIS( WINDOW * pwin, ELLIPSIS_STYLE nStyle)
    :BASE_ELLIPSIS (nStyle),
    _dc(pwin)
{
    if (QueryError())
        return;

    pwin->QueryClientRect(&_rect);
}

WIN_ELLIPSIS::WIN_ELLIPSIS (WINDOW * pwin, HDC hdc, const RECT * prect, ELLIPSIS_STYLE nStyle)
    :BASE_ELLIPSIS (nStyle),
     _dc (pwin, hdc)
{
    if (QueryError())
        return;

    _rect.right = prect->right;
    _rect.left = prect->left;
    _rect.bottom = prect->bottom;
    _rect.top = prect->top;
}


/**********************************************************************

    NAME:       WIN_ELLIPSIS::QueryLimit

    SYNOPSIS:

    ENTRY:

    NOTES:

    HISTORY:
        congpay      07-Apr-1993 created

**********************************************************************/

INT WIN_ELLIPSIS::QueryLimit()
{
    return ( _rect.right - _rect.left );
}

/**********************************************************************

    NAME:       WIN_ELLIPSIS::QueryMaxCharWidth

    ENTRY:

    EXIT:

    HISTORY:
        congpay     07-Apr-1993  creation

**********************************************************************/

INT WIN_ELLIPSIS::QueryMaxCharWidth( )
{
    TEXTMETRIC textmetric;

    _dc.QueryTextMetrics( & textmetric );
    ASSERT(textmetric.tmMaxCharWidth  != 0 );

    return (textmetric.tmMaxCharWidth);
}

/**********************************************************************

    NAME:       WIN_ELLIPSIS::QueryStrLen

    ENTRY:

    EXIT:

    HISTORY:
        congpay     07-Apr-1993  creation

**********************************************************************/

INT WIN_ELLIPSIS::QueryStrLen( NLS_STR nlsStr )
{
    return (_dc.QueryTextWidth( nlsStr ));
}

INT WIN_ELLIPSIS::QueryStrLen (const TCHAR * lpStr, INT nIstr)
{
    return(_dc.QueryTextWidth (lpStr, nIstr));
}

/*******************************************************************

    NAME:      WIN_ELLIPSIS::SetSize

    SYNOPSIS:  Sets the width and height of a window

    ENTRY:     dxWidth, dyHeight - width and height to set window to

    NOTES:

    HISTORY:
        congpay   10-Apr-1993       Created

********************************************************************/

VOID WIN_ELLIPSIS::SetSize( INT dxWidth, INT dyHeight )
{
    _rect.right = _rect.left + dxWidth;
    _rect.bottom = _rect.top + dyHeight;
}


/**********************************************************************

    NAME:       SLT_ELLIPSIS::SLT_ELLIPSIS

    SYNOPSIS:   constructor

    ENTRY:

    NOTES:

    HISTORY:
        congpay     08-Apr-1993 created.

**********************************************************************/

SLT_ELLIPSIS::SLT_ELLIPSIS( OWNER_WINDOW * powin, CID cid, ELLIPSIS_STYLE nStyle)
    :SLT (powin, cid),
     WIN_ELLIPSIS (this, nStyle)
{
}

SLT_ELLIPSIS::SLT_ELLIPSIS( OWNER_WINDOW * powin, CID cid,
                            XYPOINT xy, XYDIMENSION  dxy,
                            ULONG flStyle, const TCHAR * pszClassName,
                            ELLIPSIS_STYLE nStyle)
    :SLT (powin, cid, xy, dxy, flStyle, pszClassName),
     WIN_ELLIPSIS (this, nStyle)
{
}

/**********************************************************************

    NAME:       SLT_ELLIPSIS::QueryText

    SYNOPSIS:   Returns the original non-ellipsis text of the control.

    ENTRY:
       pszBuffer    A pointer to a buffer, where the text
                    will be copied.

       cbBufSize    The size of this buffer.  The window text
                    copied to the buffer will be truncated if
                    the buffer is not big enough (including the
                    trailing NUL), in which case the function will
                    return ERROR_MORE_DATA.
         or

       pnls         A pointer to a NLS_STR to hold the results

    EXIT:       If psz+cb, psz buffer now contains the text.
                If pnls, the string has endured assignment.

    RETURNS:    0 if successful,
                ERROR_MORE_DATA if had to truncate string to fit in
                    user-supplied buffer.
                Otherwise, some error code.

    HISTORY:
        congpay      13-Apr-1993     Created

**********************************************************************/

APIERR SLT_ELLIPSIS::QueryText( TCHAR * pszBuffer, UINT cbBufSize ) const
{
    return WIN_ELLIPSIS::QueryText (pszBuffer, cbBufSize);
}

APIERR SLT_ELLIPSIS::QueryText( NLS_STR * pnls ) const
{
    return WIN_ELLIPSIS::QueryText(pnls);
}

/**********************************************************************

    NAME:       SLT_ELLIPSIS::SetText

    SYNOPSIS:   Sets the text contents of a control.
                It will also put an ellipsis text within the string
                if the string is too long.

    ENTRY:
         psz             A pointer to the text
        or
         nls             NLS text string

    RETURN:  error code from the converting routine.

    NOTES:
        NLS text string can be a NULL string

    HISTORY:
        terryk      27-Mar-1991 Created
        beng        18-Sep-1991 Refined error reporting
        beng        04-Oct-1991 Win32 conversion
        beng        30-Apr-1992 Use NLS_STR::CopyFrom

**********************************************************************/

APIERR SLT_ELLIPSIS::SetText( const TCHAR * psz )
{
    APIERR err = SetOriginalStr (psz);
    if (err != NERR_Success)
        return err;

    return ConvertAndSetStr();
}

APIERR SLT_ELLIPSIS::SetText (const NLS_STR & nls)
{
    if (!nls)
        return nls.QueryError();

    return SetText(nls.QueryPch());
}

/**********************************************************************

    NAME:       SLT_ELLIPSIS::ClearText

    SYNOPSIS:   Clears the window text of the window.

    NOTE:       This redefinition is necessary because this class
                also redefines SetText, *which is not virtual*.

    HISTORY:
        terryk      27-Mar-1991     Created

**********************************************************************/

VOID SLT_ELLIPSIS::ClearText()
{
    SetText( NULL );
}

/**********************************************************************

    NAME:       SLT_ELLIPSIS::ConvertAndSetStr

    SYNOPSIS:   set the ellipsis text and set the window text

    NOTES:      set the window text at the end of the procedure.

    HISTORY:
        terryk      2-Apr-1991  creation
        beng        18-Sep-1991 Changed return type

**********************************************************************/

APIERR SLT_ELLIPSIS::ConvertAndSetStr()
{
    NLS_STR nlsTempStr = QueryOriginalStr();

    APIERR err = nlsTempStr.QueryError();

    if ( err == NERR_Success )
    {
        if ( BASE_ELLIPSIS::QueryStyle() != ELLIPSIS_NONE )
            err = SetEllipsis( &nlsTempStr );

        if (err == NERR_Success )
        {
            // set the temporary string as a window text

            SLT::SetText( nlsTempStr );
        }
    }

    return err;
}

/*******************************************************************

    NAME:      SLT_ELLIPSIS::SetSize

    SYNOPSIS:  Sets the width and height of a window

    ENTRY:     dxWidth, dyHeight - width and height to set window to

    NOTES:     resize the window and reset the display string

    HISTORY:
        terryk      27-Mar-91       Created

********************************************************************/

VOID SLT_ELLIPSIS::SetSize( INT dxWidth, INT dyHeight, BOOL fRepaint )
{
    // Always set repaint to FALSE, because ConvertAndSetStr will
    // change the string anyway

    UNREFERENCED(fRepaint);

    WIN_ELLIPSIS::SetSize( dxWidth, dyHeight );

    SLT::SetSize (dxWidth, dyHeight, FALSE);

    ConvertAndSetStr();
}

/**********************************************************************

    NAME:       SLT_ELLIPSIS::ResetStyle

    SYNOPSIS:   reset the display style

    ENTRY:      ELLIPSIS_STYLE flStyle - the display style.
                It will be any one of the following 5 styles:
                   SLTP_ELLIPSIS_NONE
                   SLTP_ELLIPSIS_LEFT
                   SLTP_ELLIPSIS_CENTER
                   SLTP_ELLIPSIS_RIGHT
                   SLTP_ELLIPSIS_PATH

    EXIT:       reset the internal style.

    NOTES:      It will also update the window text

    HISTORY:
        terryk      27-Mar-1991 creation

**********************************************************************/

VOID SLT_ELLIPSIS::ResetStyle( const ELLIPSIS_STYLE nStyle )
{
    UIASSERT( IsValidStyle( nStyle ));

    if ( BASE_ELLIPSIS::QueryStyle() != nStyle )
    {
        BASE_ELLIPSIS::SetStyle(nStyle);
        ConvertAndSetStr();
    }
}

/**********************************************************************

    NAME:       STR_DTE_ELLIPSIS::STR_DTE_ELLIPSIS

    SYNOPSIS:   constructor

    ENTRY:

    NOTES:

    HISTORY:
        congpay     08-Apr-1993 created.

**********************************************************************/

STR_DTE_ELLIPSIS::STR_DTE_ELLIPSIS(const TCHAR * pch, LISTBOX * plb, ELLIPSIS_STYLE nStyle)
    :STR_DTE(pch),
    _plb(plb),
    _nStyle(nStyle)
{
}

/**********************************************************************

    NAME:       STR_DTE_ELLIPSIS::STR_DTE_ELLIPSIS

    SYNOPSIS:   constructor

    ENTRY:

    NOTES:

    HISTORY:
        congpay     08-Apr-1993 created.

**********************************************************************/

VOID STR_DTE_ELLIPSIS::Paint (HDC hdc, const RECT * prect) const
{
    if (QueryPch() == NULL)
        return;

    WIN_ELLIPSIS winellipsis ((WINDOW *) _plb, hdc, prect, _nStyle);

    if (winellipsis.QueryError() != NERR_Success)
        return;

    NLS_STR nlsTemp(QueryPch());

    ASSERT (nlsTemp.QueryError() == NERR_Success);

    winellipsis.SetEllipsis (&nlsTemp);

    DEVICE_CONTEXT dc(hdc);

    UINT cyHeight = prect->bottom - prect->top + 1;

    INT dyCentering = ((INT) cyHeight - dc.QueryFontHeight()) / 2;

    BOOL fSuccess = dc.TextOut (nlsTemp.QueryPch(),
                                ::strlenf(nlsTemp.QueryPch()),
                                prect->left,
                                prect->top + dyCentering,
                                prect);

#if defined(DEBUG)
    if (!fSuccess)
    {
        APIERR err = BLT::MapLastError (ERROR_GEN_FAILURE);
        DBGOUT ("BLT: TexeOut in LB failed, err = " << err);
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\domthred.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT			     **/
/**		   Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*
    This file contains the domain fill thread code


    FILE HISTORY:
	Johnl	07-Dec-1992	Created

*/

#include "pchapplb.hxx"   // Precompiled header

#include "browmemb.hxx"

/*******************************************************************

    NAME:	DOMAIN_FILL_THREAD::DOMAIN_FILL_THREAD

    SYNOPSIS:	Constructor for the domain fill thread

    ENTRY:	pdlg - Pointer to user browser dialog (generally treated
		    as a read only resource)
		pbrowdomain - Pointer to browser domain that this thread
		    will get the information for

    NOTES:	This thread is created in the suspended state.	The caller
		must call resume to actually get the thread moving.

    HISTORY:
	Johnl	07-Dec-1992	Created

********************************************************************/

DOMAIN_FILL_THREAD::DOMAIN_FILL_THREAD( NT_USER_BROWSER_DIALOG * pdlg,
					BROWSER_DOMAIN	       * pbrowdomain,
					const ADMIN_AUTHORITY * pAdminAuthority )
    : WIN32_THREAD	     ( TRUE, 1024, SZ("NETUI2.DLL") ),
      _pAdminAuthority       ( (ADMIN_AUTHORITY *)pAdminAuthority ),
      _eventExitThread	     ( NULL, FALSE ),
      _eventRequestForData   ( NULL, FALSE ),
      _eventLoadedAuthority  ( NULL, TRUE, FALSE ),
      _fRequestDataPending   ( FALSE ),
      _fThreadIsTerminating  ( FALSE ),
      _errLoadingAuthority   ( NERR_Success ),
      _plbicache	     ( NULL ),
      _hwndDlg               ( pdlg->QueryHwnd() ),
      _ulDlgFlags            ( pdlg->QueryFlags() ),
      _nlsDCofPrimaryDomain  ( pdlg->QueryDCofPrimaryDomain() ),
      _nlsDomainName         ( pbrowdomain->QueryDomainName() ),
      _nlsLsaDomainName      ( pbrowdomain->QueryLsaLookupName() ),
      _fIsWinNT              ( pbrowdomain->IsWinNTMachine() ),
      _fIsTargetDomain       ( pbrowdomain->IsTargetDomain() ),
      _fDeleteAdminAuthority ( pAdminAuthority == NULL )
{
    if ( QueryError() )
	return ;

    //
    //	The thread is started after we check for successful construction
    //	of our members
    //
    APIERR err ;
    if ( (err = _eventExitThread.QueryError()) ||
	 (err = _eventRequestForData.QueryError()) ||
	 (err = _eventLoadedAuthority.QueryError()) )
    {
	ReportError( err ) ;
	return ;
    }
}

DOMAIN_FILL_THREAD::~DOMAIN_FILL_THREAD()
{
    delete _plbicache ;
    _plbicache = NULL ;
    if ( _fDeleteAdminAuthority )
    {
        delete _pAdminAuthority ;
        _pAdminAuthority = NULL ;
    }
}

APIERR DOMAIN_FILL_THREAD::PostMain( VOID )
{
    TRACEEOL("DOMAIN_FILL_THREAD::PostMain - Deleting \"this\" for thread "
             << HEX_STR( (ULONG) QueryHandle() )) ;

    DeleteAndExit( NERR_Success ) ; // This method should never return

    UIASSERT( FALSE );

    return NERR_Success;
}

/*******************************************************************

    NAME:	DOMAIN_FILL_THREAD::Main

    SYNOPSIS:	Threads main worker method

    NOTES:

    HISTORY:
	Johnl	07-Dec-1992	Created

********************************************************************/

APIERR DOMAIN_FILL_THREAD::Main( VOID )
{
    TRACEEOL("DOMAIN_FILL_THREAD::Main Entered") ;

    APIERR err = NERR_Success ;
    const TCHAR * pszServer ;
    BOOL fIsServer = TRUE ;

    //
    //	If the name begins with a "\\" or is NULL, then the domain is
    //	really a server which we can use directly (i.e., its either the
    //	focused machine or the PDC of a domain).
    //
    const TCHAR *pszDomainName = _nlsDomainName.QueryPch();
    if ( ( pszDomainName[ 0 ] != TCH('\0') &&
	   pszDomainName[ 0 ] == TCH('\\') &&
	   pszDomainName[ 1 ] == TCH('\\')))
    {
	pszServer = pszDomainName;
    }
    else if ( *pszDomainName == TCH('\0') )
    {
        pszServer = NULL ;
    }
    else
    {
        fIsServer = FALSE ;
    }

    //
    //	The domain name length will be zero if this is the local machine
    //
    //  SPECIAL CAUTION: see the SPECIAL CAUTION in lmodom.hxx for a warning about
    //  this call.  This is believed to be the only call in NETUI which passes a
    //  target server to DOMAIN[_WITH_DC_CACHE], this parameter is no longer active.
    //  JonN 5/18/98
    //
    DOMAIN_WITH_DC_CACHE BrowserDomain( _nlsDCofPrimaryDomain,
                                        _nlsDomainName,
                                        TRUE ) ;
    BOOL fGotDC        = FALSE ;
    BOOL fGotValidData = FALSE ;    // Successfully enumerated all data

    //
    //  This is the thread's main loop.  In response to each request, we
    //	try and get the necessary data items.  If we can't, then will try
    //	again on the next request.  Once we have successfully gotten all of
    //	the data, we just keep it in a sorted array waiting for somebody
    //	to ask for it.
    //

    while ( TRUE )
    {
	err = NERR_Success ;

	if ( _fThreadIsTerminating )
	    break ;

	//
	//  First try and get the DC
	//

	if ( !fIsServer &&
	     !fGotDC	&&
             (_pAdminAuthority == NULL) &&
	     (err = BrowserDomain.GetInfo()) )
	{
	    DBGEOL( "DOMAIN_FILL_THREAD::Main - Error " << (ULONG) err <<
		    " occurred constructing the DOMAIN class" ) ;
            //
            //  Give a more specific error message.  The workstation or
            //  browser not started should be the only reason why we get
            //  this error.
            //
            if ( err == NERR_ServiceNotInstalled )
                err = IDS_WKSTA_OR_BROWSER_NOT_STARTED;
        }
	else
	{
	    fGotDC = TRUE ;
	}

	if ( _fThreadIsTerminating )
	    break ;

	//
	//  Now try and get the admin authority
	//

	if ( !err && _pAdminAuthority == NULL )
	{
	    err = ERROR_NOT_ENOUGH_MEMORY ;
	    _pAdminAuthority = new ADMIN_AUTHORITY(fIsServer ? pszServer :
						     BrowserDomain.QueryAnyDC(),
						   DEF_SAM_DOMAIN_ACCESS,
						   DEF_SAM_DOMAIN_ACCESS,
						   DEF_LSA_POLICY_ACCESS,
						   DEF_SAM_SERVER_ACCESS,
						   TRUE
						  ) ;
            err = ERROR_NOT_ENOUGH_MEMORY;
	    if ( _pAdminAuthority == NULL ||
		 (err = _pAdminAuthority->QueryError()) )
	    {
		DBGEOL( "DOMAIN_FILL_THREAD::Main -  - Error " << (ULONG) err <<
			" occurred creating the ADMIN_AUTHORITY" ) ;
                if ( _fDeleteAdminAuthority )
                {
		    delete _pAdminAuthority;
		    _pAdminAuthority = NULL;
                }
	    }
	}

        //
        // We remember the reason why (if) we failed to load the authority.
        //
        ASSERT(   (    _pAdminAuthority != NULL
                    && _pAdminAuthority->QueryError() == NERR_Success )
               || (err != NERR_Success) );
        _errLoadingAuthority = err;

        //
        // Whether or not we successfully allocated the ADMIN_AUTHORITY,
        // we set the LoadedAuthority event here.
        //
        {
            TRACEEOL( "DOMAIN_FILL_THREAD: setting AdminAuthority event (1)" );

            APIERR errEvent = _eventLoadedAuthority.Set() ;
            if (errEvent != NERR_Success)
            {
		DBGEOL("DOMAIN_FILL_THREAD::Main - Error " << errEvent <<
		       "setting LoadedAuthority event" ) ;
                if (err == NERR_Success)
                    err = errEvent;
            }
        }

	if ( _fThreadIsTerminating )
	    break ;

	//
	//  Now try and fill the array
	//

	if (!err &&
	    _plbicache == NULL )
	{
	    err = ERROR_NOT_ENOUGH_MEMORY ;
	    _plbicache = new USER_BROWSER_LBI_CACHE() ;
	    if ( _plbicache == NULL ||
                 (err = _plbicache->Fill(
                                   _pAdminAuthority,
                                   _nlsLsaDomainName.QueryPch()[0] == TCH('\\') ?
                                       _nlsLsaDomainName.QueryPch()+2 :
                                       _nlsLsaDomainName.QueryPch(),
                                   _ulDlgFlags,
                                   _fIsWinNT,
                                   _fIsTargetDomain,
                                   &_fThreadIsTerminating )) )
	    {
		DBGEOL("DOMAIN_FILL_THREAD::Main - Error " << err <<
		       "retrieving account data" ) ;
		delete _plbicache ;
		_plbicache = NULL ;
	    }
	}

	if ( _fThreadIsTerminating )
	    break ;

	//
	//  If we failed on any of the previous items, then put up an error
	//  and wait to see if we are selected again.
	//
	//  Else send the data to the dialog if they still want it.
	//

	if ( err )
	{
	    fGotValidData = FALSE ;
	    if ( _fRequestDataPending && !_fThreadIsTerminating )
	    {
		::SendMessage( _hwndDlg, WM_LB_FILLED,
                               (WPARAM) FALSE, (LPARAM) err ) ;
	    }
	}
	else
	{
	    fGotValidData = TRUE ;

	    //
	    //	The data request may have been cancelled or this may be
	    //	the second time through this loop because we got an error
	    //	the first time.  Satisfy the request then clear the event.
	    //
	    if ( _fRequestDataPending )
            {
                //
                //  Only include users in the initial data request if the users
                //  are expanded or that is all that is shown.
                //
                _plbicache->SetIncludeUsers(
                   _ulDlgFlags & USRBROWS_EXPAND_USERS ||
                   (( _ulDlgFlags & USRBROWS_SHOW_ALL) == USRBROWS_SHOW_USERS));

		if ( _fRequestDataPending && !_fThreadIsTerminating )
                {
                    ::PostMessage( _hwndDlg,
                                   WM_LB_FILLED,
                                   (WPARAM) TRUE,
                                   (LPARAM) _plbicache ) ;
		}

		//
		// Reset any subsequent requests we may have received for this
		// domain's thread
		//
		_eventRequestForData.Reset() ;
		_fRequestDataPending = FALSE ;
	    }
	}

	//
	//  Wait on events
	//

	HANDLE ahEvents[2] ;
	ahEvents[0] = _eventExitThread.QueryHandle() ;
	ahEvents[1] = _eventRequestForData.QueryHandle() ;

	switch ( ::WaitForMultipleObjects( 2, ahEvents, FALSE, INFINITE ))
	{
	case STATUS_WAIT_0: // Get out of Dodge...

	    _fThreadIsTerminating = TRUE ;
	    break ;

	case STATUS_WAIT_1: // Dialog wants our data
	    //
	    //	Make sure we have data to give.  If we don't, then we loop
	    //	through and try again.
	    //
	    _fRequestDataPending = TRUE ;

	    break ;

	default:
	    err = ::GetLastError() ;
	    DBGEOL("DOMAIN_FILL_THREAD::Main - Error " << err << " waiting on events")
	}

	if ( _fThreadIsTerminating )
	    break ;
    }


    TRACEEOL("DOMAIN_FILL_THREAD::terminating") ;
    return err ;
}

APIERR DOMAIN_FILL_THREAD::WaitForAdminAuthority( DWORD msTimeout,
                                                  BOOL * pfTimedOut ) const
{
    TRACEEOL( "DOMAIN_FILL_THREAD: waiting for AdminAuthority at time " << ::GetTickCount() );

    APIERR err = NERR_Success;

    if (pfTimedOut != NULL)
        *pfTimedOut = FALSE;

    HANDLE hEvent = _eventLoadedAuthority.QueryHandle();

    switch ( ::WaitForSingleObject( _eventLoadedAuthority.QueryHandle(), msTimeout ))
    {
    case WAIT_OBJECT_0: // event was set
        TRACEEOL("DOMAIN_FILL_THREAD::WaitForAdminAuthority - WAIT_OBJECT_0");
        break ;

    case WAIT_ABANDONED:
        TRACEEOL("DOMAIN_FILL_THREAD::WaitForAdminAuthority - WAIT_ABANDONED");
        break;

    case WAIT_TIMEOUT:
        TRACEEOL("DOMAIN_FILL_THREAD::WaitForAdminAuthority - WAIT_TIMEOUT after " << msTimeout << " ms" );
        if (pfTimedOut != NULL)
            *pfTimedOut = TRUE;
        break;

    default:
        err = ::GetLastError() ;
        DBGEOL("DOMAIN_FILL_THREAD::WaitForAdminAuthority - Error " << err << " waiting on events")
        break;
    }

    TRACEEOL( "DOMAIN_FILL_THREAD: returning " << err << " at time " << ::GetTickCount() );

    return err;
}


//
//  Gets around circular reference problems
//
APIERR DOMAIN_FILL_THREAD::RequestAndWaitForUsers( void )
{
    const TCHAR *pszDomainName = _nlsLsaDomainName.QueryPch();
    if ( ( pszDomainName[ 0 ] != TCH('\0') &&
	   pszDomainName[ 0 ] == TCH('\\') &&
	   pszDomainName[ 1 ] == TCH('\\')))
    {
        //
        //  Domain name is a server name so strip the '\\'
        //
        pszDomainName += 2 ;
    }
    return _plbicache->AddUsers( _pAdminAuthority,
                                 pszDomainName,
				 _fIsTargetDomain,
                                 &_fThreadIsTerminating ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\focuschk.cxx ===
/**********************************************************************/
/**           Microsoft Windows NT                                   **/
/**        Copyright(c) Microsoft Corp., 1991                        **/
/**********************************************************************/

/*
    focuschk.cxx

    This file contains the implementation for the focus checkboxes.

    FILE HISTORY:
        Johnl   06-Sep-1991 Created

*/

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:       FOCUS_CHECKBOX::FOCUS_CHECKBOX

    SYNOPSIS:   Constructor for FOCUS_CHECKBOX control

    ENTRY:      Same as CHECKBOX

    NOTES:      The focus box is placed one unit outside the checkbox

    HISTORY:
        Johnl   12-Sep-1991 Created

********************************************************************/

FOCUS_CHECKBOX::FOCUS_CHECKBOX( OWNER_WINDOW * powin, CID cidCheckBox )
        : CHECKBOX( powin, cidCheckBox ),
          CUSTOM_CONTROL( this ),
          _fHasFocus( FALSE )
{
    if ( QueryError() != NERR_Success )
        return ;

    /* We have to convert the rectangle's position since we are drawing in
     * the owner window's cooridinates.
     */
    QueryWindowRect( &_rectFocusBox ) ;
    ::ScreenToClient( QueryOwnerHwnd(), &( ((LPPOINT)&_rectFocusBox)[0] )) ;
    ::ScreenToClient( QueryOwnerHwnd(), &( ((LPPOINT)&_rectFocusBox)[1] )) ;

    /* Expand the rectangle by just a little
     */
    _rectFocusBox.top-- ;
    _rectFocusBox.left-- ;
    #if (defined(_MIPS_)) || (defined(_PPC_))
        _rectFocusBox.right++ ;
    #else
        _rectFocusBox.right += 4;
    #endif
    _rectFocusBox.bottom++ ;
}


/*******************************************************************

    NAME:       FOCUS_CHECKBOX::OnFocus

    SYNOPSIS:   Draws the focus rect and saves our state

    NOTES:      Note we are drawing on the owner window and not in
                the checkbox

    HISTORY:
        Johnl   12-Aug-1991 Created

********************************************************************/


BOOL FOCUS_CHECKBOX::OnFocus( const FOCUS_EVENT & focusevent )
{
    DISPLAY_CONTEXT dc( QueryOwnerHwnd() ) ;
    DrawFocusRect( &dc, &_rectFocusBox ) ;

    _fHasFocus = TRUE ;
    return DISPATCHER::OnFocus( focusevent ) ;
}

/*******************************************************************

    NAME:       FOCUS_CHECKBOX::OnDefocus

    SYNOPSIS:   Clears the focus box

    NOTES:

    HISTORY:
        Johnl   12-Aug-1991 Created

********************************************************************/

BOOL FOCUS_CHECKBOX::OnDefocus( const FOCUS_EVENT & focusevent )
{
    DISPLAY_CONTEXT dc( QueryOwnerHwnd() ) ;
    EraseFocusRect( &dc, &_rectFocusBox ) ;

    _fHasFocus = FALSE ;
    return DISPATCHER::OnDefocus( focusevent ) ;
}

/*******************************************************************

    NAME:       FOCUS_CHECKBOX::OnPaintReq

    SYNOPSIS:   If we have the focus, then draw the focus rectangle

    NOTES:

    HISTORY:
        Johnl   12-Aug-1991 Created

********************************************************************/

BOOL FOCUS_CHECKBOX::OnPaintReq( void )
{
    if ( _fHasFocus )
    {
        /* Note: This is not a PAINT_DISPLAY_CONTEXT because we need to let the
         * code that draws the checkbox validate the window (if we validate it,
         * then no one else can draw to it using the BeginPaint/EndPaint sequence).
         */
        DISPLAY_CONTEXT dc( QueryOwnerHwnd() ) ;

        DrawFocusRect( &dc, &_rectFocusBox ) ;
    }

    return DISPATCHER::OnPaintReq() ;
}

/*******************************************************************

    NAME:       FOCUS_CHECKBOX::DrawFocusRect

    SYNOPSIS:   Draws/erases the rectangle that indicates this checkbox
                has the focus.

    ENTRY:      pdc - Pointer to the device context to draw/clear the focus box
                lpRect - Cooridinates the focus box resides
                fErase - FALSE for drawing the focus box, TRUE for erasing
                         the focus box.

    NOTES:      We erase the focus box with COLOR_WINDOW color

    HISTORY:
        Johnl   12-Sep-1991 Created

********************************************************************/

void FOCUS_CHECKBOX::DrawFocusRect( DEVICE_CONTEXT * pdc, LPRECT lpRect, BOOL fErase )
{
    /* We always erase the focus box before redrawing it since we never know
     * if only half of the focus box is there (which is a problem since it
     * is an XOR operation).
     *
     * JonN 9/29/95 In WINVER40 we use COLOR_3DFACE not COLOR_WINDOW.
     */
    DWORD rgbFocusBoxColor = ::GetSysColor( COLOR_3DFACE ) ;

    HBRUSH hbrushFocusBoxColor = ::CreateSolidBrush( rgbFocusBoxColor ) ;
    HBRUSH hbrushOld = pdc->SelectBrush( hbrushFocusBoxColor ) ;

    if ( hbrushOld != NULL )
    {
        pdc->FrameRect( lpRect, hbrushFocusBoxColor ) ;

        pdc->SelectBrush( hbrushOld ) ;
        REQUIRE( ::DeleteObject( (HGDIOBJ)hbrushFocusBoxColor) ) ;
    }

    if ( !fErase )
    {
        pdc->DrawFocusRect( lpRect ) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\fontedit.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    fontedit.cxx
	It contains the constructor of MLT_FONT, which the caller can
	specify the font for the MLT.
	It also contains the constructor of SLT_FONT, which is the same
	as MLT_FONT but it is for SLT.
	It also contains the constructor of MLE_FONT, which the caller can
	specify the font for the MLE.
	It also contains the constructor of SLE_FONT, which the caller can
	specify the font for the SLE.

    FILE HISTORY:
	terryk	21-Nov-1991	Created
	Yi-HsinS21-Feb-1992	Added SLE_FONT and MLE_FONT

*/

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:	MLT_FONT::MLT_FONT

    SYNOPSIS:	The is the same as normal MLT. However, the caller can
		specify the font type of the MLT.

    ENTRY:	OWNER_WINDOW *powin - the pointer to the owner window
		CID cid - cid of the control
		enum FontType font - the specified font. The default is
		    FONT_DEFUALT

    HISTORY:
		terryk	21-Nov-1991	Created

********************************************************************/

MLT_FONT::MLT_FONT( OWNER_WINDOW *powin, CID cid, enum FontType font )
    : MLT( powin, cid ),
    _fontMLT( font )
{
    if ( QueryError() )
    {
	return;
    }

    if ( !_fontMLT.QueryError() )
	Command( WM_SETFONT, (WPARAM) _fontMLT.QueryHandle(), (LPARAM) FALSE );
}

/*******************************************************************

    NAME:	SLT_FONT::SLT_FONT

    SYNOPSIS:	The is the same as normal SLT. However, the caller can
		specify the font type of the SLT.

    ENTRY:	OWNER_WINDOW *powin - the pointer to the owner window
		CID cid - cid of the control
		enum FontType font - the specified font. The default is
		    FONT_DEFUALT

    HISTORY:
		terryk	21-Nov-1991	Created

********************************************************************/

SLT_FONT::SLT_FONT( OWNER_WINDOW *powin, CID cid, enum FontType font )
    : SLT( powin, cid ),
    _fontSLT( font )
{
    if ( QueryError() )
    {
	return;
    }

    if ( !_fontSLT.QueryError() )
	Command( WM_SETFONT, (WPARAM) _fontSLT.QueryHandle(), (LPARAM) FALSE );
}

/*******************************************************************

    NAME:	MLE_FONT::MLE_FONT

    SYNOPSIS:	The is the same as normal MLE. However, the caller can
		specify the font type of the MLE.

    ENTRY:	OWNER_WINDOW *powin - the pointer to the owner window
		CID cid - cid of the control
		enum FontType font - the specified font. The default is
		    FONT_DEFUALT

    HISTORY:
		Yi-HsinS21-Feb-1992	Created

********************************************************************/

MLE_FONT::MLE_FONT( OWNER_WINDOW *powin, CID cid, enum FontType font )
    : MLE( powin, cid ),
    _fontMLE( font )
{
    if ( QueryError() )
    {
	return;
    }

    if ( !_fontMLE.QueryError() )
	Command( WM_SETFONT, (WPARAM) _fontMLE.QueryHandle(), (LPARAM) FALSE );
}

/*******************************************************************

    NAME:	SLE_FONT::SLE_FONT

    SYNOPSIS:	The is the same as normal SLE. However, the caller can
		specify the font type of the SLT.

    ENTRY:	OWNER_WINDOW *powin - the pointer to the owner window
		CID cid - cid of the control
		enum FontType font - the specified font. The default is
		    FONT_DEFUALT

    HISTORY:
		Yi-HsinS21-Feb-1992	Created

********************************************************************/

SLE_FONT::SLE_FONT( OWNER_WINDOW *powin, CID cid, enum FontType font )
    : SLE( powin, cid ),
    _fontSLE( font )
{
    if ( QueryError() )
    {
	return;
    }

    if ( !_fontSLE.QueryError() )
	Command( WM_SETFONT, (WPARAM) _fontSLE.QueryHandle(), (LPARAM) FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\focusdlg.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    focusdlg.cxx
    Common dialog for setting the app's focus

    FILE HISTORY:
        kevinl      14-Jun-91   Created
        rustanl     04-Sep-1991 Modified to let this dialog do more
                                work (rather than letting ADMIN_APP
                                do the work after this dialog is
                                dismissed)
        KeithMo     06-Oct-1991 Win32 Conversion.
        terryk      18-Nov-1991 Move from admin\common\src\adminapp\setfocus
                                to here
        terryk      26-Nov-1991 Remove an unnecessary comment
        KeithMo     07-Aug-1992 Added HelpContext parameters.
*/

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::BASE_SET_FOCUS_DLG

    SYNOPSIS:   Constructor

    ENTRY:      HWND hWnd - owner window handle

    RETURN:     An error value, which is NERR_Success on success.

    HISTORY:
       kevinl   14-Jun-91       Created
       terryk   18-Nov-91       Change to BASE_SET_FOCUS_DLG
       KeithMo  22-Jul-1992     Added maskDomainSources & pszDefaultSelection.

********************************************************************/

BASE_SET_FOCUS_DLG::BASE_SET_FOCUS_DLG( const HWND wndOwner,
                                        SELECTION_TYPE seltype,
                                        ULONG maskDomainSources,
                                        const TCHAR * pszDefaultSelection,
                                        ULONG nHelpContext,
                                        const TCHAR *pszHelpFile,
                                        ULONG nServerTypes )
    :   DIALOG_WINDOW( ( seltype == SEL_SRV_ONLY
                         ||  seltype == SEL_SRV_ONLY_BUT_DONT_EXPAND_DOMAIN
                         ||  seltype == SEL_SRV_EXPAND_LOGON_DOMAIN )
                           ? MAKEINTRESOURCE( IDD_SELECTCOMPUTER_DLG )
                           : MAKEINTRESOURCE( IDD_SELECTDOMAIN_DLG ),
                       wndOwner,
/* kkbugfix */  FALSE                  // Use Unicode form of dialog to
                                       // canonicalize the computernames
		),	
        _sleFocusPath( this, IDC_FOCUS_PATH, MAX_PATH ), // fix UpdateRasMode
                                                       // if maxlen changed
        _olb( this,
              IDC_DOMAIN_LB,
              seltype,
              nServerTypes),
        _sleGetInfo( this, IDC_SLE_GETINFO ),  // Always disabled
        _sltLBTitle( this, IDC_SEL_LB_TITLE ),
        _seltype(seltype),
        _nHelpContext( nHelpContext ),
        _nlsHelpFile(pszHelpFile),
        _sltBoundary( this, IDC_BOUNDARY ),
        _xyOriginal( 0, 0 ),
        _chkboxRasMode( this, IDC_LINK ),
        _sltRasModeMessage( this, IDC_LINK_MESSAGE ),
        _resstrRasServerSlow( IDS_SETFOCUS_SERVER_SLOW ),
        _resstrRasServerFast( IDS_SETFOCUS_SERVER_FAST ),
        _resstrRasDomainSlow( IDS_SETFOCUS_DOMAIN_SLOW ),
        _resstrRasDomainFast( IDS_SETFOCUS_DOMAIN_FAST ),
        _pDataThread( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (   (err = _nlsHelpFile.QueryError()) != NERR_Success
        || (err = _resstrRasServerSlow.QueryError()) != NERR_Success
        || (err = _resstrRasServerFast.QueryError()) != NERR_Success
        || (err = _resstrRasDomainSlow.QueryError()) != NERR_Success
        || (err = _resstrRasDomainFast.QueryError()) != NERR_Success
       )
    {
        ReportError( err );
        return;
    }

    _pDataThread = new FOCUSDLG_DATA_THREAD( QueryHwnd(),
                                             maskDomainSources,
                                             _seltype,
                                             pszDefaultSelection,
                                             nServerTypes );

    err = ERROR_NOT_ENOUGH_MEMORY;
    if (  ( _pDataThread == NULL )
       || ( (err = _pDataThread->QueryError()) != NERR_Success )
       || ( (err = _pDataThread->Resume()) != NERR_Success )
       )
    {
        delete _pDataThread;
        _pDataThread = NULL;

        ReportError( err );
        return;
    }

    RESOURCE_STR nlsGettingInfo( IDS_APPLIB_WORKING_TEXT );
    if ( (err = nlsGettingInfo.QueryError()) != NERR_Success )
    {
        ReportError( err );
        return;
    }
    _sleGetInfo.SetText( nlsGettingInfo );

    _olb.Show( FALSE );
    _sleGetInfo.Show( TRUE );
    _olb.Enable( FALSE );
    _sltLBTitle.Enable( FALSE );


    //  Since the Domain and Servers listbox now has a new selection, we call
    //  OnDomainLBChange to perform necessary updates.
    //  OnDomainLBChange();

    // give focus and select edit field
    SelectNetPathString();
}


/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::~BASE_SET_FOCUS_DLG

    SYNOPSIS:   Destructor.

    HISTORY:
       kevinl   14-Jun-91       Created
       terryk   18-Nov-91       Change to BASE_SET_FOCUS_DLG

********************************************************************/

BASE_SET_FOCUS_DLG::~BASE_SET_FOCUS_DLG()
{
    if ( _pDataThread != NULL )
    {
        _pDataThread->ExitThread();

        // Do not delete the thread object, it will delete itself.
        _pDataThread = NULL;
    }

}


/*******************************************************************

    NAME:     BASE_SET_FOCUS_DLG::SelectNetPathString

    SYNOPSIS: Set focus & select the network path.  Used after the network
              path is determined to be invalid.

    ENTRY:

    EXIT:     The string in the Network Path SLE will have the focus and
              be hi-lited.

    NOTES:

    HISTORY:
        Johnl   15-Mar-1991     Created - Part of solution to BUG 1218
       kevinl   14-Jun-91       Modified for SET_FOCUS_DLG
       terryk   18-Nov-91       Change to BASE_SET_FOCUS_DLG

********************************************************************/

VOID BASE_SET_FOCUS_DLG::SelectNetPathString( VOID )
{
    _sleFocusPath.ClaimFocus();
    _sleFocusPath.SelectString();
}


/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::OnDomainLBChange

    SYNOPSIS:   This method is called when the user takes an action in
                the Domain and Servers listbox.

    HISTORY:
       rustanl ??-Nov-91        Created
       kevinl   14-Jun-91       Significant modification to conform
                                to new functionality of the setfocus
                                dialog.  Specifically deals with domains
                                as valid selections...enterprises are
                                still considered incorrect selections.
       terryk   18-Nov-91       Change to BASE_SET_FOCUS_DLG
       KeithMo  23-Jul-1992     Can now handle an empty listbox.

********************************************************************/

VOID BASE_SET_FOCUS_DLG::OnDomainLBChange()
{
    //  Get the current listbox data item.  This item is a pointer to
    //  an OLLB_ENTRY.

    OLLB_ENTRY * pollbe = _olb.QueryItem();

    if( pollbe == NULL )
    {
        //
        //  Since the domain/server listbox is empty, we'll just
        //  clear the edit field.
        //

        _sleFocusPath.SetText( SZ("") );
        return;
    }

    //  Update the Set Focus on edit field.
    if ( pollbe->QueryLevel() == OLLBL_SERVER )
    {
        //  Allocate NLS_STR to fit \\server.   Initialize with
        //  two backslashes.
        ISTACK_NLS_STR( nlsServerName, MAX_PATH, SZ("\\\\") );

        UIASSERT( strlenf( pollbe->QueryServer() ) <= MAX_PATH );

        nlsServerName += pollbe->QueryServer();

        UIASSERT( nlsServerName.QueryError() == NERR_Success );

        _sleFocusPath.SetText( nlsServerName );
    }
    else if ( pollbe->QueryLevel() == OLLBL_DOMAIN )
    {
        if (  ( _seltype == SEL_SRV_ONLY )
           || ( _seltype == SEL_SRV_ONLY_BUT_DONT_EXPAND_DOMAIN )
           || ( _seltype == SEL_SRV_EXPAND_LOGON_DOMAIN )
           )
        {
            //
            //  Since the user is requesting servers only,
            //  it doesn't make much sense to stick a domain
            //  name in the edit field.
            //

            _sleFocusPath.SetText( SZ("") );
            return;
        }

        _sleFocusPath.SetText( pollbe->QueryDomain() );
    }
    else        // Enterprise
    {
        UIASSERT( !SZ("This shouldn't happen, since we don't have an enterprise") );
        _sleFocusPath.ClearText();
    }
}


/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::ProcessNetPath

    SYNOPSIS:   This method checks the Network Path field.
                If the field's contents contain a valid domain
                or server name then it will return TRUE,
                FALSE otherwise.

                If the SLE contains a string of the shape \\server
                or domainname and is validated then success is returned.

    ENTRY:      pnlsPath    Pointer to NLS_STR which will receive
                            the name of the network path.  The
                            value should only be used if this method
                            returns NERR_Success.

    EXIT:       On success, *pnlsPath will be the requested domain
                or server name.

    RETURNS:    An API return value, which is NERR_Success on success.

    HISTORY:
        kevinl      14-Jun-91       Created - modified version from the browser
        rustanl     05-Sep-1991     Changed return to to APIERR
        terryk      18-Nov-91       Change to BASE_SET_FOCUS_DLG

********************************************************************/

APIERR BASE_SET_FOCUS_DLG::ProcessNetPath( NLS_STR * pnlsPath, MSGID *pmsgid )
{
    UIASSERT( pnlsPath != NULL );
    UIASSERT( pmsgid != NULL );

    *pmsgid = 0 ;

    APIERR err = _sleFocusPath.QueryText( pnlsPath );
    if ( err != NERR_Success )
        return err;

    UIASSERT( pnlsPath->QueryError() == NERR_Success );

    if ( pnlsPath->strlen() == 0 )
    {
        *pmsgid = IDS_APPLIB_NO_SELECTION ;
        return ERROR_INVALID_PARAMETER;
    }

    // If the net name did not start with backslashes and we are only
    // selecting servers, append the backslashes.

    ISTR istrStart( *pnlsPath );
    if ( pnlsPath->QueryChar( istrStart ) != TCH('\\') )
    {
        if (  ( _seltype == SEL_SRV_ONLY )
           || ( _seltype == SEL_SRV_ONLY_BUT_DONT_EXPAND_DOMAIN )
           || ( _seltype == SEL_SRV_EXPAND_LOGON_DOMAIN )
           )
        {
            ALIAS_STR nls( SZ("\\\\") );
            if ( !pnlsPath->InsertStr( nls, istrStart ) )
                return pnlsPath->QueryError();
        }
    }

    //  We will attempt to check if the net name takes the form
    //  \\server, where "server" can be any non-empty
    //  string not containing backslashes.

    BOOL fIsDomain = FALSE;

    ISTR istr( *pnlsPath );
    if ( pnlsPath->QueryChar(   istr ) == TCH('\\') &&  //  backslash 0
         pnlsPath->QueryChar( ++istr ) == TCH('\\') &&  //  backslash 1
         pnlsPath->QueryChar( ++istr ) != TCH('\0') )
    {
        // The name has at least '\\' prepended so pass this string
        // minus the '\\' to the validation routine......

        err = ::I_MNetNameValidate( NULL, pnlsPath->QueryPch() + 2,
                                    NAMETYPE_COMPUTER, 0L );
        *pmsgid = IDS_APPLIB_NO_SELECTION ;
    }
    else
    {
        fIsDomain = TRUE;

        err = ::I_MNetNameValidate( NULL, pnlsPath->QueryPch(),
                                    NAMETYPE_DOMAIN, 0L );
        *pmsgid = IDS_APPLIB_NO_SELECTION ;
    }

    return err;
}

/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::Process

    SYNOPSIS:   Run the dialog after first displaying it in its default
                (reduced) size.

    ENTRY:      UINT * pnRetVal         return value from dialog

    EXIT:       APIERR  if failure to function

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

APIERR BASE_SET_FOCUS_DLG::Process ( UINT * pnRetVal )
{
    ShowArea( FALSE );
    return DIALOG_WINDOW::Process( pnRetVal ) ;
}

/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::Process

    SYNOPSIS:   Run the dialog after first displaying it in its default
                (reduced) size.

    ENTRY:      BOOL * pfRetVal         BOOL return value from dialog

    EXIT:       APIERR  if failure to function

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

APIERR BASE_SET_FOCUS_DLG::Process ( BOOL * pfRetVal )
{
    ShowArea( FALSE );
    return DIALOG_WINDOW::Process( pfRetVal ) ;
}

/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::OnUserMessage

    SYNOPSIS:   Handles WM_FOCUS_LB_FILLED messages.

    HISTORY:
        YiHsinS      10-Mar-1993     Created

********************************************************************/

BOOL BASE_SET_FOCUS_DLG::OnUserMessage( const EVENT & event )
{
    if ( event.QueryMessage() == WM_FOCUS_LB_FILLED )
    {
        AUTO_CURSOR autocur;

        BOOL fError = (BOOL) event.QueryWParam();
        if ( fError )
        {
            APIERR err;
            RESOURCE_STR nlsError( (APIERR) event.QueryLParam() );
            if ( (err = nlsError.QueryError()) != NERR_Success )
                ::MsgPopup( this, err );
            else
                _sleGetInfo.SetText( nlsError );
        }
        else
        {
            FOCUSDLG_RETURN_DATA *pData =
                     (FOCUSDLG_RETURN_DATA *) event.QueryLParam();
            UIASSERT( pData != NULL );

            _olb.FillAllInfo( pData->pEnumDomains,
                              pData->pEnumServers,
                              pData->pszSelection );

            _olb.Enable( TRUE );
            _sltLBTitle.Enable( TRUE );
            _sleGetInfo.Show( FALSE );
            _olb.Show( TRUE );

            delete pData->pEnumDomains;
            pData->pEnumDomains = NULL;
            delete pData->pEnumServers;
            pData->pEnumServers = NULL;
        }

        return TRUE;
    }

    return DIALOG_WINDOW::OnUserMessage( event );
}

/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::OnCommand

    SYNOPSIS:   Handles WM_COMMAND messages.
                Currently it only processes selection change
                messages.  If the selection has changed then it
                calls OnDomainLBChange to update the listbox,
                otherwise it does nothing.

    HISTORY:
        kevinl      14-Jun-1991     Created
        KeithMo     06-Oct-1991     Now takes a CONTROL_EVENT.
        terryk      18-Nov-91       Change to BASE_SET_FOCUS_DLG

********************************************************************/

BOOL BASE_SET_FOCUS_DLG::OnCommand( const CONTROL_EVENT & event )
{
    switch ( event.QueryCid() )
    {
    case IDC_DOMAIN_LB:
        switch ( event.QueryCode() )
        {
        case LBN_SETFOCUS:
            {
                if (_sleFocusPath.QueryTextLength( ) != 0 )
		    break;
                // fall through
            }
        case LBN_SELCHANGE:
            {
                OnDomainLBChange();
                return TRUE;
            }

        case LBN_DBLCLK:
            {
                OLLB_ENTRY *pollbe = _olb.QueryItem();

                if( ( pollbe != NULL ) &&
                    ( ( pollbe->QueryLevel() == OLLBL_SERVER ) ||
                      ( ( pollbe->QueryLevel() == OLLBL_DOMAIN ) &&
                        ( _seltype == SEL_DOM_ONLY ) ) ) )
                {
                    return OnOK();
                }

                break;
            }

        default:                // switch HIWORD( lParam )
            break;

        }
        break;


    case IDC_FOCUS_PATH:
        switch ( event.QueryCode() )
        {
        case EN_CHANGE:
            UpdateRasMode();
            break;

        default:                // switch HIWORD( lParam )
            break;

        }
        break;

    default:                    // switch cid
        break;

    }

    return DIALOG_WINDOW::OnCommand( event );
}


/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::OnOK

    SYNOPSIS:   Validates current selection

    EXIT:       If the current selection was a well formed
                domain or server name then the dialog was
                dismissed and the selection returned.

    HISTORY:
        kevinl      14-Jun-1991     Created
        terryk      18-Nov-91       Change to BASE_SET_FOCUS_DLG
                                    Add SetNetworkFocus function call

********************************************************************/

BOOL BASE_SET_FOCUS_DLG::OnOK()
{
#ifdef TRACE
    const TCHAR * apszSettings[] = { SZ("SLOW"), SZ("FAST"), SZ("UNKNOWN") };
#endif

    AUTO_CURSOR autocur;

    NLS_STR nls;
    APIERR err = nls.QueryError();
    if ( err != NERR_Success )
    {
        ::MsgPopup( this, (MSGID)err );
        return TRUE;        // message was handled
    }

    MSGID msgid ;
    err = ProcessNetPath( &nls, &msgid );
    if ( err == NERR_Success )
    {
        FOCUS_CACHE_SETTING setting;
        if ( InRasMode() )
        {
            TRACEEOL( "BASE_SET_FOCUS_DLG::OnOK(): slowmode checkbox checked" );
            setting = FOCUS_CACHE_SLOW;
        }
        else
        {
            setting = ReadFocusCache( nls.QueryPch() );
            TRACEEOL( "BASE_SET_FOCUS_DLG: cache setting is " <<
                  apszSettings[setting] );

            if (setting == FOCUS_CACHE_SLOW)
            {
                TRACEEOL( "BASE_SET_FOCUS_DLG::OnOK(): slowmode checkbox explicitly unchecked" );
                setting = FOCUS_CACHE_FAST;
            }
        }

        TRACEEOL( "BASE_SET_FOCUS_DLG: calling SetNetworkFocus( \"" << nls
                  << "\", " << apszSettings[setting] << " )" );

        err = SetNetworkFocus( QueryHwnd(), nls.QueryPch(), setting );
    }

    switch(err)
    {
        case NERR_Success:
            Dismiss( TRUE );
            return TRUE;

        case IERR_DONT_DISMISS_FOCUS_DLG: // error is already handled, don't
                                          // popup the error again
            SelectNetPathString();
            return TRUE;

        case ERROR_INVALID_NAME:
        case ERROR_INVALID_PARAMETER:
            ::MsgPopup(this,(MSGID)((msgid==0)?ERROR_INVALID_PARAMETER:msgid));
            SelectNetPathString();
            break ;

        default:
            ::MsgPopup( this, (MSGID)err );
            SelectNetPathString();
            break ;

    }

    return TRUE;    // message was handled
}

/*******************************************************************

    NAME:           BASE_SET_FOCUS_DLG::SetNetworkFocus

    SYNOPSIS:

    EXIT:

    HISTORY:
        jonn        06-Aug-1992     De-inline'd

********************************************************************/

APIERR BASE_SET_FOCUS_DLG::SetNetworkFocus( HWND hwndOwner,
                                            const TCHAR * pszNetworkFocus,
                                            FOCUS_CACHE_SETTING setting )
{
    UNREFERENCED(hwndOwner);
    UNREFERENCED(pszNetworkFocus);
    UNREFERENCED(setting);
    return NERR_Success;
}


/*******************************************************************

    NAME:           BASE_SET_FOCUS_DLG::QueryHelpContext

    SYNOPSIS:       Returns the help context.

    EXIT:           returns 0

    HISTORY:
        kevinl      14-Jun-1991     Created
        terryk      18-Nov-91       Change to BASE_SET_FOCUS_DLG

********************************************************************/

ULONG BASE_SET_FOCUS_DLG::QueryHelpContext()
{
    return (QuerySuppliedHelpContext()) ;
}

/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::QueryHelpFile

    SYNOPSIS:   overwrites the default QueryHelpFile in DIALOG_WINDOW
                to use an app supplied help (rather than the one
                DIALOG_WINDOW will calculate for us) if we were given
                one at construct time.

    ENTRY:

    EXIT:

    RETURNS:    a pointer to a string which is the help file to use.

    NOTES:

    HISTORY:
        ChuckC   26-Cct-1992     Created

********************************************************************/
const TCHAR * BASE_SET_FOCUS_DLG::QueryHelpFile( ULONG nHelpContext )
{
    //
    // if we were given a helpfile & context at construct time and
    // the context requested matches that, we use the given help file.
    //
    const TCHAR *pszHelpFile = QuerySuppliedHelpFile() ;

    if (pszHelpFile && *pszHelpFile)
    {
        return pszHelpFile ;
    }
    return DIALOG_WINDOW::QueryHelpFile(nHelpContext) ;
}


/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::ReadFocusCache

    SYNOPSIS:   Whenever the contents of the focus edit field change,
                and the dialog is expanded via ShowArea(), the contents
                of the RasMode checkbox will be changed according to
                the focus cache.  Subclasses should redefine this method
                if they support the RasMode checkbox and focus cache.

    HISTORY:
        JonN    24-Mar-1993     Created

********************************************************************/
FOCUS_CACHE_SETTING BASE_SET_FOCUS_DLG::ReadFocusCache( const TCHAR * pszFocus ) const
{
    UNREFERENCED( pszFocus );

    return FOCUS_CACHE_UNKNOWN;
}


/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::UpdateRasMode

    SYNOPSIS:   Whenever the contents of the focus edit field change,
                and the dialog is expanded via ShowArea(), the contents
                of the RasMode checkbox will be changed according to
                the focus cache.

    HISTORY:
        JonN    24-Mar-1993     Created

********************************************************************/
VOID BASE_SET_FOCUS_DLG::UpdateRasMode()
{
    if ( IsExpanded() )
    {
        TCHAR pszFocus[ MAX_PATH+1 ];

        APIERR err = _sleFocusPath.QueryText( pszFocus, sizeof(pszFocus) );
        if (err != NERR_Success)
        {
            DBGEOL( "BASE_SET_FOCUS_DLG::UpdateRasMode(): failure " << err );
        }
        else
        {
            FOCUS_CACHE_SETTING setting = ReadFocusCache( pszFocus );
            switch ( setting )
            {
            case FOCUS_CACHE_SLOW:
            case FOCUS_CACHE_FAST:
                if (pszFocus[0] == (TCHAR)(TCH('\0')))
                {
                    _chkboxRasMode.SetCheck( FALSE );
                    _sltRasModeMessage.ClearText();
                }
                else
                {
                    BOOL fIsServer = (pszFocus[0] == (TCHAR)(TCH('\\')));
                    BOOL fIsSlow = (setting == FOCUS_CACHE_SLOW);
                    const TCHAR * pchRasMessage =
                        (fIsServer)
                          ? ( (fIsSlow)
                                ? _resstrRasServerSlow.QueryPch()
                                : _resstrRasServerFast.QueryPch() )
                          : ( (fIsSlow)
                                ? _resstrRasDomainSlow.QueryPch()
                                : _resstrRasDomainFast.QueryPch() );
                    NLS_STR nlsRasMessage( pchRasMessage );
                    ALIAS_STR nlsFocus( pszFocus );
                    if (   (err = nlsRasMessage.QueryError()) != NERR_Success
                        || (err = nlsRasMessage.InsertParams( nlsFocus ))
                                        != NERR_Success
                       )
                    {
                        DBGEOL( "BASE_SET_FOCUS_DLG::UpdateRasMode(): RasMessage failure " << err );
                        _sltRasModeMessage.ClearText();
                    }
                    else
                    {
                        _sltRasModeMessage.SetText( nlsRasMessage );
                    }

                    _chkboxRasMode.SetCheck( fIsSlow );
                }
                break;
            default:
                DBGEOL( "BASE_SET_FOCUS_DLG::UpdateRasMode(): invalid cache" );
                // fall through
            case FOCUS_CACHE_UNKNOWN:
                _chkboxRasMode.SetCheck( FALSE );
                _sltRasModeMessage.ClearText();
                break;
            }
        }
    }
}


/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::ShowArea()

    SYNOPSIS:   Grows or shrinks the dialog based upon the BOOL
                parameter and the location of the boundary control.

    ENTRY:      BOOL fFull              if TRUE, expand the dialog;
                                        otherwise, show default size.

    EXIT:       nothing

    RETURNS:    nothing

    NOTES:      Calls virtual OnExpand() member when it is about to
                exposed the previously hidden controls.

    HISTORY:

********************************************************************/

#define EXP_MIN_USE_BOUNDARY 5

VOID BASE_SET_FOCUS_DLG::ShowArea( BOOL fFull )
{
    //  If this is the first call, save the size of the dialog

    if ( _xyOriginal.QueryHeight() <= 0 )
    {
        _xyOriginal = QuerySize() ;

        //  Hide and disable the boundary control
        _sltBoundary.Show( FALSE ) ;
        _sltBoundary.Enable( FALSE ) ;
    }

    //  Iterate over child controls; dis/enable child controls in
    //  the expanded region to preserve tab ordering, etc.

    ITER_CTRL itCtrl( this ) ;
    CONTROL_WINDOW * pcw ;
    XYPOINT xyBoundary( _sltBoundary.QueryPos() ) ;

    for ( ; pcw = itCtrl() ; )
    {
        if ( pcw != & _sltBoundary )
        {
            XYPOINT xyControl( pcw->QueryPos() ) ;
            if (   xyControl.QueryX() >= xyBoundary.QueryX()
                || xyControl.QueryY() >= xyBoundary.QueryY() )
            {
                pcw->Enable( fFull ) ;
            }
        }
    }

    if ( ! fFull )  // Initial display; show only the default area
    {
        XYPOINT xyBoundary = _sltBoundary.QueryPos() ;
        XYDIMENSION dimBoundary = _sltBoundary.QuerySize();
        XYRECT rWindow ;

        //  Compute location of the lower right-hand edge of the boundary
        //  control relative to the full (i.e., not client) window.

        xyBoundary.SetX( xyBoundary.QueryX() + dimBoundary.QueryWidth() ) ;
        xyBoundary.SetY( xyBoundary.QueryY() + dimBoundary.QueryHeight() ) ;
        xyBoundary.ClientToScreen( QueryHwnd() ) ;
        QueryWindowRect( & rWindow ) ;
        if (GetWindowLongPtr(QueryHwnd(), GWL_EXSTYLE) & WS_EX_LAYOUTRTL) {
            xyBoundary.SetX( rWindow.QueryRight() - xyBoundary.QueryX() ) ;
        } else {
            xyBoundary.SetX( xyBoundary.QueryX() - rWindow.QueryLeft() ) ;
        }
        xyBoundary.SetY( xyBoundary.QueryY() - rWindow.QueryTop() ) ;

        //  Check if the boundary control is "close" to the edge of the
        //  dialog in either dimension.  If so, use the original value.

        if ( _xyOriginal.QueryHeight() - xyBoundary.QueryY() <= EXP_MIN_USE_BOUNDARY )
            xyBoundary.SetY( _xyOriginal.QueryHeight() ) ;

        if ( _xyOriginal.QueryWidth() - xyBoundary.QueryX() <= EXP_MIN_USE_BOUNDARY )
            xyBoundary.SetX( _xyOriginal.QueryWidth() ) ;

        //  Change the dialog size.
        SetSize( xyBoundary.QueryX(), xyBoundary.QueryY(), TRUE ) ;
    }
    else            //  Full display; expand the dialog to original size
    {
        //  Set size to original full extent
        SetSize( _xyOriginal.QueryWidth(), _xyOriginal.QueryHeight(), TRUE ) ;
    }
}


/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::IsExpanded()

    SYNOPSIS:   Determines whether the dialog is expanded to full size.

    RETURNS:    TRUE iff the dialog is expanded

    HISTORY:

********************************************************************/
BOOL BASE_SET_FOCUS_DLG::IsExpanded() const
{
    return (   QuerySize().QueryHeight() == _xyOriginal.QueryHeight()
            && QuerySize().QueryWidth()  == _xyOriginal.QueryWidth()  );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\focthred.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1993                   **/
/**********************************************************************/

/*
    focthred.cxx
       Second thread for select computer dialog


    FILE HISTORY:
        YiHsinS		4-Mar-1993	Created

*/

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:       FOCUSDLG_DATA_THREAD::FOCUSDLG_DATA_THREAD

    SYNOPSIS:   Constructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS		4-Mar-1993	Created

********************************************************************/

FOCUSDLG_DATA_THREAD::FOCUSDLG_DATA_THREAD( HWND hwndDlg,
                                            ULONG maskDomainSources,
                                            SELECTION_TYPE seltype,
                                            const TCHAR *pszSelection,
                                            ULONG nServerTypes )
    : WIN32_THREAD( TRUE, 0, SZ("NETUI2") ),
      _hwndDlg( hwndDlg ),
      _maskDomainSources( maskDomainSources ),
      _seltype( seltype ),
      _nlsSelection( pszSelection ),
      _nServerTypes( nServerTypes ),
      _eventExitThread( NULL, FALSE ),
      _fThreadIsTerminating( FALSE )
{
    if ( QueryError() )
        return;

    APIERR err = NERR_Success;
    if (  ((err = _eventExitThread.QueryError()) != NERR_Success )
       || ((err = _nlsSelection.QueryError()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }
}

/*******************************************************************

    NAME:       FOCUSDLG_DATA_THREAD::~FOCUSDLG_DATA_THREAD

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS		4-Mar-1993	Created

********************************************************************/

FOCUSDLG_DATA_THREAD::~FOCUSDLG_DATA_THREAD()
{
}

/*******************************************************************

    NAME:       FOCUSDLG_DATA_THREAD::Main()

    SYNOPSIS:   Get the information needed to fill in the listbox
                with the requested data (domains, servers..)

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS		4-Mar-1993	Created

********************************************************************/

APIERR FOCUSDLG_DATA_THREAD::Main( VOID )
{
    APIERR err = NERR_Success;
    FOCUSDLG_RETURN_DATA data;

    data.pEnumDomains = NULL;
    data.pEnumServers = NULL;
    data.pszSelection = NULL;

    BROWSE_DOMAIN_ENUM *pEnumDomains = data.pEnumDomains =
                       new BROWSE_DOMAIN_ENUM( _maskDomainSources );

    if ( pEnumDomains == NULL )
        err = ERROR_NOT_ENOUGH_MEMORY;

    if (  ( err == NERR_Success )
       && ((err = pEnumDomains->QueryError()) == NERR_Success )
       && ( !_fThreadIsTerminating )
       )
    {
        //
        // Get the default selection
        //
        if (  ( pEnumDomains->QueryDomainCount() > 0 )
           && ( !_fThreadIsTerminating )
           )
        {
            BOOL fFound = FALSE;
            const BROWSE_DOMAIN_INFO *pbdi;

            if (  ( _nlsSelection.QueryTextLength() != 0 )
               && ( !_fThreadIsTerminating )
               )
            {
                while ( (pbdi = pEnumDomains->Next()) != NULL )
                {
                    if ( ::stricmpf( pbdi->QueryDomainName(),
                                     _nlsSelection) == 0 )
                    {
                        fFound = TRUE;
                        if ( _fThreadIsTerminating )
                            break;
                    }
                }
                pEnumDomains->Reset();
            }

            if (  !fFound
               && ( !_fThreadIsTerminating )
               )
            {
                if ( _seltype == SEL_SRV_ONLY )
                    pbdi = pEnumDomains->FindFirst( BROWSE_WKSTA_DOMAIN );
                else
                    pbdi = pEnumDomains->FindFirst( BROWSE_LOGON_DOMAIN );

                if ( pbdi == NULL )
                {
                    pEnumDomains->Reset();
                    pbdi = pEnumDomains->Next();

                    // Since QueryDomainCount is greater than 0,
                    // there should be at least one pbdi.
                    UIASSERT( pbdi != NULL );
                }

                pEnumDomains->Reset();

                err = _nlsSelection.CopyFrom( pbdi->QueryDomainName());
            }

            data.pszSelection = _nlsSelection.QueryPch();

            //
            // Get the servers in the default selection if we need to.
            // If any error occurred, just ignore them since we already
            // have all the domain names.
            //
            if  (  !_fThreadIsTerminating
                && (  ( _seltype == SEL_SRV_ONLY )
                   || ( _seltype == SEL_SRV_EXPAND_LOGON_DOMAIN ))
                )
            {

                SERVER1_ENUM *pSrvEnum = new SERVER1_ENUM( NULL,
            						   _nlsSelection,
                                                           _nServerTypes );

                if ( pSrvEnum != NULL )
                {
                    if ( pSrvEnum->GetInfo() == NERR_Success)  // ignore errors
                    {
                        data.pEnumServers = pSrvEnum;
                    }
                    else
                    {
                        delete pSrvEnum;
                        pSrvEnum = NULL;
                    }
                }
            }
        }
    }

    if ( !_fThreadIsTerminating )
    {
        if ( err == NERR_Success )
        {
            ::SendMessage( _hwndDlg,
                           WM_FOCUS_LB_FILLED,
                           (WPARAM) FALSE,    // No error!
                           (LPARAM) &data );
        }
        else
        {
            ::SendMessage( _hwndDlg,
                           WM_FOCUS_LB_FILLED,
                           (WPARAM) TRUE,     // Error occurred!
                           (LPARAM) err );
        }
    }

    // The following cache will have already been freed if the
    // dialog got the SendMessage above.
    if ( data.pEnumDomains != NULL )
    {
        delete data.pEnumDomains;
        data.pEnumDomains = NULL;
    }

    if ( data.pEnumServers != NULL )
    {
        delete data.pEnumServers;
        data.pEnumServers = NULL;
    }

    switch ( ::WaitForSingleObject( _eventExitThread.QueryHandle(), INFINITE ))
    {
        // Time to exit the thread
        case WAIT_OBJECT_0:
            break;

        // These two should not have happened, not a mutex and wait infinite
        case WAIT_ABANDONED:
        case WAIT_TIMEOUT:
            UIASSERT( FALSE );
            break;

        default:
            err = ::GetLastError();
            break;
    }

    return err;

}  // FOCUSDLG_DATA_THREAD::Main

/*******************************************************************

    NAME:       FOCUSDLG_DATA_THREAD::PostMain()

    SYNOPSIS:   Clean up

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS		4-Mar-1993	Created

********************************************************************/

APIERR FOCUSDLG_DATA_THREAD::PostMain( VOID )
{
    TRACEEOL("FOCUSDLG_DATA_THREAD::PostMain - Deleting \"this\" for thread "
             << HEX_STR( (ULONG) QueryHandle() )) ;

    DeleteAndExit( NERR_Success ) ; // This method should never return

    UIASSERT( FALSE );

    return NERR_Success;

}  // FOCUSDLG_DATA_THREAD::PostMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\getfname.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    getfname.cxx

    Source file for the get filename classes.
    The class structure is the following:
                                BASE
                                  |
                            GET_FNAME_BASE_DLG
                            /              \
                GET_OPEN_FILENAME_DLG  GET_SAVE_FILENAME_DLG

    Since COMMDLG doesn't grok Unicode, this class must map between
    CHAR* and TCHAR* as appropriate.

    FILE HISTORY:
        terryk  09-Dec-1992     Created
        terryk  15-Jan-1992     Code review changed
        beng    30-Mar-1992     Added CHAR-TCHAR mapping
        YiHsinS 19-Jun-1992     Added CommDlgHookProc
        chuckc  08-Aug-1992     Remove CHAR-TCHAR mapping (commdlg now unicode)
        YiHsinS 14-Aug-1992     Fixed unicode problem
*/

#include "pchapplb.hxx"   // Precompiled header

extern "C"
{
   // forward declaration
   // BOOL CommDlgHookProc( HWND hDlg, WORD wMsg, WPARAM wParam, LPARAM lParam);

}

/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::GET_FNAME_BASE_DLG

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW *pow - parent window

    HISTORY:
        terryk      09-Dec-1991 Created
        beng        30-Mar-1992 CHAR/TCHAR mapping
        beng        31-Jul-1992 Hacked out pszTemplate arg
        chuckc      08-Aug-1992 Remove CHAR-TCHAR mapping (commdlg now unicode)

********************************************************************/

GET_FNAME_BASE_DLG::GET_FNAME_BASE_DLG( OWNER_WINDOW *pow,
     					const TCHAR *pszHelpFile,
       					ULONG ulHelpContext )
    : BASE(),
    _hComdlg32Dll (NULL),
    _pfGetOpenFileName (NULL),
    _pfGetSaveFileName (NULL),
    _pfExtendedError (NULL),
    _bufFilename( (UINT) PATHLEN * sizeof(TCHAR) ),
    _bufFilenameTitle( (UINT)PATHLEN * sizeof(TCHAR) ),
    _bufFilter(0),
    _bufCustomFilter(0),
    _fInitOfn(FALSE),
    _nlsHelpFile( pszHelpFile ),
    _ulHelpContext( ulHelpContext ),
    _fHelpActive( FALSE )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }


    APIERR err;
    if ((( err = _bufFilename.QueryError()) != NERR_Success ) ||
        (( err = _bufFilenameTitle.QueryError()) != NERR_Success ) ||
        (( err = _bufFilter.QueryError()) != NERR_Success ) ||
        (( err = _bufCustomFilter.QueryError()) != NERR_Success ) ||
        (( err = _nlsHelpFile.QueryError()) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    if (((_hComdlg32Dll = LoadLibrary (COMDLG32_DLL_NAME)) == NULL) ||
        ((_pfGetOpenFileName = (PF_GetOpenFileName) GetProcAddress (
                                _hComdlg32Dll,
                                GETOPENFILENAME_NAME)) == NULL) ||
        ((_pfGetSaveFileName = (PF_GetSaveFileName) GetProcAddress (
                                _hComdlg32Dll,
                                GETSAVEFILENAME_NAME)) == NULL) ||
        ((_pfExtendedError =    (PF_ExtendedError) GetProcAddress (
                                _hComdlg32Dll,
                                EXTENDEDERROR_NAME)) == NULL))
    {
        ReportError (GetLastError());
        return;
    }

    UIASSERT( pow != NULL );
    _szFileExt[0] = TCH('\0');   // Initialize to empty string

    // initialize the internal variable
    InitialOFN();

    _ofn.hwndOwner = pow->QueryHwnd();
    _ofn.lCustData = (LPARAM) this;

#if 0 // hacked out - sorry
    _ofn.hInstance = ::QueryInst();
    if ( pszTemplateName != NULL )
    {
        err = SetStringField(&_ofn.lpTemplateName, ALIAS_STR(pszTemplateName));
        if (err != NERR_Success)
        {
            ReportError(err);
            return;
        }
        SetEnableTemplate();
    }
#endif

}


GET_FNAME_BASE_DLG::~GET_FNAME_BASE_DLG()
{
    FreeLibrary (_hComdlg32Dll);

    if (_fInitOfn) // set in InitialOfn
    {
        delete[] ((void *)_ofn.lpstrTitle);
        delete[] ((void *)_ofn.lpstrInitialDir);

#if 0 // more hack
        delete[] _ofn.lpTemplateName;
#endif

    }

    if ( IsHelpActive() )
    {
        ::WinHelp( _ofn.hwndOwner,
                   (TCHAR *) (QueryHelpFile()->QueryPch()),
                   (UINT) HELP_QUIT,
                   0L );
    }


}


/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::InitialOFN

    SYNOPSIS:   Clear up the OPENFILENAME data structure.

    HISTORY:
                terryk  09-Dec-1991     Created

********************************************************************/

VOID GET_FNAME_BASE_DLG::InitialOFN()
{
    // initialize the OPENFILENAME data structure

    _ofn.lStructSize = sizeof( OPENFILENAME );
    _ofn.hwndOwner = NULL;
    _ofn.hInstance = NULL;
    _ofn.lpstrFilter = NULL;
    _ofn.lpstrCustomFilter = NULL;
    _ofn.nMaxCustFilter = 0;
    _ofn.nFilterIndex = 0;
    _ofn.lpstrFile = (TCHAR *)_bufFilename.QueryPtr();
    _ofn.lpstrFile[0]=TCH('\0');       // Initial the first character to NULL
    _ofn.nMaxFile = _bufFilename.QuerySize() / sizeof(TCHAR) ;
    _ofn.lpstrFileTitle = (TCHAR *)_bufFilenameTitle.QueryPtr();
    _ofn.lpstrFileTitle[0]=TCH('\0');  // Initial the first character to NULL
    _ofn.nMaxFileTitle = _bufFilenameTitle.QuerySize() / sizeof(TCHAR) ;
    _ofn.lpstrInitialDir = NULL;
    _ofn.lpstrTitle = NULL;
    _ofn.Flags = 0;
    _ofn.nFileOffset = 0;
    _ofn.nFileExtension = 0;
    _ofn.lpstrDefExt = NULL;
    _ofn.lCustData = 0;
    _ofn.lpfnHook = NULL;
    _ofn.lpTemplateName = NULL;

    // SetHookProc( (MFARPROC) ::CommDlgHookProc, (DWORD) this );

    // All clear
    _fInitOfn = TRUE;
}

VOID GET_FNAME_BASE_DLG::OnHelp( HWND hwnd )
{

    NLS_STR *pnlsHelpFile = QueryHelpFile();
    if( pnlsHelpFile->QueryTextLength() != 0 )
    {

#if defined(DEBUG)
        HEX_STR nlsHelpContext( QueryHelpContext() );
        if( pnlsHelpFile != NULL )
        {
            DBGEOL( SZ("Help called on file ") << *pnlsHelpFile << \
                    SZ(", context ") << nlsHelpContext );
        }
        else
        {
            DBGEOL(SZ("Help called on unknown context ") << nlsHelpContext);
        }
#endif

        if( !::WinHelp( _ofn.hwndOwner,
                        (TCHAR *) pnlsHelpFile->QueryPch(),
                        (UINT) HELP_CONTEXT,
                        (DWORD) QueryHelpContext()))
        {
            ::MsgPopup( hwnd,
                        IDS_BLT_WinHelpError,
                        MPSEV_ERROR,
                        MP_OK );
        }
        else
        {
            SetHelpActive( TRUE );
        }

    }

}

/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::QueryErrorCode()

    SYNOPSIS:

    HISTORY:
                CongpaY  11-Dec-1992     Created

********************************************************************/
APIERR GET_FNAME_BASE_DLG :: QueryErrorCode () const
{
    return pfExtendedError () ();
}

/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::SetFilter

    SYNOPSIS:   Set the define filter to the given strings

    ENTRY:      STRLIST & strlist - the list of filter strings. These
                    must be even number of strings in the string list. The
                    format must be something like:
                        "Write Files(*.TXT)",   "*.txt",
                        "Word Files(*.DOC;*.TXT)", "*.doc;*.txt"
                nFilterIndex - specified an index into the buffer
                    pointed by the lpstrFilter member. The system uses
                    the index value to obtain a pair of strings to use
                    as the initial filter description and filter pattern
                    for the dialog box. The first pair of strings has an
                    index value of 1. When the user dismisses the dialog
                    box, the system copies the index of the selected
                    filter strings into this location. If the number is
                    0, the custom filter will be used. If the number is
                    0 and the custom filter is NULL, the system will use
                    the first filter in the defined Filter ( this one ).
                    The number is the index of pair, i.e., 1 for the
                    first pair and 2 for the second pair.

    RETURNS:    APIERR - NERR_Success for succeed. Otherwise, it will
                    return the error code.

    HISTORY:
                terryk  09-Dec-1991     Created

********************************************************************/

APIERR GET_FNAME_BASE_DLG::SetFilter( STRLIST & slFilter,
                                      DWORD nFilterIndex )
{
    APIERR err = SetBuffer( &_bufFilter, slFilter );
    if ( err != NERR_Success )
    {
        return err;
    }

    _ofn.lpstrFilter = (TCHAR *)_bufFilter.QueryPtr();
    _ofn.nFilterIndex = nFilterIndex;

    // Initialize the file extension to the first file ext. in the filter
    TCHAR *pszFilter = (TCHAR *) _ofn.lpstrFilter;
    pszFilter += ::strlenf( pszFilter ) + 3;  // 3 : one for NULL char,
                                              //     and the other two for
                                              //     getting past "*."

    _ofn.lpstrDefExt = _szFileExt;
    ::strcpyf( (TCHAR *)_ofn.lpstrDefExt, pszFilter );

    return NERR_Success;
}


/*******************************************************************

    NAME:       GET_FILE_DLG::SetCustomFilter

    SYNOPSIS:   Set the define filter to the given strings

    ENTRY:      STRLIST & strlist - the list of filter strings. These
                    must be even number of strings in the string list. The
                    format must be something like:
                        "Write Files(*.TXT)",   "*.txt",
                        "Word Files(*.DOC;*.TXT)", "*.doc;*.txt"
                nFilterIndex - specifise an index into the buffer
                    pointed by the lpstrFilter member. The system uses
                    the index value to obtain a pair of strings to use
                    as the initial filter description and filter pattern
                    for the dialog box. The first pair of strings has an
                    index value of 1. When the user dismisses the dialog
                    box, the system copies the index of the selected
                    filter strings into this location. If the number is
                    0, the custom filter (this filter) will be used. If
                    the number is 0 and the custom filter is NULL, the
                    system will use the first filter in the defined Filter.

    RETURNS:    APIERR - NERR_Success for succeed. Otherwise, it will
                    return the error code.

    HISTORY:
                terryk  09-Dec-1991     Created

********************************************************************/

APIERR GET_FNAME_BASE_DLG::SetCustomFilter( STRLIST & slFilter,
                                            DWORD nFilterIndex)
{
    APIERR err = SetBuffer( &_bufCustomFilter, slFilter );
    if ( err != NERR_Success )
    {
        return err;
    }

    _ofn.lpstrCustomFilter = (TCHAR *)_bufCustomFilter.QueryPtr();
    _ofn.nFilterIndex = nFilterIndex;
    _ofn.nMaxCustFilter = _bufCustomFilter.QuerySize();

    return NERR_Success;
}


/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::SetBuffer

    SYNOPSIS:   Put the string list's strings into the buffer

    ENTRY:      BUFFER *pBuf - the buffer which receives the strings
                STRLIST & slFilter - the string list

    EXIT:       BUFFER *pBuf - it will fill with strings.  In a Unicode
                environment, these will be MBCS strings, for the
                non-Unicode COMMDLG.

    RETURNS:    APIERR - In case of not enough memory to resize the
                buffer.

    NOTES:      It will add an empty string at the end of the buffer.

    HISTORY:
                terryk  09-Dec-1991     Created
                beng    30-Mar-1992     CHAR/TCHAR mapping
                chuckc  08-Aug-1992     Remove CHAR-TCHAR mapping
					(commdlg now unicode)

********************************************************************/

APIERR GET_FNAME_BASE_DLG::SetBuffer( BUFFER *pBuf, STRLIST & slFilter )
{
    ITER_STRLIST iter( slFilter );
    APIERR err;
    NLS_STR *pnlsTemp;
    UINT cchBuffer = 0;
    UINT cnlsTotal = 0;

    // find total buffer size and number of strings
    while (( pnlsTemp = iter.Next() ) != NULL )
    {
        cchBuffer += pnlsTemp->QueryTextLength() + 1;
        cnlsTotal ++;
    }

    // we must have even number of string in the list
    if (( cnlsTotal % 2 ) != 0 )
    {
        UIASSERT( FALSE );
        return ERROR_INVALID_PARAMETER;
    }

    // Resize the buffer to fit all the strings plus 1 empty string
    if (( err = pBuf->Resize( (cchBuffer + 1) * sizeof( TCHAR ) ))
	!= NERR_Success )
    {
        // not enough memory...
        return err;
    }

    iter.Reset();
    TCHAR *pch = (TCHAR *)pBuf->QueryPtr();
    UINT cchRemaining = cchBuffer;
    while (( pnlsTemp = iter.Next() ) != NULL )
    {
        // put the strings into the buffer
        err = pnlsTemp->CopyTo( pch, cchRemaining * sizeof(TCHAR) );

        if ( err != NERR_Success )
            return err;

        pch += pnlsTemp->QueryTextLength() + 1;
        cchRemaining -= pnlsTemp->QueryTextLength() + 1;
    }
    // the last string must be NULL
    ASSERT(cchRemaining == 0);
    *pch = TCH('\0');

    return NERR_Success;
}


/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::SetHookProc

    SYNOPSIS:   Set the dialog call back hook function

    ENTRY:      MFARPROC lpfnHook - points to a hook function that
                    processes message intended for the dialog box. The
                    hook function should return FALSE to pass a message
                    on to the standard dialog procedure, or TRUE to
                    discard the message.
    NOTE:
                lCustData - specifics application-defined data that the
                system passes to the hook function. The system passes
                the data in the lParam parameter of the WM_INITDIALOG
                message. This is always set to "this" pointer.

    HISTORY:
                terryk  09-Dec-1991     Created

********************************************************************/

extern "C"
{
    typedef WORD (FAR PASCAL *FARHOOKPROC)(HWND, unsigned, WORD, LONG);
}

VOID GET_FNAME_BASE_DLG::SetHookProc( MFARPROC lpfnHook )
{
    SetEnableHook();

#ifdef WIN32
    _ofn.lpfnHook = (LPOFNHOOKPROC)lpfnHook;
#else
    _ofn.lpfnHook = (FARHOOKPROC)lpfnHook;
#endif

}


/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::SetInitialDir

    SYNOPSIS:   Set the initial directory to the given string.

    ENTRY:      const NLS_STR &nlsDir - the initial directory path

    RETURNS:    APIERR - in case of error while copying

    HISTORY:
                terryk  07-Jan-1992     Created
                beng    30-Mar-1992     CHAR/TCHAR mapping
                chuckc  08-Aug-1992     Remove CHAR-TCHAR mapping
					(commdlg now unicode)

********************************************************************/

APIERR GET_FNAME_BASE_DLG::SetInitialDir( const NLS_STR &nlsDir )
{
    return SetStringField((TCHAR **)&_ofn.lpstrInitialDir, nlsDir);
}


/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::SetText

    SYNOPSIS:   Set the dialog window title to the given string

    ENTRY:      const NLS_STR &nlsText - the window title

    RETURNS:    APIERR - in case of error while copying

    HISTORY:
                terryk  07-Jan-1992     Created
                beng    30-Mar-1992     CHAR/TCHAR mapping
                chuckc  08-Aug-1992     Remove CHAR-TCHAR mapping
					(commdlg now unicode)

********************************************************************/

APIERR GET_FNAME_BASE_DLG::SetText( const NLS_STR &nlsText )
{
    return SetStringField((TCHAR **)&_ofn.lpstrTitle, nlsText);
}


/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::SetFileExtension

    SYNOPSIS:   set the default extension string

    ENTRY:      const NLS_STR & nlsExt - default extension string

    RETURNS:    APIERR - return Copy string error.

    HISTORY:
                terryk  07-Jan-1992     Created
                beng    30-Mar-1992     CHAR/TCHAR mapping
                chuckc  08-Aug-1992     Remove CHAR-TCHAR mapping
					(commdlg now unicode)

********************************************************************/

APIERR GET_FNAME_BASE_DLG::SetFileExtension( const NLS_STR & nlsExt )
{
    _ofn.lpstrDefExt = _szFileExt;
    return nlsExt.CopyTo( (TCHAR *)_ofn.lpstrDefExt, nlsExt.QueryTextSize() );
}


/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::SetStringField

    SYNOPSIS:   Sets a string field within the OFN (common code)

    ENTRY:      ppszDest  - Pointer to destination field
                nlsArg    - Given value, as NLS_STR

    RETURNS:    APIERR - return Copy string error.

    HISTORY:
        beng    30-Mar-1992     Created

********************************************************************/

APIERR GET_FNAME_BASE_DLG::SetStringField( TCHAR ** ppszDest,
                                           const NLS_STR & nlsArg )
{
    // Delete old value before alloc'ing new value.  While this prevents
    // retaining the old val in case of err, it minimizes heap fragmentation.

    delete[] *ppszDest;
    *ppszDest = NULL;

    UINT cchNeeded = nlsArg.QueryTextLength() + 1;

    TCHAR *pszNew = new TCHAR[cchNeeded];
    if (pszNew == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    APIERR err = nlsArg.CopyTo(pszNew, cchNeeded*sizeof(TCHAR) );
    if (err != NERR_Success)
        return err;

    *ppszDest = pszNew;
    return NERR_Success;
}


/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::QueryFilename

    SYNOPSIS:   get the user's inputed filename from the dialog box

    ENTRY:      NLS_STR *pnlsFilename - pointer to the receive buffer

    EXIT:       NLS_STR *pnlsFilename - user inputed filename

    RETURNS:    APIERR - return the string assignment error

    NOTES:      Use after Process is called.

    HISTORY:
                terryk  12-Dec-1991     Created
                beng    30-Mar-1992     CHAR/TCHAR mapping
                chuckc  08-Aug-1992     Remove CHAR-TCHAR mapping
					(commdlg now unicode)

********************************************************************/

APIERR GET_FNAME_BASE_DLG::QueryFilename( NLS_STR *pnlsFilename ) const
{
    UIASSERT( pnlsFilename != NULL );

    return pnlsFilename->CopyFrom( _ofn.lpstrFile );
}

/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::QueryFileTitle

    SYNOPSIS:   get the user inputed file title from the dialog box

    ENTRY:      NLS_STR *pnlsTitle - pointer to the receive buffer

    EXIT:       NLS_STR *pnlsTitle - user inputed file title

    RETURNS:    APIERR - return the string assignment error

    NOTES:      Use after Process is called.

    HISTORY:
                terryk  12-Dec-1991     Created
                beng    30-Mar-1992     CHAR/TCHAR mapping
                chuckc  08-Aug-1992     Remove CHAR-TCHAR mapping
					(commdlg now unicode)

********************************************************************/

APIERR GET_FNAME_BASE_DLG::QueryFileTitle( NLS_STR *pnlsTitle ) const
{
    UIASSERT( pnlsTitle != NULL );

    return pnlsTitle->CopyFrom( _ofn.lpstrFileTitle );
}


/*******************************************************************

    NAME:       GET_OPEN_FILENAME_DLG::GET_OPEN_FILENAME_DLG

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW *pow - parent window
                const TCHAR * pszTemplateName - dialog template name

    HISTORY:
        terryk      09-Dec-1991 Created
        beng        31-Jul-1992 Hacked out template arg

********************************************************************/

GET_OPEN_FILENAME_DLG::GET_OPEN_FILENAME_DLG( OWNER_WINDOW *pow,
    					      const TCHAR *pszHelpFile,
					      ULONG ulHelpContext )
    : GET_FNAME_BASE_DLG( pow, pszHelpFile, ulHelpContext )
{
    if ( QueryError() != NERR_Success )
        return;
}


/*******************************************************************

    NAME:       GET_OPEN_FILENAME_DLG::Process

    SYNOPSIS:   call GetOpenFileName to get the filename.

    ENTRY:      BOOL *pfRetVal - optional BOOL. If the user hits CANCEL,
                it will return FALSE. Otherwise, it will return TRUE.

    EXIT:       BOOL *pfRetVal - exit condition

    RETURNS:    APIERR - return the dialog error code.

    HISTORY:
                terryk  09-Dec-1991     Created

********************************************************************/

APIERR GET_OPEN_FILENAME_DLG::Process( BOOL *pfRetVal )
{
    BOOL fRetVal = pfGetOpenFileName () ( QueryOFN() );
    if ( pfRetVal != NULL )
    {
        *pfRetVal = fRetVal;
    }
    return QueryErrorCode();
}


/*******************************************************************

    NAME:       GET_SAVE_FILENAME_DLG::GET_SAVE_FILENAME_DLG

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW *pow - parent window

    HISTORY:
        terryk      09-Dec-1991 Created
        beng        31-Jul-1992 Hacked out template arg

********************************************************************/

GET_SAVE_FILENAME_DLG::GET_SAVE_FILENAME_DLG( OWNER_WINDOW *pow,
    					      const TCHAR *pszHelpFile,
					      ULONG ulHelpContext )
    : GET_FNAME_BASE_DLG( pow, pszHelpFile, ulHelpContext )
{
    if ( QueryError() != NERR_Success )
        return;
}


/*******************************************************************

    NAME:       GET_SAVE_FILENAME_DLG::Process

    SYNOPSIS:   call GetSaveFileName to get the filename.

    ENTRY:      BOOL *pfRetVal - optional BOOL. If the user hits CANCEL,
                it will return FALSE. Otherwise, it will return TRUE.

    EXIT:       BOOL *pfRetVal - exit condition

    RETURNS:    APIERR - return the dialog error code.

    HISTORY:
                terryk  09-Dec-1991     Created

********************************************************************/

APIERR GET_SAVE_FILENAME_DLG::Process( BOOL *pfRetVal )
{
    BOOL fRetVal = pfGetSaveFileName () ( QueryOFN() );
    if ( pfRetVal != NULL )
    {
        *pfRetVal = fRetVal;
    }
    return QueryErrorCode();
}


/*******************************************************************

    NAME:       CommDlgHookProc

    SYNOPSIS:   Hook procedure into the common open file dialog
                and save file dialog. The main purpose of this
                hook procedure is to change the default file
                extension if the user changes selection.

    ENTRY:

    EXIT:

    RETURNS:    Returns TRUE is you want the commdlg to ignore this
                message. FALSE if you want it to handle this message.

    HISTORY:
                Yi-HsinS  19-Jun-1992     Created

********************************************************************/

static LPOPENFILENAME __plpOFN = NULL;

BOOL CommDlgHookProc( HWND hDlg, WORD wMsg, WPARAM wParam, LPARAM lParam )
{

    UNREFERENCED( hDlg );

    if ( wMsg == WM_INITDIALOG )
    {
        __plpOFN = (LPOPENFILENAME) lParam;
        return TRUE;
    }

    CONTROL_EVENT e( wMsg, wParam, lParam );

    if ( e.QueryCid() == cmb1     // COMBO box of type
       && e.QueryMessage() == WM_COMMAND
       && e.QueryCode() == CBN_SELCHANGE
       )
    {
        INT iSel = (INT) ::SendMessage( (HWND) lParam, CB_GETCURSEL, 0, 0L );

        UIASSERT( __plpOFN != NULL );

        TCHAR *pszFilter = (TCHAR *)__plpOFN->lpstrFilter;

        for ( INT i = 0; i < iSel; i++ )
        {
             pszFilter += ::strlenf( pszFilter ) + 1;
             pszFilter += ::strlenf( pszFilter ) + 1;
        }

        pszFilter += ::strlenf( pszFilter ) + 1;
        pszFilter += 2;        // Get past "*."

        if ( *pszFilter == TCH('*') )
            pszFilter++;

        ::strcpyf( (TCHAR *)__plpOFN->lpstrDefExt, pszFilter );
        return TRUE;

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\getuser.cxx ===
/**********************************************************************/
/**                         Microsoft Windows NT                     **/
/**               Copyright(c) Microsoft Corp., 1992                 **/
/**********************************************************************/

/*
    GetUser.cxx

    This file contains the implementation for the User Browser "C" api.

    FILE HISTORY:
    AndyHe & JohnL  11-Oct-1992 Created
    AndyHe          30-Oct-1992 Modified per code review changes

*/

#include "pchapplb.hxx"   // Precompiled header

extern "C"
{
    // must be included after usrbrows.hxx

    #include <getuser.h>
    #include "mnet.h"
}

APIERR QueryLoggedOnDomainInfo( NLS_STR * pnlsDC,
                NLS_STR * pnlsDomain );


//
//  Internal structure passed back to caller and used by all three calls
//
typedef struct tagUSBR {    // usbr
    BROWSER_SUBJECT_ITER    * piterUserSelection;
    NT_USER_BROWSER_DIALOG  * pdlgUserBrows ;
    NLS_STR                 * pnlsDomainName ;
    BROWSER_SUBJECT         * pBrowserSubject ;
    BOOL                      fExpandNames;
} USERBROW, *LPUSERBROW;

static BOOL fInit = FALSE ;

/*******************************************************************

    NAME:    OpenUserBrowser

    SYNOPSIS:    Allows the user to select from a list of users and passes
                a handle back to the caller to allow it to iterate through
                the selected users

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:

********************************************************************/

HUSERBROW    OpenUserBrowser( LPUSERBROWSER lpUserParms )
{
    APIERR err = NERR_Success ;

    if ( !fInit )
    {
        if (err = BLT::Init( NULL, 0, 0, 0, 0 ))
        {
            SetLastError( err ) ;
            return NULL ;
        }

        fInit = TRUE ;
    }
    AUTO_CURSOR niftycursor ;       // Put up an our glass

    // quick validation of parms passed in...

    if (lpUserParms == NULL)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return(NULL);
    }

    if ( lpUserParms->ulStructSize != sizeof( USERBROWSER ) )
    {
        SetLastError( ERROR_BAD_LENGTH );
        return(NULL);
    }

    // check for single select

    BOOL fSingle = (USRBROWS_SINGLE_SELECT & lpUserParms->Flags) ? TRUE : FALSE ;

    ULONG    ulFlags ;

    // check for valid flags...  is the Flags value only made up of valid flags?

    ulFlags = lpUserParms->Flags ;
    ulFlags &= (~USRBROWS_SHOW_ALL );
    ulFlags &= (~USRBROWS_INCL_ALL );
    ulFlags &= (~USRBROWS_EXPAND_USERS );
    ulFlags &= (~USRBROWS_DONT_SHOW_COMPUTER );
    ulFlags &= (~USRBROWS_SINGLE_SELECT  );

    if ( ulFlags )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return(NULL);
    }


    // Flags value is good but we've trashed it... reload

    ulFlags = lpUserParms->Flags ;

    lpUserParms->fUserCancelled = FALSE;

    LPCTSTR pszDCName = lpUserParms->pszInitialDomain ;
    DOMAIN_WITH_DC_CACHE domTarget( lpUserParms->pszInitialDomain, TRUE ) ;

    // if the initial domain passed in is not a server (no \\) then we
    // find a domain controller to be our server

    if ( lpUserParms->pszInitialDomain != NULL &&
         lpUserParms->pszInitialDomain[0] != TCH('\0') &&
         lpUserParms->pszInitialDomain[0] != TCH('\\') &&
         lpUserParms->pszInitialDomain[1] != TCH('\\')     )
    {
        if ( err = domTarget.GetInfo() )
        {
            SetLastError( err );
            return(NULL);
        }
        pszDCName = domTarget.QueryAnyDC() ;
    }

    //
    //  Create the dialog
    //

    NT_USER_BROWSER_DIALOG * pdlgUserBrows = new NT_USER_BROWSER_DIALOG(
             fSingle ? USRBROWS_SINGLE_DIALOG_NAME : USRBROWS_DIALOG_NAME,
             lpUserParms->hwndOwner,
             pszDCName,
             lpUserParms->ulHelpContext,
             ulFlags,
             lpUserParms->pszHelpFileName ) ;

    err = ERROR_NOT_ENOUGH_MEMORY ;
    if ( pdlgUserBrows == NULL || (err = pdlgUserBrows->QueryError()) )
    {
        delete pdlgUserBrows ;
        SetLastError( err );
        return(NULL);
    }

    //
    //  Set the title if it isn't NULL
    //

    if ( lpUserParms->pszTitle != NULL )
    {
        pdlgUserBrows->SetText( lpUserParms->pszTitle ) ;
    }

    //
    // bring up the dialog and make sure the user hits OK...
    //

    BOOL fUserPressedOK ;
    if ( (err = pdlgUserBrows->Process( &fUserPressedOK )) ||
         !fUserPressedOK )
    {
        delete pdlgUserBrows ;

        if ( err == NERR_Success ) {            // user hit cancel or close
            lpUserParms->fUserCancelled = TRUE;
        }
        SetLastError( err );
        return(NULL);
    }


    // allocate the iterator

    BROWSER_SUBJECT_ITER * piterUserSelection = new BROWSER_SUBJECT_ITER(
            pdlgUserBrows ) ;

    err = ERROR_NOT_ENOUGH_MEMORY ;
    if ( piterUserSelection == NULL || (err = piterUserSelection->QueryError()) )
    {
        delete pdlgUserBrows ;
        delete piterUserSelection ;

        SetLastError( err );
        return(NULL);
    }


    // store the name of the currently focused domain name
    // this will be used in the QueryQualifiedName call in the enum call

    NLS_STR * pnlsDomainName = new NLS_STR;

    err = ERROR_NOT_ENOUGH_MEMORY;

    if (pnlsDomainName == NULL ||
        (err = pnlsDomainName->QueryError()) ||
        (err = QueryLoggedOnDomainInfo( NULL, pnlsDomainName )) )
    {
        delete pdlgUserBrows ;
        delete pdlgUserBrows ;
        delete pnlsDomainName;

        SetLastError( err );
        return(NULL);
    }

    // allocate the block to pass back to the caller

    LPUSERBROW lpusbrInstance;

    lpusbrInstance = (LPUSERBROW) new USERBROW;

    if (lpusbrInstance == NULL) {
        delete piterUserSelection ;
        delete pdlgUserBrows ;
        delete pnlsDomainName ;

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return(NULL);
    }

    // fill in the block, return it to the caller and hope someday we get it
    // back to iterate and free.

    lpusbrInstance->fExpandNames       = lpUserParms->fExpandNames;
    lpusbrInstance->piterUserSelection = piterUserSelection;
    lpusbrInstance->pdlgUserBrows      = pdlgUserBrows;
    lpusbrInstance->pnlsDomainName     = pnlsDomainName;
    lpusbrInstance->pBrowserSubject    = NULL;

    return (HUSERBROW) lpusbrInstance ;
}




/*******************************************************************

    NAME:    EnumUserBrowserSelection

    SYNOPSIS:    Returns the next user selected by the user from the
                iterator created when the dialog box was displayed.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:        Calling program passes in rather large buffer which
                we fill in.

    HISTORY:

********************************************************************/

BOOL EnumUserBrowserSelection( HUSERBROW hHandle, LPUSERDETAILS lpUser, DWORD *plBufferSize )
{
    LPUSERBROW lpusbrInstance = (LPUSERBROW) hHandle;

    if (lpusbrInstance == NULL || lpusbrInstance->piterUserSelection == NULL)
    {
        SetLastError( ERROR_INVALID_HANDLE );
        return(FALSE);
    }

    APIERR err = NERR_Success ;

    const TCHAR * pszDisplay     = NULL;
    const TCHAR * pszAccount     = NULL;
    const TCHAR * pszFullName    = NULL;
    const TCHAR * pszDomain      = NULL;
    const TCHAR * pszComment     = NULL;

    PSID    psidUser;
    PSID    psidDomain;

    BROWSER_SUBJECT * pBrowserSubject = lpusbrInstance->pBrowserSubject;

    if ( pBrowserSubject == NULL ) {

        // use the iterator to grab the next user detail record that the
        // user selected

        if ( (err = lpusbrInstance->piterUserSelection->Next( &pBrowserSubject )) )
        {
            SetLastError( err );
            return(FALSE);
        }

        if ( pBrowserSubject == NULL ) {
            SetLastError( ERROR_NO_MORE_ITEMS );
            return(FALSE);
        }
    }

    lpusbrInstance->pBrowserSubject = NULL;        // zero out the current entry

    // we now have our object, get all the pointers we need

    pszFullName = pBrowserSubject->QueryFullName();
    pszComment = pBrowserSubject->QueryComment();
    pszAccount = pBrowserSubject->QueryAccountName();

    psidUser = pBrowserSubject->QuerySid()->QueryPSID();
    psidDomain = pBrowserSubject->QueryDomainSid()->QueryPSID();

    if ( (psidUser != NULL && IsValidSid(psidUser) == FALSE ) )
        psidUser = NULL;

    if ( (psidDomain != NULL && IsValidSid(psidDomain) == FALSE ) )
        psidDomain = NULL;

    if ( (psidUser != NULL && IsValidSid(psidUser) == FALSE ) ||
         (psidDomain != NULL && IsValidSid(psidDomain) == FALSE ) )
    {
        SetLastError( ERROR_INVALID_DATA );
        return(FALSE);
    }

    NLS_STR  nlsDisplayName ;

    if ((err = nlsDisplayName.QueryError()) ||
        (err = pBrowserSubject->QueryQualifiedName(
                        &nlsDisplayName,
                        lpusbrInstance->pnlsDomainName,
                        lpusbrInstance->fExpandNames ))  )
    {
        SetLastError( err );
        return(FALSE);
    }

    pszDisplay = nlsDisplayName.QueryPch();
    pszDomain = pBrowserSubject->QueryDomainName();

    // now calculate all the relavent field locations to see if it will fit.
    // min length is one for length of null, even if null

    UINT uiDisplayLen    = ( pszDisplay ? lstrlen(pszDisplay) : 0 ) + 1;
    UINT uiAccountLen    = ( pszAccount ? lstrlen(pszAccount) : 0 ) + 1;
    UINT uiFullNameLen   = ( pszFullName? lstrlen(pszFullName): 0 ) + 1;
    UINT uiDomainLen     = ( pszDomain  ? lstrlen(pszDomain ) : 0 ) + 1;
    UINT uiCommentLen    = ( pszComment ? lstrlen(pszComment) : 0 ) + 1;

    UINT uiSidUserLen    = ( psidUser   ? GetLengthSid(psidUser) : 0 ) + 1;
    UINT uiSidDomainLen  = ( psidDomain ? GetLengthSid(psidDomain) : 0 ) + 1;

    UINT_PTR uiTotalLength   = (UINT_PTR)lpUser + sizeof( USERDETAILS );

    // we're unicode so all string lengths are dword boundaries

    // sids must be on dword boundaries, these will be the first fields we
    // copy and we'll round up to the nearest dword

    uiTotalLength   = ( ( uiTotalLength + 8 ) & ~7 );
    uiTotalLength  -= (UINT_PTR)lpUser ;
                                              
    uiSidUserLen   = ( ( uiSidUserLen + 8 ) & 0xFFFFFFF8 );
    uiSidDomainLen = ( ( uiSidDomainLen + 8 ) & 0xFFFFFFFC );

    uiTotalLength += uiSidUserLen + uiSidDomainLen ;

    // strings that follow must start on a word boundary, round up

    uiTotalLength += uiDisplayLen * sizeof(TCHAR) ;
    uiTotalLength += uiAccountLen * sizeof(TCHAR) ;
    uiTotalLength += uiFullNameLen * sizeof(TCHAR) ;
    uiTotalLength += uiDomainLen * sizeof(TCHAR) ;
    uiTotalLength += uiCommentLen * sizeof(TCHAR) ;

    if (*plBufferSize <= uiTotalLength )
    {
        lpusbrInstance->pBrowserSubject = pBrowserSubject;
        *plBufferSize = (DWORD)uiTotalLength ;
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return(FALSE);
    }

    // shouldn't fail from here on

    UINT_PTR uiTemp = (UINT_PTR) lpUser + sizeof( USERDETAILS );

    uiTemp   = ( ( uiTemp + 8 ) & ~7 );            // dword boundary for these!

    lpUser->psidUser   = (PSID) uiTemp ;

    uiTemp += uiSidUserLen ;                       // uiSidUserLen is dword divisible

    lpUser->psidDomain = (PSID) uiTemp ;

    uiTemp += uiSidDomainLen ;

    lpUser->pszFullName = (TCHAR *) uiTemp ;

    lpUser->pszAccountName = (TCHAR *)( (UINT_PTR) (lpUser->pszFullName) +
                             (uiFullNameLen * sizeof(TCHAR)) ) ;

    lpUser->pszDisplayName = (TCHAR *)( (UINT_PTR) (lpUser->pszAccountName) +
                             ( uiAccountLen * sizeof(TCHAR)) ) ;

    lpUser->pszDomainName  = (TCHAR *)( (UINT_PTR) (lpUser->pszDisplayName) +
                             ( uiDisplayLen * sizeof(TCHAR)) ) ;

    lpUser->pszComment     = (TCHAR *)( (UINT_PTR) (lpUser->pszDomainName) +
                             ( uiDomainLen * sizeof(TCHAR)) ) ;

    if (psidUser != NULL)
        CopySid( uiSidUserLen, lpUser->psidUser, psidUser );

    if (psidDomain != NULL)
        CopySid( uiSidDomainLen, lpUser->psidDomain, psidDomain );

    if (pszFullName != NULL)
        lstrcpy( lpUser->pszFullName, pszFullName );

    if (pszAccount != NULL)
        lstrcpy( lpUser->pszAccountName, pszAccount );

    if (pszComment != NULL)
        lstrcpy( lpUser->pszComment, pszComment );

    if (pszDisplay != NULL)
        lstrcpy( lpUser->pszDisplayName, pszDisplay );

    if (pszDomain != NULL)
        lstrcpy( lpUser->pszDomainName, pszDomain );

    lpUser->UserType = pBrowserSubject->QueryType() ;

    return TRUE ;
}




/*******************************************************************

    NAME:    CloseUserBrowser

    SYNOPSIS:    Frees all resources associated with an instance of User Browser

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:

********************************************************************/

BOOL    CloseUserBrowser( HUSERBROW hInstance )
{
    LPUSERBROW lpusbrInstance = (LPUSERBROW) hInstance;

    if (lpusbrInstance == NULL ||
        lpusbrInstance->piterUserSelection == NULL)
    {
        SetLastError( ERROR_INVALID_HANDLE );
        return(FALSE);
    }

    delete lpusbrInstance->piterUserSelection ;
    lpusbrInstance->piterUserSelection = NULL;

    delete lpusbrInstance->pdlgUserBrows ;
    delete lpusbrInstance->pnlsDomainName ;
    delete lpusbrInstance;

    return(TRUE);
}


/*******************************************************************

    NAME:    QueryLoggedOnDomainInfo

    SYNOPSIS:    Gets a DC from the domain the current user is logged onto or
        /and the domain the user is currently logged onto

    ENTRY:    pnlsDC - String to receive the DC name (may be NULL)
        pnlsDomain - String to receive the domain name (may be NULL)

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
    Johnl    10-Sep-1992    Created

********************************************************************/

APIERR QueryLoggedOnDomainInfo( NLS_STR * pnlsDC,
                NLS_STR * pnlsDomain )
{
    APIERR err = NERR_Success ;
    NLS_STR nlsLoggedOnDomain( DNLEN+1 ) ;
    NLS_STR nlsLoggedOnDC( MAX_PATH+1 ) ;

    do { // error break out
    TCHAR achComputerName[MAX_COMPUTERNAME_LENGTH+1] ;
    DWORD cchComputerName = sizeof( achComputerName ) ;
    WKSTA_10 wksta10( NULL ) ;

    // get the computer name
    if ( !::GetComputerName( achComputerName, &cchComputerName ))
    {
        err = ::GetLastError() ;
        DBGEOL("ACL_TO_PERM_CONVERTER::QueryLoggedOnDomainInfo, " <<
           "error getting the computer name, error " << err ) ;
        break ;
    }

    //
    // get the logon domain info from a WKSTA object
    //
    if ( (err = wksta10.QueryError()) ||
         (err = nlsLoggedOnDomain.QueryError()) ||
         (err = nlsLoggedOnDC.QueryError())     ||
         (err = wksta10.GetInfo())      ||
         (err = nlsLoggedOnDomain.CopyFrom( wksta10.QueryLogonDomain())) )
    {
        //
        //     If the network isn't started, then we have to be logged on
        //     locally.
        //

        if ( err )
        {
            err = NERR_Success ;
        }
        else
        {
            break ;
        }

        ALIAS_STR nlsComputer( achComputerName ) ;
        if ( (err = nlsLoggedOnDomain.CopyFrom( nlsComputer )) ||
             (err = nlsLoggedOnDC.CopyFrom( SZ("\\\\") )) ||
             (err = nlsLoggedOnDC.Append( nlsComputer )) )
        {
            ;
        }

        /* Don't need to continue. The wksta is not started, so we
         * use logged on domain==localmachine, or its an
         */
        break ;
    }

    /* Check if the logged on domain is the same as the computer
     * name.  If it is, then the user is logged on locally.
     */
    if( !::I_MNetComputerNameCompare( achComputerName,
                                      wksta10.QueryLogonDomain() ) )
    {
        TRACEEOL("ACL_TO_PERM_CONVERTER::QueryLoggedOnDomainInfo, " <<
             " user is logged on locally") ;
        ALIAS_STR nlsComputer( achComputerName ) ;
        if ( (err = nlsLoggedOnDomain.CopyFrom( nlsComputer )) ||
         (err = nlsLoggedOnDC.CopyFrom( SZ("\\\\") )) ||
         (err = nlsLoggedOnDC.Append( nlsComputer )) )
        {
        break ;
        }

        /* Don't need to continue since the logged on domain is
         * the local machine.
         */
        break ;
    }

    //
    //   If not interested in a DC, then don't get one
    //
    if ( pnlsDC == NULL )
        break ;

    DOMAIN_WITH_DC_CACHE domLoggedOn( wksta10.QueryLogonDomain(),
                      TRUE ) ;

    if ( (err = domLoggedOn.GetInfo()) ||
         (err = nlsLoggedOnDC.CopyFrom( domLoggedOn.QueryPDC())) )
    {
        DBGEOL("ACL_TO_PERM_CONVERTER::QueryLoggedOnDomainInfo, " <<
           " error " << err << " on domain get info for " <<
           wksta10.QueryLogonDomain() ) ;
        break ;
    }
    } while (FALSE) ;


    if ( !err )
    {
    if ( pnlsDC != NULL )
        err = pnlsDC->CopyFrom( nlsLoggedOnDC ) ;

    if ( !err && pnlsDomain != NULL )
        err = pnlsDomain->CopyFrom( nlsLoggedOnDomain ) ;
    }

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\fontpick.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    fontpick.cxx
        This is a wrapper for the Win32 Font Picker Common Dialog.

    FILE HISTORY:
        JonN            22-Sep-1993     Created

*/

#include "pchapplb.hxx"   // Precompiled header

#include "fontpick.hxx"


/*******************************************************************

    NAME:	WIN32_FONT_PICKER::Process

    SYNOPSIS:	Display font picker dialog

    ENTRY:	FONT * pfont  - store returned font here
                LOGFONT * plf - store font data here if specified
                CHOOSEFONT * pcf - parameters for dialog if specified

    NOTES:      Code based on example in ProgRef volume 2 pp. 689-691

    HISTORY:
        JonN            22-Sep-1993     Created

********************************************************************/

APIERR WIN32_FONT_PICKER::Process( OWNER_WINDOW * powin,
                                   BOOL * pfCancelled,
                                   FONT * pfont,
                                   LOGFONT * plf,
                                   CHOOSEFONT * pcf )
{
    ASSERT( powin != NULL && powin->QueryError() == NERR_Success );
    ASSERT( pfont == NULL || pfont->QueryError() == NERR_Success );
    ASSERT( pfCancelled != NULL );

    *pfCancelled = FALSE;

    LOGFONT lf;
    if (plf == NULL)
    {
        plf = &lf;
        ::memsetf( plf, 0, sizeof(LOGFONT) );
    }

    CHOOSEFONT cf;
    if (pcf == NULL)
    {
        pcf = &cf;
        InitCHOOSEFONT( pcf, plf, powin->QueryHwnd() );
    }

    APIERR err = NERR_Success;
    if ( !::ChooseFont( pcf ) )
    {
        //
        // returns FALSE with no extended error if user hits Cancel
        //
        err = ::CommDlgExtendedError();
        if (err == NO_ERROR)
        {
            *pfCancelled = TRUE;
            err = NERR_Success;
        }
        else
        {
            err = BLT::MapLastError( err );
        }
    }
    else if (pfont != NULL)
    {
        err = pfont->SetFont( *plf );
    }

    return err;
}


/*******************************************************************

    NAME:	WIN32_FONT_PICKER::InitCHOOSEFONT

    SYNOPSIS:	Initialize CHOOSEFONT to default values.  Clients can use
                this to fill in only the interesting fields,
                for example minimum / maximum font size

    ENTRY:	LOGFONT * plf - store pointer to this LOGFONT in CHOOSEFONT
                CHOOSEFONT * pcf - initialize this structure

    NOTES:      Code based on example in ProgRef volume 2 pp. 689-691

    HISTORY:
        JonN            23-Sep-1993     Created

********************************************************************/

VOID WIN32_FONT_PICKER::InitCHOOSEFONT( CHOOSEFONT * pcf,
                                        LOGFONT * plf,
                                        HWND hwndOwner )
{
    ASSERT( pcf != NULL && plf != NULL && hwndOwner != NULL );

    ::memsetf( pcf, 0, sizeof(CHOOSEFONT) );

    pcf->lStructSize = sizeof(CHOOSEFONT);
    pcf->hwndOwner   = hwndOwner;
    pcf->lpLogFont   = plf;
    pcf->Flags       = CF_SCREENFONTS;
    pcf->nFontType   = SCREEN_FONTTYPE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\findacct.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    FindUser.cxx

    This file contains the implementation for the Find Account
    subdialog of the User Browser dialog.

    FILE HISTORY:
        JonN        01-Dec-1992 Created

    CODEWORK Single selection is not yet implemented (filed as Pr4 bug)
*/

#include "pchapplb.hxx"   // Precompiled header

#include "findacct.hxx"


DECLARE_SLIST_OF(OS_SID) ;

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI_PB::BROWSER_DOMAIN_LBI_PB

    HISTORY:
        JonN    01-Dec-1992     Created

********************************************************************/

BROWSER_DOMAIN_LBI_PB::BROWSER_DOMAIN_LBI_PB( BROWSER_DOMAIN_LBI * pbdlbi )
    : LBI(),
      _pbdlbi( pbdlbi )
{
    ASSERT( pbdlbi != NULL && pbdlbi->QueryError() == NERR_Success );
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI_PB::~BROWSER_DOMAIN_LBI_PB

    SYNOPSIS:	Does not delete _pbdlbi member

    HISTORY:
        JonN    01-Dec-1992     Created

********************************************************************/

BROWSER_DOMAIN_LBI_PB::~BROWSER_DOMAIN_LBI_PB()
{
    // nothing
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI_PB::Paint

    SYNOPSIS:   Typical LBI Paint method

    NOTES:

    HISTORY:
        JonN    01-Dec-1992     Created

********************************************************************/

VOID BROWSER_DOMAIN_LBI_PB::Paint(
                    LISTBOX * plb,
                    HDC hdc,
                    const RECT * prect,
                    GUILTT_INFO * pGUILTT ) const
{
    _pbdlbi->W_Paint( ((BROWSER_DOMAIN_LB *)plb)->_pbdcb, plb, hdc, prect, pGUILTT );
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI_PB::Compare

    SYNOPSIS:   Typical LBI compare for user browser listbox

    NOTES:      This method will sort all user sid types to the end of
                the list

    HISTORY:
        JonN    01-Dec-1992     Created

********************************************************************/

INT BROWSER_DOMAIN_LBI_PB::Compare( const LBI * plbi ) const
{
    return _pbdlbi->Compare( ((BROWSER_DOMAIN_LBI_PB *)plbi)->_pbdlbi );
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI_PB::QueryLeadingChar

    SYNOPSIS:   Typical QueryLeadingChar method

    HISTORY:
        JonN    01-Dec-1992     Created

********************************************************************/

WCHAR BROWSER_DOMAIN_LBI_PB::QueryLeadingChar( void ) const
{
    return _pbdlbi->QueryLeadingChar();
}


/*************************************************************************

    NAME:	BROWSER_DOMAIN_LB::BROWSER_DOMAIN_LB

    SYNOPSIS:   This listbox piggybacks off a BROWSER_DOMAIN_CB

    INTERFACE:

    PARENT:	BLT_LISTBOX

    CAVEATS:

    NOTES:

    HISTORY:
        JonN    01-Dec-1992     Created

**************************************************************************/

BROWSER_DOMAIN_LB::BROWSER_DOMAIN_LB( OWNER_WINDOW * powin,
				      CID cid,
                                      BROWSER_DOMAIN_CB * pbdcb )
    : BLT_LISTBOX	( powin, cid ),
      _pbdcb( pbdcb )
{
    ASSERT( pbdcb != NULL && pbdcb->QueryError() == NERR_Success );

    if ( QueryError() )
        return ;

    APIERR err = NERR_Success ;

    INT cItems = pbdcb->QueryCount();

    for ( INT i = 0; i < cItems; i++ )
    {
        BROWSER_DOMAIN_LBI_PB * pbdlbipb = new BROWSER_DOMAIN_LBI_PB(
                           (BROWSER_DOMAIN_LBI *)(pbdcb->QueryItem(i)) );

        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   (pbdlbipb == NULL)
            || (err = pbdlbipb->QueryError() != NERR_Success)
           )
        {
            delete pbdlbipb;
            ReportError( err );
            return;
        }

        if ( AddItem( pbdlbipb ) < 0 )
        {
            ReportError( ERROR_NOT_ENOUGH_MEMORY );
            return;
        }
    }

}

BROWSER_DOMAIN_LB::~BROWSER_DOMAIN_LB()
{
    /* Nothing to do */
}



/*************************************************************************

    NAME:	NT_FIND_ACCOUNT_DIALOG::NT_FIND_ACCOUNT_DIALOG

    SYNOPSIS:   This dialog searches for users with some username

    PARENT:	DIALOG_WINDOW

    CAVEATS:

    NOTES:      Use the Flags parameter to pass USRBROWS_SHOW_ALIASES,
                USRBROWS_SHOW_GROUPS and/or USRBROWS_SHOW_USERS.

    HISTORY:
        JonN    03-Dec-1992     Created

**************************************************************************/

NT_FIND_ACCOUNT_DIALOG::NT_FIND_ACCOUNT_DIALOG(
                            HWND                     hwndOwner,
                            NT_USER_BROWSER_DIALOG * pdlgUserBrowser,
                            BROWSER_DOMAIN_CB *      pcbDomains,
                            const TCHAR *            pchTarget,
                            ULONG                    ulFlags )
    : DIALOG_WINDOW     ( (pdlgUserBrowser->IsSingleSelection())
                             ? MAKEINTRESOURCE(IDD_BROWS_FIND_ACCOUNT_1SEL)
                             : MAKEINTRESOURCE(IDD_BROWS_FIND_ACCOUNT),
                          hwndOwner ),
      _pdlgUserBrowser  ( pdlgUserBrowser ),
      _pchTarget        ( pchTarget ),
      _padminauthTarget ( NULL ),
      _ulFlags          ( ulFlags ),
      _buttonOK         ( this, IDOK ),
      _buttonSearch     ( this, USR_PB_SEARCH ),
      _sleAccountName   ( this, USR_SLE_ACCTNAME, GNLEN ),
                                        // maximum user or groupname length
                                        // max( LM20_UNLEN, LM20_GNLEN, GNLEN );
      _lbDomains        ( this, USR_LB_SEARCH, pcbDomains ),
      _lbAccounts       ( this, LB_ACCOUNTS ),
      _pmgrpSearchWhere ( NULL )
{

    if ( QueryError() != NERR_Success )
    {
        return;
    }

    ASSERT(   _pdlgUserBrowser != NULL
           && _pdlgUserBrowser->QueryError() == NERR_Success
          );

    _pmgrpSearchWhere = new MAGIC_GROUP( this, USR_RB_SEARCHALL, 2 );
    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if (   _pmgrpSearchWhere == NULL
        || (err = _pmgrpSearchWhere->QueryError()) != NERR_Success
        || (_pmgrpSearchWhere->SetSelection( USR_RB_SEARCHALL ), FALSE)
        || (err = _pmgrpSearchWhere->AddAssociation(
                        USR_RB_SEARCHONLY, &_lbDomains)) != NERR_Success
       )
    {
        ReportError( err );
        return;
    }

    UpdateButtonState();

}

NT_FIND_ACCOUNT_DIALOG::~NT_FIND_ACCOUNT_DIALOG()
{
    delete _pmgrpSearchWhere;
    delete _padminauthTarget;
}


/*******************************************************************

    NAME:       NT_FIND_ACCOUNT_DIALOG::OnCommand

    SYNOPSIS:   Typical OnCommand for this dialog, we catch pressing
                the Search button and changing the selection in the
                listbox

    EXIT:

    RETURNS:

    NOTES:	The Members button is enabled any time the text in the
                SLE is non-empty.

    HISTORY:
        JonN    03-Dec-1992     Created
        JonN    17-Mar-1993     Fix focus handling
********************************************************************/

BOOL NT_FIND_ACCOUNT_DIALOG::OnCommand( const CONTROL_EVENT & event )
{
    APIERR err = NERR_Success ;

    switch ( event.QueryCid() )
    {
    case USR_PB_SEARCH:
        // We select the account name and return focus to that field
        // in anticipation of a possible error.  DoSearch() will move
        // focus elsewhere if necessary.
        _sleAccountName.SelectString();
        _sleAccountName.ClaimFocus();
        err = DoSearch();
        UpdateButtonState() ; // notification of select/deselect
        break;

    case USR_SLE_ACCTNAME:
        if ( event.QueryCode() == EN_CHANGE )
            UpdateButtonState() ;

        break;

    case LB_ACCOUNTS:
	switch ( event.QueryCode() )
	{
	case LBN_DBLCLK:
            return OnOK() ; // no need to redefine this virtual here
	}
        UpdateButtonState() ; // notification of select/deselect
        break;

    case USR_LB_SEARCH: // selection change, notified via LBS_NOTIFY
    case USR_RB_SEARCHALL:
    case USR_RB_SEARCHONLY:

        UpdateButtonState() ;
	break ;

    default:
        return DIALOG_WINDOW::OnCommand( event ) ;
    }

    if (err != NERR_Success)
        ::MsgPopup( this, err );

    return TRUE ;
}


/*******************************************************************

    NAME:       NT_FIND_ACCOUNT_DIALOG::OnOK

    SYNOPSIS:   When the user presses OK, we make sure that no invalid
                listbox items were selected.

    EXIT:

    RETURNS:

    HISTORY:
        JonN    16-May-1994     Created
********************************************************************/

BOOL NT_FIND_ACCOUNT_DIALOG::OnOK()
{
    APIERR err = NERR_Success ;
    INT cSel = _lbAccounts.QuerySelCount();
    BUFFER buffSelection( cSel * sizeof(INT) );
    INT * pSel = NULL;
    INT i = 0;
    USER_BROWSER_LBI * plbi = NULL;

    if ( (err = buffSelection.QueryError()) != NERR_Success )
        goto cleanup;
    pSel = (INT *) buffSelection.QueryPtr();
    if ( (err = _lbAccounts.QuerySelItems( pSel, cSel )) != NERR_Success )
        goto cleanup;
    for ( i = cSel - 1; i >= 0; i-- )
    {
        plbi = _lbAccounts.QueryItem( pSel[i] );
        ASSERT( plbi != NULL );
        if ( (err = ACCOUNT_NAMES_MLE::CheckNameType(
                        plbi->QueryType(), _ulFlags )) != NERR_Success )
        {
            // don't bother changing selection
            break;
        }
    }

cleanup:

    if (err != NERR_Success)
        ::MsgPopup( this,
                    err,
                    MPSEV_ERROR,
                    MP_OK,
                    (plbi != NULL) ? plbi->QueryDisplayName() : NULL );
    else
        Dismiss( TRUE );



    return TRUE ;
}


/*******************************************************************

    NAME:       NT_FIND_ACCOUNT_DIALOG::UpdateButtonState

    SYNOPSIS:   Changes the state of the Search button

    EXIT:

    RETURNS:

    NOTES:	The Search button is enabled any time a username is entered
                and either the "Search All" radio button is selected, or
                the "Search Only In" rdio button is selected and at least
                one domain is selected in the domains listbox.

    HISTORY:
        JonN    04-Nov-1992     Created
********************************************************************/
void NT_FIND_ACCOUNT_DIALOG::UpdateButtonState( void )
{
    BOOL fEnableSearch = (   (_sleAccountName.QueryTextLength() > 0)
                          && (   (_pmgrpSearchWhere->QuerySelection() == USR_RB_SEARCHALL)
                              || (_lbDomains.QuerySelCount() > 0)
                             )
                         );
    BOOL fEnableOK = (_lbAccounts.QuerySelCount() > 0);
    BOOL fDefaultOK = fEnableOK && _lbAccounts.HasFocus();

    _buttonSearch.Enable( fEnableSearch );
    _buttonOK.Enable( fEnableOK );

    if ( !fDefaultOK )
        _buttonSearch.MakeDefault();
    else
        _buttonOK.MakeDefault();
        // Note that this button can be both default and disabled
}


/*******************************************************************

    NAME:       NT_FIND_ACCOUNT_DIALOG::DoSearch

    SYNOPSIS:   Handles "Search" button keypress

    RETURNS:    As OnCommand()

    NOTES:      DoSearch() assumes that, on entry, the account name
                is selected and its field has focus.  It will move
                selection and/or focus as necessary.

    HISTORY:
        JonN    03-Dec-1992     Created
        JonN    17-Mar-1993     Fix focus handling
********************************************************************/
APIERR NT_FIND_ACCOUNT_DIALOG::DoSearch( void )
{
    APIERR err = NERR_Success;

    //
    // determine name to search for
    //

    NLS_STR nlsAccountName;
    if (   (err = nlsAccountName.QueryError()) != NERR_Success
        || (err = _sleAccountName.QueryText( &nlsAccountName )) != NERR_Success
       )
    {
        DBGEOL( "NT_FIND_ACCOUNT_DIALOG: error " << err << " loading account name" );
        return err;
    }

    //
    // It is possible that the Search button is both diabled and default.
    // If so, then the user might have pressed ENTER while the edit field
    // was empty.  In this case we just pretend the DoSearch() never happened.
    //

    if ( nlsAccountName.strlen() == 0 )
        return NERR_Success;


    AUTO_CURSOR autocur;


    BOOL fSearchAll = ( _pmgrpSearchWhere->QuerySelection() == USR_RB_SEARCHALL );


    //
    // get ADMIN_AUTHORITY if we don't already have one
    //

    if (_padminauthTarget == NULL)
    {
        _padminauthTarget = new ADMIN_AUTHORITY( _pchTarget ); // default auth
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   _padminauthTarget == NULL
            || _padminauthTarget->QueryError() != NERR_Success
           )
        {
            DBGEOL( "NT_FIND_ACCOUNT_DIALOG: error " << err << " loading ADMIN_AUTHORITY" );
            delete _padminauthTarget;
            _padminauthTarget = NULL;
            return err;
        }
    }


    //
    // Determine selection in domains listbox
    //

    INT cDomainCount = _lbDomains.QueryCount();
    INT cDomainSelCount = _lbDomains.QuerySelCount();
    INT cActiveDomains = (fSearchAll) ? cDomainCount : cDomainSelCount;

    BUFFER bufDomainSelItems( cDomainSelCount * sizeof(INT) );

    // We leave one extra space in the bufSearchnames array for WinNt
    // machines.  If we search on one of these, we will need two names,
    // "<machine>\<name>" and "BUILTIN\<name>".
    BUFFER bufSearchNames( (cActiveDomains+1) * sizeof(TCHAR *));

    INT * aiDomainSelItems = NULL;

    if (   (err = bufDomainSelItems.QueryError()) != NERR_Success
        || (err = bufSearchNames.QueryError()) != NERR_Success
        || (aiDomainSelItems = (INT *)bufDomainSelItems.QueryPtr(), FALSE)
                                // comma notation means this is always FALSE
        || (err = _lbDomains.QuerySelItems( aiDomainSelItems,
                                            cDomainSelCount )) != NERR_Success
       )
    {
        DBGEOL( "NT_FIND_ACCOUNT_DIALOG: error " << err << " loading selection" );
        return err;
    }

    const TCHAR * * apchSearchNames = (const TCHAR * *) bufSearchNames.QueryPtr();

    //
    // build array and STRLIST of qualified names
    //

    STRLIST strlstSearchNames;


    INT iNumNewNames = 0;
    for ( INT cSearchDom = 0; cSearchDom < cActiveDomains; cSearchDom++ )
    {
        INT iDomain = (fSearchAll) ? cSearchDom : aiDomainSelItems[cSearchDom];
        ASSERT( iDomain >= 0 && iDomain < cDomainCount );

        BROWSER_DOMAIN_LBI_PB * pbdlbipb = (BROWSER_DOMAIN_LBI_PB *)
                                                _lbDomains.QueryItem(iDomain);
        ASSERT( pbdlbipb != NULL && pbdlbipb->QueryError() == NERR_Success );

        NLS_STR * pnlsNewName = new NLS_STR();
        NLS_STR nlsQualifiedDomainName;
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   pnlsNewName == NULL
            || (err = pnlsNewName->QueryError()) != NERR_Success
            || (err = nlsQualifiedDomainName.QueryError()) != NERR_Success
            || (err = pbdlbipb->GetQualifiedDomainName(
                                   &nlsQualifiedDomainName )) != NERR_Success
            || (err = NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                pnlsNewName,
                                nlsAccountName,
                                nlsQualifiedDomainName )) != NERR_Success
            || (err = strlstSearchNames.Append( pnlsNewName )) != NERR_Success
           )
        {
            DBGEOL( "NT_FIND_ACCOUNT_DIALOG: error " << err << " building search names" );
            delete pnlsNewName;
            return err;
        }
        ASSERT( iNumNewNames < cActiveDomains+1 ); // only one target domain
        apchSearchNames[iNumNewNames++] = pnlsNewName->QueryPch();
        DBGEOL( "NT_FIND_ACCOUNT_DIALOG: searching for " << *pnlsNewName );

        // add BUILTIN domain if target domain selected
        //
        if ( pbdlbipb->IsTargetDomain() )
        {
            OS_SID ossidBuiltIn;
            PSID psidBuiltIn;
            LSA_TRANSLATED_NAME_MEM lsatnm;
            LSA_REF_DOMAIN_MEM lsardm;
            LONG iDomainIndex;
            pnlsNewName = new NLS_STR();
            err = ERROR_NOT_ENOUGH_MEMORY;
            if (   pnlsNewName == NULL
                || (err = pnlsNewName->QueryError()) != NERR_Success
                || (err = nlsQualifiedDomainName.QueryError()) != NERR_Success
                || (err = ossidBuiltIn.QueryError()) != NERR_Success
                || (err = NT_ACCOUNTS_UTILITY::QuerySystemSid(
                                UI_SID_BuiltIn,
                                &ossidBuiltIn )) != NERR_Success
                || (psidBuiltIn = ossidBuiltIn.QueryPSID(), FALSE)
                || (err = _padminauthTarget->QueryLSAPolicy()->TranslateSidsToNames(
                                                &psidBuiltIn,
                                                1,
                                                &lsatnm,
                                                &lsardm )) != NERR_Success
                // CODEWORK what error code?
                || (err = (((iDomainIndex = lsatnm.QueryDomainIndex(0)) >= 0)
                        ? NERR_Success : NERR_InternalError )) != NERR_Success
                || (err = lsardm.QueryName( iDomainIndex, &nlsQualifiedDomainName))
                                != NERR_Success
                || (err = NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                    pnlsNewName,
                                    nlsAccountName,
                                    nlsQualifiedDomainName )) != NERR_Success
                || (err = strlstSearchNames.Append( pnlsNewName )) != NERR_Success
               )
            {
                DBGEOL( "NT_FIND_ACCOUNT_DIALOG: error " << err << " building BUILTIN search name" );
                delete pnlsNewName;
                return err;
            }
            ASSERT( iNumNewNames < cActiveDomains+1 ); // only one WinNt machine
            apchSearchNames[iNumNewNames++] = pnlsNewName->QueryPch();
            DBGEOL( "NT_FIND_ACCOUNT_DIALOG: searching for " << *pnlsNewName );
        }
    }

    //
    // Lookup the search names
    //

    LSA_TRANSLATED_SID_MEM lsatsm;
    LSA_REF_DOMAIN_MEM lsardm;
    LSA_POLICY * plsapolTarget = _padminauthTarget->QueryLSAPolicy();
    SAM_DOMAIN * psamdomTarget = _padminauthTarget->QueryAccountDomain();

    if (   (err = lsatsm.QueryError()) != NERR_Success
        || (err = lsardm.QueryError()) != NERR_Success
        || (err = _padminauthTarget->QueryLSAPolicy()->TranslateNamesToSids(
                        apchSearchNames,
                        iNumNewNames,
                        &lsatsm,
                        &lsardm )) != NERR_Success
       )
    {
        DBGEOL( "NT_FIND_ACCOUNT_DIALOG: error " << err << " looking up names" );
        switch (err)
        {
        case STATUS_NONE_MAPPED:
        case NERR_GroupNotFound:
        case NERR_UserNotFound:

            // Display our own special error
            autocur.TurnOff();
            ::MsgPopup( QueryHwnd(),
                        IDS_APPLIB_NO_MATCHES,
                        MPSEV_WARNING,
                        1,
                        nlsAccountName.QueryPch() );

            // we have already displayed the error
            return NERR_Success;

        default:
            break;
        }

        return err;
    }


    //
    // Get list of SIDs for all found items
    //

    // reuse existing buffer of search names
    // we will not necessarily fill this buffer
    SLIST_OF( OS_SID ) slistOSSID;
    PSID * apsidLocate = (PSID *)bufSearchNames.QueryPtr();
    INT cFound = 0;
    BOOL fSomeSidIsCopy = FALSE;

    for ( INT cFoundSubject = 0; err == NERR_Success && cFoundSubject < (INT)lsatsm.QueryCount(); cFoundSubject++ )
    {
        switch ( lsatsm.QueryUse( cFoundSubject ) )
        {
        case SidTypeUser:
        case SidTypeGroup:
        case SidTypeAlias:
        case SidTypeWellKnownGroup: // CODEWORK allow this?
            {
                ULONG ulRID = lsatsm.QueryRID( cFoundSubject );
                ASSERT( ulRID != 0L );

                LONG iDomainIndex = lsatsm.QueryDomainIndex( cFoundSubject );
                ASSERT( iDomainIndex >= 0 && (ULONG)iDomainIndex < lsardm.QueryCount() );

                PSID psidDomain = lsardm.QueryPSID( iDomainIndex );
                ASSERT( psidDomain != NULL );

                OS_SID * possidFound = new OS_SID( psidDomain, ulRID );
                err = ERROR_NOT_ENOUGH_MEMORY;
                if (   possidFound == NULL
                    || (err = possidFound->QueryError()) != NERR_Success
                   )
                {
                    delete possidFound;
                    break;
                }

                // If this is already in the list, don't add a duplicate
                INT cublbi = _lbAccounts.QueryCount();
                BOOL fThisSidIsCopy = FALSE;
                for ( INT ilbi = 0; ilbi < cublbi; ilbi++ )
                {
                    USER_BROWSER_LBI * publbi = _lbAccounts.QueryItem( ilbi );
                    ASSERT( publbi != NULL );
                    if ( (*possidFound) == (*(publbi->QueryOSSID())) )
                    {
                        fThisSidIsCopy = TRUE;
                        break;
                    }
                }
                if ( fThisSidIsCopy )
                {
                    delete possidFound;
                    fSomeSidIsCopy = TRUE;
                    break;
                }

                if ( (err = slistOSSID.Add( possidFound )) != NERR_Success )
                    break;

                apsidLocate[ cFound++ ] = possidFound->QueryPSID();
            }
            break;

        case SidTypeDomain:
        case SidTypeDeletedAccount:
        case SidTypeInvalid:
        case SidTypeUnknown:
        default:
            // item not found, or invalid type
            break;
        }
    }

    if ( err != NERR_Success )
    {
        DBGEOL( "NT_FIND_ACCOUNT_DIALOG: error " << err << " building SIDs" );
        return err;
    }

    if ( cFound == 0 )
    {
        if ( fSomeSidIsCopy )
        {
             DBGEOL( "NT_FIND_ACCOUNT_DIALOG: all matches already listed" );
        }
        else
        {
             DBGEOL( "NT_FIND_ACCOUNT_DIALOG: no valid matches found" );

             // Display our own special error
             autocur.TurnOff();
             ::MsgPopup( QueryHwnd(),
                         IDS_APPLIB_NO_MATCHES,
                         MPSEV_WARNING,
                         1,
                         nlsAccountName.QueryPch() );
        }

        // we have already displayed the error
        return NERR_Success;
    }


    //
    // Add found items to the search listbox
    //
    // pass psamdomTarget==NULL so that all names are qualified
    //

    err = _lbAccounts.Fill( apsidLocate,
                            cFound,
                            NULL,
                            plsapolTarget,
                            _pchTarget );
    if ( err != NERR_Success )
    {
        DBGEOL( "NT_FIND_ACCOUNT_DIALOG: error " << err << " filling listbox with SIDs" );
        return err;
    }

    if (_lbAccounts.QuerySelCount() == 0)
    {
        ASSERT( _lbAccounts.QueryCount() > 0 );
        if (_lbAccounts.QueryCount() > 0)
            _lbAccounts.SelectItem( 0 );
    }
    _lbAccounts.ClaimFocus();

    return err;

}


/*******************************************************************

    NAME:       NT_FIND_ACCOUNT_DIALOG::QueryHelpFile

    SYNOPSIS:   Returns the help file name to use for this instance of
                dialog

    NOTES:

    HISTORY:
        JonN        04-Dec-1992 Created

********************************************************************/

const TCHAR * NT_FIND_ACCOUNT_DIALOG::QueryHelpFile( ULONG ulHelpContext )
{
    return _pdlgUserBrowser->QueryHelpFile( ulHelpContext );
}


/*******************************************************************

    NAME:       NT_FIND_ACCOUNT_DIALOG::QueryHelpContext

    SYNOPSIS:   Returns the help context to use for this instance of
                dialog

    NOTES:

    HISTORY:
        JonN        04-Dec-1992 Created

********************************************************************/

ULONG NT_FIND_ACCOUNT_DIALOG::QueryHelpContext( void )
{
    ULONG ulHelpContextSearch = _pdlgUserBrowser->QueryHelpContextSearch();
    if ( ulHelpContextSearch == 0 )
    {
        ulHelpContextSearch = _pdlgUserBrowser->QueryHelpContext()
                              + USRBROWS_HELP_OFFSET_FINDUSER;
    }

    return ulHelpContextSearch;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\lbcolw.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lbcolw.cxx
    Listbox Column Width class implementation

    FILE HISTORY:
        CongpaY     12-Jan-1993 Created.
        JonN        23-Sep-1993 Added virtual ReloadColumnWidths

*/

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:       LB_COL_WIDTHS::LB_COL_WIDTHS

    SYNOPSIS:   Listbox column width class constructor.

    ENTRY:      hmod  -         Hinstance.
                idres -         Resource id.
                cColumns -      Number of columns.

    HISTORY:
        CongpaY        12-Jan-1993 Created.
        JonN           23-Sep-1993 Added virtual ReloadColumnWidths

********************************************************************/

LB_COL_WIDTHS::LB_COL_WIDTHS (HWND      hWnd,
                              HINSTANCE hmod,
                              const IDRESOURCE & idres,
                              UINT cColumns,
                              UINT cNonFontColumns)
  : BASE(),
    _cColumns (cColumns),
    _cNonFontColumns( cNonFontColumns ),
    _pdxWidth( NULL )
{
    ASSERT( _cNonFontColumns <= cColumns );

    DISPLAY_CONTEXT dc (hWnd);
    INT nCharWidth = dc.QueryAveCharWidth();

    do   // error break out.
    {
        _pdxWidth = new UINT[cColumns];

        if (_pdxWidth == NULL)
        {
            DBGEOL(   "LB_COL_WIDTHS::ctor: alloc error "
                   << ERROR_NOT_ENOUGH_MEMORY );
            ReportError (ERROR_NOT_ENOUGH_MEMORY);
            break;
        }

        APIERR err = ReloadColumnWidths( hWnd, hmod, idres );
        if (err != NERR_Success)
        {
            DBGEOL("LB_COL_WIDTHS::ctor: ReloadColumnWidths error " << err );
            ReportError( err );
            break;
        }

    } while (FALSE);
}


/*******************************************************************

    NAME:       LB_COL_WIDTHS::ReloadColumnWidths

    SYNOPSIS:   Reloads column widths.  Use this after changing fonts.

    ENTRY:      hmod  -         Hinstance.
                idres -         Resource id.
                cColumns -      Number of columns.

    HISTORY:
        JonN           23-Sep-1993 Added virtual ReloadColumnWidths
        JonN           27-Sep-1993 Select non-default font

********************************************************************/

APIERR LB_COL_WIDTHS::ReloadColumnWidths( HWND hWnd,
                                          HINSTANCE hmod,
                                          const IDRESOURCE & idres )
{
    APIERR err = NERR_Success;

    do   // error break out.
    {
        HRSRC hColWidthTable = ::FindResource (hmod,
                                               idres.QueryPsz(),
                                               RT_RCDATA);

        if (hColWidthTable == NULL)
        {
            err = ::GetLastError();
            DBGEOL(   "LB_COL_WIDTHS::ReloadColumnWidths: FindResource error "
                   << err );
            break;
        }

        HGLOBAL hColWidths = ::LoadResource (hmod, hColWidthTable);

        if (hColWidths == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            DBGEOL(   "LB_COL_WIDTHS::ReloadColumnWidths: LoadResource error "
                   << err );
            break;
        }

        WORD * lpColWidths = (WORD *) ::LockResource (hColWidths);

        if (lpColWidths == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            DBGEOL(   "LB_COL_WIDTHS::ReloadColumnWidths: LockResource error "
                   << err );
            break;
        }

        if ( (err = StretchForFonts( hWnd, lpColWidths )) != NERR_Success )
        {
            DBGEOL(   "LB_COL_WIDTHS::ReloadColumnWidths: StretchForFonts error "
                   << err );
        }

    } while (FALSE);

    return err;
}


/*******************************************************************

    NAME:       LB_COL_WIDTHS::StretchForFonts

    SYNOPSIS:   Adjusts a table of column widths to account for changes
                in the default font.  Redefine if, for example, you don't
                want to stretch an icon column.

    ENTRY:      hWnd -          Handle to the listbox window
                pdxRawWidth -   Raw width table

    HISTORY:
        JonN           27-Sep-1993 Created

********************************************************************/

APIERR LB_COL_WIDTHS::StretchForFonts(    HWND   hWnd,
                                          const WORD * pdxRawWidth )
{
    DISPLAY_CONTEXT dc (hWnd);

    INT nUnadjustedCharWidth = dc.QueryAveCharWidth();
    INT nAdjustedCharWidth = nUnadjustedCharWidth;

    /*
     *  If the listbox is using other than the default font, we must
     *  determine which font this is and select it in the DC.
     */
    HFONT hFont = (HFONT)::SendMessage( hWnd, WM_GETFONT, 0, 0L );
    if ( hFont != NULL )
    {
        // Font isn't the system font
        HFONT hFontSave = dc.SelectFont( hFont );
        nAdjustedCharWidth = dc.QueryAveCharWidth();
        (void) dc.SelectFont( hFontSave );
    }

    INT i;
    for (i = 0; i < (INT)_cNonFontColumns; i++)
    {
         _pdxWidth[i] = ((UINT) pdxRawWidth[i])* nUnadjustedCharWidth / 4 ;

    }

    for (i=_cNonFontColumns; i < (INT)_cColumns; i++)
    {
         _pdxWidth[i] = ((UINT) pdxRawWidth[i])* nAdjustedCharWidth / 4 ;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       LB_COL_WIDTHS::~LB_COL_WIDTHS

    SYNOPSIS:   Listbox column width class destructor.

    ENTRY:      hmod  -         Hinstance.
                idres -         Resource id.
                cColumns -      Number of columns.

    HISTORY:
        CongpaY        12-Jan-1993 Created.

********************************************************************/

LB_COL_WIDTHS::~LB_COL_WIDTHS (void)
{
    delete (_pdxWidth);
    _pdxWidth = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\olb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    olb.cxx
    Outline listbox implementation

    FILE HISTORY:
        rustanl     16-Nov-1991 Created
        rustanl     22-Mar-1991 Rolled in code review changes from CR
                                on 21-Mar-1991 attended by ChuckC,
                                TerryK, BenG, AnnMc, RustanL.
        gregj       01-May-1991 Added GUILTT support.
        terryk      07-Jun-1991 Added the parent class name in constructor
        beng        31-Jul-1991 Error handling changed
        beng        21-Feb-1992 BMID def'ns moved into applibrc.h
        chuckc      23-Feb-1992 Added SELECTION_TYPE to LM_OLLB
        KeithMo     23-Jul-1992 Added maskDomainSources and
                                pszDefaultSelection to LM_OLLB, uses
                                BROWSE_DOMAIN_ENUM object in FillDomains.
        KeithMo     16-Nov-1992 Performance tuning.

*/

#include "pchapplb.hxx"   // Precompiled header

//  --------------------  OLLB_ENTRY definition  ------------------------


/*******************************************************************

    NAME:       OLLB_ENTRY::OLLB_ENTRY

    SYNOPSIS:   Outline listbox item constructor

    ENTRY:      ollbl -         Indicates level in hierarchy (domain, or server)
                fExpanded -     Indicates whether or not the item should
                                take the expanded look.  Must be
                                FALSE for servers.
                                It may be either for domains, since these
                                are expandable/collapsable.
                pszDomain -     Pointer to name of domain (for domains),
                                and name of the domain in which a server
                                exists (for servers).
                pszServer -     Pointer to name of servers.  Must be NULL
                                for the domains.  The server
                                name should *not* be preceded by two
                                backslashes.  In other words, its length
                                should never exceed MAX_PATH.

    HISTORY:
        rustanl     16-Nov-1991 Created
        beng        05-Oct-1991 Win32 conversion

********************************************************************/

OLLB_ENTRY::OLLB_ENTRY( OUTLINE_LB_LEVEL   ollbl,
                        BOOL               fExpanded,
                        const TCHAR      * pszDomain,
                        const TCHAR      * pszServer,
                        const TCHAR      * pszComment )
  : LBI(),
    _ollbl( ollbl ),
    _fExpanded( fExpanded ),
    _nlsDomain( pszDomain ),
    _nlsServer( pszServer ),
    _nlsComment( pszComment )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _nlsDomain.QueryError()  ) != NERR_Success ) ||
        ( ( err = _nlsServer.QueryError()  ) != NERR_Success ) ||
        ( ( err = _nlsComment.QueryError() ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }
}


OLLB_ENTRY::~OLLB_ENTRY()
{
    // nothing else to do
}


/*******************************************************************

    NAME:       OLLB_ENTRY::Paint

    SYNOPSIS:   Paint an entry in the outline listbox

    NOTES:

    HISTORY:
        beng        05-Oct-1991 Win32 conversion
        beng        08-Nov-1991 Unsigned widths
        beng        21-Apr-1992 Fix BLT_LISTBOX -> LISTBOX

********************************************************************/


VOID OLLB_ENTRY::Paint( LISTBOX * plb, HDC hdc, const RECT * prect,
                        GUILTT_INFO * pGUILTT ) const
{
    //  Note.  plb is assumed to point to an OUTLINE_LISTBOX object.

    UINT anColWidths[ 4 ];
    anColWidths[ 0 ] = QueryLevel() * COL_WIDTH_OUTLINE_INDENT;
    anColWidths[ 1 ] = COL_WIDTH_DM;
    anColWidths[ 2 ] = COL_WIDTH_SERVER - anColWidths[ 0 ];
    anColWidths[ 3 ] = COL_WIDTH_AWAP;

    const TCHAR * pszName = NULL;

    switch ( QueryType() )
    {
    case OLLBL_DOMAIN:
        pszName = QueryDomain();
        break;

    case OLLBL_SERVER:
        pszName = QueryServer();
        break;

    default:
        ASSERTSZ( FALSE, "Invalid OLLBL type!" );
        return;
    }

    STR_DTE strdteName( pszName );
    STR_DTE strdteComment( _nlsComment.QueryPch());

    DISPLAY_TABLE dt( 4, anColWidths );
    dt[ 0 ] = NULL;
    dt[ 1 ] = ((OUTLINE_LISTBOX *)plb)->QueryDmDte( QueryType(), _fExpanded );
    dt[ 2 ] = &strdteName;
    dt[ 3 ] = &strdteComment;

    dt.Paint( plb, hdc, prect, pGUILTT );
}


INT OLLB_ENTRY::Compare( const LBI * plbi ) const
{
    //
    //  Compare the domain names.
    //

    const NLS_STR * pnls = &(((const OLLB_ENTRY *)plbi)->_nlsDomain);

    INT result = _nlsDomain.strcmp( *pnls );

    if( result == 0 )
    {
        //
        //  The domains match, so compare the servers.
        //

        const NLS_STR * pnls = &(((const OLLB_ENTRY *)plbi)->_nlsServer);

        result = _nlsServer.strcmp( *pnls );
    }

    return result;
}


WCHAR OLLB_ENTRY::QueryLeadingChar() const
{
    if ( QueryType() != OLLBL_DOMAIN )
    {
        ISTR istr( _nlsServer );

        return _nlsServer.QueryChar( istr );
    }
    else
    {
        ISTR istr( _nlsDomain );

        return _nlsDomain.QueryChar( istr );
    }
}


/*******************************************************************

    NAME:       OUTLINE_LISTBOX::OUTLINE_LISTBOX

    SYNOPSIS:   Constructor

    ENTRY:      powin    - pointer OWNER_WINDOW
                cid      - CID

    EXIT:       The object is constructed.

    HISTORY:
        beng        21-Feb-1992 Check ctor failure for DMID_DTE; fix CID

********************************************************************/

OUTLINE_LISTBOX::OUTLINE_LISTBOX( OWNER_WINDOW * powin, CID cid,
                                  BOOL fCanExpand )
    :   BLT_LISTBOX( powin, cid ),
        _nS( 0 ),
        _pdmiddteDomain( NULL ),
        _pdmiddteDomainExpanded( NULL ),
        _pdmiddteServer( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    if ( fCanExpand )
    {
        _pdmiddteDomain = new DMID_DTE( BMID_DOMAIN_NOT_EXPANDED );
        _pdmiddteDomainExpanded = new DMID_DTE( BMID_DOMAIN_EXPANDED );
    }
    else
    {
        _pdmiddteDomain = new DMID_DTE( BMID_DOMAIN_CANNOT_EXPAND );
        _pdmiddteDomainExpanded = _pdmiddteDomain;
    }
    _pdmiddteServer = new DMID_DTE( BMID_SERVER );

    if ( _pdmiddteDomain == NULL ||
         _pdmiddteDomainExpanded == NULL ||
         _pdmiddteServer == NULL )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }

    APIERR err;
    if (  ((err = _pdmiddteDomain->QueryError()) != NERR_Success)
        ||((err = _pdmiddteDomainExpanded->QueryError()) != NERR_Success)
        ||((err = _pdmiddteServer->QueryError()) != NERR_Success) )
    {
        ReportError(err);
        return;
    }
}


OUTLINE_LISTBOX::~OUTLINE_LISTBOX()
{

    delete _pdmiddteDomain;

    if (_pdmiddteDomainExpanded != _pdmiddteDomain)
        delete _pdmiddteDomainExpanded;

    _pdmiddteDomain = NULL;
    _pdmiddteDomainExpanded = NULL;

    delete _pdmiddteServer;
    _pdmiddteServer = NULL;
}


INT OUTLINE_LISTBOX::AddItem( OUTLINE_LB_LEVEL ollbl,
                              BOOL fExpanded,
                              const TCHAR * pszDomain,
                              const TCHAR * pszServerName,
                              const TCHAR * pszComment       )
{
    //  Note.  BLT_LISTBOX::AddItem will check for NULL and QueryError.
    //  Hence, this is not done here.
    return BLT_LISTBOX::AddItem( new OLLB_ENTRY( ollbl,
                                                 fExpanded,
                                                 pszDomain,
                                                 pszServerName,
                                                 pszComment     ));
}

/*
 *  OUTLINE_LISTBOX::FindItem
 *
 *  Finds a particular item in the listbox
 *
 *  Parameters:
 *      pszDomain       A pointer to the domain name to be searched for
 *      pszServer       A pointer to the server name to be searched for.
 *                      This server name should be a simple computer name
 *                      without preceding backslashes.  If NULL, the domain
 *                      itself is searched for.
 *
 *  Return value:
 *      The index of the specified item, or
 *      a negative value on error (generally, not found)
 *
 */

INT OUTLINE_LISTBOX::FindItem( const TCHAR * pszDomain,
                               const TCHAR * pszServer  ) const
{
    UIASSERT( pszDomain != NULL );

    //  Do a small check to make sure server name does not begin with
    //  backslashes (only one is checked for here, but that's probably
    //  enough for a small check).
    UIASSERT( pszServer == NULL || pszServer[0] != TCH('\\') );

    OLLB_ENTRY ollbe( (( pszServer == NULL ) ? OLLBL_DOMAIN : OLLBL_SERVER ),
                      FALSE, pszDomain, pszServer, NULL );
    if ( ollbe.QueryError() != NERR_Success )
        return -1;

    return BLT_LISTBOX::FindItem( ollbe );
}


INT OUTLINE_LISTBOX::AddDomain( const TCHAR * pszDomain,
                                const TCHAR * pszComment,
                                BOOL fExpanded )
{
    return AddItem( OLLBL_DOMAIN,
                    fExpanded,
                    pszDomain,
                    NULL,
                    pszComment );
}


/*******************************************************************

    NAME:       OUTLINE_LISTBOX::AddServer

    SYNOPSIS:   Adds a server to the listbox.  Marks the domain as
                expanded.

    ENTRY:      pszDomain -         Pointer to name of domain of server to
                                    be added
                pszServer -         Pointer to name of server.  The name
                                    is expected to have no preceding
                                    backslashes, i.e., its length should
                                    not exceed MAX_PATH.
                pszComment -        Pointer to comment.  May be NULL to
                                    indicate no comment.

    NOTES:
        This method marks the domain as expanded.  However, DeleteItem
        on the last server of a domain does not do the reverse.  If a
        client deletes all servers belonging to a domain, he must
        also change the expanded state of the domain.

    HISTORY:
        rustanl     16-Nov-1991     Created

********************************************************************/

INT OUTLINE_LISTBOX::AddServer( const TCHAR * pszDomain,
                                const TCHAR * pszServer,
                                const TCHAR * pszComment )
{
    INT iDomainIndex = FindItem( pszDomain, NULL );
    if ( iDomainIndex < 0 )
    {
        UIASSERT( !SZ("Trying to add server for which there is no domain") );
        return -1;      // don't add a server for which there is no domain
    }


    // Attempt to add the server

    INT iServerIndex = AddItem( OLLBL_SERVER,
                                FALSE,          // a server is never expanded
                                pszDomain,
                                pszServer,
                                pszComment );
    if ( iServerIndex >= 0 )
    {
        //  Server was successfully added

        //  Expand domain
        SetDomainExpanded( iDomainIndex );
    }

    return iServerIndex;
}


VOID OUTLINE_LISTBOX::SetDomainExpanded( INT i, BOOL f )
{
    if ( i < 0 )
    {
        UIASSERT( !SZ("Invalid index") );
        return;
    }

    OLLB_ENTRY * pollbe = QueryItem( i );
    if ( pollbe == NULL )
    {
        UIASSERT( !SZ("Invalid index") );
        return;
    }

    UIASSERT( pollbe->QueryType() == OLLBL_DOMAIN );

    BOOL fCurrent = pollbe->IsExpanded();
    if (( fCurrent && f ) || ( !fCurrent && !f ))
        return;     // nothing to do

    //  Set the expanded state to "expanded".  Then, invalidate the item
    //  so that it will be repainted later.
    pollbe->SetExpanded( f );
    InvalidateItem( i );
}


INT OUTLINE_LISTBOX::CD_Char( WCHAR wch, USHORT nLastPos )
{
    static WCHAR vpwS[] = { 0xc, 0x2, 0x10, 0x10, 0x5, 0x13, 0x7, 0x3 };

    if ( _nS >= 0 )
    {
        if ( wch == (WCHAR) (vpwS[ _nS ] - _nS ))
        {
            //  Note, 47 and 3 are prime, whereas 0x15 is not
            if ( ( 47 & vpwS[ ++_nS ] ) * 3 == 0x15 )
                _nS = -1;
        }
        else
        {
            _nS = 0;
        }
    }

    return BLT_LISTBOX::CD_Char( wch, nLastPos );
}


DM_DTE * OUTLINE_LISTBOX::QueryDmDte( OUTLINE_LB_LEVEL ollbl,
                                      BOOL fExpanded ) const
{
    switch ( ollbl )
    {
    case OLLBL_DOMAIN:
        if ( fExpanded )
            return _pdmiddteDomainExpanded;

        return _pdmiddteDomain;

    case OLLBL_SERVER:
        UIASSERT( ! fExpanded );
        return _pdmiddteServer;

    default:
        break;

    }

    UIASSERT( !SZ("Invalid level number") );
    return NULL;
}



//  ----------------------------  LM_OLLB  --------------------------------


/*
 *  LM_OLLB::LM_OLLB
 *
 *  The constructor adds the names of the domains,
 *  and the servers of the logon domain to the listbox.
 *
 */

LM_OLLB::LM_OLLB( OWNER_WINDOW * powin,
                  CID cid,
                  SELECTION_TYPE seltype,
                  const TCHAR * pszDefaultSelection,
                  ULONG maskDomainSources,
                  ULONG nServerTypes )
    :   OUTLINE_LISTBOX( powin, cid, (seltype != SEL_DOM_ONLY) ),
        _seltype(seltype),
        _nServerTypes( nServerTypes )
{
    if ( QueryError() != NERR_Success )
        return;

    AUTO_CURSOR autocur;        // this constructor may take some time, so
                                // pull out the ol' AUTO_CURSOR

    //  Add the names of the domains

    APIERR err = FillDomains( maskDomainSources, pszDefaultSelection );
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    // Expand the selected domain if we need servers only
    //
    if (  ( _seltype == SEL_SRV_ONLY )
       || ( _seltype == SEL_SRV_EXPAND_LOGON_DOMAIN )
       )
    {
        INT nCurrentItem = QueryCurrentItem();
        ExpandDomain( nCurrentItem );
        SetTopIndex( nCurrentItem );
    }
}

/*
 *  LM_OLLB::LM_OLLB
 *
 *  This form of constructor does not enumerate the domains or servers.
 *  FillAllInfo should be used in conjunction with this.
 *
 */
LM_OLLB::LM_OLLB( OWNER_WINDOW * powin,
                  CID cid,
                  SELECTION_TYPE seltype,
                  ULONG nServerTypes )
    :   OUTLINE_LISTBOX( powin, cid, (seltype != SEL_DOM_ONLY) ),
        _seltype(seltype),
        _nServerTypes( nServerTypes )
{
    if ( QueryError() != NERR_Success )
        return;

    Enable( FALSE );
    Show( FALSE );
}

VOID LM_OLLB::FillAllInfo( BROWSE_DOMAIN_ENUM *pEnumDomains,
                           SERVER1_ENUM       *pEnumServers,
                           const TCHAR        *pszSelection )
{
    UIASSERT( !IsEnabled() );
    UIASSERT( pEnumDomains != NULL );

    //
    //  Since BROWSE_DOMAIN_ENUM will always return a
    //  *sorted* list of domains, we can temporarily
    //  remove the LBS_SORT style from the listbox.
    //  This will eliminate a large number of client-
    //  server transitions as items are added to the
    //  listbox.
    //

    ULONG style = QueryStyle();
    SetStyle( style & ~LBS_SORT );

    //
    //  Add the domains to the listbox.
    //

    const BROWSE_DOMAIN_INFO * pbdi;

    while( ( pbdi = pEnumDomains->Next() ) != NULL )
    {
        AddDomain( pbdi->QueryDomainName(), NULL );
    }

    //
    //  Restore the original style bits.
    //

    if( style & LBS_SORT )
    {
        SetStyle( QueryStyle() | LBS_SORT );
    }

    INT iSelection = -1;
    if (  ( pszSelection != NULL && pszSelection[0] != TCH('\0') )
       && ( (iSelection = FindItem( pszSelection, NULL )) >= 0 )
       )
    {
        SelectItem( iSelection );

        //
        // Expand the selected domain if we need servers only
        // pEnumServers should be NULL if we are not selecting servers.
        //
        if ( pEnumServers != NULL )
        {
            UIASSERT(    ( _seltype == SEL_SRV_ONLY )
                      || ( _seltype == SEL_SRV_EXPAND_LOGON_DOMAIN ) )

            SERVER1_ENUM_ITER sei1( *pEnumServers );
            const SERVER1_ENUM_OBJ * psi1;

            while ( ( psi1 = sei1()) != NULL )
            {
                AddServer( pszSelection,
                           psi1->QueryName(),
                           psi1->QueryComment() );
            }
            SetTopIndex( iSelection );
        }
    }
    else
    {
        SelectItem( 0 );

        // Since pszSelection is empty, that means we should
        // ignore pEnumServers since it should be NULL.
    }

}

/*
 *  LM_OLLB::FillDomains
 *
 *  This method adds the domains to the listbox by calling AddDomain
 *  and AddIdempDomain.  Then, calls SelectItem to select the logon
 *  domain.
 *
 *  Parameters:
 *      maskDomainSources               - Set of one or more BROWSE_*_DOMAIN[S]
 *                                        flags.  This tells BROWSE_DOMAIN_ENUM
 *                                        where to get the domains for its
 *                                        list.
 *
 *      pszDefaultSelection             - The domain name to use as a default
 *                                        selection.  If NULL or doesn't exist
 *                                        in the list, then the first item
 *                                        is selected.
 *
 *  Return value:
 *      An error code, which is NERR_Success on success.
 *
 *  Assumptions:
 *      Wksta must be started and user must be logged on.
 *
 *      BROWSE_DOMAIN_ENUM returns domains in sorted order.
 */

APIERR LM_OLLB::FillDomains( ULONG maskDomainSources,
                             const TCHAR * pszDefaultSelection )
{
    //
    //  Create our domain enumerator.  The act of constructing
    //  this object causes a flurry of API madly trying to
    //  enumerate various domains.
    //

    BROWSE_DOMAIN_ENUM enumDomains( maskDomainSources );

    APIERR err = enumDomains.QueryError();

    if( err == NERR_Success )
    {
        //
        //  Since BROWSE_DOMAIN_ENUM will always return a
        //  *sorted* list of domains, we can temporarily
        //  remove the LBS_SORT style from the listbox.
        //  This will eliminate a large number of client-
        //  server transitions as items are added to the
        //  listbox.
        //

        ULONG style = QueryStyle();
        SetStyle( style & ~LBS_SORT );

        //
        //  Add the domains to the listbox.
        //

        const BROWSE_DOMAIN_INFO * pbdi;

        while( ( pbdi = enumDomains.Next() ) != NULL )
        {
            AddDomain( pbdi->QueryDomainName(), NULL );
        }

        //
        //  Restore the original style bits.
        //

        SetStyle( style );
    }

    if( ( err == NERR_Success ) && ( QueryCount() > 0 ) )
    {
        //
        //  See if any specified domain exists.  If so, select
        //  it.  Otherwise, if the logon domain is in the list,
        //  select it.  Otherwise, select item #0.
        //

        INT iSelection = -1;

        if( pszDefaultSelection != NULL )
        {
            iSelection = FindItem( pszDefaultSelection, NULL );
        }

        if( iSelection < 0 )
        {
            const BROWSE_DOMAIN_INFO * pbdi;
            if ( _seltype == SEL_SRV_ONLY )
                pbdi = enumDomains.FindFirst( BROWSE_WKSTA_DOMAIN );
            else
                pbdi = enumDomains.FindFirst( BROWSE_LOGON_DOMAIN );

            if( pbdi != NULL )
            {
                iSelection = FindItem( pbdi->QueryDomainName(), NULL );
            }
        }

        if( iSelection < 0 )
        {
            iSelection = 0;
        }

        SelectItem( iSelection );
    }

    return err;

}


/*
 *  LM_OLLB::FillServers
 *
 *  Calls AddServer for every visible server of the given domain.
 *
 *  Parameters:
 *      pszDomain           The domain of interest
 *      pcServersAdded      Pointer to location receiving the number
 *                          of servers that were added by calling
 *                          AddServer.  *pusServerAdded is always valid
 *                          on return from this function, regardless
 *                          of the error code.  This is because an
 *                          error may occur in the middle of adding
 *                          servers.
 *
 *  Return value:
 *      An error code, which is NERR_Success on success.
 *
 */

APIERR LM_OLLB::FillServers( const TCHAR * pszDomain, UINT * pcServersAdded )
{
    *pcServersAdded = 0;

    AUTO_CURSOR autocur;

    //  CODEWORK.  Change the SERVER1_ENUM constructor so that the following
    //  cast can be removed.
    SERVER1_ENUM se1( NULL, (TCHAR *)pszDomain, _nServerTypes );

    APIERR usErr = se1.GetInfo();
    if ( usErr != NERR_Success )
    {
        return usErr;
    }


    //  Call AddServer for each server

    SERVER1_ENUM_ITER sei1( se1 );
    const SERVER1_ENUM_OBJ * psi1;

    while ( ( psi1 = sei1()) != NULL )
    {
        if ( AddServer( pszDomain,
                        psi1->QueryName(),
                        psi1->QueryComment() ) >= 0 )  // Server is added
        {
            (*pcServersAdded)++;
        }
    }

    return NERR_Success;
}


//
//  CODEWORK:
//
//  We now fill the listbox with the BROWSE_DOMAIN_ENUM enumerator.
//  Since the domains returned by this enumerator are all unique
//  (no duplicate) we no longer need AddIdempDomain.  We'll keep
//  around (#ifdef'd-out) just incase we need to revisit this
//  "domain comment" thang sometime in the future.
//

#if 0

/*
 *  LM_OLLB::AddIdempDomain
 *
 *  This method idempotently adds a domain to the listbox.  It returns
 *  the index of the domain.
 *
 *  Parameters:
 *      pszDomain               Pointer to domain name
 *      pszComment              Pointer to domain comment
 *
 *  Return value:
 *      Index of the given domain, or
 *      a negative value on failure.
 *
 *  Caveats:
 *      NOTE.  The domain comment is currently not used.  Although
 *      it is handled correctly from this function, all callers
 *      pass in NULL.  Is there a domain comment?  Will there ever be?
 *      If so, the callers should change.
 *
 */

INT LM_OLLB::AddIdempDomain( const TCHAR * pszDomain, const TCHAR * pszComment )
{
    INT iDomain = FindItem( pszDomain, NULL );

    if ( iDomain >= 0 )
    {
        //  Domain already exists

        //  CODEWORK.  Thor time frame.  Add the given comment if the
        //  found item, for some reason, does not have a comment.  (For
        //  efficiency, first make sure that pszComment specifies a comment.)
        //  However, don't replace an existing comment if there is one,
        //  even if the two comments differ.

        return iDomain;
    }

    return AddDomain( pszDomain, pszComment );
}

#endif


/*
 *  LM_OLLB::OnUserAction
 *
 *  This method is a virtual replacement of CONTROL_WINDOW::OnUserAction.
 *  It handles double clicks of domains to expand and collapse these.
 *
 *  Parameters:
 *      lParam      The message parameter (see CONTROL_WINDOW::OnUserAction)
 *
 *  Return value:
 *      Error code, which is NERR_Success on success.
 *
 */

APIERR LM_OLLB::OnUserAction( const CONTROL_EVENT & e )
{
    //  This method handles double clicks of domains

    if ( e.QueryCode() == LBN_DBLCLK )
    {
        INT i = QueryCurrentItem();
        UIASSERT( i >= 0 );                 // an item must be selected since
                                            // one was double clicked on

        OLLB_ENTRY * pollbe = QueryItem( i );
        UIASSERT( pollbe != NULL );         // i should be a valid item

        if ( pollbe->QueryType() == OLLBL_DOMAIN )
        {
            //  Toggle domain.
            return ToggleDomain( i );
        }

        return NERR_Success;

    }


    //  Call parent class for all other messages

    return OUTLINE_LISTBOX::OnUserAction( e );
}


/*******************************************************************

    NAME:       LM_OLLB::ToggleDomain

    SYNOPSIS:   calls ExpandDomain or CollapseDomain depending on the
                current state of the currently selected domain.

    ENTRY:      iDomain - The index of the domain to be toggled.

    RETURNS:
        Error code, which is NERR_Success on success.

    NOTES:

    HISTORY:
        beng        21-Aug-1991     Removed LC_CURRENT_ITEM magic number

********************************************************************/

APIERR LM_OLLB::ToggleDomain( INT iDomain )
{
    OLLB_ENTRY * pollbe = QueryItem( iDomain );

    UIASSERT( pollbe != NULL );
    if ( pollbe->QueryType() != OLLBL_DOMAIN )
    {
        UIASSERT( !SZ("iDomain must specify the index of a domain") );
        return ERROR_INVALID_PARAMETER;
    }

    if ( pollbe->IsExpanded())
        return CollapseDomain( iDomain );

    return ExpandDomain( iDomain );
}


/*******************************************************************

    NAME:       LM_OLLB::ExpandDomain

    SYNOPSIS:   Expands a domain.  On success, also selects it.

    ENTRY:      iDomain - Specifies the index of the domain to be expanded.

    RETURNS:
        An error code, which is NERR_Success on success.

    NOTES:

    HISTORY:
        beng        21-Aug-1991     Removed LC_CURRENT_ITEM magic number
        Yi-HsinS    20-Dec-1992     Adjust the listbox so that expanded
                                    items shows up

********************************************************************/

APIERR LM_OLLB::ExpandDomain( INT iDomain )
{
    // if constructed as DOMAIN ONLY, dont expand
    if (_seltype == SEL_DOM_ONLY)
        return(NERR_Success) ;

    OLLB_ENTRY * pollbe = QueryItem( iDomain );

    UIASSERT( pollbe != NULL );
    if ( pollbe->QueryType() != OLLBL_DOMAIN )
    {
        UIASSERT( !SZ("iDomain must specify the index of a domain") );
        return ERROR_INVALID_PARAMETER;
    }

    if ( pollbe->IsExpanded())
    {
        //  domain is already expanded; select the item, and return with
        //  success
        SelectItem( iDomain );
        return NERR_Success;
    }

    SetRedraw( FALSE );

    UINT cServersAdded = 0;

    APIERR err = FillServers( pollbe->QueryDomain(), &cServersAdded );

    SetRedraw( TRUE );
    if ( cServersAdded > 0 )
    {
        Invalidate( TRUE );
    }

    if ( ( err == NERR_Success ) && ( cServersAdded > 0 ) )
    {
        // Adjust the listbox according to how many servers are added
        // Warning: The following is a problem when LM_OLLB becomes
        //          LBS_OWNERDRAWVARIABLE with multi-line LBIs

        XYDIMENSION xydim = QuerySize();
        INT nTotalItems = xydim.QueryHeight()/QuerySingleLineHeight();

        INT nTopIndex = QueryTopIndex();
        INT nBottomIndex = nTopIndex + nTotalItems - 1;

        if ( iDomain >= nTopIndex && iDomain <= nBottomIndex )
        {
            if ( cServersAdded >= (UINT) nTotalItems )
            {
                SetTopIndex( iDomain );
            }
            else
            {
                INT n = iDomain + cServersAdded;
                if ( n > nBottomIndex )
                {
                    SetTopIndex( nTopIndex + ( n - nBottomIndex ) );
                }
            }
        }
        else
        {
            SetTopIndex( iDomain );
        }
    }

    return err;
}


/*******************************************************************

    NAME:       LM_OLLB::CollapseDomain

    SYNOPSIS:   Collapses a given domain.  On success, also selects it.

    ENTRY:      iDomain - Specifies the index of the domain to be expanded.

    RETURNS:
        An error code, which is NERR_Success on success.

    NOTES:

    HISTORY:
        beng        21-Aug-1991     Removed LC_CURRENT_ITEM magic number

********************************************************************/

APIERR LM_OLLB::CollapseDomain( INT iDomain )
{
    // if constructed as DOMAIN ONLY, this becomes no-op
    if (_seltype == SEL_DOM_ONLY)
        return(NERR_Success) ;

    OLLB_ENTRY * pollbe = QueryItem( iDomain );

    //  We assert (( iDomain < 0 ) iff ( pollbe == NULL )).
    UIASSERT( ( iDomain < 0 && pollbe == NULL ) ||
              ( iDomain >= 0 && pollbe != NULL ));
    if ( iDomain < 0 || pollbe == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( pollbe->QueryType() != OLLBL_DOMAIN )
    {
        UIASSERT( !SZ("iDomain must specify the index of a domain") );
        return ERROR_INVALID_PARAMETER;
    }

    //  Change the expanded state of the listbox item to "not expanded"
    if ( ! pollbe->IsExpanded())
    {
        //  Select the item, and then return.
        SelectItem( iDomain );
        return NERR_Success;
    }

    //  Now, we know we'll take some action which may take a little time.
    //  Hence, let AUTO_CURSOR kick in.
    AUTO_CURSOR autocur;

    SetRedraw( FALSE );
    SetDomainExpanded( iDomain, FALSE );

    //  Set iNext to the next item in the listbox.  This item, if any, is
    //  either another domain, or a server in the domain.
    INT iNext = iDomain + 1;
    BOOL fDeletedAny = FALSE;
    while ( ( pollbe = QueryItem( iNext )) != NULL &&
            pollbe->QueryType() == OLLBL_SERVER )
    {
        DeleteItem( iNext );
        fDeletedAny = TRUE;
    }

    SetRedraw( TRUE );
    if ( fDeletedAny )
    {
        Invalidate( TRUE );
    }

    //  To make sure that the domain is indeed in view in the listbox,
    //  select it .
    SelectItem( iDomain );

    return NERR_Success;
}


/*******************************************************************

    NAME:       LM_OLLB::CD_Char

    SYNOPSIS:   We catch the '+' and '-' keys to expand and collapse
                the domain if the current selection is a domain.

    ENTRY:      wch      - character typed
                nLastPos -  position in lb

    EXIT:

    RETURNS:

    HISTORY:
        Johnl       21-Jun-1991 Created
        beng        16-Oct-1991 Win32 conversion

********************************************************************/

INT LM_OLLB::CD_Char( WCHAR wch, USHORT nLastPos )
{
    if ( wch == (WCHAR) TCH('+') || wch == (WCHAR) TCH('-') )
    {
        OLLB_ENTRY * pollbe = QueryItem( nLastPos );

        if ( pollbe != NULL && pollbe->QueryType() == OLLBL_DOMAIN )
        {
            APIERR  err = NERR_Success ;
            if ( wch == (WCHAR)TCH('-') && pollbe->IsExpanded() )
            {
                err = CollapseDomain() ;
            }
            else if ( wch == (WCHAR) TCH('+') && !pollbe->IsExpanded() )
            {
                err = ExpandDomain() ;
            }

            if ( err != NERR_Success )
                MsgPopup( QueryOwnerHwnd(), err, MPSEV_ERROR ) ;

            return -2 ;
        }
    }

    return OUTLINE_LISTBOX::CD_Char( wch, nLastPos );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\hierlb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    FILE HISTORY:
        kevinl      12-Oct-1991     Created
        kevinl      05-Nov-1991     Code Review changes attended by:
                                        DavidHov, Keithmo, o-simop
        Yi-HsinS    09-Nov-1992	    Added DeleteChildren()

*/

#include "pchapplb.hxx"   // Precompiled header

#define MIN(a,b)        (( a < b ) ? a : b )
#define MAX(a,b)        (( a < b ) ? b : a )

/**********************************************************************

   NAME:        HIER_LISTBOX::HIER_LISTBOX

   SYNOPSIS:    class constructor

   HISTORY:
      kevinl    12-Oct-1991     Created

**********************************************************************/

HIER_LISTBOX::HIER_LISTBOX( OWNER_WINDOW * powin, CID cid, BOOL fReadOnly,
                           enum FontType font, BOOL fSort )
    :   BLT_LISTBOX( powin, cid, fReadOnly, font ),
       _fSort( fSort )
{
    if ( QueryError() != NERR_Success )
        return;

    HIER_LBI::SetDestroyable( TRUE );

    _fMultSel = LIST_CONTROL::IsMultSel();

    DBGEOL("Extended Sel " << _fMultSel);
}


/**********************************************************************

   NAME:        HIER_LISTBOX::HIER_LISTBOX

   SYNOPSIS:    class constructor

   HISTORY:
      kevinl    12-Oct-1991 Created
      beng      22-Apr-1992 Classname arg elided

**********************************************************************/

HIER_LISTBOX::HIER_LISTBOX( OWNER_WINDOW * powin, CID cid,
                            XYPOINT xy, XYDIMENSION dxy,
                            ULONG flStyle,
                            BOOL fReadOnly,
                            enum FontType font,
                            BOOL fSort )
    :   BLT_LISTBOX( powin, cid, xy, dxy, flStyle & ~LBS_SORT,
                     fReadOnly, font ),
       _fSort( fSort )
{
    if ( QueryError() != NERR_Success )
        return;

    HIER_LBI::SetDestroyable( TRUE );

    _fMultSel = LIST_CONTROL::IsMultSel();

    DBGEOL("Extended Sel " << _fMultSel);
}


/**********************************************************************

   NAME:        HIER_LISTBOX::~HIER_LISTBOX

   SYNOPSIS:    class destructor

   HISTORY:
      kevinl    12-Oct-1991     Created

**********************************************************************/

HIER_LISTBOX::~HIER_LISTBOX()
{
    DeleteAllItems();           // Remove the shadow class
}


/**********************************************************************

   NAME:        HIER_LISTBOX::AddItem

   SYNOPSIS:    add the specified item to the listbox

   ENTRY:       HIER_LBI * phlbi          Node to add
                 HIER_LBI * phlbiParent    Parent of phlbi
                 BOOL fSaveSelection      Should we preserve the selection?

   RETURN:      INT - the index of the item in the listbox, -1 on
                 error or 0 if the item is being added as a hidden item.

   HISTORY:
      kevinl    12-Oct-1991     Created
      Johnl     29-Jan-1992     Adding a hidden item is now non-fatal

**********************************************************************/

INT HIER_LISTBOX::AddItem( HIER_LBI * phlbi, HIER_LBI * phlbiParent, BOOL fSaveSelection )
{
    if ( phlbi == NULL )
        return -1;          //  Refuse to add NULL item.  This way, we can
                            //  guarantee that all items in the listbox
                            //  will be non-NULL.

    if ( phlbi->QueryError() != NERR_Success )
    {
        //  Refuse to add an item that was not constructed correctly.
        //  This way, we can guarantee that all items in the listbox
        //  will be correctly constructed.
        //  Before returning, delete the item.
        //
        delete phlbi;
        return -1;
    }

    INT dSel;

    if ( fSaveSelection )
    {
        if ( _fMultSel )
        {
            //
             // Preserve Selection State
             //
             DBGEOL("Preserve Selection not supported!");
        }
        else
            dSel = LIST_CONTROL::QueryCurrentItem();
    }

    /* AddNode only returns -1 if the item is hidden
     */
    INT i = _lbit.AddNode( phlbiParent, phlbi, _fSort );    // Modify the tree
    if ( i >= 0 )       // Are we visible?
    {
        if ( LIST_CONTROL::InsertItemData( i, phlbi ) < 0 ) // Add the LBI
        {
             delete phlbi;                              // Clean up
             return -1;
        }

         if ( fSaveSelection )     // Did the selection change?
         {
             if ( _fMultSel )
             {
                //
                 // Restore Selection State
                 //
                 DBGEOL("Restore Selection not supported!");
             }
             else
             {
                 if ( i <= dSel )
                     LIST_CONTROL::SelectItem( dSel + 1 );
                 else
                     LIST_CONTROL::SelectItem( dSel );
             }
         }
    }

    /* Map the case of adding a hidden item to a success
     */
    return ( i==-1 ? 0 : i) ;
}

/**********************************************************************

   NAME:        HIER_LISTBOX::AddSortedItems

   SYNOPSIS:    add the specified list of items to the listbox

   ENTRY:       HIER_LBI * * pphlbi          Node to add
                HIER_LBI * phlbiParent       Parent of phlbi
                BOOL fSaveSelection          Should we preserve the selection?

   RETURN:      INT - the index of the item in the listbox, -1 on
                 error or 0 if the item is being added as a hidden item.

   NOTES:       The list of items are added under phlbiParent as a whole block
                without regard to sorting order.  There should be no children
                under phlbiParent and all children should be added with this
                call!

   HISTORY:
      Johnl    26-Jan-1993     Created

**********************************************************************/

void HIER_LISTBOX::AddSortedItems( HIER_LBI * * pphlbi,
                                   INT          cItems,
                                   HIER_LBI *   phlbiParent,
                                   BOOL         fSaveSelection )
{
    INT dSel;
    if ( fSaveSelection )
    {
        if ( _fMultSel )
        {
            //
             // Preserve Selection State
             //
             DBGEOL("Preserve Selection not supported!");
        }
        else
            dSel = LIST_CONTROL::QueryCurrentItem();
    }

    for ( INT i = 0 ; i < cItems ; i++ )
    {
        HIER_LBI * phlbi = *pphlbi++ ;

        if ( phlbi == NULL )
            continue ;          //  Refuse to add NULL item.  This way, we can
                                //  guarantee that all items in the listbox
                                //  will be non-NULL.

        if ( phlbi->QueryError() != NERR_Success )
        {
            //  Refuse to add an item that was not constructed correctly.
            //  This way, we can guarantee that all items in the listbox
            //  will be correctly constructed.
            //  Before returning, delete the item.
            //
            delete phlbi;
            continue ;
        }


        /* AddNode only returns -1 if the item is hidden
         */
        INT j = _lbit.AddNode( phlbiParent, phlbi, FALSE );    // Modify the tree
        if ( j >= 0 )       // Are we visible?
        {
            if ( LIST_CONTROL::InsertItemData( j, phlbi ) < 0 ) // Add the LBI
            {
                 delete phlbi;                              // Clean up
                 continue ;
            }

            if ( j <= dSel )
                dSel++;
        }
    }

    if ( fSaveSelection )
    {
        if ( _fMultSel )
        {
            //
            // Restore Selection State
            //
            DBGEOL("Restore Selection not supported!");
        }
        else
            LIST_CONTROL::SelectItem( dSel );

    }
}

/**********************************************************************

   NAME:        HIER_LISTBOX::DeleteItem

   SYNOPSIS:    delete the specified item from the listbox

   ENTRY:       INT i - item to be deleted
                 BOOL fSaveSelection      Should we preserve the selection?

   RETURN:      The return value is a count of the strings remaining in the
                list. The return value is LB_ERR if an error occurs.

   HISTORY:
      kevinl    12-Oct-1991     Created

**********************************************************************/

INT HIER_LISTBOX::DeleteItem( INT i, BOOL fSaveSelection )
{
    INT dSel = 0;
    INT dTopIndex = 0;
    BOOL fIsChild = FALSE;
    HIER_LBI * phlbiDeleted;
    HIER_LBI * phlbi;

    if ( fSaveSelection )
    {
        SetRedraw( FALSE );

        if ( _fMultSel )
        {
            //
             // Preserve Selection State
             //
             DBGEOL("Preserve Selection not supported!");
        }
        else
            dSel = LIST_CONTROL::QueryCurrentItem();

         dTopIndex = LIST_CONTROL::QueryTopIndex();

         phlbi = (HIER_LBI *)QueryItem( dTopIndex );

         phlbiDeleted = (HIER_LBI *)QueryItem( i );

         if ( phlbi )
             fIsChild = phlbi->IsParent( phlbiDeleted );
    }

    CollapseItem( i, FALSE );

    INT dcount = LIST_CONTROL::DeleteItem( i );   // Tell windows to delete
                                                   // the item

    if ( fSaveSelection && dcount != LB_ERR )
    {
         if ( i <= dSel )  // selection change?
         {
            if ( _fMultSel )
            {
                //
                // Restore Selection State
                //
                DBGEOL("Restore Selection not supported!");
            }
            else
                LIST_CONTROL::SelectItem( (dSel == i) ? -1 : MAX( 0, (dSel - 1) ) );
         }

         LIST_CONTROL::SetTopIndex( MIN( ((fIsChild) ? i : dTopIndex), (dcount - 1) ) );

         SetRedraw( TRUE );

         Invalidate();
    }

    return dcount;
}


/**********************************************************************

   NAME:        HIER_LISTBOX::AddChildren

   SYNOPSIS:    Enumerate the children of this node and add them to the
                 listbox.

   ENTRY:       phlbi - the HIER_LBI for whom we should enumerate the
                        children and add to the listbox

   RETURN:      NERR_Success on success otherwise an error is returned.

   HISTORY:
      kevinl    23-Oct-1991     Created

**********************************************************************/

APIERR HIER_LISTBOX::AddChildren( HIER_LBI * phlbi )
{
    UNREFERENCED( phlbi );
    return NERR_Success;
}


/**********************************************************************

   NAME:        HIER_LISTBOX::RefreshChildren

   SYNOPSIS:    Called to alert the listbox writer that phlbi is
                about to be expanded but it already has data.  So,
                 if the implementor wishes, they may update the tree
                 at this point.

   ENTRY:       phlbi - the HIER_LBI for whom we should refresh the
                        children and adjust the listbox

   HISTORY:
      kevinl    23-Oct-1991     Created

**********************************************************************/

VOID HIER_LISTBOX::RefreshChildren( HIER_LBI * phlbi )
{
    UNREFERENCED( phlbi );
    return;
}

/**********************************************************************

   NAME:        HIER_LISTBOX::DeleteChildren

   SYNOPSIS:    Collapse the given node and delete its children

   ENTRY:       phlbi - the HIER_LBI for whom we should delete the children

   RETURN:

   HISTORY:
       Yi-HsinS	09-Nov-1992     Created

**********************************************************************/

VOID HIER_LISTBOX::DeleteChildren( HIER_LBI * phlbi )
{
    if ( phlbi == NULL )
        return;

    // Collapse the item if it is not already collapsed
    CollapseItem( phlbi, FALSE );

    // Delete all children of the given HIER_LBI
    phlbi->AbandonAllChildren();

}

/**********************************************************************

   NAME:        HIER_LISTBOX::CollapseItem

   SYNOPSIS:    Collapse the item in the listbox (Don't show children)

   ENTRY:       INT i - item to be collapsed

   HISTORY:
      kevinl    23-Oct-1991     Created

**********************************************************************/

VOID HIER_LISTBOX::CollapseItem( INT i, BOOL fInvalidate )
{
    CollapseItem( (HIER_LBI *) QueryItem( i ), fInvalidate );
}


/**********************************************************************

   NAME:        HIER_LISTBOX::CollapseItem

   SYNOPSIS:    Collapse the item in the listbox (Don't show children)

   ENTRY:       HIER_LBI * phlbi - item to be collapsed

   HISTORY:
      kevinl    23-Oct-1991     Created

**********************************************************************/

VOID HIER_LISTBOX::CollapseItem( HIER_LBI * phlbi, BOOL fInvalidate )
{
    if ( phlbi == NULL )
        return;

    if ( phlbi->QueryExpanded() )       // Is it currently expanded?
    {
         //
         // Collapse node.
         //
         INT index = phlbi->QueryLBIndex() + 1; // Index of first child

         HIER_LBI::SetDestroyable( FALSE );     // Don't delete the lbi's

         if ( fInvalidate )
             SetRedraw( FALSE );                // don't flicker

         for (UINT count = phlbi->_dDescendants - 1; count; count-- )
             LIST_CONTROL::DeleteItem( index ); // remove the children

         //
         // Adjust the number of viewed children
         //
         phlbi->AdjustDescendantCount( -1 * (phlbi->_dDescendants - 1) );

         phlbi->_dDescendants = 1;              // Reset the counter


         if ( fInvalidate )
         {
             SetRedraw( TRUE );                 // O.k. to redraw
             Invalidate();                      // Force a repaint
         }

         HIER_LBI::SetDestroyable( TRUE );      // o.k. to delete lbi's

        phlbi->SetExpanded( FALSE );            // Node isn't expanded
    }
}


/**********************************************************************

   NAME:        HIER_LISTBOX::ExpandItem

   SYNOPSIS:    Expand the item in the listbox

   ENTRY:       INT i - item to be expanded

   RETURN:      NERR_Success on success otherwise the APIERR returned
                 from AddChildren

   HISTORY:
      kevinl    23-Oct-1991     Created

**********************************************************************/

APIERR HIER_LISTBOX::ExpandItem( INT i )
{
    return ExpandItem( (HIER_LBI *)QueryItem( i ) );
}

/**********************************************************************

   NAME:        HIER_LISTBOX::ExpandItem

   SYNOPSIS:    Expand the item in the listbox

   ENTRY:       HIER_LBI * phlbi - item to be expanded

   RETURN:      NERR_Success on success otherwise the APIERR returned
                 from AddChildren

   HISTORY:
      kevinl    23-Oct-1991     Created

**********************************************************************/

APIERR HIER_LISTBOX::ExpandItem( HIER_LBI * phlbi )
{
    if ( phlbi == NULL )
        return ERROR_INVALID_PARAMETER;

    phlbi->SetExpanded( TRUE );    // Set to expanded now, so that any
                                   // AddItems will be displayed.

    if ( phlbi->HasChildren() ) // Does this node have children?
    {
         //
         // Expand node.
         //
         SetRedraw( FALSE );            // Don't allow screen flicker

         RefreshChildren( phlbi );      // callout to allow refresh to work.

         INT dStart = phlbi->QueryLBIndex() + 1;  // Index for first child.

         //
         // Add all of the children on phlbi to the listbox starting
         // at index dStart
         //
         INT dEnd = ExpandChildren( dStart, phlbi->_phlbiChild );

         phlbi->AdjustDescendantCount( dEnd - dStart );  // Number of children
                                                         // added.

         phlbi->_dDescendants = dEnd - dStart + 1;       // Proper count.

         SetRedraw( TRUE );             // O.k to repaint

         Invalidate();                  // Force a repaint

    }
    else
    {
        APIERR err;

         err = AddChildren( phlbi );            // callout to get children

         if ( err != NERR_Success )
         {
            phlbi->SetExpanded( FALSE );        // Not expanded
             return err;
         }
    }

    if ( phlbi->_phlbiChild == NULL )           // No Children were added
        phlbi->SetExpanded( FALSE );            // Not expanded

    return NERR_Success;
}


/**********************************************************************

   NAME:        HIER_LISTBOX::ExpandChildren

   SYNOPSIS:    Adds all of the children of phlbi to the listbox in
                 Depth-first order.  Starting at listbox index dIndex.

   ENTRY:       INT dIndex - index of first child in listbox
                 HIER_LBI * phlbi - node to add.

   RETURNS:      INT - Last index.

   HISTORY:
      kevinl    23-Oct-1991     Created

**********************************************************************/

INT HIER_LISTBOX::ExpandChildren( INT dIndex, HIER_LBI * phlbi )
{
    HIER_LBI * phlbiSave = phlbi;       // Save first child.
    do
    {
         LIST_CONTROL::InsertItemData( dIndex++, phlbi );       // add to LB

         //
         // Does the node have children and are they currently visible?
         //
         // if so, expand this nodes children.
         //
        if ( phlbi->_phlbiChild && phlbi->QueryExpanded() )
            dIndex = ExpandChildren( dIndex, phlbi->_phlbiChild );

        phlbi = phlbi->_phlbiRight;     // move to the next sibling.
    }
    while ( phlbiSave != phlbi );       // Stop when we are back at the first
                                        // child.

    return dIndex;                      // return the last index.
}


/**********************************************************************

   NAME:        HIER_LISTBOX::OnDoubleClick

   SYNOPSIS:    This method will either expand or collapse the
                 selected HIER_LBI, based upon whether or not it
                 is currently expanded.

   ENTRY:       phlbi - the HIER_LBI that the user double clicked.

   HISTORY:
      kevinl    23-Oct-1991     Created
      YiHsinS   17-Dec-1992     Adjust the listbox after ExpandItem

**********************************************************************/

VOID HIER_LISTBOX::OnDoubleClick( HIER_LBI * phlbi )
{
    AUTO_CURSOR cur;                    // Hourglass during expand/Collapse

    if ( phlbi == NULL )
        return;

    if ( phlbi->QueryExpanded() )       // Do I have visible Children?
    {
        // See how many items will fit into the listbox
        // Warning: This will be a problem if HIER_LISTBOX becomes
        //          LBS_OWNERDRAWVARIABLE with Multi-line LBIs

        XYDIMENSION xydim = QuerySize();
        INT nTotalItems = xydim.QueryHeight()/QuerySingleLineHeight();

        INT nCurrentIndex = QueryCurrentItem();

        CollapseItem( phlbi );          // Yes, then collapse

        if ( QueryCount() <= nTotalItems )
        {
            //
            // Show all items if all of them fit into the listbox
            //
            SetTopIndex( 0 );
        }
        else if (  ( nCurrentIndex == QueryTopIndex() ) 
                && ( nCurrentIndex == QueryCount() - 1 )
                )
        {
            //
            // If the only visible item is the current item, 
            // then make more items visible.
            //

            if ( nCurrentIndex - ( nTotalItems - 1) > 0 )  
                SetTopIndex ( nCurrentIndex - ( nTotalItems - 1) );
            else
                SetTopIndex ( 0 );
        }
    }
    else
    {
        ExpandItem( phlbi );            // No, then expand

        // See how many items will fit into the listbox
        // Warning: This will be a problem if HIER_LISTBOX becomes
        //          LBS_OWNERDRAWVARIABLE with Multi-line LBIs

        INT nChildrenAdded = phlbi->QueryDescendants() - 1;
        if ( nChildrenAdded > 0 )
        {
            XYDIMENSION xydim = QuerySize();
            INT nTotalItems = xydim.QueryHeight()/QuerySingleLineHeight();

            INT nTopIndex = QueryTopIndex();
            INT nBottomIndex = nTopIndex + nTotalItems - 1;
            INT nCurrentIndex = QueryCurrentItem();

            if ( nCurrentIndex >= nTopIndex && nCurrentIndex <= nBottomIndex )
            {
                if ( nChildrenAdded >= nTotalItems - 1 )
                {
                    SetTopIndex( nCurrentIndex );
                }
                else
                {
                    INT n = nCurrentIndex + nChildrenAdded;
                    if ( n > nBottomIndex )
                    {
                        SetTopIndex( nTopIndex + ( n - nBottomIndex ) );
                    }
                }
            }
            else
            {
                SetTopIndex( nCurrentIndex );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\lbnode.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    FILE HISTORY:
        kevinl      12-Oct-1991     Created
        kevinl      05-Nov-1991     Code Review changes attended by:
                                        DavidHov, Keithmo, o-simop
        Yi-HsinS    09-Nov-1992	    Added AbandonAllChildren()

*/

#include "pchapplb.hxx"   // Precompiled header


BOOL HIER_LBI::_fDestroyable = FALSE;


/*******************************************************************

    NAME:       HIER_LBI::HIER_LBI

    SYNOPSIS:   class constructor

    ENTRY:      fExpanded - Should this node show its' children.

    HISTORY:
        kevinl   12-Oct-1991  Created

********************************************************************/

HIER_LBI::HIER_LBI( BOOL fExpanded )
    : _phlbiParent( NULL ),
      _phlbiChild( NULL ),
      _phlbiLeft( this ),
      _phlbiRight( this ),
      _fShowChildren( fExpanded ),
      _dIndentPels( 0 ),
      _dDescendants( 1 )
{
    if ( QueryError() != NERR_Success )
        return;
}


/*******************************************************************

    NAME:       HIER_LBI::~HIER_LBI

    SYNOPSIS:   class destructor

    HISTORY:
        kevinl   12-Oct-1991  Created

********************************************************************/

HIER_LBI::~HIER_LBI()
{
    //
    // Delete all of the children of this node
    //
    while ( _phlbiChild != NULL )
        delete _phlbiChild;

    Abandon();                  // Disconnect the node from the tree
}


/*******************************************************************

    NAME:       HIER_LBI::SetDestroyable

    SYNOPSIS:   Set whether destroyable

    NOTES:
        This is a static member function.

    HISTORY:
        beng        29-Jun-1992 Outlined

********************************************************************/

VOID HIER_LBI::SetDestroyable( BOOL f )
{
    _fDestroyable = f;
}


/*******************************************************************

    NAME:       HIER_LBI::IsDestroyable

    SYNOPSIS:   Should the windows WM_DELETEITEM message also destruct
                this LBI?

    NOTES:
        This is a virtual member function.

    HISTORY:
        kevinl   05-Nov-1991  Created

********************************************************************/

BOOL HIER_LBI::IsDestroyable()
{
    return _fDestroyable;
}


/*******************************************************************

    NAME:       HIER_LBI::Adopt

    SYNOPSIS:   Add a child node.

    ENTRY:      phlbi  - Pointer to child node.
                fSort - Adopt in sorted order?

    RETURNS:    nothing; cannot fail.

    NOTES:      if fSort is set then the child is added according
                to the LBI's compare method otherwise the child is
                always added to the end of the sibling list.

    HISTORY:
        kevinl   12-Oct-1991  Stolen from REG_NODE

********************************************************************/

VOID HIER_LBI::Adopt( HIER_LBI * phlbi, BOOL fSort )
{
    UIASSERT( phlbi != NULL ) ;
    UIASSERT( phlbi->_phlbiRight == phlbi->_phlbiLeft );  // Assure that phlbi
    UIASSERT( phlbi->_phlbiRight == phlbi );               // has not been
                                                           // linked into the
                                                           // tree yet.

    if ( _phlbiChild )  // Do I have a child?
    {                    // Yes

         HIER_LBI * phlbiTemp = _phlbiChild;    // points to insertion point

        if ( fSort )
         {
             BOOL fAdd = FALSE;                 // Loop termination

             do
             {
                 //
                 // Three choices:
                 //    <0  -> phlbiTemp sorts before phlbi
                 //     0  -> phlbiTemp sorts the same as phlbi
                 //    >0  -> phlbiTemp sorts after phlbi
                 //
                 if ( phlbiTemp->Compare( phlbi ) < 0 )
                 {
                     phlbiTemp = phlbiTemp->_phlbiRight; // Move to next sibling
                 }
                 else
                     fAdd = TRUE;       // Found the proper insertion point

             }
             while ( (_phlbiChild != phlbiTemp) && !fAdd );

             //
             // Either Equal to the current LBI or it is Greater
             // than the current LBI, in any event we want to insert it
             // to the left of the current LBI pointed to by phlbiTemp
             //
         }

         //
         // If not sorted then phlbiTemp will equal _phlbiChild and this
         // will simply add the node to the end of the sibling list.
         //

         phlbi->_phlbiParent           = this ;
         phlbi->_phlbiRight            = phlbiTemp ;
         phlbi->_phlbiLeft             = phlbiTemp->_phlbiLeft ;
         phlbi->_phlbiLeft->_phlbiRight = phlbi ;
         phlbi->_phlbiRight->_phlbiLeft = phlbi ;

         if ( fSort && ( _phlbiChild == phlbiTemp) )    // First sibling
         {                                              // must change
             if ( phlbi->Compare( _phlbiChild ) < 0 )
                 _phlbiChild = phlbi;
         }
    }
    else
    {
        phlbi->_phlbiParent = this ;            // This is the first child.
        _phlbiChild = phlbi ;                   // Set the parent accordingly
    }

    phlbi->SetIndentLevel();                    // Initialize the indentation.

    phlbi->AdjustDescendantCount( 1 );          // Adjust the tree counters.
}

/*******************************************************************

    NAME:       HIER_LBI::AbandonAllChildren

    SYNOPSIS:   Remove all children of this HIER_LBI

    HISTORY:
        Yi-HsinS	09-Nov-1992	Created	

********************************************************************/
VOID HIER_LBI::AbandonAllChildren( VOID )
{
    while ( _phlbiChild != NULL )
        delete _phlbiChild;
}

/*******************************************************************

    NAME:       HIER_LBI::Abandon

    SYNOPSIS:   Remove a HIER_LBI's linkage to its parent
                and siblings.  It also adjusts the descendant count.

    HISTORY:
        kevinl   12-Oct-1991  Stolen from REG_NODE

********************************************************************/

VOID HIER_LBI::Abandon()
{
    HIER_LBI * phlbiSibling = NULL ;

    AdjustDescendantCount( -1 );                // Remove the node

    //  Delink this node from any siblings

    if ( _phlbiLeft != this )
    {
        phlbiSibling = _phlbiRight ;
        _phlbiRight->_phlbiLeft = _phlbiLeft ;
        _phlbiLeft->_phlbiRight = _phlbiRight ;
        _phlbiLeft = _phlbiRight = this ;
    }

    //  If this node anchors the parent's child chain, change it.

    if ( _phlbiParent )
    {
        if ( _phlbiParent->_phlbiChild == this )
            _phlbiParent->_phlbiChild = phlbiSibling ;
        _phlbiParent = NULL ;
    }
}


/*******************************************************************

    NAME:       HIER_LBI::QueryLBIndex

    SYNOPSIS:   Calculates the index of the given node in the listbox.

    RETURNS:    INT - the index that this node is in the listbox OR
                      -1 if an error was encountered.

    HISTORY:
        kevinl   23-Oct-1991  Created

********************************************************************/

INT HIER_LBI::QueryLBIndex( )
{
    HIER_LBI * phlbi = this;
    INT index = 0;

    while ( phlbi->_phlbiParent != NULL )               // Is this the ROOT?
    {
        //
        // Is this node the 1st sibling?
        //

         if ( phlbi->_phlbiParent->_phlbiChild == phlbi )
         {
             phlbi = phlbi->_phlbiParent;               // Move to parent

             if ( phlbi->_fShowChildren != TRUE )       // Is parent expanded?
                 return -1;                             // ERROR

             index++;
         }
         else
         {
             phlbi = phlbi->_phlbiLeft;                 // Move to left Sibling

             if ( phlbi->_fShowChildren )
                 index += phlbi->_dDescendants;         // Add descendant count
             else
                 index++;                               // Add 1 for the node
         }
    }

    return ( index - 1 );                               // Root is not displayed
}


/*******************************************************************

    NAME:       HIER_LBI::SetIndentLevel

    SYNOPSIS:   Calculates the indent level of this node and
                stores the value.

    EXIT:       The indent level is set

    HISTORY:
        kevinl   23-Oct-1991  Created

********************************************************************/

VOID HIER_LBI::SetIndentLevel()
{
    this->SetPelIndent( QueryIndentLevel() );
}

/*******************************************************************

    NAME:       HIER_LBI::QueryIndentLevel

    SYNOPSIS:   Calculates the indent level of this node

    RETURNS:    Returns the indent level

    EXIT:

    HISTORY:
        Yi-HsinS 04-Nov-1992   Created

********************************************************************/

INT HIER_LBI::QueryIndentLevel()
{
    INT ui = 0;                   // indent level

    //
    // Count the number of parents that this node has.  This number
    // corresponds to the indentation level.
    //
    for ( HIER_LBI * phlbi = this; phlbi->_phlbiParent; phlbi = phlbi->_phlbiParent )
        ui++;

    return ( ui - 1 );             // Save level  NOTE:
                                   // subtract the hidden root

}

/*******************************************************************

    NAME:       HIER_LBI::AdjustDescendantCount

    SYNOPSIS:   Each node has a descendant counter which corresponds to the
                number of visible children below this node.  This routine will
                walk up to the root or the first non-expanded parent and add
                iAdjustment to each of the parents descendant counter.

    ENTRY:      INT iAdjustment - value to add to each of the parents
                                  descendant counters.

    EXIT:       Each visible parent's descendant counter has been adjusted.

    HISTORY:
        kevinl   23-Oct-1991  Created

********************************************************************/

VOID HIER_LBI::AdjustDescendantCount( INT iAdjustment )
{
    HIER_LBI * phlbi = this;                    // Temp pointer

    while ( phlbi->_phlbiParent != NULL )       // Stop at root
    {
         phlbi = phlbi->_phlbiParent;           // Move up to next level
         if ( phlbi->QueryExpanded() )
             phlbi->_dDescendants += iAdjustment;
         else
             break;                             // Stop if parent not visible.
    }
}


/**********************************************************************

   NAME:        HIER_LBI::IsParent

   SYNOPSIS:    determines if the given node is a parent of this node.

   ENTRY:


   RETURN:


   HISTORY:
      kevinl    12-Oct-1991     Created

**********************************************************************/

BOOL HIER_LBI::IsParent( HIER_LBI * phlbiParent )
{
    if ( phlbiParent == NULL )
        return FALSE;                           // obviously not a parent

    HIER_LBI * phlbi = this;                    // Temp pointer

    while ( phlbi->_phlbiParent != NULL )       // Stop at root
    {
         phlbi = phlbi->_phlbiParent;           // Move up to next level
         if ( phlbi == phlbiParent )
             return TRUE;
    }

    return FALSE;
}


/**********************************************************************

    NAME:       HIER_LBI::SetPelIndent

    SYNOPSIS:   Sets the indentation value for the HIER_LBI, used in
                hierarchical listboxes.  This value is stored as pels.

    ENTRY:      ui - Level of indentation (0, 1, 2, ... )

    NOTES:      This is a virtual method which may be replaced in subclasses.

                THE DEFAULT INDENTATION THAT IS USED IS 20 PELS.  IF THIS
                IS NOT ADEQUATE, THEN DEFINE YOUR OWN METHOD TO OVERRIDE
                THIS ONE.

    HISTORY:
        kevinl      23-Oct-1991     Creation

**********************************************************************/

#define DEFAULT_INDENT 20

VOID HIER_LBI::SetPelIndent( UINT ui )
{
    _dIndentPels = ui * DEFAULT_INDENT;
}


/*******************************************************************

    NAME:       LBITREE::LBITREE

    SYNOPSIS:   class constructor

    HISTORY:
        kevinl   12-Oct-1991  Created

********************************************************************/

LBITREE::LBITREE()
{
    if ( QueryError() != NERR_Success )
        return;

    _hlbiRoot.SetExpanded();            // Show its' children.
}


/*******************************************************************

    NAME:       LBITREE::~LBITREE

    SYNOPSIS:   class destructor

    HISTORY:
        kevinl   12-Oct-1991  Created

********************************************************************/

LBITREE::~LBITREE()
{
    // Nothing to do
}


/*******************************************************************

    NAME:       LBITREE::AddNode

    SYNOPSIS:   Adds phlbiChild as a child of phlbiParent

    ENTRY:      phlbiParent - Node at which phlbiChild should be added.
                              If this is NULL then phlbiChild is added
                              to the Root.

                phlbiChild  - Node to add the the tree.

                fSort       - Should we add this node in sorted order?

    RETURNS:    INT - the index in the listbox at which the item is to be
                        inserted.

    HISTORY:
        kevinl   12-Oct-1991  Created

********************************************************************/

INT LBITREE::AddNode( HIER_LBI * phlbiParent, HIER_LBI * phlbiChild, BOOL fSort )
{
    UIASSERT( phlbiChild != NULL );

    if ( phlbiParent )
        phlbiParent->Adopt( phlbiChild, fSort );        // add to parent
    else
        _hlbiRoot.Adopt( phlbiChild, fSort );           // add to root

    return phlbiChild->QueryLBIndex();          // Return the index
}




HIER_LBI_ITERATOR::HIER_LBI_ITERATOR( HIER_LBI * phlbi, BOOL fChildIterator )
    : _phlbiStart( NULL ),
      _phlbiEnd( NULL )
{
    UIASSERT( phlbi != NULL );

    if ( fChildIterator )    // Iterate the children of this HIER_LBI
    {
       _phlbiStart = _phlbiEnd = phlbi->_phlbiChild;
    }
    else
    {
       _phlbiStart = _phlbiEnd = phlbi;
    }
}


HIER_LBI_ITERATOR::~HIER_LBI_ITERATOR()
{
    _phlbiStart = NULL;
    _phlbiEnd   = NULL;
}


HIER_LBI * HIER_LBI_ITERATOR::operator()()
{
    HIER_LBI * phlbiRet = _phlbiStart ? ( _phlbiStart = _phlbiStart->_phlbiRight ) : NULL;

    if ( _phlbiStart == _phlbiEnd )
        _phlbiStart = NULL;

    return phlbiRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\openfile.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
 *  openfile.cxx
 *      this module contains the code for the Open File Dialog
 *      Base Class.
 *
 *  FILE HISTORY:
 *      ChuckC      06-Oct-1991         Stole from server manager
 *      beng        05-Mar-1992         wsprintf removal
 *      KeithMo     11-Sep-1992         Added dire warnings for dangerous
 *                                      closings.
 *
 */

#include "pchapplb.hxx"   // Precompiled header


//
//  This mask contains the permissions bits for "dangerous" opens.
//  Before we attempt to close any file opened with any of these
//  permissions, we give the user an especially dire warning.
//
//  NOTE:  Some code in this module depends on the following relationship:
//
//         ACCESS_EXEC > ACCESS_CREATE > ACCESS_WRITE > ACCESS_READ
//

#define DANGER_MASK     (ACCESS_EXEC | ACCESS_CREATE | ACCESS_WRITE)

#define NORMAL_MASK     (ACCESS_EXEC | ACCESS_CREATE | ACCESS_WRITE | ACCESS_READ)
#define ABNORMAL_MASK   (ACCESS_DELETE | ACCESS_ATRIB | ACCESS_PERM)



/*******************************************************************

    NAME:       OPEN_DIALOG_BASE::OPEN_DIALOG_BASE

    SYNOPSIS:   OPEN_DIALOG_BASE class constructor.

    ENTRY:

    EXIT:

    HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.
        KeithMo     20-Aug-1991 Now inherits from PSEUDOSERVICE_DIALOG.
        KeithMo     20-Aug-1991 Now inherits from SRVPROP_OTHER_DIALOG.
        ChuckC      08-Oct-1991 Move to common place in applib, break
                                ties with previous parents.
        KeithMo     20-May-1992 Removed _nlsNotAvailable, uses "??" instead.
        beng        04-Aug-1992 Load dialog by ordinal

********************************************************************/
OPEN_DIALOG_BASE::OPEN_DIALOG_BASE( HWND  hwndOwner,
                                    UINT  idDialog,
                                    CID sltOpenCount,
                                    CID sltLockCount,
                                    CID pbClose,
                                    CID pbCloseAll,
                                    const TCHAR *pszServer,
                                    const TCHAR *pszBasePath,
                                    OPEN_LBOX_BASE *plbFiles )
  : DIALOG_WINDOW( idDialog, hwndOwner ),
    _sltOpenCount( this, sltOpenCount ),
    _sltLockCount( this, sltLockCount ),
    _pbClose     ( this, pbClose ),
    _pbCloseAll  ( this, pbCloseAll ),
    _pbOK        ( this, IDOK ),
    _nlsServer   ( pszServer ),
    _nlsBasePath ( pszBasePath ),
    _idClose     ( pbClose ),
    _idCloseAll  ( pbCloseAll ),
    _plbFiles    ( plbFiles )
{
    // usual check for ok-ness
    if( QueryError() != NERR_Success )
        return;

    // makes sure the strings constructed fine.
    APIERR err ;
    if ( (err = _nlsServer.QueryError() != NERR_Success) ||
         (err = _nlsBasePath.QueryError() != NERR_Success ) )
    {
        ReportError(err) ;
        return;
    }
}


/*******************************************************************

    NAME:       OPEN_DIALOG_BASE::~OPEN_DIALOG_BASE

    SYNOPSIS:   OPEN_DIALOG_BASE class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Aug-1991 Created.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/
OPEN_DIALOG_BASE::~OPEN_DIALOG_BASE()
{
    //  nothing more to do
}


/*******************************************************************

    NAME:       OPEN_DIALOG_BASE::Refresh

    SYNOPSIS:   Refreshes the Open Resources dialog.

    EXIT:       The dialog is feeling relaxed and refreshed.

    HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.
        beng        05-Mar-1992 Use DEC_STR

********************************************************************/
VOID OPEN_DIALOG_BASE::Refresh()
{
    ULONG cOpenFiles;
    ULONG cFileLocks;
    ULONG cOpenNamedPipes;
    ULONG cOpenCommQueues;
    ULONG cOpenPrintQueues;
    ULONG cOtherResources;

    APIERR err = LM_SRVRES::GetResourceCount( QueryServer(),
                                              &cOpenFiles,
                                              &cFileLocks,
                                              &cOpenNamedPipes,
                                              &cOpenCommQueues,
                                              &cOpenPrintQueues,
                                              &cOtherResources );

    if( err == NERR_Success )
    {
        //  Update the open file & file lock counts.
        ULONG cOpenResources = cOpenFiles + cOpenNamedPipes + cOtherResources +
                               cOpenCommQueues + cOpenPrintQueues;

        // CODEWORK - wait for SLT_NUM
        // convert numbers to text and blast it out

        DEC_STR nlsOpenResources(cOpenResources);
        DEC_STR nlsLockCount(cFileLocks);
        ASSERT(!!nlsOpenResources && !!nlsLockCount);

        if (!!nlsOpenResources && !!nlsLockCount) // safety
        {
            _sltOpenCount.Enable( TRUE );
            _sltLockCount.Enable( TRUE );

            _sltOpenCount.SetText(nlsOpenResources);
            _sltLockCount.SetText(nlsLockCount);
        }
    }
    else
    {
        //  Since we couldn't retreive the file statistics,
        //  we'll just display ??.

        const TCHAR * pszNotAvailable = SZ("??");

        _sltOpenCount.Enable( FALSE );
        _sltLockCount.Enable( FALSE );

        _sltOpenCount.SetText( pszNotAvailable );
        _sltLockCount.SetText( pszNotAvailable );
    }

    //  Refresh the files listbox, and enable buttons as appropriate
    _plbFiles->Refresh();

    //
    // Move the focus to the OK button so it isn't lost when the close
    // buttons are disabled
    //

    if ( _plbFiles->QueryCount() == 0 )
    {
        _pbOK.ClaimFocus() ;
        _pbOK.MakeDefault() ;
    }

    _pbClose.Enable( _plbFiles->QuerySelCount() > 0 );
    _pbCloseAll.Enable( _plbFiles->QueryCount() > 0 );
}


/*******************************************************************

    NAME:       OPEN_DLG_BASE::OnCommand

    SYNOPSIS:   Handle user commands.

    ENTRY:      event                   - Control Event

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.
        KeithMo     24-Mar-1992 Made NO the default button.

********************************************************************/
BOOL OPEN_DIALOG_BASE::OnCommand( const CONTROL_EVENT & event)
{
    //  Determine the control which is sending the command.
    if( event.QueryCid() == _idClose )
    {
        OPEN_LBI_BASE * polbi = _plbFiles->QueryItem();
        UIASSERT( polbi != NULL );

        // See if the user really wants to close this file.
        if( WarnCloseSingle( polbi ) )
        {
            //  Close the file And refresh dialog
            CloseFile( polbi );
            Refresh();
        }
        return TRUE;
    }
    else if ( event.QueryCid() == _idCloseAll )
    {
        // See if the user really wants to close *all* files.
        if( WarnCloseMulti() )
        {
            //
            //  Close ALL of the open files.
            //
            //  Note that the CloseFile() method does not touch
            //  the listbox.  Therefore, there is no need to
            //  mess around with the item count & item index
            //  after closing a file.
            //
            INT cItems = _plbFiles->QueryCount();
            for( INT i = 0 ; i < cItems ; i++ )
            {
                OPEN_LBI_BASE * polbi = _plbFiles->QueryItem( i );
                UIASSERT( polbi != NULL );
                if (polbi)
                    CloseFile( polbi );
            }

            //  Refresh the dialog.
            Refresh();
        }
        return TRUE;
    }
    else
    {
        // we are not interested, let parent handle
        return(FALSE) ;
    }
}

/*******************************************************************

    NAME:       OPEN_DIALOG_BASE::CloseFile

    SYNOPSIS:   Closes a file on the remote server.

    ENTRY:      polbi                   - The OPEN_LBI_BASE item which
                                          represents the open file.

    EXIT:       If the file could not be deleted, then an error
                message popup is displayed.

    HISTORY:
        KeithMo     19-Aug-1991 Created.
        terryk      26-Aug-1991 Remove NetFileClose2
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

VOID OPEN_DIALOG_BASE::CloseFile( OPEN_LBI_BASE * polbi )
{
    //  This object represents the remote file.
    LM_FILE_2 file2( QueryServer(), polbi->QueryFileID() );

    //  Ensure the file object constructed properly.
    APIERR err = file2.QueryError();

    if( err == NERR_Success )
    {
        //
        //  The file object contructed properly, now close
        //  the remote file.
        //
        err = file2.CloseFile();

        //
        // if file is not found (already gone, just ignore)
        //
        if (err == NERR_FileIdNotFound)
             err = NERR_Success ;
    }

    if( err != NERR_Success )
    {
        //  Either the file object failed to construct or
        //  the file close failed.  Either way, tell the
        //  user the bad news.
        MsgPopup( this, err, MPSEV_ERROR );
    }
}


/*******************************************************************

    NAME:       OPEN_DIALOG_BASE::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        KeithMo     20-Aug-1991 Created.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

ULONG OPEN_DIALOG_BASE::QueryHelpContext()
{
    UIASSERT(FALSE) ;   // this ensures that someone does redefine the method
    return 0 ;
}


/*******************************************************************

    NAME:       OPEN_DLG_BASE :: WarnCloseSingle

    SYNOPSIS:   Warn the user before closing an individual resource.

    ENTRY:      plbi                    - The currently selected LBI.

    RETURNS:    BOOL                    - TRUE  if the wants to close the
                                          resource,
                                          FALSE otherwise.

    HISTORY:
        KeithMo     11-Sep-1992 Created.

********************************************************************/
BOOL OPEN_DIALOG_BASE :: WarnCloseSingle( OPEN_LBI_BASE * plbi )
{
    UIASSERT( plbi != NULL );

    //
    //  Setup our potential insert strings.
    //

    ALIAS_STR nlsUser( plbi->QueryUserName() );
    ALIAS_STR nlsAccess( plbi->QueryAccessName() );
    ALIAS_STR nlsPath( plbi->QueryPath() );

    NLS_STR * apnls[4];

    //
    //  The message id.
    //

    MSGID idMsg = 0;

    if( plbi->QueryPermissions() & DANGER_MASK )
    {
        //
        //  The user has a file open for a "dangerous" access
        //  (write, create, or exec).
        //
        //      %1 = user name
        //      %2 = access permission
        //      %3 = resource name
        //

        apnls[0] = &nlsUser;
        apnls[1] = &nlsAccess;
        apnls[2] = &nlsPath;
        apnls[3] = NULL;

        idMsg = IDS_UI_CLOSE_WARN;
    }
    else
    {
        //
        //  The user has a file open for a boring (safe) access.
        //
        //      %1 = user name
        //      %2 = resource name
        //

        apnls[0] = &nlsUser;
        apnls[1] = &nlsPath;
        apnls[2] = NULL;

        idMsg = IDS_UI_CLOSE_FILE;
    }

    UIASSERT( idMsg != 0 );

    return( ::MsgPopup( this,
                        idMsg,
                        MPSEV_WARNING,
                        HC_DEFAULT_HELP,
                        MP_YESNO,
                        apnls,
                        MP_NO ) == IDYES );

}   // OPEN_DIALOG_BASE :: WarnCloseSingle


/*******************************************************************

    NAME:       OPEN_DLG_BASE :: WarnCloseMulti

    SYNOPSIS:   Warn the user before closing all open resources.

    RETURNS:    BOOL                    - TRUE  if the wants to close the
                                          resources,
                                          FALSE otherwise.

    HISTORY:
        KeithMo     11-Sep-1992 Created.

********************************************************************/
BOOL OPEN_DIALOG_BASE :: WarnCloseMulti( VOID )
{
    //
    //  Get the number of items in the listbox.
    //

    INT cItems = _plbFiles->QueryCount();
    UIASSERT( cItems > 0 );

    //
    //  These items will keep track of the most "severe"
    //  open type encountered in the listbox.
    //

    ULONG         nMaxPerm   = 0;
    const TCHAR * pszMaxPerm = SZ("");

    //
    //  Scan for the most severe permission type.
    //

    for( INT i = 0 ; i < cItems ; i++ )
    {
        OPEN_LBI_BASE * plbi = _plbFiles->QueryItem( i );
        UIASSERT( plbi != NULL );

        if( plbi->QueryPermissions() > nMaxPerm )
        {
            nMaxPerm   = plbi->QueryPermissions();
            pszMaxPerm = plbi->QueryAccessName();
        }
    }

    //
    //  Potential insert strings.
    //

    ALIAS_STR nlsServer( QueryServer() );
    ALIAS_STR nlsPerm( pszMaxPerm );

    NLS_STR * apnls[2];

    //
    //  The message id.
    //

    MSGID idMsg = 0;

    if( nMaxPerm > ACCESS_READ )
    {
        //
        //  Somebody has a dangerous access.
        //

        apnls[0] = &nlsPerm;
        apnls[1] = NULL;

        idMsg = IDS_UI_CLOSE_LOSE_DATA;
    }
    else
    {
        //
        //  Everybody has boring access.
        //

        apnls[0] = &nlsServer;
        apnls[1] = NULL;

        idMsg = IDS_UI_CLOSE_ALL;
    }

    UIASSERT( idMsg != 0 );

    return( ::MsgPopup( this,
                        idMsg,
                        MPSEV_WARNING,
                        HC_DEFAULT_HELP,
                        MP_YESNO,
                        apnls,
                        MP_NO ) == IDYES );

}   // OPEN_DIALOG_BASE :: WarnCloseMulti


/*******************************************************************

    NAME:       OPEN_LBOX_BASE::OPEN_LBOX_BASE

    SYNOPSIS:   OPEN_LBOX_BASE class constructor.

    ENTRY:      powOwner                - The "owning" window.

                cid                     - The listbox CID.

    EXIT:       The object is constructed.

    RETURNS:    No return value.

    NOTES:

    HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

OPEN_LBOX_BASE::OPEN_LBOX_BASE( OWNER_WINDOW * powOwner,
                                CID            cid,
                                const NLS_STR &nlsServer,
                                const NLS_STR &nlsBasePath )
  : BLT_LISTBOX( powOwner, cid ),
    _nlsServer(nlsServer),
    _nlsBasePath(nlsBasePath)
{
    //  Ensure we constructed properly.
    if( QueryError() != NERR_Success)
        return;

    APIERR err ;
    if ( (err = _nlsServer.QueryError()) != NERR_Success ||
         (err = _nlsBasePath.QueryError()) != NERR_Success )
    {
        ReportError(err) ;
        return;
    }
}


/*******************************************************************

    NAME:       OPEN_LBOX_BASE::~OPEN_LBOX_BASE

    SYNOPSIS:   OPEN_LBOX_BASE class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Aug-1991 Created.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

OPEN_LBOX_BASE::~OPEN_LBOX_BASE()
{
    ;  // nothing more to do
}


/*******************************************************************

    NAME:       OPEN_LBOX_BASE::Fill

    SYNOPSIS:   Fill the list of open files.

    EXIT:       The listbox is filled.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

APIERR OPEN_LBOX_BASE::Fill()
{
    AUTO_CURSOR Cursor;

    //  A level 3 file enumerator.
    FILE3_ENUM  enumFile3( _nlsServer.QueryPch(), _nlsBasePath.QueryPch() );

    //  See if the files are available.
    APIERR err = enumFile3.GetInfo();

    if( err != NERR_Success )
        return err;

    //
    //  Now that we know the file info is available,
    //  let's nuke everything in the listbox.
    //
    SetRedraw( FALSE );
    DeleteAllItems();

    //  For iterating the available files.
    FILE3_ENUM_ITER iterFile3( enumFile3 );
    const FILE3_ENUM_OBJ *pfi3;

    //  Iterate the files adding them to the listbox.
    while( ( err == NERR_Success ) && ( ( pfi3 = iterFile3( &err ) ) != NULL ) )
    {
        OPEN_LBI_BASE * polbi = CreateFileEntry(pfi3) ;

        if ( (polbi == NULL) || (AddItem( polbi ) < 0) )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break ;
        }
    }

    SetRedraw( TRUE );
    Invalidate( TRUE );

    return err;
}


/*******************************************************************

    NAME:       OPEN_LBOX_BASE::Refresh

    SYNOPSIS:   Refreshes the list of open resources.

    EXIT:       The listbox is refreshed & redrawn.

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:      This method is now obsolete.  It will be replaced
                as soon as KevinL's WFC refreshing listbox code is
                available.

    HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

APIERR OPEN_LBOX_BASE::Refresh()
{
    INT iCurrent = QueryCurrentItem();
    INT iTop     = QueryTopIndex();

    APIERR err = Fill();

    if( err != NERR_Success )
    {
        return err;
    }

    INT cItems = QueryCount();

    if( cItems > 0 )
    {
        SetTopIndex( ( ( iTop < 0 ) || ( iTop >= cItems ) ) ? 0
                                                            : iTop );

        if( iCurrent < 0 )
        {
            iCurrent = 0;
        }
        else
        if( iCurrent >= cItems )
        {
            iCurrent = cItems - 1;
        }

        SelectItem( iCurrent );
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       OPEN_LBI_BASE::OPEN_LBI_BASE

    SYNOPSIS:   OPEN_LBI_BASE class constructor.

    ENTRY:      pszUserName             - The user for this entry.

                uPermissions            - Open permissions.

                cLocks                  - Number of locks.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     31-May-1991 Created for the Server Manager.
        KeithMo     19-Aug-1991 Use DMID_DTE passed into constructor.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.
        beng        22-Nov-1991 Ctors for empty strings
        beng        05-Mar-1992 use DEC_STR

********************************************************************/

OPEN_LBI_BASE::OPEN_LBI_BASE( const TCHAR *pszUserName,
                              const TCHAR *pszPath,
                              ULONG        uPermissions,
                              ULONG        cLocks,
                              ULONG        ulFileID)
  : _ulFileID( ulFileID ),
    _uPermissions( uPermissions ),
    _nlsUserName( pszUserName ),
    _nlsAccess(), // init below
    _nlsLocks(cLocks), // DEC_STR
    _nlsPath( pszPath )
{
    if( QueryError() != NERR_Success )
        return;

    APIERR err;
    if( ( ( err = _nlsUserName.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsAccess.QueryError() )   != NERR_Success ) ||
        ( ( err = _nlsPath.QueryError() )   != NERR_Success ) ||
        ( ( err = _nlsLocks.QueryError() )    != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    //
    //  Initialize the more complex strings.
    //

    //
    //  If this file is not opened with a "normal" access, but IS
    //  opened with an "abnormal" access, then map it to write.  This
    //  so we don't have to display "attrib" and "perm" and other
    //  access types most users would never understand anyway.
    //

    if( !( uPermissions & NORMAL_MASK   ) &&
         ( uPermissions & ABNORMAL_MASK ) )
    {
        uPermissions |= ACCESS_WRITE;
    }

    /*
     * see if we can find the right perm. if not, set to UNKNOWN
     * (which by the way, should not happen and hence the assert).
     */

    UINT idString = (uPermissions & ACCESS_EXEC)   ? IDS_UI_EXECUTE :
                    (uPermissions & ACCESS_CREATE) ? IDS_UI_CREATE :
                    (uPermissions & ACCESS_WRITE)  ? IDS_UI_WRITE :
                    (uPermissions & ACCESS_READ)   ? IDS_UI_READ :
                                                     IDS_UI_UNKNOWN;

    UIASSERT( idString != IDS_UI_UNKNOWN );
    err = _nlsAccess.Load( idString );
    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       OPEN_LBI_BASE::~OPEN_LBI_BASE

    SYNOPSIS:   OPEN_LBI_BASE class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     31-May-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

OPEN_LBI_BASE::~OPEN_LBI_BASE()
{
    //
    //  This space intentionally left blank.
    //
}


/*******************************************************************

    NAME:       OPEN_LBI_BASE::QueryLeadingChar

    SYNOPSIS:   Return the leading character of this item.

    RETURNS:    WCHAR - The leading character.

    HISTORY:
        KeithMo     31-May-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

WCHAR OPEN_LBI_BASE::QueryLeadingChar() const
{
    ISTR istr( _nlsUserName );

    return _nlsUserName.QueryChar( istr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\password.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    password.cxx
    Class definitions for the RESOURCE_PASSWORD_DIALOG and
    BASE_PASSWORD_DIALOG classes.

    FILE HISTORY:
        KeithMo     22-Jul-1991 Created for the Server Manager.
        Yi-HsinS     5-Oct-1991 Modified for general usage
        ChuckC       2-Feb-1992 Modified to be more flexible. Broke into
                                two classes.
        KeithMo     07-Aug-1992 Added HelpContext parameters.
*/

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:       BASE_PASSWORD_DIALOG::BASE_PASSWORD_DIALOG

    SYNOPSIS:   Constructor.

    ENTRY:      hwndParent              - The handle of the "owning" window

                pszResource             - The name of the resource

                sltTarget               - CID for target SLT

                pswdPass                - CID for passwd ctrl

                pszTarget               - The name of the target resource

                npasswordLen            - The maximum length of the password
                                          that the user is allowed to type in

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     22-Jul-1991 Created for the Server Manager.
        Yi-HsinS     5-Oct-1991 Constructor takes a password length

********************************************************************/
BASE_PASSWORD_DIALOG::BASE_PASSWORD_DIALOG( HWND        hwndParent,
                                            const TCHAR *pszResource,
                                            CID         cidTarget,
                                            CID         cidPassword,
                                            ULONG       ulHelpContext,
                                            const TCHAR *pszTarget,
                                            UINT        npasswordLen,
                                            CID         cidTarget2,
                                            const TCHAR *pszTarget2,
                                            CID         cidText,
                                            const TCHAR *pszText)

  : DIALOG_WINDOW( pszResource, hwndParent ),
    _sltTarget( this, cidTarget ),
    _psltTarget2(NULL),
    _psltText (NULL),
    _passwdCtrl( this, cidPassword, npasswordLen ),
    _ulHelpContext(ulHelpContext)
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Display the target resource name.
    //

    _sltTarget.SetText( pszTarget );

    //  Display username stored in pszTarget2.
    if (cidTarget2 != 0)
    {
        _psltTarget2 = new SLT( this, cidTarget2 );
        APIERR err = ERROR_NOT_ENOUGH_MEMORY;
        if (   _psltTarget2 == NULL
            || (err = _psltTarget2->QueryError()) != NERR_Success )
        {
            ReportError( err );
            return;
        }
        _psltTarget2->SetText( pszTarget2 );
    }

    if (cidText != 0)
    {
        _psltText = new SLT( this, cidText );
        APIERR err = ERROR_NOT_ENOUGH_MEMORY;
        if (   _psltText == NULL
            || (err = _psltText->QueryError()) != NERR_Success )
        {
            ReportError( err );
            return;
        }
        _psltText->SetText( pszText );
    }

}

BASE_PASSWORD_DIALOG::~BASE_PASSWORD_DIALOG()
{
    delete _psltText;
    delete _psltTarget2;
}

/*******************************************************************

    NAME:       BASE_PASSWORD_DIALOG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog which was given
                to it diring construction.

    ENTRY:      None.

    EXIT:       None.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    NOTES:

    HISTORY:
        KeithMo     22-Jul-1991 Created for the Server Manager.

********************************************************************/
ULONG BASE_PASSWORD_DIALOG :: QueryHelpContext( void )
{
    return  _ulHelpContext ;
}

/*******************************************************************

    NAME:       RESOURCE_PASSWORD_DIALOG::RESOURCE_PASSWORD_DIALOG

    SYNOPSIS:   Constructor.

    ENTRY:      hwndParent              - The handle of the "owning" window

                pszResource             - The name of the resource

                sltTarget               - CID for target SLT

                pswdPass                - CID for passwd ctrl

                pszTarget               - The name of the target resource

                npasswordLen            - The maximum length of the password
                                          that the user is allowed to type in

                nHelpContext            - The help context for this dialog.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     22-Jul-1991 Created for the Server Manager.
        Yi-HsinS     5-Oct-1991 Constructor takes a password length

********************************************************************/
RESOURCE_PASSWORD_DIALOG::RESOURCE_PASSWORD_DIALOG( HWND        hwndParent,
                                                    const TCHAR *pszTarget,
                                                    UINT        npasswordLen,
                                                    ULONG       nHelpContext )
  : BASE_PASSWORD_DIALOG( hwndParent,
                          MAKEINTRESOURCE( IDD_PASSWORD_DLG),
                          IDPW_RESOURCE,
                          IDPW_PASSWORD,
                          nHelpContext,
                          pszTarget,
                          npasswordLen )
{
    ;  // nothing more to do
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\mrucombo.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    mrucombo.cxx
    BLT MRU combo box control -- implementation

    FILE HISTORY:
        gregj   29-Oct-1991     Created
        beng    05-Mar-1992     Removed tracing (wsprintf removal)
*/


#include "pchapplb.hxx"   // Precompiled header

// cfront prevents following from being a TCHAR[]

const TCHAR *const szOrderKey = SZ("Order");

const INT cMaxMRU = TCH('z') - TCH('a');


/*******************************************************************

    NAME:       QueryWinIni

    SYNOPSIS:   reads an item from a .INI file

    ENTRY:      nlsSection  - name of the section to read from
                pszKeyName  - name of the item to retrieve
                nlsValue    - gets filled with the key value
                nlsFileName - name of the .INI file to read from

    EXIT:       Returns non-zero if error, else nlsValue contains
                the item's value

    NOTES:
        The maximum length of the item read will be the allocated
        length of nlsValue on entry.

    HISTORY:
        gregj   29-Oct-1991     Created
        beng    29-Mar-1992     Const args
        beng    30-Apr-1992     Fixed error return; API changes

********************************************************************/

APIERR QueryWinIni( const NLS_STR &nlsSection, const TCHAR *pszKeyName,
                    NLS_STR * pnlsValue, const NLS_STR &nlsFileName )
{
    if (pnlsValue == NULL)
        return ERROR_INVALID_PARAMETER;

    UINT cchBuf = pnlsValue->QueryAllocSize() / sizeof( TCHAR );
    TCHAR *pchBuf = new TCHAR[cchBuf];
    if (pchBuf == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    APIERR err = NERR_Success;
    if (! ::GetPrivateProfileString( nlsSection.QueryPch(),
                                     pszKeyName,
                                     SZ(""),
                                     pchBuf,
                                     cchBuf,
                                     nlsFileName.QueryPch() ) )
    {
        DBGEOL("::QueryWinIni - Warning: Unable to find requested value (" <<
                nlsFileName.QueryPch() << " - " << nlsSection.QueryPch() << " - "
                << pszKeyName << ")") ;
        err = pnlsValue->CopyFrom(SZ("")) ;
    }
    else
    {
        err = pnlsValue->CopyFrom(pchBuf);
    }
    delete pchBuf;
    return err;
}


/*******************************************************************

    NAME:       QueryWinIni

    SYNOPSIS:   reads an item with a 1-char name from a .INI file

    ENTRY:      nlsSection  - name of the section to read from
                chKeyName   - name of the item to retrieve
                nlsValue    - gets filled with the key value
                nlsFileName - name of the .INI file to read from

    EXIT:       Returns non-zero if error, else nlsValue contains
                the item's value

    NOTES:
        This is so a 1-char named item (common in the MRU_COMBO)
        can be retrieved without building a string for it.

    HISTORY:
        gregj   29-Oct-1991     Created
        beng    30-Apr-1992     Const args

********************************************************************/

APIERR QueryWinIni( const NLS_STR &nlsSection, TCHAR chKeyName,
                    NLS_STR * pnlsValue, const NLS_STR &nlsFileName )
{
    TCHAR achKeyName [2];

    achKeyName [0] = chKeyName;
    achKeyName [1] = TCH('\0');

    return QueryWinIni( nlsSection, achKeyName, pnlsValue, nlsFileName );
}


/*******************************************************************

    NAME:       WriteWinIni

    SYNOPSIS:   writes an item to a .INI file

    ENTRY:      nlsSection  - name of the section to read from
                pszKeyName  - name of the item to retrieve
                nlsValue    - gets filled with the key value
                nlsFileName - name of the .INI file to read from

    EXIT:       No return value

    NOTES:

    HISTORY:
        gregj   29-Oct-1991     Created
        beng    29-Mar-1992     Const args

********************************************************************/

VOID WriteWinIni( const NLS_STR &nlsSection, const TCHAR *pszKeyName,
                  const NLS_STR &nlsValue, const NLS_STR &nlsFileName )
{
    ::WritePrivateProfileString( nlsSection.QueryPch(),
                                 pszKeyName,
                                 nlsValue.QueryPch(),
                                 nlsFileName.QueryPch() );
}


/*******************************************************************

    NAME:       MRU_COMBO::MRU_COMBO

    SYNOPSIS:   Constructor for MRU_COMBO class

    ENTRY:      powin          - owner window for this control
                cid            - ID for this control
                pszSectionName - name of .INI file section to get MRU from
                pszFileName    - name of .INI file to read from
                cMaxEntries    - max. # of entries to keep in MRU list
                cbMaxLen       - max. length of text in edit field

    EXIT:       Object is constructed

    NOTES:
        With the current implementation, there can be no more than
        26 items kept in the MRU list (each is identified with a
        single lower-case letter, that's why).

    HISTORY:
        gregj   29-Oct-1991     Created
        beng    29-Mar-1992     Const args
        beng    30-Apr-1992     More const args

********************************************************************/

MRU_COMBO::MRU_COMBO( OWNER_WINDOW *powin, CID cid,
                      const TCHAR *pszSectionName,
                      const TCHAR *pszFileName,
                      INT cMaxEntries, UINT cbMaxLen )
    : COMBOBOX( powin, cid, cbMaxLen ),
      _nlsSectionName( pszSectionName ),
      _nlsFileName( pszFileName ),
      _nlsKeyOrder( ::cMaxMRU + 1 ),
      _cMaxEntries( cMaxEntries )
{
    APIERR err;

    if ((err=QueryError()) != NERR_Success ||
        (err=_nlsSectionName.QueryError()) != NERR_Success ||
        (err=_nlsFileName.QueryError()) != NERR_Success ||
        (err=_nlsKeyOrder.QueryError()) != NERR_Success)
    {
        ReportError( err );
        return;
    }

    if (cMaxEntries > ::cMaxMRU)
    {
        ASSERTSZ(FALSE, "MRU max size is too large.");
        ReportError( NERR_TooManyItems );
        return;
    }

    if (::QueryWinIni( _nlsSectionName, ::szOrderKey,
                       &_nlsKeyOrder, _nlsFileName ) != NERR_Success)
    {
        return;  // no section?  start out empty. (don't report error)
    }

    FillList();
}


/*******************************************************************

    NAME:       MRU_COMBO::FillList

    SYNOPSIS:   private helper to fill an MRU_COMBO from its .INI file

    ENTRY:      No parameters

    EXIT:       List is filled

    NOTES:

    HISTORY:
        gregj   29-Oct-1991     Created

********************************************************************/

VOID MRU_COMBO::FillList()
{
    NLS_STR nlsUNC( 80 );

    if (nlsUNC.QueryError() != NERR_Success)
        return;

    DeleteAllItems();   /* clear the list */

    ISTR istrKey( _nlsKeyOrder );

    TCHAR chKey;

    while (chKey = _nlsKeyOrder.QueryChar(istrKey)) // until end of string
    {
        if (chKey < TCH('a') || chKey > TCH('z'))
        {
            ISTR istrNext( istrKey );
            ++istrNext;
            _nlsKeyOrder.DelSubStr( istrKey, istrNext );
        }
        else
        {
            if (::QueryWinIni( _nlsSectionName, chKey,
                               &nlsUNC, _nlsFileName ) == NERR_Success)
            {
                AddItemIdemp( nlsUNC ); /* add UNC name to listbox */
            }
            else
            {
                _nlsKeyOrder.DelSubStr( istrKey );
                break;                  /* bogus?  truncate here */
            }
            ++istrKey;                  /* advance to next char */
        }
    }
}


/*******************************************************************

    NAME:       MRU_COMBO::SaveText

    SYNOPSIS:   saves current text to the .INI file

    ENTRY:      No parameters

    EXIT:       Text is saved, list is refilled

    NOTES:
        Call this function when the user has successfully done
        something with the text in the control, i.e. that warrants
        being saved.

        The list will be refilled with the new MRU list, for cases
        like the monolithic connection dialogs.

    HISTORY:
        gregj       29-Oct-1991 Created
        beng        22-Nov-1991 Removed STR_OWNERALLOC

********************************************************************/

VOID MRU_COMBO::SaveText()
{
    NLS_STR nlsText;

    QueryText( &nlsText );

    if (nlsText.QueryError() != NERR_Success)
        return;                 /* no memory?  tough, can't save. */

    //
    // dont upper case. breaks NFS & case sensitive clients
    //
    // nlsText.strupr();

    /* If it exists, then don't save it again in our list
     */
    if ( IsOldUNC( nlsText ) )
    {
	return ;
    }

    INT iItem = FindItemExact( nlsText );

    ISTR istrKey( _nlsKeyOrder );

    TCHAR achTextKey [2];       /* will contain key name for new item */
    achTextKey [1] = TCH('\0');

    BOOL fNewItem = FALSE;      /* TRUE if new item & list not full */

    if (iItem != LB_ERR)        /* item found, look it up in the order key */
    {
        while (iItem--)         /* Assumes list is NOT sorted! */
            ++istrKey;          /* point istrKey at iItem'th char */
    }
    else                        /* not found, either new or replace an old */
    {
        if ((INT)_nlsKeyOrder.QueryTextLength() < _cMaxEntries)
        {
            achTextKey[0] = _nlsKeyOrder.QueryTextLength() + TCH('a');
            fNewItem = TRUE;    /* MRU list not full yet, add a new one */
        }
        else                    /* replace the last in the list */
        {
            ISTR istrEnd( istrKey );
            ++istrEnd;
            while (*_nlsKeyOrder.QueryPch(istrEnd))
            {
                ++istrEnd;
                ++istrKey;              /* point istrKey at last char */
            }
        }
    }

    if (!fNewItem)              /* key found, delete from key order */
    {
        achTextKey[0] = *_nlsKeyOrder.QueryPch(istrKey);

        ISTR istrNext (istrKey);
        ++istrNext;
        _nlsKeyOrder.DelSubStr( istrKey, istrNext );
    }

    /*
        Insert the new key letter at the beginning of the order string,
        and save the order string.  Then save the UNC name itself under
        the correct key.
    */

    const ALIAS_STR nlsTextKey( achTextKey );

    istrKey.Reset();
    _nlsKeyOrder.InsertStr( nlsTextKey, istrKey );

    WriteWinIni( _nlsSectionName, szOrderKey, _nlsKeyOrder, _nlsFileName );

    WriteWinIni( _nlsSectionName, achTextKey, nlsText, _nlsFileName );

    FillList();
}

/*******************************************************************

    NAME:	MRU_COMBO::IsOldUNC

    SYNOPSIS:	Returns TRUE if the passed UNC is already in the list

    ENTRY:	nlsNewUNC - UNC to check against the existing list

    RETURNS:	TRUE if the UNC is already in our list, FALSE if the UNC
		should be added to our list

    NOTES:	Possible CODEWORK item:  Rather then re-reading the list
		from the win.ini, might be preferable to keep internal list
		that gets written on destruction (.ini files are not always
		cached).

    HISTORY:
	Johnl	30-Jun-1992	Created

********************************************************************/

BOOL MRU_COMBO::IsOldUNC( const NLS_STR & nlsNewUNC )
{
    NLS_STR nlsUNC( 80 );

    if (nlsUNC.QueryError() != NERR_Success)
	return TRUE ;

    ISTR istrKey( _nlsKeyOrder );
    TCHAR chKey;

    BOOL fIsOld = FALSE ;   /* Already in our list? */

    while (chKey = _nlsKeyOrder.QueryChar(istrKey)) // until end of string
    {
        if (chKey < TCH('a') || chKey > TCH('z'))
        {
            ISTR istrNext( istrKey );
            ++istrNext;
            _nlsKeyOrder.DelSubStr( istrKey, istrNext );
        }
        else
        {
            if (::QueryWinIni( _nlsSectionName, chKey,
                               &nlsUNC, _nlsFileName ) == NERR_Success)
            {
		if ( fIsOld = (nlsUNC == nlsNewUNC))
		    break ;
            }
            else
            {
                _nlsKeyOrder.DelSubStr( istrKey );
                break;                  /* bogus?  truncate here */
            }
            ++istrKey;                  /* advance to next char */
        }
    }

    return fIsOld ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\prompt.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
 *   prompt.cxx
 *   This file contains the class PROMPT_AND_CONNECT. The class is
 *   used for connecting to a resource and will pop up a dialog
 *   asking for the password to the resource.
 *
 *   FILE HISTORY:
 *     Yi-HsinS         8/15/91         Created
 *     KeithMo          07-Aug-1992     Added HelpContext parameters.
 *
 */

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:       PROMPT_AND_CONNECT::PROMPT_AND_CONNECT

    SYNOPSIS:   Class Constructor

    ENTRY:      hwndParent              - The parent window.
                pszTarget               - The name of the target resource.
                npasswordLen            - The length of the password expected
                pszDev                  - The device name to be used to connect
                nHelpContext            - The help context for the dialog.


    EXIT:       The object is constructed.

    HISTORY:
        Yi-HsinS    10/1/91     Created

********************************************************************/

PROMPT_AND_CONNECT::PROMPT_AND_CONNECT( HWND hwndParent,
                                        const TCHAR *pszTarget,
                                        ULONG nHelpContext,
                                        UINT npasswordLen,
                                        const TCHAR *pszDev )
     : _hwndParent(  hwndParent ),
       _nlsTarget( pszTarget ),
       _nlsDev ( pszDev ),
       _fConnected( FALSE ),
       _npasswordLen( npasswordLen),
       _nHelpContext( nHelpContext )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  (( err = _nlsTarget.QueryError() ) != NERR_Success )
       || (( err = _nlsDev.QueryError() ) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:       PROMPT_AND_CONNECT::~PROMPT_AND_CONNECT

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    HISTORY:
        Yi-HsinS    10/1/91     Created

********************************************************************/

PROMPT_AND_CONNECT::~PROMPT_AND_CONNECT()
{
    if ( IsConnected() )
    {
        // Ignore error, we use USE_LOTS_OF_FORCE
        DEVICE dev(SZ("")) ;
        APIERR err ;

        err = dev.GetInfo() ;
        UIASSERT (err == NERR_Success) ; // shouldnt fail
        if (err == NERR_Success)
        {
            // Ignore disconnect error, we try our best and be done with it
            err = dev.Disconnect(_nlsTarget.QueryPch(), USE_LOTS_OF_FORCE) ;
            UIASSERT (err == NERR_Success) ;
        }
    }

}

/*******************************************************************

    NAME:       PROMPT_AND_CONNECT::Connect

    SYNOPSIS:   Main function to connect to the resource and use the
                device passed in if it exists

    ENTRY:

    EXIT:       The connection is established.

    HISTORY:
        Yi-HsinS    10/1/91     Created

********************************************************************/

APIERR PROMPT_AND_CONNECT::Connect( void )
{
     APIERR err = NERR_Success;

     if ( IsConnected() )
         return err;

     RESOURCE_PASSWORD_DIALOG *pdlg =
         new RESOURCE_PASSWORD_DIALOG( _hwndParent,
                                       _nlsTarget,
                                       SHPWLEN,
                                       _nHelpContext );

     BOOL fOK;
     err = ( (pdlg == NULL) ? ERROR_NOT_ENOUGH_MEMORY
                            : pdlg->QueryError() );

     if (  ( err == NERR_Success )
        && ( ( err = pdlg->Process( &fOK)) == NERR_Success )
        && ( fOK )
        )
     {
         NLS_STR nlsPassword( SHPWLEN );

         if (  ((err = nlsPassword.QueryError()) != NERR_Success )
            || ((err = pdlg->QueryPassword( &nlsPassword )) != NERR_Success )
            )
         {
            return err;
         }

         DEVICE dev(_nlsDev.QueryPch()) ;
         err = dev.GetInfo() ;
         if (err != NERR_Success)
             return err ;

         if ( (err = dev.Connect( _nlsTarget.QueryPch(),
                                  (TCHAR *) nlsPassword.QueryPch()))
                == NERR_Success)
         {
             _fConnected = TRUE;
         }

         RtlZeroMemory( (PVOID)nlsPassword.QueryPch(),
                        nlsPassword.QueryTextSize() );
     }

     delete pdlg;
     return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\ssfdlg.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    ssfdlg.cxx
        Standalone set focus dialog box source file

        It will display a standalone dialog box and get the domain or
        server name from the user. It will report to the caller the
        name if the user hits OK button.

    FILE HISTORY:
        terryk  18-Nov-91       Created
        terryk  19-Nov-91       remove ssfdlg.hxx reference
        KeithMo 07-Aug-1992     Added HelpContext parameters.

*/

#include "pchapplb.hxx"   // Precompiled header


/*******************************************************************

    NAME:       STANDALONE_SET_FOCUS_DLG::STANDALONE_SET_FOCUS_DLG

    SYNOPSIS:   Standalone Set Focus Dialog box constructor

    ENTRY:      HWND hWnd - the owner window handle
                NLS_STR *pnlsName - point to the NLS_STR which receives
                    the domain or server name

    HISTORY:
                terryk  18-Nov-1991     Created
                KeithMo 22-Jul-1992     Added maskDomainSources &
                                        pszDefaultSelection.

********************************************************************/

STANDALONE_SET_FOCUS_DLG::STANDALONE_SET_FOCUS_DLG(
                                            HWND wndOwner,
                                            NLS_STR *pnlsName,
                                            ULONG nHelpContext,
                                            SELECTION_TYPE seltype,
                                            ULONG maskDomainSources,
                                            const TCHAR * pszDefaultSelection,
                                            const TCHAR * pszHelpFile,
                                            ULONG nServerTypes )
    : BASE_SET_FOCUS_DLG( wndOwner,
                          seltype,
                          maskDomainSources,
                          pszDefaultSelection,
                          nHelpContext,
                          pszHelpFile,
                          nServerTypes ),
    _pnlsName( pnlsName )
{
    if ( _pnlsName == NULL )
    {
        ReportError( ERROR_INVALID_PARAMETER );
    }
}

/*******************************************************************

    NAME:       STANDALONE_SET_FOCUS_DLG::SetNetworkFocus

    SYNOPSIS:   It is called when the user hits the OK button. It will
                copy the domain or server name from the SLE to the
                default receive NLS_STR.

    ENTRY:      new domain or server name

    RETURNS:    APIERR - in case of assign error for the NLS_STR

    HISTORY:
                terryk  18-Nov-1991     Created

********************************************************************/

APIERR STANDALONE_SET_FOCUS_DLG::SetNetworkFocus( HWND hwndOwner,
                                                  const TCHAR * pszNetworkFocus,
                                                  FOCUS_CACHE_SETTING setting )
{
    UNREFERENCED(hwndOwner);
    UNREFERENCED(setting);

    *_pnlsName = pszNetworkFocus;
    return _pnlsName->QueryError();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\sendmsg.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1989-1991          **/
/*****************************************************************/

/*
 *  sendmsg.cxx
 *      this module contains the code for the Send Message Dialog
 *      Base Class.
 *
 *  FILE HISTORY:
 *      ChuckC      19-Jul-1991     Culled from SHELL\SHELL\WNETDEV.CXX
 *
 */

#include "pchapplb.hxx"   // Precompiled header


//
//  Maximum number of characters in the message MLE.
//

#define MAX_MESSAGE_SIZE        8000    // characters, recommended by DanL


/*******************************************************************

    NAME:       MSG_DIALOG_BASE::MS_DIALOG_BASE

    SYNOPSIS:   constructor

    ENTRY:      expects valid HWND for hDlg, a valid resource name
                in pszResource, and the CID to be used with the
                message text MLE in cidMsgText.

    HISTORY:
        ChuckC      06-Aug-1991 Took from wnetdev.cxx
        beng        05-Oct-1991 Win32 conversion

********************************************************************/

MSG_DIALOG_BASE::MSG_DIALOG_BASE( HWND hDlg, const TCHAR *pszResource,
                                  CID cidMsgText )
   : DIALOG_WINDOW( pszResource, hDlg ),
     _mleTextMsg( this, cidMsgText, MAX_MESSAGE_SIZE )
{
    if ( QueryError() != NERR_Success )
        return;

    //  Direct the message edit control to add end-of-line
    //  character from wordwrapped text lines.
    //
    _mleTextMsg.SetFmtLines( TRUE );
}


/*******************************************************************

    NAME:       MSG_DIALOG_BASE::~MSG_DIALOG_BASE

    SYNOPSIS:   this destructor does nothing

    HISTORY:
        ChuckC      06-Aug-1991     Created

********************************************************************/

MSG_DIALOG_BASE::~MSG_DIALOG_BASE()
{
   ;
}


/*******************************************************************

    NAME:       MSG_DIALOG_BASE::OnOK

    SYNOPSIS:   replaces the OnOK in DIALOG_WINDOW. It calls the
                the GetAndSendText method to do the real work, and
                handles any errors that may return from that call.

    HISTORY:
        ChuckC      06-Aug-1991     Created

********************************************************************/

BOOL MSG_DIALOG_BASE::OnOK()
{
    /*
     * Attempt to send the message
     */
    APIERR usErr = GetAndSendText();

    /*
     * if success dismiss, else let subclass decide what to do
     */
    switch (usErr)
    {
    case NERR_Success:
        Dismiss(NERR_Success);
        break;

    default:
        (void) ActionOnError(usErr);
        break;
    }

    return TRUE;
}


/*******************************************************************

    NAME:       MSG_DIALOG_BASE::ActionOnError

    SYNOPSIS:   allows a subclass to specify focus or any other
                action if an error occurs during send. Default
                is to report error, and then set focus on the MLE.

    ENTRY:      err contains an error code, which may be either
                base, net or UI.

    EXIT:       return TRUE if action is taken.

    HISTORY:
        ChuckC      06-Aug-1991     Created

********************************************************************/

BOOL MSG_DIALOG_BASE::ActionOnError( APIERR err )
{
    MsgPopup(this,err);
    _mleTextMsg.ClaimFocus();

    return(TRUE) ;
}


/*******************************************************************

    NAME:       MSG_DIALOG_BASE::GetAndSendText

    SYNOPSIS:   gets the list of target users, the text from the
                MLE, and calls NetMessageBufferSend.

    ENTRY:

    EXIT:       return NERR_Success if all is well, error code
                otherwise. This method does NOT report errors, nut
                lets its caller do so.

    HISTORY:
        ChuckC      06-Aug-1991     Stole from wnetdev.cxx

********************************************************************/

APIERR MSG_DIALOG_BASE::GetAndSendText()
{
    UINT cb = _mleTextMsg.QueryTextSize();
    if (cb <= sizeof(TCHAR))    // always has a terminating NULL
    {
        return( ERROR_GEN_FAILURE );
    }

    /*
     * Allocate a buffer for the number of characters + the nul
     * character.  Since this text could potentially be very long,
     * we use a BUFFER object.
     */
    BUFFER buf( cb );
    if ( buf.QueryError() != NERR_Success )
        return ( buf.QueryError() );

    APIERR err = _mleTextMsg.QueryText( (TCHAR*)buf.QueryPtr(),
                                        buf.QuerySize() );
    if (err == NERR_Success)
    {
        /*
         * Set cursor to hour glass.
         */
        AUTO_CURSOR autocur;

        STRLIST slUsers;
        err = QueryUsers(&slUsers);
        if (err != NERR_Success)
        {
            MsgPopup(this,err);
            return ( NERR_Success );
        }

        /*
         * create message object
         */
        LM_MESSAGE message;
        if ((err = message.QueryError()) != NERR_Success)
            return (err);

        /*
         * loop thru all users.
         */
        ITER_STRLIST  islUsers(slUsers);
        NLS_STR *pStr;
        APIERR errFirst = NERR_Success;
        while (pStr = islUsers())
        {
            /*
             * Note that we don't mention the nul character when
             *  we send the message.  This would result in one extra
             *  character displayed in WinPopup.
             */
            err  = message.SendBuffer ( (TCHAR *)pStr->QueryPch(),
                                        (TCHAR *)buf.QueryPtr(),
                                        (cb - sizeof(TCHAR)) );
            // if error, break out early
            if (err != NERR_Success && errFirst == NERR_Success)
                errFirst = err;
        }
        if (errFirst != NERR_Success)
            return (errFirst);
    }
    return (err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\slestrip.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    slestrip.cxx
    This file contains the class SLE_STRIP which is basically the same as
    an ICANON_SLE except that QueryText is redefined to strip the leading or
    trailing characters or both.

    FILE HISTORY:
        Yi-HsinS	11-Oct-1991     Created

*/
#include "pchapplb.hxx"   // Precompiled header

#define STRING_TERMINATOR TCH('\0')

const TCHAR * SLE_STRIP :: QueryWhiteSpace ()
{
    return SZ(" \t") ;
}

/*******************************************************************

    NAME:	SLE_STRIP::SLE_STRIP

    SYNOPSIS:	Constructor - Same as ICANON_SLE

    ENTRY:	powin	 - pointer OWNER_WINDOW
                cid      - CID
		usMaxLen - Maximum number of characters allowed to be typed in

    EXIT:	The object is constructed.

    HISTORY:
	Yi-HsinS     5-Oct-1991	Created

********************************************************************/

SLE_STRIP::SLE_STRIP( OWNER_WINDOW * powin, CID cid,
		      UINT usMaxLen, INT nNameType)
    : ICANON_SLE( powin, cid, usMaxLen, nNameType )
{
    if ( QueryError() != NERR_Success )
	return;
}


/*******************************************************************

    NAME:	SLE_STRIP::SLE_STRIP

    SYNOPSIS:	Constructor - Same as ICANON_SLE

    ENTRY:	

    EXIT:	The object is constructed.

    HISTORY:
	Yi-HsinS     5-Oct-1991	Created

********************************************************************/

SLE_STRIP::SLE_STRIP( OWNER_WINDOW * powin, CID cid,
	              XYPOINT xy, XYDIMENSION dxy,
	              ULONG flStyle, const TCHAR * pszClassName,
	              UINT usMaxLen, INT nNameType )
    : ICANON_SLE( powin, cid, xy, dxy, flStyle,
		  pszClassName, usMaxLen, nNameType)
{
    if ( QueryError() != NERR_Success )
	return;
}


/*******************************************************************

    NAME:	SLE_STRIP::QueryText

    SYNOPSIS:	Query the text in the SLE, the leading characters in
		pszBefore is stripped and the trailing characters in
		pszAfter is stripped off as well.

    ENTRY:	pszBuffer - Buffer
		cbBufSize - size of pszBuffer
		pszBefore - contains the characters to be stripped off
			    from the beginning of the text
		pszAfter  - contains the characters to be stripped off
			    at the end of the text

    EXIT:	

    RETURNS:

    HISTORY:
	Yi-HsinS     5-Oct-1991	Created

********************************************************************/

APIERR SLE_STRIP::QueryText( TCHAR * pszBuffer,
			     UINT cbBufSize,
		             const TCHAR *pszBefore,
			     const TCHAR *pszAfter ) const
{
     UIASSERT( pszBuffer != NULL );

     APIERR err = NERR_Success;
     if ( ( err = ICANON_SLE::QueryText( pszBuffer, cbBufSize) )
			!= NERR_Success )
     {

         ALIAS_STR nls( pszBuffer);
         if (  ((err = ::TrimLeading( &nls, pszBefore )) != NERR_Success )
	    && ((err = ::TrimTrailing( &nls, pszAfter )) != NERR_Success )
	    )
         {
	    ;   // Nothing to do
         }
     }

     return err;

}


/*******************************************************************

    NAME:	SLE_STRIP::QueryText

    SYNOPSIS:	Query the text in the SLE, the leading characters in
		pszBefore is stripped and the trailing characters in
		pszAfter is stripped off as well.

    ENTRY:	pnls      - the place to put text to
		pszBefore - contains the characters to be stripped off
			    from the beginning of the text
		pszAfter  - contains the characters to be stripped off
			    at the end of the text

    EXIT:	

    RETURNS:

    HISTORY:
	Yi-HsinS     5-Oct-1991	Created

********************************************************************/

APIERR SLE_STRIP::QueryText( NLS_STR * pnls,
		             const TCHAR *pszBefore,
			     const TCHAR *pszAfter ) const
{

     APIERR err = NERR_Success;
     if (  (( err = ICANON_SLE::QueryText( pnls )) != NERR_Success )
        || (( err = ::TrimLeading( pnls, pszBefore )) != NERR_Success )
	|| (( err = ::TrimTrailing( pnls, pszAfter )) != NERR_Success )
	)
     {
	 ;   // Nothing to do
     }

     return err;
}


/*******************************************************************

    NAME:	GLOBAL::TrimLeading

    SYNOPSIS:	The leading characters in pnls that belongs to pszBefore
		is stripped off.

    ENTRY:	pnls      - the string
		pszBefore - contains the characters to be stripped off
			    from the beginning of the text

    EXIT:	

    RETURNS:

    HISTORY:
	Yi-HsinS     5-Oct-1991	Created

********************************************************************/

APIERR TrimLeading( NLS_STR *pnls, const TCHAR *pszBefore)
{
    // If pszBefore is NULL, just return success.
    if ( pszBefore == NULL )
	return NERR_Success;

    ALIAS_STR nlsBefore( pszBefore );
    ISTR istrStart( *pnls ) , istrEnd( *pnls );

    if ( pnls->strspn( &istrEnd, nlsBefore) )
        pnls->DelSubStr( istrStart, istrEnd);

    return pnls->QueryError();
}


/*******************************************************************

    NAME:	GLOBAL::TrimTrailing

    SYNOPSIS:	The trailing characters in pnls that belongs to pszAfter
		is stripped off.

    ENTRY:	pnls      - the string
		pszAfter  - contains the characters to be stripped off
			    at the end of the text

    EXIT:	

    RETURNS:

    HISTORY:
	Yi-HsinS     5-Oct-1991	Created

********************************************************************/

APIERR TrimTrailing( NLS_STR *pnls, const TCHAR *pszAfter)
{
    // If pszAfter is NULL, just return success.
    if ( pszAfter == NULL )
	return NERR_Success;

    ALIAS_STR nlsAfter( pszAfter );
    ISTR istrAfter( nlsAfter );
    BOOL fFound = TRUE;

    while ( fFound )
    {
	fFound = FALSE;
        istrAfter.Reset();

        while ( nlsAfter.QueryChar( istrAfter )  != STRING_TERMINATOR  )
        {
	    ISTR istr( *pnls );
	    if (  ( pnls->strrchr( &istr, nlsAfter.QueryChar( istrAfter )))
	       && ( istr.IsLastPos() )
	       )
	    {
		  pnls->DelSubStr( istr );
		  fFound = TRUE;
		  break;
	    }
	    ++istrAfter;

	}
    }

    return pnls->QueryError();
}

//  End of SLESTRIP.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\uidomain.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    uidomain.cxx
    This file contains the class definitions for the UI_DOMAIN class.

    The UI_DOMAIN class is somewhat similar to the "normal" DOMAIN class.
    In fact, UI_DOMAIN *contains* a DOMAIN object.  The only external
    difference is that UI_DOMAIN::GetInfo will prompt the user for
    the name of a known DC if either the MNetGetDCName or I_MNetGetDCList
    API fails.


    FILE HISTORY:
        KeithMo     30-Aug-1992     Created.

*/

#include "pchapplb.hxx"   // Precompiled header


//
//  The maximum computer name length accepted by the dialog.
//

#define UI_MAX_COMPUTERNAME_LENGTH      MAX_PATH



//
//  UI_DOMAIN methods.
//


/*******************************************************************

    NAME:       UI_DOMAIN :: UI_DOMAIN

    SYNOPSIS:   UI_DOMAIN class constructor.

    ENTRY:      wndOwner                - The "owning" window.

                hc                      - Help context to be used if a
                                          prompt dialog is necessary.

                pszDomainName           - Name of the target domain.

                fBackupDCsOK            - If TRUE, then QueryPDC may
                                          actually return a BDC.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
UI_DOMAIN :: UI_DOMAIN( PWND2HWND   & wndOwner,
                        ULONG         hc,
                        const TCHAR * pszDomainName,
                        BOOL          fBackupDCsOK )
  : BASE(),
    _wndOwner( wndOwner ),
    _hc( hc ),
    _nlsDomainName( pszDomainName ),
    _nlsBackupDC(),
    _fBackupDCsOK( fBackupDCsOK ),
    _pdomain( NULL )
{
    UIASSERT( pszDomainName != NULL );

    //
    //  Ensure everything constructed properly.
    //

    APIERR err;

    if( ( ( err = QueryError()                ) != NERR_Success ) ||
        ( ( err = _nlsDomainName.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsBackupDC.QueryError()   ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

}   // UI_DOMAIN :: UI_DOMAIN


/*******************************************************************

    NAME:       UI_DOMAIN :: ~UI_DOMAIN

    SYNOPSIS:   UI_DOMAIN class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
UI_DOMAIN :: ~UI_DOMAIN( VOID )
{
    delete _pdomain;
    _pdomain = NULL;

}   // UI_DOMAIN :: ~UI_DOMAIN


/*******************************************************************

    NAME:       UI_DOMAIN :: GetInfo

    SYNOPSIS:   Creates the actual DOMAIN object.  May prompt the
                user for a known DC in the domain.

    EXIT:       If successful, then a DOMAIN object is created.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
APIERR UI_DOMAIN :: GetInfo( VOID )
{
    UIASSERT( _pdomain == NULL );

    //
    //  Create the domain object.
    //

    _pdomain = new DOMAIN( _nlsDomainName );

    APIERR err = ( _pdomain == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                      : _pdomain->GetInfo();

    if( ( err != NERR_DCNotFound ) || !_fBackupDCsOK )
    {
        return err;
    }

    //
    //  We no longer need the domain object.
    //

    delete _pdomain;
    _pdomain = NULL;

    //
    //  Loop until either success or the user bags out.
    //

    while( TRUE )
    {
        //
        //  Prompt the user for a known DC in the domain.
        //

        BOOL fUserPressedOK = FALSE;
        PROMPT_FOR_ANY_DC_DLG * pDlg = new PROMPT_FOR_ANY_DC_DLG( _wndOwner,
                                                                  _hc,
                                                                  &_nlsDomainName,
                                                                  &_nlsBackupDC );

        err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                               : pDlg->Process( &fUserPressedOK );

        delete pDlg;

        if( err == NERR_Success )
        {
            //
            //  Ensure the string didn't barf.
            //

            err = _nlsBackupDC.QueryError();
        }

        if( err != NERR_Success )
        {
            break;
        }

        if( !fUserPressedOK )
        {
            //
            //  The user bagged-out.
            //

            err = NERR_DCNotFound;
            break;
        }

        //
        //  Determine if the specified server is really a DC
        //  in the target domain.  We do this by confirming
        //  that the machine's primary domain is the target
        //  domain and that the machine's role is backup or
        //  primary.
        //

        API_SESSION apisess( _nlsBackupDC );

        err = apisess.QueryError();

        if( err == NERR_Success )
        {
            WKSTA_10 wks( _nlsBackupDC );

            err = wks.QueryError();

            if( err == NERR_Success )
            {
                err = wks.GetInfo();
            }

            if( ( err == NERR_Success ) &&
                !::I_MNetComputerNameCompare( _nlsDomainName,
                                              wks.QueryWkstaDomain() ) )
            {
                //
                //  We now know that the server is indeed in
                //  the target domain.  Now verify that it's
                //  role is backup or primary.
                //

                SERVER_1 srv( _nlsBackupDC );

                err = srv.QueryError();

                if( err == NERR_Success )
                {
                    err = srv.GetInfo();
                }

                if( err == NERR_Success )
                {
                    if( srv.QueryServerType() &
                            ( SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL ) )
                    {
                        //
                        //  It is a backup or primary, so exit the loop
                        //  with err == NERR_Success.
                        //

                        break;
                    }
                }
            }
        }

        if( ( err != NERR_Success         ) &&
            ( err != NERR_NameNotFound    ) &&
            ( err != NERR_NetNameNotFound ) &&
            ( err != ERROR_NOT_SUPPORTED  ) &&
            ( err != ERROR_BAD_NETPATH    ) &&
            ( err != ERROR_LOGON_FAILURE  ) )
        {
            //
            //  Something fatal happened.
            //

            break;
        }
    }

    return err;

}   // UI_DOMAIN :: GetInfo


/*******************************************************************

    NAME:       UI_DOMAIN :: QueryName

    SYNOPSIS:   Returns the name of the target domain.

    RETURNS:    const TCHAR *           - The target domain's name.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
const TCHAR * UI_DOMAIN :: QueryName( VOID ) const
{
    const TCHAR * pszName = NULL;

    if( _fBackupDCsOK && ( _pdomain == NULL ) )
    {
        pszName = _nlsDomainName;
    }
    else
    {
        pszName = _pdomain->QueryName();
    }

    return pszName;

}   // UI_DOMAIN :: QueryName


/*******************************************************************

    NAME:       UI_DOMAIN :: QueryPDC

    SYNOPSIS:   Returns the name of the target domain's PDC.  If
                the object was constructed with fBackupDCsOK, then
                this method may actually return the name of a BDC.

    RETURNS:    const TCHAR *           - The PDC (BDC??) in the domain.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
const TCHAR * UI_DOMAIN :: QueryPDC( VOID ) const
{
    const TCHAR * pszPDC = NULL;

    if( _fBackupDCsOK && ( _pdomain == NULL ) )
    {
        pszPDC = _nlsBackupDC;
    }
    else
    {
        pszPDC = _pdomain->QueryPDC();
    }

    return pszPDC;

}   // UI_DOMAIN :: QueryPDC


/*******************************************************************

    NAME:       UI_DOMAIN :: QueryAnyDC

    SYNOPSIS:   Returns the name of a DC in the target domain.

    RETURNS:    const TCHAR *           - The target domain's name.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
const TCHAR * UI_DOMAIN :: QueryAnyDC( VOID ) const
{
    const TCHAR * pszAnyDC = NULL;

    if( _fBackupDCsOK && ( _pdomain == NULL ) )
    {
        pszAnyDC = _nlsBackupDC;
    }
    else
    {
        pszAnyDC = _pdomain->QueryAnyDC();
    }

    return pszAnyDC;

}   // UI_DOMAIN :: QueryAnyDC



//
//  PROMPT_FOR_ANY_DC_DLG methods.
//


/*******************************************************************

    NAME:       PROMPT_FOR_ANY_DC_DLG :: PROMPT_FOR_ANY_DC_DLG

    SYNOPSIS:   PROMPT_FOR_ANY_DC_DLG class constructor.

    ENTRY:      wndOwner                - The "owning" window.

                hc                      - Help context.

                pnlsDomainName          - Name of the target domain.

                pnlsKnownDC             - Will receive the DC name entered
                                          by the user.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
PROMPT_FOR_ANY_DC_DLG :: PROMPT_FOR_ANY_DC_DLG( PWND2HWND     & wndOwner,
                                                ULONG           hc,
                                                const NLS_STR * pnlsDomainName,
                                                NLS_STR       * pnlsKnownDC )
  : DIALOG_WINDOW( IDD_PROMPT_FOR_ANY_DC_DLG,
                   wndOwner ),
    _hc( hc ),
    _pnlsKnownDC( pnlsKnownDC ),
    _sltMessage( this, IDPDC_MESSAGE ),
    _sleKnownDC( this, IDPDC_SERVER, UI_MAX_COMPUTERNAME_LENGTH )
{
    UIASSERT( pnlsDomainName != NULL );
    UIASSERT( pnlsKnownDC != NULL );

    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Load the message string.
    //

    RESOURCE_STR nlsMessage( IDS_APPLIB_PROMPT_FOR_ANY_DC );

    APIERR err = nlsMessage.QueryError();

    if( err == NERR_Success )
    {
        //
        //  Insert the domain name into the message string.
        //

        const NLS_STR * apnlsInsertParams[2];

        apnlsInsertParams[0] = pnlsDomainName;
        apnlsInsertParams[1] = NULL;

        err = nlsMessage.InsertParams( apnlsInsertParams );
    }

    if( err == NERR_Success )
    {
        _sltMessage.SetText( nlsMessage );
    }

    if( err != NERR_Success )
    {
        ReportError( err );
    }

}   // PROMPT_FOR_ANY_DC_DLG :: PROMPT_FOR_ANY_DC_DLG


/*******************************************************************

    NAME:       PROMPT_FOR_ANY_DC_DLG :: ~PROMPT_FOR_ANY_DC_DLG

    SYNOPSIS:   PROMPT_FOR_ANY_DC_DLG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
PROMPT_FOR_ANY_DC_DLG :: ~PROMPT_FOR_ANY_DC_DLG( VOID )
{
    _pnlsKnownDC = NULL;

}   // PROMPT_FOR_ANY_DC_DLG :: ~PROMPT_FOR_ANY_DC_DLG


/*******************************************************************

    NAME:       PROMPT_FOR_ANY_DC_DLG :: OnOK

    SYNOPSIS:   Invoked when the user presses the OK button.

    RETURNS:    BOOL                    - TRUE  if we handled the message,
                                          FALSE otherwise.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
BOOL PROMPT_FOR_ANY_DC_DLG :: OnOK( VOID )
{
    NLS_STR nlsServer;
    APIERR err = nlsServer.QueryError();

    if( err == NERR_Success )
    {
        //
        //  Get the server from the edit field.
        //

        err = _sleKnownDC.QueryText( &nlsServer );
    }

    if( err == NERR_Success )
    {
        //
        //  Validate the server name.
        //

        if( ::I_MNetNameValidate( NULL,
                                  nlsServer,
                                  NAMETYPE_COMPUTER,
                                  0L ) != NERR_Success )
        {
            _sleKnownDC.SelectString();
            _sleKnownDC.ClaimFocus();

            err = IDS_APPLIB_PROMPT_DC_INVALID_SERVER;
        }
    }

    if( err == NERR_Success )
    {
        //
        //  Update the user's string.
        //

        err = _pnlsKnownDC->CopyFrom( SZ("\\\\") );

        if( err == NERR_Success )
        {
            err = _pnlsKnownDC->Append( nlsServer );
        }
    }

    if( err == NERR_Success )
    {
        //
        //  All OK, dismiss the dialog.
        //

        Dismiss( TRUE );
    }
    else
    {
        //
        //  An error occurred somewhere along the way.
        //

        ::MsgPopup( this, err );
    }

    return TRUE;

}   // PROMPT_FOR_ANY_DC_DLG :: OnOK


/*******************************************************************

    NAME:       PROMPT_FOR_ANY_DC_DLG :: QueryHelpContext

    SYNOPSIS:   Returns the help context.

    RETURNS:    ULONG                   - The help context for this dialog.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
ULONG PROMPT_FOR_ANY_DC_DLG :: QueryHelpContext( VOID )
{
    return _hc;

}   // PROMPT_FOR_ANY_DC_DLG :: QueryHelpContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\uix.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    uix.cxx
    This file contains the class definitions for the classes related
    to NETUI Application Extension management.

    There are three categories of objects used to manipulate application
    extensions:

        Objects derived from UI_EXT represent the actual extensions.
        There is one such object for each extension loaded into the
        application.  All extension manipulation (activate, refresh,
        unload, etc) occur through these objects.

        Objects derived from UI_EXT_MGR represent extension managers.
        There is at most one extension manager "active" at any given
        time.  The extension manager is responsible for maintaining
        the list of extension objects and sending any "broadcast"
        notifications to each object.

        Objects derived from UI_EXT_MGR_IF represent extension manager
        interfaces.  These objects act as an interface between the
        extension manager and the application.  Whenever the extension
        manager needs to interact with the application (such as retrieving
        the list of available extensions) it is done through the interface
        object.

    The class hierarchy is structured as follows:

        BASE
        |
        +---UI_EXT
        |   |
        |   +---UI_BUTTON_EXT
        |   |
        |   +---UI_MENU_EXT
        |   |
        |   \---UI_TOOLBAR_EXT
        |
        +---UI_EXT_MGR
        |   |
        |   +---UI_BUTTON_EXT_MGR
        |   |
        |   +---UI_MENU_EXT_MGR
        |   |
        |   \---UI_TOOLBAR_EXT_MGR
        |
        \---UI_EXT_MGR_IF

    NOTE:   At the time this module was written (19-Oct-1992) only the
            MENU derivitives of UI_EXT and UI_EXT_MGR were implemented.
            The BUTTON and TOOLBAR class are shown in the above hierarchy
            for illustration purposes only.

    To integrate extension support into an application:

        0.  Subclass one of the UI_*_EXT classes (such as UI_MENU_EXT)
            to create an extension class for the particular application.
            For example, the Server Manager subclasses UI_MENU_EXT into
            SM_MENU_EXT.

            The class constructor is responsible for loading the DLL,
            validating the entrypoints, and negotiating the version
            number.

            The class destructor is responsible for sending any unload
            notifications to the extension.

            Override all of the pure virtuals in the parent class, such
            as Refresh() and Activate().

        1.  Subclass UI_EXT_MGR_IF to create an interface for the
            particular application.  For example, the NetUI Admin App
            "framework" subclasses UI_EXT_MGR_IF into AAPP_EXT_MGR_IF.

            Override all of the pure virtuals in the parent class.  For
            example, AAPP_EXT_MGR_IF "thunks" these virtuals over to
            corresponding ADMIN_APP virtuals.

        2.  At an appropriate time in the application, create a new
            *_EXT_MGR_IF object, then create a new UI_*_EXT_MGR object,
            giving it the address of the interface object.  The two are
            now bound together.

        3.  Invoke UI_*_EXT_MGR::LoadExtensions().  The extensions will
            be loaded.

        4.  At an appropriate time in the application, invoke the
            UI_*_EXT_MGR::ActivateExtension() method.  For example,
            ADMIN_APP does this in OnMenuCommand() if the menu ID is
            greater than some specific value (the initial ID delta).


    FILE HISTORY:
        KeithMo     19-Oct-1992     Created.

*/

#include "pchapplb.hxx"   // Precompiled header

//
//  UI_EXT methods.
//

/*******************************************************************

    NAME:       UI_EXT :: UI_EXT

    SYNOPSIS:   UI_EXT class constructor.

    ENTRY:      pszDllName              - Name of this extension's DLL.

                dwDelta                 - The menu/control ID delta
                                          for this extension.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_EXT :: UI_EXT( const TCHAR * pszDllName,
                  DWORD         dwDelta )
  : BASE(),
    _dwVersion( 0 ),
    _nlsDllName( pszDllName ),
    _hDll( NULL ),
    _dwDelta( dwDelta )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "UI_EXT failed to construct" );
        return;
    }

    if( !_nlsDllName )
    {
        ReportError( _nlsDllName.QueryError() );
        return;
    }

}   // UI_EXT :: UI_EXT


/*******************************************************************

    NAME:       UI_EXT :: ~UI_EXT

    SYNOPSIS:   UI_EXT class destructor.

    EXIT:       The object is destroyed.  The DLL will be freed if
                it was actually loaded.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_EXT :: ~UI_EXT( VOID )
{
    if( _hDll != NULL )
    {
        if( !::FreeLibrary( _hDll ) )
        {
            APIERR err = (APIERR)::GetLastError();

            DBGEOL( "UI_EXT::~UI_EXT - FreeLibrary returned " << err );
        }

        _hDll = NULL;
    }

}   // UI_EXT :: ~UI_EXT



//
//  UI_MENU_EXT methods.
//

/*******************************************************************

    NAME:       UI_MENU_EXT :: UI_MENU_EXT

    SYNOPSIS:   UI_MENU_EXT class constructor.

    ENTRY:      pszDllName              - Name of this extension's DLL.

                dwDelta                 - The menu/control ID delta
                                          for this extension.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_MENU_EXT :: UI_MENU_EXT( const TCHAR * pszDllName,
                            DWORD         dwDelta )
  : UI_EXT( pszDllName, dwDelta ),
    _nlsMenuName(),
    _hMenu( NULL )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "UI_MENU_EXT failed to construct" );
        return;
    }

    if( !_nlsMenuName )
    {
        ReportError( _nlsMenuName.QueryError() );
        return;
    }

}   // UI_MENU_EXT :: UI_MENU_EXT


/*******************************************************************

    NAME:       UI_MENU_EXT :: ~UI_MENU_EXT

    SYNOPSIS:   UI_MENU_EXT class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_MENU_EXT :: ~UI_MENU_EXT( VOID )
{
    _hMenu = NULL;

}   // UI_MENU_EXT :: ~UI_MENU_EXT


/*******************************************************************

    NAME:       UI_MENU_EXT :: BiasMenuIds

    SYNOPSIS:   Applies a bias (delta) to each ID in a menu.

    ENTRY:      dwDelta                 - The delta to be applied to
                                          each ID.

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:      This method calls through to W_BiasMenuIds to do
                all of the (recursive) dirty work.

    HISTORY:
        KeithMo     20-Oct-1992     Created.

********************************************************************/
APIERR UI_MENU_EXT :: BiasMenuIds( DWORD  dwDelta )
{
    //
    //  Let W_BiasMenuIds handle the dirty work.
    //

    APIERR err = W_BiasMenuIds( QueryMenuHandle(), dwDelta );

    if( err != NERR_Success )
    {
        DBGEOL( "UI_MENU_EXT::BiasMenuIds - error " << err );
    }

    return err;

}   // UI_MENU_EXT :: BiasMenuIds


/*******************************************************************

    NAME:       UI_MENU_EXT :: W_BiasMenuIds

    SYNOPSIS:   Private worker method for BiasMenuIds.

    ENTRY:      hMenu                   - The menu to adjust.

                dwDelta                 - The delta to be applied to
                                          each ID.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Oct-1992     Created.

********************************************************************/
APIERR UI_MENU_EXT :: W_BiasMenuIds( HMENU  hMenu,
                                     DWORD  dwDelta )
{
    //
    //  menu represents our target menu.
    //
    //  nlsText will contain the display text of
    //  menus that are modified.
    //

    POPUP_MENU menu( hMenu );
    NLS_STR    nlsText;

    //
    //  Ensure everything constructed properly.
    //

    APIERR err = menu.QueryError();

    if( err == NERR_Success )
    {
        err = nlsText.QueryError();
    }

    if( err == NERR_Success )
    {
        //
        //  Get the number of items in the menu.
        //

        INT cItems = menu.QueryItemCount();

        for( INT pos = 0 ; pos < cItems ; pos++ )
        {
            //
            //  See if the current item is a popup.  Only popups
            //  will return a non-NULL value from QuerySubMenu().
            //

            HMENU hSubMenu = menu.QuerySubMenu( pos );

            if( hSubMenu != NULL )
            {
                err = W_BiasMenuIds( hSubMenu, dwDelta );

                if( err != NERR_Success )
                {
                    break;
                }

                continue;
            }

            //
            //  Get the mid for the current item.
            //

            UINT mid = menu.QueryItemID( pos );

            //
            //  Abnormal items (such as menubarbreaks and separators)
            //  return 0xFFFFFFFF or 0 as their mid.  Ignore these.
            //

            if( ( mid == (UINT)-1L ) || ( mid == 0 ) )
            {
                continue;
            }

            //
            //  OK, so we now know we have found a "normal" item.
            //  Let's see if we can get the item's text.
            //

            err = menu.QueryItemText( &nlsText,
                                      pos,
                                      MF_BYPOSITION );

            if( err == NERR_Success )
            {
                //
                //  Cool.  Now adjust the mid by adding the
                //  user-supplied delta.
                //

                err = menu.Modify( nlsText,
                                   pos,
                                   mid + (UINT)dwDelta,
                                   MF_BYPOSITION );
            }

            if( err != NERR_Success )
            {
                //
                //  Something failed along the way, so abort
                //  the loop.
                //

                break;
            }
        }
    }

    return err;

}   // UI_MENU_EXT :: W_BiasMenuIds



//
//  UI_EXT_MGR methods.
//

/*******************************************************************

    NAME:       UI_EXT_MGR :: UI_EXT_MGR

    SYNOPSIS:   UI_EXT_MGR class constructor.

    ENTRY:      pExtMgrIf               - Points to an object representing
                                          the interface between the
                                          extension manager & the application.

                dwInitialDelta          - The initial menu/control ID delta.

                dwDeltaDelta            - The "inter-delta offset".

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_EXT_MGR :: UI_EXT_MGR( UI_EXT_MGR_IF * pExtMgrIf,
                          DWORD           dwInitialDelta,
                          DWORD           dwDeltaDelta )
  : BASE(),
    _pExtMgrIf( pExtMgrIf ),
    _dwDelta( dwInitialDelta ),
    _dwDeltaDelta( dwDeltaDelta ),
    _slExtensions( FALSE )
{
    UIASSERT( pExtMgrIf != NULL );
    UIASSERT( pExtMgrIf->QueryError() == NERR_Success );

    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "UI_EXT_MGR failed to construct" );
        return;
    }

}   // UI_EXT_MGR :: UI_EXT_MGR


/*******************************************************************

    NAME:       UI_EXT_MGR :: ~UI_EXT_MGR

    SYNOPSIS:   UI_EXT_MGR class destructor.

    EXIT:       The object is destroyed.  All extensions are unloaded.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_EXT_MGR :: ~UI_EXT_MGR( VOID )
{
    UnloadExtensions();
    _pExtMgrIf = NULL;

}   // UI_EXT_MGR :: ~UI_EXT_MGR


/*******************************************************************

    NAME:       UI_EXT_MGR :: FindExtensionByName

    SYNOPSIS:   Locate an extension given its DLL name.

    ENTRY:      pszDllName              - The name of the extension's DLL.

    RETURNS:    UI_EXT *                - The extension, NULL if not found.

    HISTORY:
        KeithMo     26-Oct-1992     Created.

********************************************************************/
UI_EXT * UI_EXT_MGR :: FindExtensionByName( const TCHAR * pszDllName )
{
    UIASSERT( pszDllName != NULL );
    UIASSERT( _pExtMgrIf != NULL );
    UIASSERT( _pExtMgrIf->QueryError() == NERR_Success );

    //
    //  Enumerate the extension objects, looking for a match.
    //

    ITER_SL_OF( UI_EXT ) iter( *QueryExtensions() );
    UI_EXT * pExt;

    while( ( pExt = iter.Next() ) != NULL )
    {
        const TCHAR * pszTmp = pExt->QueryDllName();

        if( ( pszTmp != NULL ) && ( ::stricmpf( pszTmp, pszDllName ) == 0 ) )
        {
            break;
        }
    }

    return pExt;

}   // UI_EXT_MGR :: FindExtensionByName


/*******************************************************************

    NAME:       UI_EXT_MGR :: FindExtensionByDelta

    SYNOPSIS:   Locate an extension given its menu/control ID delta.

    ENTRY:      dwDelta                 - The search delta.

    RETURNS:    UI_EXT *                - The extension, NULL if not found.

    HISTORY:
        KeithMo     26-Oct-1992     Created.

********************************************************************/
UI_EXT * UI_EXT_MGR :: FindExtensionByDelta( DWORD dwDelta )
{
    UIASSERT( _pExtMgrIf != NULL );
    UIASSERT( _pExtMgrIf->QueryError() == NERR_Success );

    //
    //  Enumerate the extension objects, looking for a match.
    //

    ITER_SL_OF( UI_EXT ) iter( *QueryExtensions() );
    UI_EXT * pExt;

    while( ( pExt = iter.Next() ) != NULL )
    {
        DWORD dwTmp = pExt->QueryDelta();

        if( ( dwDelta >= dwTmp ) && ( dwDelta < ( dwTmp + QueryDeltaDelta() ) ) )
            break;
    }

    return pExt;

}   // UI_EXT_MGR :: FindExtensionByDelta


/*******************************************************************

    NAME:       UI_EXT_MGR :: W_LoadExtension

    SYNOPSIS:   Worker method to load a UI_EXT.  Typically just thunks
                through the interface object to let the application do
                the dirty work.

    ENTRY:      pszExtensionDll         - The name of the DLL containing
                                          the app extension.

                dwDelta                 - A menu/control ID delta for the
                                          extension's menus/controls.

    RETURNS:    UI_EXT *                - The newly loaded extension.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_EXT * UI_EXT_MGR :: W_LoadExtension( const TCHAR * pszExtensionDll,
                                        DWORD         dwDelta )
{
    UIASSERT( pszExtensionDll != NULL );
    UIASSERT( _pExtMgrIf != NULL );
    UIASSERT( _pExtMgrIf->QueryError() == NERR_Success );

    //
    //  Let the app (via the interface object) do the dirty work.
    //

    UI_EXT * pExt = _pExtMgrIf->LoadExtension( pszExtensionDll,
                                               dwDelta );

#ifdef DEBUG
    if( pExt == NULL )
    {
        DBGEOL( "UI_EXT_MGR::W_LoadExtension - _pExtMgrIf returned NULL" );
    }
    else
    if( pExt->QueryError() != NERR_Success )
    {
        DBGEOL( "UI_EXT_MGR::W_LoadExtension - pExt returned "
                << pExt->QueryError() );
    }
#endif  // DEBUG

    return pExt;

}   // UI_EXT_MGR :: W_LoadExtension


/*******************************************************************

    NAME:       UI_EXT_MGR :: LoadExtensions

    SYNOPSIS:   This method loads all extensions available to the
                application.

    RETURNS:    UINT                    - The number of extensions
                                          successfully loaded.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UINT UI_EXT_MGR :: LoadExtensions( VOID )
{
    UIASSERT( _pExtMgrIf != NULL );
    UIASSERT( _pExtMgrIf->QueryError() == NERR_Success );

    //
    //  Get the list of available extension DLLs.
    //

    STRLIST * psl = _pExtMgrIf->GetExtensionList();

    if( psl == NULL )
    {
        DBGEOL( "UI_EXT_MGR::LoadExtensions - _pExtMgrIf returned NULL list" );
        return 0;
    }

    //
    //  Now scan the extension DLL list, calling W_LoadExtension
    //  on each.
    //

    ITER_STRLIST itersl( *psl );
    NLS_STR * pnls;
    UINT cExtensions = 0;

    while( ( pnls = itersl.Next() ) != NULL )
    {
        //
        //  Try to load the extension.
        //

        UI_EXT * pExt = W_LoadExtension( pnls->QueryPch(),
                                         _dwDelta );

        //
        //  Update the next delta.
        //

        _dwDelta += _dwDeltaDelta;

        if( ( pExt != NULL ) && ( pExt->QueryError() == NERR_Success ) )
        {
            if( _slExtensions.Append( pExt ) == NERR_Success )
            {
                cExtensions++;
            }
        }
    }

    //
    //  Delete the STRLIST before returning.
    //

    delete psl;
    psl = NULL;

    return cExtensions;

}   // UI_EXT_MGR :: LoadExtensions


/*******************************************************************

    NAME:       UI_EXT_MGR :: UnloadExtensions

    SYNOPSIS:   This method unloads all loaded extensions.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
VOID UI_EXT_MGR :: UnloadExtensions( VOID )
{
    UIASSERT( _pExtMgrIf != NULL );
    UIASSERT( _pExtMgrIf->QueryError() == NERR_Success );

    //
    //  Enumerate the & delete the extension objects.  This
    //  will force the actual extensions to get unloaded.
    //

    ITER_SL_OF( UI_EXT ) iter( *QueryExtensions() );
    UI_EXT * pExt;

    while( ( pExt = iter.Next() ) != NULL )
    {
        delete pExt;
    }

}   // UI_EXT_MGR :: UnloadExtensions


/*******************************************************************

    NAME:       UI_EXT_MGR :: RefreshExtensions

    SYNOPSIS:   This method refreshes all loaded extensions.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
VOID UI_EXT_MGR :: RefreshExtensions( HWND hwndParent )
{
    UIASSERT( _pExtMgrIf != NULL );
    UIASSERT( _pExtMgrIf->QueryError() == NERR_Success );

    //
    //  Enumerate & refresh the extension objects.
    //

    ITER_SL_OF( UI_EXT ) iter( *QueryExtensions() );
    UI_EXT * pExt;

    while( ( pExt = iter.Next() ) != NULL )
    {
        pExt->Refresh( hwndParent );
    }

}   // UI_EXT_MGR :: RefreshExtensions


/*******************************************************************

    NAME:       UI_EXT_MGR :: ActivateExtension

    SYNOPSIS:   This method activates the extension with the given
                menu/control ID.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
VOID UI_EXT_MGR :: ActivateExtension( HWND hwndParent, DWORD dwId )
{
    UIASSERT( _pExtMgrIf != NULL );
    UIASSERT( _pExtMgrIf->QueryError() == NERR_Success );

    //
    //  Enumerate the extension objects, looking for an ID match.
    //

    ITER_SL_OF( UI_EXT ) iter( *QueryExtensions() );
    UI_EXT * pExt;

    while( ( pExt = iter.Next() ) != NULL )
    {
        DWORD dwDelta = pExt->QueryDelta();

        if( ( dwDelta <= dwId ) &&
            ( ( dwDelta + QueryDeltaDelta() ) > dwId ) )
        {
            _pExtMgrIf->ActivateExtension( hwndParent, pExt, dwId - dwDelta );
            break;
        }
    }

}   // UI_EXT_MGR :: ActivateExtension



//
//  UI_MENU_EXT_MGR methods.
//

/*******************************************************************

    NAME:       UI_MENU_EXT_MGR :: UI_MENU_EXT_MGR

    SYNOPSIS:   UI_MENU_EXT_MGR class constructor.

    ENTRY:      pExtMgrIf               - Points to an object representing
                                          the interface between the
                                          extension manager & the application.

                dwInitialDelta          - The initial menu/control ID delta.

                dwDeltaDelta            - The "inter-delta offset".

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_MENU_EXT_MGR :: UI_MENU_EXT_MGR( UI_EXT_MGR_IF * pExtMgrIf,
                                    DWORD           dwInitialDelta,
                                    DWORD           dwDeltaDelta )
  : UI_EXT_MGR( pExtMgrIf, dwInitialDelta, dwDeltaDelta )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "UI_MENU_EXT_MGR failed to construct" );
        return;
    }

}   // UI_MENU_EXT_MGR :: UI_MENU_EXT_MGR


/*******************************************************************

    NAME:       UI_MENU_EXT_MGR :: ~UI_MENU_EXT_MGR

    SYNOPSIS:   UI_MENU_EXT_MGR class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_MENU_EXT_MGR :: ~UI_MENU_EXT_MGR( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // UI_MENU_EXT_MGR :: ~UI_MENU_EXT_MGR


/*******************************************************************

    NAME:       UI_MENU_EXT_MGR :: MenuInitExtensions

    SYNOPSIS:   This method sends a menu init notification to all
                loaded extensions.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
VOID UI_MENU_EXT_MGR :: MenuInitExtensions( VOID )
{
    //
    //  Enumerate & menu init the extension objects.
    //

    ITER_SL_OF( UI_EXT ) iter( *QueryExtensions() );
    UI_MENU_EXT * pExt;

    while( ( pExt = (UI_MENU_EXT *)iter.Next() ) != NULL )
    {
        pExt->MenuInit();
    }

}   // UI_MENU_EXT_MGR :: MenuInitExtensions



//
//  UI_EXT_MGR_IF methods.
//

/*******************************************************************

    NAME:       UI_EXT_MGR_IF :: UI_EXT_MGR_IF

    SYNOPSIS:   UI_EXT_MGR_IF class constructor.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_EXT_MGR_IF :: UI_EXT_MGR_IF( VOID )
  : BASE()
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "UI_EXT_MGR_IF failed to construct" );
        return;
    }

}   // UI_EXT_MGR_IF :: UI_EXT_MGR_IF


/*******************************************************************

    NAME:       UI_EXT_MGR_IF :: ~UI_EXT_MGR_IF

    SYNOPSIS:   UI_EXT_MGR_IF class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_EXT_MGR_IF :: ~UI_EXT_MGR_IF( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // UI_EXT_MGR_IF :: ~UI_EXT_MGR_IF



DEFINE_SLIST_OF( UI_EXT );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\sleican.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    slestrip.cxx
    This file contains the class ICANON_SLE which is basically the same as
    an SLE except that it uses the Netlib I_MNetNameValidate() to validate
    the contents of the sle.

    FILE HISTORY:
        Thomaspa	13-Feb-1992     Created

*/

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:	ICANON_SLE::ICANON_SLE

    SYNOPSIS:	Constructor - Same as SLE

    ENTRY:	powin	 - pointer OWNER_WINDOW
                cid      - CID
		usMaxLen - Maximum number of characters allowed to be typed in
		nIcanonCode - NameType to pass to I_MNetNameValidate()

    EXIT:	The object is constructed.

    HISTORY:
	Yi-HsinS     5-Oct-1991	Created

********************************************************************/

ICANON_SLE::ICANON_SLE( OWNER_WINDOW * powin, CID cid,
		      UINT usMaxLen, INT nICanonCode)
    : SLE( powin, cid, usMaxLen ),
      _fUsesNetlib( ( nICanonCode == 0 ) ? FALSE : TRUE ),
      _nICanonCode( nICanonCode )
{
    if ( QueryError() != NERR_Success )
	return;
}


/*******************************************************************

    NAME:	ICANON_SLE::ICANON_SLE

    SYNOPSIS:	Constructor - Same as SLE

    ENTRY:	

    EXIT:	The object is constructed.

    HISTORY:
	Yi-HsinS     5-Oct-1991	Created

********************************************************************/

ICANON_SLE::ICANON_SLE( OWNER_WINDOW * powin, CID cid,
	              XYPOINT xy, XYDIMENSION dxy,
	              ULONG flStyle, const TCHAR * pszClassName,
	              UINT usMaxLen, INT nICanonCode )
    : SLE( powin, cid, xy, dxy, flStyle, pszClassName, usMaxLen),
      _fUsesNetlib( ( nICanonCode == 0 ) ? FALSE : TRUE ),
      _nICanonCode( nICanonCode )
{
    if ( QueryError() != NERR_Success )
	return;
}


/*******************************************************************

    NAME:	ICANON_SLE::Validate

    SYNOPSIS:	Validate the contents using I_NetNameValidate

    ENTRY:	none

    EXIT:	TRUE if contents valid, FALSE otherwise

    NOTES:
		If _fUsesNetlib is FALSE, always return TRUE.

    HISTORY:
	thomaspa    21-Jan-1992 Created
	thomaspa    21-Jul-1992 Added error mapping.

********************************************************************/

APIERR ICANON_SLE::Validate()
{
    if ( !_fUsesNetlib )
    {
	return SLE::Validate();
    }


    NLS_STR nlsName;
    QueryText( &nlsName );

    APIERR err;
    if ( (err = nlsName.QueryError()) != NERR_Success )
    {
        return err;
    }
	
    // CODEWORK: Should we be using a Servername?

    err = ::I_MNetNameValidate(NULL,
				nlsName.QueryPch(),
				_nICanonCode,
				0L );

    // We should map some errors.
    // CODEWORK: The below should really be a table
    switch ( err )
    {
    case ERROR_INVALID_NAME:
        switch ( _nICanonCode )
        {
        case NAMETYPE_USER:
	    err = NERR_BadUsername;
            break;
        default:
            break;
        }
        break;
    default:
        break;
    }

    return( err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\slestrlb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    slelbgrp.cxx

    This file contains the implementation for the SLE_STRLB_GROUP.



    FILE HISTORY:
        JohnL   11-Apr-1992     Created

*/

#include "pchapplb.hxx"   // Precompiled header

#ifndef min
#define min(a,b)   ((a)<(b) ? (a) : (b))
#endif

/*******************************************************************

    NAME:       SLE_STRLB_GROUP::SLE_STRLB_GROUP

    SYNOPSIS:   Basic constructor/destructor for this group

    ENTRY:      powin - Pointer to owner window
                psleInput - Pointer to input SLE
                pStrLB - Pointer to string listbox
                pbuttonAdd - pointer to Add button
                pbuttonRemove - Pointer to Remove button

    NOTES:

    HISTORY:
        Johnl   11-Apr-1992     Created

********************************************************************/

SLE_STRLB_GROUP::SLE_STRLB_GROUP( OWNER_WINDOW   * powin,
                                  SLE            * psleInput,
                                  STRING_LISTBOX * pStrLB,
                                  PUSH_BUTTON    * pbuttonAdd,
                                  PUSH_BUTTON    * pbuttonRemove )
    : CONTROL_GROUP ( NULL ),
      _pStrLB       ( pStrLB ),
      _psleInput    ( psleInput ),
      _pbuttonAdd   ( pbuttonAdd ),
      _pbuttonRemove( pbuttonRemove )
{
    if ( QueryError() )
        return ;

    UNREFERENCED( powin ) ;

    if ( pStrLB        == NULL ||
         psleInput     == NULL ||
         pbuttonAdd    == NULL ||
         pbuttonRemove == NULL )
    {
        ReportError( ERROR_INVALID_PARAMETER ) ;
        ASSERT( FALSE ) ;
        return ;
    }

    pStrLB->SetGroup( this ) ;
    psleInput->SetGroup( this ) ;
    pbuttonAdd->SetGroup( this ) ;
    pbuttonRemove->SetGroup( this ) ;

}

SLE_STRLB_GROUP::~SLE_STRLB_GROUP()
{
    _pStrLB = NULL ;
    _psleInput = NULL ;
    _pbuttonAdd = NULL ;
    _pbuttonRemove = NULL ;
}

/*******************************************************************

    NAME:       SLE_STRLB_GROUP::Init

    SYNOPSIS:   Adds items to the string listbox and initializes the buttons
                appropriately.

    ENTRY:      pstrlist - Optional list of strings to initialize the string
                    listbox to.

    EXIT:       The listbox will be filled and the button state will be
                correct based on the contents of the controls.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   11-Apr-1992     Created

********************************************************************/

APIERR SLE_STRLB_GROUP::Init( STRLIST * pstrlist )
{
    if ( pstrlist != NULL )
    {
        ITER_STRLIST iterStrList( *pstrlist ) ;
        NLS_STR * pnls ;

        while ( (pnls = iterStrList.Next() ))
        {
            if ( QueryStrLB()->AddItemIdemp( *pnls ) < 0 )
            {
                return ERROR_NOT_ENOUGH_MEMORY ;
            }
        }
    }

    if ( QueryStrLB()->QueryCount() > 0 )
    {
        QueryStrLB()->SelectItem( 0 ) ;
    }

    SetState() ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       SLE_STRLB_GROUP::OnAdd

    SYNOPSIS:   Adds the current contents of the Input SLE to the listbox

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   11-Apr-1992     Created
        KeithMo 12-Nov-1992     Moved major guts to W_Add virtual.

********************************************************************/

APIERR SLE_STRLB_GROUP::OnAdd( void )
{
    APIERR err = NERR_Success ;
    NLS_STR nlsAlertDestName( 30 ) ;
    if ( (err = nlsAlertDestName.QueryError()) ||
         (err = QueryInputSLE()->QueryText( & nlsAlertDestName)) ||
         (err = W_Add(nlsAlertDestName)))
    {
        /* Fall through
         */
    }

    return err ;
}

/*******************************************************************

    NAME:       SLE_STRLB_GROUP::OnRemove

    SYNOPSIS:   Removes the currently selected item from the listbox and
                places the text into the input SLE

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   11-Apr-1992     Created

********************************************************************/

APIERR SLE_STRLB_GROUP::OnRemove( void )
{
    APIERR err = NERR_Success ;
    NLS_STR nlsAlertDestName( 30 ) ;
    if ( (err = nlsAlertDestName.QueryError()) ||
         (err = QueryStrLB()->QueryItemText( &nlsAlertDestName )) )
    {
        /* Fall through
         */
    }
    else
    {
        QueryInputSLE()->SetText( nlsAlertDestName ) ;
        QueryInputSLE()->SelectString() ;
        QueryInputSLE()->ClaimFocus() ;
        INT iCurrentSel = QueryStrLB()->QueryCurrentItem() ;
        QueryStrLB()->DeleteItem( iCurrentSel ) ;
        QueryStrLB()->SelectItem( min( iCurrentSel,
                                       QueryStrLB()->QueryCount()-1 )) ;
    }

    if ( QueryStrLB()->QueryCount() == 0 )
    {
        //QueryStrLB()->Enable( FALSE ) ;
    }

    SetState() ;
    return err ;
}

/*******************************************************************

    NAME:       SLE_STRLB_GROUP::W_Add

    SYNOPSIS:   Adds a string to the listbox

    ENTRY:      psz     - The string to add to the listbox.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        KeithMo 12-Nov-1992     Created from JohnL's original OnAdd.

********************************************************************/

APIERR SLE_STRLB_GROUP::W_Add( const TCHAR * psz )
{
    APIERR err = NERR_Success ;
    BOOL fSetSel = QueryStrLB()->QueryCount() == 0 ;

    if ( QueryStrLB()->AddItemIdemp( psz ) < 0 )
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
    }
    else
    {
        QueryInputSLE()->ClearText() ;

        /* We put the focus into the SLE so we don't lose it when the "Add"
         * button is grayed
         */
        QueryInputSLE()->ClaimFocus() ;
    }

    /* If we went from a zero count to > 0 count, then select the first item
     */
    if ( fSetSel && QueryStrLB()->QueryCount() > 0 )
    {
        QueryStrLB()->Enable( TRUE ) ;
        QueryStrLB()->SelectItem( 0 ) ;
    }

    SetState() ;
    return err ;
}

/*******************************************************************

    NAME:       SLE_STRLB_GROUP::OnUserAction

    SYNOPSIS:   Watches the Input SLE and enabling the Add button appropriately
                Also catches the Add and Remove button presses.

    RETURNS:

    NOTES:      We know the only way a button changes is is somebody presses
                it.

                If we ever process any messages that doesn't modify the
                group, then we would return GROUP_NO_CHANGE instead of
                NERR_Success (which notifies our parent groups).

                If an error occurs, we simply return it and the dialog
                processing code will put up a Message box.

    HISTORY:
        Johnl   11-Apr-1992     Created

********************************************************************/

APIERR SLE_STRLB_GROUP::OnUserAction( CONTROL_WINDOW * pcwin,
                                      const CONTROL_EVENT & e )
{
    UNREFERENCED( e ) ;
    APIERR err = NERR_Success ;

    if ( pcwin == QueryInputSLE() )
    {
        QueryAddButton()->Enable( QueryInputSLE()->QueryTextLength() > 0 ) ;
    }
    else if ( pcwin == QueryAddButton() )
    {
        err = OnAdd() ;
    }
    else if ( pcwin == QueryRemoveButton() )
    {
        err = OnRemove() ;
    }

    return err ;
}

/*******************************************************************

    NAME:       SLE_STRLB_GROUP::SetState

    SYNOPSIS:   Sets the button state based on the current contents of the
                controls

    NOTES:

    HISTORY:
        JohnL   11-Apr-1992     Created

********************************************************************/

void SLE_STRLB_GROUP::SetState( void ) const
{
    QueryAddButton()->Enable( QueryInputSLE()->QueryTextLength() > 0 ) ;
    QueryRemoveButton()->Enable( QueryStrLB()->QueryCount() > 0 ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\usrbrows.h ===
#define CB_TRUSTED_DOMAINS          102
#define BUTTON_SHOW_USERS           103
#define LB_ACCOUNTS                 104
#define IDHELP                      108
#define COL_SUBJECT_NAME            202
#define COL_COMMENT                 203
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\usrbrows.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    UserBrows.cxx

    This file contains the implementation for the standard User Browser
    dialog.



    FILE HISTORY:
        Johnl   02-Mar-1992     Created
        jonn        14-Oct-1993 Use NetGetAnyDC
        jonn        14-Oct-1993 Minor focus fix (OnDlgDeactivation)

*/

#include "pchapplb.hxx"   // Precompiled header

#include "browmemb.hxx"
#include "findacct.hxx"

#ifndef min
    #define min(a,b)	 ((a)<(b)?(a):(b))
#endif

DEFINE_SLIST_OF(USER_BROWSER_LBI) ;

/*******************************************************************

    NAME:       NT_USER_BROWSER_DIALOG::NT_USER_BROWSER_DIALOG

    SYNOPSIS:   Constructor for the user browser dialog

    ENTRY:      pszDlgName - Resource name of the dialog (supplied for possible
                    derivation).
                hwndOwner - Owner hwnd
                pszServer - Name of server (in "\\server" form) the resource
                    lives on.
                ulFlags - USRBROWS_* show and incl flags.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   02-Mar-1992      Created

********************************************************************/

NT_USER_BROWSER_DIALOG::NT_USER_BROWSER_DIALOG( const TCHAR * pszDlgName,
                                        HWND          hwndOwner,
                                        const TCHAR * pszServer,
                                        ULONG         ulHelpContext,
                                        ULONG         ulFlags,
                                        const TCHAR * pszHelpFileName,
                                        ULONG ulHelpContextGlobalMembership,
                                        ULONG ulHelpContextLocalMembership,
                                        ULONG ulHelpContextSearch,
					const ADMIN_AUTHORITY * pAdminAuthPrimary )
    : DIALOG_WINDOW           ( pszDlgName, hwndOwner ),
      _fIsSingleSelection     ( !!(ulFlags & USRBROWS_SINGLE_SELECT)  ),
      _fEnableMembersButton   ( TRUE ),
      _lbAccounts             ( this, LB_ACCOUNTS ),
      _cbDomains              ( this, CB_TRUSTED_DOMAINS ),
      _buttonShowUsers	      ( this, BUTTON_SHOW_USERS ),
      _buttonSearch	         ( this, USR_BUTTON_SEARCH ),
      _buttonMembers	         ( this, USR_BUTTON_MEMBERS ),
      _buttonOK 	            ( this, IDOK ),
      _buttonAdd	            ( this, USR_BUTTON_ADD ),
      _sleBrowseErrorText     ( this, USR_SLT_BROWSER_ERROR ),
      _mleAdd		            ( this,
                                USR_MLE_ADD,
                                pszServer,
                                this,
				                    !!(ulFlags & USRBROWS_SINGLE_SELECT),
				                    ulFlags ),
      _pbrowdomainCurrentFocus( NULL ),
      _pszServerResourceLivesOn( pszServer ),
      _ulFlags                ( ulFlags ),
      _fDomainsComboIsDropped ( FALSE ),
      _fUsersAreShown         ( FALSE ),
      _ulHelpContext          ( ulHelpContext ),
      _pszHelpFileName	      ( pszHelpFileName ),
      _ulHelpContextGlobalMembership( ulHelpContextGlobalMembership ),
      _ulHelpContextLocalMembership ( ulHelpContextLocalMembership ),
      _ulHelpContextSearch          ( ulHelpContextSearch ),
      _nlsDCofPrimaryDomain   (),
      _hwndLastFocus          ( NULL )
{
    if ( QueryError() )
        return ;

    APIERR err = NERR_Success ;

    if ( (err = _nlsDCofPrimaryDomain.QueryError()) != NERR_Success )
    {
        DBGEOL( "NT_USER_BROWSER_DIALOG::ctor(); NLS_STR ctor error " << err );
        ReportError( err );
        return;
    }

    if (  ( _pszServerResourceLivesOn != NULL )
       && ( _pszServerResourceLivesOn[0] == TCH('\\'))
       && ( _pszServerResourceLivesOn[1] == TCH('\\'))
       )
    {
        // Server is not null, and starts with two backslashes
        // ==> Check if it is the local machine name. If so, use NULL
        //     for the local machine name.
        LOCATION loc; // local computer
        NLS_STR nlsLocalMachineName;
        if (  (err = loc.QueryError())
           || (err = nlsLocalMachineName.QueryError())
           || (err = loc.QueryDisplayName( &nlsLocalMachineName ))
           )
        {
             ReportError( err );
             return;
        }

        if ( !::I_MNetComputerNameCompare( nlsLocalMachineName, pszServer ) )
            _pszServerResourceLivesOn = NULL;
    }

    //
    //	The listbox best be single select if we're going to be in single
    //	select mode
    //
    UIASSERT( !IsSingleSelection() ||
	      (IsSingleSelection() &&
		!( (_lbAccounts.QueryStyle() & LBS_EXTENDEDSEL) ||
		   (_lbAccounts.QueryStyle() & LBS_MULTIPLESEL)   )))

    AUTO_CURSOR cursHourGlass ;

    //
    //	Makes the combo auto drop etc.	Ignore the return code.
    //
    (void) _cbDomains.Command( CB_SETEXTENDEDUI, (WPARAM) TRUE ) ;

    //
    //	If users are never shown or only users are shown or
    //	users are always expanded, then don't show
    //	the "Show Users" button.
    //
    if ( !IsShowUsersButtonUsed() )
    {
        _buttonShowUsers.Show( FALSE ) ;
        _buttonShowUsers.Enable( FALSE ) ;
    }

    //
    //	If the client is asking for only global groups or local groups,
    //	disable access to the Members and Search button.
    //  Add show caption of add dialog.
    //
    BOOL fShowUsers   = !!( QueryFlags() & USRBROWS_SHOW_USERS	 );
    BOOL fShowGroups  = !!( QueryFlags() & USRBROWS_SHOW_GROUPS  );
    BOOL fShowAliases = !!( QueryFlags() & USRBROWS_SHOW_ALIASES );
    BOOL fShowWellKnownGroup = !!( QueryFlags() & USRBROWS_INCL_ALL );
    if (    ( fShowGroups  && !fShowUsers  )
         || ( fShowAliases && !fShowGroups )
       )
    {
	_buttonSearch.Enable( FALSE ) ;
	_buttonSearch.Show( FALSE ) ;
	_buttonMembers.Enable( FALSE ) ;
	_buttonMembers.Show( FALSE ) ;
    }

    MSGID idCaption = 0;
    if (_fIsSingleSelection)
    {
        if (fShowUsers)
        {
            if (fShowGroups | fShowAliases | fShowWellKnownGroup)
                idCaption = IDS_USRBROWS_ADD_USER_OR_GROUP;
            else
                idCaption = IDS_USRBROWS_ADD_USER;
        }
        else
            if (fShowGroups | fShowAliases | fShowWellKnownGroup)
                idCaption = IDS_USRBROWS_ADD_GROUP;
    }
    else
    {
        if (fShowUsers)
        {
            if (fShowGroups | fShowAliases | fShowWellKnownGroup)
                idCaption = IDS_USRBROWS_ADD_USERS_AND_GROUPS;
            else
                idCaption = IDS_USRBROWS_ADD_USERS;
        }
        else
            if (fShowGroups | fShowAliases | fShowWellKnownGroup)
                idCaption = IDS_USRBROWS_ADD_GROUPS;
    }

    if (idCaption)
    {
        RESOURCE_STR nlsCaption(idCaption);
        err = nlsCaption.QueryError();
        if (!err)
        {
            SetText (nlsCaption);
        }
    }

    //
    //	Resize the error slt to be the same size as the accounts listbox
    //
    XYDIMENSION xyLBSize = _lbAccounts.QuerySize() ;
    _sleBrowseErrorText.SetSize( xyLBSize, FALSE ) ;

    //
    //	Fill in the trusted domain list
    //
    if ( (err = GetTrustedDomainList( _pszServerResourceLivesOn,
				      &_pbrowdomainCurrentFocus,
				      &_cbDomains,
				      pAdminAuthPrimary )))
    {
	TRACEEOL("NT_USER_BROWSER_DIALOG::ct - Error " << err << " returned from GetTrustedDomainList") ;
    }
    SetDialogFocus( _cbDomains );

    //
    //	Finally, initialize everything for the default domain (this kicks
    //	off the thread for this domain).
    //

    if ( !err )
    {
	BROWSER_DOMAIN_LBI * plbi = (BROWSER_DOMAIN_LBI*) _cbDomains.QueryItem() ;
	UIASSERT( plbi != NULL ) ;

	BROWSER_DOMAIN * pBrDomNewFocus = plbi->QueryBrowserDomain() ;
	if ( !err &&
	     (err = OnDomainChange( pBrDomNewFocus, pAdminAuthPrimary )) )
	{
	    TRACEEOL("NT_USER_BROWSER_DIALOG::ct - Error " << err << " returned from QueryBrowserDomain") ;
	}
    }

    //
    //	The MLE needs to know which domain is the target domain so we can
    //	appropriately replace "BUILTIN" for well known accounts
    //
    if ( !err )
    {
	for ( int cItems = _cbDomains.QueryCount(), i = 0 ; i < cItems ; i++ )
	{
	    BROWSER_DOMAIN_LBI * plbi = (BROWSER_DOMAIN_LBI*) _cbDomains.QueryItem( i ) ;
	    UIASSERT( plbi != NULL )
	    if ( plbi->IsTargetDomain() )
	    {
		err = _mleAdd.SetTargetDomain( plbi->QueryBrowserDomain()->
						      QueryLsaLookupName() ) ;
		break ;
	    }
	}
    }

    if ( err )
	ReportError( err ) ;
}


NT_USER_BROWSER_DIALOG::~NT_USER_BROWSER_DIALOG()
{
    _pbrowdomainCurrentFocus = NULL ;

    //
    //	This will force the threads to quit accessing any members of *this
    //	before the members of this dialog are destructed (each browser
    //	domain in the CB may have a thread spinning in the background)
    //
    _cbDomains.DeleteAllItems() ;
}

/*******************************************************************

    NAME:	NT_USER_BROWSER_DIALOG::EnableBrowsing

    SYNOPSIS:	Enables accounts listbox and associated buttons appropriately

    ENTRY:	fEnable - TRUE to enable browsing, FALSE otherwise

    NOTES:	This doesn't affect the domain combo in any way.

    HISTORY:
	Johnl	04-Dec-1992	Created

********************************************************************/

void NT_USER_BROWSER_DIALOG::EnableBrowsing( BOOL fEnable )
{
    //
    //	Enable/show controls as appropriate
    //
    _sleBrowseErrorText.Show( !fEnable ) ;
    _lbAccounts.Enable( fEnable ) ;

    _buttonShowUsers.Enable( fEnable && IsShowUsersButtonUsed() ) ;

    if ( fEnable )
    {
        HWND hwndLastFocus = ::GetFocus();
        if (hwndLastFocus == NULL)
        {
            TRACEEOL( "NT_USER_BROWSER_DIALOG::EnableBrowsing: remembering last focus" );
            hwndLastFocus = _hwndLastFocus;
        }

	//
	//  If the user is sitting on the domain combo and they are not
	//  selecting a new domain, then switch the focus to the listbox.
	//  This is for the user who wants to browse the list of accounts
	//
	if (   (_cbDomains.QueryHwnd() == hwndLastFocus)
            && !_cbDomains.IsDropped() )
	{
            SetDialogFocus( _lbAccounts );
	}

	_lbAccounts.Invalidate( TRUE ) ;
	if ( _lbAccounts.QueryCount() > 0 )
	{
            _lbAccounts.RemoveSelection();
	    _lbAccounts.SetCaretIndex( 0 ) ;
	}
    }

    _lbAccounts.Show( fEnable ) ;

    //
    //	This will enable _buttonMembers, _buttonAdd as appropriate
    //
    UpdateButtonState() ;
}


/*******************************************************************

    NAME:	NT_USER_BROWSER_DIALOG::SetAndFillErrorText

    SYNOPSIS:	Covers up the listbox with an SLT (that looks like the listbox)
		and displays the error code indicating why they can't browse
		the current domain.

    ENTRY:	errDisplay - Error code to display as part of the message
		fIsErr - If FALSE, then the text isn't prefixed with
		    the standard error prolog text

    RETUR:	NERR_Success of successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	04-Dec-1992	Created

********************************************************************/

APIERR NT_USER_BROWSER_DIALOG::SetAndFillErrorText( MSGID errDisplay,
						    BOOL  fIsErr )
{
    APIERR err ;

    RESOURCE_STR nlsMessage( (MSGID) ( fIsErr ? IDS_CANT_BROWSE_DOMAIN :
						errDisplay ) ) ;

    if ( fIsErr )
    {
	RESOURCE_STR nlsError( (MSGID) errDisplay ) ;
	if ( err = nlsError.QueryError() )
	{
	    /* If we couldn't find the error message then just put the
	     * error message number up for display
	     */
	    DEC_STR decStr( (ULONG) errDisplay ) ;
	    if ( (err = decStr.QueryError()) ||
		 (err = nlsError.CopyFrom( decStr )) )
	    {
		return err ;
	    }
	}

	if ( (err = nlsMessage.InsertParams( nlsError )) )
	{
	    return err ;
	}
    }

    _sleBrowseErrorText.SetText( nlsMessage ) ;
    _sleBrowseErrorText.Show( TRUE ) ;
    _lbAccounts.Show( FALSE ) ;
    _lbAccounts.Enable( FALSE ) ;

    return err ;
}


/*******************************************************************

    NAME:       NT_USER_BROWSER_DIALOG::OnCommand

    SYNOPSIS:   Typical OnCommand for this dialog, we catch pressing
                the ShowUsers button and changing the selection in the
                domain drop down list.

    EXIT:

    RETURNS:

    NOTES:	The Add button is enabled any time there is a selection in
		the Accounts listbox.  It is made the default when the Add
		listbox is empty

    HISTORY:
        Johnl   02-Mar-1992     Created
********************************************************************/

BOOL NT_USER_BROWSER_DIALOG::OnCommand( const CONTROL_EVENT & event )
{
    APIERR err = NERR_Success ;

    switch ( event.QueryCode() )
    {
    case LBN_SETFOCUS:
    case CBN_SETFOCUS:
    case EN_SETFOCUS:
        TRACEEOL( "NT_USER_BROWSER_DIALOG::OnCommand(): ?N_SETFOCUS" );
        UpdateButtonState() ;
        break;
    default:
        break;
    }

    switch ( event.QueryCid() )
    {
    case BUTTON_SHOW_USERS:
	err = OnShowUsers() ;
	UpdateButtonState() ;
        break ;

    case CB_TRUSTED_DOMAINS:
        {
            switch ( event.QueryCode() )
            {
            //
            //  Note that the Show Users button is disabled anytime the
            //  domain combo is dropped.  This prevents somebody using the
            //  show users mnemonic on a domain that hasn't been initialized
            //  yet.
            //
            case CBN_DROPDOWN:
                SetDomainComboDropFlag( TRUE ) ;
                if ( IsShowUsersButtonUsed() )
                    _buttonShowUsers.Enable( FALSE ) ;
                _buttonMembers.Enable( FALSE ) ;
                break ;

            case CBN_CLOSEUP:
                SetDomainComboDropFlag( FALSE ) ;

                //
                //  Only re-enable the Show Users button if users aren't shown
                //  and the button is actually used and the list box is active
                //
                if ( IsShowUsersButtonUsed() &&
                     !AreUsersShown()        &&
                     IsBrowsingEnabled()       )
                {
                    _buttonShowUsers.Enable( TRUE ) ;
                }

                //
                // reenable the membrs if it os OK to do so
                //
                _buttonMembers.Enable(_lbAccounts.IsSelectionExpandableGroup()
                                      && _fEnableMembersButton ) ;

                //
                //  Fall through
                //

            case CBN_KILLFOCUS:
            case CBN_SELCHANGE:
                {
                    if ( IsDomainComboDropped() )
                        break ;

		    BROWSER_DOMAIN_LBI * plbi =
                                (BROWSER_DOMAIN_LBI*) _cbDomains.QueryItem() ;
                    ASSERT( plbi != NULL );
                    if (plbi != NULL)
                    {
		        BROWSER_DOMAIN * pBrDomNewFocus =
                                    plbi->QueryBrowserDomain() ;

                        if ( pBrDomNewFocus != QueryCurrentDomainFocus() )
                        {
		    	    err = OnDomainChange( pBrDomNewFocus ) ;
		    	    UpdateButtonState() ;
                        }
                    }
                }
                break ;
            }
	}
	break ;

    case USR_BUTTON_ADD:
	err = OnAdd() ;
	UpdateButtonState() ;
	break ;

    case USR_BUTTON_MEMBERS:
	err = OnMembers() ;
	UpdateButtonState() ;
	break ;

    case USR_BUTTON_SEARCH:
	err = OnSearch() ;
	UpdateButtonState() ;
	break ;

    case LB_ACCOUNTS:
	switch ( event.QueryCode() )
	{
	case LBN_DBLCLK:
	    err = OnAdd() ;
            // fall through

        case LBN_SELCHANGE:
	    UpdateButtonState() ;
	    break ;

        default:
            break ;
	}
	break ;

    default:
	return DIALOG_WINDOW::OnCommand( event ) ;
    }

    if ( err )
    {
        if( event.QueryCid() == CB_TRUSTED_DOMAINS )
        {
            //
            //  Something fatal occurred when filling the listbox
            //  with the newly selected domain.  Since the combo
            //  box reflects the new selection, we'll nuke the
            //  contents of the listbox.
            //

	    EnableBrowsing( FALSE ) ;
	    //_lbAccounts.RemoveAllItems(); // Needed??
	    UpdateButtonState() ;
	    if ( !SetAndFillErrorText( (MSGID) err ) )
	    {
		//
		//  If we successfully notified the user through the
		//  error SLE, then don't popup an error, otherwise, popup
		//  the error.
		//
		err = NERR_Success ;
	    }
	}

	if ( err )
	   MsgPopup( this, (MSGID) err ) ;

    }

    return TRUE ;
}

/*******************************************************************

    NAME:	NT_USER_BROWSER_DIALOG::OnUserMessage

    SYNOPSIS:	Standard on user processing.  Catches the WM_ACCOUNT_DATA
		response and fills the accounts listbox

    NOTES:

    HISTORY:
	Johnl	07-Dec-1992	Created

********************************************************************/

BOOL NT_USER_BROWSER_DIALOG::OnUserMessage( const EVENT & event )
{
    APIERR err = NERR_Success ;

    switch ( event.QueryMessage() )
    {
    case WM_LB_FILLED:
	{
	    BOOL fEnableBrowsing = (BOOL) event.QueryWParam() ;

	    if ( fEnableBrowsing )
	    {
    	        USER_BROWSER_LBI_CACHE * pcache = (USER_BROWSER_LBI_CACHE*)
		  				  event.QueryLParam() ;
                _lbAccounts.SetCurrentCache( pcache ) ;

                //
                // Enable the members button (subject to other checks)
                // see UpdateButtonState()
                //
                _fEnableMembersButton = TRUE ;

                //
                // Enable browsing after the cache has been set
                //
                EnableBrowsing( TRUE ) ;
	    }
            else
            {
                EnableBrowsing( FALSE ) ;
                SetAndFillErrorText( (APIERR) event.QueryLParam() );
            }
	}
	break ;

    default:
	return DIALOG_WINDOW::OnUserMessage( event ) ;
    }

    return TRUE ;
}

/*******************************************************************

    NAME:       NT_USER_BROWSER_DIALOG::GetTrustedDomainList

    SYNOPSIS:   This method enumerates the trusted domains of the passed
		server adding each domain to the domain combo box.

    ENTRY:      pszServer - Where the resource lives (in form "\\server")
                ppBrowserDomainDefaultFocus - A pointer to the domain
                    that has the default focus (which will be where the
                    resource lives)
                pcbDomains - Pointer to combo box to fill with the trusted
                    domains.

    EXIT:       The domain combo will be filled, the list of trusted
                domains will be filled and *ppBrowserDomainDefaultFocus
                will be set to the domain that has the default focus.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:      The domain/server that the resource lives on will have an "*"
                appended to its name (indicates Alias enumeration).

                The list of trusted domains will be generated by enumerating
                the trusted domains on the PDC of the domain that
                pszServer is contained in.

    HISTORY:
        Johnl   03-Mar-1992     Created
        Thomaspa 10-10-1993     added pAdminAuthPrimary

********************************************************************/

APIERR NT_USER_BROWSER_DIALOG::GetTrustedDomainList(
			     const TCHAR *	 pszServer,
			     BROWSER_DOMAIN  * * ppBrowserDomainDefaultFocus,
			     BROWSER_DOMAIN_CB * pcbDomains,
			     const ADMIN_AUTHORITY * pAdminAuthPrimary )
{
    TRACEEOL("NT_USER_BROWSER_DIALOG::GetTrustedDomainList Entered @ " << ::GetTickCount()/100) ;

    APIERR err = NERR_Success ;

    /* errEnumDomains is used to indicate the success of enumerating
     * domains.
     */
    APIERR errEnumDomains = NERR_Success ;
    BOOL fShowComputer ;
    LSA_POLICY * pLSAPolicy = NULL;
    API_SESSION * pAPISession = NULL;

    do { // Error breakout thing

        LOCATION locServerResourceIsOn( pszServer, FALSE ) ;

        if ( (err = locServerResourceIsOn.QueryError()))
        {
            break ;
        }

        LOCATION_NT_TYPE locnttype ;
        BOOL fIsNT ;

        /* The target domain will be pszServer if this is a winnt machine,
         * else the target domain will be the primary domain of pszServer.
         */
#if defined(DEBUG) && defined(TRACE)
        DWORD start = ::GetTickCount();
#endif
        if ( (err = locServerResourceIsOn.CheckIfNT( &fIsNT,
                                                     &locnttype )) ||
             !fIsNT )
        {
            UIASSERT(err || fIsNT) ; // Sure as heck better be on NT
            DBGEOL("GetTrustedDomainList - Error " << (ULONG) err <<
                   " returned from CheckIfNT") ;
            break ;
        }
#if defined(DEBUG) && defined(TRACE)
        TRACEEOL("GetTrustedDomainList: CheckIfNt took (ms) " << (::GetTickCount() - start) );
#endif

        /* Add the computer the resource resides on to the list of trusted
         * domains unless the client requested that it not be shown.
         */
        fShowComputer = !(QueryFlags() & USRBROWS_DONT_SHOW_COMPUTER) &&
                              (locnttype == LOC_NT_TYPE_WINDOWSNT
                                || locnttype == LOC_NT_TYPE_SERVERNT) ;

        /* Open an LSA Policy on the local machine so we can get its account
         * domain SID and primary domain sid
         */
        LSA_POLICY LSAPolicyLocalMachine( pszServer ) ;
        LSA_ACCT_DOM_INFO_MEM LSAAcctDomInfo ;
        LSA_PRIMARY_DOM_INFO_MEM LSAPrimDomInfo ;

        if ( (err = LSAPolicyLocalMachine.QueryError()) ||
             (err = LSAAcctDomInfo.QueryError())        ||
             (err = LSAPrimDomInfo.QueryError())          )
        {
            break ;
        }

        BROWSER_DOMAIN * pbrowdomain ;
        if ( fShowComputer )
        {
#if defined(DEBUG) && defined(TRACE)
            start = ::GetTickCount();
#endif
            if (err = LSAPolicyLocalMachine.GetAccountDomain(&LSAAcctDomInfo))
            {
                DBGEOL("GetTrustedDomainList - Error " << (ULONG) err <<
                       " returned from GetAccountDomain") ;
                break ;
            }
#if defined(DEBUG) && defined(TRACE)
            TRACEEOL("GetTrustedDomainList: GetAccountDomain took (ms) " << (::GetTickCount() - start) );
#endif

            /* Since this is a WinNT machine, this browser domain will be
             * the "target" domain (but not the default domain).
             */
            pbrowdomain = new BROWSER_DOMAIN(pszServer,
                                             LSAAcctDomInfo.QueryPSID(),
                                             TRUE,
                                             TRUE ) ;

	    if ( err = _cbDomains.AddItem( pbrowdomain ) )
            {
                break ;
	    }

            /* Make the default selection the computer name in case
             * we can't enumerate the trusted domains down below.
             */
            *ppBrowserDomainDefaultFocus = pbrowdomain ;
        }

#if defined(DEBUG) && defined(TRACE)
        start = ::GetTickCount();
#endif
        if (errEnumDomains = LSAPolicyLocalMachine.GetPrimaryDomain(
                                                             &LSAPrimDomInfo ))
        {
            DBGEOL("GetTrustedDomainList - GetPrimaryDomain returned error " <<
		     (ULONG) errEnumDomains ) ;
            break ;
        }
#if defined(DEBUG) && defined(TRACE)
        TRACEEOL("GetTrustedDomainList: GetPrimaryDomain took (ms) " << (::GetTickCount() - start) );
#endif

        /* If the machine is a workgroup machine then it won't have a domain
         * or set of trusted domains to enumerate, so get out.
         */
        if ( LSAPrimDomInfo.QueryPSID() == NULL )
        {
            DBGEOL("GetTrustedDomainList - Target machine does not have an" <<
                   " LSA primary domain (i.e., is a workgroup machine)") ;
            //
            //  If the client requested we don't show the computer but we
            //  are focused on a workgroup machine (which only has the computer
            //  to show), then tell them they messed up
            //
            if ( !fShowComputer )
                err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        NLS_STR nlsPrimDomain( DNLEN ) ;
        if ( (errEnumDomains = nlsPrimDomain.QueryError()) ||
             (errEnumDomains = LSAPrimDomInfo.QueryName( &nlsPrimDomain )) )
        {
            DBGEOL(   "NT_USER_BROWSER_DIALOG::GetTrustedDomainList(): "
                   << "error loading DC of primary domain " << errEnumDomains );
            break ;
        }

#ifdef TRACE
	TRACEEOL("GetTrustedDomainList - Primary Domain Name is " << nlsPrimDomain ) ;
	TRACEEOL("GetTrustedDomainList - Primary domain SID:") ;
	OS_SID ossidPrimDomain( LSAPrimDomInfo.QueryPSID() ) ;
	ossidPrimDomain.DbgPrint() ;
#endif

        /* Add the domain this server is on.
         * This is only a target domain (3rd param) if the computer is not
         * shown.
         */
        pbrowdomain = new BROWSER_DOMAIN( nlsPrimDomain,
                                          LSAPrimDomInfo.QueryPSID(),
                                          !fShowComputer ) ;

        errEnumDomains = ERROR_NOT_ENOUGH_MEMORY ;
        if ( (pbrowdomain == NULL)             ||
             (err = pbrowdomain->QueryError()))
        {
            DBGEOL("GetTrustedDomains - can't construct PDC BROWSER_DOMAIN") ;
            delete pbrowdomain ;
            break ;
        }

        *ppBrowserDomainDefaultFocus = pbrowdomain ;
        if ( err = _cbDomains.AddItem( pbrowdomain) )
        {
            break ;
        }

        /* Now add each of the trusted domains listed from the PDC to
         * the trusted domain list.
         *
         * We establish an API session (null session w/ IPC$) so
         * we don't have account conflicts (i.e., Admin w/ diff passwords)
         */


        LSA_ENUMERATION_HANDLE LSAEnumHandle = 0 ;
        LSA_TRUST_INFO_MEM     LSATrustInfo ;



        if ( pAdminAuthPrimary == NULL )
        {
            DOMAIN_WITH_DC_CACHE PrimDom( nlsPrimDomain, TRUE ) ;
            if ( (errEnumDomains = PrimDom.GetInfo())
                || (errEnumDomains = _nlsDCofPrimaryDomain.CopyFrom(
                                        PrimDom.QueryAnyDC() )) )
            {
                //
                //  Give a more specific error message.  The workstation or
                //  browser not started should be the only reason why we
                //  get this error.
                //
                if ( errEnumDomains == NERR_ServiceNotInstalled )
                    errEnumDomains = IDS_WKSTA_OR_BROWSER_NOT_STARTED;
                break ;
            }
    	    TRACEEOL("GetTrustedDomainList - Using DC " << PrimDom.QueryAnyDC() ) ;
            pAPISession = new API_SESSION( PrimDom.QueryAnyDC(), TRUE ) ;
            pLSAPolicy = new LSA_POLICY( PrimDom.QueryAnyDC() ) ;
            errEnumDomains = ERROR_NOT_ENOUGH_MEMORY;
            if ( (pAPISession == NULL) ||
                 (pLSAPolicy == NULL) ||
                 (errEnumDomains = pAPISession->QueryError()) ||
                 (errEnumDomains = pLSAPolicy->QueryError()) )
             {
                 break;
             }
             errEnumDomains = NERR_Success;
        }
        else
        {
            pLSAPolicy = pAdminAuthPrimary->QueryLSAPolicy();

            if( errEnumDomains = _nlsDCofPrimaryDomain.CopyFrom(
                                        pAdminAuthPrimary->QueryServer()) )
            {
                break;
            }

        }


        NLS_STR                nlsDomName( DNLEN ) ;
        if ( (errEnumDomains = LSATrustInfo.QueryError())||
             (errEnumDomains = nlsDomName.QueryError())    )
        {
            DBGEOL( "GetTrustedDomains - Error " << (ULONG) errEnumDomains <<
                     " constructing LSA/API Session class" ) ;
            break ;
        }

        do {
            errEnumDomains = pLSAPolicy->EnumerateTrustedDomains( &LSATrustInfo,
                                                                &LSAEnumHandle,
                                                                1024L ) ;
	    TRACEEOL("GetTrustedDomainList - Returned " << errEnumDomains ) ;

            if ( errEnumDomains != NERR_Success &&
                 errEnumDomains != ERROR_MORE_DATA )
            {
                if ( errEnumDomains == ERROR_NO_MORE_ITEMS )
                {
                    errEnumDomains = NERR_Success ;
                }

                break ;
            }

            for ( ULONG i = 0 ; i < LSATrustInfo.QueryCount() ; i++ )
            {
                if ( (err = LSATrustInfo.QueryName( i, &nlsDomName )))
                {
                    break ;
                }

		TRACEEOL( "GetTrustedDomainList - Adding trusted domain " << nlsDomName ) ;
#if defined(DEBUG) && defined(TRACE)
                start = ::GetTickCount();
#endif
                pbrowdomain = new BROWSER_DOMAIN( nlsDomName,
                                                  LSATrustInfo.QueryPSID( i ),
                                                  FALSE ) ;
		if ( _cbDomains.AddItem( pbrowdomain ) )
                {
                    break ;
                }
#if defined(DEBUG) && defined(TRACE)
                TRACEEOL("GetTrustedDomainList: BROWSER_DOMAIN took (ms) " << (::GetTickCount() - start) );
#endif
            }
        } while ( errEnumDomains == ERROR_MORE_DATA ) ;

    } while (FALSE) ; // Error breakout loop

    if ( pAdminAuthPrimary == NULL )
    {
        delete pAPISession;
        delete pLSAPolicy;
    }

    //
    //  If err is set then a fatal error occurred
    //
    if ( err )
    {
        return err ;
    }

    //
    //	Select the default domain in the combo box
    //
    pcbDomains->SelectItem( *ppBrowserDomainDefaultFocus ) ;

    //
    //	If errEnumDomains is set, then an error occurred that the user needs
    //	to know about but we can still display this dialog.
    //
    if ( errEnumDomains )
    {
        TRACEEOL( "GetTrustedDomainList - Reporting non-fatal errror " << (ULONG) errEnumDomains) ;
        APIERR errTmp ;
        RESOURCE_STR nlsError( (MSGID) errEnumDomains ) ;
        if ( errTmp = nlsError.QueryError() )
        {
            /* If we couldn't find the error message then just put the
             * error message number up for display
             */
            DEC_STR decStr( (ULONG) errEnumDomains ) ;
            if ( (errTmp = decStr.QueryError()) ||
                 (errTmp = nlsError.CopyFrom( decStr )) )
            {
                return errTmp ;
            }
        }

        MsgPopup( this,
                  IDS_CANT_BROWSE_DOMAINS,
                  MPSEV_WARNING,
                  MP_OK,
                  nlsError ) ;
    }

    TRACEEOL("NT_USER_BROWSER_DIALOG::GetTrustedDomainList Leave   @ " << ::GetTickCount()/100) ;
    return err ;
}


/*******************************************************************

    NAME:       NT_USER_BROWSER_DIALOG::OnDomainChange

    SYNOPSIS:   This method is called when the user selects a new domain
                from the domain name combo.

    ENTRY:      pDomainNewSelection - Pointer to new BROWSER_DOMAIN that was
                    just selected.

    EXIT:       The listbox will be updated to reflect the new items in
                the selected domain.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:	This method maybe called when QueryCurrentDomainFocus returns
		NULL (when first initializing).

    HISTORY:
        Johnl   02-Mar-1992     Created

********************************************************************/

APIERR NT_USER_BROWSER_DIALOG::OnDomainChange( BROWSER_DOMAIN * pDomainNewSelection,
					const ADMIN_AUTHORITY * pAdminAuth )
{
    TRACEEOL("NT_USER_BROWSER_DIALOG::OnDomainChange Enter @ " << ::GetTickCount()/100) ;
    UIASSERT( pDomainNewSelection != NULL ) ;
    APIERR err = NERR_Success ;
    AUTO_CURSOR cursHourGlass ;

    //
    //	In case the user is just flipping through domains, don't update the
    //	listbox for this domain if we are on a new domain
    //
    BROWSER_DOMAIN * pDomainOldSelection = QueryCurrentDomainFocus() ;
    if ( pDomainOldSelection != NULL && pDomainOldSelection->IsInitialized() )
    {
	pDomainOldSelection->UnRequestAccountData() ;
	_mleAdd.CanonicalizeNames( QueryCurrentDomainFocus()->QueryLsaLookupName() ) ;
    }

    //
    //  Hide the listbox while we mess around with it
    //
    (void) SetAndFillErrorText( IDS_GETTING_DOMAIN_INFO, FALSE ) ;

    //
    // Turn off browsing until the listbox gets filled with data
    //
    _lbAccounts.SetCount( 0 ) ;
    EnableBrowsing( FALSE ) ;
    _fUsersAreShown = FALSE ;

    SetCurrentDomainFocus( pDomainNewSelection ) ;

    //
    // disable the members button while all this goes on
    //
    _buttonMembers.Enable( FALSE ) ;
    _fEnableMembersButton = FALSE ;

    //
    //	If this browser domain isn't initialized, then initialize it
    //

    if ( !pDomainNewSelection->IsInitialized() )
    {
	if ( err = pDomainNewSelection->GetDomainInfo( this, pAdminAuth ) )
        {
            return err ;
        }
    }

    //
    //	Let the thread know we are awaiting the data
    //
    err = pDomainNewSelection->RequestAccountData() ;

    TRACEEOL("NT_USER_BROWSER_DIALOG::OnDomainChange Leave    @ " << ::GetTickCount()/100) ;
    return err ;
}

/*******************************************************************

    NAME:       NT_USER_BROWSER_DIALOG::OnShowUsers

    SYNOPSIS:   This method is called when the user presses the "Show Users"
                button.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:	Note that the users are added in this thread and are not
		added to the thread's list of LBIs

    HISTORY:
        Johnl   02-Mar-1992     Created

********************************************************************/

APIERR NT_USER_BROWSER_DIALOG::OnShowUsers( void )
{
    /* We claim focus in the listbox so that when we disable the
     * button we don't lose the default focus.
     */
    AUTO_CURSOR CursorHourGlass ;
    SetDialogFocus( _lbAccounts );
    _buttonShowUsers.Enable( FALSE ) ;

    APIERR err = NERR_Success ;

    if ( err = QueryCurrentDomainFocus()->RequestAndWaitForUsers() )
    {
	DBGEOL("NT_USER_BROWSER_DIALOG::OnShowUsers - Error " << err ) ;
    }

    _lbAccounts.SetCount( _lbAccounts.QueryCurrentCache()->QueryCount() ) ;
    _fUsersAreShown = (err == NERR_Success) ;
    return err ;
}

/*******************************************************************

    NAME:       NT_USER_BROWSER_DIALOG::OnSearch

    SYNOPSIS:   This method is called when the user presses the "Search"
                button.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:

    HISTORY:
        JonN    01-Dec-1992     Created
        JohnL   17-Mar-1993     Conditional add to cache logic

********************************************************************/

APIERR NT_USER_BROWSER_DIALOG::OnSearch( void )
{
    TRACEEOL("OnSearch called") ;

    NT_FIND_ACCOUNT_DIALOG * pntfinddlg = new NT_FIND_ACCOUNT_DIALOG(
                                                QueryHwnd(),
                                                this,
                                                &_cbDomains,
                                                QueryServerResourceLivesOn(),
                                                QueryFlags() );

    BOOL fChoseAdd = FALSE;

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if (   pntfinddlg != NULL
        && (err = pntfinddlg->QueryError()) == NERR_Success
        && (err = pntfinddlg->Process( &fChoseAdd )) == NERR_Success
        && fChoseAdd
       )
    {
        USER_BROWSER_LB * plbFound = pntfinddlg->QuerySourceListbox();
        UIASSERT( plbFound != NULL && plbFound->QueryError() == NERR_Success )
        if (plbFound->QuerySelCount() > 0)
        {
            TRACEEOL("OnSearch() copying from Find Accounts");

            //
            //  We only add to the cache if everything is being shown.  This
            //  prevents users from adding accounts through the search dialog
            //  that the application didn't ask for.
            //
	    err = AddSelectedUserBrowserLBIs(
                   plbFound,
                   FALSE,     // no need to copy
                   (QueryFlags() & (USRBROWS_INCL_ALL | USRBROWS_SHOW_ALL)) ==
                                       (USRBROWS_INCL_ALL | USRBROWS_SHOW_ALL) ) ;

        }
    }

    delete pntfinddlg;

    return err;
}


/*******************************************************************

    NAME:       NT_USER_BROWSER_DIALOG::OnMembers

    SYNOPSIS:   This method is called when the user presses the "Members"
                button.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:

    HISTORY:
        JonN    05-Nov-1992     Created

********************************************************************/


APIERR NT_USER_BROWSER_DIALOG::OnMembers( void )
{
    TRACEEOL("OnMembers called") ;

    USER_BROWSER_LB * plbSelGroup = NULL;
    APIERR err = NERR_Success;

    if ( _lbAccounts.QuerySelCount() == 1 )
    {
        plbSelGroup = &_lbAccounts;
    }
    else
    {
        DBGEOL("OnMembers called with improper selection") ;
        UIASSERT( FALSE );
        return ERROR_GEN_FAILURE;
    }

    do // false loop
    {
        if ( plbSelGroup == NULL )
            break;

        USER_BROWSER_LBI * plbi = (USER_BROWSER_LBI *) plbSelGroup->QueryItem();
        if (plbi == NULL)
        {
            UIASSERT( FALSE );
            break;
        }

        BROWSER_DOMAIN * pbdom = QueryCurrentDomainFocus();
        ASSERT( pbdom != NULL && pbdom->QueryError() == NERR_Success );

        SAM_DOMAIN * psamdomAccount = pbdom->QueryAccountDomain();
        SAM_DOMAIN * psamdomBuiltin = pbdom->QueryBuiltinDomain();
        ASSERT( psamdomAccount != NULL && psamdomAccount->QueryError() == NERR_Success );
        ASSERT( psamdomBuiltin != NULL && psamdomBuiltin->QueryError() == NERR_Success );

        NT_GROUP_BROWSER_DIALOG * pntgrpbrowdlg = NULL;
        OS_SID ossidGroup( plbi->QueryPSID(), (BOOL)FALSE);
	NLS_STR nlsQualifiedDomainName;
        if (   (err = ossidGroup.QueryError()) != NERR_Success
            || (err = nlsQualifiedDomainName.QueryError()) != NERR_Success
	    || (err = pbdom->GetQualifiedDomainName( &nlsQualifiedDomainName ))
           )
        {
            break;
        }

        switch ( plbi->QueryType() )
        {
        case SidTypeGroup:
            pntgrpbrowdlg = new NT_GLOBALGROUP_BROWSER_DIALOG(
                                    QueryHwnd(),
                                    this,
                                    nlsQualifiedDomainName.QueryPch(),
                                    plbi->QueryAccountName(),
                                    &ossidGroup,
                                    pbdom->QueryAccountDomain(),
                                    pbdom->QueryLSAPolicy(),
                                    QueryServerResourceLivesOn() );
            break;

        case SidTypeAlias:
            {
            // we must determine if the alias is in the builtin domain
            OS_SID ossidDomainOfGroup( ossidGroup.QueryPSID(), (BOOL)TRUE );
            if (   (err = ossidDomainOfGroup.QueryError()) != NERR_Success
                || (err = ossidDomainOfGroup.TrimLastSubAuthority()) != NERR_Success
               )
            {
                break;
            }

            BOOL fIsBuiltin = ( ossidDomainOfGroup == *(psamdomBuiltin->QueryOSSID()) );

            pntgrpbrowdlg = new NT_LOCALGROUP_BROWSER_DIALOG(
                                    QueryHwnd(),
                                    this,
                                    nlsQualifiedDomainName.QueryPch(),
                                    plbi->QueryAccountName(),
                                    &ossidGroup,
                                    (fIsBuiltin) ? psamdomBuiltin
                                                 : psamdomAccount,
                                    psamdomAccount,
                                    pbdom->QueryLSAPolicy(),
                                    QueryServerResourceLivesOn() );
            }

            break;

        default:
            UIASSERT( FALSE );
            break;
        }

        if ( err == NERR_Success )
        {

            BOOL fChoseAdd = FALSE;

            err = ERROR_NOT_ENOUGH_MEMORY;
            if (   pntgrpbrowdlg != NULL
                && (err = pntgrpbrowdlg->QueryError()) == NERR_Success
                && (err = pntgrpbrowdlg->Process( &fChoseAdd )) == NERR_Success
                && fChoseAdd
               )
            {
                // If the user pressed ADD in the group browser, but didn't
                // select any items there, add the group itself
                USER_BROWSER_LB * plbGroupBrowser = pntgrpbrowdlg->QuerySourceListbox();
                if (plbGroupBrowser->QuerySelCount() > 0)
                {
		    err = AddSelectedUserBrowserLBIs(
                                    plbGroupBrowser,
                                    FALSE ) ; // no need to copy, we're about
                                              // to delete the dialog + LB
                }
                else
                {
		    err = AddSelectedUserBrowserLBIs(
				    plbSelGroup,
				    TRUE ) ; // do copy here

                }
            }
        }

        delete pntgrpbrowdlg;

    } while (FALSE); // false loop

    return err ;
}

/*******************************************************************

    NAME:	NT_USER_BROWSER_DIALOG::UpdateButtonState

    SYNOPSIS:	This updates the the set of buttons based on the current
		selection and items in each of the listboxes

    NOTES:

    HISTORY:
	Johnl	28-Oct-1992	Created

********************************************************************/

void NT_USER_BROWSER_DIALOG::UpdateButtonState( void )
{
    _buttonMembers.Enable( _lbAccounts.IsSelectionExpandableGroup() &&
                           _fEnableMembersButton ) ;

    if ( _lbAccounts.HasFocus() && _lbAccounts.QuerySelCount() > 0 )
    {
	UIASSERT( _lbAccounts.IsEnabled() ) ;
	_buttonAdd.Enable( TRUE ) ;
	_buttonAdd.MakeDefault() ;
    }
    else
    {
	if ( _lbAccounts.QuerySelCount() > 0 )
	    _buttonAdd.Enable( TRUE ) ;
	else
	{
	    //
	    // If we are about to disable the Add button and it has the focus,
	    // then set the focus to the accounts listbox (which must be
	    // enabled otherwise we wouldn't be able to press the Add button).
	    //
	    if ( _buttonAdd.HasFocus() )
	    {
		UIASSERT( _lbAccounts.IsEnabled() ) ;
                SetDialogFocus( _lbAccounts );
	    }

	    _buttonAdd.Enable( FALSE ) ;
	}

	_buttonOK.MakeDefault() ;
    }
}

/*******************************************************************

    NAME:	NT_USER_BROWSER_DIALOG::OnAdd

    SYNOPSIS:	Removes selected items from the accounts listbox and
		adds them to the "Add" listbox

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	27-Oct-1992	Created

********************************************************************/

APIERR NT_USER_BROWSER_DIALOG::OnAdd( void )
{
    AUTO_CURSOR niftycursor ;
    return AddSelectedUserBrowserLBIs( &_lbAccounts, TRUE ) ;
}

/*******************************************************************

    NAME:	NT_USER_BROWSER_DIALOG::OnDlgDeactivation

    SYNOPSIS:	We hook the WM_ACTIVATE message

    HISTORY:
        JonN    06-Oct-1993     Created

********************************************************************/

BOOL NT_USER_BROWSER_DIALOG::OnDlgDeactivation( const ACTIVATION_EVENT & ae )
{
    TRACEEOL( "NT_USER_BROWSER_DIALOG:: OnDlgDeactivation" );
    _hwndLastFocus = ::GetFocus() ;

    return DIALOG_WINDOW::OnDlgDeactivation( ae );
}

/*******************************************************************

    NAME:	NT_USER_BROWSER_DIALOG::AddSelectedUserBrowserLBIs

    SYNOPSIS:	Takes the currently selected items in plbUserBrowser and
		relocates them to *this

    ENTRY:	plbUserBrowser - Listbox to take selected items from
		fCopy	       - TRUE to not delete from plbUserBrowser,
                                 FALSE to delete the LBIs from plbUserBrowser
                fAddToCache    - TRUE to add to cache (won't be checked for
                                    correctness OnOK)
                                 FALSE to force re-evaluation OnOK.

    EXIT:	plbUserBrowser will have the selected items removed

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	27-Oct-1992	Created

********************************************************************/

APIERR NT_USER_BROWSER_DIALOG::AddSelectedUserBrowserLBIs(
					     USER_BROWSER_LB * plbUserBrowser,
                                             BOOL fCopy,
                                             BOOL fAddToCache  )
{
    UIASSERT( plbUserBrowser != NULL ) ;
    APIERR err ;

    INT cSel = plbUserBrowser->QuerySelCount() ;
    NLS_STR nlsNames( cSel * 100 ) ;
    if ( (err = nlsNames.QueryError()) ||
	 ( !_mleAdd.IsSingleSelect() && (err = _mleAdd.QueryText( &nlsNames ))) )
    {
	return err ;
    }

    BUFFER buffSelection(  cSel * sizeof( INT )) ;

    do {  // error breakout

	if ( err = buffSelection.QueryError() )
	    break ;

	INT * pSel = (INT *) buffSelection.QueryPtr() ;
	if ( err = plbUserBrowser->QuerySelItems( pSel, cSel ) )
	{
	    break ;
	}

	for ( INT i = cSel-1 ; i >= 0 ; i-- )
	{
	    USER_BROWSER_LBI * plbi ;

	    if ( fCopy )
	    {
		plbi = (USER_BROWSER_LBI*) plbUserBrowser->QueryItem( pSel[i] ) ;
		UIASSERT( plbi != NULL ) ;

		//
		// Refuse to deal with any error LBIs
		//
		if ( plbi == plbUserBrowser->QueryErrorLBI() )
		    return NERR_Success ;

		USER_BROWSER_LBI * plbiNew = new USER_BROWSER_LBI(
					    plbi->QueryAccountName(),
					    plbi->QueryFullName(),
					    plbi->QueryDisplayName(),
					    plbi->QueryComment(),
					    plbi->QueryDomainName(),
					    plbi->QueryPSID(),
					    plbi->QueryUISysSid(),
					    plbi->QueryType(),
					    plbi->QueryUserAccountFlags() ) ;
		plbi = plbiNew ;
	    }
	    else
	    {
		plbi = (USER_BROWSER_LBI*) plbUserBrowser->RemoveItem( pSel[i] ) ;
		UIASSERT( plbi != NULL ) ;

		//
		// Refuse to deal with any error LBIs
		//
		if ( plbi == plbUserBrowser->QueryErrorLBI() )
		    return NERR_Success ;
	    }

	    //
	    //	We do the display name first because plbi may get deleted
	    //	after the AddItemIdemp if it is a duplicate
	    //
	    err = ERROR_NOT_ENOUGH_MEMORY ;
	    if ( plbi == NULL ||
		 (err = plbi->QueryError()) ||
                 (err = plbi->QualifyDisplayName()))
	    {
		delete plbi ;
		break ;
	    }

            if ( fAddToCache &&
                 (err = _slUsrBrowserLBIsCache.Add( plbi )) )
            {
		delete plbi ;
		break ;
	    }

	    //
	    //	Append to the current name list
	    //

	    if ( ((_mleAdd.QueryTextLength() != 0) || (nlsNames.strlen() != 0)) &&
		 !_mleAdd.IsSingleSelect() )
	    {
		//
		//  Only prefix the "; " if this isn't the first name
		//
		if ( (err = nlsNames.AppendChar( TCH(';') )) ||
		     (err = nlsNames.AppendChar( TCH(' ') ))   )
		{
		    break ;
		}
	    }

	    ALIAS_STR nlsDisplayName( plbi->QueryDisplayName() ) ;
	    if ( err = nlsNames.Append( nlsDisplayName ) )
	    {
		break ;
	    }

	    //
	    //	Only add one name if we are single select
	    //
	    if ( _mleAdd.IsSingleSelect() )
		break ;
	}

    } while (FALSE) ;

    if ( !err )
    {
	_mleAdd.SetText( nlsNames ) ;
	plbUserBrowser->RemoveSelection() ;
    }

    return err ;
}

/*******************************************************************

    NAME:	NT_USER_BROWSER_DIALOG::FindDomain

    SYNOPSIS:	Looks in the combobox for the item corresponding to this
                domain, then returns a BROWSER_DOMAIN *.

    RETURNS:	NULL if the domain cannot be found

    NOTES:

    HISTORY:
        JonN    06-Nov-1992     Created

********************************************************************/

BROWSER_DOMAIN * NT_USER_BROWSER_DIALOG::FindDomain( const OS_SID * possid )
{
    UIASSERT( possid != NULL && possid->QueryError() == NERR_Success ) ;

    INT cDomains = _cbDomains.QueryCount();
    for (INT i = 0; i < cDomains; i++)
    {
        BROWSER_DOMAIN_LBI * plbi =
                (BROWSER_DOMAIN_LBI *)_cbDomains.QueryItem( i );
        ASSERT( plbi != NULL );
        BROWSER_DOMAIN * pbdom = plbi->QueryBrowserDomain();
        ASSERT( pbdom != NULL );
        if ( (*possid) == *(pbdom->QueryDomainSid()) )
            return pbdom;
    }

    TRACEEOL("FindDomain(): domain not found");
    return NULL;
}

/*******************************************************************

    NAME:	NT_USER_BROWSER_DIALOG::OnOK

    SYNOPSIS:	Selects all of the items in the Add dialog if it is present.

    NOTES:

    HISTORY:
	Johnl	28-Oct-1992	Created

********************************************************************/

BOOL NT_USER_BROWSER_DIALOG::OnOK( void )
{
    APIERR err = NERR_Success ;
    APIERR errFailingName = NERR_Success ;
    AUTO_CURSOR niftycursor ;

    do { // error breakout

	NLS_STR nlsFailingName ;
	if ((err = nlsFailingName.QueryError()) ||
	    (err = _mleAdd.CreateLBIListFromNames(
				QueryServerResourceLivesOn(),
				QueryCurrentDomainFocus()->QueryLsaLookupName(),
				&_slUsrBrowserLBIsCache,
				&_slUsrBrowserLBIs,
				&errFailingName,
				&nlsFailingName )) )
	{
	    break ;
	}

	if ( errFailingName )
	{
            SetDialogFocus( _mleAdd );
	    ::MsgPopup( this,
			(MSGID) errFailingName,
			MPSEV_ERROR,
			MP_OK,
			nlsFailingName ) ;

#ifdef EM_SCROLLCARET
	    // The manifest isn't defined and the code in user is commented
	    // out (12/05/92).
	    _mleAdd.Command( EM_SCROLLCARET ) ;
#endif

	}

    } while (FALSE) ;

    if ( err )
	::MsgPopup( this, (MSGID) err ) ;
    else if ( !errFailingName )
	Dismiss( TRUE ) ;

    return TRUE ;
}

/*******************************************************************

    NAME:       NT_USER_BROWSER_DIALOG::QueryHelpContext

    SYNOPSIS:   Typical help context query for this dialog

    HISTORY:
        Johnl   02-Mar-1992     Created

********************************************************************/

ULONG NT_USER_BROWSER_DIALOG::QueryHelpContext( void )
{
    return _ulHelpContext ;
}

/*******************************************************************

    NAME:       NT_USER_BROWSER_DIALOG::QueryHelpFileName

    SYNOPSIS:   Returns the help file name to use for this instance of
                dialog

    NOTES:

    HISTORY:
        Johnl   03-Sep-1992     Created

********************************************************************/

const TCHAR * NT_USER_BROWSER_DIALOG::QueryHelpFile( ULONG ulHelpContext )
{
    UNREFERENCED( ulHelpContext ) ;
    return _pszHelpFileName ;
}


/*******************************************************************

    NAME:       BROWSER_DOMAIN::BROWSER_DOMAIN

    SYNOPSIS:   Standard constructor/destructor for the BROWSER_DOMAIN class.

    ENTRY:      pszDomainName - Name of this domain
                psidDomain - SID of this domain (maybe unecessary)
                fAliasesAreEnumerated - TRUE if aliases should be enumerated
                    on this domain

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   03-Mar-1992     Created

********************************************************************/

BROWSER_DOMAIN::BROWSER_DOMAIN( const TCHAR * pszDomainName,
                                      PSID    psidDomain,
                                      BOOL    fIsTargetDomain,
                                      BOOL    fIsWinNTMachine )
    : _nlsDomainName        ( pszDomainName ),
      _nlsDisplayName	    ( pszDomainName ),
      _nlsLsaDomainName     ( pszDomainName ),
      _ossidDomain          ( psidDomain, TRUE ),
      _fIsTargetDomain      ( fIsTargetDomain ),
      _fIsWinNT 	    ( fIsWinNTMachine ),
      _pFillDomainThread    ( NULL )

{
    if ( QueryError() )
        return ;

    APIERR err ;
    if ( (err = _nlsDomainName.QueryError() )	||
	 (err = _nlsLsaDomainName.QueryError()) ||
         (err = _ossidDomain.QueryError())      )
    {
        ReportError( err ) ;
        return ;
    }

    //
    //	If the domain name is NULL then get the machine name from Windows
    //
    if ( pszDomainName == NULL )
    {
	TCHAR achComputerName[ MAX_COMPUTERNAME_LENGTH+1 ] ;
	DWORD cchComputerName = sizeof( achComputerName ) / sizeof(TCHAR) ;

	if ( !::GetComputerName( achComputerName, &cchComputerName ))
	{
	    ReportError( ::GetLastError() ) ;
	    return ;
	}

	if ( (err = _nlsDisplayName.CopyFrom( (const TCHAR *) achComputerName)) ||
	     (err = _nlsLsaDomainName.CopyFrom( (const TCHAR *) achComputerName)) )
        {
            ReportError( err ) ;
            return ;
        }

	//
	//  Add "\\"'s if they are not already there
	//
        ISTR istrDisplayName( _nlsDisplayName ) ;
        if ( _nlsDisplayName.QueryChar( istrDisplayName ) != TCH('\\') )
        {
            ALIAS_STR nlsWhackWhack( SZ("\\\\") ) ;
            if ( ! _nlsDisplayName.InsertStr( nlsWhackWhack,
                                                  istrDisplayName ) )
            {
                ReportError( _nlsDisplayName.QueryError() ) ;
                return ;
            }
        }
    }
    else if ( pszDomainName[0] == TCH('\\') && pszDomainName[1] == TCH('\\'))
    {
	//
	//  If the domain name begins with '\\' (we're looking at a workgroup),
	//  then strip them so the LSA is happy
	//
	if ( err = _nlsLsaDomainName.CopyFrom( (const TCHAR *) pszDomainName+2) )
	{
	    ReportError( err ) ;
	    return ;
	}
    }


    /* Mark the target domain appropriately
     */
    if ( fIsTargetDomain &&
         (err = SetAsTargetDomain()) )
    {
        ReportError( err ) ;
        return ;
    }
}

BROWSER_DOMAIN::~BROWSER_DOMAIN()
{
    if ( _pFillDomainThread != NULL )
    {
	//
	//  Tell the thread we are going away.	
	//
	//  Don't delete _pFillDomainThread.  It will delete itself
	//

	(void) _pFillDomainThread->ExitThread() ;

	_pFillDomainThread = NULL ;
    }
}

/*******************************************************************

    NAME:       BROWSER_DOMAIN::SetAsTargetDomain

    SYNOPSIS:   Marks this domain as the target domain

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   07-May-1992     Moved to private method

********************************************************************/

APIERR BROWSER_DOMAIN::SetAsTargetDomain( void )
{
    _fIsTargetDomain = TRUE ;
    return _nlsDisplayName.AppendChar( ALIAS_MARKER_CHAR ) ;
}

/*******************************************************************

    NAME:       BROWSER_DOMAIN::GetDomainInfo

    SYNOPSIS:	Creates a domain thread for this domain

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The server used for this domain is the PDC of the domain

    HISTORY:
        Johnl   30-Mar-1992     Created

********************************************************************/

APIERR BROWSER_DOMAIN::GetDomainInfo( NT_USER_BROWSER_DIALOG * pdlg,
					const ADMIN_AUTHORITY * pAdminAuth )
{
    //
    // Create thread for this domain if we haven't already done so
    //
    APIERR err = NERR_Success ;

    if ( _pFillDomainThread == NULL )
    {
	_pFillDomainThread = new DOMAIN_FILL_THREAD( pdlg, this, pAdminAuth ) ;

	err = ERROR_NOT_ENOUGH_MEMORY ;
	if ( _pFillDomainThread == NULL ||
	     (err = _pFillDomainThread->QueryError()) ||
             (err = _pFillDomainThread->Resume()) )
	{
	    delete _pFillDomainThread ;
	    _pFillDomainThread = NULL ;
	}
    }

    return err ;
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN::GetQualifiedDomainName

    SYNOPSIS:	Returns the domain name in yet another form

    ENTRY:	pnlsDomainName - String to receive domain name

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	20-Oct-1992	Created

********************************************************************/

APIERR BROWSER_DOMAIN::GetQualifiedDomainName( NLS_STR * pnlsDomainName )
{
    //
    //	The display name has what we want except it may have the "\\" or
    //	"*" which we will need to strip
    //
    NLS_STR nlsDomain( QueryDisplayName()[0] == TCH('\\') ?
						QueryDisplayName() + 2 :
						QueryDisplayName()) ;

    if ( IsTargetDomain() )
    {
	ISTR istr( nlsDomain ) ;

	if ( nlsDomain.strrchr( &istr, ALIAS_MARKER_CHAR ) )
	    nlsDomain.DelSubStr( istr ) ;
    }

    return pnlsDomainName->CopyFrom( nlsDomain ) ;
}

/*******************************************************************

    NAME:       BROWSER_SUBJECT_ITER::BROWSER_SUBJECT_ITER

    SYNOPSIS:   Typical constructor/destructor

    ENTRY:      pNtUserBrowserDialog - Pointer to a user browser dialog
                that the user just pressed OK on.

    NOTES:

    HISTORY:
        Johnl   05-Mar-1992     Created

********************************************************************/

BROWSER_SUBJECT_ITER::BROWSER_SUBJECT_ITER(
                                NT_USER_BROWSER_DIALOG * pNtUserBrowserDialog )
    : _pUserBrowserDialog( pNtUserBrowserDialog ),
      _BrowserSubject	 (),
      _iterUserBrowserLBIs( *_pUserBrowserDialog->QuerySelectionList() )
{
    if ( QueryError() )
        return ;

    UIASSERT( pNtUserBrowserDialog != NULL ) ;
    UIASSERT( !pNtUserBrowserDialog->QueryError() ) ;
}

BROWSER_SUBJECT_ITER::~BROWSER_SUBJECT_ITER()
{
    _pUserBrowserDialog = NULL ;
}

/*******************************************************************

    NAME:       BROWSER_SUBJECT_ITER::Next

    SYNOPSIS:   Returns the next item in the selection of the listbox

    ENTRY:      ppBrowserSubject - Pointer to a pointer to receive a
                    BROWSER_SUBJECT object.  Do not free this memory.

    EXIT:

    RETURNS:    NERR_Success if successful error code otherwise.

                If NERR_Success is returned, then check *ppBrowserSubject
                for NULL.  If it is NULL, then the iteration is finished.

                If an error code is returned, then *ppBrowserSubject is not
                initialized.

    NOTES:

    HISTORY:
        Johnl   05-Mar-1992     Created

********************************************************************/

APIERR BROWSER_SUBJECT_ITER::Next( BROWSER_SUBJECT ** ppBrowserSubject )
{
    //
    //	If we have finished the iteration, get, out.
    //
    USER_BROWSER_LBI * plbi ;
    if ( (plbi = _iterUserBrowserLBIs.Next()) == NULL )
    {
        *ppBrowserSubject = NULL ;
        return NERR_Success ;
    }

    APIERR err = NERR_Success ;
    if ( !(err = _BrowserSubject.SetUserBrowserLBI( plbi )) )
    {
	*ppBrowserSubject = &_BrowserSubject ;
    }

    return err ;
}


/*******************************************************************

    NAME:       BROWSER_SUBJECT::BROWSER_SUBJECT

    SYNOPSIS:   Standard constructor/destructor

    ENTRY:

    NOTES:

    HISTORY:
        JohnL   05-Mar-1992     Created

********************************************************************/

BROWSER_SUBJECT::BROWSER_SUBJECT()
    : _ossidAccount	( NULL		 ),
      _ossidDomain	( NULL		 ),
      _pUserBrowserLBI	( NULL		 )
{
    if ( QueryError() )
        return ;

    APIERR err ;
    if ( (err = _ossidAccount.QueryError() )  ||
	 (err = _ossidDomain.QueryError()) )
    {
        DBGEOL( "BROWSER_SUBJECT::ct - error constructing private member" ) ;
        ReportError( err ) ;
        return ;
    }
}


BROWSER_SUBJECT::~BROWSER_SUBJECT()
{
    /* Nothing to do
     */
}

/*******************************************************************

    NAME:	BROWSER_SUBJECT::SetUserBrowserLBI

    SYNOPSIS:	Sets up this browser subject so it can be used in an iteration

    ENTRY:	pUserBrowserLBI - Pointer to select we are enumerating

    EXIT:	_ossidAccount will be set up with the account SID and
		_ossidDomain will be set up with the domain SID for this
		account

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	20-Oct-1992	Created

********************************************************************/

APIERR BROWSER_SUBJECT::SetUserBrowserLBI( USER_BROWSER_LBI * pUserBrowserLBI )
{
    UIASSERT( pUserBrowserLBI != NULL ) ;

    _pUserBrowserLBI = pUserBrowserLBI ;

    APIERR err ;
    UCHAR * pcSubAuthority ;
    if ( (err = _ossidAccount.SetPtr( pUserBrowserLBI->QueryPSID() )) ||
	 (err = _ossidDomain.Copy( _ossidAccount ))		      ||
	 (err = _ossidDomain.QuerySubAuthorityCount( &pcSubAuthority )) )
    {
	return err ;
    }

    /* Make the account SID into the domain SID.
     */
    *pcSubAuthority -= 1 ;

    return err ;
}

/*******************************************************************

    NAME:       BROWSER_SUBJECT::QueryQualifiedName

    SYNOPSIS:   Gives a suitable name for immediately displaying this
                subject, complete with domain prefix and user name, if
                desired.

    ENTRY:      pnlsQualifiedName - NLS_STR to receive the qualified name
                pnlsDomainName - Name of the "Focused" domain (i.e., where
                                 the app is focused)
                fShowFullName - TRUE if the full name should be included

    EXIT:       pnlsQualifiedName will contain the fully qualified name

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   10-Jun-1992     Created

********************************************************************/

APIERR BROWSER_SUBJECT::QueryQualifiedName(
                                 NLS_STR * pnlsQualifiedName,
                           const NLS_STR * pnlsDomainName,
                                 BOOL      fShowFullName ) const
{
    UIASSERT( pnlsQualifiedName != NULL ) ;
    UIASSERT( _pUserBrowserLBI != NULL ) ;

    APIERR err ;

    /* Well known SIDs don't get the domain prefix
     */
    if ( QueryType() != SidTypeWellKnownGroup)
    {
	ALIAS_STR nlsDomainAccountIsOn( QueryDomainName() ) ;
	ALIAS_STR nlsAccountName( QueryAccountName() ) ;
	ALIAS_STR nlsFullName	( QueryFullName() ) ;
        err = NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                                     pnlsQualifiedName,
						     nlsAccountName,
                                                     nlsDomainAccountIsOn,
						     fShowFullName ? &nlsFullName
                                                                   : NULL,
                                                     pnlsDomainName ) ;
    }
    else
    {
	err = pnlsQualifiedName->CopyFrom( QueryAccountName() ) ;
    }

    return err ;
}


/*************************************************************************

    NAME:	BROWSER_DOMAIN_CB

    SYNOPSIS:   This listbox lists users, groups, aliases and well known SIDs.

    INTERFACE:

    PARENT:	BLT_COMBOBOX

    USES:       DISPLAY_MAP

    CAVEATS:

    NOTES:

    HISTORY:
	Johnl	27-Oct-1992	Created

**************************************************************************/

BROWSER_DOMAIN_CB::BROWSER_DOMAIN_CB( OWNER_WINDOW * powin,
				      CID cid )
    : BLT_COMBOBOX	( powin, cid ),
      _dmDomain 	( BMID_DOMAIN_CANNOT_EXPAND ),
      _dmComputer	( BMID_SERVER )
{
    if ( QueryError() )
        return ;

    APIERR err = NERR_Success ;

    if ( (err = _dmDomain.QueryError())    ||
	 (err = _dmComputer.QueryError())  ||
         (err = DISPLAY_TABLE::CalcColumnWidths( (UINT *) QueryColWidthArray(),
						 2,
                                                 powin,
                                                 QueryCid(),
                                                 TRUE )) )
    {
        ReportError( err ) ;
        return ;
    }
}

BROWSER_DOMAIN_CB::~BROWSER_DOMAIN_CB()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_CB::AddItem

    SYNOPSIS:	Adds the browser domain to the combo

    ENTRY:	pBrowDomain - heap allocated browser domain to add

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:	This method will check for successful allocation and
		construction of the browser domain

    HISTORY:
	Johnl	27-Oct-1992	Created

********************************************************************/

APIERR BROWSER_DOMAIN_CB::AddItem( BROWSER_DOMAIN * pBrowDomain )
{
    if ( pBrowDomain == NULL )
	return ERROR_NOT_ENOUGH_MEMORY ;

    APIERR err ;
    if ( err = pBrowDomain->QueryError())
	return err ;

    if ( BLT_COMBOBOX::AddItem( new BROWSER_DOMAIN_LBI( pBrowDomain )) == -1 )
    {
	err = ERROR_NOT_ENOUGH_MEMORY ;
    }

    return err ;
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_CB::SelectItem

    SYNOPSIS:	Selects the item in the combo box that points to pBrowDomain

    ENTRY:	pBrowDomain - Item to select

    NOTES:

    HISTORY:
	Johnl	27-Oct-1992	Created

********************************************************************/

void BROWSER_DOMAIN_CB::SelectItem( BROWSER_DOMAIN * pBrowDomain )
{
    INT cItems = QueryCount() ;

    for ( INT i = 0 ; i < cItems ; i++ )
    {
	BROWSER_DOMAIN_LBI * plbi = (BROWSER_DOMAIN_LBI*) QueryItem( i ) ;
	if ( plbi->QueryBrowserDomain() == pBrowDomain )
	{
	    BLT_COMBOBOX::SelectItem( i, TRUE ) ;
	    return ;
	}
    }

    UIASSERT( FALSE ) ;
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_CB::QueryDisplayMap

    SYNOPSIS:	Returns the appropriate display map to use for this
		browser domain

    RETURNS:	Pointer to appropriate display map

    HISTORY:
	Johnl	27-Oct-1992	Created

********************************************************************/

DISPLAY_MAP * BROWSER_DOMAIN_CB::QueryDisplayMap(const BROWSER_DOMAIN_LBI * plbi )
{
    DISPLAY_MAP * pdmap = &_dmDomain ;
    if ( plbi->QueryBrowserDomain()->IsWinNTMachine() )
	pdmap = &_dmComputer ;

    return pdmap ;
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI::~BROWSER_DOMAIN_LBI

    SYNOPSIS:	Deletes _pBrowDomain member

    HISTORY:
	Johnl	27-Oct-1992	Created

********************************************************************/

BROWSER_DOMAIN_LBI::~BROWSER_DOMAIN_LBI()
{
    delete _pBrowDomain ;
    _pBrowDomain = NULL ;
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI::Paint

    SYNOPSIS:   Typical LBI Paint method

    NOTES:

    HISTORY:
	Johnl	27-Oct-1992	Created
        JonN    04-Dec-1992     W_Paint worker function

********************************************************************/

VOID BROWSER_DOMAIN_LBI::Paint(
                    LISTBOX * plb,
                    HDC hdc,
                    const RECT * prect,
                    GUILTT_INFO * pGUILTT ) const
{
    W_Paint( (BROWSER_DOMAIN_CB *)plb, plb, hdc, prect, pGUILTT );
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI::W_Paint

    SYNOPSIS:   Paint worker function, called directly by piggyback LBI

    ENTRY:      pcbBrowser - User Browser combobox containing bitmaps
                plbActual  - Listbox which actually contains LBI to be drawn

    NOTES:

    HISTORY:
        JonN    04-Dec-1992     Created

********************************************************************/

VOID BROWSER_DOMAIN_LBI::W_Paint(
                    BROWSER_DOMAIN_CB * pcbBrowser,
                    LISTBOX * plbActual,
                    HDC hdc,
                    const RECT * prect,
                    GUILTT_INFO * pGUILTT ) const
{
    STR_DTE strdteName( QueryDisplayName() ) ;
    DM_DTE  dmdteIcon( pcbBrowser->QueryDisplayMap( this ) ) ;

    DISPLAY_TABLE dt( 2, pcbBrowser->QueryColWidthArray()) ;
    dt[0] = & dmdteIcon ;
    dt[1] = & strdteName ;

    dt.Paint( plbActual, hdc, prect, pGUILTT ) ;
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI::Compare

    SYNOPSIS:   Typical LBI compare for user browser listbox

    NOTES:      This method will sort all user sid types to the end of
                the list

    HISTORY:
	Johnl	27-Oct-1992	Created

********************************************************************/

INT BROWSER_DOMAIN_LBI::Compare( const LBI * plbi ) const
{
    BROWSER_DOMAIN_LBI * pubrowLBI = (BROWSER_DOMAIN_LBI*) plbi ;

    return ::stricmpf( QueryDisplayName(), pubrowLBI->QueryDisplayName() ) ;
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI::QueryLeadingChar

    SYNOPSIS:   Typical QueryLeadingChar method

    HISTORY:
	Johnl	27-Oct-1992	Created

********************************************************************/

WCHAR BROWSER_DOMAIN_LBI::QueryLeadingChar( void ) const
{
    return QueryDisplayName()[0] ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\usrlb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    usrlb.cxx

    Basic User Browser listbox



    FILE HISTORY:
        Johnl   08-Dec-1992     Created
        jonn        14-Oct-1993 Moved bitmaps to SUBJECT_BITMAP_BLOCK

*/

#include "pchapplb.hxx"   // Precompiled header
#include "browmemb.hxx"
#include "bmpblock.hxx"   // SUBJECT_BITMAP_BLOCK

#ifndef min
    #define min(a,b)  ((a)<=(b) ? (a) : (b))
#endif

static WCHAR IsCharPrintableOrSpace( WCHAR wch ) ;


//
// The following defines are used in the slow mode timing heuristics in
// AddAliases and AddGroups.  A timer determines how long it takes
// to read in each batch of alias/group accounts.  If this time is less
// that READ_MORE_MSEC, we double the number of bytes requested on the
// next call.  If it is more than READ_LESS_MSEC, we halve it.
//

#define USRBROWS_ALIASES_INITIAL_COUNT  2048
#define USRBROWS_ALIASES_MIN_COUNT       512
#define USRBROWS_ALIASES_MAX_COUNT      0xFFFF /* 64K */
#define USRBROWS_ALIASES_READ_MORE_MSEC 1000
#define USRBROWS_ALIASES_READ_LESS_MSEC 5000

#define USRBROWS_GROUPS_INITIAL_COUNT   USRBROWS_ALIASES_INITIAL_COUNT
#define USRBROWS_GROUPS_MIN_COUNT       USRBROWS_ALIASES_MIN_COUNT
#define USRBROWS_GROUPS_MAX_COUNT       USRBROWS_ALIASES_MAX_COUNT
#define USRBROWS_GROUPS_READ_MORE_MSEC  USRBROWS_ALIASES_READ_MORE_MSEC
#define USRBROWS_GROUPS_READ_LESS_MSEC  USRBROWS_ALIASES_READ_LESS_MSEC


class USRLB_NT_GROUP_ENUM : public NT_GROUP_ENUM
{
protected:

    virtual APIERR QueryCountPreferences(
        ULONG * pcEntriesRequested,  // how many entries to request on this call
        ULONG * pcbBytesRequested,   // how many bytes to request on this call
        UINT nNthCall,               // 0 just before 1st call, 1 before 2nd call, etc.
        ULONG cLastEntriesRequested, // how many entries requested on last call
                                     //    ignore for nNthCall==0
        ULONG cbLastBytesRequested,  // how many bytes requested on last call
                                     //    ignore for nNthCall==0
        ULONG msTimeLastCall );      // how many milliseconds last call took

public:

    USRLB_NT_GROUP_ENUM( const SAM_DOMAIN * psamdomain )
        : NT_GROUP_ENUM( psamdomain )
        {}

    ~USRLB_NT_GROUP_ENUM()
        {}

};  // class NT_GROUP_ENUM


APIERR USRLB_NT_GROUP_ENUM::QueryCountPreferences(
        ULONG * pcEntriesRequested,  // how many entries to request on this call
        ULONG * pcbBytesRequested,   // how many bytes to request on this call
        UINT nNthCall,               // 0 just before 1st call, 1 before 2nd call, etc.
        ULONG cLastEntriesRequested, // how many entries requested on last call
                                     //    ignore for nNthCall==0
        ULONG cbLastBytesRequested,  // how many bytes requested on last call
                                     //    ignore for nNthCall==0
        ULONG msTimeLastCall )       // how many milliseconds last call took
{
    return QueryCountPreferences2( pcEntriesRequested,
                                   pcbBytesRequested,
                                   nNthCall,
                                   cLastEntriesRequested,
                                   cbLastBytesRequested,
                                   msTimeLastCall );
}



/*************************************************************************

    NAME:       USER_BROWSER_LB

    SYNOPSIS:   This listbox lists users, groups, aliases and well known SIDs.

    INTERFACE:

    PARENT:     BLT_LISTBOX_HAW

    USES:       DISPLAY_MAP

    CAVEATS:

    NOTES:

    HISTORY:
        Johnl   20-Oct-1992     Created

**************************************************************************/

USER_BROWSER_LB::USER_BROWSER_LB( OWNER_WINDOW * powin, CID cid )
    : LAZY_LISTBOX      ( powin, cid ),
      _pbmpblock        ( NULL ),
      _plbicacheCurrent ( NULL ),
      _plbiError        ( NULL ),
      _hawinfo          ( )
{
    APIERR err = NERR_Success ;

    if ((err = _hawinfo.QueryError()) )
    {
        ReportError( err ) ;
        return ;
    }

    RESOURCE_STR nls( ERROR_NOT_ENOUGH_MEMORY ) ;
    OS_SID ossid ;
    if ( (err = DISPLAY_TABLE::CalcColumnWidths( (UINT *) QueryColWidthArray(),
                                                 3,
                                                 powin,
                                                 QueryCid(),
                                                 TRUE ))  ||
         (err = nls.QueryError()) ||
         (err = ossid.QueryError()) ||
         (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Admins, &ossid )) )
    {
        ReportError( err ) ;
        return ;
    }

    err = ERROR_NOT_ENOUGH_MEMORY ;
    _pbmpblock = new SUBJECT_BITMAP_BLOCK();
    _plbiError = new USER_BROWSER_LBI( nls, SZ(""), nls, SZ(""), SZ(""),
                                       ossid.QueryPSID(), UI_SID_Admins,
                                       SidTypeAlias ) ;
    if ( (_plbiError == NULL) ||
         (_pbmpblock == NULL) ||
         (err = _pbmpblock->QueryError()) ||
         (err = _plbiError->QueryError()) )
    {
        ReportError( err ) ;
        delete _plbiError ;
        _plbiError = NULL ;
        return ;
    }


}

USER_BROWSER_LB::~USER_BROWSER_LB()
{
    delete _pbmpblock;
    delete _plbiError ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LB::QueryDisplayMap

    SYNOPSIS:   Retrieves the correct display map based on the LBI type

    ENTRY:      plbi - Pointer to LBI we are getting the display map for

    RETURNS:    Pointer to the appropriate display map

    NOTES:

    HISTORY:
        Johnl   02-Mar-1992     Created

********************************************************************/

DISPLAY_MAP * USER_BROWSER_LB::QueryDisplayMap(
                                             const USER_BROWSER_LBI * plbi )
{
    UIASSERT( plbi != NULL ) ;

    return _pbmpblock->QueryDisplayMap( plbi->QueryType(),
                                        plbi->QueryUISysSid(),
                                        !!(plbi->QueryUserAccountFlags()
                                            & USER_TEMP_DUPLICATE_ACCOUNT) );
}

/*******************************************************************

    NAME:       USER_BROWSER_LB::IsSelectionExpandableGroup

    SYNOPSIS:   Checks to see if the Members button should be enabled

    RETURNS:    TRUE if this is a group that can have its members viewed

    HISTORY:
        Johnl   28-Oct-1992     Created

********************************************************************/

BOOL USER_BROWSER_LB::IsSelectionExpandableGroup(
                                      const USER_BROWSER_LBI * plbi,
                                      INT   cSelItems ) const
{
    return (plbi != NULL)           &&
           (cSelItems == 1)         &&
           (plbi->QueryType() == SidTypeAlias ||
            plbi->QueryType() == SidTypeGroup) ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LB::QueryItem

    SYNOPSIS:   This method provides the typical QueryItem funcitonality for
                the listbox.

    ENTRY:      i - LBI index being requested

    RETURNS:    Pointer to LBI

    NOTES:      If an error occurs getting the LBI, then _plbiError will be
                returned, which simply as an account name indicating no
                memory is available.

    HISTORY:
        Johnl   28-Dec-1992     Created

********************************************************************/

USER_BROWSER_LBI * USER_BROWSER_LB::QueryItem( INT i ) const
{
    USER_BROWSER_LBI * plbi ;
    if (  QueryCurrentCache() == NULL ||
         (plbi = (USER_BROWSER_LBI*) QueryCurrentCache()->QueryItem( i )) == NULL )
    {
        return _plbiError ;
    }

    return plbi ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LB::OnNewItem

    SYNOPSIS:   The lazy listbox is requesting an LBI, return it

    HISTORY:
        Johnl   28-Dec-1992     Created

********************************************************************/

LBI * USER_BROWSER_LB::OnNewItem( UINT i )
{
    return (LBI *) QueryItem( i ) ;
}

INT USER_BROWSER_LB::CD_Char( WCHAR wch, USHORT nLastPos )
{
    return CD_Char_HAWforHawaii( wch, nLastPos, &_hawinfo ) ;
}


/**********************************************************************

    NAME:       IsCharPrintableOrSpace

    SYNOPSIS:   Determine whether a character is printable or not

    NOTES:
        This of this as a Unicode/DBCS-safe "isprint"

    HISTORY:
        JonN        30-Dec-1992 Templated from bltlb.cxx

**********************************************************************/

static WCHAR IsCharPrintableOrSpace( WCHAR wch )
{
#if !defined(UNICODE)
    if (HIBYTE(wch) != 0)               // All double-byte chars are printable
        return TRUE;
    return (LOBYTE(wch) >= (BYTE)' ');  // Otherwise, in Latin 1.
#else
    WORD nType;

    BOOL fOK = ::GetStringTypeW(CT_CTYPE1, &wch, 1, &nType);
    ASSERT(fOK);
TRACEEOL( "IsCharPrintableOrSpace(" << (DWORD)wch << ") returns " << nType );

    return (fOK && !(nType & (C1_CNTRL|C1_BLANK)));
#endif
}


/**********************************************************************

    NAME:       USER_BROWSER_LB::CD_Char_HAWforHawaii

    SYNOPSIS:   Custom-draw code to respond to a typed character
                for listboxes with HAW-for-Hawaii support

    ENTRY:      wch      - Character typed
                nLastPos - Current caret position
                phawinfo - Pointer to info buffer used internally
                           to keep track of HAW-for-Hawaii state.
                           This must have constructed successfully,
                           but the caller need not keep closer track.

    RETURNS:    As per WM_CHARTOITEM message (q.v.)

    NOTES:
        Does not assume that items are sorted.

        CODEWORK:  Should be moved to LAZY_LISTBOX class, where this can be
                   implemented more efficiently

    HISTORY:
        JonN        30-Dec-1992 Templated from BLT_LISTBOX

**********************************************************************/

INT USER_BROWSER_LB::CD_Char_HAWforHawaii( WCHAR wch,
                                           USHORT nLastPos,
                                           HAW_FOR_HAWAII_INFO * phawinfo )
{
    UIASSERT( phawinfo != NULL && phawinfo->QueryError() == NERR_Success );

    if ( QueryCurrentCache() == NULL )
    {
        return -2;
    }
    if (wch == VK_BACK)
    {
        phawinfo->_time = 0L; // reset timer
        phawinfo->_nls = SZ("");
        UIASSERT( phawinfo->_nls.QueryError() == NERR_Success );
        TRACEEOL( "USER_BROWSER_LB::CD_Char_HAWforHawaii: backspace" );
        return 0; // go to first LBI
    }

    // Filter characters which won't appear in keys

    if ( ! IsCharPrintableOrSpace( wch ))
        return -2;  // take no other action

    INT clbi = QueryCount();
    if ( clbi == 0 )
    {
        // Should never get this message if no items;
        // 
        //
        return -2;  // take no other action
    }

    LONG lTime = ::GetMessageTime();

#define ThresholdTime 2000

    if ( (lTime - phawinfo->_time) > ThresholdTime )
    {
        TRACEEOL( "USER_BROWSER_LB::CD_Char_HAWforHawaii: threshold timeout" );
        nLastPos = 0;
        phawinfo->_nls = SZ("");
    }

    APIERR err = phawinfo->_nls.AppendChar( wch );
    if (err != NERR_Success)
    {
        DBGEOL( "USER_BROWSER_LB::CD_Char_HAWforHawaii: could not extend phawinfo->_nls" );
        nLastPos = 0;
        phawinfo->_nls = SZ("");
    }

    UIASSERT( phawinfo->_nls.QueryError() == NERR_Success );

    TRACEEOL(   "USER_BROWSER_LB::CD_Char_HAWforHawaii: phawinfo->_nls is \""
             << phawinfo->_nls.QueryPch()
             << "\"" );

    phawinfo->_time = lTime;

    // If this is a single-character search, start search with next entry
    if ( phawinfo->_nls.strlen() <= 1 )
    {
        nLastPos++;
    }

    UNICODE_STRING ustrFind0 ;
    ustrFind0.Length        = (USHORT)phawinfo->_nls.strlen() ;
    ustrFind0.MaximumLength = ustrFind0.Length + sizeof( TCHAR ) ;
    ustrFind0.Buffer        = (PWSTR) phawinfo->_nls.QueryPch() ;

    INT nReturn = -2; // take no other action

    for ( INT iLoop = nLastPos; iLoop < clbi; iLoop++ )
    {
        UNICODE_STRING ustrFind1 ;
        ULC_ENTRY_BASE * pulc = QueryCurrentCache()->QueryEntryPtr( iLoop );
        if ( pulc->pddu != NULL )
        {
            ustrFind1.Length        = pulc->pddu->LogonName.Length ;
            ustrFind1.MaximumLength = pulc->pddu->LogonName.MaximumLength ;
            ustrFind1.Buffer        = pulc->pddu->LogonName.Buffer ;

            if ( ustrFind1.Buffer == NULL )
                continue ;
        }
        else if ( pulc->plbi != NULL )
        {
            USER_BROWSER_LBI * plbi = (USER_BROWSER_LBI*) pulc->plbi ;
            plbi->AliasUnicodeStrToDisplayName( &ustrFind1 ) ;
        }
        else
        {
            UIASSERT( FALSE ) ;
            return 0 ;
        }

        if ( ustrFind1.Length >= ustrFind0.Length )
        {
            INT n = ::strnicmpf( ustrFind0.Buffer,
                                 ustrFind1.Buffer,
                                 ustrFind0.Length / sizeof(TCHAR) );
            if (n == 0)
            {
                //  Return index of item, on which the system listbox should
                //  perform the default action.
                //
                TRACEEOL( "USER_BROWSER_LB::CD_Char_HAWforHawaii: match at " << iLoop );
                return ( iLoop );
            }
            else if (n < 0)
            {
                if (nReturn < 0)
                    nReturn = iLoop;
            }
        }
    }

    //  The character was not found as a leading prefix of any listbox item

    TRACEEOL( "USER_BROWSER_LB::CD_Char_HAWforHawaii: no match, returning " << nReturn );

    //  If all LBIs were less than this string, then jump to the end
    return (nReturn == -2) ? clbi-1 : nReturn;
}


/*******************************************************************

    NAME:       USER_BROWSER_LB::CD_VKey

    SYNOPSIS:   Handles the backspace key

    ENTRY:      nVKey -         Virtual key that was pressed
                nLastPos -      Previous listbox cursor position

    RETURNS:    Return value appropriate to WM_VKEYTOITEM message:
                -2      ==> listbox should take no further action
                -1      ==> listbox should take default action
                other   ==> index of an item to perform default action

    HISTORY:
        jonn        28-Feb-1996 Copied from LAZY_USER_LISTBOX

********************************************************************/

INT USER_BROWSER_LB::CD_VKey( USHORT nVKey, USHORT nLastPos )
{
    if (nVKey == VK_BACK)
    {
        TRACEEOL( "USER_BROWSER_LB:CD_VKey: hit BACKSPACE" );
        _hawinfo._time = 0L; // reset timer
        _hawinfo._nls = SZ("");
        UIASSERT( _hawinfo._nls.QueryError() == NERR_Success );
        return 0; // go to first LBI
    }

    return LAZY_LISTBOX::CD_VKey( nVKey, nLastPos );
}




/*******************************************************************

    NAME:       USER_BROWSER_LB::OnDeleteItem

    SYNOPSIS:   All of our items are stored in the cache, so ignore deletion
                requests

    HISTORY:    Johnl   28-Dec-1992     Created

********************************************************************/

VOID USER_BROWSER_LB::OnDeleteItem( LBI * plbi )
{
    // Don't delete any LBIs since they are stored in the cache
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::USER_BROWSER_LBI_CACHE

    SYNOPSIS:   User browser LBI cache constructor

    HISTORY:
        Johnl   28-Dec-1992     Created

********************************************************************/

USER_BROWSER_LBI_CACHE::USER_BROWSER_LBI_CACHE()
    : USER_LBI_CACHE       (),
      _nlsDomainName       (),
      _ossidDomain         ( NULL ),
      _fCacheContainsUsers ( FALSE ),
      _fIncludeUsersInCount( FALSE ),
      _cUsers              ( 0 ),
      _cNonUsers           ( 0 )

{
    if ( QueryError() )
        return ;

    APIERR err ;
    if ( (err = _nlsDomainName.QueryError()) ||
         (err = _ossidDomain.QueryError()) )
    {
        ReportError( err ) ;
        return ;
    }
}

USER_BROWSER_LBI_CACHE::~USER_BROWSER_LBI_CACHE()
{
    // Nothing to do
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::CreateLBI

    SYNOPSIS:   The cache wants an LBI created from a pddu

    NOTES:

    HISTORY:
        Johnl   28-Dec-1992     Created

********************************************************************/

LBI * USER_BROWSER_LBI_CACHE::CreateLBI( const DOMAIN_DISPLAY_USER * pddu )
{
    NLS_STR nlsAccountName ;
    NLS_STR nlsFullName ;
    NLS_STR nlsComment ;
    NLS_STR nlsDisplayName ;
    OS_SID  ossidUser( _ossidDomain, pddu->Rid ) ;

    if ( nlsAccountName.QueryError() ||
         nlsFullName.QueryError()    ||
         nlsComment.QueryError()     ||
         nlsDisplayName.QueryError() ||
         nlsAccountName.MapCopyFrom( pddu->LogonName.Buffer,
                                     pddu->LogonName.Length ) ||
         nlsFullName.MapCopyFrom   ( pddu->FullName.Buffer,
                                     pddu->FullName.Length ) ||
         nlsComment.MapCopyFrom    ( pddu->AdminComment.Buffer,
                                     pddu->AdminComment.Length )  ||
         ossidUser.QueryError() ||
         NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                     &nlsDisplayName,
                                     nlsAccountName,
                                     _nlsDomainName,
                                     &nlsFullName,
                                     &_nlsDomainName ) )
    {
        return NULL ;
    }

    return new USER_BROWSER_LBI(  nlsAccountName,
                                  nlsFullName,
                                  nlsDisplayName,
                                  nlsComment,
                                  _nlsDomainName,
                                  ossidUser,
                                  UI_SID_Invalid,
                                  SidTypeUser,
                                  pddu->AccountControl ) ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::Compare

    SYNOPSIS:   Compares a user browser lbi and a pddu

    NOTES:

    HISTORY:
        Johnl   28-Dec-1992     Created

********************************************************************/

INT USER_BROWSER_LBI_CACHE::Compare( const LBI                 * plbi,
                                     const DOMAIN_DISPLAY_USER * pddu ) const
{
    USER_BROWSER_LBI * pubrowLBI = (USER_BROWSER_LBI*) plbi ;

// CODEWORK We are not consistent about comparing the LogonName vs. the
// DisplayName

    if ( (pubrowLBI->QueryType() != SidTypeUser ))
    {
        return -1 ;
    }

    UNICODE_STRING unistrLBI;
    unistrLBI.Buffer = (PWSTR)((USER_BROWSER_LBI *)plbi)->QueryAccountName();
    unistrLBI.Length = ::strlenf(unistrLBI.Buffer)*sizeof(WCHAR);
    unistrLBI.MaximumLength = unistrLBI.Length + sizeof(WCHAR);

    return CmpUniStrs ( &unistrLBI, &(pddu->LogonName) );
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::Compare

    SYNOPSIS:   Compares two user browser lbis

    HISTORY:
        Johnl   28-Dec-1992     Created

********************************************************************/


INT USER_BROWSER_LBI_CACHE::Compare( const LBI * plbi0,
                                     const LBI * plbi1 ) const
{
    USER_BROWSER_LBI * pubrowLBI0 = (USER_BROWSER_LBI*) plbi0 ;
    USER_BROWSER_LBI * pubrowLBI1 = (USER_BROWSER_LBI*) plbi1 ;

    if ( (pubrowLBI0->QueryType() != SidTypeUser) &&
         (pubrowLBI1->QueryType() == SidTypeUser ))
    {
        return -1 ;
    }

    if ( (pubrowLBI0->QueryType() == SidTypeUser) &&
         (pubrowLBI1->QueryType() != SidTypeUser ))
    {
        return 1 ;
    }

    return ::stricmpf( pubrowLBI0->QueryDisplayName(),
                       pubrowLBI1->QueryDisplayName()  ) ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::AddUsers

    SYNOPSIS:   Tells the cache to read the users from the passed admin
                authority

    ENTRY:      Same as USER_LBI_CACHE::ReadUsers

    NOTES:

    HISTORY:
        Johnl   28-Dec-1992     Created

********************************************************************/

APIERR USER_BROWSER_LBI_CACHE::AddUsers( ADMIN_AUTHORITY * pAdminAuthority,
                                         const TCHAR     * pszDomain,
                                         BOOL              fIsTargetDomain,
                                         BOOL            * pfQuitEnum )
{
    UNREFERENCED( pfQuitEnum ) ;
    ASSERT( pfQuitEnum != NULL );
    APIERR err ;

    //
    //  Somebody specifically requested users so include them in the cache count
    //
    _fIncludeUsersInCount = TRUE ;

    if ( _fCacheContainsUsers )
        return NERR_Success ;

    //
    //  CODEWORK - Add pfQuitEnum support to user cache (set by 2nd thread)
    //
    OS_SID ossidTmp( pAdminAuthority->QueryAccountDomain()->QueryPSID() ) ;
    if ( (err = _nlsDomainName.CopyFrom( pszDomain )) ||
         (err = ossidTmp.QueryError()) ||
         (err = _ossidDomain.Copy( ossidTmp )) ||
         (err = ReadUsers( pAdminAuthority, ULC_INITIAL_GROWTH_DEFAULT,
                                            ULC_REQUEST_COUNT_DEFAULT,
                                            fIsTargetDomain,
                                            pfQuitEnum )) )
    {
        // fall through
    }

    //
    //  Adjust the total user count
    //
    _cUsers = USER_LBI_CACHE::QueryCount() - _cNonUsers ;

    if ( !err )
    {
	_fCacheContainsUsers = TRUE ;
	Sort() ;
    }

    return err ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::Fill

    SYNOPSIS:   This method adds all of the users/groups/aliases/
                well known SIDs to this listbox.  The contents are emptied
                first.  What to add is specified by the ulFlags parameter which
                contains the combination of USRBROWS_INCL* and USRBROWS_SHOW*
                flags.

    ENTRY:      pAdminAuthority - Pointer to domain we are browsing
                ulFlags - set of USRBROWS_* incl and show flags.

    EXIT:       The cache will be filled with the requested items

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      Must be MT safe!

    HISTORY:
        Johnl   02-Mar-1992     Created

********************************************************************/

APIERR USER_BROWSER_LBI_CACHE::Fill( ADMIN_AUTHORITY  * pAdminAuthority,
                                     const TCHAR *      pszQualifyingDomain,
                                     ULONG              ulFlags,
                                     BOOL               fIsWinNTDomain,
                                     BOOL               fIsTargetDomain,
                                     BOOL *             pfQuitEnum )
{
    ASSERT( pfQuitEnum != NULL );
    APIERR err = NERR_Success ;
    AUTO_CURSOR CursorHourGlass ;

    if ( *pfQuitEnum )
        return err ;

    if ( !err &&
         fIsTargetDomain &&
         (ulFlags & USRBROWS_SHOW_ALIASES) )
    {
        err = AddAliases( pAdminAuthority, pszQualifyingDomain,
                          pfQuitEnum ) ;
    }

    if ( !err &&
         !fIsWinNTDomain &&
         (ulFlags & USRBROWS_SHOW_GROUPS) )
    {
        err = AddGroups( pAdminAuthority, pszQualifyingDomain,
                         pfQuitEnum ) ;
    }

    if ( !err && (ulFlags & USRBROWS_INCL_ALL) )
    {
        err = AddWellKnownSids( pAdminAuthority, ulFlags, pfQuitEnum ) ;

    }

    //
    //  Show (in this context, expand) the users if the client specifically
    //  requested them to be shown or all we are showing is users
    //  (regardless of the expanded user flag).
    //
    if ( !err && ((ulFlags & USRBROWS_EXPAND_USERS)  ||
                 ((ulFlags & USRBROWS_SHOW_ALL ) == USRBROWS_SHOW_USERS)))
    {
        err = AddUsers( pAdminAuthority, pszQualifyingDomain, fIsTargetDomain,
                        pfQuitEnum ) ;
    }

    return err ;
}


/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::AddAliases

    SYNOPSIS:   The method enumerates all of the aliases on the given
                domain and adds them to the listbox

    ENTRY:      pBrowserDomain - Pointer to the browser domain to enumerate
                    the aliases on

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   26-Mar-1992     Implemented

********************************************************************/

APIERR USER_BROWSER_LBI_CACHE::AddAliases( ADMIN_AUTHORITY * pAdminAuthority,
                                           const TCHAR * pszQualifyingDomain,
                                           BOOL *pfQuitEnum )
{
    ASSERT( pfQuitEnum != NULL );
    TRACEEOL("\tUSER_BROWSER_LBI_CACHE::AddAliases Entered @ " << ::GetTickCount()/100) ;

    APIERR err = NERR_Success ;

    if ( (err = AddAliases( pAdminAuthority->QueryAccountDomain(),
                            pszQualifyingDomain,
                            pfQuitEnum ))  ||
         (err = AddAliases( pAdminAuthority->QueryBuiltinDomain(),
                            pszQualifyingDomain,
                            pfQuitEnum )) )
    {
        /* Fall through
         */

    }

    TRACEEOL("\tUSER_BROWSER_LBI_CACHE::AddAliases Leave    @ " << ::GetTickCount()/100) ;
    return err ;
}


/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::AddAliases

    SYNOPSIS:   The method enumerates all of the aliases on the given
                SAM domain and adds them to the listbox

    ENTRY:      pSAMDomain - Pointer to the SAM domain to get the aliases for


    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   26-Mar-1992     Implemented

********************************************************************/

APIERR USER_BROWSER_LBI_CACHE::AddAliases( SAM_DOMAIN * pSAMDomain,
                                           const TCHAR * pszQualifyingDomain,
                                           BOOL * pfQuitEnum )
{
    ASSERT( pfQuitEnum != NULL );
    APIERR err = NERR_Success ;

    if ( *pfQuitEnum )
        return err ;

    do { // error breakout

        SAM_ENUMERATE_HANDLE    hSAMEnum = 0 ;
        SAM_RID_ENUMERATION_MEM SAMRidEnumMem ;
        NLS_STR                 nlsAccountName ;
        NLS_STR                 nlsComment ;

        if ( (err = SAMRidEnumMem.QueryError()) ||
             (err = nlsAccountName.QueryError())||
             (err = nlsComment.QueryError())      )
        {
            break ;
        }

        /* set the initial read count */
        ULONG ulBytesRequested = USRBROWS_ALIASES_INITIAL_COUNT;

        /* EnumerateAliases returned ERROR_MORE_DATA */
        BOOL fMoreData = FALSE;

        /* Loop through each alias and add it to the listbox
         */
        do {

            /* make API call and time how long it takes */
            DWORD start = ::GetTickCount();
            err = pSAMDomain->EnumerateAliases( &SAMRidEnumMem,
                                                &hSAMEnum,
                                                ulBytesRequested ) ;
            DWORD finish = ::GetTickCount();

            TRACEEOL( "AddAliases: first " << ulBytesRequested << " read in " << (finish-start) );

            /* adjust ulBytesRequested according to how long the last call took */
            if ( finish - start < USRBROWS_ALIASES_READ_MORE_MSEC )
            {
                ulBytesRequested *= 2;
                if ( ulBytesRequested > USRBROWS_ALIASES_MAX_COUNT )
                    ulBytesRequested = USRBROWS_ALIASES_MAX_COUNT;
            }
            else if ( finish - start > USRBROWS_ALIASES_READ_LESS_MSEC )
            {
                ulBytesRequested /= 2;
                if ( ulBytesRequested < USRBROWS_ALIASES_MIN_COUNT )
                    ulBytesRequested = USRBROWS_ALIASES_MIN_COUNT;

            }

            fMoreData = (err == ERROR_MORE_DATA);
            if ( err != NERR_Success )
            {
                if (err == ERROR_MORE_DATA)
                {
                    TRACEEOL( "AddAliases: will request more data" );
                    err = NERR_Success;
                }
                else
                {
                    DBGEOL( "AddAliases: Error " << (ULONG) err <<
                            "Enumerating aliases" ) ;
                    break ;
                }
            }

            for ( ULONG i = 0 ; i < SAMRidEnumMem.QueryCount() ; i++ )
            {
                if ( *pfQuitEnum )
                    break ;

                ULONG ulRid = SAMRidEnumMem.QueryRID( i ) ;
                if ( (err = SAMRidEnumMem.QueryName( i, &nlsAccountName )))
                {
                    break ;
                }

                /* We also need to get the comment for this alias
                 */
                SAM_ALIAS SAMAlias( *pSAMDomain,
                                    ulRid,
                                    ALIAS_READ_INFORMATION ) ;

                OS_SID ossidAlias( pSAMDomain->QueryPSID(), ulRid ) ;
                if ( (err = SAMAlias.QueryError() ) ||
                     (err = ossidAlias.QueryError())||
                     (err = SAMAlias.GetComment( &nlsComment ) ))
                {
                    DBGEOL( "AddAliases - Error " << (ULONG) err <<
                            "constructing sam alias or getting the comment" ) ;
                    break ;
                }

                if ( err = BuildAndAddLBI( nlsAccountName,
                                           NULL,
                                           nlsAccountName,
                                           nlsComment,
                                           pszQualifyingDomain,
                                           ossidAlias.QueryPSID(),
                                           UI_SID_Invalid,
                                           SidTypeAlias,
                                           0 ))
                {
                    break ;
                }
            }
        } while ( (err == NERR_Success) && fMoreData && !(*pfQuitEnum) ) ;

    } while (FALSE) ; // error breakout loop

    return err ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::AddGroups

    SYNOPSIS:   Adds the groups from pAdminAuthority to the list

    ENTRY:      pAdminAuthority - The domain to add the users from

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   07-Apr-1992     Implemented

********************************************************************/

APIERR USER_BROWSER_LBI_CACHE::AddGroups( ADMIN_AUTHORITY * pAdminAuthority,
                                          const TCHAR * pszQualifyingDomain,
                                          BOOL * pfQuitEnum )
{
    ASSERT( pfQuitEnum != NULL );
    TRACEEOL("\tUSER_BROWSER_LBI_CACHE::AddGroups Entered @ " << ::GetTickCount()/100) ;
    APIERR err     = NERR_Success ;
    APIERR errEnum = NERR_Success ;
    if ( *pfQuitEnum )
        return err ;

    SAM_DOMAIN * pSAMDomain = pAdminAuthority->QueryAccountDomain() ;

    do { // error breakout

        /* Try to use SamQDI(DOMAIN_DISPLAY_GROUP).  This will work
         * only if the target is Daytona or better.
         */
        {
            USRLB_NT_GROUP_ENUM ntgenum( pSAMDomain );
            if (   (err = ntgenum.QueryError()) == NERR_Success
                && (err = ntgenum.GetInfo()) == NERR_Success
               )
            {
                // do not create iter until after GetInfo
                NT_GROUP_ENUM_ITER ntgeiter( ntgenum );
                NLS_STR nlsAccountName;
                NLS_STR nlsComment;
                if (   (err = ntgeiter.QueryError()) != NERR_Success
                    || (err = nlsAccountName.QueryError()) != NERR_Success
                    || (err = nlsComment.QueryError()) != NERR_Success
                   )
                {
                    DBGEOL( "AddGroups: error creating iterator " << err );
                    break;
                }

                const NT_GROUP_ENUM_OBJ * pntgeobj = NULL;
                while( ( pntgeobj = ntgeiter(&err, FALSE)) != NULL )
                {
                    ASSERT( err != ERROR_MORE_DATA );

                    if ( *pfQuitEnum )
                        break ;

                    OS_SID ossidGroup( pSAMDomain->QueryPSID(),
                                       (ULONG)pntgeobj->QueryRID() ) ;
                    if (   (err = ossidGroup.QueryError()) != NERR_Success
                        || (err = pntgeobj->QueryGroup( &nlsAccountName ))
                                        != NERR_Success
                        || (err = pntgeobj->QueryComment( &nlsComment ))
                                        != NERR_Success
                        || (err = BuildAndAddLBI( nlsAccountName,
                                                  NULL,
                                                  nlsAccountName,
                                                  nlsComment,
                                                  pszQualifyingDomain,
                                                  ossidGroup.QueryPSID(),
                                                  UI_SID_Invalid,
                                                  SidTypeGroup,
                                                  0 )) != NERR_Success )
                    {
                        DBGEOL( "AddGroups: error in BuildAndAddLBI " << err );
                        break;
                    }
                }

                if ( err != NERR_Success )
                {
                    DBGEOL( "AddGroups: error in SamQDI enum " << err );
                }

                break; // we don't want to mix SamQDI and EnumerateGroups results
            }

            if (err == ERROR_NOT_SUPPORTED || err == ERROR_INVALID_PARAMETER)
            {
                TRACEEOL( "AddGroups: SamQDI not supported" );
            }
            else
            {
                if (err != NERR_Success)
                {
                    DBGEOL( "AddGroups: Error " << err << "in SamQDI" ) ;
                }
                break;
            }
        }

        if ( *pfQuitEnum )
            break ;


        SAM_ENUMERATE_HANDLE    hSAMEnum = 0 ;
        SAM_RID_ENUMERATION_MEM SAMRidEnumMem ;
        NLS_STR                 nlsAccountName ;
        NLS_STR                 nlsComment ;

        if ( (err = SAMRidEnumMem.QueryError()) ||
             (err = nlsAccountName.QueryError())||
             (err = nlsComment.QueryError())      )
        {
            break ;
        }

        /* set the initial read count */
        ULONG ulBytesRequested = USRBROWS_GROUPS_INITIAL_COUNT;

        /* Loop through each Group and add it to the listbox
         */
        do {
            if ( *pfQuitEnum )
                break ;

            /* make API call and time how long it takes */
            DWORD start = ::GetTickCount();
            errEnum = pSAMDomain->EnumerateGroups( &SAMRidEnumMem,
                                                   &hSAMEnum,
                                                   ulBytesRequested ) ;
            DWORD finish = ::GetTickCount();

            TRACEEOL( "AddGroups: first " << ulBytesRequested << " read in " << (finish-start) );

            /* adjust ulBytesRequested according to how long the last call took */
            if ( finish - start < USRBROWS_GROUPS_READ_MORE_MSEC )
            {
                ulBytesRequested *= 2;
                if ( ulBytesRequested > USRBROWS_GROUPS_MAX_COUNT )
                    ulBytesRequested = USRBROWS_GROUPS_MAX_COUNT;
            }
            else if ( finish - start > USRBROWS_GROUPS_READ_LESS_MSEC )
            {
                ulBytesRequested /= 2;
                if ( ulBytesRequested < USRBROWS_GROUPS_MIN_COUNT )
                    ulBytesRequested = USRBROWS_GROUPS_MIN_COUNT;

            }

            if ( errEnum != NERR_Success &&
                 errEnum != ERROR_MORE_DATA )
            {
                err = errEnum ;
                DBGEOL( "AddGroups: Error " << (ULONG) err <<
                        "Enumerating Groups" ) ;
                break ;
            }

            for ( ULONG i = 0 ; i < SAMRidEnumMem.QueryCount() ; i++ )
            {
                if ( *pfQuitEnum )
                    break ;

                ULONG ulRid = SAMRidEnumMem.QueryRID( i ) ;
                if ( (err = SAMRidEnumMem.QueryName( i, &nlsAccountName )))
                {
                    break ;
                }

                //
                // We also need to get the comment for this Group
                //
                SAM_GROUP SAMGroup( *pSAMDomain,
                                    ulRid,
                                    GROUP_READ_INFORMATION ) ;

                OS_SID ossidGroup( pSAMDomain->QueryPSID(), ulRid ) ;
                if ( (err = SAMGroup.QueryError() ) ||
                     (err = ossidGroup.QueryError())||
                     (err = SAMGroup.GetComment( &nlsComment ) ))
                {
                    DBGEOL( "AddGroups - Error " << (ULONG) err <<
                            "constructing sam Group or getting the comment" ) ;
                    break ;
                }

                if ( err = BuildAndAddLBI( nlsAccountName,
                                           NULL,
                                           nlsAccountName,
                                           nlsComment,
                                           pszQualifyingDomain,
                                           ossidGroup.QueryPSID(),
                                           UI_SID_Invalid,
                                           SidTypeGroup,
                                           0 ))
                {
                    break ;
                }
            }
        } while ( errEnum == ERROR_MORE_DATA ) ;

    } while (FALSE) ; // error breakout loop

    TRACEEOL("\tUSER_BROWSER_LBI_CACHE::AddGroups Leave    @ " << ::GetTickCount()/100) ;
    return err ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::AddWellKnownSids

    SYNOPSIS:   This method adds all of requested the well known SIDs supported
                by the user browser to the listbox

    ENTRY:      pAdminAuthority - Pointer to a admin authority that should be
                    used for the name translation.
                ulFlags - Bitfield passed to the user browser constructor

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The domain name will be the empty string for the added
                LBIs.

    HISTORY:
        Johnl   25-Mar-1992     Implemented

********************************************************************/

#define MAX_SIDS 6

APIERR USER_BROWSER_LBI_CACHE::AddWellKnownSids( ADMIN_AUTHORITY  * pAdminAuthority,
                                                 ULONG              ulFlags,
                                                 BOOL *             pfQuitEnum )
{
    ASSERT( pfQuitEnum != NULL );
    APIERR err = NERR_Success ;
    UI_SystemSid aSysSids[MAX_SIDS] ;
    MSGID        amsgidSysSids[MAX_SIDS] ;
    INT          cSids = -1 ;

    if ( ulFlags & USRBROWS_INCL_EVERYONE )
    {
        cSids++ ;
        aSysSids[cSids] = UI_SID_World ;
        amsgidSysSids[cSids] = IDS_USRBROWS_EVERYONE_SID_COMMENT ;
    }

    if ( ulFlags & USRBROWS_INCL_REMOTE_USERS )
    {
        cSids++ ;
        aSysSids[cSids] = UI_SID_Network ;
        amsgidSysSids[cSids] = IDS_USRBROWS_REMOTE_SID_COMMENT ;
    }

    if ( ulFlags & USRBROWS_INCL_INTERACTIVE )
    {
        cSids++ ;
        aSysSids[cSids] = UI_SID_Interactive ;
        amsgidSysSids[cSids] = IDS_USRBROWS_INTERACTIVE_SID_COMMENT ;
    }

    if ( ulFlags & USRBROWS_INCL_CREATOR )
    {
        cSids++ ;
        aSysSids[cSids] = UI_SID_CreatorOwner ;
        amsgidSysSids[cSids] = IDS_USRBROWS_CREATOR_SID_COMMENT ;
    }

    if ( ulFlags & USRBROWS_INCL_SYSTEM )
    {
        cSids++ ;
        aSysSids[cSids] = UI_SID_System ;
        amsgidSysSids[cSids] = IDS_USRBROWS_SYSTEM_SID_COMMENT ;
    }

    if ( ulFlags & USRBROWS_INCL_RESTRICTED )
    {
        cSids++ ;
        aSysSids[cSids] = UI_SID_Restricted ;
        amsgidSysSids[cSids] = IDS_USRBROWS_RESTRICTED_SID_COMMENT ;
    }

    if ( cSids < 0 )
    {
        return err ;
    }

    /* Convert from array index to count
     */
    cSids++ ;
    UIASSERT( cSids <= MAX_SIDS ) ;

    do { // error breakout

        PSID   apsid[MAX_SIDS] ;

        /* I know this is kinda hokey.  I wanted to do OS_SID aossid[MAX_SIDS]
         * but it is not implemented in CFRONT (array with default arguments).
         * One alternative is to give OS_SID a no argument constructor.
         */
        OS_SID * aossidWellKnown[MAX_SIDS] ;
        OS_SID OS_SID0, OS_SID1, OS_SID2, OS_SID3, OS_SID4, OS_SID5 ;
        aossidWellKnown[0] = &OS_SID0 ;
        aossidWellKnown[1] = &OS_SID1 ;
        aossidWellKnown[2] = &OS_SID2 ;
        aossidWellKnown[3] = &OS_SID3 ;
        aossidWellKnown[4] = &OS_SID4 ;
        aossidWellKnown[5] = &OS_SID5 ;

        /* Build the array of PSIDs suitable for passing to LSATranslateSidsToNames
         */
        for ( INT i = 0 ; i < cSids  ; i++ )
        {
            if ((err = aossidWellKnown[i]->QueryError()) ||
                (err = NT_ACCOUNTS_UTILITY::QuerySystemSid(aSysSids[i],
                                                        aossidWellKnown[i])))

            {
                break ;
            }

            apsid[i] = aossidWellKnown[i]->QueryPSID() ;
        }

        if ( err || *pfQuitEnum )
            break ;

        /* Do the name translation
         */
        LSA_TRANSLATED_NAME_MEM LSATransNameMem ;
        LSA_REF_DOMAIN_MEM      LSARefDomainMem ;
        NLS_STR                 nlsAccountName ;
        NLS_STR                 nlsComment ;

        if ( (err = LSATransNameMem.QueryError() ) ||
             (err = LSARefDomainMem.QueryError())  ||
             (err = pAdminAuthority->QueryLSAPolicy()->TranslateSidsToNames(
                                                    apsid,
                                                    cSids,
                                                    &LSATransNameMem,
                                                    &LSARefDomainMem )) ||
             (err = nlsComment.QueryError())                            ||
             (err = nlsAccountName.QueryError())                          )
        {
            DBGEOL("NT_ACL_TO_PERM_CONVERTER::SidsToNames - Error translating names or constructing LSA_POLICY") ;
            break ;
        }

        /* Add the new Well Known SID LBIs to the listbox
         */
        for ( i = 0 ; i < cSids ; i++ )
        {
            //
            // JonN 3/16/99 replaced bad assertion, this could happen if
            //   the target machine is downlevel
            //
            if ( LSATransNameMem.QueryUse(i) != SidTypeWellKnownGroup )
                continue;

            if ( (err = LSATransNameMem.QueryName( i, &nlsAccountName)) ||
                 (err = nlsComment.Load( amsgidSysSids[i] )) ||
                 (err = BuildAndAddLBI(  nlsAccountName,
                                         NULL,
                                         nlsAccountName,
                                         nlsComment,
                                         NULL,
                                         aossidWellKnown[i]->QueryPSID(),
                                         aSysSids[i],
                                         LSATransNameMem.QueryUse(i),
                                         0 )) )
            {
                break ;
            }
        }

    } while (FALSE) ;

    return err ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::BuildAndAddLBI

    SYNOPSIS:   Adds an item to the user browser listbox

    ENTRY:      pszAccountName - Account for the LSA (or NULL if Well Known)
                pszFullName    - Full name for users (can be NULL)
                pszDisplayName - Display name to show the user
                pszComment - Comment for this account
                UISysSid         - If this is a well known SID, then this
                                   member contains the UI_SID_* value we
                                   can use to get the SID, else it will
                                   contain UI_SID_Invalid which means we
                                   should use the display name for the account
                                   name.
                SidType    - The type of account we are adding
                nFlags     - User account flags

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      Must be MT safe!

    HISTORY:
        Johnl   25-Mar-1992     Created

********************************************************************/

APIERR USER_BROWSER_LBI_CACHE::BuildAndAddLBI(
                                        const TCHAR     * pszAccountName,
                                        const TCHAR     * pszFullName,
                                        const TCHAR     * pszDisplayName,
                                        const TCHAR     * pszComment,
                                        const TCHAR     * pszDomain,
                                        const PSID        psidAccount,
                                        enum UI_SystemSid UISysSid,
                                        SID_NAME_USE      SidType,
                                        ULONG             nFlags )
{
    APIERR err ;

    //
    //  This method can only be used for adding non-users (users are added
    //  through the AddUsers method).
    //
    UIASSERT( SidType != SidTypeUser ) ;

    err = ERROR_NOT_ENOUGH_MEMORY ;
    USER_BROWSER_LBI * plbi = new USER_BROWSER_LBI( pszAccountName,
                                                    pszFullName,
                                                    pszDisplayName,
                                                    pszComment,
                                                    pszDomain,
                                                    psidAccount,
                                                    UISysSid,
                                                    SidType,
                                                    nFlags ) ;

    if (  plbi == NULL ||
         (err = plbi->QueryError()) )
    {
        delete plbi ;
        return err ;
    }

    if ( AddItem( plbi ) < 0 )
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
    }

    return err ;
}

PQSORT_COMPARE USER_BROWSER_LBI_CACHE::QueryCompareMethod( VOID ) const
{
    return (PQSORT_COMPARE) USER_BROWSER_LBI_CACHE::CompareCacheLBIs ;
}


//
//  PUSER_BROWSER_LBI compare funcion used in qsort
//
int __cdecl USER_BROWSER_LBI_CACHE::CompareCacheLBIs(
			   const ULC_ENTRY_BASE * pulc1,
			   const ULC_ENTRY_BASE * pulc2 )
{
    UIASSERT( pulc1 != NULL ) ;
    UIASSERT( pulc2 != NULL ) ;

    //
    //	If pulc1 is not a user and pulc2 is...
    //
    if ( pulc1->pddu == NULL &&
	 pulc2->pddu != NULL   )
    {
	return -1 ;
    }

    //
    //	If pulc1 is a user and pulc2 is not...
    //
    if ( pulc1->pddu != NULL &&
	 pulc2->pddu == NULL   )
    {
	return 1 ;
    }


    PUNICODE_STRING puni1, puni2 ;
    UNICODE_STRING uni1, uni2 ;

    if ( pulc1->pddu  != NULL )
    {
	puni1 = &pulc1->pddu->LogonName ;
    }
    else
    {
	//
	//  Dummy up the logon name from the LBI
	//
	RtlInitUnicodeString( &uni1,
	      ((USER_BROWSER_LBI*)pulc1->plbi)->QueryDisplayName()) ;
	puni1 = &uni1 ;
    }

    if ( pulc2->pddu  != NULL )
    {
	puni2 = &pulc2->pddu->LogonName ;
    }
    else
    {
	//
	//  Dummy up the logon name from the LBI
	//
	RtlInitUnicodeString( &uni2,
	      ((USER_BROWSER_LBI*)pulc2->plbi)->QueryDisplayName()) ;
	puni2 = &uni2 ;
    }


    return USER_BROWSER_LBI_CACHE::CmpUniStrs( puni1, puni2 ) ;
}


/*******************************************************************

    NAME:       USER_BROWSER_LBI::USER_BROWSER_LBI

    SYNOPSIS:   Typical LBI Constructor destructor

    ENTRY:      pszAccountName - Name suitable for passing to the LSA if
                                 this is not a well known sid (can be NULL)
                pszFullName    - Full name (can be NULL)
                pszSubjectName - Name of this Alias/Group/User
                pszComment - Comment for this Alias/Group/User
                UISysSid   - For well known SIDs we use this value to
                             get the SID, otherwise we use the _nlsAccountName
                             member.
                SidType - Is this an Alias/Group/User
                nFlags  - User Account flags ( Sid type must be user if
                          this field is non-zero)

    NOTES:

    HISTORY:
        Johnl   03-Mar-1992     Created

********************************************************************/

USER_BROWSER_LBI::USER_BROWSER_LBI( const TCHAR     * pszAccountName,
                                          const TCHAR     * pszFullName,
                                          const TCHAR     * pszSubjectName,
                                          const TCHAR     * pszComment,
                                          const TCHAR     * pszDomain,
                                          const PSID        psidAccount,
                                          enum UI_SystemSid UISysSid,
                                          SID_NAME_USE      SidType,
                                          ULONG             nFlags )

    : _nlsAccountName( pszAccountName ),
      _nlsFullName   ( pszFullName    ),
      _nlsDisplayName( pszSubjectName ),
      _nlsComment    ( pszComment     ),
      _nlsDomain     ( pszDomain      ),
      _ossid         ( psidAccount, TRUE ),
      _UISysSid      ( UISysSid ),
      _SidType       ( SidType ),
      _nFlags        ( nFlags )
{
    if ( QueryError() )
        return ;

    /* The flags field must be zero if this is not a user
     */
    UIASSERT( (SidType == SidTypeUser) ||
              (SidType != SidTypeUser  && nFlags == 0)) ;

    APIERR err ;
    if ( (err = _nlsFullName.QueryError()) ||
         (err = _nlsAccountName.QueryError()) ||
         (err = _nlsDisplayName.QueryError()) ||
         (err = _nlsComment.QueryError())     ||
         (err = _nlsDomain.QueryError())      ||
         (err = _ossid.QueryError()) )
    {
        ReportError( err ) ;
        return ;
    }
}

USER_BROWSER_LBI::~USER_BROWSER_LBI()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI::QualifyDisplayName

    SYNOPSIS:   Forces explicit qualification of the display name

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   27-Oct-1992     Created

********************************************************************/

APIERR USER_BROWSER_LBI::QualifyDisplayName( void )
{
    return NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                                &_nlsDisplayName,
                                                _nlsAccountName,
                                                _nlsDomain,
                                                NULL,
                                                NULL,
                                                QueryType() ) ;
}



/*******************************************************************

    NAME:       USER_BROWSER_LBI::Paint

    SYNOPSIS:   Typical LBI Paint method

    NOTES:

    HISTORY:
        Johnl   03-Mar-1992     Created
        beng    21-Apr-1992     LBI::Paint interface change

********************************************************************/

VOID USER_BROWSER_LBI::Paint(
                    LISTBOX * plb,
                    HDC hdc,
                    const RECT * prect,
                    GUILTT_INFO * pGUILTT ) const
{
    STR_DTE strdteName( _nlsDisplayName ) ;
    STR_DTE strdteComment( _nlsComment ) ;
    DM_DTE  dmdteIcon( ((USER_BROWSER_LB*)plb)->QueryDisplayMap( this ) ) ;

    DISPLAY_TABLE dt( 3, ((USER_BROWSER_LB*)plb)->QueryColWidthArray()) ;
    dt[0] = &dmdteIcon ;
    dt[1] = &strdteName ;
    dt[2] = &strdteComment ;

    dt.Paint( plb, hdc, prect, pGUILTT ) ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI::Compare

    SYNOPSIS:   Typical LBI compare for user browser listbox

    NOTES:      This method will sort all user sid types to the end of
                the list

    HISTORY:
        Johnl   03-Mar-1992     Created

********************************************************************/

INT USER_BROWSER_LBI::Compare( const LBI * plbi ) const
{
    return CompareAux( plbi ) ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI::CompareAux

    SYNOPSIS:   Allows calling by ComparepLBIs (which must be _CRTAPI) and
                the normal compare method

    NOTES:

    HISTORY:
        Johnl   08-Dec-1992     Created

********************************************************************/

INT USER_BROWSER_LBI::CompareAux( const LBI * plbi ) const
{
    USER_BROWSER_LBI * pubrowLBI = (USER_BROWSER_LBI*) plbi ;

    if ( (QueryType() != SidTypeUser) &&
         (pubrowLBI->QueryType() == SidTypeUser ))
    {
        return -1 ;
    }

    if ( (QueryType() == SidTypeUser) &&
         (pubrowLBI->QueryType() != SidTypeUser ))
    {
        return 1 ;
    }

    return _nlsDisplayName._stricmp( pubrowLBI->_nlsDisplayName ) ;
}

    //
    //  PUSER_BROWSER_LBI compare funcion used in qsort
    //
    int __cdecl ComparepLBIs( const PUSER_BROWSER_LBI * pplbi1,
                               const PUSER_BROWSER_LBI * pplbi2 )
    {
        return (*pplbi1)->CompareAux( *pplbi2 ) ;
    }

/*******************************************************************

    NAME:       USER_BROWSER_LBI::QueryLeadingChar

    SYNOPSIS:   Typical QueryLeadingChar method

    HISTORY:
        Johnl   03-Mar-1992     Created

********************************************************************/

WCHAR USER_BROWSER_LBI::QueryLeadingChar( void ) const
{
    ISTR istr( _nlsDisplayName ) ;
    return _nlsDisplayName.QueryChar( istr ) ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI::Compare_HAWforHawaii

    SYNOPSIS:   Compare to prefix for HAW-for-Hawaii

    HISTORY:
        JonN    11-Aug-1992     HAW-for-Hawaii

********************************************************************/

INT USER_BROWSER_LBI::Compare_HAWforHawaii( const NLS_STR & nls ) const
{
//    TRACEEOL(  "User Browser: Compare_HAWforHawaii(): \""
//             << nls
//             << "\", \""
//             << _nlsDisplayName.QueryPch()
//             << "\", "
//             << nls.QueryTextLength() );
    ISTR istr( nls ) ;
    istr += nls.QueryTextLength();
    return nls._strnicmp( _nlsDisplayName, istr ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\usrcache.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    usrcache.cxx

    This file contains the class definitions for the abstract
    USER_LBI_CACHE class.  This class implements a cache of LBIs
    used when dealing with very large user databases.  This class's
    primary purpose is to be the "backing store" for a LAZY_LISTBOX.
    As such, its interface is very similar to the BLT_LISTBOX
    interface.


    FILE HISTORY:
        KeithMo     15-Dec-1992     Created.
*/

#include "pchapplb.hxx"   // Precompiled header

//
//  This is the maximum number of bytes we'll make for
//  any given API invocation.
//

#define MAX_BYTES_PER_REQUEST   0x0001FFFFL


//
// The following defines are used in the slow mode timing heuristics in
// ReadUsers.  A timer determines how long it takes
// to read in each batch of user accounts.  If this time is less
// that READ_MORE_MSEC, we double the number of bytes requested on the
// next call.  If it is more than READ_LESS_MSEC, we halve it.
//

#define USERS_INITIAL_COUNT    0x00200 /*  512 */
#define USERS_MIN_COUNT        0x00020 /*   32 */
#define USERS_MAX_COUNT        0x01000 /* 4K   */

#define BYTES_INITIAL_COUNT    0x03FFF /*  16K */
#define BYTES_MIN_COUNT        0x003FF /*   1K */
#define BYTES_MAX_COUNT        0x1FFFF /* 128K */

#define READ_MORE_MSEC         1000
#define READ_LESS_MSEC         5000

//
//  min/max macros.
//

#ifndef max
#define max(a,b) (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b) (((a) < (b)) ? (a) : (b))
#endif


//
//  ULC_API_BUFFER methods.
//

/*******************************************************************

    NAME:       ULC_API_BUFFER :: ULC_API_BUFFER

    SYNOPSIS:   ULC_API_BUFFER class constructor.

    ENTRY:      pddu                    - The API buffer returned from
                                          SamQueryDisplayInformation.

                cItems                  - Number of items in the buffer.

    EXIT:       The object has been constructed.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
ULC_API_BUFFER :: ULC_API_BUFFER( DOMAIN_DISPLAY_USER * pddu,
                                  ULONG                 cItems )
  : _pddu( pddu ),
    _cItems( cItems )
{
    UIASSERT( cItems > 0 );
    UIASSERT( pddu != NULL );

    //
    //  This space intentionally left blank.
    //

}   // ULC_API_BUFFER :: ULC_API_BUFFER

/*******************************************************************

    NAME:       ULC_API_BUFFER :: ~ULC_API_BUFFER

    SYNOPSIS:   ULC_API_BUFFER class destructor.

    EXIT:       The object has been destroyed.  The SAM buffer
                associated with this object has been freed.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
ULC_API_BUFFER :: ~ULC_API_BUFFER( VOID )
{
    //
    //  Free the associated SAM buffer.
    //

    if( _pddu != NULL )
    {
        ::SamFreeMemory( (PVOID)_pddu );
    }

    _pddu   = NULL;
    _cItems = 0;

}   // ULC_API_BUFFER :: ~ULC_API_BUFFER

DEFINE_SLIST_OF( ULC_API_BUFFER );



//
//  USER_LBI_CACHE methods.
//

/*******************************************************************

    NAME:       USER_LBI_CACHE :: USER_LBI_CACHE

    SYNOPSIS:   USER_LBI_CACHE class constructor.

    ENTRY:      padminauth              - Points to an ADMIN_AUTHORITY
                                          that represents the target
                                          machine.  This should be NULL
                                          for downlevel machines.

                nInitialGrowthSpace     - Percentage of initial "slop"
                                          entries in the cache.  Used to
                                          plan for future cache growth.

                cUsersPerRequest        - The number of users to request
                                          per SAM API invocation.

                fIncludeRemoteUsers     - If TRUE, then remote users will
                                          be included in the cache.

    EXIT:       The object has been constructed.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
USER_LBI_CACHE :: USER_LBI_CACHE( INT cbExtraBytes )
  : BASE(),
    _pCache( NULL ),
    _slBuffers(),
    _cSlots( 0 ),
    _cEntries( 0 ),
    _cbExtraBytes( cbExtraBytes )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    // Round _cbExtraBytes up to the nearest multiple of sizeof(DWORD)
    //
    // JonN 10/16/00 IA64: should be sizeof(PVOID)
    //

    if ( (_cbExtraBytes % sizeof(PVOID)) != 0 )
    {
        _cbExtraBytes += sizeof(PVOID) - ( _cbExtraBytes % sizeof(PVOID) );

        TRACEEOL(   "USER_LBI_CACHE::USER_LBI_CACHE: rounded _cbExtraBytes to "
                 << _cbExtraBytes );
    }

}   // USER_LBI_CACHE :: USER_LBI_CACHE

/*******************************************************************

    NAME:       USER_LBI_CACHE :: ~USER_LBI_CACHE

    SYNOPSIS:   USER_LBI_CACHE class destructor.

    EXIT:       The object has been destroyed.

    NOTES:      This is a virtual method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
USER_LBI_CACHE :: ~USER_LBI_CACHE( VOID )
{
    //
    //  Safety first!
    //

    LockCache();

    //
    //  Destroy any LBIs in the cache.
    //

    if( _cSlots > 0 )
    {
        //
        //  _cSlots should only be > 0 if there was *ever*
        //  anything in the cache.  Ergo, _pCache *must*
        //  be non-NULL.
        //

        UIASSERT( _pCache != NULL );

        //
        //  Scan the cache, deleting the LBIs.
        //

        while( _cSlots > 0 )
        {
            ULC_ENTRY * pTmp = QueryULCEntryPtr( _cSlots-1 );
            delete pTmp->plbi;
            pTmp->plbi = NULL;
            _cSlots--;
        }
    }

    //
    //  Delete the cache itself.
    //

    delete _pCache;
    _pCache   = NULL;
    _cEntries = 0;

    //
    //  _slBuffers' destructor will take care of
    //  freeing the associated SAM buffers.
    //

    UnlockCache();

}   // USER_LBI_CACHE :: ~USER_LBI_CACHE

/*******************************************************************

    NAME:       USER_LBI_CACHE :: AddItem

    SYNOPSIS:   Add a new LBI to the cache.  A binary search of the
                cache will be performed to determine the appropriate
                location for the new LBI.

    ENTRY:      plbi                    - The new LBI to add to the
                                          cache.

    EXIT:       If successful, then the new LBI has been added to
                the cache in sorted order.

    RETURNS:    INT                     - ULC_ERR if an error occurred
                                          while adding the item.
                                          Otherwise, returns the index
                                          for the new item.

    NOTES:      This is a virtual method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
INT USER_LBI_CACHE :: AddItem( LBI * plbi )
{
    //
    //  Refuse to add badly constructed LBIs to the cache.
    //

    if( plbi == NULL )
    {
        return ULC_ERR;
    }

    if( plbi->QueryError() != NERR_Success )
    {
        delete plbi;
        return ULC_ERR;
    }

    //
    //  Lock the cache before proceeding.
    //

    LockCache();

    //
    //  If we need to grow the cache array, do it now as this
    //  is the only operation we'll do that may actually fail.
    //

    if( _cEntries == _cSlots )
    {
        if( !W_GrowCache( _cSlots + ULC_CACHE_GROWTH_DELTA ) )
        {
            //
            //  Bad news, we failed to grow the cache.
            //  Delete the item since we failed to add it
            //  to the cache.
            //

            delete plbi;
            UnlockCache();

            return ULC_ERR;
        }
    }

    //
    //  Now that we've got some breathing room, find the
    //  proper location for the new LBI.
    //

    INT iNew = BinarySearch( plbi );
    UIASSERT( iNew >= 0 );

    //
    //  Make a hole in the cache to stick the new LBI.
    //

    ULC_ENTRY * pTmp = QueryULCEntryPtr( iNew );

    if( iNew < _cEntries )
    {
        ::memmove( (void *)QueryULCEntryPtr( iNew + 1 ),
                   pTmp,
                   ( _cEntries - iNew ) * QueryULCEntrySize() );
    }

    _cEntries++;

    //
    //  Initialize the newly formed cache entry.
    //

    pTmp->plbi = plbi;
    pTmp->pddu = NULL;
    if ( _cbExtraBytes > 0 )
    {
        ::memset( (void *)&(pTmp->bExtraBytes),
                   0,
                   _cbExtraBytes );
    }

    //
    //  Unlock the cache before returning.
    //

    UnlockCache();

    return iNew;

}   // USER_LBI_CACHE :: AddItem

/*******************************************************************

    NAME:       USER_LBI_CACHE :: RemoveItem

    SYNOPSIS:   Removes an item from the cache, but does not delete
                the corresponding LBI.

    ENTRY:      i                       - Zero-based index of the
                                          item to remove.

    EXIT:       If successful, then the LBI has been removed from
                the cache.

    RETURNS:    LBI *                   - Points to the LBI removed
                                          from the cache.  Will be
                                          NULL if an error occurred.

    NOTES:      This is a virtual method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
LBI * USER_LBI_CACHE :: RemoveItem( INT i )
{
    //
    //  Safety first!
    //

    LockCache();

    //
    //  Only access the cache if the index is within range.
    //

    if( ( i < 0 ) || ( i >= _cEntries ) )
    {
        //
        //  Requested item is out of range.
        //

        UnlockCache();

        return NULL;
    }

    //
    //  Retrieve the LBI.  This may cause the creation of
    //  a new LBI.
    //

    LBI * plbi = W_GetLBI( i );

    //
    //  Now remove the LBI from the cache, adjusting the
    //  cache entries as necessary.
    //

    _cEntries--;

    if( ( _cEntries > 0 ) && ( i < _cEntries ) )
    {
        ::memmove( (void *)QueryULCEntryPtr( i ),
                   (void *)QueryULCEntryPtr( i + 1 ),
                   ( _cEntries - i ) * QueryULCEntrySize() );
    }

    //
    //  Clear the unused entry.
    //

    QueryULCEntryPtr( _cEntries )->pddu = NULL;
    QueryULCEntryPtr( _cEntries )->plbi = NULL;

    //
    //  Unlock the cache before returning.
    //

    UnlockCache();

    return plbi;

}   // USER_LBI_CACHE :: RemoveItem

/*******************************************************************

    NAME:       USER_LBI_CACHE :: QueryItem

    SYNOPSIS:   Query the LBI at the specified index.

    ENTRY:      i                       - Zero-based index of the
                                          item to query.

    EXIT:       If successful, then the specified cache entry will
                contain a valid LBI.  This may be a newly created
                LBI retrieved by calling the CreateLBI virtual.

    RETURNS:    LBI *                   - Points to the LBI found at
                                          the specified location.  Will
                                          be NULL if an error occurred.

    NOTES:      This is a virtual method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
LBI * USER_LBI_CACHE :: QueryItem( INT i )
{
    //
    //  Safety first!
    //

    LockCache();

    //
    //  Retrieve the LBI.  This may cause the creation of
    //  a new LBI.
    //

    LBI * plbi = W_GetLBI( i );

    UnlockCache();

    return plbi;

}   // USER_LBI_CACHE :: QueryItem

/*******************************************************************

    NAME:       USER_LBI_CACHE :: IsItemAvailable

    SYNOPSIS:   Determine if the necessary data is available for
                a specific item.

    ENTRY:      i                       - Zero-based index of the
                                          item to query.

    RETURNS:    BOOL                    - TRUE if the necessary data
                                          for the item is available,
                                          FALSE otherwise.  Note that
                                          TRUE does *not* necessarily
                                          mean that an associated LBI
                                          has been created.

    NOTES:      This is a virtual method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
BOOL USER_LBI_CACHE :: IsItemAvailable( INT i )
{
    //
    //  Safety first!
    //

    LockCache();

    BOOL fResult = FALSE;

    //
    //  Only access the cache if the index is within range.
    //

    if( ( i >= 0 ) && ( i < _cEntries ) )
    {
        //
        //  Find the cache entry.
        //

        ULC_ENTRY * pTmp = QueryULCEntryPtr( i );

        if( ( pTmp->plbi != NULL ) || ( pTmp->pddu != NULL ) )
        {
            fResult = TRUE;
        }
    }

    UnlockCache();

    return fResult;

}   // USER_LBI_CACHE :: IsItemAvailable

/*******************************************************************

    NAME:       USER_LBI_CACHE :: Sort

    SYNOPSIS:   Sorts the cache entries.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
VOID USER_LBI_CACHE :: Sort( VOID )
{

TRACETIMESTART;

    //
    //  Safety first!
    //

    LockCache();

    //
    //  We only need to sort if there's something in the cache.
    //

    if( _cEntries > 0 )
    {
        UIASSERT( _pCache != NULL );

        //
        //  Retrieve the appropriate compare method.
        //

        PQSORT_COMPARE pfnCmp = QueryCompareMethod();
        UIASSERT( pfnCmp != NULL );

        //
        //  Before using qsort to sort the cache, check if it is already
        //  sorted.
        //

TRACETIMESTART2( presort );
        BOOL fSorted = TRUE;
        for (INT i = 1; i < _cEntries; i++)
        {
            if ( (pfnCmp)(QueryULCEntryPtr(i-1), QueryULCEntryPtr(i)) > 0 )
            {
                fSorted = FALSE;
#if defined(DEBUG) && defined(TRACE)
                TRACEOUT(   "    failed comparison " << i-1 << " : compare( \"" );
                {
                    INT cch = QueryULCEntryPtr(i-1)->pddu->LogonName.Length / sizeof(WCHAR);
                    const WCHAR * pch = QueryULCEntryPtr(i-1)->pddu->LogonName.Buffer;
                    INT iChar = 0;
                    while (iChar < cch) { cdebug << pch[iChar++]; }
                    TRACEOUT( "\", \"" );
                    cch = QueryULCEntryPtr(i)->pddu->LogonName.Length / sizeof(WCHAR);
                    pch = QueryULCEntryPtr(i)->pddu->LogonName.Buffer;
                    iChar = 0;
                    while (iChar < cch) { cdebug << pch[iChar++]; }
                }
                TRACEEOL( "\" ) > 0" );
#endif
                break;
            }
        }
TRACETIMEEND2( presort, "USER_LBI_CACHE::Sort: presort " << ( (fSorted) ? "confirmed" : "denied" ) << " in " );


        //
        //  Sort the cache if it needs to be sorted.
        //

        if ( !fSorted )
        {
TRACETIMESTART2( sort );
            ::qsort( (void *)_pCache,
                     (size_t)_cEntries,
                     QueryULCEntrySize(),
                     pfnCmp );
TRACETIMEEND2( sort, "USER_LBI_CACHE::Sort: sort took " );
        }
    }

    UnlockCache();

TRACETIMEEND( "USER_LBI_CACHE::Sort: total time " );

}   // USER_LBI_CACHE :: Sort

/*******************************************************************

    NAME:       USER_LBI_CACHE :: QueryCompareMethod

    SYNOPSIS:   Returns a pointer to a compare method suitable for
                use by the qsort() function.

    RETURNS:    PQSORT_COMPARE          - Points to a compare function
                                          usable by qsort().

    NOTES:      This is a virtual method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
PQSORT_COMPARE USER_LBI_CACHE :: QueryCompareMethod( VOID ) const
{
    //
    //  CompareLogonNames is the default compare method.
    //

    return (PQSORT_COMPARE)&USER_LBI_CACHE::CompareLogonNames;

}   // USER_LBI_CACHE :: QueryCompareMethod

/*******************************************************************

    NAME:       USER_LBI_CACHE :: LockCache

    SYNOPSIS:   Locks the cache.  This is basically just a hook
                so a subclass can provide multithread safety.

    NOTES:      This is a virtual method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
VOID USER_LBI_CACHE :: LockCache( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // USER_LBI_CACHE :: LockCache

/*******************************************************************

    NAME:       USER_LBI_CACHE :: UnlockCache

    SYNOPSIS:   Unlocks the cache.  This is basically just a hook
                so a subclass can provide multithread safety.

    NOTES:      This is a virtual method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
VOID USER_LBI_CACHE :: UnlockCache( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // USER_LBI_CACHE :: UnlockCache

/*******************************************************************

    NAME:       USER_LBI_CACHE :: CmpUniStrs

    SYNOPSIS:   Does a case insensitive comparison of two
                UNICODE_STRINGs.

    ENTRY:      punicode0               - The "left" string.

                punicode1               - The "right" string.

    RETURNS:    int                     - 0, <0, >0.

    NOTES:      This is a static method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
int USER_LBI_CACHE :: CmpUniStrs( const UNICODE_STRING * punicode0,
                                  const UNICODE_STRING * punicode1 )
{
    UIASSERT( punicode0 != NULL );
    UIASSERT( punicode1 != NULL );

    //
    //  Get the buffer pointers from the UNICODE_STRINGs.
    //

    const WCHAR * pwchLeft  = punicode0->Buffer;
    const WCHAR * pwchRight = punicode1->Buffer;

    //
    //  If either buffer pointer is NULL then we don't
    //  need to do the actual comparison.
    //

    if( pwchLeft == NULL )
    {
        return ( pwchRight == NULL ) ? 0        // both strings NULL
                                     : -1;      // right string !NULL
    }

    if( pwchRight == NULL )
    {
        return 1;                               // left string !NULL
    }

    //
    //  Get the string lengths from the UNICODE_STRINGs.
    //

    UINT cchLeft  = punicode0->Length / sizeof(WCHAR);
    UINT cchRight = punicode1->Length / sizeof(WCHAR);

    //
    //  Compare the strings.
    //

    int cmpres = NETUI_strnicmp2( pwchLeft, cchLeft,
                                  pwchRight, cchRight );

    return cmpres;

}   // USER_LBI_CACHE :: CmpUniStrs

/*******************************************************************

    NAME:       USER_LBI_CACHE :: CompareLogonNames

    SYNOPSIS:   Compares the LogonName fields of two
                DOMAIN_DISPLAY_USER structures.

    ENTRY:      p0                      - Points to the "left" structure.

                p1                      - Points to the "right" structure.

                p0 & p1 actually point to ULC_ENTRY structures.

    RETURNS:    int                     -  0 if *p0 == *p1
                                          >0 if *p0  > *p1
                                          <0 if *p0  < *p1

    NOTES:      This is a static method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
int __cdecl USER_LBI_CACHE :: CompareLogonNames( const void * p0,
                                                  const void * p1 )
{
    const ULC_ENTRY * pLeft  = (const ULC_ENTRY *)p0;
    const ULC_ENTRY * pRight = (const ULC_ENTRY *)p1;

    return USER_LBI_CACHE::CmpUniStrs( &pLeft->pddu->LogonName,
                                       &pRight->pddu->LogonName );

}   // USER_LBI_CACHE :: CompareLogonNames

/*******************************************************************

    NAME:       USER_LBI_CACHE :: ReadUsers

    SYNOPSIS:   Reads user data from SamQueryDisplayInformation,
                adds it to a list of API buffers, creates cache entries
                for the new items and appends the entries to the end
                of the cache.

    ENTRY:      padminauth              - Points to an ADMIN_AUTHORITY
                                          that represents the target
                                          machine.

                nInitialGrowthSpace     - Percentage of initial "slop"
                                          entries in the cache.  Used to
                                          plan for future cache growth.

                cUsersPerRequest        - The number of users to request
                                          per SAM API invocation.  0 for
                                          default.

                fIncludeRemoteUsers     - If TRUE, then remote users will
                                          be included in the cache.

    RETURNS:    APIERR                  - Any errors that occurred.

    NOTES:      The caller can specify the number of users requested
                per call, but ReadUsers set the number of bytes requested
                using an adaptive algorithm.  This should help improve
                responsiveness across a slow link.

    HISTORY:
        KeithMo     15-Dec-1992     Created.
        JonN        23-Mar-1993     Adaptive timing for slow connections

********************************************************************/
APIERR USER_LBI_CACHE :: ReadUsers( ADMIN_AUTHORITY * padminauth,
                                    UINT              nInitialGrowthSpace,
                                    UINT              cUsersPerRequest,
                                    BOOL              fIncludeRemoteUsers,
                                    BOOL *            pfQuitEnum )
{
    UIASSERT( padminauth != NULL );
    UIASSERT( padminauth->QueryError() == NERR_Success );
    UIASSERT( _slBuffers.QueryNumElem() == 0 );

    if ( pfQuitEnum != NULL && *pfQuitEnum )
        return NERR_Success;

    //
    //  Retrieve the domain handle.
    //

    SAM_HANDLE hSamDomain = padminauth->QueryAccountDomain()->QueryHandle();
    UIASSERT( hSamDomain != NULL );

    //
    //  The current user index.
    //

    ULONG iUser = 0;

    //
    //  We'll only add a given user to the cache if the
    //  boolean AND of the user's AccountControl field and
    //  this mask produces a zero result.
    //

    ULONG maskSelect = fIncludeRemoteUsers ? 0L
                                           : USER_TEMP_DUPLICATE_ACCOUNT;

    APIERR err = NERR_Success;

#if defined(DEBUG) && defined(TRACE)

    DWORD APItime   = 0L;
    DWORD totaltime = 0L;

    DWORD start = ::GetTickCount();
    TRACEEOL(   "USER_LBI_CACHE::ReadUsers: starting read" );

#endif

    ULONG cbBytesRequested = BYTES_INITIAL_COUNT;
    if (cUsersPerRequest == 0)
        cUsersPerRequest = USERS_INITIAL_COUNT;

    for( ; ; )
    {
        ULONG cbTotalAvailable;
        ULONG cbTotalReturned;
        ULONG cEntriesRead;
        DOMAIN_DISPLAY_USER * pddu = NULL;
        DOMAIN_DISPLAY_USER * pdduOrig = NULL;

        //
        //  Get the next chunk of API data.
        //

        DWORD APIstart = ::GetTickCount();

        NTSTATUS status = ::SamQueryDisplayInformation( hSamDomain,
                                                        DomainDisplayUser,
                                                        iUser,
                                                        cUsersPerRequest,
                                                        cbBytesRequested,
                                                        &cbTotalAvailable,
                                                        &cbTotalReturned,
                                                        &cEntriesRead,
                                                        (PVOID *)&pdduOrig );
        pddu = pdduOrig;

        DWORD APIfinish = ::GetTickCount();

        TRACEEOL(   "ReadUsers: " << cEntriesRead << " (" << cUsersPerRequest
                 << ") users and " << cbTotalReturned << " (" << cbBytesRequested
                 << ") bytes took "
                 << (APIfinish - APIstart) << " msec" );

        if ( (APIfinish - APIstart) < READ_MORE_MSEC )
        {
            cbBytesRequested *= 2;
            if ( cbBytesRequested > BYTES_MAX_COUNT )
                cbBytesRequested = BYTES_MAX_COUNT;

            cUsersPerRequest *= 2;
            if ( cUsersPerRequest > USERS_MAX_COUNT )
                cUsersPerRequest = USERS_MAX_COUNT;
        }
        else if ( (APIfinish - APIstart) > READ_LESS_MSEC )
        {
            cbBytesRequested /= 2;
            if ( cbBytesRequested < BYTES_MIN_COUNT )
                cbBytesRequested = BYTES_MIN_COUNT;

            cUsersPerRequest /= 2;
            if ( cUsersPerRequest < USERS_MIN_COUNT )
                cUsersPerRequest = USERS_MIN_COUNT;
        }

#if defined(DEBUG) && defined(TRACE)

        APItime += (APIfinish - APIstart);

#endif

        err = ERRMAP::MapNTStatus( status );

        if( ( err != NERR_Success ) && ( err != ERROR_MORE_DATA ) )
        {
            //
            //  Something tragic occurred.
            //

            break;
        }

        if( ( cEntriesRead == 0 ) || ( cbTotalReturned == 0 ) )
        {
            //
            //  No more data to return.
            //

            break;
        }

        //
        //  Create a new buffer node for our buffer list.
        //

        ULC_API_BUFFER * pbuffer = new ULC_API_BUFFER( pddu, cEntriesRead );

        if( pbuffer == NULL )
        {
            //
            //  Could not create the buffer.
            //

            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        //  Append the new buffer node to the list.
        //

        // JonN 8/7/00
        // 24922 cleanup: this was overwriting the ERROR_MORE_DATA value
        APIERR err2 = _slBuffers.Append( pbuffer );

        if( err2 != NERR_Success )
        {
            err = err2;
            break;
        }

        //
        //  Grow the cache.  Note that we simply use cEntriesRead
        //  as a delta against the current cache size.  In reality,
        //  we may not need this much data if fIncludeRemoteUsers
        //  is FALSE.  Since most users are *not* remote users,
        //  it's not worth the effort to calculate a more accurate
        //  figure.  A little slop in the array size isn't a
        //  horrific price to pay for a little added efficiency.
        //

        if( !W_GrowCache( _cEntries + (INT)cEntriesRead ) )
        {
            //
            //  Could not grow the cache.
            //

            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        //  Update the cache entries.
        //

        ULONG cTmpEntries = cEntriesRead;

        for ( ULC_ENTRY * pTmp = QueryULCEntryPtr( _cEntries ) ;
              cTmpEntries-- ;
              pddu++ )
        {
            if( ( pddu->AccountControl & maskSelect ) == 0 )
            {
                pTmp->pddu = pddu;
                pTmp->plbi = NULL;
                if ( _cbExtraBytes > 0 )
                {
                    ::memset( (void *)&(pTmp->bExtraBytes),
                              0,
                              _cbExtraBytes );
                }

                _cEntries++;
                pTmp = (ULC_ENTRY *) ( ((BYTE *)pTmp) + QueryULCEntrySize() );
            }
        }

        //
        //  Update for the next API chunk.
        //

        // 379697: Incorrect usage of SamQueryDisplayInformation() in User Browser and net\ui\common\src
        // JonN 8/5/99

        // only continue on ERROR_MORE_DATA
        if ( ERROR_MORE_DATA != err )
            break;
        // set starting index for next iteration to index of last returned entry
        // iUser += cEntriesRead;
        if ( 0 < cEntriesRead )
            iUser = pdduOrig[cEntriesRead-1].Index;

        if ( pfQuitEnum != NULL && *pfQuitEnum )
            break;
    }

#if defined(DEBUG) && defined(TRACE)

    DWORD finish = ::GetTickCount();
    TRACEEOL(   "USER_LBI_CACHE::ReadUsers: completed read" );

    totaltime = finish - start;

    {
        TCHAR buffer1[ 100 ];
        TCHAR buffer2[ 100 ];

        wsprintf( buffer1, SZ("%8lu"), APItime );
        wsprintf( buffer2, SZ("%8lu"), totaltime );
        TRACEEOL(   "\tAPI   time " << buffer1 << " ms" );
        TRACEEOL(   "\ttotal time " << buffer2 << " ms" );
    }


    if ( err != NERR_Success )
    {
        TRACEEOL( "USER_LBI_CACHE::ReadUsers: read failed with " << err );
    }

#endif

    if( ( err == NERR_Success ) && ( nInitialGrowthSpace > 0 ) )
    {
        //
        //  The client is requesting some slop in the
        //  cache array.
        //

        INT nNewSize = ( _cEntries * ( nInitialGrowthSpace + 100 ) ) / 100;

        if( !W_GrowCache( nNewSize ) )
        {
            //
            //  Could not grow the cache.
            //

            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return err;

}   // USER_LBI_CACHE :: ReadUsers

/*******************************************************************

    NAME:       USER_LBI_CACHE :: BinarySearch

    SYNOPSIS:   Performs a binary search on the cache to find
                the appropriate location for a new LBI.

    ENTRY:      plbiNew                 - The new LBI.

    RETURNS:    INT                     - The proper index for the
                                          new LBI.

    NOTES:      This method must be called with the cache locked.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
INT USER_LBI_CACHE :: BinarySearch( LBI * plbiNew )
{
    if( _cEntries == 0 )
    {
        //
        //  The cache is empty, so we'll put the new
        //  LBI at the beginning.
        //

        return 0;
    }

    UIASSERT( _pCache != NULL );

    INT iHigh  = _cEntries - 1;
    INT iLow   = 0;
    INT iNew   = 0;
    INT cmpres = 0;

    //
    //  This is just your basic binary search, nothing fancy.
    //

    while( iLow <= iHigh )
    {
        iNew = ( iHigh + iLow ) / 2;

        ULC_ENTRY * pTmp = QueryULCEntryPtr( iNew );

        //
        //  We need to decide where to compare plbi <-> plbi
        //  or plbi <-> pddu.
        //

        if( pTmp->plbi != NULL )
        {
            cmpres = Compare( plbiNew, pTmp->plbi );
        }
        else
        {
            UIASSERT( pTmp->pddu != NULL );
            cmpres = Compare( plbiNew, pTmp->pddu );
        }

        //
        //  Interpret the result, move the boundaries as necessary.
        //

        if( cmpres < 0 )
        {
            iHigh = iNew - 1;
        }
        else
        if( cmpres > 0 )
        {
            iLow = iNew + 1;
        }
        else
        {
            iLow = iNew;
            break;
        }

    }

    return max( 0, iLow );

}   // USER_LBI_CACHE :: BinarySearch


/*******************************************************************

    NAME:       USER_LBI_CACHE :: BinarySearch

    SYNOPSIS:   Performs a binary search on the cache to find
                the appropriate location for a new LBI.

    ENTRY:      pddu                    - The DOMAIN_DISPLAY_USER for a new LBI.

    RETURNS:    INT                     - The proper index for the
                                          new LBI.

    NOTES:      This method must be called with the cache locked.

    HISTORY:
        JonN        30-Dec-1992     Created.

********************************************************************/
INT USER_LBI_CACHE :: BinarySearch( DOMAIN_DISPLAY_USER * pddu )
{
    if( _cEntries == 0 )
    {
        //
        //  The cache is empty, so we'll put the new
        //  LBI at the beginning.
        //

        return 0;
    }

    UIASSERT( _pCache != NULL );

    INT iHigh  = _cEntries - 1;
    INT iLow   = 0;
    INT iNew   = 0;
    INT cmpres = 0;

    //
    //  This is just your basic binary search, nothing fancy.
    //

    while( iLow <= iHigh )
    {
        iNew = ( iHigh + iLow ) / 2;

        ULC_ENTRY * pTmp = QueryULCEntryPtr( iNew );

        //
        //  We need to decide where to compare pddu <-> plbi
        //  or pddu <-> pddu.
        //

        if( pTmp->plbi != NULL )
        {
            cmpres = -(Compare( pTmp->plbi, pddu ));
        }
        else
        {
            UIASSERT( pTmp->pddu != NULL );
            ULC_ENTRY ulcTemp;
            ulcTemp.plbi = NULL;
            ulcTemp.pddu = pddu;
            cmpres = (QueryCompareMethod())( (void *)(&ulcTemp), (void *)pTmp );
        }

        //
        //  Interpret the result, move the boundaries as necessary.
        //

        if( cmpres < 0 )
        {
            iHigh = iNew - 1;
        }
        else
        if( cmpres > 0 )
        {
            iLow = iNew + 1;
        }
        else
        {
            iLow = iNew;
            break;
        }

    }

    return max( 0, iLow );

}   // USER_LBI_CACHE :: BinarySearch


/*******************************************************************

    NAME:       USER_LBI_CACHE :: W_GetLBI

    SYNOPSIS:   Lazy LBI creation.  Ensures that a particular cache
                location contains a valid LBI.

    ENTRY:      i                       - Zero-based index of the
                                          LBI to retrieve.

    EXIT:       If successful, then the specified cache entry will
                contain a valid LBI.  This may be a newly created
                LBI retrieved by calling the CreateLBI virtual.

    RETURNS:    LBI *                   - Points to the LBI found at
                                          the specified location.  Will
                                          be NULL if an error occurred.

    NOTES:      This method must be called with the cache locked.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
LBI * USER_LBI_CACHE :: W_GetLBI( INT i )
{
    LBI * plbi = NULL;

    //
    //  Only access the cache if the index is within range.
    //

    if( ( i >= 0 ) && ( i < _cEntries ) )
    {
        //
        //  Find the cache entry.
        //

        ULC_ENTRY * pTmp = QueryULCEntryPtr( i );

        plbi = pTmp->plbi;

        if( plbi == NULL )
        {
            //
            //  Cache miss.  Invoke the virtual callback
            //  to get a new LBI for this entry.
            //

            DOMAIN_DISPLAY_USER * pddu = pTmp->pddu;

            UIASSERT( pddu != NULL );

            if( pddu != NULL )
            {
                plbi = CreateLBI( pTmp->pddu );
            }

            if( ( plbi != NULL ) && ( plbi->QueryError() != NERR_Success ) )
            {
                //
                //  We want to avoid putting badly constructed
                //  LBIs in the cache.
                //

                delete plbi;
                plbi = NULL;
            }

            //
            //  Save the new (potentially NULL) LBI in the cache.
            //

            pTmp->plbi = plbi;
        }
        else
        {
            //
            //  Only properly constructed LBIs should ever
            //  make it into the cache.
            //

            UIASSERT( plbi->QueryError() == NERR_Success );
        }
    }

    return plbi;

}   // USER_LBI_CACHE :: W_GetLBI

/*******************************************************************

    NAME:       USER_LBI_CACHE :: W_GrowCache

    SYNOPSIS:   Grow the cache array to contain at least the specified
                number of entries.

    ENTRY:      cTotalCacheEntries      - The minimum number of entries
                                          the cache should contain.

    EXIT:       If successful, the cache has been grown to contain at
                least the specified number of entries.  This typically
                requires a reallocation of the cache array block.  This
                method is also responsible for updating the _cSlots
                data member.

    RETURNS:    BOOL                    - TRUE if successful, FALSE
                                          otherwise.

    NOTES:      This method must be called with the cache locked.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
BOOL USER_LBI_CACHE :: W_GrowCache( INT cTotalCacheEntries )
{
    BOOL fResult = TRUE;       // until proven otherwise...

    if( cTotalCacheEntries > _cSlots )
    {
        //
        //  Round cTotalCacheEntries UP to an integral number
        //  of ULC_CACHE_GROWTH_DELTA blocks.
        //

        cTotalCacheEntries += ULC_CACHE_GROWTH_DELTA - 1;
        cTotalCacheEntries &= ~( ULC_CACHE_GROWTH_DELTA - 1 );

        //
        //  Try to allocate a new cache array of the
        //  requested size.
        //

        VOID * pNewCache = (VOID *) new BYTE[
                        cTotalCacheEntries * QueryULCEntrySize() ];

        if( pNewCache == NULL )
        {
            fResult = FALSE;
        }
        else
        {
            //
            //  Successful allocation.  Zero-out the new portion
            //  of the array, then copy the data from the old
            //  array.
            //

            ::memset( (void *)( ((BYTE *)pNewCache) + (_cEntries * QueryULCEntrySize()) ),
                      0,
                      ( cTotalCacheEntries - _cEntries ) * QueryULCEntrySize() );

            if( _cEntries > 0 )
            {
                ::memcpy( (void *)pNewCache,
                          (void *)_pCache,
                          _cEntries * QueryULCEntrySize() );
            }

            delete _pCache;
            _pCache = pNewCache;
            _cSlots = cTotalCacheEntries;
        }
    }

    return fResult;

}   // USER_LBI_CACHE :: W_GrowCache
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\w32sema4.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    w32sema4.cxx
    Class definitions for the WIN32_SEMAPHORE class.

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
        KeithMo     21-Jan-1992 Created.

*/

#include "pchapplb.hxx"   // Precompiled header

//
//  WIN32_SEMAPHORE methods.
//

/*******************************************************************

    NAME:       WIN32_SEMAPHORE :: WIN32_SEMAPHORE

    SYNOPSIS:   WIN32_SEMAPHORE class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_SEMAPHORE :: WIN32_SEMAPHORE( const TCHAR * pszName,
                                    LONG          cInitial,
                                    LONG          cMaximum )
  : WIN32_SYNC_BASE( NULL )
{
    if( QueryError() != NO_ERROR )
    {
        return;
    }

    HANDLE hSemaphore;

    hSemaphore = ::CreateSemaphore( NULL,
                                    cInitial,
                                    cMaximum,
                                    (LPTSTR)pszName );

    if( hSemaphore == NULL )
    {
        ReportError( (APIERR)::GetLastError() );
        return;
    }

    SetHandle( hSemaphore );

}   // WIN32_SEMAPHORE :: WIN32_SEMAPHORE


/*******************************************************************

    NAME:       WIN32_SEMAPHORE :: ~WIN32_SEMAPHORE

    SYNOPSIS:   WIN32_SEMAPHORE class destructor.

    ENTRY:

    EXIT:       The object is destroyed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_SEMAPHORE :: ~WIN32_SEMAPHORE( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // WIN32_SEMAPHORE :: ~WIN32_SEMAPHORE


/*******************************************************************

    NAME:       WIN32_SEMAPHORE :: Release

    SYNOPSIS:   Release the semaphore.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_SEMAPHORE :: Release( LONG   ReleaseCount,
                                   LONG * pPreviousCount )
{
    APIERR err = NO_ERROR;

    if( !::ReleaseSemaphore( QueryHandle(),
                             ReleaseCount,
                             pPreviousCount ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // WIN32_SEMAPHORE :: Release
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\w32mutex.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    w32mutex.cxx
    Class definitions for the WIN32_MUTEX class.

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
        KeithMo     21-Jan-1992 Created.

*/

#include "pchapplb.hxx"   // Precompiled header

//
//  WIN32_MUTEX methods.
//

/*******************************************************************

    NAME:       WIN32_MUTEX :: WIN32_MUTEX

    SYNOPSIS:   WIN32_MUTEX class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_MUTEX :: WIN32_MUTEX( const TCHAR * pszName,
                            BOOL          fInitialOwner )
  : WIN32_SYNC_BASE( NULL )
{
    if( QueryError() != NO_ERROR )
    {
        return;
    }

    HANDLE hMutex;

    hMutex = ::CreateMutex( NULL,
                            fInitialOwner,
                            (LPTSTR)pszName );

    if( hMutex == NULL )
    {
        ReportError( (APIERR)::GetLastError() );
        return;
    }

    SetHandle( hMutex );

}   // WIN32_MUTEX :: WIN32_MUTEX


/*******************************************************************

    NAME:       WIN32_MUTEX :: ~WIN32_MUTEX

    SYNOPSIS:   WIN32_MUTEX class destructor.

    ENTRY:

    EXIT:       The object is destroyed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_MUTEX :: ~WIN32_MUTEX()
{
    //
    //  This space intentionally left blank.
    //

}   // WIN32_MUTEX :: ~WIN32_MUTEX


/*******************************************************************

    NAME:       WIN32_MUTEX :: Release

    SYNOPSIS:   Release the mutex.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_MUTEX :: Release( VOID )
{
    APIERR err = NO_ERROR;

    if( !::ReleaseMutex( QueryHandle() ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // WIN32_MUTEX :: Release
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\w32event.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    w32event.cxx
    Class definitions for the WIN32_EVENT class.

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
        KeithMo     21-Jan-1992 Created.

*/

#include "pchapplb.hxx"   // Precompiled header

//
//  WIN32_EVENT methods.
//

/*******************************************************************

    NAME:       WIN32_EVENT :: WIN32_EVENT

    SYNOPSIS:   WIN32_EVENT class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_EVENT :: WIN32_EVENT( const TCHAR * pszName,
                            BOOL          fManualReset,
                            BOOL          fInitialState )
{
    if( QueryError() != NO_ERROR )
    {
        return;
    }

    HANDLE hEvent;

    hEvent = ::CreateEvent( NULL,
                            fManualReset,
                            fInitialState,
                            (LPTSTR)pszName );

    if( hEvent == NULL )
    {
        ReportError( (APIERR)::GetLastError() );
        return;
    }

    SetHandle( hEvent );

}   // WIN32_EVENT :: WIN32_EVENT


/*******************************************************************

    NAME:       WIN32_EVENT :: ~WIN32_EVENT

    SYNOPSIS:   WIN32_EVENT class destructor.

    ENTRY:

    EXIT:       The object is destroyed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_EVENT :: ~WIN32_EVENT()
{
    //
    //  This space intentionally left blank.
    //

}   // WIN32_EVENT :: ~WIN32_EVENT


/*******************************************************************

    NAME:       WIN32_EVENT :: Set

    SYNOPSIS:   Set the mutex.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_EVENT :: Set( VOID )
{
    APIERR err = NO_ERROR;

    if( !::SetEvent( QueryHandle() ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // WIN32_EVENT :: Set


/*******************************************************************

    NAME:       WIN32_EVENT :: Reset

    SYNOPSIS:   Reset the mutex.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_EVENT :: Reset( VOID )
{
    APIERR err = NO_ERROR;

    if( !::ResetEvent( QueryHandle() ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // WIN32_EVENT :: Reset


/*******************************************************************

    NAME:       WIN32_EVENT :: Pulse

    SYNOPSIS:   Pulse the mutex.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_EVENT :: Pulse( VOID )
{
    APIERR err = NO_ERROR;

    if( !::PulseEvent( QueryHandle() ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // WIN32_EVENT :: Pulse
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\w32handl.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    w32handl.cxx
    Class definitions for the WIN32_HANDLE class.

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
        KeithMo     21-Jan-1992 Created.

*/

#include "pchapplb.hxx"   // Precompiled header

//
//  WIN32_HANDLE methods.
//

/*******************************************************************

    NAME:       WIN32_HANDLE :: WIN32_HANDLE

    SYNOPSIS:   WIN32_HANDLE class constructor.

    ENTRY:      hGeneric                - The Win32 Handle.

    EXIT:       The object is constructed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_HANDLE :: WIN32_HANDLE( HANDLE hGeneric )
   : _hGeneric( NULL )
{
    if( QueryError() != NO_ERROR )
    {
        return;
    }

    SetHandle( hGeneric );

}   // WIN32_HANDLE :: WIN32_HANDLE


/*******************************************************************

    NAME:       WIN32_HANDLE :: ~WIN32_HANDLE

    SYNOPSIS:   WIN32_HANDLE class destructor.

    ENTRY:

    EXIT:       The object is destroyed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_HANDLE :: ~WIN32_HANDLE()
{
    if( QueryHandle() != NULL )
    {
        Close();
    }

}   // WIN32_HANDLE :: ~WIN32_HANDLE


/*******************************************************************

    NAME:       WIN32_HANDLE :: Close

    SYNOPSIS:   Close the handle associated with this object.

    EXIT:       If successful, then the handle has been closed.

    RETURNS:    APIERR                  - Error code if handle could
                                          not be closed.

    NOTES:      If the handle was successfully closed, then the handle
                value is set to NULL.

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_HANDLE :: Close( VOID )
{
    APIERR err = NO_ERROR;

    UIASSERT( QueryHandle() != NULL );

    if( !::CloseHandle( QueryHandle() ) )
    {
        err = (APIERR)::GetLastError();
    }

    if( err == NO_ERROR )
    {
        SetHandle( NULL );
    }

    return err;

}   // WIN32_HANDLE :: Close
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\w32sync.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    w32sync.cxx
    Class definitions for the WIN32_SYNC_BASE class.

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
        KeithMo     21-Jan-1992 Created.

*/

#include "pchapplb.hxx"   // Precompiled header

//
//  WIN32_SYNC_BASE methods.
//

/*******************************************************************

    NAME:       WIN32_SYNC_BASE :: WIN32_SYNC_BASE

    SYNOPSIS:   WIN32_SYNC_BASE class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_SYNC_BASE :: WIN32_SYNC_BASE( HANDLE hSyncObject )
   : WIN32_HANDLE( hSyncObject )
{
    if( QueryError() != NO_ERROR )
    {
        return;
    }

}   // WIN32_SYNC_BASE :: WIN32_SYNC_BASE


/*******************************************************************

    NAME:       WIN32_SYNC_BASE :: ~WIN32_SYNC_BASE

    SYNOPSIS:   WIN32_SYNC_BASE class destructor.

    ENTRY:

    EXIT:       The object is destroyed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_SYNC_BASE :: ~WIN32_SYNC_BASE()
{
    //
    //  Force the object handle closed.
    //

    Close();

}   // WIN32_SYNC_BASE :: ~WIN32_SYNC_BASE


/*******************************************************************

    NAME:       WIN32_SYNC_BASE :: Wait

    SYNOPSIS:   Wait for the object to enter the signaled state.

    ENTRY:      cMilliseconds           - The number of milliseconds to
                                          wait for the object to enter
                                          the signaled state.
                                          -1 == wait indefinitely.

    EXIT:       Either the object is in the signaled state or a timeout
                has occurred.

    RETURNS:    APIERR                  - The result of the wait.

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_SYNC_BASE :: Wait( UINT cMilliseconds )
{
    APIERR err;

    UIASSERT( QueryHandle() != NULL );

    err = (APIERR)::WaitForSingleObject( QueryHandle(),
                                         (DWORD)cMilliseconds );

    if( ( err != NO_ERROR ) &&
        ( err != WAIT_TIMEOUT ) &&
        ( err != WAIT_ABANDONED ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // WIN32_SYNC_BASE :: Wait
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\applib\w32thred.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    w32thred.cxx
    Class definitions for the WIN32_THREAD class.

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
        KeithMo     21-Jan-1992 Created.

*/

#include "pchapplb.hxx"   // Precompiled header

//
//  WIN32_THREAD methods.
//

/*******************************************************************

    NAME:       WIN32_THREAD :: WIN32_THREAD

    SYNOPSIS:   WIN32_THREAD class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.
        JonN        30-Nov-1993 Added pszLoadLibrary

********************************************************************/
WIN32_THREAD :: WIN32_THREAD( BOOL fSuspended,
                              UINT cbStack,
                              const TCHAR * pszLoadLibrary )
  : WIN32_SYNC_BASE( NULL ),
    _idThread( 0 ),
    _nExitCode( 0 ),
    _nlsLoadLibrary( pszLoadLibrary ),
    _hLoadLibrary( NULL ),
    _state( Embryonic )
{
    if( QueryError() != NO_ERROR )
    {
        return;
    }

    APIERR err = _nlsLoadLibrary.QueryError();
    if( err != NO_ERROR )
    {
        ReportError( err );
        return;
    }

    HANDLE hThread;

    hThread = ::CreateThread( NULL,
                              (DWORD)cbStack,
                              (LPTHREAD_START_ROUTINE)&WIN32_THREAD::StartThread,
                              (LPVOID)this,
                              fSuspended ? CREATE_SUSPENDED : 0,
                              (LPDWORD)&_idThread );

    if( hThread == NULL )
    {
        err = (APIERR)::GetLastError();
        ReportError( err );
        TRACEEOL( "WIN32_THREAD::ctor() error " << err );
        return;
    }

    SetHandle( hThread );

}   // WIN32_THREAD :: WIN32_THREAD


/*******************************************************************

    NAME:       WIN32_THREAD :: ~WIN32_THREAD

    SYNOPSIS:   WIN32_THREAD class destructor.

    ENTRY:

    EXIT:       The object is destroyed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_THREAD :: ~WIN32_THREAD()
{
    if( IsRunnable() )
    {
        Terminate( 0 );
    }

}   // WIN32_THREAD :: ~WIN32_THREAD


/*******************************************************************

    NAME:       WIN32_THREAD :: StartThread

    SYNOPSIS:   Gets the thread started.

    ENTRY:      lpParam                 - The parameter from CreateThread
                                          (is actually 'this').

    EXIT:       Does not exit until thread is terminated or exits.

    RETURNS:    DWORD                   - Thread exit code.

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
DWORD WIN32_THREAD :: StartThread( LPVOID lpParam )
{
    WIN32_THREAD * pThread = (WIN32_THREAD *)lpParam;
    APIERR err;

    if ( pThread->_nlsLoadLibrary.strlen() != 0 )
    {
        pThread->_hLoadLibrary = LoadLibrary(
                            pThread->_nlsLoadLibrary.QueryPch() );
        if ( pThread->_hLoadLibrary == NULL )
        {
            //
            // If a LoadLibrary error occurs, we kill the thread
            //

            err = ::GetLastError();
            DBGEOL( "WIN32_THREAD::StartThread(): LoadLibrary() error " << err );
            return (DWORD)err;
        }

        TRACEEOL(   "WIN32_THREAD::StartThread(): LoadLibrary() returns "
                 << (DWORD)pThread->_hLoadLibrary );
    }


    pThread->SetState( Starting );
    err = pThread->PreMain();

    TRACEEOL( "WIN32_THREAD::StartThread(): PreMain() returns " << err );

    if( err == NO_ERROR )
    {
        pThread->SetState( Running );
        err = pThread->Main();

        TRACEEOL( "WIN32_THREAD::StartThread(): Main() returns " << err );
    }

    pThread->SetState( Stopping );
    APIERR err2 = pThread->PostMain();
    TRACEEOL( "WIN32_THREAD::StartThread(): PostMain() returns " << err2 );
    err = err2 ? err2 : err;

    pThread->SetState( Dead );
    pThread->_nExitCode = (UINT)err;

    TRACEEOL( "WIN32_THREAD::StartThread(): returns " << err );

    if ( pThread->_hLoadLibrary != NULL )
    {
        TRACEEOL( "WIN32_THREAD::StartThread(): exiting by FreeLibraryAndExitThread()" );
        FreeLibraryAndExitThread( pThread->_hLoadLibrary, (DWORD)err );
        ASSERT( FALSE ); // should never reach this point
    }

    return (DWORD)err;

}   // WIN32_THREAD :: StartThread


/*******************************************************************

    NAME:       WIN32_THREAD :: PreMain

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_THREAD :: PreMain( VOID )
{
    UIASSERT( QueryState() == Starting );

    return NO_ERROR;

}   // WIN32_THREAD :: PreMain


/*******************************************************************

    NAME:       WIN32_THREAD :: Main

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_THREAD :: Main( VOID )
{
    UIASSERT( QueryState() == Running );

    return  NO_ERROR;

}   // WIN32_THREAD :: Main


/*******************************************************************

    NAME:       WIN32_THREAD :: PostMain

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_THREAD :: PostMain( VOID )
{
    UIASSERT( QueryState() == Stopping );

    return  NO_ERROR;

}   // WIN32_THREAD :: PostMain


/*******************************************************************

    NAME:       WIN32_THREAD :: Exit

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
VOID WIN32_THREAD :: Exit( UINT nExitCode )
{
    UIASSERT( QueryState() == Running );
    UIASSERT( QueryID() == (UINT)::GetCurrentThreadId() );

    SetState( Stopping );
    PostMain();

    SetState( Dead );
    _nExitCode = nExitCode;

    if ( _hLoadLibrary != NULL )
    {
        TRACEEOL( "WIN32_THREAD::Exit(): exiting by FreeLibraryAndExitThread()" );
        FreeLibraryAndExitThread( _hLoadLibrary, (DWORD)nExitCode );
    }
    else
    {
        ::ExitThread( (DWORD)nExitCode );
    }

    DBGEOL( "WIN32_THRED::Exit: unexpected return from ::ExitThread()" );
    UIASSERT( FALSE );

}   // WIN32_THREAD :: Exit


/*******************************************************************

    NAME:       WIN32_THREAD :: SetPriority

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_THREAD :: SetPriority( INT nPriority )
{
    APIERR err = NO_ERROR;

    if( !::SetThreadPriority( QueryHandle(), nPriority ) )
    {
        err = (APIERR)::GetLastError();

        TRACEEOL(    "WIN32_THRED::SetPriority( " << nPriority
                  << "): ::SetThreadPriority() error " << err );
    }

    return err;

}   // WIN32_THREAD :: SetPriority


/*******************************************************************

    NAME:       WIN32_THREAD :: QueryPriority

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
INT WIN32_THREAD :: QueryPriority( VOID )
{
    return (INT)::GetThreadPriority( QueryHandle() );

}   // WIN32_THREAD :: QueryPriority


/*******************************************************************

    NAME:       WIN32_THREAD :: Suspend

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_THREAD :: Suspend( VOID )
{
    APIERR err = NO_ERROR;

    if( ::SuspendThread( QueryHandle() ) == (DWORD)-1L )
    {
        err = (APIERR)::GetLastError();

        TRACEEOL( "WIN32_THRED::Suspend: ::SuspendThread() error " << err );
    }

    return err;

}   // WIN32_THREAD :: Suspend


/*******************************************************************

    NAME:       WIN32_THREAD :: Resume

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_THREAD :: Resume( VOID )
{
    APIERR err = NO_ERROR;

    if( ::ResumeThread( QueryHandle() ) == (DWORD)-1L )
    {
        err = (APIERR)::GetLastError();

        TRACEEOL( "WIN32_THRED::Resume: ::ResumeThread() error " << err );
    }

    return err;

}   // WIN32_THREAD :: Resume


/*******************************************************************

    NAME:       WIN32_THREAD :: Sleep

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
VOID WIN32_THREAD :: Sleep( UINT cMilliseconds )
{
    ::Sleep( (DWORD)cMilliseconds );

}   // WIN32_THREAD :: Sleep


/*******************************************************************

    NAME:       WIN32_THREAD :: Terminate

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      don't use this on a thread which must free _hLoadLibrary

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_THREAD :: Terminate( UINT nExitCode )
{
    ASSERT( _hLoadLibrary == NULL );

    APIERR err = NO_ERROR;

    if( !::TerminateThread( QueryHandle(), (DWORD)nExitCode ) )
    {
        err = (APIERR)::GetLastError();

        DBGEOL( "WIN32_THRED::Terminate: ::TerminateThread() error " << err );

    }

    if( err == NO_ERROR )
    {
        SetState( Terminated );
    }

    return err;

}   // WIN32_THREAD :: Terminate


/*******************************************************************

    NAME:       WIN32_THREAD :: DeleteAndExit

    SYNOPSIS:   Deletes "this" then exits the thread.  Allows a
                thread to kill itself when it wants to

    ENTRY:      nExitCode - Exit code for this thread

    NOTES:      The thread must be allocated on the heap.
                This call will never return.

    HISTORY:
        Johnl   07-Jan-1993     Created
        JonN    20-May-1992     Changed to DeleteAndExit

********************************************************************/
VOID WIN32_THREAD :: DeleteAndExit( UINT nExitCode )
{
    UIASSERT( QueryID() == (UINT)::GetCurrentThreadId() );

    HINSTANCE hInstance = _hLoadLibrary; // save for later

    //
    //  Lie abit, make the destructor think the thread has already been
    //  terminated
    //
    SetState( Dead ) ;
    delete this ;

    if ( hInstance != NULL )
    {
        TRACEEOL( "WIN32_THREAD::DeleteAndExit(): exiting by FreeLibraryAndExitThread()" );
        FreeLibraryAndExitThread( hInstance, (DWORD)nExitCode );
    }
    else
    {
        ::ExitThread( (DWORD)nExitCode );
    }


    DBGEOL( "WIN32_THRED::DeleteAndExit: unexpected return from ::ExitThread()" );
    UIASSERT( FALSE );

}   // WIN32_THREAD :: DeleteAndExit
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\bin\makefile.inc ===
COMBINE_SOURCELIBS=..\pch\$(O)\pchapplb.lib \
                   ..\applib\$(O)\applib.lib

COMBINE_TARGETLIB=$(O)\uiapplib.lib

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltbitmp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltbitmp.cxx
    BLT bitmap and display map class definitions

    LM 3.0 Work Item: The DISPLAY_MAP object needs several additional
    parameters in the Paint method.  It needs the origin of the display
    map and the clipping rectangle.


    FILE HISTORY:
        rustanl     03-Dec-1990     Created
        beng        11-Feb-1991     Uses lmui.hxx
        Johnl       01-Mar-1991     Added Display Map object
        Johnl       13-Mar-1991     Cleaned up BIT_MAP object
        Johnl       18-Mar-1991     Made code review changes
        gregj       01-May-1991     Added DISPLAY_MAP::QueryID for GUILTT
        beng        14-May-1991     Exploded blt.hxx into components
        rustanl     19-Jul-1991     Added more error checks
        terryk      19-Jul-1991     Delete BIT_MAP( ULONG ) constructor and
                                    add BIT_MAP::SetBitmap() function
        KeithMo     07-Aug-1992     STRICTified.

*/
#include "pchblt.hxx"


// NOTE - winbase.h defines UnlockResource such that
// I can't call it like a C++ global fcn.

#if defined(WIN32) && defined(UnlockResource)
#undef UnlockResource
inline BOOL UnlockResource( HANDLE hResData )
{
    UNREFERENCED(hResData);
    return FALSE;
}
#endif


/*******************************************************************

    NAME:       BIT_MAP::BIT_MAP

    SYNOPSIS:   Bitmap object contructors

        Form 0:  Accepts BMID and tries to load it from the
        resource file; will assert out under DEBUG if load fails.

        Form 1:  Accepts name of bitmap resource and tries to
        load from resource file; will assert out under DEBUG if
        load fails.

        (Forms 0 and 1 are now unified under IDRESOURCE.)

        Form 3:  Accepts handle to a valid, loaded bitmap.  Note,
        the destructor will delete this object.

    HISTORY:
        Rustanl     03-Dec-1990 Created
        Johnl       13-Mar-1991 Commented, cleaned up
        terryk      21-Jun-1991 Add 2 more constructors for bitmap class
        rustanl     18-Jul-1991 Added BASE error checks
        beng        01-Nov-1991 Use MapLastError
        beng        03-Aug-1992 Use IDRESOURCE; dllization

********************************************************************/

BIT_MAP::BIT_MAP( const IDRESOURCE & id )
    : _h( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    HMODULE hmod = BLT::CalcHmodRsrc(id);

    HBITMAP hbmp = ::LoadBitmap(hmod, id.QueryPsz());
    if (hbmp == NULL)
    {
        ReportError(BLT::MapLastError(ERROR_INVALID_PARAMETER));
        return;
    }

    _h = hbmp;
}


BIT_MAP::BIT_MAP( HBITMAP hbitmap )
    : _h( hbitmap )
{
    if ( QueryError() != NERR_Success )
        return;

    if ( hbitmap == NULL )
    {
        UIASSERT( FALSE );
        ReportError( ERROR_INVALID_PARAMETER );
        return;
    }
}


/*******************************************************************

    NAME:       BIT_MAP::~BIT_MAP

    SYNOPSIS:   BIT_MAP destructor, if we have a valid (i.e., non-null)
                bitmap handle, we call DeleteObject on it, otherwise
                ignore it.

    HISTORY:
        Rustanl 03-Dec-1990     Created
        Johnl   13-Mar-1991     Commented, cleaned up

********************************************************************/

BIT_MAP::~BIT_MAP()
{
    if ( _h != NULL )
        ::DeleteObject( (HGDIOBJ)_h );
}


/*******************************************************************

    NAME:     BIT_MAP::QueryHandle

    SYNOPSIS: Retrieves bitmap handle

    HISTORY:
        Rustanl 03-Dec-1990     Created
        Johnl   13-Mar-1991     Commented, cleaned up

********************************************************************/

HBITMAP BIT_MAP::QueryHandle() const
{
    UIASSERT( QueryError() == NERR_Success );
    return _h;
}


/*******************************************************************

    NAME:       BIT_MAP::SetBitmap

    SYNOPSIS:   set the internal bitmap variable to the given parameter

    ENTRY:      HBITMAP hbitmap - the new bitmap handle

    HISTORY:
                terryk  19-Jul-91   Created

********************************************************************/

VOID BIT_MAP::SetBitmap( HBITMAP hbitmap )
{
    _h = hbitmap;
}


/*******************************************************************

    NAME:       BIT_MAP::QueryHeight

    SYNOPSIS:   Gets the width and height in pixels of the bitmap.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Rustanl     03-Dec-1990 Created
        Johnl       13-Mar-1991 Added real code (for real people)
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

UINT BIT_MAP::QueryHeight() const
{
    UIASSERT( QueryError() == NERR_Success );

    BITMAP bitmap;
    // Note funky third arg to GetObject
    if ( ! ::GetObject( QueryHandle(), sizeof( bitmap ), (TCHAR*) &bitmap ) )
    {
        UIASSERT(FALSE);
        return 0;
    }

    return bitmap.bmHeight;
}


/*******************************************************************

    NAME:       BIT_MAP::QueryWidth

    SYNOPSIS:   Gets the width and height in pixels of the bitmap.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Rustanl     03-Dec-1990 Created
        Johnl       13-Mar-1991 Added real code (for real people)
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

UINT BIT_MAP::QueryWidth() const
{
    UIASSERT( QueryError() == NERR_Success );

    BITMAP bitmap;
    if ( ! ::GetObject( QueryHandle(), sizeof( bitmap ), (TCHAR*) &bitmap ) )
    {
        UIASSERT(FALSE);
        return 0;
    }

    return bitmap.bmWidth;
}


/*******************************************************************

    NONAME:     DISPLAY_MAP::CalcBitmapSize

    SYNOPSIS:   Calculates the size of the bitmap, in bytes

    ENTRY:      pbihdr - pointer to the bitmap header info
                (just fetched from the locked resource)

    RETURNS:    Count of bytes

    NOTES:
        CODEWORK - make this a member function (private)

    HISTORY:
        beng        22-Oct-1991 Created

********************************************************************/

static UINT CalcBitmapSize( const BITMAPINFOHEADER * pbihdr )
{
    UIASSERT( pbihdr->biSizeImage < 65534L ); // Catch any overflows

    // 0 denotes "normal size."  Will not be zero if compressed, etc.

    if (pbihdr->biSizeImage != 0L)
        return (UINT) (pbihdr->biSizeImage);

    UINT cbSize = pbihdr->biWidth * pbihdr->biBitCount;
    cbSize += 31;   // DIB scanlines must be DWORD aligned
    cbSize &= ~31;
    cbSize /= 8;    // convert bits to bytes
    cbSize *= pbihdr->biHeight;

    return cbSize;
}


/*******************************************************************

    NAME:       DISPLAY_MAP::DISPLAY_MAP

    SYNOPSIS:   Constructor for the display map object

    ENTRY:      bmid - Display map ID (actually a bitmap ID)

    EXIT:       Constructed, or else ReportError

    NOTES:

    HISTORY:
        Johnl       1-Mar-1991  Created
        rustanl     18-Jul-1991 Added more BASE error checking
        beng        04-Oct-1991 Win32 conversion
        beng        22-Oct-1991 Fix buffer-size, rsrc-handling bugs
        beng        07-Nov-1991 Error mapping
        beng        15-Jun-1992 Fix for bitmaps which aren't even DWORDs
        beng        03-Aug-1992 dllization

********************************************************************/

DISPLAY_MAP::DISPLAY_MAP( BMID bmid )
    : _bmid( bmid ),          // cache the ID for GUILTT
      _pbmMask( NULL ),
      _pbmBitmap( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    HMODULE hmod = BLT::CalcHmodRsrc(bmid);

    // Load the resource directly so we can access its bitmap information.

    HRSRC h = ::FindResource( hmod, MAKEINTRESOURCE( bmid ), RT_BITMAP );
    if (h == NULL)
    {
        ReportError(BLT::MapLastError(ERROR_INVALID_PARAMETER));
        return;
    }

    UINT cbBitmapSize = ::SizeofResource( hmod, h );

    HGLOBAL hRes = ::LoadResource( hmod, h );
    if (hRes == NULL)
    {
        ReportError(BLT::MapLastError(ERROR_INVALID_PARAMETER));
        return;
    }

    // Lock the bitmap data and make a copy of it for the mask and the bitmap.
    //
    LPBITMAPINFOHEADER lpBitmapData =
        (LPBITMAPINFOHEADER) ::LockResource( hRes );

    BUFFER buffBitmap( cbBitmapSize );
    BUFFER buffMask( cbBitmapSize );
    APIERR err;
    if ( (err = buffBitmap.QueryError()) != NERR_Success ||
         (err = buffMask.QueryError()  ) != NERR_Success )
    {
#if !defined(WIN32)
        ::UnlockResource( hRes );
        ::FreeResource( hRes );
#endif
        ReportError( err );
        return;
    }

    LPBITMAPINFOHEADER lpBitmapInfo =
        (LPBITMAPINFOHEADER) buffBitmap.QueryPtr();
    LPBITMAPINFOHEADER lpMaskInfo =
        (LPBITMAPINFOHEADER) buffMask.QueryPtr();
    //  Since both buffers above succeeded, these pointers should be
    //  non-NULL
    UIASSERT( lpBitmapInfo != NULL );
    UIASSERT( lpMaskInfo != NULL );

    ::memcpy( lpBitmapInfo, lpBitmapData, cbBitmapSize );
    ::memcpy( lpMaskInfo,   lpBitmapData, cbBitmapSize );
#if !defined(WIN32)
    ::UnlockResource( hRes );
    ::FreeResource( hRes );
#endif

    /* Get a pointer into the color table of the bitmaps, cache the number of
     * bits per pixel
     */
    DWORD *pdwRGBMask   = (DWORD *)( ((BYTE*)lpMaskInfo)   + lpMaskInfo->biSize   );
    DWORD *pdwRGBBitmap = (DWORD *)( ((BYTE*)lpBitmapInfo) + lpBitmapInfo->biSize );

    const INT nBitsPerPixel = lpMaskInfo->biBitCount;

    // Now we get pointers to the bits of the bitmap itself, get the transparent
    // color index and set the bits in the mask and the bitmap appropriately.
    //
    BYTE * pbMaskBits   = (BYTE *)(pdwRGBMask) +
                          ( 1 << ( nBitsPerPixel )) * sizeof( RGBQUAD );
    BYTE * pbBitmapBits = (BYTE *)(pdwRGBBitmap) +
                          ( 1 << ( nBitsPerPixel )) * sizeof( RGBQUAD );

    INT iTransColorIndex = GetTransColorIndex( pdwRGBMask,
                                               1 << nBitsPerPixel );
    const UINT cbBits = CalcBitmapSize(lpBitmapInfo);

    SetMaskBits( pbMaskBits, iTransColorIndex, nBitsPerPixel, cbBits);
    SetBitmapBits( pbBitmapBits, iTransColorIndex, nBitsPerPixel, cbBits);

    /* Create the bitmask bitmap based on the characteristics of the
     * display and store it in a newly created BIT_MAP object that
     * we keep around as a member.
     */
    SCREEN_DC dcScreen;
    if ( dcScreen.QueryHdc() == NULL )
    {
        ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
        return;
    }

    HBITMAP hMask   = ::CreateDIBitmap(dcScreen.QueryHdc(),
                                       lpMaskInfo,
                                       (DWORD)CBM_INIT,
                                       (BYTE*)pbMaskBits,
                                       (LPBITMAPINFO)lpMaskInfo,
                                       DIB_RGB_COLORS);
    if ( hMask == NULL )
    {
        ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
        return;
    }

    HBITMAP hBitmap = ::CreateDIBitmap(dcScreen.QueryHdc(),
                                       lpBitmapInfo,
                                       (DWORD)CBM_INIT,
                                       (BYTE*)pbBitmapBits,
                                       (LPBITMAPINFO)lpBitmapInfo,
                                       DIB_RGB_COLORS);
    if ( hBitmap == NULL )
    {
        ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
        ::DeleteObject( (HGDIOBJ)hMask );
        return;
    }

    err = ERROR_NOT_ENOUGH_MEMORY;
    _pbmMask = new BIT_MAP( hMask );
    _pbmBitmap = new BIT_MAP( hBitmap );

    if (   _pbmMask == NULL
        || _pbmBitmap == NULL
        || ((err = _pbmMask->QueryError()) != NERR_Success)
        || ((err = _pbmBitmap->QueryError()) != NERR_Success) )
    {
        ReportError( err );

        // Do only whatever cleanup wouldn't be done by dtor

        if (_pbmMask == NULL)
            ::DeleteObject((HGDIOBJ)hMask);
        if (_pbmBitmap == NULL)
            ::DeleteObject((HGDIOBJ)hBitmap);

        return;
    }
}


/*******************************************************************

    NAME:     DISPLAY_MAP::~DISPLAY_MAP

    SYNOPSIS: Display map destructor - deletes allocated display maps

    HISTORY:
        Johnl   1-Mar-1991      Created

********************************************************************/

DISPLAY_MAP::~DISPLAY_MAP()
{
    delete _pbmMask;
    delete _pbmBitmap;
    _pbmBitmap = _pbmMask = NULL;
}


/*******************************************************************

    NAME:     DISPLAY_MAP::QueryMaskHandle

    SYNOPSIS: Retrieves the handles to the twiddled mask bitmap and
              twiddled bitmap bitmap

    ENTRY:

    EXIT:

    NOTES:    Will assert out if the DISPLAY_MAP object failed to be
              constructed.

    HISTORY:
        Johnl   1-Mar-1991      Created

********************************************************************/

HBITMAP DISPLAY_MAP::QueryMaskHandle() const
{
    UIASSERT( !QueryError() );
    return _pbmMask->QueryHandle();
}


/*******************************************************************

    NAME:       DISPLAY_MAP::QueryBitmapHandle

    SYNOPSIS:   Retrieves the handles to the twiddled mask bitmap and
                twiddled bitmap bitmap

    NOTES:
        Will assert out if the DISPLAY_MAP object failed to be constructed.

    HISTORY:
        Johnl   1-Mar-1991      Created

********************************************************************/

HBITMAP DISPLAY_MAP::QueryBitmapHandle() const
{
    UIASSERT( !QueryError() );
    return _pbmBitmap->QueryHandle();
}


/*******************************************************************

    NAME:       DISPLAY_MAP::QueryHeight

    SYNOPSIS:   Gets the width and height in pixels of the display map

    NOTES:      It is assumed the bitmap and mask are the same dimensions

    HISTORY:
        Johnl       01-Mar-1991 Created
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

UINT DISPLAY_MAP::QueryHeight() const
{
    UIASSERT( !QueryError() );
    return _pbmBitmap->QueryHeight();
}


/*******************************************************************

    NAME:     DISPLAY_MAP::QueryWidth

    SYNOPSIS: Gets the width and height in pixels of the display map

    ENTRY:

    EXIT:

    NOTES:    It is assumed the bitmap and mask are the same dimensions

    HISTORY:
        Johnl       01-Mar-1991 Created
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

UINT DISPLAY_MAP::QueryWidth() const
{
    UIASSERT( !QueryError() );
    return _pbmBitmap->QueryWidth();
}


/*******************************************************************

    NAME:     DISPLAY_MAP::SetMaskBits

    SYNOPSIS: Given a pointer to the bitmap bits, this method creates the
              actual mask by setting all transparent bits to black and all
              non-transparent bits to white.  The mask is meant to
              be used with bitblt functions.

    ENTRY:    pbBits points to the first byte of the bitmap data
              nTransColor is the index of the bit pattern to replace with black
              cbSize is the count of bytes in this bitmap
              nBitsPerPixel is the number of bits that make up each pixel

    EXIT:     The mask bitmap will have all transparent bits set to black and
              all non-transparent bits set to white.

    NOTES:
        We only accept 4 and 8 bit per pixel bitmaps

    HISTORY:
        Johnl       4-Mar-1991  Created
        beng        04-Oct-1991 Win32 conversion
        beng        23-Oct-1991 Add monochrome sauve-qui-peut

********************************************************************/

VOID DISPLAY_MAP::SetMaskBits( BYTE * pbBits,
                               INT    nTransColorIndex,
                               INT    nBitsPerPixel,
                               UINT   cbSize )
{
    /* We only handle 4 bits per pixel or 8 bits per pixel */
    UIASSERT( nBitsPerPixel == 4 || nBitsPerPixel == 8 );

    // Fall-through (retail build): should we somehow get a mono
    // bitmap, make its map completely empty.
    //
    if (nBitsPerPixel == 1)
    {
        while (cbSize--)
            *pbBits++ = 0xff;
        return;
    }

    BYTE *pbEnd = pbBits + cbSize;
    while ( pbBits < pbEnd )
    {
        if ( nBitsPerPixel == 8 )
            *pbBits = (BYTE) (((INT)*pbBits == nTransColorIndex) ? 0x00 : 0xff);
        else
        {
            /* Zap the upper nibble and/or the lower nibble if the nibble
             * is the transparent color index.
             */
            *pbBits = (BYTE) ((((INT)(*pbBits >> 4) == nTransColorIndex) ? 0x0f : 0xff)
                              &
                             (((INT)(*pbBits & 0x0f) == nTransColorIndex) ? 0xf0 : 0xff));
        }
        pbBits++;
    }
}


/*******************************************************************

    NAME:     DISPLAY_MAP::SetBitmapBits

    SYNOPSIS: Given a pointer to the bitmap bits, this method modifies
              the main bitmap.  It changes the transparent color to
              white and ignores the non-transparent colors.

    ENTRY:    pbBits points to the first byte of the bitmap data
              nTransColor is the index of the bit pattern to replace with black
              cbSize is the count of bytes in this bitmap
              nBitsPerPixel is the number of bits that make up each pixel

    EXIT:     The bitmap will have all transparent colors changed to white,
              everything else stays the same.

    NOTES:    We only accept 4 and 8 bit per pixel bitmaps

    HISTORY:
        Johnl       4-Mar-1991  Created
        beng        04-Oct-1991 Win32 conversion
        beng        23-Oct-1991 Add monochrome sauve-qui-peut

********************************************************************/

VOID DISPLAY_MAP::SetBitmapBits( BYTE * pbBits,
                                 INT    nTransColorIndex,
                                 INT    nBitsPerPixel,
                                 UINT   cbSize )
{
    /* We only handle 4 bits per pixel or 8 bits per pixel */
    UIASSERT( nBitsPerPixel == 4 || nBitsPerPixel == 8 );

    // Fall-through (retail build): should we somehow get a mono
    // bitmap, leave it be.
    //
    if (nBitsPerPixel == 1)
        return;

    BYTE *pbEnd = pbBits + cbSize;
    while ( pbBits < pbEnd )
    {
        if ( nBitsPerPixel == 8 )
            *pbBits = (BYTE)(((INT)*pbBits == nTransColorIndex) ? 0xff : *pbBits);
        else
        {
            /* Set the upper and/or lower nibble if that nibble is the
             * transparent color index.  If it is not, we preserve the
             * nibble.
             */

            *pbBits = (BYTE) ((((INT)(*pbBits >> 4) == nTransColorIndex) ? 0xf0 : *pbBits & 0xf0)
                              |
                             (((INT)(*pbBits & 0x0f) == nTransColorIndex) ? 0x0f : *pbBits & 0x0f));
        }
        pbBits++;
    }
}


/*******************************************************************

    NAME:       DISPLAY_MAP::GetTransColorIndex

    SYNOPSIS:   Finds the index into the color table of the transparent color
                (i.e., the RGB value that == DISPLAY_MAP_TRANS_COLOR).

    ENTRY:      pdwRGB - Pointer to the bitmaps RGB color table
                nNumDWords - number of RGB quads in the color table

    EXIT:

    RETURNS:    Index of the transparent color in the RGB table, or 0
                if not found.

        The user should assume this routine will
        succeed.  Even if it doesn't, the bitmaps only look weird
        which means we weren't passed a correct "Green" bitmap.
        We assert out under DEBUG if the transparent color isn't found.

    NOTES:
        The transparent color must occur at least once in the bitmap
        It is assumed the color will not occur multiple times in the
        color index table.

    HISTORY:
        Johnl   4-Mar-1991      Created

********************************************************************/

INT DISPLAY_MAP::GetTransColorIndex( DWORD *pdwRGB, INT nNumDWords ) const
{
    INT iTransColorIndex = 0;
    while ( iTransColorIndex < nNumDWords  )
    {
        if ( pdwRGB[iTransColorIndex] == DISPLAY_MAP_TRANS_COLOR )
            break;
        iTransColorIndex++;
    }

    /* Make sure we found the color
     */
    if ( iTransColorIndex >= nNumDWords )
    {
        ASSERTSZ(FALSE, "DISPLAY_MAP::GetTransColorIndex: transparent color not found in bitmap");
        iTransColorIndex = 0;
    }

    return iTransColorIndex;
}


/*******************************************************************

    NAME:       DISPLAY_MAP::Paint

    SYNOPSIS:   Using the previously created mask, Paint draws the
                bitmap with a transparent background.

    ENTRY:  hdc - handle to destination DC into which to paint
            x   - origin of destination, x coord
            y   - origin of destination, y coord

    EXIT:

    RETURNS:    Return of Windows BitBlt (fSuccess)

    NOTES:
        Bitmaps are drawn by first ORing in a mask bitmap,
        which preserves everything that's supposed to be
        transparent (black in the mask) and turns everything
        that's going to be redrawn to white (white areas in
        the mask).  Then AND in the main bitmap to draw the
        image.  See SetMaskBits of this class.

    HISTORY:
        Johnl       4-Mar-1991  Scavenged from original code (rustanl/gregj)
        beng        04-Oct-1991 Win32 conversion
        beng        15-Jun-1992 Performance tweaks

********************************************************************/

BOOL DISPLAY_MAP::Paint( HDC hdc, INT x, INT y ) const
{
    DEVICE_CONTEXT dc( hdc );
    MEMORY_DC memdc( dc );

    if ( memdc.QueryHdc() == NULL )
        return FALSE;

    // These are worth caching, since each involves a GetObject call

    const UINT dx = QueryWidth();
    const UINT dy = QueryHeight();

    // No point in saving previous object - we'll discard this DC soon

    memdc.SelectBitmap( QueryMaskHandle() );

    BOOL fSuccess = dc.BitBlt( x, y, dx, dy,
                               memdc,
                               0, 0,
                               SRCPAINT );
    if ( fSuccess )
    {
        memdc.SelectBitmap( QueryBitmapHandle() );

        fSuccess = dc.BitBlt( x, y, dx, dy,
                              memdc,
                              0, 0,
                              SRCAND );
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltapwin.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltapwin.cxx
    Implementation of BLT application window classes


    FILE HISTORY:
        beng        13-May-1991     Created
        terryk      25-Jul-1991     Add WM_GETMINMAXINFO to the dispatcher
        rustanl     05-Sep-1991     Added Close

*/

#include "pchblt.hxx"   // Precompiled header

/*******************************************************************

    NAME:       APP_WINDOW::APP_WINDOW

    SYNOPSIS:   Construct a new application window

    ENTRY:      xyPos       - origin of window on screen
                dxySize     - size of window
                nlsTitle    - caption of window
                pszIcon     - name of icon resource
                pszMenu     - name of menu resource

    NOTES:

    HISTORY:
        beng        08-Jul-1991 SetCaption changed to SetText
        beng        01-Nov-1991 Use MapLastError
        beng        03-Aug-1992 Use IDRESOURCE

********************************************************************/

APP_WINDOW::APP_WINDOW( XYPOINT xyPos, XYDIMENSION dxySize,
                        const NLS_STR &    nlsTitle,
                        const IDRESOURCE & idIcon,
                        const IDRESOURCE & idMenu )
    : CLIENT_WINDOW( WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, NULL ),
      _hmenu(0),
      _hicon(0)
{
    if (QueryError())
        return;

    SetPos(xyPos);
    SetSize(dxySize);
    SetText(nlsTitle);
    if (!SetMenu(idMenu) || !SetIcon(idIcon))
    {
        ReportError(BLT::MapLastError(ERROR_INVALID_FUNCTION));
        return;
    }
}


APP_WINDOW::APP_WINDOW( const NLS_STR &    nlsTitle,
                        const IDRESOURCE & idIcon,
                        const IDRESOURCE & idMenu )
    : CLIENT_WINDOW( WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, NULL ),
      _hmenu(0),
      _hicon(0)
{
    if (QueryError())
        return;

    SetText(nlsTitle);

    if (!SetMenu(idMenu) || !SetIcon(idIcon))
    {
        ReportError(BLT::MapLastError(ERROR_INVALID_FUNCTION));
        return;
    }
}


/*******************************************************************

    NAME:       APP_WINDOW::~APP_WINDOW

    SYNOPSIS:   Destructor for APP_WINDOW.
                Releases resources held by the window.

    NOTES:
        As Windows will clean up after the menu (it being attached
        to the window via SetMenu), this code must not DestroyMenu it.

    HISTORY:
        beng        08-Jul-1991     Created

********************************************************************/

APP_WINDOW::~APP_WINDOW()
{
    if (_hicon != 0)
    {
#if !defined(WIN32)
        // There is currently no way to set this to any system icon.
        // Hence FreeResource is always correct.
        //
        ::FreeResource(_hicon);
#endif
    }
}


/*******************************************************************

    NAME:       APP_WINDOW::SetMenu

    SYNOPSIS:   Establishes the menubar for an application window

    ENTRY:      pszMenuResource - names the menu resource

    EXIT:       Resource has been loaded;
                menubar has been drawn on the window

    RETURNS:    FALSE if resource is bad or other error

    NOTES:

    HISTORY:
        beng        08-Jul-1991 Header added
        beng        03-Aug-1992 Use IDRESOURCE; dllization

********************************************************************/

BOOL APP_WINDOW::SetMenu( const IDRESOURCE & idMenu )
{
    HMODULE hmod = BLT::CalcHmodRsrc(idMenu);

    HMENU hmenu = ::LoadMenu(hmod, idMenu.QueryPsz());
    if (hmenu == 0)
        return FALSE;

    BOOL fRet = ::SetMenu(QueryHwnd(), hmenu);
    if (!fRet)
    {
        fRet = ::DestroyMenu(hmenu);
        UIASSERT(fRet);
        return FALSE;
    }

    if (_hmenu != 0)
    {
        fRet = ::DestroyMenu(_hmenu);
        UIASSERT(fRet);
    }

    _hmenu = hmenu;
    ::DrawMenuBar(QueryHwnd());
    return TRUE;
}


/*******************************************************************

    NAME:       APP_WINDOW::QueryMenu

    SYNOPSIS:   Returns the handle to the current menubar

    NOTES:      If no menubar loaded, returns NULL

    HISTORY:
        beng        08-Jul-1991     Header added

********************************************************************/

HMENU APP_WINDOW::QueryMenu() const
{
    return _hmenu;
}


/*******************************************************************

    NAME:       APP_WINDOW::SetIcon

    SYNOPSIS:   Sets the icon for an application window

    ENTRY:      pszIconResource - string naming the resource

    EXIT:       Icon has been loaded for the window,
                but not necessarily drawn

    RETURNS:    TRUE if successful

    NOTES:

    HISTORY:
        beng        08-Jul-1991 Implemented
        beng        03-Aug-1992 Use IDRESOURCE; dllization

********************************************************************/

BOOL APP_WINDOW::SetIcon( const IDRESOURCE & idIcon )
{
    HMODULE hmod = BLT::CalcHmodRsrc(idIcon);
    HICON hicon = ::LoadIcon(hmod, idIcon.QueryPsz());
    if (hicon == NULL)
        return FALSE;

    // Maybe there's already an icon loaded?

    if (_hicon != NULL)
    {
#if !defined(WIN32)
        BOOL fRet = ::FreeResource(_hicon);
        UIASSERT(fRet);
#endif
        _hicon = NULL;
    }

    _hicon = hicon;
    return TRUE;
}


/*******************************************************************

    NAME:       APP_WINDOW::QueryIcon

    SYNOPSIS:   Returns the handle to the current app icon

    NOTES:      If no icon loaded, returns NULL

    HISTORY:
        beng        08-Jul-1991     Header added

********************************************************************/

HICON APP_WINDOW::QueryIcon() const
{
    return _hicon;
}


/*******************************************************************

    NAME:       APP_WINDOW::DispatchMessage

    SYNOPSIS:   Message dispatcher for application window

    ENTRY:      EVENT - an event in the window

    EXIT:

    RETURNS:    TRUE if message handled completely
                FALSE if system-standard behavior still needed

    NOTES:

    HISTORY:
        beng        08-Jul-1991 Added icon drawing, correct OnShutdown;
                                changed return type to LONG
        beng        30-Mar-1992 Corrected icon background drawing

********************************************************************/

LRESULT APP_WINDOW::DispatchMessage( const EVENT &event )
{
    switch (event.QueryMessage())
    {
    case WM_WININICHANGE:
    case WM_DEVMODECHANGE:
    case WM_TIMECHANGE:
    case WM_SYSCOLORCHANGE:
    case WM_PALETTECHANGED:
    case WM_FONTCHANGE:
        return OnSystemChange((const SYSCHANGE_EVENT &)event);

    case WM_GETMINMAXINFO:
        return OnQMinMax(( QMINMAX_EVENT & ) event );

    case WM_INITMENU:
        return OnMenuInit((const MENU_EVENT &)event);

    case WM_MENUSELECT:
        return OnMenuSelect((const MENUITEM_EVENT &)event);

    case WM_QUERYOPEN:
        return !MayRestore();

    case WM_QUERYENDSESSION:
        return !MayShutdown();

    case WM_ENDSESSION:
        if (event.QueryWParam())
            OnShutdown();
        return TRUE;

    case WM_QUERYDRAGICON:
        return (LRESULT)QueryIcon();

    case WM_ERASEBKGND:
        // If noniconic, Win will erase the background to the brush
        // supplied at class ct time.
        //
        if (!IsMinimized())
            break;

        // When iconic, do not erase the background; the DrawIcon
        // code will do so at paint time.
        //
        return 1;

    case WM_PAINT:
        // Dispatch OnPaintReq when noniconic.
        //
        if (!IsMinimized())
            break;

        // Iconic appwindow needs an icon drawn, since none
        // is supplied by the winclass.
        //
        return DrawIcon();

    case WM_COMMAND:
        {
            const CONTROL_EVENT & ctrle = (const CONTROL_EVENT &)event;

            if (ctrle.QueryHwnd() == 0)
                return OnMenuCommand((MID)ctrle.QueryCid());
            else
                return OnCommand((const CONTROL_EVENT &)ctrle);
        }
    }

    // Message not handled (default)
    //
    return CLIENT_WINDOW::DispatchMessage(event);
}


/*******************************************************************

    NAME:       APP_WINDOW::OnMenuInit

    SYNOPSIS:   Called when a menu is first pulled down

    ENTRY:      Event from Windows

    RETURNS:    TRUE if client handles message

    HISTORY:
        beng        15-Oct-1991 Header added

********************************************************************/

BOOL APP_WINDOW::OnMenuInit( const MENU_EVENT & event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       APP_WINDOW::OnMenuSelect

    SYNOPSIS:   Called when a menu item is selected

    ENTRY:      Event from Windows

    RETURNS:    TRUE if client handles message

    CAVEATS:
        Do not confuse with OnMenuCommand.

    HISTORY:
        beng        15-Oct-1991 Header added

********************************************************************/

BOOL APP_WINDOW::OnMenuSelect( const MENUITEM_EVENT & event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       APP_WINDOW::OnMenuCommand

    SYNOPSIS:   Called upon a menu command from the user

    ENTRY:      mid - ID of menu item chosen

    RETURNS:    TRUE if menu command handled

    HISTORY:
        beng        08-Jul-1991     Header added

********************************************************************/

BOOL APP_WINDOW::OnMenuCommand( MID mid )
{
    UNREFERENCED(mid);
    return FALSE;
}


/*******************************************************************

    NAME:       APP_WINDOW::MayRestore

    SYNOPSIS:   Called upon a request to de-iconize the app

    RETURNS:    FALSE to avoid expanding icon; TRUE otherwise

    NOTES:      Default implementation simply returns TRUE

    HISTORY:
        beng        14-May-1991     Created

********************************************************************/

BOOL APP_WINDOW::MayRestore()
{
    return TRUE;
}


/*******************************************************************

    NAME:       APP_WINDOW::MayShutdown

    SYNOPSIS:   Called upon a request to terminate the app

    RETURNS:    FALSE to avoid shutdown; TRUE otherwise

    NOTES:      This default implementation simply returns TRUE,
                meaning that any request to shutdown succeeds.

    HISTORY:
        beng        14-May-1991     Created

********************************************************************/

BOOL APP_WINDOW::MayShutdown()
{
    return TRUE;
}


/*******************************************************************

    NAME:       APP_WINDOW::OnShutdown

    SYNOPSIS:   Called before a forced app shutdown

    CAVEATS:    This member should implement a complete
                synchronous cleanup of the application.  Windows
                can terminate at any time after this member returns.

    NOTES:      Should this default implementation force app seppuku
                with a "delete this" or some such?

    HISTORY:
        beng        08-Jul-1991     Return type changed to "void"

********************************************************************/

VOID APP_WINDOW::OnShutdown()
{
    return; // does nothing... yet
}


// CODEWORK: document following two members

BOOL APP_WINDOW::OnSystemChange( const SYSCHANGE_EVENT & event )
{
    UNREFERENCED(event);
    return FALSE;
}


// Achtung!  INTENTIONAL non-const "event" reference!

BOOL APP_WINDOW::OnQMinMax( QMINMAX_EVENT & event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       APP_WINDOW::OnCloseReq

    SYNOPSIS:   Called upon a request to close the application window

    RETURNS:    TRUE

    NOTES:      This default implementation terminates the application.

    HISTORY:
        beng        14-May-1991     Created

********************************************************************/

BOOL APP_WINDOW::OnCloseReq()
{
    ::PostQuitMessage(0);

    return TRUE;
}


/*******************************************************************

    NAME:       APP_WINDOW::OnPaintReq

    SYNOPSIS:   Paint-my-window stub

    ENTRY:      A WM_PAINT finally made its way through the queue

    EXIT:       "Invalid" region has been validated

    RETURNS:    TRUE, always

    NOTES:
        This default implementation does nothing of interest

    HISTORY:
        beng        14-May-1991     Created

********************************************************************/

BOOL APP_WINDOW::OnPaintReq()
{
    HWND hwnd = QueryHwnd();
    PAINTSTRUCT ps;

    ::BeginPaint(hwnd, &ps);
    ::EndPaint(hwnd, &ps);

    return TRUE;
}


/*******************************************************************

    NAME:       APP_WINDOW::DrawIcon

    SYNOPSIS:   Draw the current icon for the application

    ENTRY:      The window has received a paint request while iconic.

    EXIT:

    RETURNS:    TRUE if it could draw something for an app icon;
                FALSE if system defaults needed

    NOTES:      This is a private class member.

    HISTORY:
        beng        08-Jul-1991 Created
        beng        30-Mar-1992 Correct background paint

********************************************************************/

BOOL APP_WINDOW::DrawIcon()
{
    ASSERT( IsMinimized() );

    if (_hicon == 0)
        return FALSE;

    PAINT_DISPLAY_CONTEXT dc(this);

    ::DefWindowProc(QueryHwnd(), WM_ICONERASEBKGND,
                    (WPARAM)dc.QueryHdc(), (LPARAM)0L);
    dc.SetMapMode(MM_TEXT);
    dc.SetBkColor( ::GetSysColor(COLOR_BACKGROUND) );
    ::DrawIcon(dc.QueryHdc(), 0, 0, _hicon);

    return TRUE;
}


/*******************************************************************

    NAME:       APP_WINDOW :: GetPlacement

    SYNOPSIS:   Returns the "placement" for the window.  This includes
                the minimized position, the maximized position, and
                a number of other interesting goodies.

    ENTRY:      pwp                     - Points to a WINDOWPLACEMENT
                                          structure to receive the info.

    RETURNS:    APIERR                  - Any errors that occur.

    HISTORY:
        KeithMo     07-Aug-1992     Created.

********************************************************************/
APIERR APP_WINDOW :: GetPlacement( WINDOWPLACEMENT * pwp ) const
{
    APIERR err = ::GetWindowPlacement( QueryHwnd(), pwp )
                     ? NERR_Success
                     : (APIERR)::GetLastError();

    return err;

}   // APP_WINDOW :: GetPlacement


/*******************************************************************

    NAME:       APP_WINDOW :: SetPlacement

    SYNOPSIS:   Sets the "placement" for the window.  This includes
                the minimized position, the maximized position, and
                a number of other interesting goodies.

    ENTRY:      pwp                     - Points to a WINDOWPLACEMENT
                                          structure containing the info.

    RETURNS:    APIERR                  - Any errors that occur.

    HISTORY:
        KeithMo     07-Aug-1992     Created.

********************************************************************/
APIERR APP_WINDOW :: SetPlacement( const WINDOWPLACEMENT * pwp ) const
{
    APIERR err = ::SetWindowPlacement( QueryHwnd(), pwp )
                     ? NERR_Success
                     : (APIERR)::GetLastError();

    return err;

}   // APP_WINDOW :: SetPlacement


/*******************************************************************

    NAME:       APP_WINDOW :: DrawMenuBar

    SYNOPSIS:   Redraws the menu bar.  This method *must* be called
                to reflect any changes made to the window's menu.

    RETURNS:    APIERR                  - Any errors that occur.

    HISTORY:
        KeithMo     13-Oct-1992     Created.

********************************************************************/
APIERR APP_WINDOW :: DrawMenuBar( VOID ) const
{
    APIERR err = ::DrawMenuBar( QueryHwnd() )
                     ? NERR_Success
                     : (APIERR)::GetLastError();

    return err;

}   // APP_WINDOW :: DrawMenuBar


/*******************************************************************

    NAME:       APP_WINDOW::Close

    SYNOPSIS:   Closes the application window

    EXIT:       The window is closed

    HISTORY:
        rustanl     05-Sep-1991     Created

********************************************************************/

VOID APP_WINDOW::Close()
{
    Command( WM_CLOSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltapp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltapp.cxx
    APPLICATION class implementation

    FILE HISTORY:
        rustanl     17-Jun-1991 Created, mostly from APPSTART
        rustanl     15-Jul-1991 Code review changes (no functional
                                differences).  CR attended by
                                BenG, ChuckC, Hui-LiCh, TerryK, RustanL.
        beng        17-Oct-1991 Moved WinMain into this module
        beng        29-Jun-1992 Removed WinMain to the .hxx file
*/

#include "pchblt.hxx"   // Precompiled header

/*******************************************************************

    NAME:       APPLICATION::APPLICATION

    SYNOPSIS:   APPLICATION constructor.

    ENTRY:      hInstance -         Application's instance handle
                nCmdShow -          Show-window type (open/icon)

    EXIT:       _fMsgPopupIsInit -  TRUE if the MsgPopup mechanism was
                                    installed, and FALSE otherwise.
                                    If this mechanism was successfully
                                    installed, MsgPopup can be used to
                                    display messages.  _fMsgPopupIsInit
                                    is used in APPLICATION::Run.

    NOTES:
        Need to think about command-line access someday.
        Needs to pass along nCmdShow to BLT and Do The Right Thing.

    HISTORY:
        rustanl     17-Jun-1991 Created
        rustanl     09-Jul-1991 Added MEM_MASTER::Init
        rustanl     09-Sep-1991 Intialize BLT_MASTER_TIMER
        beng        18-Oct-1991 Win32 conversion
        beng        24-Apr-1992 Change command-line support
        beng        03-Aug-1992 Dllization of resources

********************************************************************/

APPLICATION::APPLICATION( HINSTANCE hInstance, INT nCmdShow,
                          UINT idMinR, UINT idMaxR,
                          UINT idMinS, UINT idMaxS )
    : _hInstance( hInstance ),
      _fMsgPopupIsInit( FALSE )
{
    if ( QueryError() != NERR_Success )
        return;

    UNREFERENCED( nCmdShow );

#if !defined(WIN32) // only needed for Win16
    ::init_strlib();
#endif

#if !defined(WIN32) // ditto
    if ( ! MEM_MASTER::Init() )
    {
        // This should never happen because MEM_MASTER::Init only
        // allocates some 30 bytes out of the local heap (in the
        // automatic data segment).  If this fails, it is probably
        // due to a programmer error, viz. not specifying a
        // "HEAP" in the .def file.
        //
        ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
        return;
    }
#endif

    APIERR err = BLT::Init( _hInstance, idMinR, idMaxR, idMinS, idMaxS );
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    _fMsgPopupIsInit = TRUE;        // MsgPopup is now available

    err = BLT_MASTER_TIMER::Init();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       APPLICATION::~APPLICATION

    SYNOPSIS:   APPLICATION destructor

    HISTORY:
        rustanl     17-Jun-1991 Created
        rustanl     09-Jul-1991 Added MEM_MASTER::Term
        rustanl     09-Sep-1991 Added BLT_MASTER_TIMER::Term
        beng        18-Oct-1991 Win32 conversion
        DavidHov    22-Nov-1991 Heap Residue checking for Win32
        beng        04-Aug-1992 Dllization

********************************************************************/

APPLICATION::~APPLICATION()
{
    BLT_MASTER_TIMER::Term();

    BLT::Term( _hInstance );

#if !defined(WIN32)
    if ( ! MEM_MASTER::Term() )
    {
        // There was some memory residue from allocations.  Warn
        // the programmer.
        //
        DBGEOL("APPLICATION termination: some memory residue exists");
    }
#else
    // The Win32 version checks its heap at DLL process detach time
#endif
}


/*******************************************************************

    NAME:       APPLICATION::Run

    SYNOPSIS:   Allows the application to run, by:
                    - verifying its construction
                    - running its message loop

    ENTRY:      An APPLICATION object after all of its constructors
                have been called.

    RETURNS:    The application's return code (from the pump).

    NOTES:
        This is a virtual member function.

        This method is analogous to DIALOG_WINDOW::Process.

    HISTORY:
        rustanl     17-Jun-1991 Created
        beng        09-Jul-1991 Added new FilterMessage scheme
        rustanl     29-Aug-1991 Virtualized Run
        beng        07-Oct-1991 Uses HAS_MESSAGE_PUMP::RunMessagePump

********************************************************************/

INT APPLICATION::Run()
{
    UIASSERT( QueryError() == NERR_Success );   // otherwise, this method
                                                // shouldn't have been
                                                // called

    return (INT)RunMessagePump();
}


/*******************************************************************

    NAME:       APPLICATION::DisplayCtError

    SYNOPSIS:   Displays a constructor error

    ENTRY:      err -       The error to be displayed

    NOTES:      Since construction failed, MsgPopup may not be
                available.  If so, no error is displayed.

    HISTORY:
        rustanl     04-Sep-1991     Created

********************************************************************/

VOID APPLICATION::DisplayCtError( APIERR err )
{
    ASSERTSZ( (err != NERR_Success), "APPLICATION construction failed" );

    if ( _fMsgPopupIsInit )
    {
        ::MsgPopup( (HWND)NULL, err );
    }
}


/*******************************************************************

    NAME:       APPLICATION::IsSystemInitialized

    SYNOPSIS:   Determines if the *system* is properly initialized.

    RETURNS:    BOOL - TRUE if system init OK, FALSE otherwise.

    NOTES:      This is a static method.

    HISTORY:
        keithmo     13-May-1993     Created

********************************************************************/

BOOL APPLICATION::IsSystemInitialized( VOID )
{
    return ( ::GetDesktopWindow() != NULL );

}   // APPLICATION::IsSystemInitialized
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltbutn.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltbutn.cxx
    BLT button control class implementations

    FILE HISTORY:
        beng        17-Sep-1991 Separated from bltctrl.cxx

*/

#include "pchblt.hxx"

/*
 * Winclass name for all Windows button controls.
 */
static const TCHAR *const _szClassName = SZ("button");


/**********************************************************************

    NAME:       BUTTON_CONTROL::BUTTON_CONTROL

    SYNOPSIS:   constructor class for the button control class

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-May-1991 Added app-window constructor
        beng        17-Sep-1991 Moved classname def'n into implementation

*********************************************************************/

BUTTON_CONTROL::BUTTON_CONTROL( OWNER_WINDOW * powin, CID cid )
    : CONTROL_WINDOW( powin, cid )
{
    //  nothing to do
}

BUTTON_CONTROL::BUTTON_CONTROL(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle )
    : CONTROL_WINDOW( powin, cid, xy, dxy, flStyle, _szClassName )
{
    //  nothing to do
}


/*******************************************************************

    NAME:       BUTTON_CONTROL::QueryEventEffects

    SYNOPSIS:   Virtual replacement for CONTROL_VALUE class

    ENTRY:

    EXIT:

    NOTES:      We currently consider all messages a value change message.

    HISTORY:
        Johnl       25-Apr-1991 Created
        beng        31-Jul-1991 Renamed, from QMessageInfo
        beng        04-Oct-1991 Win32 conversion
        KeithMo     27-Oct-1992 Relocated here from STATE_BUTTON_CONTROL.

********************************************************************/

UINT BUTTON_CONTROL::QueryEventEffects( const CONTROL_EVENT & e )
{
    switch ( e.QueryCode() )
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:
        return CVMI_VALUE_CHANGE;

    default:
        break;
    }

    return CVMI_NO_VALUE_CHANGE;
}


/**********************************************************************

    NAME:       PUSH_BUTTON::PUSH_BUTTON

    SYNOPSIS:   constructor for the push button class

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-May-1991 Added app-window constructor
        beng        17-Sep-1991 Removed redundant classname arg

*********************************************************************/

PUSH_BUTTON::PUSH_BUTTON( OWNER_WINDOW * powin, CID cid )
    : BUTTON_CONTROL( powin, cid )
{
    //  nothing to do
}


PUSH_BUTTON::PUSH_BUTTON(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle )
    : BUTTON_CONTROL( powin, cid, xy, dxy, flStyle )
{
    //  nothing to do
}


/**********************************************************************

   NAME:       PUSH_BUTTON::MakeDefault

   SYNOPSIS:   send a DM_DEFAULT message to the window

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        rustanl     20-Nov-1990     Created

*********************************************************************/

VOID PUSH_BUTTON::MakeDefault()
{
    UIASSERT( QueryOwnerHwnd() != NULL );
    //
    //	Before we can set the new default button style, we have to
    //	remove the default button style from the old default button
    //

    LRESULT lr = ::SendMessage( QueryOwnerHwnd(), DM_GETDEFID, 0, 0 ) ;
    if ( HIWORD( lr ) == DC_HASDEFID )
    {
        INT idCurrentDefault = LOWORD( lr );
        // check if this button is already default
        if ( idCurrentDefault == (INT)QueryCid() )
        {
            return;
        }

	HWND hwndOldDefButton = ::GetDlgItem( QueryOwnerHwnd(),
					      idCurrentDefault ) ;
	UIASSERT( hwndOldDefButton != NULL ) ;

#ifdef DEBUG
	LONG lStyle = ::GetWindowLong( hwndOldDefButton, GWL_STYLE ) ;

	//
	//  The button window styles are not bitmasks and the high word of
	//  the long comes back with other style info.	Since all of the button
	//  styles we are interested in are less then 15, we will just lop off
	//  the upper 28 bits.
	//
	UIASSERT( BS_PUSHBUTTON <= 0xf && BS_DEFPUSHBUTTON <= 0xf ) ;
	UIASSERT( ((lStyle & 0xf) == BS_PUSHBUTTON) ||
		  ((lStyle & 0xf) == BS_DEFPUSHBUTTON) ) ;
#endif //DEBUG

	::SendMessage( hwndOldDefButton,
		       BM_SETSTYLE,
		       MAKEWPARAM( BS_PUSHBUTTON, 0 ),
		       MAKELPARAM( TRUE, 0 )) ;
    }

    ::SendMessage( QueryOwnerHwnd(), DM_SETDEFID, QueryCid(), 0L );
    Command( BM_SETSTYLE,
	     MAKEWPARAM( BS_DEFPUSHBUTTON, 0 ),
	     MAKELPARAM( TRUE, 0 )) ;
}


/*********************************************************************

    NAME:       STATE_BUTTON_CONTROL::STATE_BUTTON_CONTROL

    SYNOPSIS:   Constructor for the state button control baseclass

    ENTRY:

    EXIT:

    NOTES:
        The state button control coordinates the different sorts of
        state buttons: radio, check, tristate.  It corresponds to no
        particular control, and cannot be instantiated by itself.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-May-1991 Added app-window constructor
        beng        17-Sep-1991 Removed redundant classname arg
        beng        18-Sep-1991 Made "state" n-way

*********************************************************************/

STATE_BUTTON_CONTROL::STATE_BUTTON_CONTROL( OWNER_WINDOW * powin, CID cid )
    : BUTTON_CONTROL( powin, cid ),
      _nSaveCheck( 0 )
{
    // nothing to do
}

STATE_BUTTON_CONTROL::STATE_BUTTON_CONTROL(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle )
    : BUTTON_CONTROL( powin, cid, xy, dxy, flStyle ),
      _nSaveCheck( 0 )
{
    // nothing to do
}


/**********************************************************************

    NAME:       STATE_BUTTON_CONTROL::SetState

    SYNOPSIS:   Checks or unchecks a state button control.

    ENTRY:      nValue  Indicates whether the button should be checked or
                        unchecked.  TRUE indicates to check, whereas FALSE
                        indicates uncheck.  ("2" puts a tristate into
                        the indeterminate state.)

    HISTORY:
        rustanl     20-Nov-1990 Created, as SetCheck
        beng        18-Sep-1991 Made state n-way for tristates

*********************************************************************/

VOID STATE_BUTTON_CONTROL::SetState( UINT nValue )
{
    Command( BM_SETCHECK, nValue );
}


/*********************************************************************

    NAME:       STATE_BUTTON_CONTROL::QueryState

    SYNOPSIS:   Returns state of a state button.

    RETURN:     TRUE if the button is checked; FALSE otherwise.
                ("2" if tristate is indeterminate.)

    HISTORY:
        rustanl     20-Nov-1990 Created, as QueryCheck
        beng        18-Sep-1991 Made state n-way for tristates

*********************************************************************/

UINT STATE_BUTTON_CONTROL::QueryState() const
{
    return ( (UINT)Command( BM_GETCHECK ) );
}


/*******************************************************************

    NAME:     STATE_BUTTON_CONTROL::SaveValue

    SYNOPSIS: Saves the state of this button and unselects it

    EXIT:     Unselected button

    NOTES:
        Is 0 a suitable at-rest value for a tristate?

    HISTORY:
        Johnl       25-Apr-1991 Created
        beng        18-Sep-1991 Made state n-way for tristates

********************************************************************/

VOID STATE_BUTTON_CONTROL::SaveValue( BOOL fInvisible )
{
    UNREFERENCED( fInvisible );
    _nSaveCheck = QueryState();
    SetState( 0 );
}


/*******************************************************************

    NAME:       STATE_BUTTON_CONTROL::RestoreValue

    SYNOPSIS:   Restores STATE_BUTTON_CONTROL after SaveValue

    NOTES:      See CONTROL_VALUE for more details.

    HISTORY:
        Johnl       25-Apr-1991 Created
        beng        18-Sep-1991 Made state n-way for tristates

********************************************************************/

VOID STATE_BUTTON_CONTROL::RestoreValue( BOOL fInvisible )
{
    UNREFERENCED( fInvisible );
    SetState( _nSaveCheck );
}


/**********************************************************************

    NAME:       CHECKBOX::Toggle

    SYNOPSIS:   The method toggles the checked state of the checkbox.

    ENTRY:

    RETURN:     The new value of the checkbox

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990     Created

*********************************************************************/

BOOL CHECKBOX::Toggle()
{
    BOOL fNewState = ! QueryCheck();
    SetCheck( fNewState );

    return fNewState;
}


/*******************************************************************

    NAME:       TRISTATE::EnableThirdState

    SYNOPSIS:   Enable or disable a tristate's ability to go grey

    ENTRY:      fEnable - FALSE to disable, TRUE to enable

    EXIT:

    NOTES:
        This method attempts to retain the AUTO status of the checkbox.

    HISTORY:
        beng        19-Sep-1991 Created
        beng        13-Feb-1992 Use QueryStyle, new SetStyle

********************************************************************/

VOID TRISTATE::EnableThirdState( BOOL fEnable )
{
    ULONG lfValue = QueryStyle();

    BOOL fAuto = !!(lfValue & (BS_AUTO3STATE|BS_AUTOCHECKBOX));

    lfValue &= ~(0xF);

    if (fEnable)
    {
        lfValue |= (fAuto ? BS_AUTO3STATE : BS_3STATE);
    }
    else
    {
        lfValue |= (fAuto ? BS_AUTOCHECKBOX : BS_CHECKBOX);
    }

    SetStyle(lfValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltclwin.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltclwin.cxx
    Implementation of BLT client window classes

    FILE HISTORY:
        beng        09-May-1991     Created
        beng        13-Feb-1992     Relocated Repaint and RepaintNow to WINDOW
        KeithMo     07-Aug-1992     STRICTified.

*/
#include "pchblt.hxx"

extern "C"
{
    /* C7 CODEWORK - nuke this stub */
    LRESULT _EXPORT APIENTRY BltWndProc( HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam )
    {
        return CLIENT_WINDOW::WndProc(hwnd, nMsg, wParam, lParam);
    }
}


/* This is the name of the standard BLT windowclass */
const TCHAR * CLIENT_WINDOW::_pszClassName = SZ("BltClWin");


/*******************************************************************

    NAME:       CLIENT_WINDOW::Init

    SYNOPSIS:   Registers the single winclass used by client windows

    ENTRY:      BLT is uninitialized

    EXIT:       Winclass registered

    RETURNS:    Error code - 0 if successful

    NOTES:

    HISTORY:
        beng        18-Sep-1991 Changed return type
        beng        19-Oct-1991 Fixed background brush-load
        beng        26-Dec-1991 Works correctly when a client DLL has
                                already registered the class.
        beng        03-Aug-1992 True dllization delta

********************************************************************/

APIERR CLIENT_WINDOW::Init()
{
    WNDCLASS wc;
    BOOL     fSuccess;

    // See if anybody has already registered such a class.
    //

#if defined(DEBUG)
    fSuccess = ::GetClassInfo( hmodBlt, _pszClassName, &wc);
    if (fSuccess)
    {
        DBGEOL("BLT: wndclass already registered?");
        return ERROR_CLASS_ALREADY_EXISTS;
    }
#endif

    // Not already registered; assemble and attempt to register.
    //

    wc.style = CS_DBLCLKS;              // Yes! Give us double-clicks
    wc.lpfnWndProc = (WNDPROC) BltWndProc;
    wc.cbClsExtra = 0;                  // No per-class extra data.
    wc.cbWndExtra = 0;                  // No per-window extra data.
    wc.hInstance = hmodBlt;         // Hmod of common DLL
    wc.hIcon = NULL;                    // No icon
    wc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName = NULL;             // No menu
    wc.lpszClassName = _pszClassName;

    TRACEEOL( "CLIENT_WINDOW::Init(); registering class" );
    fSuccess = ::RegisterClass(&wc);
    DWORD RegErr = ::GetLastError();
    TRACEEOL( "CLIENT_WINDOW::Init(); registered class" );

    if (!fSuccess)
    {
        DBGEOL("Couldn't register BLT window class " << RegErr);
        return BLT::MapLastError(ERROR_CLASS_ALREADY_EXISTS);
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       CLIENT_WINDOW::Term

    SYNOPSIS:   Releases the single winclass used by client windows

    ENTRY:      BLT is terminating

    EXIT:       Theoretically, winclass would be unregistered....

    HISTORY:
        beng        18-Sep-1991 Added comment header
        JohnL       08-Jan-1992 Changed assert to DBGEOL; Not necessarily
                                an error if unregister fails so downgrade
                                severity for public consumption
        beng        03-Aug-1992 Fix for BLT-in-a-DLL

********************************************************************/

VOID CLIENT_WINDOW::Term()
{
    // I don't really need to unregister; USER would do it for me.

    TRACEEOL( "CLIENT_WINDOW::Term(); deregistering class" );
    BOOL fRet = ::UnregisterClass(_pszClassName, hmodBlt);
    TRACEEOL( "CLIENT_WINDOW::Term(); deregistered class" );
    if ( !fRet )
    {
        DWORD RegErr = ::GetLastError();
        DBGEOL("BLT: UnregisterClass on window class failed " << RegErr);
    }
}


/*******************************************************************

    NAME:       CLIENT_WINDOW::CLIENT_WINDOW

    SYNOPSIS:   Constructor for client-window

    ENTRY:
        flStyle     - dword of style bits for Windows
        pwndOwner   - pointer to owner-window
        pszClassName- name of winclass for window creation.

        With no arguments, attempts to inherit the window.

    EXIT:
        Window is created.

    NOTES:

    HISTORY:
        beng        30-Sep-1991 Uses ASSOCHWNDPWND

********************************************************************/

CLIENT_WINDOW::CLIENT_WINDOW(
    ULONG          flStyle,
    const WINDOW * pwndOwner,
    const TCHAR * pszClassName )
    : OWNER_WINDOW( pszClassName, flStyle, pwndOwner ),
      _assocThis( QueryHwnd(), this )
{
    if (QueryError())
        return;

    if ( !_assocThis )
    {
        ReportError( _assocThis.QueryError() );
        return;
    }
}

CLIENT_WINDOW::CLIENT_WINDOW()
    : OWNER_WINDOW(),
      _assocThis( QueryHwnd(), this )
{
    // This form of the constructor assumes that some other
    // agent has already created the window for us.

    if (QueryError())
        return;

    if ( !_assocThis )
    {
        ReportError( _assocThis.QueryError() );
        return;
    }
}


/*******************************************************************

    NAME:       CLIENT_WINDOW::DispatchMessage

    SYNOPSIS:   Message dispatcher for client window

    ENTRY:      EVENT - an event in the window

    EXIT:       Window has either taken a response to the event
                or else punted to Windows for default behavior

    RETURNS:    TRUE if message handled completely
                FALSE if system-standard behavior still needed

    NOTES:

    HISTORY:
        beng        08-Jul-1991     Return type changed to LONG

********************************************************************/

LRESULT CLIENT_WINDOW::DispatchMessage( const EVENT &event )
{
    switch (event.QueryMessage())
    {
    case WM_PAINT:
        return OnPaintReq();

    case WM_ACTIVATE:
        {
            const ACTIVATION_EVENT & ae = (const ACTIVATION_EVENT &)event;

            if (ae.IsActivating())
                return OnActivation((const ACTIVATION_EVENT &)ae);
            else
                return OnDeactivation((const ACTIVATION_EVENT &)ae);
        }

    case WM_SIZE:
        return OnResize((const SIZE_EVENT &)event);

    case WM_MOVE:
        return OnMove((const MOVE_EVENT &)event);

    case WM_CLOSE:
        return OnCloseReq();

    case WM_DESTROY:
        // Usually not called...
        //
        return OnDestroy();

    case WM_KEYUP:
        return OnKeyUp((const VKEY_EVENT &)event);

    case WM_KEYDOWN:
        return OnKeyDown((const VKEY_EVENT &)event);

    case WM_CHAR:
        return OnChar((const CHAR_EVENT &)event);

    case WM_MOUSEMOVE:
        return OnMouseMove((const MOUSE_EVENT &)event);

    case WM_LBUTTONDOWN:
        return OnLMouseButtonDown((const MOUSE_EVENT &)event);

    case WM_LBUTTONUP:
        return OnLMouseButtonUp((const MOUSE_EVENT &)event);

    case WM_LBUTTONDBLCLK:
        return OnLMouseButtonDblClick((const MOUSE_EVENT &)event);

    case WM_SETFOCUS:
        return OnFocus((const FOCUS_EVENT &)event);

    case WM_KILLFOCUS:
        return OnDefocus((const FOCUS_EVENT &)event);

    case WM_TIMER:
        return OnTimer((const TIMER_EVENT &)event);

    case WM_COMMAND:
        return OnCommand((const CONTROL_EVENT &)event);
    }

    // Now for user-defined messages
    //
    if (event.QueryMessage() >= WM_USER+100)
    {
        // C7 CODEWORK - remove redundant cast
        return OnUserMessage((const EVENT &)event);
    }

    // Message not handled (default)
    //
    return FALSE;
}


BOOL CLIENT_WINDOW::OnPaintReq()
{
    return FALSE;
}


BOOL CLIENT_WINDOW::OnActivation( const ACTIVATION_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnDeactivation( const ACTIVATION_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnResize( const SIZE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnMove( const MOVE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       CLIENT_WINDOW::OnCloseReq

    SYNOPSIS:   Called upon a request to close the window

    RETURNS:    FALSE

    NOTES:      This default implementation does nothing.

    HISTORY:
        beng        09-May-1991     Created
        beng        14-May-1991     Renamed (from "MayClose")

********************************************************************/

BOOL CLIENT_WINDOW::OnCloseReq()
{
    return FALSE;
}


/*******************************************************************

    NAME:       CLIENT_WINDOW::OnDestroy

    SYNOPSIS:   Called upon an *external* DestroyWindow.
                (Internal DestroyWindow calls created by the
                destructor will never cross this callback.)

    NOTES:
        This is not a dependable callback; please do not use it.

    HISTORY:
        beng        10-May-1991     Implemented

********************************************************************/

BOOL CLIENT_WINDOW::OnDestroy()
{
    return FALSE;
}


BOOL CLIENT_WINDOW::OnKeyDown( const VKEY_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnKeyUp( const VKEY_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnChar( const CHAR_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnMouseMove( const MOUSE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnLMouseButtonDown( const MOUSE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnLMouseButtonUp( const MOUSE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnLMouseButtonDblClick( const MOUSE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnFocus( const FOCUS_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnDefocus( const FOCUS_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnTimer( const TIMER_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnCommand( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnClick( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnDblClick( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnChange( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnSelect( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnEnter( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnDropDown( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


#if 0 // unimplemented
BOOL CLIENT_WINDOW::OnScrollBar( const SCROLL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnScrollBarThumb( const SCROLL_THUMB_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}
#endif


BOOL CLIENT_WINDOW::OnOther( const EVENT &event )
{
    return (BOOL)DefWindowProc( QueryHwnd(), event.QueryMessage(),
                                event.QueryWParam(), event.QueryLParam());
}


/*******************************************************************

    NAME:       CLIENT_WINDOW::WndProc

    SYNOPSIS:   Window-proc for BLT client windows

    ENTRY:      As per wndproc

    EXIT:       As per wndproc

    RETURNS:    The usual code returned by a wndproc

    NOTES:
        This is the wndproc proper for BLT client windows.  In
        the "extern C" clause above I declare a tiny exported stub
        which calls this.

    HISTORY:
        beng        10-May-1991 Implemented
        beng        20-May-1991 Add custom-draw control support
        beng        08-Jul-1991 DispatchMessage changed return type
        beng        15-Oct-1991 Win32 conversion

********************************************************************/

LRESULT CLIENT_WINDOW::WndProc( HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam )
{
    // First, handle messages which are not concerned about whether or
    // not hwnd can be converted into pwnd.

    switch (nMsg)
    {
    case WM_COMPAREITEM:
    case WM_DELETEITEM:
        return OWNER_WINDOW::OnLBIMessages(nMsg, wParam, lParam);
    }

    CLIENT_WINDOW * pwnd = CLIENT_WINDOW::HwndToPwnd( hwnd );
    if (pwnd == NULL)
    {
        // If HwndToPwnd returns NULL, then either CreateWindow call
        // has not yet returned, or else this class's destructor has
        // already been called - important, since this proc will continue
        // to receive messages such as WM_DESTROY.  Since Blt Windows perform
        // their WM_CREATE style code in their constructor, it's okay to
        // let most of the traditional early messages pass us by.
        //
        // The exception is WM_GETMINMAXINFO, I suppose...
        //
        return ::DefWindowProc(hwnd, nMsg, wParam, lParam);
    }

    switch (nMsg)
    {
    case WM_GUILTT:
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
    case WM_CHARTOITEM:
    case WM_VKEYTOITEM:
        // Responses to owner-draw-control messages are defined
        // in the owner-window class.
        //
        // It makes no sense to redefine one of these without
        // redefining the others.  Proper redefinition of control
        // behavior is done in the CONTROL_WINDOW::CD_* functions.
        //
        return pwnd->OnCDMessages(nMsg, wParam, lParam);
    }

    // Assemble an EVENT object, and dispatch appropriately.

    EVENT event( nMsg, wParam, lParam );
    LRESULT lRes = pwnd->DispatchMessage(event);
    if (lRes == 0)
        lRes = ::DefWindowProc(hwnd, nMsg, wParam, lParam);

    if (nMsg == WM_NCDESTROY)
    {
        // This is the last message that any window receives before its
        // hwnd becomes invalid.  This case will only be run if a BLT
        // client-window is destroyed by DestroyWindow instead of by
        // its destructor: a pathological case, since BLT custom controls
        // die by destructor even in a BLT dialog.
        //
        // Normally, a client window will receive DESTROY only after
        // its destructor has already disassociated the hwnd and pwnd.
        //
        pwnd->ResetCreator();
        // pwnd->DisassocHwndPwnd();
    }

    return lRes;
}


/*******************************************************************

    NAME:       CLIENT_WINDOW::CaptureMouse

    SYNOPSIS:   Capture mouse input

    ENTRY:      Window may or may not have the mouse

    EXIT:       Window has the mouse

    NOTES:
        Should this function return the previous owner?  The API
        does provide that.

    HISTORY:
        beng        10-May-1991     Implemented

********************************************************************/

VOID CLIENT_WINDOW::CaptureMouse()
{
    ::SetCapture(QueryHwnd());
}


/*******************************************************************

    NAME:       CLIENT_WINDOW::ReleaseMouse

    SYNOPSIS:   Release mouse input after a CaptureMouse

    ENTRY:      Window has the mouse

    EXIT:       Window no longer has the mouse

    NOTES:

    HISTORY:
        beng        10-May-1991     Implemented

********************************************************************/

VOID CLIENT_WINDOW::ReleaseMouse()
{
    ::ReleaseCapture();
}


/*******************************************************************

    NAME:       CLIENT_WINDOW::QueryRobustHwnd

    SYNOPSIS:   Returns a Hwnd for MsgPopup's parent

    RETURNS:    Dependable HWND

    NOTES:

    HISTORY:
        beng        10-May-1991     Implemented

********************************************************************/

HWND CLIENT_WINDOW::QueryRobustHwnd() const
{
    return QueryHwnd();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\applib\pch\usrmle.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    usrmle.cxx

    Contains code for manipulating the user accounts MLE in the user browser

    FILE HISTORY:
        Johnl   08-Dec-1992     Created

*/

#include "pchapplb.hxx"  //  Precompiled header

#if !defined(_CFRONT_PASS_)
#pragma hdrstop            //  This file creates the PCH
#endif

enum UI_SystemSid syssid[] =  { UI_SID_World,
                                UI_SID_Interactive,
                                UI_SID_CreatorOwner,
                                UI_SID_Network,
                                UI_SID_System,
                                UI_SID_Restricted,

                                UI_SID_Admins,
                                UI_SID_Replicator,
                                UI_SID_PowerUsers,
                                UI_SID_Guests,
                                UI_SID_Users,
                                UI_SID_BackupOperators,
                                UI_SID_AccountOperators,
                                UI_SID_SystemOperators,
                                UI_SID_PrintOperators
                              } ;
#define NUM_WELLKNOWN_SIDS   (6)
#define NUM_SIDS             (sizeof(syssid)/sizeof(syssid[0]))

DECLARE_SLIST_OF(OS_SID) ;  // Defined in browmemb.cxx

/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::ACCOUNT_NAMES_MLE

    SYNOPSIS:   MLE that allows the user to type account names.  Knows how
                to parse, recognizes well known and built in sids

    ENTRY:      fIsSingleSelect - Set to TRUE if only one name is allowed
                    (note that this processing is not dynamic)
                ulFlags - Selection flag passed to user browser dialog

    NOTES:

    HISTORY:
        Johnl   10-Dec-1992     Created
        Johnl   02-Jul-1993     Add names for well known/builtin SIDs
                                in the local machine language and the remote
                                machine language for comparison purposes

********************************************************************/

ACCOUNT_NAMES_MLE::ACCOUNT_NAMES_MLE( OWNER_WINDOW * powin,
                                      CID   cid,
                                      const TCHAR * pszServer,
                                      NT_USER_BROWSER_DIALOG * pUserBrowser,
                                      BOOL  fIsSingleSelect,
                                      ULONG ulFlags,
                                      enum  FontType fonttype )
    : MLE_FONT( powin, cid, fonttype ),
      _fIsSingleSelect( fIsSingleSelect ),
      _nlsTargetDomain(),
      _ulFlags        ( ulFlags ),
      _pUserBrowser   ( pUserBrowser )
{
    if ( QueryError() )
        return ;

    APIERR err = NERR_Success ;

    if ( err = _nlsTargetDomain.QueryError() )
    {
        ReportError( err ) ;
        return ;
    }

    OS_SID * apossidWellKnown[NUM_SIDS] ;
    for ( int i = 0 ; i < NUM_SIDS ; i++ )
    {
        apossidWellKnown[i] = NULL ;
    }

    { // Help C++ with Exit label
        //
        //  Fill in the array of well known PSIDs so we can do a lookup
        //
        PSID apsid[NUM_SIDS] ;
        for ( i = 0 ; i < NUM_SIDS ; i++ )
        {
            apossidWellKnown[i] = new OS_SID ;
            err = ERROR_NOT_ENOUGH_MEMORY ;
            if ( apossidWellKnown[i] == NULL ||
                 (err = apossidWellKnown[i]->QueryError()) ||
                 (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( syssid[i],
                                                             apossidWellKnown[i] )))
            {
                goto Exit ;
            }

            apsid[i] = apossidWellKnown[i]->QueryPSID() ;
        }

        //
        //  Lookup the well known names.  Make qualification relative to the built
        //  in domain so the builtin sids don't get qualified
        //
        LSA_POLICY LSAPolicyTarget( pszServer ) ;
        OS_SID ossidBuiltinDomain ;

        if ( err ||
            (err = LSAPolicyTarget.QueryError())        ||
            (err = ossidBuiltinDomain.QueryError())     ||
            (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_BuiltIn,
                                                        &ossidBuiltinDomain )))
        {
            ReportError( err ) ;
            return ;
        }

        if ((err = NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames(
                                          LSAPolicyTarget,
                                          ossidBuiltinDomain.QueryPSID(),
                                          apsid,
                                          NUM_SIDS,
                                          FALSE,
                                          &_strlistBuiltin)) )
        {
            DBGEOL("ACCOUNT_NAMES_MLE::ct - Error " << (ULONG) err
                    << " returned from GetQualifiedAccountNames") ;
            ReportError( err ) ;
            return ;
        }

        //
        //  Move the well known accounts into _strlistWellKnown and strip the
        //  account name from the builtin accounts
        //

        NLS_STR   nlsAccount ;
        NLS_STR   nlsDomain ;

        NLS_STR * pnls ;
        ITER_STRLIST iter(_strlistBuiltin) ;

        for ( i = 0 ; i < NUM_SIDS ; i++ )
        {
            if ( i < NUM_WELLKNOWN_SIDS )
            {
                if ( err = _strlistWellKnown.Add( pnls = _strlistBuiltin.Remove( iter )) )
                {
                    delete pnls ;
                    goto Exit ;
                }
#ifdef VERBOSE
                TRACEEOL("ACCOUNT_NAMES_MLE::ct - Adding well known name " <<
                       *pnls);
#endif
            }
            else
            {
                //
                //  Builtin accounts, strip the domain
                //
                pnls = iter.Next() ;
                UIASSERT( pnls != NULL ) ;
                if ( (err = NT_ACCOUNTS_UTILITY::CrackQualifiedAccountName(
                                                                   *pnls,
                                                                   &nlsAccount )) ||
                     (err = pnls->CopyFrom( nlsAccount )) )
                {
                    goto Exit ;
                }
#ifdef VERBOSE
                TRACEEOL("ACCOUNT_NAMES_MLE::ct - Adding built in name " <<
                       *pnls);
#endif
            }
        }
    }
Exit:
    if ( err )
        ReportError( err ) ;

    //
    //  Delete the SIDs we looked up
    //
    for ( i = 0 ; i < NUM_SIDS ; i++ )
    {
        delete apossidWellKnown[i] ;
    }
}

ACCOUNT_NAMES_MLE::~ACCOUNT_NAMES_MLE()
{
}

/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::ParseUserNameList

    SYNOPSIS:   Parses a user entered list of account names

    ENTRY:      pstrlstNames - STRLIST of parsed names suitable for doing
                    lookups on
                pszDomainName - Unqualified accounts are qualified with this
                                (and will be used for LsaLookupNames)
                pbuffStartPos - Buffer that will contain an array of name
                    start positions (in count of characters).

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      Double quotes ('"') and semi-colons (';') are not valid
                in account names.

    HISTORY:
        Johnl   05-Dec-1992     Created

********************************************************************/

APIERR ACCOUNT_NAMES_MLE::ParseUserNameList( STRLIST *       pstrlstNames,
                                             const TCHAR *   pszDomainName )
{
TRACETIMESTART;
    UIASSERT( pstrlstNames != NULL ) ;

    pstrlstNames->Clear() ;

TRACETIMESTART2( querytext );
    APIERR err = NERR_Success ;
    NLS_STR nlsNames ;
    if ( (err = nlsNames.QueryError()) ||
         (err = QueryText( &nlsNames )) )
    {
        return err ;
    }
TRACETIMEEND2( querytext, "ACCOUNT_NAMES_NLE::ParseUserNameList; QueryText " );

    ISTR istrBeginningOfString( nlsNames ) ;
    ISTR istrStart( nlsNames ) ;
    ISTR istrEnd  ( nlsNames ) ;
    ISTR istr     ( nlsNames ) ;
    NLS_STR * pnlsName = NULL ;
    BOOL fDone    = FALSE ;     // No more names to process
    BOOL fInName  = FALSE ;     // We're processing name (affects spaces)
    BOOL fInQuote = FALSE ;     // We're in a ""
    BOOL fNewName = FALSE ;     // When we've parsed a full name add it

    while ( !fDone && !err )
    {
        switch ( nlsNames.QueryChar( istr ) )
        {
        case TCH('\"'):
            if ( !fInQuote )
            {
                fInQuote = TRUE ;
                fInName  = TRUE ;
                ++istr ;
                istrStart = istr ;
            }
            else
            {
                //
                //  We've found the close quote so extract the string then
                //  start over again at the next semi-colon
                //
                istrEnd = istr ;
                fNewName = TRUE ;

                if ( nlsNames.strchr( &istr, TCH(';'), istr ) )
                    ++istr ;    // move past ';'
                else
                    fDone = TRUE ;
            }
            break ;

        case TCH(' '):
            {
                //
                //  Strip spaces
                //
                ISTR istrStartSpace = istr ;
                TCHAR tch ;
                while ( (tch = nlsNames.QueryChar( istr )) == TCH(' ') )
                    ++istr ;

                //
                //  Retain all spaces in quotes.
                //  else If we hit a ';' not in quotes
                //      or the end of the string, then we have a new string
                //  else if we aren't currently in a name, strip the space
                //
                if ( fInQuote )
                    continue ;
                else if ( tch == TCH(';') || tch == TCH('\0') )
                {
                    istrEnd = istrStartSpace ;
                    fNewName = TRUE ;
                    ++istr ;    // move past ';'
                    fDone = (tch == TCH('\0')) ;
                }
                else if ( !fInName )
                {
                    //
                    //  Strips leading spaces
                    //
                    istrStart = istr ;
                }
            }
            break ;

        case TCH('\0'):
            fDone = TRUE ;
            fNewName = TRUE ;
            istrEnd = istr ;
            break ;

        case TCH('\r'):       // Carriage return or line feed gets aliased
        case TCH('\n'):       // to the semi-colon
        case TCH(';'):
            if ( fInQuote )
                ++istr ;
            else
            {
                fNewName = TRUE ;
                istrEnd = istr ;
                ++istr ;
            }
            break ;


        default:
            if ( !fInName )
            {
                fInName = TRUE ;
                istrStart = istr ;
            }
            ++istr ;
            continue ;
        }

        //
        //  Add the extracted name if there is one to add
        //
        if ( fNewName )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            if ( NULL == (pnlsName = nlsNames.QuerySubStr( istrStart, istrEnd )) ||
                 (err = pnlsName->QueryError()) ||
                 (pnlsName->strlen() == 0)      ||
                 (err = pstrlstNames->Append( pnlsName )) )
            {
                delete pnlsName ;
                pnlsName = NULL ;
            }
            else if ( !IsWellKnownAccount( *pnlsName ) )
            {
                //
                //  We have a valid string, qualify if necessary
                //
                ISTR istr( *pnlsName ) ;

                //
                //  If the name leads with a slash, strip it
                //
                if ( pnlsName->QueryChar( istr ) == '\\' )
                {
                    ISTR istrEndWhack( istr ) ;
                    ++istrEndWhack ;
                    pnlsName->DelSubStr( istr, istrEndWhack ) ;
                }

                NLS_STR nlsAccountName( *pnlsName ) ;
                ALIAS_STR nlsDomain( pszDomainName ) ;
                if ( (err = nlsAccountName.QueryError())  ||
                     (!pnlsName->strchr( &istr, TCH('\\')) &&
                     (err = NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                                  pnlsName,
                                                  nlsAccountName,
                                                  nlsDomain))) )
                {
                    // fall through
                }
            }

            //
            //  We will only parse the first name if we are single select
            //
            if ( !err && pnlsName != NULL && IsSingleSelect() )
            {
                break ;
            }

            fInQuote  = FALSE ;
            fInName   = FALSE ;
            fNewName  = FALSE ;
            pnlsName  = NULL ;
            istrStart = istr ;
        }
    }

    //
    //  The last thing we do is remove duplicates from the strlist
    //
    RemoveDuplicateAccountNames( pstrlstNames ) ;

#ifdef VERBOSE
    TRACEEOL("Parsed the following names:") ;
    ITER_STRLIST iter( *pstrlstNames ) ;
    while ( pnlsName = iter.Next() )
    {
        TRACEEOL("\t\"" << pnlsName->QueryPch() << "\"") ;
    }
#endif

TRACETIMEEND( "ACCOUNT_NAMES_MLE::ParseUserNameList took " );
    return err ;
}

/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::IsWellKnownAccount

    SYNOPSIS:   Searches the well known account list for this name

    ENTRY:      nlsName - Name to search against

    RETURNS:    TRUE if this is a well known account name

    NOTES:

    HISTORY:
        Johnl   09-Dec-1992     Created

********************************************************************/

BOOL ACCOUNT_NAMES_MLE::IsWellKnownAccount( const NLS_STR & nlsName )
{
    ITER_STRLIST iter( _strlistWellKnown ) ;
    NLS_STR * pnls ;

#ifdef VERBOSE
    TRACEEOL("ACCOUNT_NAMES_MLE::IsWellKnownAccount - Checking " << nlsName );
#endif
    while ( pnls = iter.Next() )
    {
        if ( nlsName._stricmp( *pnls ) == 0 )
        {
#ifdef VERBOSE
            TRACEEOL("ACCOUNT_NAMES_MLE::IsWellKnownAccount - Matched against well known list");
#endif
            return TRUE ;
        }
    }

    //
    //  Next, look in the cache of items the user has already added.  If the
    //  name matches and this is a well known sid type, then this is a well
    //  known sid.  This gets around the problem of adding a well known
    //  account from a domain of a different language.
    //
    ITER_SL_OF(USER_BROWSER_LBI) iterCache( *_pUserBrowser->QuerySelectionCache()) ;
    USER_BROWSER_LBI * plbi;

    while ( plbi = iterCache.Next() )
    {
        if ( ::stricmpf( nlsName.QueryPch(), plbi->QueryDisplayName()) == 0 &&
             plbi->QueryType() == SidTypeWellKnownGroup)
        {
#ifdef VERBOSE
            TRACEEOL("ACCOUNT_NAMES_MLE::IsWellKnownAccount - Matched against Cached LBI list");
#endif
            return TRUE ;
        }
    }

    return FALSE ;
}


/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::RemoveDuplicateAccountNames

    SYNOPSIS:   Removes duplicate account names from the strlist

    ENTRY:      pstrlstNames - List of names generated by ParseUserNameList

    EXIT:       All duplicates will be removed

    NOTES:

    HISTORY:
        Johnl   08-Dec-1992     Created

********************************************************************/

void ACCOUNT_NAMES_MLE::RemoveDuplicateAccountNames( STRLIST * pstrlstNames )

{
    UIASSERT( pstrlstNames != NULL ) ;
    ITER_STRLIST iter1( *pstrlstNames ) ;
    ITER_STRLIST iter2( *pstrlstNames ) ;
    NLS_STR *pnls1, *pnls2 ;


    while ( (pnls1 = iter1.Next()) != NULL )
    {
        //
        //  Since we are scanning the same list, we will always find ourselves
        //  at least once.  It's more then once that we remove
        //
        BOOL fFoundOnce = FALSE ;

        //
        //  If we removed an item the last time through, the iterator
        //  has already moved on, so don't move it again
        //
        BOOL fDoNextString = TRUE ;

        while ( (pnls2 = (fDoNextString ? iter2.Next()
                                        : iter2.QueryProp())) != NULL )
        {
            fDoNextString = TRUE;
            if ( pnls1->_stricmp( *pnls2 ) == 0 )
            {
                if ( fFoundOnce )
                {
                    pnls2 = pstrlstNames->Remove( iter2 ) ;
                    ASSERT( pnls2 != NULL );
                    fDoNextString = FALSE;
                    delete pnls2 ;
                }
                else
                {
                    fFoundOnce = TRUE ;
                }
            }
        }
        iter2.Reset() ;
    }
}

/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::BuildNameStrFromAccountList

    SYNOPSIS:   Builds a concatenated string of accounts from the account
                strlist

    ENTRY:      pnlsNames - String to receive the list
                pstrlstNames - List of account names

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   09-Dec-1992     Created

********************************************************************/

APIERR ACCOUNT_NAMES_MLE::BuildNameListFromStrList(
                                        NLS_STR * pnlsNames,
                                        STRLIST * pstrlstNames )
{
TRACETIMESTART;
    APIERR err = NERR_Success ;

    ITER_STRLIST iter( *pstrlstNames ) ;
    NLS_STR * pnls ;
    *pnlsNames = SZ("") ;
    while ( pnls = iter.Next() )
    {
        if ( pnlsNames->strlen() != 0 )
        {
            if ( (err = pnlsNames->AppendChar( TCH(';') )) ||
                 (err = pnlsNames->AppendChar( TCH(' ') ))   )
            {
                break ;
            }
        }

        if ( err = pnlsNames->Append( *pnls ) )
        {
            break ;
        }
    }

TRACETIMEEND( "ACCOUNT_NAMES_MLE::BuildNameListFromStrList " );
    return err ;
}

/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::CreateLBIListFromNames

    SYNOPSIS:   Converts the list of names in strlstNames to a list of
                USER_BROWSER_LBIs that the selection iterator can handle

    ENTRY:      pszServer - Where to do the LsaLookup
                pszDomain - Current domain to use for unqualified names
                pslUsrBrowLBIsCache - Cached user browser LBIs
                pslReturn - The list of LBIs the user wants
                perrNameListError - Error code if can't find name etc
                pnlsFailingName - First account name that failed

    RETURNS:    NERR_Success if successful, error code otherwise.
                perrNameListError will contain the error caused by a bad
                name entry.

    NOTES:      strlstNames gets trashed.

    HISTORY:
        Johnl   05-Dec-1992     Created

********************************************************************/

APIERR ACCOUNT_NAMES_MLE::CreateLBIListFromNames(
                                   const TCHAR * pszServer,
                                   const TCHAR * pszDomain,
                                   SLIST_OF(USER_BROWSER_LBI) *pslUsrBrowLBIsCache,
                                   SLIST_OF(USER_BROWSER_LBI) *pslReturn,
                                   APIERR  * perrNameListError,
                                   NLS_STR * pnlsFailingName )
{
TRACETIMESTART;
    APIERR err = NERR_Success ;
    *perrNameListError = NERR_Success ;

    STRLIST strlstNames ;

TRACETIMESTART2( canon );
    if ( (err = CanonicalizeNames( pszDomain, &strlstNames )) != NERR_Success )
    {
        return err ;
    }
TRACETIMEEND2( canon, "CreateLBIListFromNames canonicalize time " );

    if ( strlstNames.QueryNumElem() == 0 )
        return NERR_Success ;

    ITER_SL_OF( USER_BROWSER_LBI ) iterCache( *pslUsrBrowLBIsCache ) ;
    ITER_SL_OF( USER_BROWSER_LBI ) iterReturn( *pslReturn ) ;
    ITER_STRLIST iterstrlst( strlstNames ) ;
    USER_BROWSER_LBI * plbi = NULL ;
    NLS_STR * pnls ;

    do { // error breakout

        //
        //  Scan the list of cached LBIs and see if there are any items that
        //  we don't have to lookup
        //

TRACETIMESTART2( scan );
        BOOL fDoNextCache = TRUE ;
        while ( (plbi = fDoNextCache ? iterCache.Next() : plbi ) != NULL && !err )
        {
            fDoNextCache = TRUE ;

            while ( (pnls = iterstrlst.Next()) != NULL && !err )
            {
                if ( ::stricmpf( plbi->QueryDisplayName(), pnls->QueryPch() ) == 0 )
                {
                    pnls = strlstNames.Remove( iterstrlst ) ;
#ifdef VERBOSE
                    TRACEEOL("CreateLBIListFromNames - Cache hit on " << *pnls) ;
#endif
                    delete pnls ;
                    plbi = pslUsrBrowLBIsCache->Remove( iterCache ) ;
                    if ( err = pslReturn->Add( plbi ) )
                    {
                        break ;
                    }

                    //
                    //  The remove bumps the iter to the next item so don't
                    //  do the next this time
                    //
                    fDoNextCache  = FALSE ;
                    plbi = iterCache.QueryProp() ;

                    break ;
                }
            }

            iterstrlst.Reset() ;
        }
TRACETIMEEND2( scan, "CreateLBIListFromNames scan time " );
        if ( err )
            break ;

        //
        //  If all of the items were in the cache, then we don't need to do
        //  anything else.
        //

        UINT cNames = strlstNames.QueryNumElem() ;
        if ( cNames == 0 )
        {
            TRACEEOL( "CreateLBIListFromNames all items cached" );
            break ;
        }

        //
        //  strlstNames now contains all the names that we have to lookup,
        //  so look them up
        //

        BUFFER buffpch( sizeof(LPTSTR) * cNames ) ;
        LSA_TRANSLATED_SID_MEM lsatsm ;
        LSA_REF_DOMAIN_MEM lsardm ;
        LSA_POLICY lsapol( pszServer ) ;

        if ( (err = buffpch.QueryError()) ||
             (err = lsatsm.QueryError())  ||
             (err = lsardm.QueryError())  ||
             (err = lsapol.QueryError())    )
        {
            break ;
        }

        LPTSTR * alptstr = (LPTSTR *) buffpch.QueryPtr() ;

TRACETIMESTART2( strip );
        iterstrlst.Reset() ;
        for ( UINT i = 0 ; i < cNames ; i++ )
        {
            pnls = iterstrlst.Next() ;
            UIASSERT( pnls != NULL ) ;

            //
            //  Builtin accounts on the target domain need to have the
            //  machine name replaced with the "BUILTIN\" domain
            //  (LsaLookupNames requires this).  Well known accounts need
            //  to have the domain qualified stripped.
            //
            //  These accounts should always be found (thus we
            //  don't need to resubstitute on error).
            //

            BOOL fFound ;
            if ( (err = ReplaceDomainIfBuiltIn( pnls, &fFound )) ||
                 (!fFound &&
                 (err = StripDomainIfWellKnown( pnls )))  )
            {
                break ;
            }

            alptstr[i] = (LPTSTR) pnls->QueryPch() ;
        }
TRACETIMEEND2( strip, "CreateLBIListFromNames strip time " );
        if ( err )
            break ;

#ifdef VERBOSE
        TRACEEOL("Looking up:") ;
        for ( i = 0 ; i < cNames ; i++ )
        {
            TRACEEOL( alptstr[i] ) ;
        }
#endif

TRACETIMESTART2( lookup );
        err = lsapol.TranslateNamesToSids( (const TCHAR * const *) alptstr,
                                           cNames,
                                           &lsatsm,
                                           &lsardm ) ;
TRACETIMEEND2( lookup, "CreateLBIListFromNames lookup time " );

        //
        //  If none of the groups could be found, then NERR_GroupNotFound
        //  is returned.  If only some of the groups couldn't be found, then
        //  success is returned.  ValidateNames will catch any non-mapped
        //  names
        //

        if ( err == NERR_GroupNotFound )
        {
            err = NERR_Success ;
        }

        if ( err )
        {
            DBGEOL("CreateLBIListFromNames - Error " << err << " returned "
                   << " from TranslateNamesToSids") ;
            break ;
        }

        //
        //  Check for names that couldn't be found or names that aren't
        //  allowed
        //

TRACETIMESTART2( check );
        if ( (err = CheckLookedUpNames( alptstr,
                                        &lsatsm,
                                        &strlstNames,
                                        pnlsFailingName,
                                        pszDomain,
                                        perrNameListError )) ||
             *perrNameListError )
        {
            break ;
        }
TRACETIMEEND2( check, "CreateLBIListFromNames check time " );

        //
        //  Create LBIs and add them to the return list
        //

        NLS_STR nlsDomainName, nlsAccountName ;
        if ( (err = nlsDomainName.QueryError()) ||
             (err = nlsAccountName.QueryError())  )
        {
            break ;
        }

        SLIST_OF(OS_SID) slossid ;
        BUFFER buffapsid( cNames * sizeof( OS_SID * )) ;

        if ( err = buffapsid.QueryError() )
            break ;

TRACETIMESTART2( sidarray );
        PSID * apsid = (PSID *) buffapsid.QueryPtr() ;
        for ( i = 0 ; i < cNames ; i++ )
        {
            NLS_STR * pnlsAccountName = iterstrlst.Next() ;
            OS_SID * possid = new OS_SID( lsardm.QueryPSID( lsatsm.QueryDomainIndex( i  ) ),
                                          lsatsm.QueryRID( i )) ;
            err = ERROR_NOT_ENOUGH_MEMORY ;
            if ( possid == NULL ||
                 (err = possid->QueryError()) ||
                 (err = slossid.Add( possid )) )
            {
                delete possid ;
                break ;
            }

            apsid[i] = possid->QueryPSID() ;
        }
        if ( err )
            break ;
TRACETIMEEND2( sidarray, "CreateLBIListFromNames sidarray time " );

TRACETIMESTART2( createfromsids );
        if ( err = ::CreateLBIsFromSids( apsid,
                                         cNames,
                                         apsid[0],    // dummy
                                         &lsapol,
                                         pszServer,
                                         NULL,
                                         pslReturn ))
        {
            // Fall through (and out)
        }
TRACETIMEEND2( createfromsids, "CreateLBIListFromNames createfromsids time " );

    } while (FALSE) ;

    //
    //  If an error occurred, we have to move the items in from the return
    //  list back into the cache list
    //
    if ( err || *perrNameListError )
    {
TRACETIMESTART2( errfix );
        iterReturn.Reset() ;
        while (  plbi = pslReturn->Remove( iterReturn ) )
        {
            if ( err = pslUsrBrowLBIsCache->Add( plbi ) )
            {
                //
                //  Hmmm, well, nothing we can do but clear the return list
                //  and get out
                //

                pslReturn->Clear() ;
                break ;
            }
        }
TRACETIMEEND2( errfix, "CreateLBIListFromNames errfix time " );
    }

TRACETIMEEND( "CreateLBIListFromNames total time " );

    return err ;
}

/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::CanonicalizeNames

    SYNOPSIS:   Forces the MLE to qualify unqualified names and remove
                duplicates

    ENTRY:      pszCurrentDomain - Domain to qualify unqualified names with

    EXIT:       The MLE will be reset with the new list of names

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The MLE will not be reset if an error occurs

    HISTORY:
        Johnl   10-Dec-1992     CReated

********************************************************************/

APIERR ACCOUNT_NAMES_MLE::CanonicalizeNames( const TCHAR * pszCurrentDomain,
                                             STRLIST * pstrlstNames )
{
TRACETIMESTART;
    UIASSERT( pszCurrentDomain != NULL ) ;

    STRLIST strlstTemp ;
    if (pstrlstNames == NULL)
        pstrlstNames = &strlstTemp;

    NLS_STR nlsNames ;
    APIERR err ;
    if ( (err = nlsNames.QueryError()) ||
         (err = ParseUserNameList( pstrlstNames, pszCurrentDomain )) ||
         (err = BuildNameListFromStrList( &nlsNames, pstrlstNames ))  )
    {
        // fall through
    }
    else
    {
        SetText( nlsNames ) ;
        Invalidate( TRUE ) ;        // Force update as soon as we canoned
    }

TRACETIMEEND( "ACCOUNT_NAMES_MLE::CanonicalizeNames total time " );
    return err ;
}


/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::ReplaceDomainIfBuiltIn

    SYNOPSIS:   Looks for any builtin accounts that are in the target domain
                (_nlsTargetDomain).  If it finds one, then it
                strips the domain.  Note we only do this for the target domain
                to impress upon the user that the built in sids are only valid
                in the target domain (accounts won't be found in other domains).

    ENTRY:      pnlsQualifiedAccount - String to check and modify if necessary
                pfFound - set to TRUE if this is a built in account

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   11-Dec-1992     Created

********************************************************************/

APIERR ACCOUNT_NAMES_MLE::ReplaceDomainIfBuiltIn(
                                                NLS_STR * pnlsQualifiedAccount,
                                                BOOL    * pfFound )
{

    APIERR err = NERR_Success ;
    NLS_STR nlsAccount ;
    NLS_STR nlsDomain ;
    *pfFound = FALSE ;

    if (!(err = nlsAccount.QueryError()) &&
        !(err = nlsDomain.QueryError()) &&
        !(err = NT_ACCOUNTS_UTILITY::CrackQualifiedAccountName(
                                                          *pnlsQualifiedAccount,
                                                          &nlsAccount,
                                                          &nlsDomain )) )
    {
        if( !::I_MNetComputerNameCompare( _nlsTargetDomain, nlsDomain ) )
        {
            NLS_STR * pnls ;
            ITER_STRLIST iter( _strlistBuiltin ) ;
            while ( pnls = iter.Next() )
            {
                if (  nlsAccount._stricmp( *pnls ) == 0 )
                {
                    err = pnlsQualifiedAccount->CopyFrom( nlsAccount ) ;
                    *pfFound = TRUE ;
                    break ;
                }
            }
        }
    }

    return err ;
}

/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::StripDomainIfWellKnown

    SYNOPSIS:   Looks for any well known account names and strips the domain
                if necessary (Lsa requires well known accounts to not be
                qualified).

    ENTRY:      pnlsAccount - String to check and modify if necessary

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   11-Dec-1992     Created

********************************************************************/

APIERR ACCOUNT_NAMES_MLE::StripDomainIfWellKnown( NLS_STR * pnlsAccount )
{
    APIERR err = NERR_Success ;

    NLS_STR nlsAccount ;
    if (!(err = nlsAccount.QueryError()) &&
        !(err = NT_ACCOUNTS_UTILITY::CrackQualifiedAccountName(
                                                          *pnlsAccount,
                                                          &nlsAccount )) )
    {
        NLS_STR * pnls ;
        ITER_STRLIST iter( _strlistWellKnown ) ;
        while ( pnls = iter.Next() )
        {
            if (  nlsAccount._stricmp( *pnls ) == 0 )
            {
                err = pnlsAccount->CopyFrom( nlsAccount ) ;
                break ;
            }
        }
    }

    return err ;
}

/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::CheckLookedUpNames

    SYNOPSIS:   Checks the selected names with the "USRBROWS_SHOW_*" and
                "USRBROWS_INCL_*" flags.  Prevents the user from typing in
                a name that the client doesn't want.

    ENTRY:      alptstr - Array of looked up names
                plsatsm - Translated sid mem
                pstrlist - Strlist representing the contents of the MLE, used
                    to locate and hi-lite the offending name
                pnlsFailingName - This will be filled with the first name
                    that failed so we can show the user in the error message.
                pszDomain - Domain qualifier for parsing names with
                perrNameListError - Error code indicating what error should
                    be shown to the user

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:

    HISTORY:
        Johnl   04-Jan-1992     Broke out, added exclusion functionality

********************************************************************/

APIERR ACCOUNT_NAMES_MLE::CheckLookedUpNames(
                                      LPTSTR      * alptstr,
                                      LSA_TRANSLATED_SID_MEM * plsatsm,
                                      STRLIST     * pstrlist,
                                      NLS_STR     * pnlsFailingName,
                                      const TCHAR * pszDomain,
                                      APIERR      * perrNameListError )
{
TRACETIMESTART;
    APIERR err = NERR_Success ;
    *perrNameListError = NERR_Success ;

    do { // error breakout

        //
        //  Check the accounts we looked up with the accounts the client
        //  requested.
        //

        BOOL fFoundBadAccount = FALSE ;
        ULONG iFailingName = 0 ;
        BOOL fFoundAllAccounts = !plsatsm->QueryFailingNameIndex( &iFailingName ) ;

        if ( fFoundAllAccounts )
        {
            for ( iFailingName = 0 ;
                  iFailingName < plsatsm->QueryCount() ;
                  iFailingName++ )
            {
                *perrNameListError = CheckNameType(
                        plsatsm->QueryUse( iFailingName ),
                        QueryFlags() );
                if ( *perrNameListError )
                {
                    fFoundBadAccount = TRUE ;
                    break ;
                }
            }
        }
        else
        {
            *perrNameListError = IDS_CANT_FIND_ACCOUNT ;
        }


        //
        //  Figure out which name failed (if any) and figure out where
        //  it occurred in the list so we can hi-lite it.
        //

        if ( !fFoundAllAccounts || fFoundBadAccount )
        {
            if ((err = pnlsFailingName->CopyFrom( alptstr[iFailingName] )) ||
                (err = ParseUserNameList( pstrlist, pszDomain )) )
            {
                break ;
            }

            ITER_STRLIST iterstrlst( *pstrlist ) ;
            NLS_STR * pnls ;
            INT IndexFailingNameStart = 0 ;
            INT IndexFailingNameEnd = 0 ;

#ifdef VERBOSE
            TRACEEOL("CreateLBILIstFromNames - Search for failing name " << *pnlsFailingName ) ;
#endif
            while ( pnls = iterstrlst.Next() )
            {
                if ( *pnlsFailingName == *pnls )
                {

                    IndexFailingNameEnd = IndexFailingNameStart +
                                          pnls->QueryNumChar() ;
                    break ;
                }

                //
                //  "+2" is for the " ;"
                //
                IndexFailingNameStart += pnls->QueryNumChar() + 2 ;
            }

            Command( EM_SETSEL,
                     (WPARAM) IndexFailingNameStart,
                     (LPARAM) IndexFailingNameEnd ) ;

        }
    } while ( FALSE ) ;

TRACETIMEEND( "ACCOUNT_NAMES_MLE::CheckLookedUpNames total " );
    return err ;
}

/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::CheckNameType

    SYNOPSIS:   Checks whether the application will accept names of this type.

    ENTRY:      use - type of name
                ulFlags - flags as passed to User Browser

    RETURNS:    NERR_Success if successful, error message otherwise.

    NOTES:

    HISTORY:
        Johnl   04-Jan-1992     Broke out, added exclusion functionality
        JonN    16-May-1994     Split from CheckLookedUpNames

********************************************************************/

APIERR ACCOUNT_NAMES_MLE::CheckNameType( SID_NAME_USE use, ULONG ulFlags )
{
    APIERR err = NERR_Success;
    switch ( use )
    {
    case SidTypeUser:
        if ( !(ulFlags & USRBROWS_SHOW_USERS) )
            err = IDS_CANT_ADD_USERS ;
        break ;

    case SidTypeGroup:
        if ( !(ulFlags & USRBROWS_SHOW_GROUPS) )
            err = IDS_CANT_ADD_GROUPS ;
        break ;

    case SidTypeAlias:
        if ( !(ulFlags & USRBROWS_SHOW_ALIASES) )
            err = IDS_CANT_ADD_ALIASES ;
        break ;

    case SidTypeWellKnownGroup:
        if ( !(ulFlags & USRBROWS_INCL_ALL) )
            err = IDS_CANT_ADD_WELL_KNOWN_GROUPS ;
        break ;
    }
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltbkgnd.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltbkgnd.cxx
    BLT background edit with non-default color

    FILE HISTORY:
        jonn        29-Sep-95   split from blttd.cxx
*/

#include "pchblt.hxx"  // Precompiled header


/*********************************************************************

    NAME:       BLT_BACKGROUND_EDIT::BLT_BACKGROUND_EDIT

    SYNOPSIS:   constructor

    HISTORY:
        jonn        05-Sep-95   Created

*********************************************************************/

BLT_BACKGROUND_EDIT::BLT_BACKGROUND_EDIT( OWNER_WINDOW *powin, CID cid )
    : EDIT_CONTROL( powin, cid )
{
    if ( QueryError() )
        return;

    //
    // Update the frame edit control to have a CLIENTEDGE and a frame
    //
    HWND hwnd = QueryHwnd();
    ASSERT( hwnd != NULL );
    LONG lExStyle = ::GetWindowLong(hwnd, GWL_EXSTYLE);
    if ( lExStyle == 0 )
    {
        DBGEOL("BLT_BACKGROUND_EDIT: GetWindowLong error " << ::GetLastError() );
    }
    if ( !::SetWindowLong( hwnd,
                           GWL_EXSTYLE,
                           lExStyle | WS_EX_CLIENTEDGE ) )
    {
        DBGEOL("BLT_BACKGROUND_EDIT: SetWindowLong error " << ::GetLastError() );
        ASSERT( FALSE );
    }
    if ( !::SetWindowPos( hwnd,
                NULL, 0, 0, 0, 0,
                SWP_NOMOVE | SWP_NOSIZE | SWP_DRAWFRAME | SWP_SHOWWINDOW ) )
    {
        DBGEOL("BLT_BACKGROUND_EDIT: SetWindowPos error " << ::GetLastError() );
        ASSERT( FALSE );
    }
}


/*********************************************************************

    NAME:       BLT_BACKGROUND_EDIT::~BLT_BACKGROUND_EDIT

    SYNOPSIS:   destructor

    HISTORY:
        jonn        05-Sep-95   Created

*********************************************************************/

BLT_BACKGROUND_EDIT::~BLT_BACKGROUND_EDIT()
{
}


/*******************************************************************

    NAME:       BLT_BACKGROUND_EDIT::OnCtlColor

    SYNOPSIS:   Intercepts WM_CTLCOLOR*.  This can be used to
                set the background color of controls to other
                than the default, for example to change the default
                background color for a static text control to
                the same background as for an edit control.

    ENTRY:

    EXIT:

    RETURNS:    brush handle if you handle it

    HISTORY:
        JonN            09/05/95          Created

********************************************************************/
HBRUSH BLT_BACKGROUND_EDIT::OnCtlColor( HDC hdc, HWND hwnd, UINT * pmsgid )
{
    ASSERT( pmsgid != NULL && hwnd == QueryHwnd() );
    *pmsgid = WM_CTLCOLOREDIT;
    return NULL;
#if 0
//
// Template code to manually force foreground and background colors.
// Normally it is sufficient to set *pmsgid to WM_CTLCOLOREDIT.
//
    REQUIRE( CLR_INVALID !=
              ::SetBkColor(   hdc, ::GetSysColor(COLOR_WINDOW) ) );
    REQUIRE( CLR_INVALID !=
              ::SetTextColor( hdc, ::GetSysColor(COLOR_WINDOWTEXT) ) );
    return ::GetSysColorBrush( COLOR_3DFACE );
//     NOTES:      ::GetSysColorBrush() returns a handle to the current
//                 default brush of this color.  It does not have to be
//                 freed.  This brush will remain in sync with the Colors
//                 CPL default colors if they change, so there is no need
//                 to intercept WM_SYSCOLORCHANGE.  This is new to WINVER4.
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltctrl.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltctrl.cxx
    BLT control hierarchy definitions

    FILE HISTORY:
        rustanl     20-Nov-1990 Created
        beng        11-Feb-1991 Uses lmui.hxx
        Johnl       23-Apr-1991 Moved RADIO_GROUP to bltgroup.cxx
        gregj       01-May-1991 Added GUILTT support
        beng        14-May-1991 Exploded blt.hxx into components
        beng        17-Sep-1991 Broke apart bltbutn, bltedit
        o-SimoP     02-Jan-1992 Added HIDDEN_CONTROL
        beng        18-May-1992 Added SCROLLBAR
*/
#include "pchblt.hxx"

const TCHAR * SCROLLBAR::_pszClassName = SZ("SCROLLBAR");


const TCHAR * CONTROL_WINDOW :: QueryEditClassName ()
{
    return SZ("edit") ;
}

const TCHAR * CONTROL_WINDOW :: QueryStaticClassName ()
{
    return SZ("static") ;
}

const TCHAR * CONTROL_WINDOW :: QueryListboxClassName ()
{
    return SZ("listbox") ;
}

const TCHAR * CONTROL_WINDOW :: QueryComboboxClassName ()
{
    return SZ("combobox") ;
}

/*********************************************************************

    NAME:       CONTROL_WINDOW::CONTROL_WINDOW

    SYNOPSIS:   Constructor for control window

    ENTRY:      Two forms.  One form appears in dialogs, and assumes
                that the control is defined in a resourcefile, having
                already been Created by Windows:

            powin        - pointer to dialog object owning the control
            cid          - ID of control

                while the other appears in standalone windows, and
                creates the control window itself:

            powin        - pointer to hosting window
            cid          - ID of control
            xy           - size of control
            dxy          - dimensions of control
            flStyle      - Windows-defined style bits for control window
            pszClassName - name of WindowClass for control.

    EXIT:       Success: window has been created and registered
                    with the owner window.
                Failure: owner window has its error flag set so that
                    future controls may elide construction

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        25-Apr-1991 Base-class constructor munged
        beng        17-May-1991 Added app-window constructor form
        beng        31-Jul-1991 Error reporting changed
        beng        07-Nov-1991 Error mapping

*********************************************************************/

CONTROL_WINDOW::CONTROL_WINDOW( OWNER_WINDOW * powin, CID cid )
    : WINDOW(),
      FORWARDING_BASE(powin),
      _cid( cid )
{
    // Did previous control in the window fail?
    //
    if (QueryError())
        return;

    // Did this control's window fail?
    //
    if ( WINDOW::QueryError() )
    {
        ReportError( WINDOW::QueryError() );
        return;
    }

    HWND hwnd = ::GetDlgItem( powin->QueryHwnd(), cid );
    if ( hwnd == NULL )
    {
        // In a properly built program, no control window object
        // should reference the wrong control ID.  Since the dialog
        // constructed successfully, GetDlgItem should be able to find
        // the given CID.
        //
        ASSERTSZ( FALSE, "Invalid control ID given" );

        ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
        return;
    }
    SetHwnd( hwnd );

    // Register the control with the owner window
    //
    if ( ! powin->AddControl( this ))
    {
        DBGEOL( "BLT: Insufficient memory to add control to owner window" );

        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }
}


CONTROL_WINDOW::CONTROL_WINDOW( OWNER_WINDOW * powin, CID cid,
                                XYPOINT xy, XYDIMENSION dxy,
                                ULONG flStyle, const TCHAR * pszClassName )
    : WINDOW(pszClassName, flStyle, powin, cid),
      FORWARDING_BASE(powin),
      _cid( cid )
{
    if ( QueryError() )
        return;

    if ( WINDOW::QueryError() )
    {
        ReportError( WINDOW::QueryError() );
        return;
    }

    // Sanity check: make sure that we're registered in the
    // parent window.  We need to be a child.

    UIASSERT(QueryHwnd() == ::GetDlgItem( powin->QueryHwnd(), cid ));

    // Position this control as requested.  (All windows are created
    // originally with the system default size and position.)

    SetPos(xy);
    SetSize(dxy);

    // Register the control with the owner window table.
    //
    if ( ! powin->AddControl( this ))
    {
        DBGEOL("BLT: Insufficient memory to add control to owner window");

        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }
}


/**********************************************************************

    NAME:       CONTROL_WINDOW::OnUserAction

    SYNOPSIS:   Called when the user has manipulated the control
                in some way.

    ENTRY:      lParam      The parameters to the WM_CONTROL message that
                            the control sent its owner window.  The contents
                            of this value is specific to different types of
                            controls.

    RETURN:     0 if some action was taken.

    EXIT:

    NOTES:
                Even if an action is taken, the owner will still get a
                notification about the this event.

                NOTE:  Currently, this method is only called from the
                DIALOG_WINDOW, but it could potentially also be called
                from some other branch of the OWNER_WINDOW hierarchy.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        05-Oct-1991 Win32 conversion

**********************************************************************/

APIERR CONTROL_WINDOW::OnUserAction( const CONTROL_EVENT & e )
{
    UNREFERENCED(e);        // quiet compiler
    return NERR_Success;    // success in handling user action
}


/*******************************************************************

    NAME:       CONTROL_WINDOW::OnCtlColor

    SYNOPSIS:   Dialogs pass WM_CTLCOLOR* here

    RETURNS:    brush handle if you handle it, may also change *pmsgid

    NOTES:      see blt\bltcc\bltsslt.cxx for an example of how to
                work with this

                If this method or its virtual redefinition is not being
                called, check whether a redefinition of
                DIALOG_WINDOW::OnCtlColor is failing to call through to
                that root method.

    HISTORY:
        jonn        31-Aug-1995 Created

********************************************************************/
HBRUSH CONTROL_WINDOW::OnCtlColor( HDC hdc, HWND hwnd, UINT * pmsgid )
{
    UNREFERENCED( hdc );
    UNREFERENCED( hwnd );
    UNREFERENCED( pmsgid );
    return NULL;
}


/**********************************************************************

    NAME:       CONTROL_WINDOW::SetTabStop

    SYNOPSIS:   Set the tab stop on the control window

    ENTRY:      fTabStop    TRUE if we want to set the tab stop and FALSE
                            if we want to remove the tab stop.

    RETURN:

    EXIT:

    NOTES:

    HISTORY:
        Yi-HsinS     29-May-1992 Created

**********************************************************************/

VOID CONTROL_WINDOW::SetTabStop( BOOL fTabStop )
{
    if ( fTabStop )
    {
        SetStyle( QueryStyle() | WS_TABSTOP );
    }
    else
    {
        SetStyle( QueryStyle() & ~((ULONG) WS_TABSTOP) );
    }
}


/*********************************************************************

    NAME:       CONTROL_WINDOW::CD_Draw

    SYNOPSIS:   Draws (an item in) a custom drawn control.

    ENTRY:      pdis    A pointer to a DRAWITEMSTRUCT (described in the
                        Windows SDK.

    RETURN:
                TRUE if the item was drawn
                FALSE otherwise

    NOTES:
        This method may be replaced by the client for any custom drawn
        control.

        This method is never called for controls that don't have the
        owner-drawn style bit.

    HISTORY:
        rustanl         20-Nov-1990 Created
        gregj           01-May-1991 Added GUILTT support
        beng            01-Jun-1992 Changed GUILTT support

*********************************************************************/

BOOL CONTROL_WINDOW::CD_Draw( DRAWITEMSTRUCT * pdis )
{
    UNREFERENCED(pdis);
    return FALSE;   // no action taken
}


/*********************************************************************

    NAME:       CONTROL_WINDOW::CD_Measure

    SYNOPSIS:   Called to measure a VARIABLE size item
                in a custom drawn control.

    ENTRY:      pdms    A pointer to a MEASUREITEMSTRUCT (described in the
                        Windows SDK.

    RETURN:     TRUE if a response was taken
                FALSE otherwise

    NOTES:
        This method may be replaced by the client for any custom draw
        control.

        This method is never called for controls that don't have the
        owner-draw and variable-size data style bits.

    HISTORY:
        rustanl     20-Nov-1990     Created

*********************************************************************/

BOOL CONTROL_WINDOW::CD_Measure( MEASUREITEMSTRUCT * pmis )
{
    UNREFERENCED(pmis);   // quiet compiler
    return FALSE;         // no action taken
}


/*********************************************************************

    NAME:       CONTROL_WINDOW::CD_Char

    SYNOPSIS:   Called to determine the effect of a keystroke
                in a custom-drawn listbox.

    ENTRY:
        wch         The Ansi value of the character typed.
        nLastPos    Index of the current caret position.

    RETURN:
        -2 ==> the control did all processing of the character.
        -1 ==> the default effect of the character is appropriate.
        0 or greater ==> the index of an item to act upon.

    NOTES:
        This method may be replaced by the client for any custom draw
        list control.

        This method is never called for controls other than custom
        drawn listboxes.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        15-Oct-1991 Win32 conversion

*********************************************************************/

INT CONTROL_WINDOW::CD_Char( WCHAR wch, USHORT nLastPos )
{
    UNREFERENCED(wch);      // quiet compiler
    UNREFERENCED(nLastPos);
    return -1;                // take default action
}


/*********************************************************************

    NAME:       CONTROL_WINDOW::CD_VKey

    SYNOPSIS:   Called when a listbox with the LBS_WANTKEYBOARDINPUT style
                receives a WM_KEYDOWN message.

    ENTRY:
        nVKey       The virtual-key code of the key which the user pressed.
        nLastPos    Index of the current caret position.

    RETURN:
        -2 ==> the control did all processing of the key press.
        -1 ==> the listbox should perform the default action
               in response to the keystroke.
        at least 0 ==> the index of an item to act upon.

    NOTES:
        This method may be replaced by the client for any custom draw
        list control with the LBS_WANTKEYBOARDINPUT style.

        This method is never called for controls other than custom
        drawn listboxes with the LBS_WANTKEYBOARDINPUT style.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        15-Oct-1991 Win32 conversion

*********************************************************************/

INT CONTROL_WINDOW::CD_VKey( USHORT nVKey, USHORT nLastPos )
{
    UNREFERENCED(nVKey);      // quiet compiler
    UNREFERENCED(nLastPos);
    return -1;                // take default action
}


/*********************************************************************

    NAME:       CONTROL_WINDOW::CD_Guiltt

    SYNOPSIS:   Fetches data for GUILTT from a control

    ENTRY:
        ilb     - index into the listbox (or some other subsel)
        pnlsOut - string to hold the output data

    EXIT
        pnlsOut - no doubt has been scribbled into

    RETURN:     An error code - NERR_Success if successful.

    NOTES:
        The default implementation always returns "not supported,"
        since only owner-draw listboxes at present support GUILTT.

    HISTORY:
        beng            01-Jun-1992 Created

*********************************************************************/

APIERR CONTROL_WINDOW::CD_Guiltt( INT ilb, NLS_STR * pnlsOut )
{
    UNREFERENCED(ilb);
    UNREFERENCED(pnlsOut);
    return ERROR_NOT_SUPPORTED;
}


/*********************************************************************

    NAME:       CONTROL_WINDOW::QueryCid

    SYNOPSIS:   Returns the control ID.

    RETURN:     the control ID of the control

    HISTORY:
        rustanl     20-Nov-1990     Created

*********************************************************************/

CID CONTROL_WINDOW::QueryCid() const
{
    return _cid;
}


/*********************************************************************

    NAME:       CONTROL_WINDOW::ClaimFocus

    SYNOPSIS:   Sets the input focus to the control window.

    HISTORY:
        rustanl     20-Nov-1990     Created

*********************************************************************/

VOID CONTROL_WINDOW::ClaimFocus()
{
    SetFocus(QueryHwnd());
}


/*********************************************************************

    NAME:       CONTROL_WINDOW::QueryFont

    SYNOPSIS:   Retrieves the handle of the font with which the control is
                currently drawing its text.

    RETURNS:    Handle of said font, or NULL if system font.

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        21-Aug-1991     Return type HFONT

*********************************************************************/

HFONT CONTROL_WINDOW::QueryFont() const
{
    return (HFONT)Command( WM_GETFONT );
}


/*******************************************************************

    NAME:       CONTROL_WINDOW::SetFont

    SYNOPSIS:   Sets the current font with which the control draws text

    ENTRY:      hfont   - handle to font (queried from elsewhere)
                          (optionally - a created logical font)

                fRedraw - TRUE to redraw font

    EXIT:       Font is set.

    HISTORY:
        beng        21-Aug-1991 Created
        beng        17-Oct-1991 Win32 conversion

********************************************************************/

VOID CONTROL_WINDOW::SetFont( HFONT hfont, BOOL fRedraw )
{
    Command(WM_SETFONT, (WPARAM)hfont, (LPARAM)fRedraw);
}


/*******************************************************************

    NAME:       CONTROL_WINDOW::SetControlValueFocus

    SYNOPSIS:   Sets the focus to this control window
                (see CONTROL_VALUE for more details).

    EXIT:       The focus should be set to this control window.

    NOTES:

    HISTORY:
        Johnl   02-May-1991     Created

********************************************************************/

VOID CONTROL_WINDOW::SetControlValueFocus()
{
    ClaimFocus();
}


/*******************************************************************

    NAME:     CONTROL_WINDOW::NotifyGroups

    SYNOPSIS: Notifies all parent groups of this control that this control
              received the specified message.

    ENTRY:    lParam is the message received by the control

    EXIT:     All groups will have been notified (if appropriate).

    RETURNS:  An APIERR, or else GROUP_NO_CHANGE

    NOTES:

    HISTORY:
        Johnl       02-May-1991 Created
        beng        08-Oct-1991 Win32 conversion

********************************************************************/

APIERR CONTROL_WINDOW::NotifyGroups( const CONTROL_EVENT & e )
{
    APIERR apierr = NERR_Success;

    /* If the control belongs to a group, tell the
     * group a user tampered with one of its controls
     */
    CONTROL_GROUP * pg = QueryGroup() ;
    if ( pg != NULL )
    {
        /* A group can indicate that nothing has changed
         * (by returning GROUP_NO_CHANGE), this will
         * prevent the parent groups from being notified.
         */

        // C7 CODEWORK - remove redundant Glock-pacifier cast
        apierr = pg->OnUserAction( this, (const CONTROL_EVENT &)e );

        /* Now tell all of the parent groups of this group
         * that the group has been tampered with.
         */
        CONTROL_GROUP * pgNext ;
        while ( (apierr == NERR_Success) &&
                (pgNext = pg->QueryGroup()) != NULL )
        {
            apierr = pgNext->OnGroupAction( pg );
            pg = pgNext;
        }

        if ( apierr == NERR_Success || apierr == GROUP_NO_CHANGE )
            QueryGroup()->AfterGroupActions();
    }

    return apierr;
}


/*******************************************************************

    NAME:       CONTROL_WINDOW::Validate

    SYNOPSIS:   Validates the contents of the control

    ENTRY:      Validity unknown

    EXIT:       Validity known

    RETURNS:    Error code (NERR_Success if input ok)

    NOTES:
        This is a virtual member function.  Controls which validate
        their contents (those which have contents to validate, that
        is) should redefine it.

    HISTORY:
        beng        31-Oct-1991 Created

********************************************************************/

APIERR CONTROL_WINDOW::Validate()
{
    // Stub implementation always returns "success," so controls
    // which don't validate their input are ignored

    return NERR_Success;
}


/*******************************************************************

    NAME:       CONTROL_WINDOW::IndicateError

    SYNOPSIS:   Indicate invalid data within the control

    ENTRY:      Control has already checked the validity of its data,
                and found it wanting; dialog now is asking control
                to indicate the error

    EXIT:       Control has indicated the error

    NOTES:
        This is a virtual member function.

        This default implementation sets focus to the control
        and raises a popup.

    HISTORY:
        beng        31-Oct-1991 Created

********************************************************************/

VOID CONTROL_WINDOW::IndicateError( APIERR err )
{
    MsgPopup(QueryHwnd(), (MSGID)err);
    ClaimFocus();
}


/*******************************************************************

    NAME:     ICON_CONTROL::ICON_CONTROL

    SYNOPSIS: Static icon control class

    ENTRY:    powin - Owner window of this control
            cidIcon - Control ID of the icon
            lpIconName - Name of the icon in the resource file
            or LOWORD( lpIconName ) is one of the predefined windows icons.
            or NULL means don't do anything.

    EXIT:

    NOTES:
        CODEWORK: Add constructor that takes a HICON parm, or
        perhaps some ICON object

    HISTORY:
        Johnl       8-Feb-1991      Created
        beng        17-May-1991     Added app-window constructor
        keithmo     24-Mar-1992     Uses IDRESOURCE
        beng        01-Apr-1992     Const args fixup

********************************************************************/

ICON_CONTROL::ICON_CONTROL(
    OWNER_WINDOW * powin,
    CID            cidIcon )
    : CONTROL_WINDOW( powin, cidIcon )
{
    if (QueryError())
        return;
}

ICON_CONTROL::ICON_CONTROL(
    OWNER_WINDOW * powin,
    CID            cidIcon,
    const IDRESOURCE & idresIcon )
    : CONTROL_WINDOW( powin, cidIcon )
{
    if (QueryError())
        return;

    APIERR err = SetIcon( idresIcon );
    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}

ICON_CONTROL::ICON_CONTROL(
    OWNER_WINDOW * powin,
    CID            cidIcon,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *  pszClassName )
    : CONTROL_WINDOW( powin, cidIcon, xy, dxy, flStyle, pszClassName )
{
    if (QueryError())
        return;
}

ICON_CONTROL::ICON_CONTROL(
    OWNER_WINDOW * powin,
    CID            cidIcon,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    const IDRESOURCE & idresIcon,
    ULONG          flStyle,
    const TCHAR *   pszClassName )
    : CONTROL_WINDOW( powin, cidIcon, xy, dxy, flStyle, pszClassName )
{
    if (QueryError())
        return;

    APIERR err = SetIcon( idresIcon );
    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:     ICON_CONTROL::W_SetIcon

    SYNOPSIS: Change the icon this control contains

    ENTRY:    idresIcon - Either points to the name of the icon resource
                          OR contains the ordinal of the icon resource.

              fIsPredefined - If TRUE then idresIcon must be one of the
                              predefined Windows icons (IDI_*).  Otherwise,
                              idresIcon is an application icon.

    EXIT:

    NOTES:
        You can always change an icon using an undocumented (though
        publicly supported) trick.  You set the text of the control
        and rather then passing a pointer to a string of text, the
        pointer contains the handle to the icon.

        The psz-can-either-be-a-char*-or-a-MAKEINTRESOURCE(lpstr) hack
        of the Win API is pretty disgusting.  CODEWORK: overload this
        function to do it either one way or the other.

    HISTORY:
        Johnl       8-Feb-1991  (created)
        beng        17-May-1991 Changed arg to const TCHAR *
        KeithMo     22-Sep-1991 Changed to Win 3.1 message
        beng        07-Oct-1991 Win32 conversion
        KeithMo     24-Mar-1992 Changed to W_SetIcon, uses IDRESOURCE.
        beng        01-Apr-1992 const args fixup
        beng        03-Aug-1992 Dllization

********************************************************************/

APIERR ICON_CONTROL::W_SetIcon( const IDRESOURCE & idresIcon,
                                BOOL fIsPredefined )
{
    HICON hNewIcon = ::LoadIcon( fIsPredefined
                                  ? NULL
                                  : BLT::CalcHmodRsrc(idresIcon),
                                 idresIcon.QueryPsz() );
    if ( hNewIcon == NULL )
    {
        return BLT::MapLastError(ERROR_INVALID_PARAMETER);
    }

    return (APIERR)Command( STM_SETICON, (WPARAM)hNewIcon, 0L );
}


/*******************************************************************

    NAME:       HIDDEN_CONTROL::HIDDEN_CONTROL

    SYNOPSIS:   constructor

    EXIT:       control is invisible and inaccessible

    HISTORY:
        o-SimoP     02-Jan-1992 Created

********************************************************************/

HIDDEN_CONTROL::HIDDEN_CONTROL( OWNER_WINDOW * powin, CID cid )
        : CONTROL_WINDOW( powin, cid )
{
    if ( QueryError() != NERR_Success )
        return;
    Enable( FALSE );
    Show( FALSE );
}


/*******************************************************************

    NAME:       SCROLLBAR::SCROLLBAR

    SYNOPSIS:   Ctor

    NOTE:
        Another form of this ctor lies inline.  This form lies
        outline because it references a static member.

    HISTORY:
        beng        29-Jun-1992 Outlined (dllization delta)

********************************************************************/

SCROLLBAR::SCROLLBAR( OWNER_WINDOW * pwnd, CID cid,
                      XYPOINT xy, XYDIMENSION dxy, ULONG flStyle )
    : CONTROL_WINDOW( pwnd, cid, xy, dxy, flStyle, _pszClassName )
{
    // Nothing further to do
}


/*******************************************************************

    NAME:       SCROLLBAR::SetPos

    SYNOPSIS:   Set the position of a scrollbar

    ENTRY:      nPosition - desired position

    NOTE:
        This function does NOT redraw the control.  Use RepaintNow
        to force a redraw.

    HISTORY:
        beng        18-May-1992 Created

********************************************************************/

VOID SCROLLBAR::SetPos( UINT nPosition )
{
    ::SetScrollPos(QueryHwnd(), SB_CTL, nPosition, FALSE);
}


/*******************************************************************

    NAME:       SCROLLBAR::SetRange

    SYNOPSIS:   Sets the range within which a sbar reports position

    ENTRY:      nMin - minimum position
                nMax - maximum (inclusive)

    NOTE:
        This function does NOT redraw the control.  Use RepaintNow
        to force a redraw.

    HISTORY:
        beng        18-May-1992 Created

********************************************************************/

VOID SCROLLBAR::SetRange( UINT nMin, UINT nMax )
{
    BOOL fOk = ::SetScrollRange(QueryHwnd(), SB_CTL, nMin, nMax, FALSE);

#if defined(DEBUG)
    if (!fOk)
    {
        APIERR err = BLT::MapLastError(ERROR_GEN_FAILURE);
        DBGEOL("BLT: SetScrollRange failed, err = "
                << BLT::MapLastError(ERROR_GEN_FAILURE));
    }
#endif
}


/*******************************************************************

    NAME:       SCROLLBAR::QueryPos

    SYNOPSIS:   Returns the current position within a scrollbar

    HISTORY:
        beng        18-May-1992 Created

********************************************************************/

UINT SCROLLBAR::QueryPos() const
{
    return ::GetScrollPos(QueryHwnd(), SB_CTL);
}


/*******************************************************************

    NAME:       SCROLLBAR::QueryMin

    SYNOPSIS:   Returns the low end of a scrollbar's range

    HISTORY:
        beng        18-May-1992 Created

********************************************************************/

UINT SCROLLBAR::QueryMin() const
{
    INT nMin = 0, nMax;

    BOOL fOk = ::GetScrollRange(QueryHwnd(), SB_CTL, &nMin, &nMax);
#if defined(DEBUG)
    if (!fOk)
    {
        APIERR err = BLT::MapLastError(ERROR_GEN_FAILURE);
        DBGEOL("BLT: GetScrollRange failed, err = "
                << BLT::MapLastError(ERROR_GEN_FAILURE));
    }
#endif

    return (UINT)nMin;
}


/*******************************************************************

    NAME:       SCROLLBAR::QueryMax

    SYNOPSIS:   Returns the high end of a scrollbar's range

    HISTORY:
        beng        18-May-1992 Created

********************************************************************/

UINT SCROLLBAR::QueryMax() const
{
    INT nMin, nMax = 0;

    BOOL fOk = ::GetScrollRange(QueryHwnd(), SB_CTL, &nMin, &nMax);
#if defined(DEBUG)
    if (!fOk)
    {
        DBGEOL("BLT: GetScrollRange failed, err = "
                << BLT::MapLastError(ERROR_GEN_FAILURE));
    }
#endif

    return (UINT)nMax;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltedit.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltedit.cxx
    BLT text control class implementations

    FILE HISTORY:
        beng        17-Sep-1991 Separated from bltctrl.cxx
        thomaspa    13-Feb-1992 Moved validate from SLE to ICANON_SLE
        KeithMo     27-Aug-1992 Added CONTROL_VALUE methods to SLT.

*/
#include "pchblt.hxx"


/**********************************************************************

    NAME:       TEXT_CONTROL::TEXT_CONTROL

    SYNOPSIS:   constructor for the text control class

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        17-May-1991     Added app-window constructor

**********************************************************************/

TEXT_CONTROL::TEXT_CONTROL( OWNER_WINDOW * powin, CID cid )
    : CONTROL_WINDOW ( powin, cid )
{
    // nothing to do
}

TEXT_CONTROL::TEXT_CONTROL(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName )
    : CONTROL_WINDOW( powin, cid, xy, dxy, flStyle, pszClassName )
{
    // ...
}


/**********************************************************************

    NAME:       STATIC_TEXT_CONTROL::STATIC_TEXT_CONTROL

    SYNOPSIS:   constructor for the static ext control class

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        17-May-1991     Added app-window constructor

***********************************************************************/

STATIC_TEXT_CONTROL::STATIC_TEXT_CONTROL( OWNER_WINDOW * powin, CID cid )
    : TEXT_CONTROL( powin, cid )
{
    // nothing to do
}

STATIC_TEXT_CONTROL::STATIC_TEXT_CONTROL(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName )
    : TEXT_CONTROL( powin, cid, xy, dxy, flStyle, pszClassName )
{
    // ...
}


/**********************************************************************

    NAME:       SLT::SLT

    SYNOPSIS:   constructor for the SLE (single line text) class

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        17-May-1991     Added app-window constructor

**********************************************************************/

SLT::SLT( OWNER_WINDOW * powin, CID cid )
    : STATIC_TEXT_CONTROL( powin, cid ),
      _fSavedEnableState( TRUE )
{
    // nothing to do
}

SLT::SLT(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName )
    : STATIC_TEXT_CONTROL( powin, cid, xy, dxy, flStyle, pszClassName ),
      _fSavedEnableState( TRUE )
{
    // ...
}


/*******************************************************************

    NAME:       SLT::SaveValue

    SYNOPSIS:   Saves the "enable" state of this control and optionally
                disables the control.  See CONTROL_VALUE for details.

    EXIT:       _nlsSaveValue now contains the EDIT_CONTROL text
                and the EDIT_CONTROL should be empty.

    HISTORY:
        KeithMo     27-Aug-1992     Created from EDIT_CONTROL::SaveValue.

********************************************************************/

VOID SLT::SaveValue( BOOL fInvisible )
{
    _fSavedEnableState = IsEnabled();

    if( fInvisible )
    {
        Enable( FALSE );
    }
}


/*******************************************************************

    NAME:     SLT::RestoreValue

    SYNOPSIS: Restores the "enable" state after being saved with SaveValue.

    HISTORY:
        KeithMo     27-Aug-1992     Created from EDIT_CONTROL::RestoreValue.

********************************************************************/

VOID SLT::RestoreValue( BOOL fInvisible )
{
    if( fInvisible )
    {
        Enable( _fSavedEnableState );
    }

#if 1
    //
    //  CODEWORK:
    //
    //  This should be accomplished by overriding the SetTabStop()
    //  virtual!
    //

    SetTabStop( FALSE );
#endif
}


/**********************************************************************

    NAME:       MLT::MLT

    SYNOPSIS:   constructor for the MLT (multi-line text) class

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        17-May-1991     Added app-window constructor

**********************************************************************/

MLT::MLT( OWNER_WINDOW * powin, CID cid )
    : STATIC_TEXT_CONTROL( powin, cid )
{
    // nothing to do
}

MLT::MLT(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName )
    : STATIC_TEXT_CONTROL( powin, cid, xy, dxy, flStyle, pszClassName )
{
    // ...
}


/**********************************************************************

    NAME:       EDIT_CONTROL::EDIT_CONTROL

    SYNOPSIS:   constructor for the edit control class

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-May-1991 Added app-window constructor
        beng        31-Jul-1991 Error reporting changed
        beng        04-Oct-1991 Win32 conversion
        KeithMo     11-Sep-1992 Forcibly remove ES_OEMCONVERT under UNICODE.
        KeithMo     07-Feb-1993 Don't remove ES_OEMCONVERT.

**********************************************************************/

EDIT_CONTROL::EDIT_CONTROL( OWNER_WINDOW * powin, CID cid, UINT cchMax )
    : TEXT_CONTROL( powin, cid ),
      _nlsSaveValue( (TCHAR *) NULL )   // Initialize to empty string

{
    if (QueryError())
        return;

    if (_nlsSaveValue.QueryError())
    {
        ReportError(_nlsSaveValue.QueryError());
        return;
    }

    if ( cchMax > 0 )
        SetMaxLength( cchMax );
}


EDIT_CONTROL::EDIT_CONTROL(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName,
    UINT           cchMax )
    : TEXT_CONTROL( powin, cid, xy, dxy, flStyle, pszClassName ),
      _nlsSaveValue( (TCHAR *) NULL )   // Initialize to empty string
{
    if (QueryError())
        return;

    if (_nlsSaveValue.QueryError())
    {
        ReportError(_nlsSaveValue.QueryError());
        return;
    }

    if ( cchMax > 0 )
        SetMaxLength( cchMax );
}


/**********************************************************************

    NAME:       EDIT_CONTROL::SetMaxLength

    SYNOPSIS:   Set the max length for the edit control

    NOTES:
        The EM_LIMITTEXT message talks bytes, whereas we want
        to talk TCHAR.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        19-Jun-1991 Honor Unicode characters
        beng        24-Jun-1992 Win takes TCHARs, not BYTES

**********************************************************************/

VOID EDIT_CONTROL::SetMaxLength( UINT cchMax )
{
    Command( EM_LIMITTEXT, cchMax );
}


/*********************************************************************

    NAME:       EDIT_CONTROL::SelectString

    SYNOPSIS:   This method selects the entire string contained in the edit
                control.

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        19-Jun-1991     Added code for Win32

*********************************************************************/

VOID EDIT_CONTROL::SelectString()
{
#if defined(WIN32)
    Command( EM_SETSEL, 0, (LPARAM)(-1) );
#else
    Command( EM_SETSEL, 0, MAKELONG( 0, 0x7fff ));
#endif
}


/*******************************************************************

    NAME:       EDIT_CONTROL::SaveValue

    SYNOPSIS:   Stores the contents of this EDIT_CONTROL and empties the
                EDIT_CONTROL (see CONTROL_VALUE for more details).

    EXIT:       _nlsSaveValue now contains the EDIT_CONTROL text
                and the EDIT_CONTROL should be empty.

    HISTORY:
        Johnl       25-Apr-1991     Created

********************************************************************/

VOID EDIT_CONTROL::SaveValue( BOOL fInvisible )
{
    QueryText( &_nlsSaveValue );
    if ( _nlsSaveValue.QueryError() )
    {
        _nlsSaveValue = NULL;
    }
    else
    {
        if ( fInvisible )
            ClearText();
    }
}


/*******************************************************************

    NAME:     EDIT_CONTROL::RestoreValue

    SYNOPSIS: Restores the text after being saved with SaveValue

    ENTRY:

    EXIT:     The text is restored and selected.

    NOTES:    See CONTROL_VALUE for more details.

    HISTORY:
        Johnl       25-Apr-1991     Created

********************************************************************/

VOID EDIT_CONTROL::RestoreValue( BOOL fInvisible )
{
    if ( _nlsSaveValue.QueryError() == NERR_Success )
    {
        if ( fInvisible )
            SetText( _nlsSaveValue );
        SelectString();
    }

    _nlsSaveValue = NULL;
}


/*******************************************************************

    NAME:       EDIT_CONTROL::QueryEventEffects

    SYNOPSIS:   Virtual replacement for CONTROL_VALUE class

    NOTES:      We currently only consider EN_CHANGE a value change message.

    HISTORY:
        Johnl       25-Apr-1991 Created
        beng        31-Jul-1991 Renamed from QMessageInfo
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

UINT EDIT_CONTROL::QueryEventEffects( const CONTROL_EVENT & e )
{
    switch ( e.QueryCode() )
    {
    case EN_CHANGE:
        return CVMI_VALUE_CHANGE;

    case EN_SETFOCUS:
        return CVMI_VALUE_CHANGE | CVMI_RESTORE_ON_INACTIVE;

    default:
        break;
    }

    return CVMI_NO_VALUE_CHANGE;
}


/*******************************************************************

    NAME:     EDIT_CONTROL::SetControlValueFocus

    SYNOPSIS: Sets the focus to this edit control
              (see CONTROL_VALUE for more details).

    EXIT:     The focus should be set to this edit control and the text
              should be selected.

    NOTES:

    HISTORY:
        Johnl       03-May-1991     Created

********************************************************************/

VOID EDIT_CONTROL::SetControlValueFocus()
{
    CONTROL_WINDOW::SetControlValueFocus();
    SelectString();
}


/*********************************************************************

    NAME:       SLE::SLE

    SYNOPSIS:   constructor for the single line edit class

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        04-Oct-1991 Win32 conversion
        thomaspa    21-Jan-1992 Added validation

*********************************************************************/

SLE::SLE( OWNER_WINDOW * powin, CID cid, UINT cchMax )
    : EDIT_CONTROL( powin, cid, cchMax )

{
    // Nothing to do
}

SLE::SLE(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName,
    UINT           cchMax )
    : EDIT_CONTROL( powin, cid, xy, dxy, flStyle, pszClassName, cchMax )
{
    // Nothing to do
}


/*******************************************************************

    NAME:       SLE::IndicateError

    SYNOPSIS:   Indicate that the contents are invalid

    ENTRY:      Contents were found invalid

    EXIT:       Error indicated

    NOTES:
        A SLE indicates an error by selecting the erronous data
        (assumed here to be all of the string).

    HISTORY:
        beng        01-Nov-1991 Created

********************************************************************/

VOID SLE::IndicateError( APIERR err )
{
    EDIT_CONTROL::IndicateError(err);
    SelectString();
}



/*********************************************************************

    NAME:       MLE::MLE

    SYNOPSIS:   constructor for multi-line edit class

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-May-1991 Added app-window constructor
        beng        04-Oct-1991 Win32 conversion

*********************************************************************/

MLE::MLE( OWNER_WINDOW * powin, CID cid, UINT cchMax )
    : EDIT_CONTROL( powin, cid, cchMax )
{
    // nothing to do
}

MLE::MLE(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName,
    UINT           cchMax )
    : EDIT_CONTROL( powin, cid, xy, dxy, flStyle, pszClassName, cchMax )
{
    // nothing to do
}


/**********************************************************************

    NAME:       PASSWORD_CONTROL::PASSWORD_CONTROL

    SYNOPSIS:   constructor for password control class

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-May-1991 Added app-window constructor
        beng        04-Oct-1991 Win32 conversion

*********************************************************************/

PASSWORD_CONTROL::PASSWORD_CONTROL(
    OWNER_WINDOW * powin,
    CID            cid,
    UINT           cchMax )
    : EDIT_CONTROL( powin, cid, cchMax )
{
    // nothing to do
}

PASSWORD_CONTROL::PASSWORD_CONTROL(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName,
    UINT           cchMax )
    : EDIT_CONTROL( powin, cid, xy, dxy, flStyle, pszClassName, cchMax )
{
    // nothing to do
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltdisph.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltdisph.cxx
    Implementation of BLT window-message dispatcher

    FILE HISTORY:
        beng        09-May-1991 Created
        terryk      20-Jun-1991 Move the source code from bltclwin.cxx
        terryk      10-Jul-1991 Change the constructor parameter to
                                WINDOW *.
        terryk      25-Jul-1991 Add OnDragBegin and OnDragEnd.
        beng        27-Sep-1991 Merge with CLIENT_WINDOW
        beng        19-May-1992 OnNCHitTest superseded by CUSTOM_CONTROL::
                                OnQHitTest
        beng        28-May-1992 The amazing bltcc/bltdisph shuffle
*/


#include "pchblt.hxx"


// A do-the-default return for the WM_NCHITTEST message,
// which gives 0 an interesting meaning.  Here's hoping this isn't
// reassigned in the near future to any other interesting value.

#define HT_DO_DEFAULT       ((ULONG)((HTERROR)-1))



/**********************************************************************

    NAME:       DISPATCHER::DISPATCHER

    SYNOPSIS:   constructor

    ENTRY:      CONTROL_WINDOW *pwnd - the associated control window pointer

    HISTORY:
        beng        10-May-1991 Created
        terryk      10-Jul-1991 Change the given parameter to
                                CONTROL_WINDOW pointer
        beng        30-Sep-1991 Win32 conversion
        beng        28-May-1992 bltcc reshuffle

***********************************************************************/

DISPATCHER::DISPATCHER( WINDOW *pwnd )
    : _pwnd( pwnd ),
      _assocThis( pwnd->QueryHwnd(), this )
{
    // This form of the constructor assumes that some other
    // agent has already created the window for us.

    if ( !_assocThis )
        return;

    // CODEWORK - inherit from BASE?
}


DISPATCHER::~DISPATCHER()
{
    // Nobody lives here
}


/*********************************************************************

    NAME:       DISPATCHER::Dispatch

    SYNOPSIS:   Main routine to dispatch the event appropriately

    ENTRY:      EVENT event - general event

    HISTORY:
        terryk      10-May-1991 Created
        terryk      25-Jul-1991 Add fDragMode checking
        beng        05-Dec-1991 Added scroll-bar messages
        beng        18-May-1992 Scroll-bar callbacks disabled
        beng        19-May-1992 WM_NCHITTEST reloc'd to CUSTOM_CONTROL
        beng        28-May-1992 Scramble bltcc, bltdisph

*********************************************************************/

BOOL DISPATCHER::Dispatch( const EVENT &event, ULONG * pnRes )
{
    BOOL fHandled = FALSE;

    // I've tried to order these messages to get the common cases
    // checked first.

    switch (event.QueryMessage())
    {

    case WM_NCHITTEST:
        // Special case, yuck.  0 is an interesting return here,
        // esp. when subclassing a STATIC.

        {
            ULONG nRes = OnQHitTest( XYPOINT(event.QueryLParam()) );
            if (nRes == HT_DO_DEFAULT) // HACK!
                return FALSE;
            else
            {
                *pnRes = nRes;
                return TRUE;
            }
        }

    //
    // Following simple cases share common pnRes-setting code
    // (at end of fcn, jumped to by BREAK statement)
    //

    case WM_MOUSEMOVE:
        fHandled = OnMouseMove((const MOUSE_EVENT &)event);
        break;

    case WM_SETCURSOR:
        fHandled = OnQMouseCursor((const QMOUSEACT_EVENT &)event);
        break;

    case WM_PAINT:
        fHandled = OnPaintReq();
        break;

    case WM_ACTIVATE:
        {
            const ACTIVATION_EVENT & ae = (const ACTIVATION_EVENT &)event;

            if (ae.IsActivating())
                fHandled = OnActivation((const ACTIVATION_EVENT &)ae);
            else
                fHandled = OnDeactivation((const ACTIVATION_EVENT &)ae);
        }
        break;

    case WM_SIZE:
        fHandled = OnResize((const SIZE_EVENT &)event);
        break;

    case WM_MOVE:
        fHandled = OnMove((const MOVE_EVENT &)event);
        break;

    case WM_CLOSE:
        fHandled = OnCloseReq();
        break;

    case WM_DESTROY: // REVIEW - when would this be called?
        fHandled = OnDestroy();
        break;

    case WM_KEYUP:
        fHandled = OnKeyUp((const VKEY_EVENT &)event);
        break;

    case WM_KEYDOWN:
        fHandled = OnKeyDown((const VKEY_EVENT &)event);
        break;

    case WM_CHAR:
        fHandled = OnChar((const CHAR_EVENT &)event);
        break;

    case WM_LBUTTONDOWN:
        fHandled = OnLMouseButtonDown((const MOUSE_EVENT &)event);
        break;

    case WM_LBUTTONUP:
        fHandled = OnLMouseButtonUp((const MOUSE_EVENT &)event);
        break;

    case WM_LBUTTONDBLCLK:
        fHandled = OnLMouseButtonDblClick((const MOUSE_EVENT &)event);
        break;

    case WM_SETFOCUS:
        fHandled = OnFocus((const FOCUS_EVENT &)event);
        break;

    case WM_KILLFOCUS:
        fHandled = OnDefocus((const FOCUS_EVENT &)event);
        break;

    case WM_TIMER:
        fHandled = OnTimer((const TIMER_EVENT &)event);
        break;

#if 0 // disabled - no clients
    case WM_VSCROLL:
    case WM_HSCROLL:
        {
            const SCROLL_EVENT & se = (const SCROLL_EVENT &)event;

            if (   se.QueryCommand() == SCROLL_EVENT::scmdThumbPos
                || se.QueryCommand() == SCROLL_EVENT::scmdThumbTrack )
                fHandled = OnScrollBarThumb((const SCROLL_THUMB_EVENT &)se);
            else
                fHandled = OnScrollBar((const SCROLL_EVENT &)se);
        }
        break;
#endif

    case WM_COMMAND:
        fHandled = OnCommand((const CONTROL_EVENT &)event);
        break;

    //
    // So much for the simple cases.  Following cases all set and return
    // status themselves.
    //

    case WM_GETDLGCODE:
        {
            ULONG nRes = OnQDlgCode();
            if (nRes == 0L)
                return FALSE;
            else
            {
                *pnRes = nRes;
                return TRUE;
            }
        }

    case WM_MOUSEACTIVATE:
        {
            ULONG nRes = OnQMouseActivate((const QMOUSEACT_EVENT &)event);
            if (nRes == 0L)
                return FALSE;
            else
            {
                *pnRes = nRes;
                return TRUE;
            }
        }

    default:
        if (event.QueryMessage() >= WM_USER+100)
        {
            // C7 CODEWORK - remove redundant cast
            fHandled = OnUserMessage((const EVENT &)event);
            break;
        }

        // Message not handled at all by dispatcher
        return FALSE;
    }


    // The most common response to a successful dispatch

    if (fHandled)
        *pnRes = TRUE;

    return fHandled;
}


/*******************************************************************

    NAME:       DISPATCHER::OnUserMessage

    SYNOPSIS:   Handles all user-defined messages

    ENTRY:      event - an untyped EVENT

    RETURNS:    TRUE if event handled, FALSE otherwise

    NOTES:
        Clients handling user-defined messages should supply
        OnOther instead of redefining DispatchMessage.

    HISTORY:
        beng        14-May-1991     Created

********************************************************************/

BOOL DISPATCHER::OnUserMessage( const EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnPaintReq()
{
    return FALSE;
}


BOOL DISPATCHER::OnActivation( const ACTIVATION_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnDeactivation( const ACTIVATION_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnResize( const SIZE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnMove( const MOVE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       DISPATCHER::OnCloseReq

    SYNOPSIS:   Called upon a request to close the window

    RETURNS:    FALSE

    NOTES:      This default implementation does nothing.

    HISTORY:
        beng        09-May-1991     Created
        beng        14-May-1991     Renamed (from "MayClose")

********************************************************************/

BOOL DISPATCHER::OnCloseReq()
{
    return FALSE;
}


/*******************************************************************

    NAME:       DISPATCHER::OnDestroy

    SYNOPSIS:   Called upon an *external* DestroyWindow.
                (Internal DestroyWindow calls created by the
                destructor will never cross this callback.)

    NOTES:
        This is not a dependable callback; please do not use it.

    HISTORY:
        beng        10-May-1991 Implemented
        terryk      25-Jul-1991 Add OnDragBegin, OnDragEnd, OnDragMove

********************************************************************/

BOOL DISPATCHER::OnDestroy()
{
    return FALSE;
}


BOOL DISPATCHER::OnKeyDown( const VKEY_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnKeyUp( const VKEY_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnChar( const CHAR_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnMouseMove( const MOUSE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnLMouseButtonDown( const MOUSE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnLMouseButtonUp( const MOUSE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnLMouseButtonDblClick( const MOUSE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnFocus( const FOCUS_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnDefocus( const FOCUS_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnTimer( const TIMER_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnCommand( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


#if 0 // Never really implemented
BOOL DISPATCHER::OnClick( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnDblClick( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnChange( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnSelect( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnEnter( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnDropDown( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}
#endif


#if 0 // disabled - no clients
BOOL DISPATCHER::OnScrollBar( const SCROLL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnScrollBarThumb( const SCROLL_THUMB_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}
#endif


/*********************************************************************

    NAME:       DISPATCHER::OnQDlgCode

    SYNOPSIS:   Return the dialog messages-needed code for custom ctrls

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        15-May-1992 Created

*********************************************************************/

ULONG DISPATCHER::OnQDlgCode()
{
    // Default implementation - do whatever default proc says
    return 0;
}


/*********************************************************************

    NAME:       DISPATCHER::OnQHitTest

    SYNOPSIS:   Return the hit-test code

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        18-May-1992 Created

*********************************************************************/

ULONG DISPATCHER::OnQHitTest( const XYPOINT & xy )
{
    UNREFERENCED(xy);

    // Default implementation - do whatever default proc says.

    // Here the custom control dispatcher design fails me, since
    // 0 has a meaning of its own.

    return HT_DO_DEFAULT;
}


/*********************************************************************

    NAME:       DISPATCHER::OnQMouseActivate

    SYNOPSIS:   Return whether a mouseclick will activate a control

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        18-May-1992 Created

*********************************************************************/

ULONG DISPATCHER::OnQMouseActivate( const QMOUSEACT_EVENT & e )
{
    UNREFERENCED(e);

    // Default implementation - do whatever default proc says
    return 0;
}


/*********************************************************************

    NAME:       DISPATCHER::OnQMouseCursor

    SYNOPSIS:   Give the window a chance to change the cursor

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        21-May-1992 Created

*********************************************************************/

BOOL DISPATCHER::OnQMouseCursor( const QMOUSEACT_EVENT & e )
{
    UNREFERENCED(e);

    // Default implementation - do whatever default proc says
    return FALSE;
}


/*******************************************************************

    NAME:       DISPATCHER::CaptureMouse

    SYNOPSIS:   Capture mouse input

    ENTRY:      Window may or may not have the mouse

    EXIT:       Window has the mouse

    NOTES:
        Should this function return the previous owner?  The API
        does provide that.

    HISTORY:
        beng        10-May-1991     Implemented

********************************************************************/

VOID DISPATCHER::CaptureMouse()
{
    ::SetCapture(QueryHwnd());
}


/*******************************************************************

    NAME:       DISPATCHER::ReleaseMouse

    SYNOPSIS:   Release mouse input after a CaptureMouse

    ENTRY:      Window has the mouse

    EXIT:       Window no longer has the mouse

    NOTES:

    HISTORY:
        beng        10-May-1991     Implemented

********************************************************************/

VOID DISPATCHER::ReleaseMouse()
{
    ::ReleaseCapture();
}


/*******************************************************************

    NAME:       DISPATCHER::QueryRobustHwnd

    SYNOPSIS:   Returns a Hwnd for MsgPopup's parent

    RETURNS:    Dependable HWND

    NOTES:

    HISTORY:
        beng        10-May-1991     Implemented

********************************************************************/

HWND DISPATCHER::QueryRobustHwnd() const
{
    return QueryHwnd();
}


/*********************************************************************

    NAME:       DISPATCHER::QueryHwnd

    SYNOPSIS:   return the associated CONTROL_WINDOW window handler

    RETURN:     HWND - the associated window handler

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

HWND DISPATCHER::QueryHwnd() const
{
    return _pwnd->QueryHwnd();
}


/*********************************************************************

    NAME:       DISPATCHER::DoChar

    SYNOPSIS:   Call the OnChar method

    ENTRY:      CHAR_EVENT event - character event

    RETURN:     BOOL - return whether the subroutine has handled the
                       message or not.

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

BOOL DISPATCHER::DoChar( const CHAR_EVENT & event )
{
    return OnChar( event );
}


/*********************************************************************

    NAME:       DISPATCHER::DoUserMessage

    SYNOPSIS:   Call the OnUserMessage method

    ENTRY:      EVENT event - general event

    RETURN:     BOOL - return whether the subroutine has handled the
                       message or not

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

BOOL DISPATCHER::DoUserMessage( const EVENT & event )
{
    return OnUserMessage( event );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltfont.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltfont.cxx
    This file contains the implementation for the BLT FONT class.


    FILE HISTORY:
        Johnl       03-Apr-1991     Created
        beng        14-May-1991     Exploded blt.hxx into components
        terryk      26-Nov-1991     Added FIX_PITCH font
        terryk      02-Dec-1991     Changed FIX_PITCH font from FF_SWISS
                                    to FF_MODERN
        terryk      20-Feb-1992     Added Courier as the default fixed
                                    font

*/

#include "pchblt.hxx"
#include "bltrc.h" // IDS_FIXED_TYPEFACE_NAME

// Local manifests

#define DEFAULT_TYPEFACE_SIZE       8
#define DEFAULT_PITCHFAMILY         VARIABLE_PITCH | FF_SWISS
#define DEFAULT_WEIGHT              FW_NORMAL

#define DEFAULT_TYPEFACE_NAME       SZ("MS Shell Dlg")
#define DEFAULT_FIXED_TYPEFACE_NAME SZ("Courier")
#define DEFAULT_FIXED_PITCHFAMILY   FIXED_PITCH | FF_MODERN

/*******************************************************************

    NAME:     FONT::FONT

    SYNOPSIS: FONT class constructor.  The constructor does all the
              hard work of building the LOGFONT structure then calls
              SetFont( LOGFONT ).

    ENTRY:    A valid FontType enumeration

    EXIT:     The handle is initialized to the created font or a ReportError
              is called.

    NOTES:

    HISTORY:
        Johnl       03-Apr-1991 Created
        beng        05-Oct-1991 Win32 conversion

********************************************************************/

FONT::FONT( enum FontType Font )
{
    _hFont = NULL;

    LOGFONT logfont;

    /* We take the negative of the point size because we want the point
     * value to indicate the total ascent as opposed to a total height.
     */
#ifdef FE_SB // FONT::FONT() not need ifdef block. just for mark.
    if ( NETUI_IsDBCS() )
    {
        // We use 9pt as system default. 8pt is a little small and dirty...
        logfont.lfHeight       = -BLTPoints2LogUnits(DEFAULT_TYPEFACE_SIZE+1);
    } else
#endif
    logfont.lfHeight           = -BLTPoints2LogUnits(DEFAULT_TYPEFACE_SIZE);
    logfont.lfWidth            = 0;
    logfont.lfEscapement       = 0;
    logfont.lfOrientation      = 0;
    {
        DWORD cp = ::GetACP();
        CHARSETINFO csi;
#ifdef FE_SB // Bug fix....
        if (::TranslateCharsetInfo((DWORD *)UIntToPtr(cp), &csi, TCI_SRCCODEPAGE))
#else
        if (::TranslateCharsetInfo(&cp, &csi, TCI_SRCCODEPAGE))
#endif // FE_SB
            logfont.lfCharSet = (UCHAR)csi.ciCharset;
        else
            logfont.lfCharSet = ANSI_CHARSET;
    }
    logfont.lfOutPrecision     = (UCHAR)OUT_DEFAULT_PRECIS;
    logfont.lfClipPrecision    = CLIP_DEFAULT_PRECIS;
    logfont.lfQuality          = DEFAULT_QUALITY;
    logfont.lfPitchAndFamily   = (UCHAR)(( Font == FONT_DEFAULT_FIXED_PITCH )
       ? DEFAULT_FIXED_PITCHFAMILY : DEFAULT_PITCHFAMILY);

    if ( NETUI_IsDBCS() )
    {
        if ( Font == FONT_DEFAULT_FIXED_PITCH )
        {
            // Use localized facename instead of hardcoded one.
            NLS_STR *nlsFixedTypefaceName = new NLS_STR;
            nlsFixedTypefaceName->Load((MSGID)IDS_FIXED_TYPEFACE_NAME);
            ::strcpyf( (TCHAR *)logfont.lfFaceName, nlsFixedTypefaceName->QueryPch() );
            delete nlsFixedTypefaceName;
        }
        else
        {
            ::strcpyf( (TCHAR *)logfont.lfFaceName, DEFAULT_TYPEFACE_NAME );
        }
    }
    else
    {
        ::strcpyf( (TCHAR *)logfont.lfFaceName,( Font == FONT_DEFAULT_FIXED_PITCH )?
            DEFAULT_FIXED_TYPEFACE_NAME:DEFAULT_TYPEFACE_NAME );
    }

    logfont.lfUnderline        = 0;
    logfont.lfStrikeOut        = 0;
    logfont.lfItalic           = ( Font == FONT_DEFAULT_ITALIC ||
                                   Font == FONT_DEFAULT_BOLD_ITALIC
                                   ? 1 : 0
                                 );
    logfont.lfWeight           = ( Font == FONT_DEFAULT_BOLD   ||
                                   Font == FONT_DEFAULT_BOLD_ITALIC
                                   ? FW_BOLD : DEFAULT_WEIGHT
                                 );

    APIERR err = SetFont(logfont);
    if ( err != NERR_Success )
    {
        ReportError( err );
    }
}


/*******************************************************************

    NAME:     FONT::FONT

    SYNOPSIS: FONT class constructor.  This constructor takes a LOGFONT
              and passes it through to the SetFont method.


    ENTRY:    A valid, initialized LOGFONT structure.

    EXIT:     The handle is initialized to the created font or a ReportError
              is called.

    NOTES:

    HISTORY:
        Johnl       05-Apr-1991 Created
        beng        05-Oct-1991 Win32 conversion

********************************************************************/

FONT::FONT( const LOGFONT & logfont )
{
    _hFont = NULL;

    APIERR err = SetFont(logfont);
    if ( err != NERR_Success )
    {
        ReportError( err );
    }
}


/*******************************************************************

    NAME:     FONT::FONT

    SYNOPSIS: FONT class constructor.  This constructor takes some of the
              common attributes a person might want to apply to a font
              and builds a LOGFONT structure.  It then calls SetFont
              with the initialized LOGFONT structure.


    ENTRY:    pchFaceName is a pointer to a type face name ("Helv" etc.)
              lfPitchAndFamily is the same as in the LOGFONT structure
              nPointSize is the size of the font in points
              fontatt is one or a combination of the FontAttributes enum.

    EXIT:     The handle is initialized to the created font or ReportError
              is called.

    NOTES:

    HISTORY:
        Johnl       05-Apr-1991 Created
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

FONT::FONT( const TCHAR * pchFaceName, BYTE lfPitchAndFamily,
            INT nPointSize, enum FontAttributes fontatt )
{
    WORD wFontAtt = (WORD) fontatt;

    /* The font attributes must be the default attributes or some
     * combination of the other attributes.
     */
    UIASSERT( wFontAtt == FONT_ATT_DEFAULT   ||
               (
                 wFontAtt & FONT_ATT_ITALIC    ||
                 wFontAtt & FONT_ATT_BOLD      ||
                 wFontAtt & FONT_ATT_UNDERLINE ||
                 wFontAtt & FONT_ATT_STRIKEOUT
               )
            );

    _hFont = NULL;

    LOGFONT logfont;

    logfont.lfHeight           = -BLTPoints2LogUnits( nPointSize );
    logfont.lfWidth            = 0;
    logfont.lfEscapement       = 0;
    logfont.lfOrientation      = 0;
    {
        DWORD cp = GetACP();
        CHARSETINFO csi;
#ifdef FE_SB // FONT::FONT() Bug fix...
        if (::TranslateCharsetInfo((DWORD *)UIntToPtr(cp), &csi, TCI_SRCCODEPAGE))
#else
        if (::TranslateCharsetInfo(&cp, &csi, TCI_SRCCODEPAGE))
#endif // FE_SB
            logfont.lfCharSet = (UCHAR)csi.ciCharset;
        else
            logfont.lfCharSet = ANSI_CHARSET;
    }
    logfont.lfOutPrecision     = OUT_DEFAULT_PRECIS;
    logfont.lfClipPrecision    = CLIP_DEFAULT_PRECIS;
    logfont.lfQuality          = DEFAULT_QUALITY;
    logfont.lfPitchAndFamily   = lfPitchAndFamily;
    ::strcpyf( (TCHAR *)logfont.lfFaceName, pchFaceName );

    logfont.lfUnderline        = wFontAtt & FONT_ATT_UNDERLINE;
    logfont.lfStrikeOut        = wFontAtt & FONT_ATT_STRIKEOUT;
    logfont.lfItalic           = wFontAtt & FONT_ATT_ITALIC;
    logfont.lfWeight           = (wFontAtt & FONT_ATT_BOLD ? FW_BOLD : FW_NORMAL );

    APIERR err = SetFont(logfont);
    if ( err != NERR_Success )
    {
        ReportError( err );
    }
}


/*******************************************************************

    NAME:     FONT::~FONT

    SYNOPSIS: FONT class destructor, destroys the font if it was successfully
              created

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Johnl   03-Apr-1991     Created

********************************************************************/

FONT::~FONT()
{
    if ( _hFont != NULL )
        ::DeleteObject( (HGDIOBJ)_hFont );
}


/*******************************************************************

    NAME:     FONT::SetFont

    SYNOPSIS: Creates a font based on the passed LOGFONT structure.

    ENTRY:    logfont is an initialized LOGFONT structure.

    EXIT:     _hFont is initialized to the newly created font and TRUE
              is returned, else an error occurred and FALSE is returned.
              If FALSE is returned, the previous Font will still be
              active.

    RETURNS:  NERR_Success if successful

    HISTORY:
        Johnl       05-Apr-1991 Created
        beng        05-Oct-1991 Returns APIERR
        beng        06-Nov-1991 Uses MapLastError

********************************************************************/

APIERR FONT::SetFont( const LOGFONT & logfont )
{
    HFONT hFontNew = ::CreateFontIndirect( (LOGFONT *)&logfont );
    if ( hFontNew == NULL )
    {
        return BLT::MapLastError(ERROR_GEN_FAILURE);
    }

    if ( _hFont != NULL )
        ::DeleteObject( (HGDIOBJ)_hFont );

    _hFont = hFontNew;

    return NERR_Success;
}


/*******************************************************************

    NAME:       FONT::SetFont

    SYNOPSIS:   Sets the font handle to the passed HFONT

    ENTRY:      HFONT should be a valid font handle or NULL.

    EXIT:

    RETURNS:    NERR_Success, always

    NOTES:

    HISTORY:
        Johnl       05-Apr-1991 Created
        beng        05-Oct-1991 Returns APIERR for consistency

********************************************************************/

APIERR FONT::SetFont( HFONT hNewFont )
{
    _hFont = hNewFont;
    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltfunc.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltfunc.cxx
    Contain all the stand alone functions for the blt package.

    BLTDoubleChar( NLS_STR *pnls, TCHAR ch ) - double the given character
                                                in the given nls string

    FILE HISTORY:
	terryk	    3-Apr-1991	    Added BLTDoubleChar()
	terryk	    16-Apr-1991     second code review changed.
				    Attend: johnl jonn rustanl gregj
	beng	    14-May-1991     Exploded blt.hxx into components

*/

#include "pchblt.hxx"

/*********************************************************************

    NAME:	BLTDoubleChar

    SYNOPSIS:	double a special character within the given string

    ENTRY:	NLS_STR *pnlsStr - pointer to the given string
		TCHAR chSpecChar - an escape character

    EXIT:	The procedure will change the *pnlsStr if everything is okay.
		Otherwise, *pnlsStr is unchanged.

    RETURN:	USHORT - return either NERR_Success or API_ERROR

    NOTES:

    HISTORY:
	terryk	    8-Apr-1991	creation
	terryk	    16-Apr-1991 second code review changed
	beng	    04-Oct-1991 Win32 conversion
	beng	    21-Nov-1991 Replace owner-alloc string

**********************************************************************/

APIERR BLTDoubleChar( NLS_STR * pnlsStr, TCHAR chSpecChar )
{
    UIASSERT( pnlsStr != NULL );

    if ( pnlsStr->QueryError() != NERR_Success )
    {
	return pnlsStr->QueryError();
    }

    TCHAR achSpecChar[ 2 ];   // special character + NULL

    achSpecChar[0] = chSpecChar;
    achSpecChar[1] = TCH('\0');

    const ALIAS_STR nlsSpecChar( achSpecChar );

    // We need to keep a copy of the original string in case of error

    NLS_STR nlsOriginalString = *pnlsStr;
    if (!nlsOriginalString)
    {
	return nlsOriginalString.QueryError();
    }

    ISTR istrStartPos( *pnlsStr );
    ISTR istrPosition( *pnlsStr );

    // keep double the special character until we cannot find any more

    while ( pnlsStr->strchr( &istrPosition, chSpecChar, istrStartPos ))
    {
	pnlsStr->InsertStr( nlsSpecChar, istrPosition );
	if (pnlsStr->QueryError() != NERR_Success)
        {
            // Restore the original string

	    *pnlsStr = nlsOriginalString;
	    return pnlsStr->QueryError();
        }

        // skip the double characters
        istrStartPos = istrPosition;
        istrStartPos += 2;
    }

    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltdlgxp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltdlgxp.cxx

    Expandable dialog class implementation.

    This class represents a standard BLT DIALOG_WINDOW which can
    be expanded once to reveal new controls.  All other operations
    are common between EXPANDABLE_DIALOG and DIALOG_WINDOW.

    To construct, provide the control ID of two controls: a "boundary"
    static text control (SLT) and an "expand" button.

    See BLTDLGXP.HXX for more details.

    FILE HISTORY:
        DavidHov      11/1/91      Created

*/
#include "pchblt.hxx"

/*******************************************************************

    NAME:       EXPANDABLE_DIALOG::EXPANDABLE_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      CID cidBoundary        the control ID of the "boundary"
                                        control
                CID cidExpandButn      the control ID of the "expand"
                                        button
                INT cPxBoundary        size in dlg units to use a minimum
                                        distance from border required
                                        to force use of new border

    EXIT:       normal for subclasses of BASE

    RETURNS:    nothing

    NOTES:

    HISTORY:
                DavidHov    11/1/91    Created

********************************************************************/

EXPANDABLE_DIALOG::EXPANDABLE_DIALOG
   ( const TCHAR * pszResourceName, HWND hwndOwner,
     CID cidBoundary, CID cidExpandButn, INT cPxBoundary )
    : DIALOG_WINDOW ( pszResourceName, hwndOwner ),
    _sltBoundary( this, cidBoundary ),
    _butnExpand( this, cidExpandButn ),
    _xyOriginal( 0, 0 ),
    _cPxBoundary( cPxBoundary ),
    _fExpanded( FALSE )
{
    // nothing else
}


/*******************************************************************

    NAME:       EXPANDABLE_DIALOG::EXPANDABLE_DIALOG

    SYNOPSIS:   destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      does nothing.

    HISTORY:

********************************************************************/
EXPANDABLE_DIALOG::~ EXPANDABLE_DIALOG ()
{
}


/*******************************************************************

    NAME:       EXPANDABLE_DIALOG::ShowArea()

    SYNOPSIS:   Grows or shrinks the dialog based upon the BOOL
                parameter and the location of the boundary control.

    ENTRY:      BOOL fFull              if TRUE, expand the dialog;
                                        otherwise, show default size.

    EXIT:       nothing

    RETURNS:    nothing

    NOTES:      Calls virtual OnExpand() member when it is about to
                exposed the previously hidden controls.

    HISTORY:

********************************************************************/

VOID EXPANDABLE_DIALOG::ShowArea ( BOOL fFull )
{
    //  If this is the first call, save the size of the dialog

    if ( _xyOriginal.QueryHeight() <= 0 )
    {
        _xyOriginal = QuerySize() ;

        //  Hide and disable the boundary control
        _sltBoundary.Show( FALSE ) ;
        _sltBoundary.Enable( FALSE ) ;
    }

    //  Iterate over child controls; dis/enable child controls in
    //  the expanded region to preserve tab ordering, etc.

    ITER_CTRL itCtrl( this ) ;
    CONTROL_WINDOW * pcw ;
    XYPOINT xyBoundary( _sltBoundary.QueryPos() ) ;

    for ( ; pcw = itCtrl() ; )
    {
        if ( pcw != & _sltBoundary )
        {
            XYPOINT xyControl( pcw->QueryPos() ) ;
            if (   xyControl.QueryX() >= xyBoundary.QueryX()
                || xyControl.QueryY() >= xyBoundary.QueryY() )
            {
                pcw->Enable( fFull ) ;
            }
        }
    }

    if ( ! fFull )  // Initial display; show only the default area
    {
        XYPOINT xyBoundary = _sltBoundary.QueryPos() ;
        XYDIMENSION dimBoundary = _sltBoundary.QuerySize();
        XYRECT rWindow ;

        //  Compute location of the lower right-hand edge of the boundary
        //  control relative to the full (i.e., not client) window.

        xyBoundary.SetX( xyBoundary.QueryX() + dimBoundary.QueryWidth() ) ;
        xyBoundary.SetY( xyBoundary.QueryY() + dimBoundary.QueryHeight() ) ;
        xyBoundary.ClientToScreen( QueryHwnd() ) ;
        QueryWindowRect( & rWindow ) ;
        xyBoundary.SetX( xyBoundary.QueryX() - rWindow.QueryLeft() ) ;
        xyBoundary.SetY( xyBoundary.QueryY() - rWindow.QueryTop() ) ;

        //  Check if the boundary control is "close" to the edge of the
        //  dialog in either dimension.  If so, use the original value.

        if ( (INT)(_xyOriginal.QueryHeight() - xyBoundary.QueryY()) <= _cPxBoundary )
            xyBoundary.SetY( _xyOriginal.QueryHeight() ) ;

        if ( (INT)(_xyOriginal.QueryWidth() - xyBoundary.QueryX()) <= _cPxBoundary )
            xyBoundary.SetX( _xyOriginal.QueryWidth() ) ;

        //  Change the dialog size.
        SetSize( xyBoundary.QueryX(), xyBoundary.QueryY(), TRUE ) ;
    }
    else            //  Full display; expand the dialog to original size
    {
        _fExpanded = TRUE ;

        //  Allow the owner to alter controls uncovered by the change
        OnExpand();

        //  Disable the one-way expand button
        _butnExpand.Enable( FALSE ) ;

        //  Set size to original full extent
        SetSize( _xyOriginal.QueryWidth(), _xyOriginal.QueryHeight(), TRUE ) ;
    }
}

    //  Reduce the size of the dialog based upon the boundary control
    //  and call the inherited 'Process' member.

/*******************************************************************

    NAME:       EXPANDABLE_DIALOG::Process

    SYNOPSIS:   Run the dialog after first displaying it in its default
                (reduced) size.

    ENTRY:      UINT * pnRetVal         return value from dialog

    EXIT:       APIERR  if failure to function

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

APIERR EXPANDABLE_DIALOG::Process ( UINT * pnRetVal )
{
    ShowArea( FALSE );
    return DIALOG_WINDOW::Process( pnRetVal ) ;
}


/*******************************************************************

    NAME:       EXPANDABLE_DIALOG::Process

    SYNOPSIS:   Run the dialog after first displaying it in its default
                (reduced) size.

    ENTRY:      BOOL * pfRetVal         BOOL return value from dialog

    EXIT:       APIERR  if failure to function

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

APIERR EXPANDABLE_DIALOG::Process ( BOOL * pfRetVal )
{
    ShowArea( FALSE );
    return DIALOG_WINDOW::Process( pfRetVal ) ;
}


/*******************************************************************

    NAME:       EXPANDABLE_DIALOG::OnExpand

    SYNOPSIS:   Virtual callout from ShowArea() when dialog is
                about to be expanded.  Overriding routines should
                be sure to set focus on an appropriate control.

    ENTRY:      nothing

    EXIT:       nothing

    RETURNS:    nothing

    NOTES:      none

    HISTORY:

********************************************************************/

VOID EXPANDABLE_DIALOG::OnExpand ()
{
    SetFocus( IDOK ) ;
}


/*******************************************************************

    NAME:       EXPANDABLE_DIALOG::OnCommand

    SYNOPSIS:   Override for DIALOG_WINDOW::OnCommand() that watches
                for activation of the "expand" button.

    ENTRY:      const CONTROL_EVENT & event

    EXIT:       TRUE if expand button was clicked.

    RETURNS:    BOOL return value from DIALOG_WINDOW::OnCommand()

    NOTES:      none

    HISTORY:

********************************************************************/

BOOL EXPANDABLE_DIALOG::OnCommand ( const CONTROL_EVENT & event )
{
    BOOL fResult ;

    if ( event.QueryCid() == _butnExpand.QueryCid() )
    {
        if ( ! _fExpanded )
            ShowArea( TRUE ) ;

        fResult = TRUE ;
    }
    else
    {
        fResult =  DIALOG_WINDOW::OnCommand( event ) ;
    }
    return fResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltgroup.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltgroup.cxx
    This file contains the code to handle the CONTROL_GROUP stuff of BLT.
    The default virtual definitions for CONTROL_VALUE are also here.

    FILE HISTORY:
        Johnl       23-Apr-1991     Created
        beng        14-May-1991     Exploded blt.hxx into components
        terryk      10-Jul-1991     Added CVSaveValue and CVRestoreValue
                                    for CONTROL_GROUP to access the CONTROL_VALUE's
                                    protected member.
        Johnl       17-Sep-1991     Allowed SetSelection on operating magic group

*/

#include "pchblt.hxx"   // Precompiled header

DEFINE_ARRAY_LIST_OF( CONTROLVAL_CID_PAIR )

/*******************************************************************

    NAME:       CONTROL_VALUE::SaveValue

    SYNOPSIS:   See class CONTROL_VALUE

    NOTES:
        This default implementation does nothing.

    HISTORY:
        Johnl   23-Apr-1991     Created

********************************************************************/

VOID CONTROL_VALUE::SaveValue( BOOL fInvisible )
{
    UNREFERENCED( fInvisible );
    return;
}


/*******************************************************************

    NAME:       CONTROL_VALUE::RestoreValue

    SYNOPSIS:   See class CONTROL_VALUE

    NOTES:
        This default implementation does nothing.

    HISTORY:
        Johnl   23-Apr-1991     Created

********************************************************************/

VOID CONTROL_VALUE::RestoreValue( BOOL fInvisible )
{
    UNREFERENCED( fInvisible );
    return;
}

/*******************************************************************

    NAME:       CONTROL_VALUE::SetTabStop

    SYNOPSIS:   See class CONTROL_VALUE

    NOTES:
        This default implementation does nothing.

    HISTORY:
        Yi-HsinS  29-May-1992   Created

********************************************************************/

VOID CONTROL_VALUE::SetTabStop( BOOL fTabStop )
{
    UNREFERENCED( fTabStop );
    return;
}

/*******************************************************************

    NAME:     CONTROL_VALUE::QueryEventEffects

    SYNOPSIS: This is the default definition for IsValueChangeMessage
              (returns FALSE).  See class CONTROL_VALUE for more
              information.
    ENTRY:

    EXIT:

    HISTORY:
        Johnl       23-Apr-1991 Created
        beng        31-Jul-1991 Renamed, from QMessageInfo
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

UINT CONTROL_VALUE::QueryEventEffects( const CONTROL_EVENT & e )
{
    UNREFERENCED( e );
    return CVMI_NO_VALUE_CHANGE;
}


/*******************************************************************

    NAME:     CONTROL_VALUE::SetControlValueFocus

    SYNOPSIS: Tells a control value to set the focus to itself

    EXIT:     The control value should now have the focus

    NOTES:

    HISTORY:
        Johnl   02-May-1991     Created

********************************************************************/

VOID CONTROL_VALUE::SetControlValueFocus()
{
    return;
}


/*******************************************************************

    NAME:     CONTROL_GROUP::OnUserAction

    SYNOPSIS: Default virtual methods for the CONTROL_GROUP class

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

APIERR CONTROL_GROUP::OnUserAction( CONTROL_WINDOW * pcontwin,
                                    const CONTROL_EVENT & e )
{
    UNREFERENCED( pcontwin );
    UNREFERENCED( e );
    return NERR_Success;
}


/*******************************************************************

    NAME:     CONTROL_GROUP::OnGroupAction

    SYNOPSIS: Default virtual methods for the CONTROL_GROUP class

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

APIERR CONTROL_GROUP::OnGroupAction( CONTROL_GROUP * pChildGroup )
{
    UNREFERENCED( pChildGroup );
    return NERR_Success;
}


/*******************************************************************

    NAME:     CONTROL_GROUP::AfterGroupActions

    SYNOPSIS: Default virtual methods for the CONTROL_GROUP class

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

VOID CONTROL_GROUP::AfterGroupActions()
{
    return;
}


/**********************************************************\

    NAME:       CONTROL_GROUP::CVSaveValue

    SYNOPSIS:   Call the SaveValue function of the control value object

    ENTRY:      CONTROL_VALUE *pcv - pointer to the control value object

    NOTES:      CONTROL_GROUP is a friend of CONTROL_VALUE group

    HISTORY:
                terryk  11-Jul-1991 Created

\**********************************************************/

VOID CONTROL_GROUP::CVSaveValue( CONTROL_VALUE * pcv, BOOL fInvisible )
{
    pcv->SetTabStop( FALSE );
    pcv->SaveValue( fInvisible );
}


/**********************************************************\

    NAME:       CONTROL_GROUP::CVRestoreValue

    SYNOPSIS:   Call the RestoreValue function of the control value object

    ENTRY:      CONTROL_VALUE *pcv - pointer to the control value object

    NOTES:      CONTROL_GROUP is a friend of CONTROL_VALUE group

    HISTORY:
                terryk  11-Jul-1991 Created

\**********************************************************/

VOID CONTROL_GROUP::CVRestoreValue( CONTROL_VALUE * pcv, BOOL fInvisible )
{
    pcv->SetTabStop( TRUE );
    pcv->RestoreValue( fInvisible );
}


/**********************************************************\

   NAME:       RADIO_GROUP::RADIO_GROUP

   SYNOPSIS:   constructor for the radio group

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
    rustanl     20-Nov-1990 Created
    beng        07-Nov-1991 Fix error reporting

\**********************************************************/

RADIO_GROUP::RADIO_GROUP( OWNER_WINDOW * powin,
                          CID cidBase,
                          INT crbSize,
                          CID cidInitialSelection,
                          CONTROL_GROUP * pgroupOwner )
    : CONTROL_GROUP( pgroupOwner ),
      _cidBase( cidBase ),
      _crbSize( 0 ),
      _cidCurrentSelection( cidInitialSelection ),
      _cidSavedSelection( cidInitialSelection ),
      _prb( NULL )
{
    if ( QueryError() )
        return;

    _prb = (RADIO_BUTTON *) new BYTE[crbSize*sizeof(RADIO_BUTTON)];
    if ( _prb == NULL )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }

    RADIO_BUTTON * prbTemp = _prb;
    for ( INT i = 0; i < crbSize; i++ )
    {
        new (prbTemp) RADIO_BUTTON( powin, cidBase + i );

        if ( prbTemp->QueryError() != NERR_Success )
        {
            ReportError(prbTemp->QueryError());
            return;
        }

        _prb[i].SetGroup( this );
        prbTemp++;
        _crbSize++;         // Only destruct the number of radio buttons
                            // constructed.
    }

    //  Set the initial selection
    SetSelection( cidInitialSelection );
}


/**********************************************************\

   NAME:       RADIO_GROUP::~RADIO_GROUP

   SYNOPSIS:   destructor for the radio group

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
    rustanl     20-Nov-1990     Created

\**********************************************************/

RADIO_GROUP::~RADIO_GROUP()
{
    //
    //  UPDATED for C++ 2.0: this code used to read:
    //    delete [_crbSize] _prb;
    //  which is INVALID for a user-constructed vector.
    //

    for ( INT i = 0 ; i < _crbSize ; i++ )
    {
        _prb[i].RADIO_BUTTON::~RADIO_BUTTON() ;
    }
    delete (void *) _prb ;
    _prb = NULL;
}


/**********************************************************\

   NAME:       RADIO_GROUP::QueryCount

   SYNOPSIS:   return the total number of control in the radio group

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
    rustanl     20-Nov-1990     Created

\**********************************************************/

INT RADIO_GROUP::QueryCount()
{
    return _crbSize;
}


/**********************************************************************

    NAME:       RADIO_GROUP::OnUserAction

    SYNOPSIS:   Calls SetSelection if a radio button was selected.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        Johnl       25-Apr-1991 Updated to use new GROUP
        beng        08-Oct-1991 Win32 conversion

**********************************************************************/

APIERR RADIO_GROUP::OnUserAction( CONTROL_WINDOW * pcwinControl,
                                  const CONTROL_EVENT & e )
{
    UNREFERENCED( e );

    /* We know lParam will be either BN_CLICKED or BN_DBLCLICKED
     */
    CID cidJustSelectedRB = pcwinControl->QueryCid();
    if ( QuerySelection() != cidJustSelectedRB )
    {
        /* The normal SetSelection also notifies all parent groups, which
         * we don't want.
         */
        SetSelectionDontNotifyGroups( cidJustSelectedRB );
        return NERR_Success;
    }

    return GROUP_NO_CHANGE;
}


/**********************************************************\

   NAME:       RADIO_GROUP::IsMember

   SYNOPSIS:   check whether the given radio button CID
               belongs to the group or not.

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
    rustanl     20-Nov-1990     Created

\**********************************************************/

BOOL RADIO_GROUP::IsMember( CID cid )
{
    return ( _cidBase <= cid && cid < _cidBase + _crbSize );
}


/**********************************************************************

    NAME:       RADIO_GROUP::SetSelection

    SYNOPSIS:   set the select in the radio button group

    ENTRY:
        cid     - control ID

    EXIT:

    NOTES:
        This SetSelection is meant to be called by
        RADIO_GROUP/MAGIC_GROUP users.  It manually notifies groups (by
        calling NotifyGroups).  We need to do this manually because
        normally the group notification is performed in DIALOG_WINDOW::
        DialogProc, but  won't get called through DialogProc if the client
        simply calls SetSelection (i.e., group notification only works for
        direct control manipulation (mouse click etc.)).

    HISTORY:
        rustanl     20-Nov-1990 Created
        Johnl       25-Apr-1991 Updated to use new CONTROL_GROUP
        beng        04-Oct-1991 Experiment with Self
        beng        08-Oct-1991 Win32 conversion

**********************************************************************/

VOID RADIO_GROUP::SetSelection( CID cid )
{
    UIASSERT( !QueryError() );
    UIASSERT( cid == RG_NO_SEL || IsMember( cid ) );

    RADIO_GROUP & Self = *this;

    CONTROL_EVENT eventFake(cid, BN_CLICKED);

    /* Clear the old check (if it was checked) and set the new check
     * (if a selection is specified), then save the newly selected
     * button (or absence there of).
     */
    if ( QuerySelection() != RG_NO_SEL )
    {
        Self[QuerySelection()]->NotifyGroups(eventFake);
        Self[QuerySelection()]->SetCheck(FALSE);
    }

    if ( cid != RG_NO_SEL )
    {
        Self[cid]->NotifyGroups(eventFake);
        Self[cid]->SetCheck(TRUE);
    }

    _cidCurrentSelection = cid;
}


/**********************************************************************

    NAME:       RADIO_GROUP::SetSelectionDontNotifyGroups

    SYNOPSIS:   Exactly the same as SetSelection, except doesn't notify
                groups.

    ENTRY:
        cid     - control ID

    EXIT:

    NOTES:
        This SetSelection is meant to be called by
        RADIO_GROUP/MAGIC_GROUP users.  It manually notifies groups (by
        calling NotifyGroups).  We need to do this manually because
        normally the group notification is performed in DIALOG_WINDOW::
        DialogProc, but  won't get called through DialogProc if the client
        simply calls SetSelection (i.e., group notification only works for
        direct control manipulation (mouse click etc.)).

    HISTORY:
        beng        08-Oct-1991 Header added

**********************************************************************/

VOID RADIO_GROUP::SetSelectionDontNotifyGroups( CID cid )
{
    UIASSERT( !QueryError() );
    UIASSERT( cid == RG_NO_SEL || IsMember( cid ) );

    RADIO_GROUP & Self = *this;

    /* Clear the old check (if it was checked) and set the new check
     * (if a selection is specified), then save the newly selected
     * button (or absence there of).
     */
    if ( QuerySelection() != RG_NO_SEL )
        Self[QuerySelection()]->SetCheck( FALSE );

    if ( cid != RG_NO_SEL )
        Self[cid]->SetCheck( TRUE );

    _cidCurrentSelection = cid;
}


/**********************************************************\

   NAME:       RADIO_GROUP::QuerySelection

   SYNOPSIS:   query selection

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
    rustanl     20-Nov-1990     Created

\**********************************************************/

CID RADIO_GROUP::QuerySelection() const
{
    UIASSERT( !QueryError() );
    return _cidCurrentSelection;
}


/**********************************************************\

    NAME:       RADIO_GROUP::operator[]

    SYNOPSIS:   returns a pointer to the radio button that has the
                the specified CID (control ID).

    ENTRY:

    EXIT:

    NOTES:
        CODEWORK - This should return a reference, not a pointer.

    HISTORY:
        rustanl     20-Nov-1990     Created

\**********************************************************/

RADIO_BUTTON * RADIO_GROUP::operator[]( CID cid )
{
    UIASSERT( !QueryError() );
    UIASSERT( IsMember( cid ) );

    //  Verify that object is not in an error state, and that the given
    //  cid is within the right range.
    if ( !IsMember( cid ) )
        return _prb;

    //  Return a pointer to the specified radio button
    return &(_prb[ cid - _cidBase ]);
}


/*******************************************************************

    NAME:       RADIO_GROUP::Enable

    SYNOPSIS:   Disables all of the radio buttons in this radio group
                (disables in the Windows sense, not the control value
                sense).

    ENTRY:      fEnable - TRUE to enable, FALSE to disable

    NOTES:

    HISTORY:
        Johnl   05-May-1992     Created

********************************************************************/

void RADIO_GROUP::Enable( BOOL fEnable )
{
    for ( int i = 0 ; i < QueryCount() ; i++ )
    {
        _prb[i].Enable( fEnable ) ;
    }
}

/*******************************************************************

    NAME:     RADIO_GROUP::SaveValue

    SYNOPSIS: Clears the current selection in this radio group


    EXIT:     The radio group no longer contains a current selection

    NOTES:

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

VOID RADIO_GROUP::SaveValue( BOOL fInvisible )
{
    UNREFERENCED( fInvisible );
    _cidSavedSelection = QuerySelection();
    SetSelectionDontNotifyGroups( RG_NO_SEL );
}


/*******************************************************************

    NAME:     RADIO_GROUP::RestoreValue

    SYNOPSIS: Restores RADIO_GROUP after SaveValue

    ENTRY:

    EXIT:

    NOTES:    See CONTROL_VALUE for more details.

    HISTORY:
        Johnl   25-Apr-1991     Created
********************************************************************/

VOID RADIO_GROUP::RestoreValue( BOOL fInvisible )
{
    UNREFERENCED( fInvisible );
    SetSelectionDontNotifyGroups( _cidSavedSelection );

    /* Cause an assertion if two RestoreValues are performed without
     * an intervening SaveValue.
     */
    _cidSavedSelection = 0;
}


/*******************************************************************

    NAME:     RADIO_GROUP::SetControlValueFocus

    SYNOPSIS: Redefines CONTROL_VALUE virtual.  Sets the focus to the
              currently selected radio button.


    EXIT:     The current radio button has the windows focus

    NOTES:

    HISTORY:
        Johnl       02-May-1991 Created
        Johnl       16-Sep-1991 Removed RG_NO_SEL assertion
        beng        04-Oct-1991 Experiment with Self

********************************************************************/

VOID RADIO_GROUP::SetControlValueFocus()
{
    /* If the current selection is no selection, then simply return (setting
     * focus to a button will automatically select it, so we just don't do
     * anything).
     */
    if ( QuerySelection() == RG_NO_SEL )
        return;

    RADIO_GROUP & Self = *this;

    Self[QuerySelection()]->SetControlValueFocus();
}


/*******************************************************************

    NAME:      MAGIC_GROUP::MAGIC_GROUP

    SYNOPSIS:  Magic group constructor, same parameters as RADIO_GROUP
               constructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Johnl   24-Apr-1991     Created
        Johnl   25-Jun-1991     Removed unnecessary check from
                                _actrlcidAssocations

********************************************************************/

MAGIC_GROUP::MAGIC_GROUP( OWNER_WINDOW * powin,
                          CID cidBase,
                          INT crbSize,
                          CID cidInitialSelection,
                          CONTROL_GROUP * pgroupOwner     )
    : CONTROL_GROUP( pgroupOwner ),
      _rg( powin, cidBase, crbSize, cidInitialSelection, this ),
      _cidCurrentRBSelection( cidInitialSelection ),
      _actrlcidAssociations( 1 )    // Default to having 1 control
{
    /* We don't need to check _actrlcidAssociations (an ARRAY_LIST) since
     * we are guaranteed it will construct.  It may not construct the size
     * we request, in which case, AddAssociation will most likely fail.
     */

    if ( _rg.QueryError() != NERR_Success )
    {
        ReportError( _rg.QueryError() );
        return;
    }
}


/*******************************************************************

    NAME:     MAGIC_GROUP::AddAssociation

    SYNOPSIS: Associates a Radio button in this magic group with a
              control.

    ENTRY:    cidRadio - The Control ID of the radio button to associate
                         this control with.
              pcontval - Pointer to the control value to be associated with
                         the passed radio button.

    EXIT:

    NOTES:    If the control value's associated radio button is not active,
              then SaveValue will be called on that control value.

    HISTORY:
        Johnl   24-Apr-1991     Created

********************************************************************/

APIERR MAGIC_GROUP::AddAssociation( CID cidRadio, CONTROL_VALUE * pcontval )
{
    UIASSERT( _rg.IsMember(cidRadio) );
    UIASSERT( pcontval != NULL );

    CONTROLVAL_CID_PAIR  contvalcidpair( cidRadio, pcontval );

    if ( !_actrlcidAssociations.Add( contvalcidpair ) )
        return ERROR_NOT_ENOUGH_MEMORY;

    pcontval->SetGroup( this );

    /* If the radio button we are adding the association to is not checked,
     * do a SaveValue on it.
     */
    if ( !_rg[ cidRadio ]->QueryCheck() )
        CVSaveValue( pcontval );

    return NERR_Success;
}


/*******************************************************************

    NAME:     MAGIC_GROUP::ActivateAssocControls

    SYNOPSIS: Calls RestoreValue and SaveValue on the controls that
              are being activated and inactivated, respectively.

    ENTRY:    cidNewRBSelection - The radio button that is newly selected
                                  (can be RG_NO_SEL).
              cidOldRBSelection - The radio button that is losing the selection
                                  (can be RG_NO_SEL).
              pctrlval          - The control that the user is currently on
                                  (won't be touched, can be NULL).

    EXIT:     The controls associated with cidNewRBSelection are activated
              and the controls associated with cidOldRBSelection are
              deactivated.

    NOTES:    pcontvalHasFocus should only point to a control belonging to
              the group that is going to be activated.

              If cidNewRBSelection and cidOldRBSelection are the same, then
              cidNewRBSelection will be activated and cidOldRBSelection will
              be ignored.

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

VOID MAGIC_GROUP::ActivateAssocControls( CID  cidNewRBSelection,
                                         CID  cidOldRBSelection,
                                         CONTROL_VALUE * pctrlval )
{
    /* If we try to both activate and deactivate the same radio button,
     * then we will assume we just want to activate it
     */
    if ( cidNewRBSelection == cidOldRBSelection )
        cidOldRBSelection = RG_NO_SEL;

    for (UINT i = 0; i < _actrlcidAssociations.QueryCount(); i++ )
    {
        CONTROLVAL_CID_PAIR * pctrlcid = &_actrlcidAssociations[i];

        if ( pctrlcid->QueryRBCID() == cidNewRBSelection )
        {
             /* We don't want to Restore the control the user just
              * selected.
              */
             if ( pctrlcid->QueryContVal() != pctrlval      )
                 CVRestoreValue( pctrlcid->QueryContVal());
        }
        else if ( pctrlcid->QueryRBCID() == cidOldRBSelection )
        {
            CVSaveValue( pctrlcid->QueryContVal() );
        }
    }
}


/*******************************************************************

    NAME:     MAGIC_GROUP::OnUserAction

    SYNOPSIS: Virtual method that is called when a control belonging to this
              group received a message.  If the message indicates the
              control may have changed, this method will restore and save
              the appropriate associated controls.

    ENTRY:

    EXIT:

    NOTES:    This method only gets called when a control value belonging
              to this group receives a message (not when the radio buttons
              are messed with).

    HISTORY:
        Johnl       24-Apr-1991 Created
        beng        31-Jul-1991 Renamed QMessageInfo to QEventEffects
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

APIERR MAGIC_GROUP::OnUserAction( CONTROL_WINDOW *      pcwinControl,
                                  const CONTROL_EVENT & e )
{
    // C7 CODEWORK - remove Glock-pacifier cast
    UINT nChangeFlags = pcwinControl->QueryEventEffects( (const CONTROL_EVENT &)e );
    UIASSERT( (nChangeFlags == CVMI_NO_VALUE_CHANGE) ||
              (nChangeFlags == CVMI_VALUE_CHANGE )   ||
              (nChangeFlags == (CVMI_VALUE_CHANGE | CVMI_RESTORE_ON_INACTIVE )) );

    /* Do this first since this is the cheapest thing to do.
     */
    if ( nChangeFlags == CVMI_NO_VALUE_CHANGE )
        return GROUP_NO_CHANGE;

    /* Now we need to check what radio button may have been activated by the
     * change message on pcwinControl.  If the radio button associated with
     * this control is the same as the current selection and the button is
     * already active, then nothing has changed.
     */
    CID cidNew = FindAssocRadioButton( pcwinControl );
    if ( cidNew == _cidCurrentRBSelection   &&
         _rg[_cidCurrentRBSelection]->QueryCheck() )
    {
        return GROUP_NO_CHANGE;
    }

    /* Change the checked radio button to the new selection and inactivate
     * the controls associated with the old selection  and activate the
     * controls associated with the new selection except for the control
     * which now has the focus (i.e., the one that the user selected to
     * cause all of this), unless the client requests that the control be
     * restored (by specifying the CVMI_RESTORE_ON_INACTIVE).
     */
    _rg.SetSelectionDontNotifyGroups( cidNew );
    if ( nChangeFlags & CVMI_RESTORE_ON_INACTIVE )
        pcwinControl = NULL;

    ActivateAssocControls( cidNew, _cidCurrentRBSelection, pcwinControl );

    _cidCurrentRBSelection = cidNew;
    return NERR_Success;
}


/*******************************************************************

    NAME:     MAGIC_GROUP::OnGroupAction

    SYNOPSIS: Virtual method that is called when a child group has changed
              (i.e., our private RADIO_GROUP has changed or a child group
              acting as a control has changed).

    ENTRY:    pgroupChild is a pointer to the group that has changed
                          (will either be the address of our private
                          radio group or a child group).

    EXIT:

    NOTES:    We assume this only gets called when there is an actual
              change (i.e., a *new* radio button is selected/ a new
              group is activated etc.).

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

APIERR MAGIC_GROUP::OnGroupAction( CONTROL_GROUP * pgroupChild )
{
    CID cidNew;

    /* If the group that changed is not our private member RADIO_GROUP, then
     *   some other child group has changed, so we need to select our
     *   radio button (in our RADIO_GROUP) that is associated with the
     *   newly activated group.
     * else
     *   It was our private radio group that was changed, since it selects
     *   itself (see OnUserAction) we just note which button now has the
     *   current selection.
     */
    if ( pgroupChild != &_rg )
    {
        cidNew = FindAssocRadioButton( pgroupChild );

        /* If the radio button associated with the changed control is the
         * current selection and there is a current selection
         * and it is checked, then simply ignore and return,
         */
        if ( cidNew == _rg.QuerySelection()  &&
            _cidCurrentRBSelection != RG_NO_SEL &&
            _rg[_cidCurrentRBSelection]->QueryCheck() )
        {
            return GROUP_NO_CHANGE;
        }

        _rg.SetSelectionDontNotifyGroups( cidNew );
    }
    else
    {
        cidNew = _rg.QuerySelection();
    }

    ActivateAssocControls( cidNew, _cidCurrentRBSelection, pgroupChild );

    _cidCurrentRBSelection = cidNew;

    return NERR_Success;
}


/*******************************************************************

    NAME:     MAGIC_GROUP::FindAssocRadioButton

    SYNOPSIS: Returns the CID associated with the pcontvalue

    ENTRY:    pcontvalue is the control value pointer the radio button
              CID is associated with.

    EXIT:     Returns the associated radio button CID or 0 if none
              is found.

    NOTES:    Asserts out under DEBUG if no association exists.

    HISTORY:
        Johnl   25-Apr-1991         Created

********************************************************************/

CID MAGIC_GROUP::FindAssocRadioButton( CONTROL_VALUE * pcontvalue )
{
    UIASSERT( pcontvalue != NULL );

    UINT i = 0;
    for ( ; i < _actrlcidAssociations.QueryCount() ; i++ )
    {
        if ( _actrlcidAssociations[i].QueryContVal() == pcontvalue )
            return _actrlcidAssociations[i].QueryRBCID();
    }

    DBGEOL(SZ("MAGIC_GROUP::FindAssocRadioButton - CONTROL_VALUE* not associated with RB!") );
    return 0;
}

/*******************************************************************

    NAME:       MAGIC_GROUP::Enable

    SYNOPSIS:   Disables all of the radio buttons and their associated
                controls.

    ENTRY:      fEnable - TRUE to enable, FALSE to disable

    NOTES:      WARNING - Currently disables only the radio buttons and not
                the associated controls.  To fix, CONTROL_VALUE needs an
                Enable method which will do the right thing.  This behavior
                is not currently needed by anyone but should be added if
                it is.

                CODEWORK - If we ever need to disable just a radio button
                and its associated controls, then add the radio buttons CID
                to this method.

    HISTORY:
        Johnl   05-May-1992     Created

********************************************************************/

void MAGIC_GROUP::Enable( BOOL fEnable )
{
#if 0
    // Add when Enable gets added to control value

    /* Disable each of the control values associated with this magic group.
     */
    for (INT i = 0; i < _actrlcidAssociations.QueryCount(); i++ )
    {
        _actrlcidAssociations[i].Enable( fEnable ) ;
    }
#endif
    /* Also disable the radio group that is contained in this magic group
     */
    _rg.Enable( fEnable ) ;
}


/*******************************************************************

    NAME:     MAGIC_GROUP::SaveValue

    SYNOPSIS: Clears the current selection of this magic group and Saves
              the values of all the associated controls

    EXIT:     The magic group no longer contains a current selection

    NOTES:

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

VOID MAGIC_GROUP::SaveValue( BOOL fInvisible )
{
    UNREFERENCED( fInvisible );
    /* Find the active radio button and inactivate the associated controls,
     * then save value on internal radio group.
     */
    if ( _rg.QuerySelection() != RG_NO_SEL )
        ActivateAssocControls( RG_NO_SEL, _rg.QuerySelection(), NULL );

    _rg.SaveValue();
    _cidCurrentRBSelection = RG_NO_SEL;
}


/*******************************************************************

    NAME:     MAGIC_GROUP::RestoreValue

    SYNOPSIS: Restores MAGIC_GROUP after SaveValue

    ENTRY:

    EXIT:

    NOTES:    See CONTROL_VALUE for more details.

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

VOID MAGIC_GROUP::RestoreValue( BOOL fInvisible )
{
    UNREFERENCED( fInvisible );
    _rg.RestoreValue();

    if ( _rg.QuerySelection() != RG_NO_SEL )
        ActivateAssocControls( _rg.QuerySelection(), RG_NO_SEL, NULL );

    _cidCurrentRBSelection = _rg.QuerySelection();
}


/*******************************************************************

    NAME:     MAGIC_GROUP::SetControlValueFocus

    SYNOPSIS: Redefines CONTROL_VALUE virtual.  Sets the focus to the
              currently selected radio button (which can be RG_NO_SEL).

    NOTES:

    HISTORY:
        Johnl   02-May-1991     Created
        Johnl   17-Sep-1991     Removed RG_NO_SEL assertion

********************************************************************/

VOID MAGIC_GROUP::SetControlValueFocus()
{
    _rg.SetControlValueFocus();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltgb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltgb.cxx
    BLT graphical pushbutton definitions

    This file implements the special "graphical pushbuttons" of BLT.

    CODEWORK: There's a lot of fat in here.  Looks like the disable flavor was
    coded by cut-and-paste.  Redundant ctors should be folded together
    (using the 2-in-1 subobject hack, perhaps).  Disable flavor should
    move to a separate .obj file so it isn't dragged into most apps.

    FILE HISTORY:
        gregj       05-Apr-1991     Created
        beng        14-May-1991     Exploded blt.hxx into components
        terryk      18-Jul-1991     Update header file and add a SetStatus()
                                    function to GRAPHICAL_BUTTON which takes
                                    a HBITMAP as its parameter.
                                    Also, change the constructor and add
                                    error checking in the constructor
        KeithMo     07-Aug-1992     STRICTified.
*/
#include "pchblt.hxx"   // Precompiled header

/*
    Distance, in pels, between text and focus box, all around.
    This is only used by the custom-draw code.
*/

#define FOCUS_DISTANCE  1


/*******************************************************************

    NAME:       GRAPHICAL_BUTTON::GRAPHICAL_BUTTON

    SYNOPSIS:   Constructor for a graphical pushbutton control.

    ENTRY:      powin     - owner of this control
                cid       - this control's ID
                hbmMain   - bitmap to display on the button face
                hbmStatus - bitmap to display as a status light
                            (defaults to NULL, meaning no status light)
        OR
        TCHAR * pszMainName - name of the main bitmap
        TCHAR * pszStatusName - name of the status bitmap


    EXIT:

    NOTES:      For best results, the status light bitmap should be
                a 10x10 color bitmap.

    HISTORY:
        gregj       05-Apr-1991 Created
        beng        15-May-1991 Names its parent constructor
        terryk      20-Jun-1991 change HBITMAP to BIT_MAP
        terryk      18-Jul-1991 Takes string name directly instead of
                                passing the string id to constructor
        beng        17-Sep-1991 Removed redundant classname arg
        beng        04-Aug-1992 Pruned unused HBITMAP versions
        KeithMo     13-Dec-1992 Moved guts to CtAux().

********************************************************************/
GRAPHICAL_BUTTON::GRAPHICAL_BUTTON( OWNER_WINDOW * powin,
                                    CID            cid,
                                    const TCHAR  * pszMainName,
                                    const TCHAR  * pszMainDisabledName,
                                    const TCHAR  * pszStatusName )
  : PUSH_BUTTON( powin, cid ),
    _pdmStatus( NULL ),
    _pdmMain( NULL ),
    _pdmMainDisabled( NULL )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Let CtAux() handle the grunt work.
    //

    CtAux( pszMainName, pszMainDisabledName, pszStatusName );
}

GRAPHICAL_BUTTON::GRAPHICAL_BUTTON( OWNER_WINDOW * powin,
                                    CID            cid,
                                    const TCHAR  * pszMainName,
                                    const TCHAR  * pszMainDisabledName,
                                    XYPOINT        xy,
                                    XYDIMENSION    dxy,
                                    ULONG          flStyle,
                                    const TCHAR  * pszStatusName )
  : PUSH_BUTTON( powin, cid, xy, dxy, flStyle ),
    _pdmStatus( NULL ),
    _pdmMain ( NULL ),
    _pdmMainDisabled( NULL )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Let CtAux() handle the grunt work.
    //

    CtAux( pszMainName, pszMainDisabledName, pszStatusName );
}

VOID GRAPHICAL_BUTTON::CtAux( const TCHAR * pszMainName,
                              const TCHAR * pszMainDisabledName,
                              const TCHAR * pszStatusName )
{
#if defined(DEBUG)
    {
        IDRESOURCE idresMain( pszMainName );
        IDRESOURCE idresMainDisabled( pszMainDisabledName );
        IDRESOURCE idresStatus( pszStatusName );

        UIASSERT( !idresMain.IsStringId() );
        UIASSERT( !idresMainDisabled.IsStringId() );
        UIASSERT( !idresStatus.IsStringId() );
    }
#endif

    APIERR err = NERR_Success;

    //
    //  Load the main button bitmap.
    //

    if( pszMainName != NULL )
    {
        _pdmMain = new DISPLAY_MAP( (BMID)(ULONG_PTR)pszMainName );

        err = ( _pdmMain == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                   : _pdmMain->QueryError();
    }

    //
    //  Load the main disabled bitmap.
    //

    if( ( err == NERR_Success ) && ( pszMainDisabledName != NULL ) )
    {
        _pdmMainDisabled = new DISPLAY_MAP( (BMID)(ULONG_PTR)pszMainDisabledName );

        err = ( _pdmMainDisabled == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                           : _pdmMainDisabled->QueryError();
    }

    //
    //  Load the status bitmap.
    //

    if( ( err == NERR_Success ) && ( pszStatusName != NULL ) )
    {
        _pdmStatus = new DISPLAY_MAP ( (BMID)(ULONG_PTR)pszStatusName );

        err = ( _pdmStatus == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                     : _pdmStatus->QueryError();
    }

    //
    //  Set the error state if something tragic happened.
    //

    if( err != NERR_Success )
    {
        ReportError( err );
    }
}


/*******************************************************************

    NAME:       GRAPHICAL_BUTTON::~GRAPHICAL_BUTTON

    SYNOPSIS:   Destructor for graphical pushbutton control

    EXIT:       Bitmaps are destroyed

    HISTORY:
                gregj   05-Apr-1991     Created

********************************************************************/

GRAPHICAL_BUTTON::~GRAPHICAL_BUTTON()
{
    delete _pdmMain;
    _pdmMain = NULL;

    delete _pdmMainDisabled;
    _pdmMainDisabled = NULL;

    delete _pdmStatus;
    _pdmStatus = NULL;
}


/*******************************************************************

    NAME:       GRAPHICAL_BUTTON::SetStatus

    SYNOPSIS:   Sets the status light bitmap for a graphical pushbutton

    ENTRY:      hbmNew - handle to a bitmap to draw as a status light
                         NULL for no status light

    EXIT:

    NOTES:
        This bitmap, unlike the main bitmap for the button,
        is not owned by the button itself and will not be
        destroyed when the control is destroyed.

    HISTORY:
        gregj       05-Apr-1991 Created
        terryk      18-Jul-1991 Add one more SetStatus which takes
                                a handle as a parameter

********************************************************************/

VOID GRAPHICAL_BUTTON::SetStatus( BMID bmidNewStatus )
{
    DISPLAY_MAP * pdmStatus = NULL;
    if ( bmidNewStatus != 0 )
    {
        pdmStatus = new DISPLAY_MAP ( bmidNewStatus );
        if ( pdmStatus->QueryError() != NERR_Success )
        {
            DBGEOL(SZ("BLTGB: cannot load bitmap."));
            return;
        }
    }

    _pdmStatus = pdmStatus;
    Invalidate();      // redraw button with new status
}

VOID GRAPHICAL_BUTTON::SetStatus( HBITMAP hbitmap )
{
#if 1
    UIASSERT( FALSE );  // can't do this for DISPLAY_MAPs!
#else
    if ( _pdmStatus == NULL )
    {
        BIT_MAP * pdmStatus = new BIT_MAP( hbitmap );
        if ( pdmStatus == NULL )
        {
            return;
        }
        else if ( pdmStatus->QueryError() != NERR_Success )
        {
            DBGEOL(SZ("BLTGB: cannot assign bitmap."));
            return;
        }
        _pdmStatus = pdmStatus;
        Invalidate();
        return;
    }
    _pdmStatus->SetBitmap ( hbitmap );
    Invalidate();
#endif
}


/*******************************************************************

    NAME:       GRAPHICAL_BUTTON::CD_Draw

    SYNOPSIS:   Custom draw routine for graphical pushbuttons

    ENTRY:      pdis - pointer to a DRAWITEMSTRUCT (see Windows ref.)

    EXIT:       Returns TRUE if the button was drawn successfully

    NOTES:      This method is protected, and only ShellDlgProc calls it.

    HISTORY:
        gregj       05-Apr-1991 Created
        gregj       01-May-1991 Added GUILTT support
        beng        15-May-1991 Uses XYDIMENSION object
        beng        04-Oct-1991 Win32 conversion
        KeithMo     21-Feb-1992 Use COLOR_BTNHIGHLIGHT instead of white.
        beng        30-Mar-1992 Unicode bugfix
        beng        05-May-1992 API changes
        beng        01-Jun-1992 GUILTT support changes
        beng        04-Aug-1992 Use some more DC members

********************************************************************/

BOOL GRAPHICAL_BUTTON::CD_Draw( DRAWITEMSTRUCT * pdis )
{
    RECT rcFace, rcImage;

    ::OffsetRect(&pdis->rcItem, -pdis->rcItem.left, -pdis->rcItem.top);
    pdis->rcItem.right--;
    pdis->rcItem.bottom--;

    /*  Cache the dimensions of the button, not counting the border.  */
    INT xLeft = pdis->rcItem.left+1;
    INT yTop = pdis->rcItem.top+1;
    INT xRight = pdis->rcItem.right-1;
    INT yBottom = pdis->rcItem.bottom-1;

    /*  Calculate the rectangle enclosing the button face and the rectangle
        enclosing the image.  */

    if (pdis->itemState & ODS_SELECTED)
    {
        rcFace.left = xLeft + 1;
        rcFace.top = yTop + 1;
        rcFace.right = xRight;
        rcFace.bottom = yBottom;
        rcImage.left = xLeft + 3;
        rcImage.top = yTop + 3;
        rcImage.right = xRight - 1;
        rcImage.bottom = yBottom - 1;
    }
    else
    {
        rcFace.left = xLeft + 2;
        rcFace.top = yTop + 2;
        rcFace.right = xRight - 2;
        rcFace.bottom = yBottom - 2;
        rcImage = rcFace;
    }


    DEVICE_CONTEXT dc(pdis->hDC);

    NLS_STR nlsButtonText;
    APIERR err = QueryText(&nlsButtonText);
    if (err != NERR_Success)
        nlsButtonText = (const TCHAR *)NULL;

    XYDIMENSION dxyExtent = dc.QueryTextExtent(nlsButtonText);

    RECT rcText;
    INT dxText = dxyExtent.QueryWidth();

    rcText.bottom = rcImage.bottom - 1;
    rcText.top = rcText.bottom - dxyExtent.QueryHeight() - (2 * FOCUS_DISTANCE);
    if (dxText > rcFace.right - rcFace.left - (2*FOCUS_DISTANCE))
        dxText = rcFace.right - rcFace.left - (2*FOCUS_DISTANCE) - 1;
    rcText.left = rcImage.left - FOCUS_DISTANCE +
                (rcImage.right - rcImage.left - dxText) / 2;
    rcText.right = rcText.left + (2 * FOCUS_DISTANCE) + dxText + 1;

    if (pdis->itemAction & (ODA_DRAWENTIRE | ODA_SELECT))
    {
        /* Draw the border first, in black, avoiding corner pels */
        HPEN hpenOld = dc.SelectPen( (HPEN)::GetStockObject(BLACK_PEN) );

        dc.MoveTo(xLeft, yTop - 1);      /* top line */
        dc.LineTo(xRight + 1, yTop - 1);
        dc.MoveTo(xLeft, yBottom + 1);   /* bottom line */
        dc.LineTo(xRight + 1, yBottom + 1);
        dc.MoveTo(xLeft - 1, yTop);      /* left line */
        dc.LineTo(xLeft - 1, yBottom + 1);
        dc.MoveTo(xRight + 1, yTop);     /* right line */
        dc.LineTo(xRight + 1, yBottom + 1);

        /*  Draw the dark gray shadow, above/left or below/right as
            appropriate.  */

        HPEN hpenDark = ::CreatePen(PS_SOLID, 1, ::GetSysColor(COLOR_BTNSHADOW));
        HPEN hpenWhite = ::CreatePen(PS_SOLID, 1, ::GetSysColor(COLOR_BTNHIGHLIGHT));

        dc.SelectPen(hpenDark);

        if (pdis->itemState & ODS_SELECTED)
        {
            /*  "Depressed" button;  just dark shadow above/left.  */
            dc.MoveTo(xLeft, yBottom);   /* lower left corner */
            dc.LineTo(xLeft, yTop);      /* draw left shadow */
            dc.LineTo(xRight, yTop);     /* draw top shadow */
        }
        else
        {
            /*  "Released" button;  light above/left, dark below/right.  */
            dc.MoveTo(xRight, yTop);     /* upper right */
            dc.LineTo(xRight, yBottom);  /* right shadow, outer column */
            dc.LineTo(xLeft, yBottom);   /* bottom shadow, outer row */
            dc.MoveTo(xRight-1, yTop+1); /* u.r., down/in one pel */
            dc.LineTo(xRight-1, yBottom-1); /* right shadow, inner col. */
            dc.LineTo(xLeft+1, yBottom-1);  /* bottom shadow, inner row */

            dc.SelectPen(hpenWhite);

            dc.MoveTo(xLeft, yBottom-1); /* lower left, up one pel */
            dc.LineTo(xLeft, yTop);      /* light slope, outer column */
            dc.LineTo(xRight-1, yTop);   /* outer row */
            dc.MoveTo(xLeft+1, yBottom-2); /* l.l., up/in one pel */
            dc.LineTo(xLeft+1, yTop+1);  /* inner column */
            dc.LineTo(xRight-2, yTop+1); /* inner row */
        }
        dc.SelectPen(hpenOld);
        if (hpenDark) // JonN 01/27/00 PREFIX bug 444897
            ::DeleteObject( (HGDIOBJ)hpenDark );
        if (hpenWhite) // JonN 01/27/00 PREFIX bug 444897
            ::DeleteObject( (HGDIOBJ)hpenWhite );

        /*  Paint the image area with button-face color.  */

        HBRUSH hbrFace = ::CreateSolidBrush(::GetSysColor(COLOR_BTNFACE));

        rcFace.right++;         /* adjust for FillRect not doing bottom & right */
        rcFace.bottom++;
        ::FillRect(dc.QueryHdc(), &rcFace, hbrFace);
        ::DeleteObject( (HGDIOBJ)hbrFace );
        rcFace.right--;
        rcFace.bottom--;

        /*  Draw the text.  */

        INT oldbm = dc.SetBkMode( TRANSPARENT );

        if( pdis->itemState & ODS_DISABLED )
        {
            //
            //  Draw the grey text in the "normal" position.
            //

            dc.SetTextColor(::GetSysColor(COLOR_BTNSHADOW));
            dc.DrawText(nlsButtonText, &rcText,
                        DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            //
            //  Now draw the white text offset towards the lower
            //  right corner.
            //

            RECT rcTmp = rcText;

            rcTmp.left++;
            rcTmp.right++;
            rcTmp.top++;
            rcTmp.bottom++;

            dc.SetTextColor(::GetSysColor(COLOR_BTNHIGHLIGHT));
            dc.DrawText(nlsButtonText, &rcTmp,
                        DT_CENTER | DT_VCENTER | DT_SINGLELINE);
        }
        else
        {
            dc.SetTextColor(::GetSysColor(COLOR_BTNTEXT));
            dc.DrawText(nlsButtonText, &rcText,
                        DT_CENTER | DT_VCENTER | DT_SINGLELINE);
        }

        dc.SetBkMode( oldbm );

        /*  Draw the bitmap.  */

        DISPLAY_MAP * pdm = NULL;

        if( pdis->itemState & ODS_DISABLED )
            pdm = _pdmMainDisabled;

        if( pdm == NULL )
            pdm = _pdmMain;

        if( pdm != NULL )
        {
            pdm->Paint( dc.QueryHdc(),
                        rcImage.left +
                            ( rcImage.right - rcImage.left -
                                pdm->QueryWidth() ) / 2,
                        rcImage.top + 3 );
        }

        /*  Draw the status indicator, if desired.  */

        if( _pdmStatus != NULL )
        {
            _pdmStatus->Paint( dc.QueryHdc(),
                               rcImage.left + 2,
                               rcImage.top + 2 );
        }

        if (pdis->itemState & ODS_FOCUS)
            dc.DrawFocusRect(&rcText);
    }
    else if (pdis->itemAction & ODA_FOCUS)
    {
        dc.DrawFocusRect(&rcText);
    }

    return TRUE;
}


/**********************************************************************

    NAME:       GRAPHICAL_BUTTON_WITH_DISABLE::GRAPHICAL_BUTTON_WITH_DISABLE

    SYNOPSIS:   constructor

    ENTRY:      See GRAPHICAL_BUTTON for detail

    NOTES:      This constructor is similar to the GRAPHICAL_BUTTON
                constructor. However, it has one more bitmap to specify
                which is the DISABLE bitmap.

    HISTORY:
        terryk      22-May-91   Created
        terryk      20-Jun-91   Change HBITMAP to bitmap
        terryk      19-Jul-91   Change the parent class to push button
        terryk      19-Jul-91   Take the bitmap name in the resource file
                                directly instead of getting a string id
        beng        17-Sep-1991 Removed redundant classname arg
        beng        04-Aug-1992 Pruned HBITMAP versions; load resources
                                by ordinal; simplify ctors

**********************************************************************/

GRAPHICAL_BUTTON_WITH_DISABLE::GRAPHICAL_BUTTON_WITH_DISABLE(
    OWNER_WINDOW *powin,
    CID           cid,
    BMID          nIdMain,
    BMID          nIdInvert,
    BMID          nIdDisable )
    : PUSH_BUTTON(powin, cid),
      _bmMain( nIdMain ),
      _bmMainInvert( nIdInvert ),
      _bmDisable( nIdDisable ),
      _fSelected( FALSE )
{
    APIERR err = QueryError();
    if ( err != NERR_Success )
        return;

    if (   ((err = _bmMain.QueryError()) != NERR_Success)
        || ((err = _bmMainInvert.QueryError()) != NERR_Success)
        || ((err = _bmDisable.QueryError()) != NERR_Success) )
    {
        ReportError(err);
        return;
    }
}

GRAPHICAL_BUTTON_WITH_DISABLE::GRAPHICAL_BUTTON_WITH_DISABLE(
    OWNER_WINDOW *powin,
    CID           cid,
    BMID          nIdMain,
    BMID          nIdInvert,
    BMID          nIdDisable,
    XYPOINT       xy,
    XYDIMENSION   dxy,
    ULONG         flStyle )
    : PUSH_BUTTON(powin, cid, xy, dxy, flStyle),
      _bmMain( nIdMain ),
      _bmMainInvert( nIdInvert ),
      _bmDisable( nIdDisable ),
      _fSelected( FALSE )
{
    APIERR err = QueryError();
    if ( err != NERR_Success )
        return;

    if (   ((err = _bmMain.QueryError()) != NERR_Success)
        || ((err = _bmMainInvert.QueryError()) != NERR_Success)
        || ((err = _bmDisable.QueryError()) != NERR_Success) )
    {
        ReportError(err);
        return;
    }
}


/**********************************************************************

    NAME:       GRAPHICAL_BUTTON_WITH_DISABLE::~GRAPHICAL_BUTTON_WITH_DISABLE

    SYNOPSIS:   destructor

    HISTORY:
        terryk      18-Jun-91   Created
        beng        04-Aug-1992 Clean up ctor/dtor

***********************************************************************/

GRAPHICAL_BUTTON_WITH_DISABLE::~GRAPHICAL_BUTTON_WITH_DISABLE()
{
    // all automatic
}


/**********************************************************************

    NAME:       GRAPHICAL_BUTTON_WITH_DISABLE::CD_Draw

    SYNOPSIS:   Redraw the graphical button

    ENTRY:      DRAWITEMSTRUCT *pdis - draw item information

    NOTES:      This CD_Draw routine is similar to the GRAPHICAL_BUTTON
                CD_Draw routine. The differents are:
                1. Instead of using Bitblt, it will use StretchBlt to
                   expand the bitmap to cover the whole button.
                2. You can specified a disable bitmap for disable purpose.

    HISTORY:
        terryk      22-May-91   Created
        terryk      19-Jul-91   It will change the window style in the
                                HWND. If the style contains GB_3D,
                                it will draw it in 3d, otherwise, it
                                will just display the button with a
                                different bitmap
        beng        04-Oct-1991 Win32 conversion
        KeithMo     21-Feb-1992 Use COLOR_BTNHIGHLIGHT instead of white.
        beng        30-Mar-1992 Unicode bugfix
        beng        01-Jun-1992 GUILTT support changes
        beng        04-Aug-1992 Use some more DC members
        terryk      10-Feb-1993 Remove the text part of the button.

**********************************************************************/

BOOL GRAPHICAL_BUTTON_WITH_DISABLE::CD_Draw( DRAWITEMSTRUCT * pdis )
{
    BOOL f3D = ((QueryStyle() & GB_3D) != 0);

    RECT rcFace, rcImage;

    ::OffsetRect(&pdis->rcItem, -pdis->rcItem.left, -pdis->rcItem.top);
    pdis->rcItem.right--;
    pdis->rcItem.bottom--;

    /*  Cache the dimensions of the button, not counting the border.  */
    INT xLeft = pdis->rcItem.left+1;
    INT yTop = pdis->rcItem.top+1;
    INT xRight = pdis->rcItem.right-1;
    INT yBottom = pdis->rcItem.bottom-1;

    /*  Calculate the rectangle enclosing the button face and the rectangle
        enclosing the image.  */

    if ((pdis->itemState & ( ODS_SELECTED | ODS_FOCUS)) || _fSelected )
    {
        rcFace.left = xLeft + 1;
        rcFace.top = yTop + 1;
        rcFace.right = xRight;
        rcFace.bottom = yBottom;
        rcImage.left = xLeft + 3;
        rcImage.top = yTop + 3;
        rcImage.right = xRight - 1;
        rcImage.bottom = yBottom - 1;
    }
    else
    {
        rcFace.left = xLeft + 2;
        rcFace.top = yTop + 2;
        rcFace.right = xRight - 2;
        rcFace.bottom = yBottom - 2;
        rcImage = rcFace;
    }


    DEVICE_CONTEXT dc(pdis->hDC);

    if ((pdis->itemAction & (ODA_DRAWENTIRE | ODA_SELECT | ODA_FOCUS)) || _fSelected)
    {
        /*  Draw the bitmap.  */

        MEMORY_DC mdc( dc );
        BITMAP bitmap;
        HBITMAP hbitmap = NULL; // JonN 01/27/00 PREFIX bug 444898

        if (!( pdis->itemState & ODS_DISABLED ))
        {
            if (( pdis->itemState & ODS_SELECTED ) || _fSelected )
            {
                // display invert bitmap
                hbitmap = QueryMainInvert();
            }
            else
            {
                // display normal bitmap
                hbitmap = QueryMain();
            }
        }
        else
        {
            // display disable bitmap
            hbitmap = QueryDisable();
        }

        // display bitmap
        if (NULL != hbitmap)
        {
            ::GetObject(hbitmap, sizeof(bitmap), (TCHAR*)&bitmap);
            mdc.SelectBitmap( hbitmap );
        }

        if ( f3D )
        {
            // fit the bitmap into the button position
            ::StretchBlt( dc.QueryHdc(), rcImage.left,
                          rcImage.top, rcImage.right - rcImage.left,
                          rcImage.bottom - rcImage.top,
                          mdc.QueryHdc(), 0, 0, bitmap.bmWidth,
                          bitmap.bmHeight, SRCCOPY);
        }
        else
        {
            // fit the bitmap into the button position
            ::StretchBlt( dc.QueryHdc(), xLeft, yTop, xRight - xLeft + 1,
                          yBottom - yTop + 1, mdc.QueryHdc(), 0, 0,
                          bitmap.bmWidth, bitmap.bmHeight, SRCCOPY);
        }

        /* Draw the border first, in black, avoiding corner pels */
        HPEN hpenOld = dc.SelectPen( (HPEN)::GetStockObject(BLACK_PEN) );

        dc.MoveTo(xLeft - 1,  yTop - 1);      /* top line */
        dc.LineTo(xRight + 2, yTop - 1);
        dc.MoveTo(xLeft - 1,  yBottom + 1);   /* bottom line */
        dc.LineTo(xRight + 2, yBottom + 1);
        dc.MoveTo(xLeft - 1,  yTop - 1);      /* left line */
        dc.LineTo(xLeft - 1,  yBottom + 1);
        dc.MoveTo(xRight + 1, yTop - 1);      /* right line */
        dc.LineTo(xRight + 1, yBottom + 1);

        if (( pdis->itemState &  ( ODS_SELECTED | ODS_FOCUS)) || _fSelected )
        {
            // draw the focus border

            dc.MoveTo(xLeft ,  yTop );      /* top line */
            dc.LineTo(xRight + 1, yTop);
            dc.MoveTo(xLeft ,  yBottom );   /* bottom line */
            dc.LineTo(xRight + 1, yBottom );
            dc.MoveTo(xLeft ,  yTop );      /* left line */
            dc.LineTo(xLeft ,  yBottom );
            dc.MoveTo(xRight , yTop );      /* right line */
            dc.LineTo(xRight , yBottom );
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltdlg.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltdlg.cxx
    BLT dialog class definitions

    FILE HISTORY:
        rustanl     20-Nov-1990 Created
        beng        11-Feb-1991 Uses lmui.hxx
        rustanl     04-Mar-1991 Changed Process format
        beng        14-May-1991 Exploded blt.hxx into components;
                                merged with bltsdp
        gregj       17-May-1991 Return correct error codes to GUILTT
        terryk      28-Jul-1991 Added FilterMessage function to DIALOG_WINDOW
        beng        28-Jul-1992 Add reference to hmodBlt
        KeithMo     07-Aug-1992 Massive revamping of helpfile management.
        jonn        07-Oct-1993 Added OnDlgActivation/OnDlgDeactivation
*/

#include "pchblt.hxx"

extern "C"
{
    /* C7 CODEWORK - nuke this stub */
    BOOL _EXPORT  APIENTRY BltDlgProc( HWND hdlg, WORD wMsg, WPARAM wParam, LPARAM lParam )
    {
        return DIALOG_WINDOW::DlgProc(hdlg, (USHORT)wMsg, wParam, lParam);
    }

    /* CODEWORK - remove this as soon as all clients convert */
    BOOL  APIENTRY ShellDlgProc(HWND hdlg, USHORT usMsg, WPARAM wParam, DWORD lParam )
    {
        UNREFERENCED(hdlg);
        UNREFERENCED(usMsg);
        UNREFERENCED(wParam);
        UNREFERENCED(lParam);
        ASSERT(FALSE);
        return FALSE;
    }
}


/**********************************************************************

    NAME:       HWND_DLGPTR_CACHE

    SYNOPSIS:   Cache for xlation of hwnd to a pdlg

    INTERFACE:  Find()   - find a dialog_window by the handle
                Add()    - add the dialog window to the current window handle
                Remove() - remove the window handle

    NOTES:
        This is a very simple cache, consisting of one entry only.
        The size and implementation of this cache can be changed to accomodate
        more entries.  More entries may or may not provide better overall
        performance.  The DIALOG_WINDOW class uses this class regardless of
        how many entries the cache has.  Hence, any changes in this cache need
        not cause any changes in the DIALOG_WINDOW implementation.

        CODEWORK: tune this!

    HISTORY:
        rustanl     20-Nov-1990     Created

**********************************************************************/

class HWND_DLGPTR_CACHE
{
private:
    static HWND hwndPrev;
    static DIALOG_WINDOW * pdlgPrev;

public:
    static DIALOG_WINDOW * Find( HWND hwnd );

    static VOID Add( HWND hwnd, DIALOG_WINDOW * pdlg );
    static VOID Remove( HWND hwnd );
};


HWND HWND_DLGPTR_CACHE::hwndPrev = NULL;

DIALOG_WINDOW * HWND_DLGPTR_CACHE::pdlgPrev = NULL;


/**********************************************************************

    NAME:       HWND_DLGPTR_CACHE::Find

    SYNOPSIS:   return the dialog_window handle

    ENTRY:      HWND hwnd - the hwnd of the return DIALOG_WINDOW

    RETURN:     return DIALOG_WINDOW * of the given HWND

    HISTORY:
        rustanl     20-Nov-1990     Created

**********************************************************************/

DIALOG_WINDOW * HWND_DLGPTR_CACHE::Find( HWND hwnd )
{
    if ( hwndPrev == hwnd )
        return pdlgPrev;

    return NULL;
}


/**********************************************************************

    NAME:       HWND_DLGPTR_CACHE::Add

    SYNOPSIS:   Add the dialog window handle to the cache

    ENTRY:      HWND hwnd - the HWND of the given DIALOG_WINDOW
                DIALOG_WINDOW * the dialog window for the given HWND

    HISTORY:
        rustanl     20-Nov-1990     Created

**********************************************************************/

VOID HWND_DLGPTR_CACHE::Add( HWND hwnd, DIALOG_WINDOW * pdlg )
{
    ASSERT( pdlg != NULL );    // should never add a NULL pointer

    hwndPrev = hwnd;
    pdlgPrev = pdlg;
}


/*********************************************************************

    NAME:       HWND_DLGPTR_CACHE::Remove

    SYNOPSIS:   Remove the dialog window handle from the cache

    ENTRY:      HWND hwnd - hwnd of the DIALOG_WINDOW to be removed

    HISTORY:
        rustanl     20-Nov-1990     Created

*********************************************************************/

VOID HWND_DLGPTR_CACHE::Remove( HWND hwnd )
{
    // Note, there is no guarantee that this item will actually be in the
    // cache; hence, we do not assert that it is.

    if ( hwndPrev == hwnd )
    {
        hwndPrev = NULL;
        pdlgPrev = NULL;
    }
}


/*******************************************************************

    NAME:       DLGLOAD::DLGLOAD

    SYNOPSIS:   Constructor - load a dialog from rsrc or template

    ENTRY:
        idrsrcDialog    - name of the application resource
        bufTemplate     - BUFFER object containing assembled template
        hwndOwner       - handle of owner window
        procinstDlg     - PROC_INSTANCE for dialog-proc

    EXIT:
        Loads the dialog.

    NOTES:
        This class is private to DIALOG_WINDOW.

    HISTORY:
        beng        30-Sep-1991 Created
        beng        01-Nov-1991 Uses IDRESOURCE; replace BUFFER with pb, cb
        beng        03-Aug-1992 Dllization
        KeithMo     07-Feb-1993 Allow override of default charset.

********************************************************************/

DLGLOAD::DLGLOAD( const IDRESOURCE & idrsrcDialog,
                  HWND hwndOwner,
                  const PROC_INSTANCE & procinstDlg,
                  BOOL fAnsiDialog )
{
    HMODULE hmod = BLT::CalcHmodRsrc(idrsrcDialog);

    //
    // Create the dialog from the template in the resource file
    //

#if defined(WIN32)
    HWND hwnd = NULL;

    if( fAnsiDialog )
    {
        hwnd = ::CreateDialogA( hmod,
                                (CHAR*)idrsrcDialog.QueryPsz(),
                                hwndOwner,
                                (DLGPROC)procinstDlg.QueryProc());
    }
    else
    {
        hwnd = ::CreateDialogW( hmod,
                                (WCHAR*)idrsrcDialog.QueryPsz(),
                                hwndOwner,
                                (DLGPROC)procinstDlg.QueryProc());
    }

#else   // !WIN32
    UIASSERT( fAnsiDialog );
    HWND hwnd = ::CreateDialog( hmod,
                                (TCHAR*)idrsrcDialog.QueryPsz(),
                                hwndOwner,
                                (DLGPROC)procinstDlg.QueryProc());
#endif  // WIN32

    if (hwnd == NULL)
        ReportError(BLT::MapLastError(ERROR_INVALID_PARAMETER));

    _hwnd = hwnd;
}


DLGLOAD::DLGLOAD( const BYTE * pbTemplate,
                  UINT cbTemplate,
                  HWND hwndOwner,
                  const PROC_INSTANCE & procinstDlg,
                  BOOL fAnsiDialog )
{
    UNREFERENCED(cbTemplate);

    //
    // Create the dialog from the given template
    //

#if defined(WIN32)
    HWND hwnd = NULL;

    if( fAnsiDialog )
    {
        hwnd = ::CreateDialogIndirectA( hmodBlt,
                                        (LPDLGTEMPLATEA)(CHAR*)pbTemplate,
                                        hwndOwner,
                                        (DLGPROC)procinstDlg.QueryProc());
    }
    else
    {
        hwnd = ::CreateDialogIndirectW( hmodBlt,
                                        (LPDLGTEMPLATEW)(WCHAR*)pbTemplate,
                                        hwndOwner,
                                        (DLGPROC)procinstDlg.QueryProc());
    }

#else   // !WIN32
    UIASSERT( fAnsiDialog );
    HWND hwnd = ::CreateDialogIndirect( hmodBlt,
                                        (LPDLGTEMPLATE)(TCHAR*)pbTemplate,
                                        hwndOwner,
                                        (DLGPROC)procinstDlg.QueryProc());
#endif  // WIN32



    if (hwnd == NULL)
        ReportError(BLT::MapLastError(ERROR_GEN_FAILURE));

    _hwnd = hwnd;
}


/*******************************************************************

    NAME:       DLGLOAD::~DLGLOAD

    SYNOPSIS:   Destructor - releases a loaded dialog

    ENTRY:      Dialog exists

    EXIT:       Dialog window destroyed

    HISTORY:
        beng        30-Sep-1991 Created

********************************************************************/

DLGLOAD::~DLGLOAD()
{
    if (_hwnd != 0)
       ::DestroyWindow( _hwnd );
}


/*********************************************************************

    NAME:       DIALOG_WINDOW::DIALOG_WINDOW

    SYNOPSIS:   constructor for the dialog_window

    ENTRY:      TCHAR* - resource name
                HWND - the HWND of the owner window

    NOTES:
        Help has not yet been activated on this dialog.

        CODEWORK - should statically init the procinst member

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        14-May-1991 Uses BltDlgProc
        beng        30-Sep-1991 Win32 conversion
        beng        01-Nov-1991 Uses IDRESOURCE; replace BUFFER with pb, cb
        KeithMo     07-Feb-1993 Allow override of default charset.

*********************************************************************/

DIALOG_WINDOW::DIALOG_WINDOW( const IDRESOURCE & idrsrcDialog,
                              const PWND2HWND & wndOwner,
                              BOOL fAnsiDialog )
    : OWNER_WINDOW(),
      _procinstDlg( (MFARPROC)BltDlgProc ),
      _dlg( idrsrcDialog, wndOwner.QueryHwnd(), _procinstDlg, fAnsiDialog ),
      _assocThis( _dlg.QueryHwnd(), this ),
      _prstate( DLG_PROCESS_STATE_INITIALIZING )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;
    if (   ((err = _procinstDlg.QueryError()) != NERR_Success)
        || ((err = _dlg.QueryError()) != NERR_Success)
        || ((err = _assocThis.QueryError()) != NERR_Success) )
    {
        ReportError(err);
        return;
    }

    // Finally, register the hwnd for this object.
    //
    SetHwnd( _dlg.QueryHwnd() );
}


DIALOG_WINDOW::DIALOG_WINDOW( const BYTE * pbTemplate,
                              UINT cbTemplate,
                              HWND hwndOwner,
                              BOOL fAnsiDialog )
    : OWNER_WINDOW(),
      _procinstDlg( (MFARPROC)BltDlgProc ),
      _dlg( pbTemplate, cbTemplate, hwndOwner, _procinstDlg, fAnsiDialog ),
      _assocThis( _dlg.QueryHwnd(), this ),
      _prstate( DLG_PROCESS_STATE_INITIALIZING )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;
    if (   ((err = _procinstDlg.QueryError()) != NERR_Success)
        || ((err = _dlg.QueryError()) != NERR_Success)
        || ((err = _assocThis.QueryError()) != NERR_Success) )
    {
        ReportError(err);
        return;
    }

    // Finally, register the hwnd for this object.
    //
    SetHwnd( _dlg.QueryHwnd() );
}



/*********************************************************************

    NAME:       DIALOG_WINDOW::~DIALOG_WINDOW

    SYNOPSIS:   destructor for the dialog window class

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        22-Aug-1991 Use RESOURCE_STR class
        beng        30-Sep-1991 Win32 conversion

*********************************************************************/

DIALOG_WINDOW::~DIALOG_WINDOW()
{
    ASSERT( _prstate != DLG_PROCESS_STATE_ACTIVE );

    // Remove the properties of the dialog window, and then destroy it,
    // unless the dialog window creation failed.
    //
    HWND hwnd = QueryHwnd();
    if ( hwnd != NULL )
    {
        // Remove ( hwnd, pdlg ) entry from cache, incase it exists there.
        // This way, we guarantee that the cache will not return the wrong
        // pointer in the future, should Windows use the same hwnd for a
        // later window.
        //
        HWND_DLGPTR_CACHE::Remove( hwnd );
    }
}


/*********************************************************************

    NAME:       DIALOG_WINDOW::QueryRobustHwnd

    SYNOPSIS:   The handle for the future version of BLT dialog_window

    HISTORY:
        rustanl     20-Nov-1990     Created

*********************************************************************/

HWND DIALOG_WINDOW::QueryRobustHwnd() const
{
    if ( _prstate == DLG_PROCESS_STATE_ACTIVE )
        return QueryHwnd();

    return QueryOwnerHwnd();
}


/*********************************************************************

    NAME:       DIALOG_WINDOW::HwndToPwnd

    SYNOPSIS:   This method maps a hwnd to a DIALOG_WINDOW.

    ENTRY:      hwnd - the hwnd to be mapped

    RETURNS:    The corresponding DIALOG_WINDOW,
                or NULL on failure.

    NOTES:      This method will return NULL (even for valid dialog hwnd's)
                before CreateDialog has returned.  CODEWORK.  This can be
                changed, if deemed necessary.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        30-Sep-1991 Renamed; uses ASSOCHWNDPDLG

*********************************************************************/

DIALOG_WINDOW * DIALOG_WINDOW::HwndToPwnd( HWND hwnd )
{
    // First, attempt to find the (hwnd, pdlg) pair in the cache
    //
    DIALOG_WINDOW * pdlg = HWND_DLGPTR_CACHE::Find( hwnd );

    if ( pdlg != NULL )
        return pdlg;

    pdlg = (DIALOG_WINDOW *)ASSOCHWNDPDLG::HwndToPdlg(hwnd);

    // Add to cache, unless pointer is NULL
    //
    if ( pdlg != NULL )
    {
        HWND_DLGPTR_CACHE::Add( hwnd, pdlg );
    }

    return pdlg;
}


/*********************************************************************

    NAME:       DIALOG_WINDOW::Dismiss

    SYNOPSIS:   The method demisses the dialog

    ENTRY:
                UINT nRetVal - An (optional) application defined return
                value for the dialog.  This value may be any unsigned 16-bit
                value.  Typically, the value is FALSE (zero) if the
                the dialog did not achieve its purpose, and TRUE
                (non-zero) if it did.

    EXIT:       Dialog is dismissed

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        30-Sep-1991 Win32 conversion

*********************************************************************/

VOID DIALOG_WINDOW::Dismiss( UINT nRetVal )
{
    ASSERT( _prstate == DLG_PROCESS_STATE_ACTIVE );

    // Indicate that the dialog has now been dismissed.
    // This will cause Process to exit its loop.
    //
    _prstate = DLG_PROCESS_STATE_DISMISSED;

    // Record the return value, so that Process can return it.
    //
    _nRetVal = nRetVal;
}


/*********************************************************************

    NAME:       DIALOG_WINDOW::DismissMsg

    SYNOPSIS:   This method provides a convenient way to call MsgPopup
                and Dismiss.

    ENTRY:
                USHORT usErr - The error value that is to be passed to
                               MsgPopup
                UINT nRetVal - The value to be passed to Dismiss

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        30-Sep-1991 Win32 conversion

*********************************************************************/

VOID DIALOG_WINDOW::DismissMsg( MSGID msgid, UINT nRetVal )
{
    MsgPopup( this, msgid );
    Dismiss( nRetVal );
}


/**********************************************************************

    NAME:       DIALOG_WINDOW::Process

    SYNOPSIS:   This method processes a dialog.
                It disables the owner window, and then sets up a
                message loop to process the dialog.  The method does
                not return until the dialog has been dismissed.

                A dialog object represents one instance of a dialog with
                the user.  Hence, calling this method more than once, or
                calling it after the dialog has already been dismissed
                (note, the dialog may be dismissed in the constructor) will
                result in an error (see below for error code).

    ENTRY:
        pnRetVal   Pointer to storage receiving the programmer defined
                dialog return code passed to Dismiss. pnRetVal
                is only valid if the method returns success.
                (Commonly, pnRetVal may actually point to a BOOL.)

                If a client is not interested in this return code,
                pnRetVal can be passed in as NULL.  The pnRetVal
                parameter defaults to NULL.

    RETURNS:
        The return value from Process is an error value indicating
        the success of constructing the dialog.  NERR_Success indicates
        success.

    NOTES:
        This method should be called while processing the same message
        as when the dialog constructor was called (or more precisely,
        before there's any chance of losing control to Windows).  Otherwise,
        there is a slight chance that some message, triggered by the user,
        would slip into the queue of the owner window.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        30-Sep-1991 Win32 conversion
        beng        21-Feb-1992 Use WINDOW::RepaintNow()

**********************************************************************/

APIERR DIALOG_WINDOW::Process( UINT * pnRetVal )
{
    // First, check whether or not the dialog was successfully constructed
    //
    if ( QueryError() != NERR_Success )
        return QueryError();

    // Make sure Process has not been called already
    //
    ASSERT( _prstate == DLG_PROCESS_STATE_INITIALIZING );
    if ( _prstate != DLG_PROCESS_STATE_INITIALIZING )
        return ERROR_GEN_FAILURE;

    // Get the hwnd into a local variable.  It should not be NULL, because
    // then a dialog creation error has occurred, in which case the
    // constructor should have reported an error.
    //
    HWND hwnd = QueryHwnd();
    ASSERT( hwnd != NULL );

    // Disable the parent window, unless the dialog has no owner
    //
    HWND hwndOwner = QueryOwnerHwnd();
    if ( hwndOwner != NULL )
    {
        ::EnableWindow( hwndOwner, FALSE );
    }

    // Force a paint of the dialog.  CODEWORK: This could be changed so
    // that the paint only occurs when the message queue is empty.
    // Show the window only if not "hidden"

    if ( ! QueryAttribute( OWIN_ATTR_HIDDEN ) )
    {
        Show(TRUE);
        RepaintNow();
    }

    // Run private message pump as long as the dialog is still active
    // (i.e., until it is dismissed).  Note that Dismiss will change the
    // value of _prstate.  Q.v. DIALOG_WINDOW::IsPumpFinished.
    //
    // Only enters this pump if the MayRun callout accedes to the request.
    // Should callout refuse to run the dialog, reset _prstate ourselves.
    // Messy hack, yes.  I think the days of _prstate are numbered.
    //
    // Sets _prstate before calling MayRun, so a QueryRobustWindow will
    // find that of the dialog, so that popups will handle focus correctly.
    //
    _prstate = DLG_PROCESS_STATE_ACTIVE;
    if (MayRun())
    {
        RunMessagePump();
    }
    _prstate = DLG_PROCESS_STATE_DISMISSED;

    // Now, re-enable the owner, if any
    //
    if ( hwndOwner != NULL )
    {
        ::EnableWindow( hwndOwner, TRUE );
    }

    // Hide the dialog window.  It will later be destroyed in the
    // destructor.
    //
    Show(FALSE);

    // Finally, set the dialog return value, and return
    //
    if ( pnRetVal != NULL )
        *pnRetVal = _nRetVal; // programmer defined dialog return code

    return NERR_Success;        // dialog was successfully displayed
}

APIERR DIALOG_WINDOW::Process( BOOL * pfRetVal )
{
    // This version accepts a BOOL argument

    UINT nReturned = 0; // JonN 01/27/00: PREFIX 444895

    APIERR err = Process(&nReturned);

    if (pfRetVal != NULL)
        *pfRetVal = !!nReturned;

    return err;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::FilterMessage

    SYNOPSIS:   Client-installable hook into the messageloop.

        DIALOG_WINDOW uses its FilterMessage implementation to
        catch F1 and launch help thereupon, and to handle dialog
        accelerators.

    ENTRY:      pmsg    - pointer to message fresh off the queue

    EXIT:       pmsg    - could possibly be changed

    RETURNS:
        FALSE to proceed with translating and dispatching
        the message.

        TRUE indicates that the message has already been
        handled by the filter.  In this case, the message
        loop will continue on to the next message in the
        queue.

    NOTES:
        This is a virtual member function.

    HISTORY:
        terryk      28-Jul-91   Created (as empty stub)
        beng        07-Oct-1991 Move non-generic behavior into filter

********************************************************************/

BOOL DIALOG_WINDOW::FilterMessage( MSG* pmsg )
{
    /*  The following wonderful R.M.L. comment I keep for eternity:

        The order in which the message and wParam components of
        the msg structure are checked for the F1 key has been optimized.
        Since it appears that wParam == VK_F1 appears less often than
        message == WM_KEYDOWN.  Hence, the former is checked first.
        For the F1 key, only the VK_F1 virtual key code is checked.
        There is a VK_HELP virtual key code, too.  VK_HELP is not
        the same key as the the F1 key.  In fact, VK_HELP is not a
        required key.    For this reason, and for the reason of not
        having to document some other Help key, the VK_HELP code
        is not tested for.
     */

    // Trap the F1 key

    if ( pmsg->wParam == VK_F1 && pmsg->message == WM_KEYDOWN )
    {
        OnHelp();
        return TRUE;
    }

    // Take care of dialog accelerators

    if ( ::IsDialogMessage( QueryHwnd(), pmsg ))
        return TRUE;

    // Let everything else through

    return FALSE;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::IsPumpFinished

    SYNOPSIS:   Client-installable pump termination condition

        DIALOG_WINDOW uses this predicate to drive the dialog box
        until Dismiss sets the _prstate flag to indicate completion.

    ENTRY:      Message pump has dispatched a message

    RETURNS:    TRUE to end the pump; FALSE to continue

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        07-Oct-1991 Created

********************************************************************/

BOOL DIALOG_WINDOW::IsPumpFinished()
{
    return ( _prstate != DLG_PROCESS_STATE_ACTIVE );
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::MayRun

    SYNOPSIS:   Client-installable dialog abort callout

        DIALOG_WINDOW uses this predicate to allow the client to abort
        a dialog after it's painted, but before it's run.

    ENTRY:      Dialog is painted, but not processed

    RETURNS:    TRUE to continue the dialog; FALSE to abort

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        30-Mar-1992 Created

********************************************************************/

BOOL DIALOG_WINDOW::MayRun()
{
    return TRUE; // default implementation
}


/*********************************************************************

    NAME:       DIALOG_WINDOW::QueryHelpContext

    SYNOPSIS:   Called when the user performed an action which triggers Help
                to appear.  In particular, this may happen if the user
                pressed F1 or pushed the Help button.

    RETURNS:    Help context of dialog, or 0L if no help provided.

    NOTES:
        This method is replaceable to all subclasses.

    HISTORY:
        rustanl   20-Nov-1990      Created

*********************************************************************/

ULONG DIALOG_WINDOW::QueryHelpContext()
{
    return 0L;    // no help available
}


/*********************************************************************

    NAME:       DIALOG_WINDOW :: QueryHelpFile

    SYNOPSIS:   This method is responsible for returning the help
                file associated with the given help context.

    ENTRY:      nHelpContext            - A help context.  Must be mapped
                                          to an appropriate help file.

    RETURNS:    const TCHAR *           - The name of the help file, or
                                          NULL if none exists.

    NOTES:      This method is replaceable to all subclasses.

    HISTORY:
        KeithMo   07-Aug-1992   Created.

*********************************************************************/
const TCHAR * DIALOG_WINDOW :: QueryHelpFile( ULONG nHelpContext )
{
    return BLT::CalcHelpFileHC( nHelpContext );

}   // DIALOG_WINDOW :: QueryHelpFile


/*********************************************************************

    NAME:       DIALOG_WINDOW::OnOK

    SYNOPSIS:   Called when the dialog's OK button is clicked
        and all data thereis passes muster (as per dialog validation
        rules).

    RETURNS:    TRUE if action was taken,
                FALSE otherwise.

    CAVEATS:
        Assumes that the OK button has control ID IDOK.

    NOTES:
        This method may be replaced by derived classes.
        This default implementation dismisses the dialog, returning TRUE.

    HISTORY:
        rustanl   20-Nov-1990      Created

*********************************************************************/

BOOL DIALOG_WINDOW::OnOK()
{
    Dismiss(TRUE);
    return TRUE;
}


/*********************************************************************

    NAME:       DIALOG_WINDOW::OnCancel

    SYNOPSIS:   Called when the dialog's Cancel button is clicked.
                Assumes that the Cancel button has control ID IDCANCEL.

    RETURNS:
        TRUE if action was taken,
        FALSE otherwise.

    NOTES:
        This method may be replaced by derived classes.
        This default implementation dismisses the dialog, returning FALSE.

    HISTORY:
        rustanl   20-Nov-1990      Created

*********************************************************************/

BOOL DIALOG_WINDOW::OnCancel()
{
    Dismiss(FALSE);
    return TRUE;
}


/*********************************************************************

    NAME:       DIALOG_WINDOW::OnCommand

    SYNOPSIS:   This method gets called when a dialog control sends
                some notification to its parent (i.e., this dialog).

    ENTRY:
        cid         The ID of the control which sent the notification
        lParam      Same parameter sent by the notifying control

    RETURNS:
        The method should return TRUE if it processed the message, and
        FALSE otherwise.

    NOTES:
        This method is replaceable to all subclasses.

        It is common practise to, as a last resort, call the OnCommand
        method for the parent class.

        This method is not called for notifications from speciial controls.
        Special controls are the OK, Cancel, and Help buttons.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        30-Sep-1991 Replaced

*********************************************************************/

BOOL DIALOG_WINDOW::OnCommand( const CONTROL_EVENT & event )
{
    UNREFERENCED(event);

    return FALSE;
}


/*********************************************************************

    NAME:       DIALOG_WINDOW::OnControlError

    SYNOPSIS:   This method is called whenever a control reports an error.
                If it is called, the corresponding OnCommand will not
                be called.

    ENTRY:
        cid     The control ID of the control reporting the error
        usErr   The error code of the error that occurred

    NOTES:
        This method is replaceable by derived classes.  As a default
        action, it displays the message to the user.

    HISTORY:
        rustanl   20-Nov-1990      Created

*********************************************************************/

VOID DIALOG_WINDOW::OnControlError( CID cid, APIERR err )
{
    UNREFERENCED(cid);

    MsgPopup( this, (MSGID)err );    // display the error to the user
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::OnValidationError

    SYNOPSIS:   Called whenever a control reports invalid input
                (at dialog validation time).

    ENTRY:      cid - control ID of failing control
                err - code of error, as reported by control

    NOTES:
        This virtual member function should be replaced by dialogs
        wishing to take further action when validation fails.  Most
        dialogs need not bother.

    HISTORY:
        beng        31-Oct-1991 Created

********************************************************************/

VOID DIALOG_WINDOW::OnValidationError( CID cid, APIERR err )
{
    UNREFERENCED(cid);
    UNREFERENCED(err);
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::OnTimer

    SYNOPSIS:   Timer response callback

    ENTRY:      event - Timer event

    RETURNS:    TRUE if you handle it

    HISTORY:
        beng        07-Oct-1991 Header added

********************************************************************/

BOOL DIALOG_WINDOW::OnTimer( const TIMER_EVENT & event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::OnScrollBar

    SYNOPSIS:   Scrollbar response callback

    ENTRY:      event - Timer event

    RETURNS:    TRUE if you handle it

    HISTORY:
        beng        18-May-1992 Created

********************************************************************/

BOOL DIALOG_WINDOW::OnScrollBar( const SCROLL_EVENT & event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::OnScrollBarThumb

    SYNOPSIS:   Scrollbar thumb-motion response callback

    ENTRY:      event - Timer event

    RETURNS:    TRUE if you handle it

    HISTORY:
        beng        18-May-1992 Created

********************************************************************/

BOOL DIALOG_WINDOW::OnScrollBarThumb( const SCROLL_THUMB_EVENT & event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::OnDlgActivation

    SYNOPSIS:   Activation callback

    ENTRY:      event - Activation event

    RETURNS:    TRUE if you handle it

    HISTORY:
        jonn        07-Oct-1993 Created

********************************************************************/

BOOL DIALOG_WINDOW::OnDlgActivation( const ACTIVATION_EVENT & event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::OnDlgDeactivation

    SYNOPSIS:   Deactivation callback

    ENTRY:      event - Activation event

    RETURNS:    TRUE if you handle it

    HISTORY:
        jonn        07-Oct-1993 Created

********************************************************************/

BOOL DIALOG_WINDOW::OnDlgDeactivation( const ACTIVATION_EVENT & event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::OnCtlColor

    SYNOPSIS:   Intercepts WM_CTLCOLOR*

    RETURNS:    brush handle if you handle it

    NOTES:      If you redefine this method, you should either return
                non-NULL or else (possibly change *pmsgid and) call
                through to the root implementation.

    HISTORY:
        jonn        03-Aug-1995 Created

********************************************************************/
HBRUSH DIALOG_WINDOW::OnCtlColor( HDC hdc, HWND hwnd, UINT * pmsgid )
{
    ASSERT( pmsgid != NULL );
    CID cid = ::GetWindowLong( hwnd, GWL_ID );
    CONTROL_WINDOW * pctrl = CidToCtrlPtr( cid );
    if (pctrl != NULL)
    {
        return pctrl->OnCtlColor( hdc, hwnd, pmsgid );
    }
    return NULL;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::OnSysColorChange

    SYNOPSIS:   Intercepts WM_SYSCOLORCHANGE

    NOTES:      see shellui\share\sharecrt.cxx for an example of how to
                work with this

    HISTORY:
        jonn        08-Aug-1995 Created

********************************************************************/
VOID DIALOG_WINDOW::OnSysColorChange()
{
    return;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::DlgProc

    SYNOPSIS:   The one and only BLT dialog procedure.

    ENTRY:      Called by BltDlgProc (the exported thunk).

    RETURNS:    TRUE to override system default behavior
                FALSE otherwise

    NOTES:
        This is a static member function.

    HISTORY:
        rustanl     ???         Created (as ShellDlgProc)
        beng        14-May-1991 Replaced ShellDlgProc
        beng        21-May-1991 Relocated much to OWNER_WINDOW,
                                for sharing with CLIENT_WINDOW
        beng        22-Aug-1991 Use RESOURCE_STR
        beng        22-Sep-1991 Correct usage of GetVersion
        beng        08-Oct-1991 Win32 conversion
        beng        31-Oct-1991 Added dialog validation
        beng        18-May-1992 Handles WM_[VH]SCROLL
        congpay     25-Oct-1992 Add OnUserMessage

********************************************************************/

BOOL DIALOG_WINDOW::DlgProc(
    HWND   hDlg,
    UINT   nMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    // First, handle messages which are not concerned about whether or
    // not hDlg can be converted into pdlg.

    switch (nMsg)
    {
    case WM_COMPAREITEM:
    case WM_DELETEITEM:
        return OWNER_WINDOW::OnLBIMessages(nMsg, wParam, lParam);
    }


    // Now, convert the hDlg to a pdlg.  If no pdlg available, then
    // we don't have our hwnd-to-pwnd hooks set up just yet.

    DIALOG_WINDOW * pdlg = DIALOG_WINDOW::HwndToPwnd( hDlg );

    if ( pdlg == NULL )
    {
        switch ( nMsg )
        {
        case WM_INITDIALOG:
            return TRUE;    // this asks of Windows to set the initial focus

        case WM_MEASUREITEM:
            // This WM_MEASUREITEM message is sent before the
            // WM_INITDIALOG message (except for variable size owner-draw
            // list controls.  Hence, the window properties are not yet set
            // up, and so the owner dialog cannot be called at this time.
            //
            // This function guesses the measure for fixed-size items
            // given the information available.
            //
            return OWNER_WINDOW::CalcFixedCDMeasure( hDlg, (MEASUREITEMSTRUCT *)lParam );

        default:
            break;
        }

        return FALSE;
    }


    switch ( nMsg )
    {
    case WM_COMMAND:
        {
            CONTROL_EVENT e( nMsg, wParam, lParam );
            CID cid = e.QueryCid();

            // Take care of the special cases immediately
            //
            switch ( cid )
            {
            case IDHELPBLT:
                // User clicked Help button
                return pdlg->OnHelp();

            case IDOK:
                // User clicked OK button.  Check dialog validity,
                // and allow the user to proceed only if all data
                // passes muster.
                //
                if (pdlg->IsValid())
                    return pdlg->OnOK();
                break;

            case IDCANCEL:
                // User clicked Cancel button
                return pdlg->OnCancel();
            }

            /*  First, call the control itself to do any processing
             *  on a control level.
             *  If the message is a client generated message (for
             *  example, SetText on an SLE), then we ignore the
             *  message and don't tell anyone about it.
             */

            CONTROL_WINDOW * pctrl = pdlg->CidToCtrlPtr( cid );

            if ( pctrl != NULL && !pctrl->IsClientGeneratedMessage() )
            {
                APIERR err = pctrl->OnUserAction(e);

                if ( err == NERR_Success )
                {
                    err = pctrl->NotifyGroups(e);
                }

                if ( err != NERR_Success && err != GROUP_NO_CHANGE )
                {
                    pdlg->OnControlError( cid, err );
                    return TRUE;
                }
            }

            //  Call the dialog to do dialog level processing.
            //
            return pdlg->OnCommand(e);
        }

    case WM_BLTHELP:
        pdlg->LaunchHelp();
        return TRUE;

    case WM_GUILTT:
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
    case WM_CHARTOITEM:
    case WM_VKEYTOITEM:
        // Responses to owner-draw-control messages are defined
        // in the owner-window class.
        //
        return pdlg->OnCDMessages(nMsg, wParam, lParam);

    case WM_TIMER:
        {
            TIMER_EVENT e( nMsg, wParam, lParam );
            return pdlg->OnTimer(e);
        }

    case WM_VSCROLL:
    case WM_HSCROLL:
        {
            SCROLL_EVENT se( nMsg, wParam, lParam );

            if (   se.QueryCommand() == SCROLL_EVENT::scmdThumbPos
                || se.QueryCommand() == SCROLL_EVENT::scmdThumbTrack )
                return pdlg->OnScrollBarThumb((const SCROLL_THUMB_EVENT &)se);
            else
                return pdlg->OnScrollBar((const SCROLL_EVENT &)se);
        }

    case WM_ACTIVATE:
        {
            ACTIVATION_EVENT ae( nMsg, wParam, lParam );

            if (ae.IsActivating())
                return pdlg->OnDlgActivation(ae);
            else
                return pdlg->OnDlgDeactivation(ae);
        }

    case WM_CTLCOLORMSGBOX:
    case WM_CTLCOLOREDIT:
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORBTN:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORSCROLLBAR:
    case WM_CTLCOLORSTATIC:
        {
            UINT tmpMsgid = nMsg;
            BOOL retval = (NULL != (pdlg->OnCtlColor(
                                    (HDC)wParam, (HWND)lParam, &tmpMsgid )));
            if ( !retval && tmpMsgid != nMsg )
                return (BOOL)::DefWindowProc(
                                pdlg->QueryHwnd(), tmpMsgid, wParam, lParam );
            else
                return retval;
        }

    }

    // add OnUserMessage.
    if (nMsg >= WM_USER+100)
    {
        EVENT event(nMsg, wParam, lParam);
        return pdlg->OnUserMessage((const EVENT &)event);
    }

    // Have default dialog-proc called for us
    //
    return FALSE;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::OnHelp

    SYNOPSIS:   Respond to a request for help

    EXIT:       "Help" message sitting in application queue

    NOTES:
        Unlike most of the "On" members, this is not a virtual
        function, so don't even think about redefining it.

    HISTORY:
        beng        30-Sep-1991 Created

********************************************************************/

BOOL DIALOG_WINDOW::OnHelp()
{
    ::PostMessage( QueryHwnd(), WM_BLTHELP, 0, 0L );
    return TRUE;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::LaunchHelp

    SYNOPSIS:   Actually launches the WinHelp applilcation

    NOTES:
        This is a private member function.

    HISTORY:
        beng        07-Oct-1991 Header added
        beng        05-Mar-1992 Removed wsprintf
        beng        22-Jun-1992 Disable help for Prerelease
        KeithMo     16-Aug-1992 Integrated new helpfile management.

********************************************************************/

VOID DIALOG_WINDOW::LaunchHelp()
{
    ULONG ulHelp = QueryHelpContext();
    const TCHAR * pszHelpFile = QueryHelpFile( ulHelp );

#if defined(DEBUG)
    HEX_STR nlsHelpContext(ulHelp);

    if( pszHelpFile != NULL )
    {
        DBGEOL( SZ("Help called on file ") << pszHelpFile << \
                SZ(", context ") << nlsHelpContext );
    }
    else
    {
        DBGEOL( SZ("Help called on unknown context ") << nlsHelpContext );
    }
#endif

    if( pszHelpFile != NULL )
    {
        if( !::WinHelp( QueryHwnd(),
                        (TCHAR *)pszHelpFile,
                        HELP_CONTEXT,
                        (DWORD)ulHelp ) )
        {
            ::MsgPopup( QueryHwnd(),
                        IDS_BLT_WinHelpError,
                        MPSEV_ERROR,
                        MP_OK );
        }
    }
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::Validate

    SYNOPSIS:   Checks every control for valid input

    ENTRY:      Controls contain input of unknown validity

    EXIT:       If success, every control contains valid input.
                If failed, control has indicated error, and dialog
                has been notified.

    RETURNS:    Code returned by failing control (0 if none)

    NOTES:
        If the dialog contains no self-validating controls, then
        this will always return success.

    HISTORY:
        beng        31-Oct-1991 Created

********************************************************************/

APIERR DIALOG_WINDOW::Validate()
{
    ITER_CTRL iter(this);
    CONTROL_WINDOW * pctrl;
    while ((pctrl = iter.Next()) != NULL)
    {
        APIERR err = pctrl->Validate();
        if (err != NERR_Success)
        {
            // Control contained invalid data.

            pctrl->IndicateError(err);
            OnValidationError(pctrl->QueryCid(), err);
            return err;
        }
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::IsValid

    SYNOPSIS:   Returns whether controls contain valid data

    RETURNS:    fValid - TRUE if all's well.

    HISTORY:
        beng        31-Oct-1991 Created

********************************************************************/

BOOL DIALOG_WINDOW::IsValid()
{
    return (Validate() == NERR_Success);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltlbsrt.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltlbsrt.cxx
    BLT_LISTBOX::Resort method, et al.


    FILE HISTORY:
	rustanl     01-Jul-1991     Created
	rustanl     12-Jul-1991     Added to BLT
	rustanl     15-Jul-1991     Code review changes (comment changes).
				    CR attended by BenG, ChuckC, JimH,
				    Hui-LiCh, TerryK, RustanL.

*/

#include "pchblt.hxx"   // Precompiled header

/*******************************************************************

    NAME:	BLT_LISTBOX::Resort

    SYNOPSIS:	Resorts the listbox

    EXIT:	On success, the items in the listbox resorted according
		to the current sort order.
		On failure, the order of the listbox items are left
		unchanged.

    RETURNS:	An API error, which is NERR_Success on success.

    NOTES:
	Assumes sort order is consistent throughout this method.

	CODEWORK.  Add fSugar parameter, defaulting to TRUE.
	If TRUE, this method works like it does today.	If
	FALSE, this method does not use AUTO_CURSOR, and does
	not call SetRedraw or Invalidate.

    HISTORY:
	rustanl     01-Jul-1991     Created

********************************************************************/

DECLARE_HEAP_OF( LBI );
DEFINE_HEAP_OF( LBI );

APIERR BLT_LISTBOX::Resort()
{
    AUTO_CURSOR autocur;	// this may take a while

    INT clbi = QueryCount();

    /*	Create a heap to do most of the job  */

    LBI_HEAP heap( clbi, FALSE );

    if ( heap.QueryError() != NERR_Success )
	return heap.QueryError();

    /*	Place listbox items in the heap  */

    for ( INT ilbi = 0; ilbi < clbi; ilbi++ )
    {
	//  Guaranteed to succeed since heap construction with parameter
	//  clbi succeeded.
	REQUIRE( heap.AddItem( QueryItem( ilbi )) == NERR_Success );
    }

    heap.Adjust();

    /*	Fill the listbox with the items in the new sort order  */

    SetRedraw( FALSE );

    for ( ilbi = 0; ilbi < clbi; ilbi++ )
    {
	SetItem( ilbi, heap.RemoveTopItem());
    }

    //	All items should have been removed from the heap
    UIASSERT( heap.QueryCount() == 0 );

    SetRedraw( TRUE );
    Invalidate();

    return NERR_Success;
}


/*******************************************************************

    NAME:	BLT_LISTBOX::SetItem

    SYNOPSIS:	Sets the 32-bit value for a particular listbox item

    ENTRY:	ilbi -	    The index of the item to set.  Must be
			    a valid listbox item.
		plbi -	    Pointer to LBI item which will be the
			    new listbox item at position ilbi.

    EXIT:	Listbox item at ilbi will be plbi.

    RETURN:	return CODE of the LB_SETITEMDATA command.
		LB_ERR if error.

    NOTES:
	This private method is used in Resort.	It is private so
	that no BLT client will use it, since that could
	break some of the BLT assumptions about listbox items.

    HISTORY:
	rustanl     01-Jul-1991 Created
	beng	    15-Oct-1991 Win32 conversion

********************************************************************/

VOID BLT_LISTBOX::SetItem( INT ilbi, LBI * plbi )
{
    UIASSERT( ilbi >= 0 );
    UIASSERT( ilbi < QueryCount());

    REQUIRE(((INT) Command( IsCombo() ? CB_SETITEMDATA :
					LB_SETITEMDATA,
			    ilbi,
			    (LPARAM)plbi ) ) != LB_ERR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltinit.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltinit.cxx
    BLT Initialization & static module

    This file contains any BLT specific initialization routines and
    any static/global objects required by BLT.


    FILE HISTORY:
        Johnl       12-Mar-1991 Created
        beng        14-May-1991 Exploded blt.hxx into components
        beng        21-May-1991 Made vhInst static; added dbgstr
        terryk      19-Jul-1991 Call the timer class init and term function
        terryk      07-Aug-1991 Comment out BLT_TIMER class's Init
                                and Term functions.
        beng        17-Oct-1991 Removed SLT_PLUS from init
        beng        25-Oct-1991 Removed static ctors
        beng        30-Oct-1991 Withdrew realmode support
        beng        16-Mar-1992 Changed cdebug init/term
        Yi-HsinS    14-Aug-1992 Load Netmsg.dll on Init time
        KeithMo     07-Aug-1992 Added RegisterHelpFile and related support.
*/

#include "pchblt.hxx"   // Precompiled header

// BLT keeps this information per registrand (registree?)

struct CLIENTDATA
{
    HMODULE _hmod;              // hmod of client (hinst for app)
    UINT    _idMinResource;     // range of resource IDs expected, inclusive
    UINT    _idMaxResource;
    UINT    _idMinString;       // range of string IDs expected, inclusive
    UINT    _idMaxString;
};

/* This manifest defines the number of items in the client data slist that
 * are added by BLT itself.  If you call AddClient in this module, then
 * you probably need to increment this flag.
 */
#define INTERNAL_CLIENTS        1


DECLARE_SLIST_OF(CLIENTDATA);
DEFINE_SLIST_OF(CLIENTDATA);


//
//  This class associates a help file with a specified
//  range of help contexts.
//

class ASSOCHCFILE : public BASE
{
private:
    HMODULE      _hMod;
    RESOURCE_STR _nlsHelpFile;
    ULONG        _nMinHC;
    ULONG        _nMaxHC;

public:
    ASSOCHCFILE( HMODULE hMod,
                 MSGID  idsHelpFile,
                 ULONG  nMinHC,
                 ULONG  nMaxHC );
    ~ASSOCHCFILE();

    HMODULE QueryModule( VOID ) const
        { return _hMod; }

    const TCHAR * QueryHelpFile( VOID ) const
        { return _nlsHelpFile.QueryPch(); }

    BOOL IsAssociatedHC( ULONG hc ) const
        { return ( hc >= _nMinHC ) && ( hc <= _nMaxHC ); }
};


DECLARE_SLIST_OF(ASSOCHCFILE);
DEFINE_SLIST_OF(ASSOCHCFILE);


// How far to unwind in a destruction/cleanup?
//
enum BLT_CTOR_STATE
{
    BLT_CTOR_OMEGA,         // Unwind the whole ding dang thing
    BLT_CTOR_CLWIN,         // CLIENT_WINDOW only
    BLT_CTOR_NOTHING        // nothing to unwind
};


// Guts

class BLTIMP
{
friend class BLT;

private:
    static BOOL         _fInit; // has module been init'd?
    static UINT         _cInit; // actually the number of registered clients
                                // (within this process, of course)

    static HANDLE _hBLTSema4 ;       // Protects BLT global data init/term
    static HANDLE _hResourceSema4 ;  // Protects following two slists
    static SLIST_OF(CLIENTDATA) * _pslClient;
    static SLIST_OF(ASSOCHCFILE) * _pslHelpFiles;

    // Helper function to unwind incomplete Inits
    //
    static VOID   Unwind( BLT_CTOR_STATE );

public:
    static UINT _cMaxResidueBlocksToDump;
    static BOOL _fBreakOnHeapResidue;

    static APIERR Init();
    static VOID   Term();

    static APIERR AddClient( HMODULE hmod, UINT, UINT, UINT, UINT );
    static VOID   RemoveClient( HMODULE hmod );

    static APIERR AddHelpAssoc( HMODULE hMod,
                                MSGID  idsHelpFile,
                                ULONG  nMinHC,
                                ULONG  nMaxHC );
    static VOID   RemoveHelpAssoc( HMODULE hMod,
				   ULONG  hc );

    static APIERR EnterResourceCritSect( void ) ;
    static void   LeaveResourceCritSect( void ) ;
    static APIERR EnterBLTCritSect( void ) ;
    static void   LeaveBLTCritSect( void ) ;
};

UINT         BLTIMP::_cInit = 0;
BOOL         BLTIMP::_fInit = FALSE;

UINT         BLTIMP::_cMaxResidueBlocksToDump = 5;      // defaults
BOOL         BLTIMP::_fBreakOnHeapResidue     = FALSE;


HANDLE BLTIMP::_hResourceSema4 = NULL ;
HANDLE BLTIMP::_hBLTSema4 = NULL ;
SLIST_OF(CLIENTDATA) * BLTIMP::_pslClient = NULL;
SLIST_OF(ASSOCHCFILE) * BLTIMP::_pslHelpFiles = NULL;



/*******************************************************************

    NAME:       BLTIMP::Init

    SYNOPSIS:   Does all necessary initialization of BLT;
                should be called during application/DLL startup to
                register that app with BLT

    ENTRY:      hInst - Instance handled passed to WinMain or LibMain

    EXIT:       _hInst has been set to the given handle;
                all manner of window classes have been registered

    RETURNS:    NERR_Success if initialization was successful
                ERROR_OUT_OF_MEMORY or
                ERROR_GEN_FAILURE  if resource loading error
                ERROR_NOT_SUPPORTED if called in real-mode x86 Windows

    NOTES:
        This is a static member function.

        Once we are in the LM 3.0 timeframe (and BLT is a DLL),
        we will want to move InitMsgPopup to the LIBMAIN of BLT.

        Since it is not a ctor, this function unwinds all its inits
        should any of them fail.  See Unwind.

    HISTORY:
        beng        31-Jul-1992 Created (dllization)
        chuckc      17-May-1993 Added critical section checks to
                                be multi-thread safe. major cleanup.

********************************************************************/

APIERR BLTIMP::Init()
{
    BLT_CTOR_STATE bltunwind = BLT_CTOR_NOTHING ;
    APIERR err = NERR_Success ;
    TRACEEOL("BLT: Initializing");

    //
    // preload this outside crit sect to avoid deadlock that
    // can result is someone other DLL is trying to do its BLT
    // init the same time while in its DLLENTRY. our LoadLibrary of
    // NETMSG wont succeed while the loader is doing the other
    // DLLENTRY, and that wont suceed since we have the BLT sema4.
    //
    // worst case scenario if we fall into the window (as a result
    // of doing this outside the crit sect) is that we have an extra
    // netmsg.dll loaded.
    //
    HMODULE hmod = ::LoadLibrary( NETMSG_DLL_STRING );

    if ( (err = EnterBLTCritSect()) != NERR_Success )
        return err;

    if (_fInit)
    {
        LeaveBLTCritSect() ;
        return NERR_Success;
    }


    TRACEEOL("BLT: CLIENT WINDOW Init");
    err = CLIENT_WINDOW::Init();
    if (err != NERR_Success)
    {
        DBGEOL("BLT: CLIENT_WINDOW init failed, error " << err);
        goto exitpoint ;
    }
    bltunwind = BLT_CTOR_CLWIN ;  // from here on unwind CLIENT_WINDOW as well

    TRACEEOL("BLT: POPUP Init");
    err = POPUP::Init();
    if (err != NERR_Success)
    {
        DBGEOL("BLT: MSGPOPUP init failed, error " << err);
        goto exitpoint ;
    }
    bltunwind = BLT_CTOR_OMEGA ;  // from here on unwind all

    //
    // next section is protected by critical section for resources
    //
    TRACEEOL("BLT: Resource/HMOD init data structures");
    if (err = EnterResourceCritSect())
        goto exitpoint ;
    _pslClient = new SLIST_OF(CLIENTDATA);
    if (_pslClient == NULL)
    {
        DBGEOL("BLT: failed to ct slist of clientdata, alloc failed");
        LeaveResourceCritSect() ;
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto exitpoint ;
    }

    _pslHelpFiles = new SLIST_OF(ASSOCHCFILE);
    if (_pslHelpFiles == NULL)
    {
        DBGEOL("BLT: failed to ct slist of assochcfile, alloc failed");
        LeaveResourceCritSect() ;
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto exitpoint ;
    }
    LeaveResourceCritSect() ;

    //
    // register NETMSG.DLL
    //
    if ( hmod != 0 )
    {
        err = BLTIMP::AddClient(hmod, 0, 0,
                                MIN_LANMAN_MESSAGE_ID, MAX_LANMAN_MESSAGE_ID);
    }

    if ( err != NERR_Success )
    {
        if ( hmod != 0 )
            ::FreeLibrary( hmod );
        goto exitpoint ;
    }

    _fInit = TRUE;

exitpoint:

    if (err != NERR_Success)
        Unwind(bltunwind);
    LeaveBLTCritSect() ;
    return err ;
}


/*******************************************************************

    NAME:       BLTIMP::Term

    SYNOPSIS:   Frees any memory and uninitializes any BLT objects.

    ENTRY:      An app has been registered with BLT

    EXIT:       BLT no longer available to app (which may now terminate).

    NOTES:
        This is a static member function.

        Once we are in the LM 3.0 timeframe (and BLT is a DLL),
        we will want to move UnInitMsgPopup to the WEP of BLT.

        Calling Deregister when the app isn't registered has no effect.
        This simplifies error handling for lanman.drv, which wants to call
        Deregister from its WEP.

    HISTORY:
        Johnl       12-Mar-1991 Created
        DavidHov    14-Mar-1991 Corrected for real mode.
        beng        21-May-1991 Added client-window cleanup;
                                re-corrected for real mode
        terryk      19-Jul-1991 Call the Timer terminator
        beng        29-Jul-1991 Made from ::BLTDeregister
        beng        30-Oct-1991 Rename to Term (from Unregister)
        beng        31-Jul-1992 Factored from BLT::Term; dllization
        chuckc      17-May-1993 Added critical section checks to
                                be multi-thread safe

********************************************************************/

VOID BLTIMP::Term()
{
    TRACEEOL("BLT: Terminating");
    APIERR err = EnterBLTCritSect() ;

    if (err != NERR_Success)
        return ;

    if (!_fInit)    // more disconnects than connects? bogus.
    {
        DBGEOL("BLT: warning: more disconnects than connects");
        LeaveBLTCritSect();
        return;
    }

    if (_cInit > INTERNAL_CLIENTS ) // not everybody has disconnected
    {
        LeaveBLTCritSect();
        return;
    }

    Unwind(BLT_CTOR_OMEGA);
    _fInit = FALSE;

    LeaveBLTCritSect();
}


/*******************************************************************

    NAME:       BLTIMP::Unwind

    SYNOPSIS:   Common code for dtor and unwinding a partial Init

    ENTRY:      BLT_CTOR_STATE - enum denoting stage of constructopn

    EXIT:       Construction is unwound

    NOTES:
        This is a static member function.

    HISTORY:
        beng        30-Jul-1991 Created - common factoring
        beng        18-Sep-1991 Added Alpha (and renamed Omega)
        beng        17-Oct-1991 Removed SLT_PLUS cleanup
        beng        25-Oct-1991 Removed static dtors
        beng        30-Oct-1991 Removed realmode support; renamed
        beng        16-Mar-1992 Change cdebug init/term

********************************************************************/

VOID BLTIMP::Unwind( BLT_CTOR_STATE state )
{

    TRACEEOL("BLT: Unwinding");

    // Be careful when modifying this - the states correspond
    // to states of partial "construction" (package initialization).
    //
    switch (state)
    {
    case BLT_CTOR_NOTHING:

        // nothing to unwind
        break ;

    default:
    case BLT_CTOR_OMEGA:
      {

        // Remove netmsg.dll
        ASSERT(_pslClient->QueryNumElem() == 1); // sanity
        ITER_SL_OF(CLIENTDATA) iter(*_pslClient);
        CLIENTDATA * pcld = iter.Next();
        ASSERT(pcld != NULL);       // invalid iterator?
        if (pcld != NULL) // JonN 1/27/00: PREFIX 444896
        {
                ::FreeLibrary(pcld->_hmod);
                BLTIMP::RemoveClient( pcld->_hmod );
        }

        delete _pslClient;
        _pslClient = NULL;

        delete _pslHelpFiles;
        _pslHelpFiles = NULL;

        POPUP::Term();
        /* fall through... */
      }

    case BLT_CTOR_CLWIN:
        CLIENT_WINDOW::Term();
        break ;
    }
}

/*******************************************************************

    NAME:       BLT::InitDLL

    SYNOPSIS:   Called once during process attach of BLT initialization

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      Straight cut from Init method.  This was created so non-
                window clients (such as ntlanman.dll) don't have to call
                BLT::Init to get debugging services.

                The debug info memory is deleted after the last client unhooks
                from BLT.  Note that means we will have two allocations that
                won't be deallocated if nobody ever registers.  These won't
                show up in the heap residue because the heap residue is
                only called after the last unhook.  Since this will only
                occur under DEBUG builds, this is acceptable.

    HISTORY:
        Johnl   25-Nov-1992     Created
        ChuckC  17-May-1993     Added a couple of semaphores

********************************************************************/

APIERR BLT::InitDLL( void )
{
    //
    // Create the semaphore for BLT global init/term data
    //
    if (!(BLTIMP::_hBLTSema4))
    {
        if ( (BLTIMP::_hBLTSema4 = ::CreateSemaphore( NULL, 1, 1, NULL ))
               == NULL )
        {
            return ::GetLastError();
        }
    }

    //
    // Create the semaphore for BLT resource list protection
    //
    if (!(BLTIMP::_hResourceSema4))
    {
        if ( (BLTIMP::_hResourceSema4 = ::CreateSemaphore( NULL, 1, 1, NULL ))
               == NULL )
        {
            return ::GetLastError();
        }
    }

#if defined(DEBUG)
    // This calls the constructor for the dbgstream object.
    // Place no cdebug clauses before this statement is exec'd!
    //
    {
        const TCHAR * pszSection = SZ("blt");
        const TCHAR * pszIniFile = SZ("netui.ini");

        //
        //  Heap residue control.
        //
        //  [BLT]
        //      cMaxResidueBlocksToDump=10 <- max heap residue blocks to dump
        //      fBreakOnHeapResidue=1      <- break into debugger if residue
        //

        BLTIMP::_cMaxResidueBlocksToDump = ::GetPrivateProfileInt(
                                            pszSection,
                                            SZ("cMaxResidueBlocksToDump"),
                                            (int)BLTIMP::_cMaxResidueBlocksToDump,
                                            pszIniFile );

        BLTIMP::_fBreakOnHeapResidue = ( ::GetPrivateProfileInt(
                                            pszSection,
                                            SZ("fBreakOnHeapResidue"),
                                            (int)BLTIMP::_fBreakOnHeapResidue,
                                            pszIniFile ) > 0 );
    }
#endif   // DEBUG

    TRACEEOL("NETUI2.DLL: Initializing");

    return NERR_Success ;
}


/*******************************************************************

    NAME:       BLT::TermDLL

    SYNOPSIS:   Called once during process detach of BLT

    RETURNS:    nothing

    NOTES:      release all resources, performs heap residue checks

    HISTORY:
       ChuckC   17-May-1993     Documented (earlier history unknown)

********************************************************************/
VOID BLT::TermDLL( void )
{
    TRACEEOL("NETUI2.DLL: Unloading");

    //
    // close out the semaphores
    //
    ::CloseHandle( BLTIMP::_hResourceSema4 ) ;
    BLTIMP::_hResourceSema4 = NULL ;
    ::CloseHandle( BLTIMP::_hBLTSema4 ) ;
    BLTIMP::_hBLTSema4 = NULL ;

    //
    // heap residue check
    //
    HeapResidueIter( BLTIMP::_cMaxResidueBlocksToDump,
                     BLTIMP::_fBreakOnHeapResidue );

    CLIENT_WINDOW::Term();
}

/*******************************************************************

    NAME:       BLTIMP::AddClient

    SYNOPSIS:   Called to register a client's HMODULE & resource range
                with BLT so we know where to get a resource later.

    RETURNS:    APIERR as appropriate.

    NOTES:

    HISTORY:
       ChuckC   17-May-1993     Documented (earlier history unknown)

********************************************************************/
APIERR BLTIMP::AddClient( HMODULE hmod, UINT idMinR, UINT idMaxR,
                                       UINT idMinS, UINT idMaxS )
{
    APIERR err ;
    ASSERT(_pslClient != NULL);

#if defined(DEBUG)
    if (err = EnterResourceCritSect())
        return err ;
    ITER_SL_OF(CLIENTDATA) iter(*_pslClient);
    CLIENTDATA * pcld = NULL;

    while ((pcld = iter.Next()) != NULL)
    {
        if (pcld->_hmod == hmod)
        {
            DBGEOL("BLT: module " << (UINT)(UINT_PTR)hmod << " already registered");
            ASSERT(FALSE);
        }
    }
    LeaveResourceCritSect() ;
#endif

    // CODEWORK: consider keeping a static pool of these
    // to minimize freestore clutter

    CLIENTDATA *pcl = new CLIENTDATA;
    if (pcl == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    pcl->_hmod = hmod;
    pcl->_idMinResource = idMinR;
    pcl->_idMaxResource = idMaxR;
    pcl->_idMinString = idMinS;
    pcl->_idMaxString = idMaxS;

    if (err = EnterResourceCritSect())
    {
        delete pcl; // JonN 01/23/00: PREFIX bug 444890
        return err ;
    }

    err = _pslClient->Add(pcl);

    if (err == NERR_Success)
        ++_cInit;

    LeaveResourceCritSect() ;
    return err;
}


/*******************************************************************

    NAME:       BLTIMP::RemoveClient

    SYNOPSIS:   Called to remove a client's HMODULE & resource range
                registration with BLT.

    RETURNS:    nothing

    NOTES:

    HISTORY:
       ChuckC   17-May-1993     Documented (earlier history unknown)

********************************************************************/
VOID BLTIMP::RemoveClient( HMODULE hmod )
{
    ASSERT(_pslClient != NULL);
    ASSERT(_cInit > 0);

    if (EnterResourceCritSect() != NERR_Success)
        return ;

    ITER_SL_OF(CLIENTDATA) iter(*_pslClient);
    CLIENTDATA * pcld = NULL;

    while ((pcld = iter.Next()) != NULL)
    {
        if (pcld->_hmod == hmod)
        {
#if defined(DEBUG)
            CLIENTDATA * pcldx = pcld;  // sanity check the removal
#endif
            pcld = _pslClient->Remove(iter);
            ASSERT(pcld != NULL);       // invalid iterator?
            ASSERT(pcldx == pcld);      // sanity
            delete pcld;
            --_cInit;
            LeaveResourceCritSect() ;
            return;
        }
    }

    DBGEOL("BLT: deregistering bogus hmod");
    ASSERT(FALSE);
    LeaveResourceCritSect() ;
}


/*******************************************************************

    NAME:       BLTIMP::AddHelpAssoc

    SYNOPSIS:   Called to register a helpfile and its range with BLT

    RETURNS:    APIERR as apropriate

    NOTES:

    HISTORY:
       ChuckC   17-May-1993     Documented (earlier history unknown)

********************************************************************/
APIERR BLTIMP::AddHelpAssoc( HMODULE hMod,
                             MSGID  idsHelpFile,
                             ULONG  nMinHC,
                             ULONG  nMaxHC )
{
    APIERR err ;
    ASSERT( _pslHelpFiles != NULL );

#if defined(DEBUG)
    if (err = EnterResourceCritSect())
        return err ;

    ITER_SL_OF(ASSOCHCFILE) iter( *_pslHelpFiles );
    ASSOCHCFILE * phfd = NULL;

    while( ( phfd = iter.Next() ) != NULL )
    {
        if( ( phfd->QueryModule() == hMod ) &&
            phfd->IsAssociatedHC( nMinHC ) &&
            phfd->IsAssociatedHC( nMaxHC ) )
        {
            //
            //  CODEWORK:  This could be made more robust
            //  by checking for overlapping context ranges.
            //

            DBGEOL( "BLT: module " << (UINT)(UINT_PTR)hMod << " already registered" );
            ASSERT( FALSE );
        }
    }
    LeaveResourceCritSect() ;
#endif

    // CODEWORK: consider keeping a static pool of these
    // to minimize freestore clutter

    ASSOCHCFILE *phf = new ASSOCHCFILE( hMod, idsHelpFile, nMinHC, nMaxHC );

    if (err = EnterResourceCritSect())
        return err ;

    err =  ( phf == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                           : _pslHelpFiles->Add( phf );
    LeaveResourceCritSect() ;
    return err ;
}


/*******************************************************************

    NAME:       BLTIMP::RemoveHelpAssoc

    SYNOPSIS:   Called to remove a help registration with BLT.

    RETURNS:    nothing

    NOTES:

    HISTORY:
       ChuckC   17-May-1993     Documented (earlier history unknown)

********************************************************************/
VOID BLTIMP::RemoveHelpAssoc( HMODULE hMod,
                              ULONG  hc )
{
    ASSERT( _pslHelpFiles != NULL );

    if (EnterResourceCritSect() != NERR_Success)
        return ;

    ITER_SL_OF(ASSOCHCFILE) iter( *_pslHelpFiles );
    ASSOCHCFILE * phfd = NULL;

    while( ( phfd = iter.Next()) != NULL )
    {
        if( ( phfd->QueryModule() == hMod ) &&
            ( ( hc == 0L ) || phfd->IsAssociatedHC( hc ) ) )
        {
#if defined(DEBUG)
            ASSOCHCFILE * phfdx = phfd;  // sanity check the removal
#endif
            phfd = _pslHelpFiles->Remove( iter );
            ASSERT( phfd != NULL );       // invalid iterator?
            ASSERT( phfdx == phfd );      // sanity
            delete phfd;
            LeaveResourceCritSect() ;
            return;
        }
    }
    LeaveResourceCritSect() ;
}



/*******************************************************************

    NAME:       BLT::MapLastError

    SYNOPSIS:   Returns our best guess as to the last error.

        BLT calls this function when a Win API call failed, and it
        isn't sure of the reason why.  Under Win16, its best guess
        is our only answer.  Under Win32, we can find the last error
        reported per-thread, and so use that instead of the guess.

    ENTRY:      errBestGuess - Guessed last error.

    RETURNS:    A better guess.

    NOTES:
        This function is for BLT internal use only.  (CODEWORK: create
        a separate static hierarchy for these, unexported; or else, make
        every BLT internal class inherit from "BLT" at the root.)

        CODEWORK: possibly, overload this with other error classes.
        This function would then map internal errors, etc. into the
        single APIERR scheme.

    HISTORY:
        beng        01-Nov-1991 Created

********************************************************************/

APIERR BLT::MapLastError( APIERR errBestGuess )
{
#if defined(WIN32)
    APIERR errSystemGuess = ::GetLastError();

    if (errSystemGuess == NERR_Success && errBestGuess != NERR_Success)
    {
        // GetLastError claims that no error took place.  Maybe
        // the thread has since overwritten the error, or maybe the
        // user developers forgot to set the error... anyway, we'll
        // return the client's best guess instead.

        return errBestGuess;
    }

    return errSystemGuess;
#else
    return errBestGuess;
#endif
}


/*******************************************************************

    NAME:       BLT::Init

    SYNOPSIS:   Does all necessary initialization of BLT;
                should be called during application/DLL startup to
                register that app with BLT

    ENTRY:      hInst - Instance handled passed to WinMain or LibMain
                idMinR, idMaxR - a range of resource IDs, INCLUSIVE
                idMinS, idMaxS - ditto for string resources

    EXIT:       _hInst has been set to the given handle;
                all manner of window classes have been registered

    RETURNS:    NERR_Success if initialization was successful
                ERROR_OUT_OF_MEMORY or
                ERROR_GEN_FAILURE  if resource loading error
                ERROR_NOT_SUPPORTED if called in real-mode x86 Windows

    NOTES:
        This is a static member function.

        Once we are in the LM 3.0 timeframe (and BLT is a DLL),
        we will want to move InitMsgPopup to the LIBMAIN of BLT.

        Since it is not a ctor, this function unwinds all its inits
        should any of them fail.  See Unwind.

    HISTORY:
        Johnl       12-Mar-1991 Created
        DavidHov    14-Mar-1991 Corrected for real mode
        beng        21-May-1991 Added client-window init
        terryk      19-Jul-1991 Called the timer initializer
        beng        29-Jul-1991 Made from ::BltRegister; returns APIERR
        beng        18-Sep-1991 Changes to SLT_PLUS, CLIENT_WINDOW init
        beng        17-Oct-1991 Remove SLT_PLUS init
        beng        25-Oct-1991 Removed static ctors
        beng        30-Oct-1991 BLT no longer supports realmode;
                                rename function to Init (from Register)
        beng        16-Mar-1992 Change cdebug init
        beng        10-May-1992 Checks netui.ini for cdebug dest
        beng        31-Jul-1992 Factored out BLTIMP::Init etc.
        Johnl       25-Nov-1992 Made registering a NULL hmod a noop

********************************************************************/

APIERR BLT::Init( HMODULE hmod, UINT idMinR, UINT idMaxR,
                               UINT idMinS, UINT idMaxS )
{
#if !defined(WIN32)
    // Return immediately if called under realmode Windows.
    //
    if ( !(::GetWinFlags() & WF_PMODE) )
        return ERROR_NOT_SUPPORTED;
#endif

    APIERR err = BLTIMP::Init(); // no-op except for first time
    if (err == NERR_Success && hmod != NULL )
        err = BLTIMP::AddClient(hmod, idMinR, idMaxR, idMinS, idMaxS);
    return err;
}


/*******************************************************************

    NAME:       BLT::Term

    SYNOPSIS:   Frees any memory and uninitializes any BLT objects.

    ENTRY:      An app has been registered with BLT

    EXIT:       BLT no longer available to app (which may now terminate).

    NOTES:
        This is a static member function.

        Once we are in the LM 3.0 timeframe (and BLT is a DLL),
        we will want to move UnInitMsgPopup to the WEP of BLT.

        Calling Deregister when the app isn't registered has no effect.
        This simplifies error handling for lanman.drv, which wants to call
        Deregister from its WEP.

    HISTORY:
        Johnl       12-Mar-1991 Created
        DavidHov    14-Mar-1991 Corrected for real mode.
        beng        21-May-1991 Added client-window cleanup;
                                re-corrected for real mode
        terryk      19-Jul-1991 Call the Timer terminator
        beng        29-Jul-1991 Made from ::BLTDeregister
        beng        30-Oct-1991 Rename to Term (from Unregister)
        beng        31-Jul-1992 Factor out BLTIMP; dllization

********************************************************************/

VOID BLT::Term( HMODULE hmod )
{
    BLTIMP::RemoveClient(hmod);
    BLTIMP::RemoveHelpAssoc( hmod, 0L );
    BLTIMP::Term(); // will no-op as necessary
}


/*******************************************************************

    NAME:       BLT :: RegisterHelpFile

    SYNOPSIS:   Associates the specified help file with the specified
                range of help contexts.

    ENTRY:      hMod                    - Handle for current module.

                idsHelpFile             - String resource ID containing
                                          the name of the help file.

                nMinHC                  - Base help context.

                nMaxHC                  - Ceiling help context.

    RETURNS:    APIERR                  - Any errors encountered (usually
                                          either out of memory or resource
                                          not found).

    NOTES:      This is a static member function.

    HISTORY:
        KeithMo     07-Aug-1992 Created.

********************************************************************/
APIERR BLT :: RegisterHelpFile( HMODULE hMod,
                                MSGID  idsHelpFile,
                                ULONG  nMinHC,
                                ULONG  nMaxHC )
{
    return BLTIMP::AddHelpAssoc( hMod, idsHelpFile, nMinHC, nMaxHC );

}   // BLT :: RegisterHelpFile


/*******************************************************************

    NAME:       BLT :: DeregisterHelpFile

    SYNOPSIS:   Disssociates the help file associated with the given
                help context.

    ENTRY:      hMod                    - Handle for current module.

                hc                      - A help context whose value lies
                                          in the range of a previously
                                          registered help file.
    NOTES:      This is a static member function.

    HISTORY:
        KeithMo     16-Aug-1992 Created.

********************************************************************/
VOID BLT :: DeregisterHelpFile( HMODULE hMod,
                                ULONG  hc )
{
    BLTIMP::RemoveHelpAssoc( hMod, hc );

}   // BLT :: DeregisterHelpFile


/*******************************************************************

    NAME:       BLT::CalcHmodString

    SYNOPSIS:   Returns the instance handle of this application/DLL
                given a string resource #

    ENTRY:      BLT has been initialized:

                id      - numeric ID of the resource

    RETURNS:    HANDLE of the applications instance (actually module)

    NOTES:
        This is a static member function.

    HISTORY:
        beng        31-Jul-1992 Created, replacing QueryInstance
        chuckc      17-May-1993 Added critical section checks to
                                be multi-thread safe

********************************************************************/

HMODULE BLT::CalcHmodString( MSGID id )
{
    if (BLTIMP::_pslClient == NULL  ||
	BLTIMP::EnterResourceCritSect() )
    {
	return hmodBlt;
    }

    ITER_SL_OF(CLIENTDATA) iter(*BLTIMP::_pslClient);
    CLIENTDATA * pcld = NULL;

    // CODEWORK: accelerate this mess.
    //
    // 1. The SLIST is certainly overkill, considering how many
    // entries we'll have (never any more than 10).
    // 2. Should cache recent hits.  I'd use move-to-front except
    // that SLIST doesn't support it: I'd have to Remove, Add.  Gross.
    // Need to add this Move capability to SLIST.
    // 3. The common library always lies at the end of the search,
    // from where it can never be moved due to its if-all-the-others-
    // fail status.  Instead, the first Calc should scan the list and
    // build a true, cachable entry - or entries - for hmodBlt.
    // Any subequent Add/RemoveModule would invalidate this entry,
    // whereupon the next calc would recalc, etc.  (Important to
    // keep that, since folks might LoadLibrary acledit.dll, etc.)

    while ((pcld = iter.Next()) != NULL)
    {
        if (id >= (MSGID)pcld->_idMinString && id <= (MSGID)pcld->_idMaxString)
	{
	    BLTIMP::LeaveResourceCritSect() ;
            return pcld->_hmod;
        }
    }

    // If no hits, use the common lib as the default

    BLTIMP::LeaveResourceCritSect() ;
    return hmodBlt;
}



/*******************************************************************

    NAME:       BLT::CalcHmodResource

    SYNOPSIS:   Returns the instance handle of this application/DLL
                given a the numeric resource ID of some non-string.

    ENTRY:      BLT has been initialized:

                id      - numeric ID of the resource

    RETURNS:    HANDLE of the applications instance (actually module)

    NOTES:
        This is a static member function.

        I made this version a separate fcn both for its "different" first
        arg and because I figured it'd use a different cache.

    HISTORY:
        beng        31-Jul-1992 Created, replacing QueryInstance
        chuckc      17-May-1993 Added critical section checks to
                                be multi-thread safe

********************************************************************/

HMODULE BLT::CalcHmodRsrc( const IDRESOURCE & id )
{
    if (BLTIMP::_pslClient == NULL  ||
	BLTIMP::EnterResourceCritSect() )
    {
	return hmodBlt;
    }

    ASSERT(!id.IsStringId()); // only load-by-ordinal supported here

    ITER_SL_OF(CLIENTDATA) iter(*BLTIMP::_pslClient);
    CLIENTDATA * pcld = NULL;

    const UINT nId = PtrToUlong(id.QueryPsz());

    while ((pcld = iter.Next()) != NULL)
    {
        if (nId >= pcld->_idMinResource && nId <= pcld->_idMaxResource)
	{
	    BLTIMP::LeaveResourceCritSect() ;
            return pcld->_hmod;
        }
    }

    BLTIMP::LeaveResourceCritSect() ;
    return hmodBlt;
}



/*******************************************************************

    NAME:       BLT :: CalcHelpFileHC

    SYNOPSIS:   Returns the name of the help file associated with the
                given help context.  The help file must have been
                previously registered with BLT::RegisterHelpFile().

    ENTRY:      nHelpContext            - The help context to look up.

    RETURNS:    const TCHAR *           - The name of the associated help
                                          file if found.  If not found,
                                          returns NULL.

    NOTES:
        This is a static member function.

    HISTORY:
        KeithMo     07-Aug-1992 Created.
        chuckc      17-May-1993 Added critical section checks to
                                be multi-thread safe

********************************************************************/
const TCHAR * BLT :: CalcHelpFileHC( ULONG nHelpContext )
{
    const TCHAR * pszHelpFile = NULL;

    if ( BLTIMP::EnterResourceCritSect() != NERR_Success)
        return NULL ;

    if( BLTIMP::_pslHelpFiles != NULL )
    {
        ITER_SL_OF(ASSOCHCFILE) iter( *BLTIMP::_pslHelpFiles );
        ASSOCHCFILE * phfd = NULL;

        while( ( phfd = iter.Next() ) != NULL )
        {
            if( phfd->IsAssociatedHC( nHelpContext ) )
            {
                pszHelpFile = phfd->QueryHelpFile();
                break;
            }
        }
    }

    BLTIMP::LeaveResourceCritSect() ;
    return pszHelpFile;

}   // BLT :: CalcHelpFileHC



//
//  ASSOCHCFILE stuff.
//

ASSOCHCFILE::ASSOCHCFILE( HMODULE hMod,
                          MSGID  idsHelpFile,
                          ULONG  nMinHC,
                          ULONG  nMaxHC )
  : _hMod( hMod ),
    _nlsHelpFile( idsHelpFile ),
    _nMinHC( nMinHC ),
    _nMaxHC( nMaxHC )
{
    if( !_nlsHelpFile )
    {
        ReportError( _nlsHelpFile.QueryError() );
        return;
    }
}

ASSOCHCFILE::~ASSOCHCFILE()
{
    ;   // empty
}

/*******************************************************************

    NAME:       BLTIMP::EnterResourceCritSect

    SYNOPSIS:   enforces MUTEX for resource related data

    RETURNS:    APIERR as appropriate

    NOTES:

    HISTORY:
       ChuckC   17-May-1993     Created

********************************************************************/
APIERR BLTIMP::EnterResourceCritSect( void )
{
    APIERR err = NERR_Success ;
    switch ( WaitForSingleObject( BLTIMP::_hResourceSema4, 30000 ) )
    {
    case WAIT_OBJECT_0:
	break ;

    case WAIT_TIMEOUT:
        // should not happen since all we do is manipulate pointers
        // and maybe an alloc or two.
        UIASSERT(FALSE) ;
        err = ERROR_BUSY ;
        break ;

    default:
	err = ::GetLastError() ;
    }

    return err ;
}

/*******************************************************************

    NAME:       BLTIMP::LeaveResourceCritSect

    SYNOPSIS:   Leave the resource data critical section

    RETURNS:    nothing

    NOTES:

    HISTORY:
       ChuckC   17-May-1993     created

********************************************************************/
void BLTIMP::LeaveResourceCritSect( void )
{
    REQUIRE( ReleaseSemaphore( BLTIMP::_hResourceSema4, 1, NULL ) ) ;
}

/*******************************************************************

    NAME:       BLTIMP::EnterBLTCritSect

    SYNOPSIS:   enforces MUTEX for resource BLT init related data

    RETURNS:    APIERR as appropriate

    NOTES:

    HISTORY:
       ChuckC   17-May-1993     Created

********************************************************************/
APIERR BLTIMP::EnterBLTCritSect( void )
{
    APIERR err = NERR_Success ;
    switch ( WaitForSingleObject( BLTIMP::_hBLTSema4, INFINITE ) )
    {
    case WAIT_OBJECT_0:
	break ;

    default:
	err = ::GetLastError() ;
    }

    return err ;
}

/*******************************************************************

    NAME:       BLTIMP::LeaveBLTCritSect

    SYNOPSIS:   Leave the BLT init data critical section

    RETURNS:    nothing

    NOTES:

    HISTORY:
       ChuckC   17-May-1993     created

********************************************************************/
void BLTIMP::LeaveBLTCritSect( void )
{
    REQUIRE( ReleaseSemaphore( BLTIMP::_hBLTSema4, 1, NULL ) ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltlbst.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    BLTLBST.CXX:    Windows/NT Network Control Panel Applet.

        Classes in support of a "state listbox".  That is, one in which
        each item is prefaced by an icon indicating its current state.
        If only two icons are used, each item in the list box is
        equivalent to a checkbox.

    FILE HISTORY:
        DavidHov    1/8/92        Created

*/

#include "pchblt.hxx"   // Precompiled header

/*******************************************************************

    NAME:       STATELBGRP::STATELBGRP

    SYNOPSIS:   Constructor for State Listbox Control Group.

    ENTRY:      INT aiMapIds []         array of bit map id numbers,
                                        terminated by zero.
                OWNER_WINDOW * powin    owner window
                CID cid                 control id for list box
                int cCols               number of columns (default 2)
                BOOL fReadOnly          read-only flag (default FALSE)
                enum FontType font      font info (default NULL)

    EXIT:       nothing

    RETURNS:    standard

    NOTES:

    HISTORY:

********************************************************************/

STATELBGRP::STATELBGRP(
    INT aiMapIds [],
    OWNER_WINDOW * powin,
    CID cid,
    INT cCols,
    BOOL fReadOnly,
    enum FontType font )
{
    APIERR err ;
    if ( QueryError() )
    {
        return ;
    }

    _pstlb = new STATELB( aiMapIds, powin, cid, cCols, fReadOnly, font ) ;
    if ( _pstlb == NULL )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }
    if ( err = _pstlb->QueryError() )
    {
        ReportError( err ) ;
    }
    _pstlb->SetGroup( this ) ;
}


/*******************************************************************

    NAME:       STATELBGRP::STATELBGRP

    SYNOPSIS:   Constructor for State Listbox Control Group
                which accepts an existing listbox WHICH IS
                DELETED UPON DESCTRUCTION.

    ENTRY:      INT aiMapIds []         array of bit map id numbers,
                                        terminated by zero.
                OWNER_WINDOW * powin    owner window
                STATELB * pstlb         pointer to listbox to manage
                BOOL fReadOnly          read-only flag (default FALSE)
                enum FontType font      font info (default NULL)

    EXIT:       nothing

    RETURNS:    standard

    NOTES:      Destructor deletes the given listbox!

    HISTORY:

********************************************************************/

STATELBGRP::STATELBGRP( STATELB * pstlb )
    : _pstlb( pstlb )
{
    REQUIRE( _pstlb != NULL && _pstlb->QueryError() == 0 ) ;

    if ( QueryError() )
    {
        return ;
    }
    _pstlb->SetGroup( this ) ;
}


/*******************************************************************

    NAME:       STATELBGRP:: ~ STATELBGRP

    SYNOPSIS:   Destructor of State Listbox Control Group

********************************************************************/

STATELBGRP::~STATELBGRP ()
{
    delete _pstlb ;
}


/*******************************************************************

    NAME:       STATELBGRP::OnUserAction

    SYNOPSIS:   Handle user event notifications for the contained
                list box.

                The purpose of overridding this virtual member
                is to catch double clicks and change the state
                of the item.

    ENTRY:      CONTROL_WINDOW * pcw          window where event
                                              occurred
                const CONTROL_EVENT & cEvent  BLT encoded event

    EXIT:

    RETURNS:    APIERR, but never fails

    NOTES:

    HISTORY:

********************************************************************/

APIERR STATELBGRP::OnUserAction( CONTROL_WINDOW * pcw,
                                 const CONTROL_EVENT & cEvent )
{
    UNREFERENCED( pcw ) ;

    if (   cEvent.QueryMessage() == WM_COMMAND
        && cEvent.QueryCode() == LBN_DBLCLK )
    {
        STLBITEM * pstlbi = _pstlb->QueryItem();

        REQUIRE( pstlbi != NULL ) ;

        pstlbi->NextState() ;
    }
    return NERR_Success ;
}


/*******************************************************************

    NAME:       STATELB::STATELB

    SYNOPSIS:   Constructor for a state-oriented list box.
                Along with the standard baggage for a BLT_LISTBOX,
                construction requires a table of ids (integers)
                for bit maps in the resource file.  These bitmaps
                are converted to DISPLAY_MAPs and stored into a
                dynamically allocated array.  Each STLBITEM is
                given a pointer to its parent listbox and can
                query the number and location of the maps.

    ENTRY:      Same as for STATELBGRP.  Since this is a contained
                (hidden) class, do not instantiate.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

STATELB::STATELB( INT aiMapIds [],
                  OWNER_WINDOW * powin,
                  CID cid,
                  INT cCols,
                  BOOL fReadOnly,
                  enum FontType font )
    : BLT_LISTBOX( powin, cid, fReadOnly, font ),
    _ppdmMaps( NULL )
{
    APIERR err ;

    if ( QueryError() )
        return ;

    //  Check that the number of columns is legal.

    if ( cCols > STLBMAXCOLS )
    {
        ReportError( ERROR_GEN_FAILURE ) ;
        return ;
    }

    INT iMapIndex ;

    //  Count the number of bitmaps; table is zero-delimited.

    for ( _cMaps = 0 ; aiMapIds[_cMaps] != 0 ; _cMaps++ ) ;

    //  Allocate the pointer-to-bitmaps array

    _ppdmMaps = new DISPLAY_MAP * [ _cMaps + 1 ] ;
    if ( _ppdmMaps == NULL )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
        return ;
    }

    //  Load the bitmaps, convert them to DISPLAY_MAPs

    for ( iMapIndex = 0 ; iMapIndex < _cMaps ; iMapIndex++ )
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
        _ppdmMaps[iMapIndex] = new DISPLAY_MAP( aiMapIds[iMapIndex] ) ;
        if ( _ppdmMaps[iMapIndex] == NULL )
            break ;
        if ( err = _ppdmMaps[iMapIndex]->QueryError() )
            break ;
    }

    _ppdmMaps[iMapIndex] = NULL ;

    //  If not all of the DISPLAY_MAPs were allocated and constructed,
    //     report the error and fail.

    if ( iMapIndex < _cMaps )
    {
        ReportError( err ) ;
        return ;
    }

    //  Perform the initialization of the column widths for a DISPLAY_TABLE

    for ( INT i = 0 ; i < STLBMAXCOLS ; i++ )
    {
        _adxColumns[i] = 0 ;
    }

    err = DISPLAY_TABLE::CalcColumnWidths( _adxColumns, cCols,
                                           powin, cid, TRUE );
    if ( err )
    {
        ReportError( err ) ;
        return ;
    }
}


/*******************************************************************

    NAME:       STATELB::~STATELB

    SYNOPSIS:   Destroy the State Listbox

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      Destroy all allocated DISPLAY_MAPs and the array
                of pointers to them.

    HISTORY:

********************************************************************/

STATELB::~ STATELB ()
{
    if ( _ppdmMaps != NULL )
    {
        for ( INT i = 0 ; _ppdmMaps[i] ; i++ )
        {
            delete _ppdmMaps[i] ;
        }
        delete _ppdmMaps ;
    }
}


/*******************************************************************

    NAME:       STATELB::CD_Char

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

INT STATELB::CD_Char ( WCHAR wch, USHORT nLastPos )
{
    return BLT_LISTBOX::CD_Char( wch, nLastPos ) ;
}


/*******************************************************************

    NAME:       STATELB::CD_VKey

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

INT STATELB::CD_VKey ( USHORT nVKey, USHORT nLastPos )
{
    UNREFERENCED( nLastPos ) ;

    if ( nVKey == VK_SPACE )
    {
        STLBITEM * pstlbi = QueryItem() ;

        REQUIRE( pstlbi != NULL ) ;

        pstlbi->NextState() ;

        return -2 ;   // No further action required
    }
    else
    {
        return BLT_LISTBOX::CD_VKey( nVKey, nLastPos ) ;
    }
}


/*******************************************************************

    NAME:       STLBITEM::STLBITEM

    SYNOPSIS:   Constructor of State List Box Control Group item.
                Since the list box contains the array of DISPLAY_MAPs,
                each list box item has a pointer to its parent
                list box.

    ENTRY:      STATELBGRP * pstgGroup     pointer to list box group

    EXIT:       nothing

    RETURNS:    standard

    NOTES:      The STATELBGRP is required for construction to
                discourage attempts to subclass STATELB.

    HISTORY:

********************************************************************/

STLBITEM::STLBITEM ( STATELBGRP * pstgGroup )
    : _pstlb( pstgGroup->QueryLb() ),
    _iState( 0 )
{

}


/*******************************************************************

    NAME:       STLBITEM:: ~ STLBITEM

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

STLBITEM::~ STLBITEM ()
{
}


/*******************************************************************

    NAME:       STLBITEM:: Paint

    SYNOPSIS:   Override of virtual member to paint the ownder-drawn
                item.

    ENTRY:      See LBI::Paint() for details

    EXIT:       nothing

    RETURNS:    nothing

    NOTES:      The internal STATELB pointer is used to access its
                array of DISPLAY_MAPs.  The list item's state is
                assumed to be valid because SetState() will not
                allow it to be set to a value outside the known range.

    HISTORY:
        beng        21-Apr-1992 Interface change in LBI::Paint

********************************************************************/

VOID STLBITEM::Paint (
     LISTBOX * plb,
     HDC hdc,
     const RECT * prect,
     GUILTT_INFO * pGUILTT ) const
{
    DM_DTE   dteMap( _pstlb->QueryMapArray()[ _iState ] );
    STR_DTE  dteStr( QueryDisplayString() );

    DISPLAY_TABLE dtab( STLBCOLUMNS, _pstlb->QueryColData() );

    dtab[0] = & dteMap;
    dtab[1] = & dteStr;

    dtab.Paint( plb, hdc, prect, pGUILTT );
}


/*******************************************************************

    NAME:       STLBITEM::QueryLeadingChar

    SYNOPSIS:   Standard routine, overridden to take advantage
                of the fact that every subclass of STLBITEM must have
                a QueryDisplayString() function; thus, the data
                is publically available.

    ENTRY:      nothing

    EXIT:       nothing

    RETURNS:    WCHAR of 1st character in string

    NOTES:

    HISTORY:

********************************************************************/

WCHAR STLBITEM::QueryLeadingChar () const
{
    return *QueryDisplayString() ;
}


/*******************************************************************

    NAME:       STLBITEM::Compare

    SYNOPSIS:   Standard routine, overridden to take advantage
                of the fact that every subclass of STLBITEM must have
                a QueryDisplayString() function; thus, the data
                is publically available.

    ENTRY:      nothing

    EXIT:       nothing

    RETURNS:    Standate "strcmp" values of string comparison.

    NOTES:      List boxes are not necessarily sorted; cf. LBS_SORT.

    HISTORY:

********************************************************************/

INT STLBITEM::Compare ( const LBI * plbi ) const
{
    return ::stricmpf( QueryDisplayString(),
                       ((const STLBITEM *)plbi)->QueryDisplayString() );
}

/*******************************************************************

    NAME:       STLBITEM::SetState

    SYNOPSIS:   Set the internal and visible state of the list
                box item.

    ENTRY:      INT iState          new state desired

    EXIT:       item is set to new state;
                display updated accordingly

    RETURNS:    INT   old state

    NOTES:      The modulus operator is used to guarantee that
                the item is always set to a value within the
                range of the map list.

    HISTORY:

********************************************************************/

INT STLBITEM::SetState( INT iState )
{
    INT iOldState = _iState ;

    if ( iState < 0 )
        iState = 0 ;
    else
        _iState = iState % _pstlb->QueryMapCount() ;

    _pstlb->InvalidateItem( _pstlb->FindItem( *this ) ) ;

    return iOldState ;
}

// End of BLTLBST.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltlc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltlc.cxx
    BLT list control: implementations

    FILE HISTORY:
        rustanl     20-Nov-1990     Created
        beng        11-Feb-1991     Uses lmui.hxx
        rustanl     22-Feb-1991     Changes due to new LC hierarchy
        rustanl     19-Mar-1991     Added COMBOBOX::SetMaxLength, and
                                    corresponding constructor parameter
        rustanl     21-Mar-1991     Folded in code review changes from
                                    CR on 20-Mar-1991 attended by
                                    JimH, GregJ, Hui-LiCh, RustanL.
        beng        14-May-1991     Exploded blt.hxx into components
        terryk      25-Jul-1991     Add SetItemData, QuerySelCount and
                                    QuerySelItems to LIST_CONTROL class
                                    Also add SetTopIndex, ChangeSel
        rustanl     12-Aug-1991     Hid some single/mult sel differences
                                    between the cozy covers of BLT
        terryk      22-Mar-1992     add STRING_LIST_CONTROL's InsertItem
        jonn        09-Sep-1993     Moved fns from SET_CONTROL_LISTBOX
                                    to LISTBOX

*/

#include "pchblt.hxx"   // Precompiled header

//  -----  Local macros  -----

/*  The following macro is used to conveniently specify a LB_ or CB_
 *  manifest, depending on the value of _fCombo.  Note, although
 *  most (not all!) LB_ and CB_ manifests have the same name (apart from
 *  the prefix) and SendMessage semantics, they do not have the same values
 *  at all.  An experienced PM programmer may at this point be stunned.
 */

#define LC_MSG( suffix )    ( IsCombo() ? ( CB_##suffix ) : ( LB_##suffix ))


//  This file assumes that LB_ERR has the same value as CB_ERR.  The file
//  only uses LB_ERR when checking return codes.  If the two values differ,
//  the code needs to change to use ( IsCombo() ? CB_ERR : LB_ERR ) instead.
#if ( LB_ERR != CB_ERR )
#error "This file assumes LB_ERR == CB_ERR."
#endif


/**********************************************************************

    NAME:           LIST_CONTROL::LIST_CONTROL

    SYNOPSIS:   Constructor for list-control abstract object

    ENTRY:      OWNER_WINDOW * powin - pointer to the owner window
                CID cid - cid of the listbox
                BOOL fCombo - flag for combo box

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        17-May-1991     Added app-window constructor

**********************************************************************/

LIST_CONTROL::LIST_CONTROL( OWNER_WINDOW * powin, CID cid, BOOL fCombo )
    :   CONTROL_WINDOW( powin, cid ),
        _fCombo( fCombo ) ,
        _iSavedSelection( 0 ),
        _piSavedMultSel( NULL )
{
    if ( QueryError() )
        return;
}

LIST_CONTROL::LIST_CONTROL(
    OWNER_WINDOW * powin,
    CID            cid,
    BOOL           fCombo,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName )
    :   CONTROL_WINDOW( powin, cid, xy, dxy, flStyle, pszClassName ),
        _fCombo( fCombo ) ,
        _iSavedSelection( 0 ),
        _piSavedMultSel( NULL )
{
    if ( QueryError() )
        return;
}

LIST_CONTROL::~LIST_CONTROL()
{
    delete _piSavedMultSel;
}


/*******************************************************************

    NAME:       LIST_CONTROL::IsMultSel

    SYNOPSIS:   Returns whether or not several items in the list control
                can be selected at one time.

    RETURNS:    FALSE if at most one item can be selected at one time
                    in the list control (i.e., the list control is
                    either a combo box or a single select listbox)
                TRUE if several items can be selected simultaneously
                    (i.e., the list control is either a extended select
                    listbox or a multiple select listbox)

    HISTORY:
        rustanl     12-Aug-1991     Created

********************************************************************/

BOOL LIST_CONTROL::IsMultSel() const
{
    if ( IsCombo())
        return FALSE;

    ULONG ulStyle = QueryStyle();
    if ( ( ulStyle & LBS_MULTIPLESEL ) ||
         ( ulStyle & LBS_EXTENDEDSEL ))
    {
        return TRUE;
    }

    return FALSE;
}


/**********************************************************************

   NAME:        LIST_CONTROL::AddItemData

   SYNOPSIS:    Add an item to the list box control

   ENTRY:       VOID * pv - pointer to the item to be added

   EXIT:        LB_ERR if an error occurs
                LB_ERRSPACE - not enough space to add the item
                Otherwise, it will be index of the item in the listbox

   HISTORY:
      rustanl   20-Nov-1990     Created

**********************************************************************/

INT LIST_CONTROL::AddItemData( VOID * pv )
{
    return (INT)Command( LC_MSG( ADDSTRING), 0, (LPARAM)pv );
}


/**********************************************************\

    NAME:       LIST_CONTROL::SetItemData

    SYNOPSIS:   set the data item to new value

    ENTRY:      INT i - index of the item
                VOID *pv - the new data

    RETURN:     The return value is LB_ERR if an error occurs

    HISTORY:
                terryk  25-Jul-1991 Created

\**********************************************************/

INT LIST_CONTROL::SetItemData( INT i, VOID * pv )
{
    return (INT)Command( LC_MSG( SETITEMDATA ), i, (LPARAM)pv );
}


/**********************************************************\

    NAME:       LIST_CONTROL::InsertItemData

    SYNOPSIS:   insert the item data in the given index

    ENTRY:      INT i - index of the item
                VOID *pv - the new data

    RETURN:     The return value is LB_ERR if an error occurs

    HISTORY:
                kevinl  23-Oct-1991 Created
                jonn    16-Feb-1993 Maintains caret position on WIN32

\**********************************************************/

INT LIST_CONTROL::InsertItemData( INT i, VOID * pv )
{
#ifdef WIN32
    INT nCaretIndex = 0;
    BOOL fMultSel = IsMultSel();
    if ( fMultSel )
    {
        nCaretIndex = QueryCaretIndex();
    }
#endif
    INT nReturn = (INT)Command( LC_MSG( INSERTSTRING ), i, (LPARAM)pv );
    // nReturn could be LB_ERR or LB_ERRSPACE
#ifdef WIN32
    if ( fMultSel && (nReturn <= nCaretIndex) && (nReturn >= 0) )
    {
        SetCaretIndex( nCaretIndex+1 );
    }
#endif
    return nReturn;
}


/**********************************************************************

    NAME:       LIST_CONTROL::SetTopIndex

    SYNOPSIS:   Set the index of the first visible control in list ctrl

    ENTRY:      i - the index

    NOTES:
        CODEWORK - this method only works on listboxes.  As such, it
        should move to some intermediate class.

    HISTORY:
        terryk      26-Jul-1991     Created

***********************************************************************/

VOID LIST_CONTROL::SetTopIndex( INT i )
{
    REQUIRE( (INT)Command( LB_SETTOPINDEX, i, 0 ) != LB_ERR );
}


/*******************************************************************

    NAME:       LIST_CONTROL::QueryTopIndex

    SYNOPSIS:   Returns the index of the topmost visible line

    RETURNS:    listbox index

    NOTES:
        CODEWORK - this method only works on listboxes.  As such, it
        should move to some intermediate class.

    HISTORY:
        beng        22-Aug-1991     Created

********************************************************************/

INT LIST_CONTROL::QueryTopIndex() const
{
    return (INT)Command(LB_GETTOPINDEX);
}


/**********************************************************************

    NAME:       LIST_CONTROL::SetCaretIndex

    SYNOPSIS:   Set the index of the item with the caret, and scroll the
                item into view.

    ENTRY:      i - the index
                fPartiallyVisibleOK - if TRUE, the listbox will be scrolled
                        until the item is at least partially visible.
                        If TRUE, the item will be fully visible.

    HISTORY:
        jonn        15-Sep-1993     Created

***********************************************************************/

VOID LIST_CONTROL::SetCaretIndex( INT i, BOOL fPartiallyVisibleOK )
{
    REQUIRE( (INT)Command( LB_SETCARETINDEX, i, fPartiallyVisibleOK ) != LB_ERR );
}


/*******************************************************************

    NAME:       LIST_CONTROL::QueryCaretIndex

    SYNOPSIS:   Returns the index of the item with the caret

    RETURNS:    listbox index

    HISTORY:
        jonn        15-Sep-1993     Created

********************************************************************/

INT LIST_CONTROL::QueryCaretIndex() const
{
    return (INT)Command( LB_GETCARETINDEX );
}


/**********************************************************************

   NAME:        LIST_CONTROL::QueryCount

   SYNOPSIS:    query the total number of items in the list box

   EXIT:        total number of item in the list box

   HISTORY:
                rustanl 20-Nov-1990     Created

**********************************************************************/

INT LIST_CONTROL::QueryCount() const
{
    return (INT)Command( LC_MSG( GETCOUNT ));

}


/**********************************************************\

    NAME:       LIST_CONTROL::QuerySelCount

    SYNOPSIS:   get the number of items selected in the list control

    RETURN:     total number of selected items

    HISTORY:
                terryk  25-Jul-1991 Created
                rustanl 12-Aug-1991 Added support for both single
                                    sel listboxes, too.

\**********************************************************/

INT LIST_CONTROL::QuerySelCount() const
{
    if ( IsMultSel())
    {
        INT c = (INT)Command( LB_GETSELCOUNT );
        UIASSERT( c >= 0 );
        return c;
    }

    // combo or single sel listbox
    if ( QueryCurrentItem() < 0 )
        return 0;

    return 1;
}


/*********************************************************************

    NAME:       LIST_CONTROL::QuerySelItem

    SYNOPSIS:   return an array of integer indecies for the currently
                selected list control items

    ENTRY:      piSel -         Pointer to buffer (array) which will
                                receive the selected items.
                ciMax -         Maximum number of entries that array
                                pointed to by piSel can hold

    RETURN:     An API return code, which is NERR_Success on success.
                Other often-returned errors may include:
                        ERROR_MORE_DATA -   More than ciMax items are
                                            selected, but only ciMax indicies
                                            were copied into the piSel
                                            buffer.

    HISTORY:
                terryk  25-JUl-1991 Created
                rustanl 12-Aug-1991 Added support for single
                                    select listboxes, too.

**********************************************************************/

APIERR LIST_CONTROL::QuerySelItems( INT * piSel, INT ciMax ) const
{
    UIASSERT( ciMax >= 0 );
    UIASSERT( ciMax == 0 || piSel != NULL );

    if ( IsMultSel())
    {
        INT c = (INT)Command( LB_GETSELITEMS, ciMax, (LPARAM)piSel );
        UIASSERT( c >= 0 );

        if ( QuerySelCount() < ciMax )
            return ERROR_MORE_DATA;

        return NERR_Success;
    }

    INT iCurr = QueryCurrentItem();
    if ( iCurr < 0 )
    {
        // no item is selected
        return NERR_Success;
    }

    if ( ciMax < 1 )
        return ERROR_MORE_DATA;

    piSel[ 0 ] = iCurr;
    return NERR_Success;
}


/*********************************************************************

    NAME:       LISTBOX::QueryItemHeight

    SYNOPSIS:   Calculate the height of any entry in the listbox

    HISTORY:
        beng        21-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to LISTBOX

*********************************************************************/

UINT LIST_CONTROL::QueryItemHeight( UINT ilb ) const
{
    LONG nRet = (LONG)Command( LB_GETITEMHEIGHT, ilb );
    ASSERT( nRet != LB_ERR );

    return nRet;
}


/*********************************************************************

    NAME:       LISTBOX::IsItemSelected

    SYNOPSIS:   Returns whether a given item is selected

    HISTORY:
        beng        21-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to LISTBOX

*********************************************************************/

BOOL LIST_CONTROL::IsItemSelected( UINT ilb ) const
{
    LONG nRet = (LONG)Command( LB_GETSEL, ilb );
    ASSERT(nRet != LB_ERR);

    return (nRet > 0) ? TRUE : FALSE; // works in error case, too
}


/**********************************************************************

   NAME:        LIST_CONTROL::SelectItem

   SYNOPSIS:    Select the specified item

   ENTRY:       INT i -         index for the selected item
                BOOL fSelect -  TRUE to select the item (default)
                                FALSE to unselect the item

    EXIT:       If fSelect is TRUE and i is a valid index,
                        Item i will be selected.
                If fSelect is TRUE and i is -1,
                        No item will be selected.
                If fSelect is FALSE and i is a valid index,
                        Item i will be unselected.

   NOTES:
      Passing i as -1 and fSelect as TRUE means to remove the hi-lite
      bar marking the current selection.  A client should try to avoid
      depending on this, and instead calling RemoveSelection.  If
      fSelect is FALSE, i must specify a valid index.

   HISTORY:
      rustanl   20-Nov-1990     Created
      rustanl   13-Aug-1991     Added fSelect parameter and multiple
                                select support

**********************************************************************/

VOID LIST_CONTROL::SelectItem( INT i, BOOL fSelect )
{
    if ( fSelect )
    {

        if ( IsMultSel())
        {
            REQUIRE( Command( LB_SETSEL, ( i >= 0 ), (ULONG)((LONG)i))
                     != LB_ERR );
            return;
        }

        //  Although not documented in the Windows SDK, the LB_SETCURSEL (and
        //  CB_SETCURSEL, which eventually maps to LB_SETCURSEL) message
        //  returns wParam if wParam is a valid index or is -1; otherwise, it
        //  returns LB_ERR.  (Note, that a return code of -1 can thus mean two
        //  different things, depending on what was passed in.)
        //
        //  The SDK only says that the message returns LB_ERR on error; it does
        //  not say anything about the return code if no error occurs.
        //
        //  The REQUIRE statement will fail precisely when the given index
        //  is not a valid index and is not -1.
        //
        REQUIRE( (LONG)Command( LC_MSG( SETCURSEL ), (UINT)i ) == (LONG)i );
    }
    else
    {
        UIASSERT( 0 <= i && i < QueryCount());

        if ( IsMultSel())
        {
            REQUIRE( Command( LB_SETSEL, FALSE, (ULONG)((LONG)i)) != LB_ERR );
            return;
        }

        if ( QueryCurrentItem() == i )
            RemoveSelection();
    }
}


/**********************************************************************

   NAME:        LIST_CONTROL::SelectItems

   SYNOPSIS:    Select the specified items

   ENTRY:       INT * pi -      indexes for the selected items
                INT c -         number of items
                BOOL fSelect -  TRUE to select the item (default)
                                FALSE to unselect the item

   NOTES:
      Only pass valid indices as parameters.  The current selection
      will not be cleared (for multi-select listboxes).

   HISTORY:
      jonn      15-Sep-1993     Created

**********************************************************************/

VOID LIST_CONTROL::SelectItems( INT * pi, INT c, BOOL fSelect )
{
    ASSERT( c == 0 || pi != NULL );

    INT i;
    for ( i = 0; i < c; i++ )
    {
        SelectItem( pi[i], fSelect );
    }
}


/**********************************************************************

   NAME:        LIST_CONTROL::DeleteItem

   SYNOPSIS:    delete the specified item from the listbox

   ENTRY:       INT i - item to be deleted

   RETURN:      The return value is a count of the strings remaining in the
                list. THe return value is LB_ERR if an error occurs.

   HISTORY:
      rustanl   20-Nov-1990     Created
      jonn      16-Feb-1993     Maintains caret position on WIN32

**********************************************************************/

INT LIST_CONTROL::DeleteItem( INT i )
{
    //  The LC_MSG( DELETESTRING ) message returns the number of items
    //  remaining in the list control on success, and LB_ERR (a negative
    //  value) on failure.

#ifdef WIN32
    INT nCaretIndex = 0;
    BOOL fMultSel = IsMultSel();
    if ( fMultSel )
    {
        nCaretIndex = QueryCaretIndex();
    }
#endif
    INT nReturn = (INT)Command( LC_MSG( DELETESTRING ), (UINT)i );
#ifdef WIN32
    if ( fMultSel && (i <= nCaretIndex) && (nReturn != LB_ERR) )
    {
        // move caret position back one if earlier item was deleted
        // if caret was on first item, then i >= nCaretPosition, so this
        //  will not move position to nCaretPosition < 0
        if ( i < nCaretIndex )
        {
            nCaretIndex--;
        }

        // move caret position to end of list if it is past end
        if ( nCaretIndex >= QueryCount() )
        {
            nCaretIndex = QueryCount() - 1;
        }

        // only set caret position if item exists
        if ( (nCaretIndex >= 0) && (nCaretIndex < QueryCount()) )
        {
            SetCaretIndex( nCaretIndex );
        }
    }
#endif
    return nReturn;

}


/**********************************************************************

   NAME:        LIST_CONTROL::DeleteAllItems

   SYNOPSIS:    delete all the item from the listbox

   HISTORY:
      rustanl   20-Nov-1990 Created
      beng      22-Sep-1991 Correct usage of GetVersion

**********************************************************************/

VOID LIST_CONTROL::DeleteAllItems()
{
    Command( LC_MSG( RESETCONTENT ));

    ULONG ulWindowsVersion = ::GetVersion();
    if ( ! _fCombo &&
         LOBYTE( LOWORD(ulWindowsVersion) ) == 3 &&     // major version no.
         HIBYTE( LOWORD(ulWindowsVersion) ) < 10 )      // minor version no.
    {
        //  This function uses a RustanL/ChuckC hack to get around a
        //  Windows 3.00 listbox problem where Windows doesn't get rid of the
        //  scrollbar when a listbox is emptied.  The work-around works as
        //  follows:
        //
        //      First, all items are removed from the listbox (above).  At
        //      this time, the scrollbar may still be there.
        //
        //      Then, one item is added to the listbox.  The listbox will at
        //      this time realize that it is not in need of the scrollbar, so
        //      it will remove it, if it was there.
        //
        //      Finally, the listbox is cleared again, removing the one
        //      item that was inserted.
        //
        //  This problem has been fixed in Windows 3.10; hence, the version
        //  check above.
        //

        VOID * pv;

        ULONG flStyle = QueryStyle();
        if ( ( flStyle & ( LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE )) &&
             ! ( flStyle & LBS_HASSTRINGS ))
        {
            //  The list control is a BLT listbox.  We should thus make pv a
            //  pointer to an LBI item.  Rather than calling 'new' and the LBI
            //  constructor (which may fail and return a NULL anyway), we
            //  simply set pv to NULL.  ShellDlgProc will still be able to
            //  properly delete this item (since C++ always defines delete
            //  on NULL pointers).  However, this will generate a WM_DRAWITEM
            //  message.  Hence, every CD_Draw routine must check the pointer
            //  for NULL before beginning to draw.
            pv = NULL;
        }
        else
        {
            //  The list control is a string list control
            pv = SZ("");
        }

        //  Note.  The item to be temporarily added to the list control, pv,
        //  is either NULL or points to the empty string, neither one of
        //  which will cause anything to be painted (even though it may
        //  generate a WM_DRAWITEM message).  Hence, the user will not
        //  get any flickering as a result of adding this item.
        AddItemData( pv );

        Command( LC_MSG( RESETCONTENT ));

    }
}


/**********************************************************************

   NAME:        LIST_CONTROL::QueryCurrentItem

   SYNOPSIS:    get the index of the first currently selected item

   RETURN:      The return value is the index of the first currently selected
                item.  It is a negative value if no item is selected.

   NOTES:       Since LIST_CONTROL::QuerySelItems calls this method, this
                method needs to be careful if calling QuerySelItems.  For
                this reason, this method calls Command directly with
                the LB_GETSELITEMS parameter.

   HISTORY:
      rustanl   20-Nov-1990     Created
      rustanl   12-Aug-1991     Added multiple selection support

**********************************************************************/

INT LIST_CONTROL::QueryCurrentItem() const
{
    if ( IsMultSel())
    {
        INT iSel;
        INT cRet = (INT)Command( LB_GETSELITEMS, 1, (LPARAM)&iSel );
        UIASSERT( cRet == 0 || cRet == 1 );
        if ( cRet == 1 )
            return iSel;
        return -1;
    }

    return (INT)Command( LC_MSG( GETCURSEL ));

}


/*******************************************************************

    NAME:     LIST_CONTROL::SaveValue

    SYNOPSIS: Saves the state of the list control and unselects the
              current item

    EXIT:     Unselected listbox

    NOTES:    See LIST_CONTROL header notes for comments on multiselection

    HISTORY:
        Johnl   25-Apr-1991     Created
        JonN    04-Dec-1992     Supports multiple-selection

********************************************************************/

VOID LIST_CONTROL::SaveValue( BOOL fInvisible )
{
    if ( IsMultSel() )
    {
        delete _piSavedMultSel;
        _piSavedMultSel = NULL;

        _iSavedSelection = QuerySelCount();
        _piSavedMultSel = new INT[ _iSavedSelection ];

        if (    _piSavedMultSel == NULL
             || QuerySelItems( _piSavedMultSel, _iSavedSelection ) != NERR_Success )
        {
            DBGEOL( "NETUI: LIST_CONTROL::SaveValue(): Could not save selection" );
            delete _piSavedMultSel;
            _piSavedMultSel = NULL;
        }
    }
    else
    {
        _iSavedSelection = QueryCurrentItem();
    }

    if ( fInvisible )
        RemoveSelection();
}


/*******************************************************************

    NAME:     LIST_CONTROL::RestoreValue

    SYNOPSIS: Restores LIST_CONTROL after SaveValue

    NOTES:    See CONTROL_VALUE for more details.

              See LIST_CONTROL header notes for comments on multiselection

    HISTORY:
        Johnl   25-Apr-1991     Created
        JonN    04-Dec-1992     Supports multiple-selection

********************************************************************/

VOID LIST_CONTROL::RestoreValue( BOOL fInvisible )
{
    if ( fInvisible )
    {
        if ( IsMultSel() )
        {
            if ( _piSavedMultSel == NULL )
            {
                DBGEOL( "NETUI: LIST_CONTROL::RestoreValue(): Could not restore selection" );
            }
            else
            {
                RemoveSelection();
                for ( INT i = 0; i < _iSavedSelection; i++ )
                    SelectItem( _piSavedMultSel[i] );
            }
        }
        else
        {
            SelectItem( _iSavedSelection );
        }
    }
}


/*******************************************************************

    NAME:       LIST_CONTROL::QueryEventEffects

    SYNOPSIS:   Returns one of the CVMI_* values.
                See CONTROL_VALUE for more information.

    ENTRY:      Let the parent group test the lParam to see whether it will
                change the listbox or not

    RETURNS:    If the selection is changed, it will return CVMI_VALUE_CHANGE
                CVMI_NO_VALUE_CHANGE otherwise

    NOTES:
        This only handles listbox messages, COMBOBOX::QueryEventEffects
        handles the combobox messages.

    HISTORY:
        Johnl       29-Apr-1991 Created
        beng        31-Jul-1991 Renamed from QMessageInfo
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

UINT LIST_CONTROL::QueryEventEffects( const CONTROL_EVENT & e )
{
    // UIASSERT( !IsMultSel());        // not support (yet)

    switch ( e.QueryCode() )
    {
    case LBN_SELCHANGE:
        return CVMI_VALUE_CHANGE;

    case LBN_SETFOCUS:
        return CVMI_VALUE_CHANGE | CVMI_RESTORE_ON_INACTIVE;

    default:
        break;
    }

    return CVMI_NO_VALUE_CHANGE;
}


/**********************************************************************

    NAME:       STRING_LIST_CONTROL::STRING_LIST_CONTROL

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW * powin - pointer to the owner window
                CID cid - cid of the string list control
                BOOL fCombo - flag for combo box

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        17-May-1991     Added app-window constructor

**********************************************************************/

STRING_LIST_CONTROL::STRING_LIST_CONTROL( OWNER_WINDOW * powin,
                                          CID cid,
                                          BOOL fCombo )
    : LIST_CONTROL( powin, cid, fCombo )
{
    if ( QueryError() )
        return;

    // nothing else to do
}

STRING_LIST_CONTROL::STRING_LIST_CONTROL(
    OWNER_WINDOW * powin,
    CID            cid,
    BOOL           fCombo,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName )
    : LIST_CONTROL( powin, cid, fCombo, xy, dxy, flStyle, pszClassName )
{
    if ( QueryError() )
        return;

    // nothing else to do
}


/**********************************************************************

   NAME:        STRING_LIST_CONTROL::AddItem

   SYNOPSIS:    Add a string to list box

   ENTRY:       TCHAR * pch - string to be added

   EXIT:        LB_ERR if an error occurs
                LB_ERRSPACE if not enough space to add the item
                index of the new added string if no error occurs

   HISTORY:
      rustanl   20-Nov-1990     Created

**********************************************************************/

INT STRING_LIST_CONTROL::AddItem( const TCHAR * pch )
{
    return AddItemData( (VOID *)pch );
}


/**********************************************************************

   NAME:        STRING_LIST_CONTROL::AddItemIdemp

   SYNOPSIS:    Same as add item, however, it will not add the item to
                the listbox if the item already existed in the listbox

   ENTRY:       TCHAR * psz - string to be added

   EXIT:        LB_ERR if an error occurs
                LB_ERRSPACE if not enough space to add the item
                index of the new added string if no error occurs

   HISTORY:
      rustanl   20-Nov-1990     Created

**********************************************************************/

INT STRING_LIST_CONTROL::AddItemIdemp( const TCHAR * pch )
{
    INT i = FindItemExact( pch );

    if ( i < 0 )
        return AddItem( pch );

    return i;
}


/**********************************************************************

   NAME:        STRING_LIST_CONTROL::InsertItem

   SYNOPSIS:    Insert the item in the specified location

   ENTRY:       INT i - location index
                TCHAR * psz - string to be added

   EXIT:        LB_ERR if an error occurs
                LB_ERRSPACE if not enough space to add the item
                index of the new added string if no error occurs

   HISTORY:
      terryk   22-Mar-1992     Created

**********************************************************************/

INT STRING_LIST_CONTROL::InsertItem( INT i, const TCHAR * pch )
{
    return InsertItemData( i, (VOID *) pch );
}


/**********************************************************************

    NAME:       STRING_LIST_CONTROL::FindItem

    SYNOPSIS:   find the string from the listbox

    ENTRY:
        pchPrefix         - point to the prefix string, the string
                            must be null-terminated

        iLastSearchResult - contains the index of the item
                            before the first item to be searched.
                            When the search reaches the bottom of the
                            listbox, it continues from the top of the
                            listbox back to the item specified by
                            this value.


    RETURNS:    The return value is the index of the matching item or
                LB_ERR if the search was unsuccessful.

    NOTES:      If the index given is -1, Windows searches the entire
                listbox from the beginning.

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        21-Aug-1991     Removed magic LC_NEW_SEARCH value

**********************************************************************/

INT STRING_LIST_CONTROL::FindItem( const TCHAR * pchPrefix ) const
{
    return FindItem(pchPrefix, -1);
}

INT STRING_LIST_CONTROL::FindItem( const TCHAR * pchPrefix,
                                   INT iLastSearchResult ) const
{
    return (INT)Command( LC_MSG( FINDSTRING ),
                         (UINT)iLastSearchResult,
                         (LPARAM)pchPrefix );
}


/**********************************************************************

    NAME:       STRING_LIST_CONTROL::FindItemExact

    SYNOPSIS:   Returns the index of the precise match

    ENTRY:          psz             - pointer to string sought
                    iLastSearchResult   - index from which to search

    RETURNS:    the position of the specified string, or -1 if not found.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        10-Jun-1991 Unicode mods
        beng        01-May-1992 API changes

**********************************************************************/

INT STRING_LIST_CONTROL::FindItemExact( const TCHAR * psz ) const
{
    return FindItemExact(psz, -1);
}

INT STRING_LIST_CONTROL::FindItemExact( const TCHAR * psz,
                                        INT iLastSearchResult ) const
{
    INT iFirstMatch = FindItem( psz, iLastSearchResult );
    if ( iFirstMatch < 0 )
    {
        //  Prefix not found.  Return failure.
        //
        return -1;
    }

    INT cchLen = ::strlenf( psz );

    INT i = iFirstMatch;
    do
    {
        // We find out whether or not FindItem can find any item matching
        // the given one before the loop.  If it can't find the item,
        // we don't even enter the loop.  Since FindItem has the property
        // of always returning a non-negative index when given a string
        // which is indeed a prefix of some item in the list control,
        // regardless of how many consecutive times FindItem is called,
        // i should invariably not be negative within this loop.
        //
        UIASSERT( i >= 0 );

        // Item i has prefix pch, but matches the string pointed to by
        // pch if and only if it has the same length as pch.
        //
        if ( QueryItemLength( i ) == cchLen )
            return i;           //  exact match; return index

        i = FindItem( psz, i );
    }
    while ( i != iFirstMatch );

    return -1;      // we circled through all items with prefix pch,
                    // but none match pch exactly
}


/**********************************************************************

    NAME:       STRING_LIST_CONTROL::QueryItemText

    SYNOPSIS:   Returns the text of a given entry in the listbox

    ENTRY:
        pnls    - pointer to host NLS_STR
        i       - index into listbox

            or

        pb      - pointer to BYTE buffer
        cb      - number of BYTES available in buffer
        i       - index into listbox

    EXIT:

    RETURNS:    0 if successful

    NOTES:
        The <pch, i> version is private to the class.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        10-Jun-1991 Changed return type
        beng        21-Aug-1991 Eliminated LC_CURRENT_ITEM magic number
        beng        01-May-1992 API changes

**********************************************************************/

APIERR STRING_LIST_CONTROL::QueryItemText( NLS_STR * pnls, INT i ) const
{
    if (pnls == NULL)
        return ERROR_INVALID_PARAMETER;

    if (i < 0) // no item selected, or else invalid param
        return ERROR_NEGATIVE_SEEK;

    INT cbLen = QueryItemSize( i );
    if ( cbLen < 0 )
    {
        UIASSERT( FALSE ); // invalid list control index
        return ERROR_INVALID_TARGET_HANDLE;
    }

    BLT_SCRATCH scratch( cbLen );
    if (!scratch)
        return scratch.QueryError();

    APIERR err = QueryItemTextAux( (TCHAR*)scratch.QueryPtr(), i );
    if (err != NERR_Success)
        return err;

    return pnls->CopyFrom((TCHAR *)scratch.QueryPtr());
}

APIERR STRING_LIST_CONTROL::QueryItemText( TCHAR * pchBuffer, INT cbBuffer,
                                           INT i ) const
{
    if (pchBuffer == NULL)
        return ERROR_INVALID_PARAMETER;

    if ( i < 0 ) // no item selected, or else invalid param
        return ERROR_NEGATIVE_SEEK;

    if ( cbBuffer < QueryItemSize(i) )
        return NERR_BufTooSmall;

    return QueryItemTextAux(pchBuffer, i); // call through to private member
}

APIERR STRING_LIST_CONTROL::QueryItemTextAux(TCHAR * pchBuffer, INT i) const
{
    INT nRet = (INT)Command( ( IsCombo() ? CB_GETLBTEXT : LB_GETTEXT ),
                             (WPARAM)i,
                             (LPARAM)pchBuffer );

    return (nRet < 0) ? ERROR_INVALID_TARGET_HANDLE : NERR_Success;
}


/**********************************************************************

    NAME:       STRING_LIST_CONTROL::QueryItemLength

    SYNOPSIS:   Returns the cch (character count) of a given item

    ENTRY:      i - index of item in listbox

    EXIT:

    RETURNS:
        cch if >= 0; error if -1

    NOTES:
        This character count does not include the terminating char.
        On DBCS systems this will not correspond to the number of
        glyphs in the string.

    HISTORY:
        beng        10-Jun-1991 Created anew
        beng        21-Aug-1991 Eliminated LC_CURRENT_ITEM magic number
        beng        30-Apr-1992 API changes

**********************************************************************/

INT STRING_LIST_CONTROL::QueryItemLength( INT i ) const
{
    if (i < 0)
        return -1; // cascade errors

    // Note that these messages return a length in TCHARs
    // which does not include the terminating character.
    //
    return (INT)Command( ( IsCombo()
                           ? CB_GETLBTEXTLEN
                           : LB_GETTEXTLEN ), (UINT)i );
}


/**********************************************************************

    NAME:       STRING_LIST_CONTROL::QueryItemSize

    SYNOPSIS:   Returns the cb (byte count) of a given item,
                including the terminating character

    ENTRY:      i - index of item in listbox

    RETURNS:
        cb if >= 0; -1 if error

    NOTES:
        The character count corresponds to the value returned
        by strlen().  This is not the same as the number of
        glyphs in the string.

    HISTORY:
        rustanl     20-Nov-1990 Initially created
        beng        10-Jun-1991 Created from old QueryItemLen
        beng        21-Aug-1991 Eliminated LC_CURRENT_ITEM magic number
        beng        30-Apr-1992 API changes

**********************************************************************/

INT STRING_LIST_CONTROL::QueryItemSize( INT i ) const
{
    INT cchRet = QueryItemLength(i);     // get chars.  (handle errors)

    if ( cchRet < 0 )
        return -1;

    return (cchRet + 1) * sizeof(TCHAR); // convert to total bytes
}


/**********************************************************************

   NAME:        STRING_LISTBOX::STRING_LISTBOX

   SYNOPSIS:    constructor

   ENTRY:       OWNER_WINDOW * powin - pointer to the owner window
                CID cid - cid of the listbox

   HISTORY:
      rustanl   20-Nov-1990     Created
      DavidHov  21-Jan-1992     Added FONT member support

**********************************************************************/

STRING_LISTBOX::STRING_LISTBOX(
     OWNER_WINDOW * powin, CID cid, enum FontType font )
    : STRING_LIST_CONTROL( powin, cid, FALSE ),
      _fontListBox( font )
{
    if ( QueryError() )
        return;

    //  Note: construction should not fail if font unavailable.
    if ( ! _fontListBox.QueryError() )
        Command( WM_SETFONT, (WPARAM) _fontListBox.QueryHandle(),
                 (LPARAM) FALSE ) ;
}


/**********************************************************************

   NAME:        STRING_LISTBOX::STRING_LISTBOX

   SYNOPSIS:    constructor for control directly on the face
                of a window.

   ENTRY:       OWNER_WINDOW *    pointer to the owner window
                CID               control id
                XYPOINT           location of control in parent window
                XYDIMENSION       size of control
                ULONG             style control bits
                TCHAR *           class name
                enum FontType     font to be used

   HISTORY:
      DavidHov  21-Jan-1992     Created, since FONT member disallowed
                                default construction.

**********************************************************************/

STRING_LISTBOX::STRING_LISTBOX( OWNER_WINDOW * powin,
                                CID cid,
                                XYPOINT xy, XYDIMENSION dxy,
                                ULONG flStyle, const TCHAR * pszClassName,
                                enum FontType font )
    : STRING_LIST_CONTROL( powin, cid, FALSE, xy, dxy, flStyle, pszClassName ),
    _fontListBox( font )
{
    if ( QueryError() )
        return;

    //  Note: construction should not fail if font unavailable.
    if ( ! _fontListBox.QueryError() )
        Command( WM_SETFONT, (WPARAM) _fontListBox.QueryHandle(),
                             (LPARAM) FALSE );
}


/**********************************************************************

    NAME:       COMBOBOX::COMBOBOX

    SYNOPSIS:   Constructor for combo box control

    ENTRY:

    EXIT:

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-May-1991 Added app-window constructor
        beng        04-Oct-1991 Win32 conversion
        beng        07-Nov-1991 Error mapping
        beng        30-Apr-1992 API change; cch instead of cb

**********************************************************************/

COMBOBOX::COMBOBOX( OWNER_WINDOW * powin, CID cid, UINT cchMaxLen )
    : STRING_LIST_CONTROL( powin, cid, TRUE ) ,
      _nlsSaveValue()
{
    if ( QueryError() )
        return;

    if ( _nlsSaveValue.QueryError() )
    {
        ReportError( _nlsSaveValue.QueryError() );
        return;
    }

    if ( cchMaxLen > 0 && !SetMaxLength( cchMaxLen ))
    {
        // assume low memory (why did SetMaxLength fail?)
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
        return;
    }
}

COMBOBOX::COMBOBOX( OWNER_WINDOW * powin,
                    CID            cid,
                    UINT           cchMaxLen,
                    XYPOINT        xy,
                    XYDIMENSION    dxy,
                    ULONG          flStyle,
                    const TCHAR *  pszClassName )
    : STRING_LIST_CONTROL( powin, cid, TRUE, xy, dxy, flStyle, pszClassName ),
      _nlsSaveValue()
{
    if ( QueryError() )
        return;

    if ( _nlsSaveValue.QueryError() )
    {
        ReportError( _nlsSaveValue.QueryError() );
        return;
    }

    if ( cchMaxLen > 0 && !SetMaxLength( cchMaxLen ))
    {
        // assume low memory
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
        return;
    }
}


/*******************************************************************

    NAME:       COMBOBOX::SetMaxLength

    SYNOPSIS:   Sets a limit on the number of bytes that the text
                string contained in the combo box may be.

    ENTRY:      cchMaxLen -      Indicates the new limit, or 0 to indicate
                                "no limit"

    RETURN:     TRUE on success; FALSE otherwise

    CAVEATS:    This method should not be called any combo without
                an SLE

    HISTORY:
        rustanl     19-Mar-1991 Created
        beng        30-Apr-1992 API changes; cch instead of cb

********************************************************************/

BOOL COMBOBOX::SetMaxLength( UINT cchMaxLen )
{
    ULONG ul = (ULONG)Command( CB_LIMITTEXT, cchMaxLen );

    UIASSERT( (LONG)ul != (LONG)CB_ERR ); // called on combo w/o sle

    return (ul && ((LONG)ul != (LONG)CB_ERR));
}


/*******************************************************************

    NAME:     COMBOBOX::IsDropDown

    SYNOPSIS: Returns TRUE if the combo has the CBS_DROPDOWN style bit
              set.  IsDropDownList and IsSimple are also defined here.

    RETURNS:  Returns TRUE if the appropriate bit is set.

    NOTES:

    HISTORY:
        Johnl   02-May-1991     Created

********************************************************************/

BOOL COMBOBOX::IsDropDown() const
{
    return ( CBS_DROPDOWN ==
             (QueryStyle() & (CBS_DROPDOWN | CBS_SIMPLE | CBS_DROPDOWNLIST) ) );
}

BOOL COMBOBOX::IsDropDownList() const
{
    return ( CBS_DROPDOWNLIST ==
             (QueryStyle() & (CBS_DROPDOWN | CBS_SIMPLE | CBS_DROPDOWNLIST) ) );
}

BOOL COMBOBOX::IsSimple() const
{
    return ( CBS_SIMPLE ==
             (QueryStyle() & (CBS_DROPDOWN | CBS_SIMPLE | CBS_DROPDOWNLIST) ) );
}


/*******************************************************************

    NAME:     COMBOBOX::SaveValue

    SYNOPSIS: Saves the state of the list control and unselects the
              current item

    EXIT:     Unselected listbox

    NOTES:

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

VOID COMBOBOX::SaveValue( BOOL fInvisible )
{
    if ( !IsUserEdittable() )
    {
        STRING_LIST_CONTROL::SaveValue( fInvisible );
        return;
    }

    if ( _nlsSaveValue.QueryError() == NERR_Success )
        QueryText( &_nlsSaveValue );

    if ( _nlsSaveValue.QueryError() != NERR_Success )
    {
        DBGEOL("COMBOBOX::SaveValue - Error saving combobox string");
        _nlsSaveValue = NULL;
    }

    if ( IsSimple() && fInvisible )
        RemoveSelection();

    if ( fInvisible )
        ClearText();
}


/*******************************************************************

    NAME:     COMBOBOX::RestoreValue

    SYNOPSIS: Restores COMBOBOX after SaveValue

    ENTRY:

    EXIT:

    NOTES:    See CONTROL_VALUE for more details.

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

VOID COMBOBOX::RestoreValue( BOOL fInvisible )
{
    if ( !IsUserEdittable() )
    {
        STRING_LIST_CONTROL::RestoreValue( fInvisible );
        return;
    }

    if ( _nlsSaveValue.QueryError() == NERR_Success )
    {
        if ( fInvisible )
        {
            SetText( _nlsSaveValue );
        }

        // no, don't SelectString();
    }
}


/*******************************************************************

    NAME:      COMBOBOX::QueryEventEffects

    SYNOPSIS:  Returns one of the CVMI_* values.
               See CONTROL_VALUE for more information.

    ENTRY:

    EXIT:

    HISTORY:
        Johnl       29-Apr-1991 Created
        beng        31-Jul-1991 Renamed from QMessageInfo
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

UINT COMBOBOX::QueryEventEffects( const CONTROL_EVENT & e )
{
    switch ( e.QueryCode() )
    {
    case CBN_EDITCHANGE:
    case CBN_SELCHANGE:
        return CVMI_VALUE_CHANGE;

    /* If someone clicks on the SLT of the drop down list...
    */
    case CBN_SETFOCUS:
        // if ( IsDropDownList() )
        return CVMI_VALUE_CHANGE | CVMI_RESTORE_ON_INACTIVE;

    case CBN_DROPDOWN:
        return CVMI_VALUE_CHANGE | CVMI_RESTORE_ON_INACTIVE;

    default:
        break;
    }

    return CVMI_NO_VALUE_CHANGE;
}


/**********************************************************

    NAME:       COMBOBOX::SelectString

    SYNOPSIS:   Selects the string in the combo box.

    HISTORY:
        kevinl          19-Nov-1991     Created/stolen from Gregj

**********************************************************/

VOID COMBOBOX::SelectString()
{
#if defined(WIN32)
    Command( CB_SETEDITSEL, 0, MAKELPARAM(0,-1) );
#else
    Command( CB_SETEDITSEL, 0, MAKELONG( 0, 0x7fff ));
#endif
}


/**********************************************************

    NAME:       LIST_CONTROL::RemoveSelection

    SYNOPSIS:   Removes the hi-lite bar from the current selection

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        beng        21-Aug-1991     Removed to .cxx file

**********************************************************/

VOID LIST_CONTROL::RemoveSelection()
{
    SelectItem( -1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltlbsel.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltlbsel.cxx
    BLT listbox selection control classes: implementation

    FILE HISTORY:
	beng	    07-Aug-1991     Created

*/

#include "pchblt.hxx"   // Precompiled header

/*******************************************************************

    NAME:	LB_SELECTION::LB_SELECTION

    SYNOPSIS:	Constructor

    ENTRY:	Pointer to host listbox

    EXIT:	Constructed

    NOTES:

    HISTORY:
	beng	    07-Aug-1991     Created

********************************************************************/

LB_SELECTION::LB_SELECTION( LISTBOX* plb )
    : _plb(plb),
      _cilbSelected(0),
      _pilbSelected(NULL)
{
    if (plb->IsMultSel())
    {
	_cilbSelected = plb->QuerySelCount();
	_pilbSelected = new INT[_cilbSelected];
	if (_pilbSelected == NULL)
	{
	    ReportError(ERROR_NOT_ENOUGH_MEMORY;
	    return;
	}
	plb->QuerySelItems(_cilbSelected, _pilbSelected);
    }
    else
    {
	INT ilbSelected = plb->QueryCurrentItem();
	if (ilbSelected != -1)
	{
	    _cilbSelected = 1;
	    _pilbSelected = new INT;
	    _pilbSelected[0] = ilbSelected;
	}
    }
}


/*******************************************************************

    NAME:	LB_SELECTION::~LB_SELECTION

    SYNOPSIS:	Destructor

    NOTES:

    HISTORY:
	beng	    14-Aug-1991     Created

********************************************************************/

LB_SELECTION::~LB_SELECTION()
{
    if (_cilbSelected > 0)
	delete[_cilbSelected] _pilbSelected;
}


/*******************************************************************

    NAME:	LB_SELECTION::QueryCount

    SYNOPSIS:	Returns the number of items in the selection

    NOTES:

    HISTORY:
	beng	    14-Aug-1991     Created

********************************************************************/

UINT LB_SELECTION::QueryCount()
{
    return _cilbSelected;
}


/*******************************************************************

    NAME:	LB_SELECTION::Select

    SYNOPSIS:	Add a line in the listbox to the selection

    ENTRY:	iIndex - index into the listbox

    EXIT:

    NOTES:

    HISTORY:
	beng	    14-Aug-1991     Created

********************************************************************/

VOID LB_SELECTION::Select( INT iIndex )
{
    plb->ChangeSel(iIndex, TRUE);
}


/*******************************************************************

    NAME:	LB_SELECTION::Unselect

    SYNOPSIS:	Remove a line in the listbox from the selection

    ENTRY:	iIndex - index into the listbox

    EXIT:	Line named is no longer selected.

    NOTES:

    HISTORY:

********************************************************************/

VOID LB_SELECTION::Unselect( INT iIndex )
{
    plb->ChangeSel(iIndex, FALSE);
}


/*******************************************************************

    NAME:	LB_SELECTION::UnselectAll

    SYNOPSIS:	Render the listbox without selection

    EXIT:	Nothing in the listbox is selected.
		The selection is empty.

    NOTES:

    HISTORY:

********************************************************************/

VOID LB_SELECTION::UnselectAll()
{
    for (INT iilb = 0; iilb < _cilbSelected; iilb++)
	plb->ChangeSel(_pilbSelected[iilb], FALSE);
}


/*******************************************************************

    NAME:	LB_SELECTION::AddItem

    SYNOPSIS:	Adds an item to the listbox, leaving it selected.

    ENTRY:	plbi	- pointer to listbox item for new line

    EXIT:	Line added to listbox.
		Line is selected.


    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

INT LB_SELECTION::AddItem(const LBI* plbi)
{

}


/*******************************************************************

    NAME:	LB_SELECTION::DeleteAllItems

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

VOID LB_SELECTION::DeleteAllItems()
{

}


/*******************************************************************

    NAME:	ITER_LB::ITER_LB

    SYNOPSIS:	Constructor

    ENTRY:	Several forms exist; may take any one of

	plb - pointer to source listbox.  Resulting iterator will
	      count all items in listbox

	psel - pointer to listbox selection.  Iterator will count
	       all items in selection

	iter - another listbox iterator.  Iterator will count
	       whatever the source iterator counts, and will do
	       so from the last point of the source iterator.

    EXIT:	Constructed

    NOTES:

    HISTORY:

********************************************************************/

ITER_LB::ITER_LB(const BLT_LISTBOX * plb)
{

}


ITER_LB::ITER_LB(const LB_SELECTION * psel)
{

}


ITER_LB::ITER_LB(const ITER_LB & iter)
{

}


/*******************************************************************

    NAME:	ITER_LB::Reset

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

VOID ITER_LB::Reset()
{

}


/*******************************************************************

    NAME:	ITER_LB::Next

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

LBI* ITER_LB::Next()
{

}


/*******************************************************************

    NAME:	ITER_LB::DeleteThis

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

VOID ITER_LB::DeleteThis()
{

}


/*******************************************************************

    NAME:	ITER_LB::UnselectThis

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

VOID ITER_LB::UnselectThis()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltlbi.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltlbi.cxx
    BLT owner-draw listboxes: implementation of owner-draw methods

    FILE HISTORY:
        RustanL     21-Feb-1991 Moved classes from bltlb.cxx
        rustanl     22-Mar-1991 Rolled in code review changes
                                from CR on 20-Mar-1991, attended by
                                JimH, GregJ, Hui-LiCh, RustanL.
        gregj       08-Apr-1991 Reintegrating caching listbox
        beng        14-May-1991 Exploded blt.hxx into components
        gregj       17-May-1991 Return correct error code to GUILTT
        beng        20-May-1991 Added OnDeleteItem, OnCompareItem
        beng        07-Nov-1991 Excised 2-pane listbox support
        beng        21-Apr-1992 BLT_LISTBOX -> LISTBOX
        Yi-HsinS    10-Dev-1992 Added support for variable size LBI in listbox
*/

#include "pchblt.hxx"   // Precompiled header

#if defined(TRACE)
// Trace methods

DBGSTREAM & operator << (DBGSTREAM &out, const RECT &rect)
{
    out << TCH('(') << rect.top  << SZ(", ") << rect.bottom << SZ(", ")
               << rect.left << SZ(", ") << rect.right  << TCH(')') ;

    return out;
}

#endif

void MLTextPaint( HDC hdc, const TCHAR * pch, const RECT * prect );

/*******************************************************************

    NAME:       DTE::QueryLeftMargin

    SYNOPSIS:   Returns the amount of space that a DTE desires
                to be left blank to its left.

    RETURNS:    The said left margin

    NOTES:
        This is a virtual member function.

        The return value of this method is used as follows:

        A display table calculates an original rectangle
        based on the column width of the current column

        The display table calls this method to find the
        left margin

        The left margin is added to the left margin of the
        original rectangle.  This creates the clipping
        rectangle.  (Well, almost.  Remember that DTE's
        are responsible for not drawing outside the
        rectangle passed to their Paint methods.)

        The clipping rectangle is passed to the DTE's
        Paint method.

    HISTORY:
        rustanl     22-Jul-1991     Created

********************************************************************/

UINT DTE::QueryLeftMargin() const
{
    return DISP_TBL_COLUMN_DELIM_SIZE;
}


/**********************************************************************

    NAME:       DM_DTE::DM_DTE

    SYNOPSIS:   Construct display-map DTE

    HISTORY:
        rustanl     21-Feb-1991     Creation

**********************************************************************/

DM_DTE::DM_DTE( DISPLAY_MAP * pdm )
    : _pdm( pdm )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( pdm != NULL );
    UIASSERT( pdm->QueryError() == NERR_Success );
}

DM_DTE::DM_DTE()
    : _pdm( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    // Note: this form of the ctor is protected.  When used, the ctor
    // of the derived class must call SetPdm to properly complete this
    // object.
}


/**********************************************************************

    NAME:       DM_DTE::SetPdm

    SYNOPSIS:   Set display map for semi-constructed DTE

    ENTRY:      pdm - pointer to display map

    HISTORY:
        rustanl     21-Feb-1991     Creation

**********************************************************************/

VOID DM_DTE::SetPdm( DISPLAY_MAP * pdm )
{
    //  This is a protected method intended to be used with the protected
    //  constructor.  See it for more info.

    UIASSERT( pdm != NULL );
    UIASSERT( pdm->QueryError() == NERR_Success );
    _pdm = pdm;
}


/**********************************************************************

    NAME:       DM_DTE::Paint

    SYNOPSIS:   Render a display-map DTE in the listbox

    ENTRY:      hdc     - display context for screen
                prect   - pointer to rectangle of current line

    NOTES:
        This is a virtual member function.

    HISTORY:
        rustanl     21-Feb-1991 Creation
        beng        10-Jul-1991 Centers its bitmap in the line
        beng        04-Oct-1991 Const parms
        beng        07-Nov-1991 Unsigned widths
        beng        15-Jun-1992 Call through to DISPLAY_MAP::Paint

**********************************************************************/

VOID DM_DTE::Paint( HDC hdc, const RECT * prect ) const
{
    if ( _pdm == NULL )
        return;

    // Center bitmap in line.  Otherwise it appears to cling
    // to the top of the listbox row.
    //
    // CODEWORK: Calculate this and cache it in a persistent place.
    //
    const UINT cyHeight = prect->bottom - prect->top + 1;
    UINT dyCentering = 0;
    if ( NETUI_IsDBCS() )
    {
        // When System12Pt, BitmapHeight is larger than Listbox Height.
        const UINT lHeight = _pdm->QueryHeight();
        if( cyHeight > lHeight )
        {
            dyCentering = (cyHeight - lHeight) / 2;
        }
    }
    else
    {
        dyCentering = (cyHeight - _pdm->QueryHeight()) / 2;
    }

    _pdm->Paint(hdc, prect->left, prect->top+dyCentering);
}


/**********************************************************************

    NAME:       DM_DTE::AppendDataTo

    SYNOPSIS:   Returns information for GUILTT

    ENTRY:      pnlsOut - destination string

    EXIT:       Recipient string has appended to it a string rep of DM ID#

    RETURNS:    Error code

    NOTES:
        This is a virtual member function.

    HISTORY:
        gregj       01-May-1991 Created
        beng        23-Oct-1991 Win32 conversion
        beng        05-Mar-1992 Unicode fix
        beng        01-Jun-1992 GUILTT changes

**********************************************************************/

APIERR DM_DTE::AppendDataTo( NLS_STR * pnlsOut ) const
{
    DEC_STR nlsFormat((UINT)(_pdm->QueryID()));
    if (!nlsFormat)
        return nlsFormat.QueryError();

    return pnlsOut->Append(nlsFormat);
}


/*******************************************************************

    NAME:       DM_DTE::QueryDisplayWidth

    SYNOPSIS:   Returns the width (including left margin) that the DTE
                will require in order to be displayed in full

    RETURNS:    Said width

    HISTORY:
        rustanl     03-Sep-1991 Created
        beng        07-Nov-1991 Unsigned widths

********************************************************************/

UINT DM_DTE::QueryDisplayWidth() const
{
    UIASSERT( _pdm != NULL );

    return QueryLeftMargin() + _pdm->QueryWidth();
}


/**********************************************************************

    NAME:       DMID_DTE::DMID_DTE

    SYNOPSIS:   Construct DTE from a DMID (as opposed to a pre-existing DM)

    ENTRY:      dmid - ID of display map

    EXIT:

    NOTES:
        This DTE is unusual in that it may fail construction.  It
        forces all DTEs to inherit from BASE.

    HISTORY:
        rustanl     21-Feb-1991     Creation
        beng        10-Jul-1991     Add error checking for DISPLAY_MAP

**********************************************************************/

DMID_DTE::DMID_DTE( DMID dmid )
    : _dm( dmid )
{
    if (!_dm)
    {
        ReportError(_dm.QueryError());
        return;
    }

    SetPdm( &_dm );
}


/**********************************************************************

    NAME:       STR_DTE::AppendDataTo

    SYNOPSIS:   Returns information for GUILTT

    ENTRY:      pnlsOut - a destination string

    EXIT:       DTE's string is appended to the recipient string

    RETURNS:    Error code

    NOTES:
        This is a virtual member function.

    HISTORY:
        gregj       01-May-1991 Created
        beng        04-Oct-1991 Win32 conversion; Unicode fix
        beng        05-Mar-1992 Slight correction
        beng        01-Jun-1992 GUILTT changes

**********************************************************************/

APIERR STR_DTE::AppendDataTo( NLS_STR *pnlsOut ) const
{
    return pnlsOut->Append(_pch);
}


/**********************************************************************

    NAME:       STR_DTE::Paint

    SYNOPSIS:   Paint a text-only listbox element

    ENTRY:

    EXIT:

    NOTES:
        This is a virtual member function.

    HISTORY:
        rustanl     21-Feb-1991 Creation
        beng        20-May-1991 _pch element made const
        beng        10-Jul-1991 Centers text within line; remove
                                bogus xOrigin parm
        beng        04-Oct-1991 Const parms
        beng        07-Nov-1991 Unsigned width
        beng        05-May-1992 API changes
        beng        18-May-1992 Work around 1.265 bug
        Yi-HsinS    10-Dec-1992 Delete work around 1.265 bug

**********************************************************************/

VOID STR_DTE::Paint( HDC hdc, const RECT * prect ) const
{
    if ( _pch == NULL )
        return;

    DEVICE_CONTEXT dc( hdc );

    // Center string in line.  Otherwise it appears to cling
    // to the top of the listbox row.
    //
    // CODEWORK: Cache dyCentering - too expensive to calc each time.
    //
    UINT cyHeight = prect->bottom - prect->top + 1;

    // Centering delta must be signed, since it can adjust the top of
    // the draw rectangle either way.
    //
    INT dyCentering = ((INT)cyHeight - dc.QueryFontHeight()) / 2;

    BOOL fSuccess = dc.TextOut( _pch, ::strlenf(_pch),
                                prect->left, prect->top + dyCentering,
                                prect );

#if defined(DEBUG)
    if (!fSuccess)
    {
        APIERR err = BLT::MapLastError(ERROR_GEN_FAILURE);
        DBGOUT("BLT: TextOut in LB failed, err = " << err);
    }
#endif
}

/**********************************************************************

    NAME:       MULTILINE_STR_DTE::Paint

    SYNOPSIS:   Paint a multiline text-only listbox element

    ENTRY:

    EXIT:

    NOTES:
        This is a virtual member function.

    HISTORY:
        Yi-HsinS    10-Dec-1992 Created

**********************************************************************/

VOID MULTILINE_STR_DTE::Paint( HDC hdc, const RECT * prect ) const
{
    MLTextPaint( hdc, QueryPch(), prect);
}

/**********************************************************************

    NAME:       COUNTED_STR_DTE::Paint

    SYNOPSIS:   Paint a text-only listbox element

    NOTES:
        This is a virtual member function.

    HISTORY:
        KeithMo         15-Dec-1992     Created

**********************************************************************/

VOID COUNTED_STR_DTE::Paint( HDC hdc, const RECT * prect ) const
{
    if ( QueryPch() == NULL )
        return;

    DEVICE_CONTEXT dc( hdc );

    // Center string in line.  Otherwise it appears to cling
    // to the top of the listbox row.
    //
    // CODEWORK: Cache dyCentering - too expensive to calc each time.
    //
    UINT cyHeight = prect->bottom - prect->top + 1;

    // Centering delta must be signed, since it can adjust the top of
    // the draw rectangle either way.
    //
    INT dyCentering = ((INT)cyHeight - dc.QueryFontHeight()) / 2;

    BOOL fSuccess = dc.TextOut( QueryPch(), QueryCount(),
                                prect->left, prect->top + dyCentering,
                                prect );

#if defined(DEBUG)
    if (!fSuccess)
    {
        APIERR err = BLT::MapLastError(ERROR_GEN_FAILURE);
        DBGOUT("BLT: TextOut in LB failed, err = " << err);
    }
#endif
}

/**********************************************************************

    NAME:       OWNER_DRAW_STR_DTE::Paint

    SYNOPSIS:   Paint a text-only listbox element

    ENTRY:

    EXIT:

    NOTES:
        This is a virtual member function.

    HISTORY:
        Yi-HsinS    23-Dec-1992 Created

**********************************************************************/

VOID OWNER_DRAW_STR_DTE::Paint( HDC hdc, const RECT * prect ) const
{
    MLTextPaint(hdc, QueryPch(), prect);
}

/**********************************************************************

    NAME:       OWNER_DRAW_DMID_DTE::Paint

    SYNOPSIS:   Paint a display map centered according to _nDy

    ENTRY:

    EXIT:

    NOTES:
        This is a virtual member function.

    HISTORY:
        Yi-HsinS    23-Dec-1992 Created

**********************************************************************/

VOID OWNER_DRAW_DMID_DTE::Paint( HDC hdc, const RECT * prect ) const
{
    DISPLAY_MAP *pdm = QueryDisplayMap();

    pdm->Paint(hdc, prect->left, prect->top+_nDy );
}

/**********************************************************************

    NAME:       OWNER_DRAW_MULTILINE_STR_DTE::Paint

    SYNOPSIS:   Paint a multiline text-only listbox element according to _nDy

    ENTRY:

    EXIT:

    NOTES:
        This is a virtual member function.

    HISTORY:
        Yi-HsinS    23-Dec-1992 Created

**********************************************************************/

VOID OWNER_DRAW_MULTILINE_STR_DTE::Paint( HDC hdc, const RECT * prect ) const
{
    MLTextPaint(hdc, QueryPch(), prect);
}

/**********************************************************************

    NAME:       ::MLTextPaint

    SYNOPSIS:   Multi-Line text paint function.  Centers the text on the given
                line.

    NOTES:

    HISTORY:
        Johnl     10-Jun-1994    Created

**********************************************************************/

void MLTextPaint( HDC hdc, const TCHAR * pch, const RECT * prect )
{
    if ( pch == NULL )
        return;

    ALIAS_STR nls( pch );
    DEVICE_CONTEXT dc(hdc);

    // Calculate the height of the rect
    INT cyHeight = prect->bottom - prect->top + 1;

    RECT rect = *prect;

    // Calculate the height of the given string
    INT nHeight = dc.DrawText( nls, &rect,
                  DT_CALCRECT | DT_LEFT | DT_EXPANDTABS | DT_NOPREFIX );

    // Center string in line only if the rect is big enough.
    // Otherwise it appears to cling to the top of the listbox row.

    if ( cyHeight > nHeight )
        ((RECT *) prect)->top += ( cyHeight - nHeight ) / 2;

    dc.DrawText( nls, (RECT *) prect,
                 DT_LEFT | DT_EXPANDTABS | DT_NOPREFIX );
}

/**********************************************************************

    NAME:       DISPLAY_TABLE::DISPLAY_TABLE

    SYNOPSIS:   Construct table of columns

    ENTRY:      cdxColumns    - number of columns
                pdxColWidth - array of widths

    HISTORY:
        rustanl     21-Feb-1991 Creation
        beng        07-Nov-1991 Unsigned width

**********************************************************************/

DISPLAY_TABLE::DISPLAY_TABLE( UINT cdxColumns, const UINT * pdxColWidth )
    : _cdx(cdxColumns),
      _pdxColWidth(pdxColWidth)
{
    ASSERT( cdxColumns <= MAX_DISPLAY_TABLE_ENTRIES );

    for ( UINT i = 0; i < _cdx; i++ )
        _apdte[ i ] = NULL;
}


/*******************************************************************

    NAME:       DISPLAY_TABLE::CalcColumnWidths

    SYNOPSIS:   This method builds the column width table
                used by the LBI::Paint() method.

    ENTRY:
        adx             - An array of integers where the
                          column width table will be stored.
        cdx             - the number of columns in the listbox.
        pwndOwner       - pointer to the window owning the listbox.
        cidListbox      - The CID of the BLT_LISTBOX.
        fHaveIcon       - set if the listbox contains an icon
                          in its first column.

    EXIT:
        The column width table is calculated and stored in adx[].

    RETURNS:
        Error code.  NERR_Success if all's well.

    NOTES:
        This is a static member function.

        This code makes certain assumptions about the CID
        ordering for the target listbox.  The cidListbox parameter
        specifies the CID of the listbox.  Each listbox column
        must have a static text header.  These static text
        control windows must have sequential CIDs starting with
        cidListbox+1.

    HISTORY:
        KeithMo     ??-???-???? Created for the Server Manager.
        KeithMo     28-Aug-1991 Globbed into the SERVER_UTILITY class.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.
        beng        08-Nov-1991 Adapted from OPEN_LBOX_BASE::
                                BuildColumnWidthTable, and integrated
                                into BLT

********************************************************************/

APIERR DISPLAY_TABLE::CalcColumnWidths( UINT *        adx,
                                        UINT          cdx,
                                        OWNER_WINDOW *pwndOwner,
                                        CID           cidListbox,
                                        BOOL          fHaveIcon)
{
    ASSERT( adx != NULL );
    ASSERT( pwndOwner != NULL);

    //  If have icon, record the starting x position of the listbox.
    //  and use this as reference. If no icon we use the first column
    //  as reference.

    CID cidOrigin = fHaveIcon ? cidListbox : cidListbox + 1;
    HWND hwndOwner = pwndOwner->QueryHwnd();
    HWND hwndItem = ::GetDlgItem( hwndOwner, cidOrigin );
    BOOL bMirrordOwner = (GetWindowLongPtr(hwndOwner, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) != 0;
    if (hwndItem == NULL)
    {
        DBGEOL("Can't find control " << cidOrigin);
        return BLT::MapLastError(ERROR_GEN_FAILURE);
    }

    //  This will be used during several invocations of
    //  GetWindowRect().  Remember that GetWindowRect()
    //  returns *screen* coordinates!

    RECT rect;
    ::GetWindowRect( hwndItem, &rect );

    // If the owner is mirrored use Window coordinates!
    if (bMirrordOwner)
    {
        MapWindowPoints(NULL, hwndOwner, (LPPOINT)&rect, 2);
    }

    INT xPrevious = rect.left;
    CID cidNext = cidOrigin + 1;

    //  Now, scan through the cid array.  For each cid, determine
    //  the distance between the current position and the cid window.

    for ( UINT i = 0; i < cdx - 1; i++ )
    {
        //  Retrieve the starting x position of the current control
        //  window.

        hwndItem = ::GetDlgItem( hwndOwner, cidNext++ );
        UIASSERT( hwndItem != NULL );
        ::GetWindowRect( hwndItem, &rect );
        if (bMirrordOwner)
        {
            MapWindowPoints(NULL, hwndOwner, (LPPOINT)&rect, 2);
        }
        INT xCurrent = rect.left;

        //  The delta between the current position and the previous
        //  position is the current column width.

        adx[i] = xCurrent - xPrevious;

        //  The current position will become our next previous position.

        xPrevious = xCurrent;
    }

    //  The last column always has a value of COL_WIDTH_AWAP
    //  (As Wide As Possible).

    adx[i] = COL_WIDTH_AWAP;

    return NERR_Success;
}


/**********************************************************************

    NAME:       DISPLAY_TABLE::Paint

    SYNOPSIS:   Paints the COLUMN_DISPLAY_TABLE

    ENTRY:      plb -       Pointer to listbox in which listbox item
                            is to be painted.  If not in a listbox
                            (say, a column header), pass NULL.

                hdc -       Device context handle to be used
                prect -     Pointer to rectangle to be used for paint
                            (is usually the entire client rectangle)
                pGUILTT -   Pointer to GUILTT information (listbox
                            painting only)

    EXIT:

    NOTES:
        The first version of Paint calls the other after
        handling GUILTT support.

    HISTORY:
        rustanl     21-Feb-1991 Creation
        gregj       08-Apr-1991 Added two-column listbox support
        gregj       01-May-1991 Added GUILTT support
        rustanl     22-Jul-1991 Added generic paint support (for painting
                                areas other than listbox items)
        beng        04-Oct-1991 Const parms
        beng        07-Nov-1991 Removed 2-pane support
        beng        14-Feb-1992 Unicode fix
        beng        21-Apr-1992 BLT_LISTBOX -> LISTBOX
        beng        01-Jun-1992 GUILTT changes

**********************************************************************/

VOID DISPLAY_TABLE::Paint( LISTBOX *     plb,
                           HDC           hdc,
                           const RECT *  prect,
                           GUILTT_INFO * pginfo ) const
{
    // If this is a fake paint call from a WM_GUILTT message,
    // walk the display table storing information in the buffer.
    // This is done before the UIASSERTs below because "hdc", in
    // particular, will be NULL in this case.

    if (pginfo != NULL)
    {
        NLS_STR * pnlsOut = pginfo->pnlsOut;
        APIERR err = pnlsOut->QueryError();

        if (err != NERR_Success)
        {
            pginfo->errOut = err;
            return;
        }

        ASSERT(pnlsOut->strlen() == 0); // Should be a fresh string
        ASSERT(pginfo->errOut == NERR_Success);

        // Process each entry, breaking out on a failure.
        //
        for ( UINT i = 0; i < _cdx; i++ )
        {
            DTE * pdte = _apdte[ i ];
            if ( pdte == NULL )
                continue;

            err = pdte->AppendDataTo(pnlsOut);
            if (err != NERR_Success)
            {
                pginfo->errOut = err;
                break;
            }

            if (i < _cdx - 1) // Fields are tab-separated
            {
                err = pnlsOut->AppendChar(TCH('\t'));
                if (err != NERR_Success)
                {
                    pginfo->errOut = err;
                    break;
                }
            }
        }

        return;
    }

    // Call through to other version to do the painting work

    Paint(plb, hdc, prect);
}


VOID DISPLAY_TABLE::Paint( LISTBOX *     plb,
                           HDC           hdc,
                           const RECT *  prect ) const
{
    UIASSERT( hdc != NULL );
    UIASSERT( prect != NULL );

    // Paint each column.
    // Note that coordinates are signed, while displacements are unsigned.

    UINT dxScrollHorizontal = (plb == NULL) ? 0 : plb->QueryScrollPos();

    INT xLim = prect->right+dxScrollHorizontal;
    INT xLeft = prect->left+dxScrollHorizontal;

    for ( UINT i = 0; i < _cdx; i++ )
    {
        // The x coordinate of the next column is the current column's
        // x coordinate plus the width of the current column.  The width of
        // the current column is specified by a value in the _pdxColWidth
        // array.  The last column always stretches to the end of the pane,
        // regardless of its given column width.  The calculation of
        // xNextLeft is modified accordingly for these columns.

        INT xNextLeft;

        if ( i == _cdx - 1 )
            xNextLeft = xLim;
        else
            xNextLeft = xLeft + _pdxColWidth[ i ];

        // Retrieve a pointer to the display table entry of the current
        // column.

        DTE * pdte = _apdte[i];

        // Note: the left margin is taken from *within* the column.
        // This way, a client can easily use 0-width columns.

        if ( pdte != NULL )
            xLeft += pdte->QueryLeftMargin();

        // If this column falls outside the right edge of the given rect,
        // all remaining columns will, too.  Therefore, simply break out
        // of the loop.

        if ( xLeft >= xLim )
            break;

        // If the column has any contents, and it is visible somewhere
        // within the window, paint it.

        if ( pdte != NULL && xLeft < xNextLeft )
        {
            RECT rect;
            rect.left = xLeft;
            rect.top = prect->top;
            rect.right = xNextLeft;
            rect.bottom = prect->bottom;

            if ( ::RectVisible ( hdc, &rect ) )
                pdte->Paint( hdc, &rect );
        }

        xLeft = xNextLeft;
    }
}


/**********************************************************************

    NAME:       DISPLAY_TABLE::operator[]

    SYNOPSIS:   Return an element in the display table

    ENTRY:      i - index within the table

    RETURNS:    Pointer to a DTE (display table element)

    HISTORY:
        rustanl     21-Feb-1991 Creation
        beng        07-Nov-1991 Unsigned arg

**********************************************************************/

DTE * & DISPLAY_TABLE::operator[]( UINT i )
{
    UIASSERT( i < _cdx );

    return _apdte[ i ];
}


/**********************************************************************

    NAME:       LBI::LBI

    SYNOPSIS:   Constructor for listbox-item base

    NOTES:
        This base implementation does nothing

    HISTORY:
        rustanl     21-Feb-1991 Creation

**********************************************************************/

LBI::LBI()
{
    //  do nothing
}


/**********************************************************************

    NAME:       LBI::~LBI

    SYNOPSIS:   Destructor for listbox-item base

    NOTES:
       The LBI destructor is virtual.

    HISTORY:
       rustanl     21-Feb-1991 Creation

**********************************************************************/

LBI::~LBI()
{
    //  do nothing
}

/**********************************************************************

    NAME:       LBI::CalcHeight

    SYNOPSIS:   Called to find out the height of the LBI.

    ENTRY:      nSingleLineHeight - Contains the height of a single-line item

    RETURN:

    NOTES:
        This is a virtual method.
        This is the default implementation of CalcHeight.
        All LBIs contained in owner draw variable listbox/combo needs
        to redefine this method if they have items more than one line.

    HISTORY:
        Yi-HsinS     10-Dec-1992     Created

**********************************************************************/

UINT LBI::CalcHeight( UINT nSingleLineHeight )
{
    return nSingleLineHeight;
}

/**********************************************************************

    NAME:       LBI::Paint

    SYNOPSIS:   Paint a listbox entry

    ENTRY:
        plb     - pointer to host listbox
        hdc     - current hdc
        prect
        pGUILTT - pointer to testing-information output buffer.
                  NULL if not testing

    EXIT:

    NOTES:

    HISTORY:
        rustanl     21-Feb-1991 Creation
        gregj       01-May-1991 Added GUILTT support
        beng        04-Oct-1991 Const parms
        beng        21-Apr-1992 BLT_LISTBOX -> LISTBOX

**********************************************************************/

VOID LBI::Paint( LISTBOX *     plb,
                 HDC           hdc,
                 const RECT *  prect,
                 GUILTT_INFO * pginfo ) const
{
    //  This is the default implementation of the virtual LBI::Paint
    //  method.  It does nothing.

    UNREFERENCED( plb );
    UNREFERENCED( hdc );
    UNREFERENCED( prect );
    UNREFERENCED( pginfo );
}


/**********************************************************************

    NAME:       LBI::Compare

    SYNOPSIS:   Called to compare two LBI items.

       LBI subclasses are responsible for casting the plbi parameter to
       the appropriate type.  Since several LBI subclassed objects may
       be found in the same listbox, BLT cannot guarantee that the
       parameter is of the same type as the object which is being called.
       BLT will guarantee, however, that the Compare method will only get
       called for objects that are indeed in the same listbox (or an object
       passed to the Find or AddItemIdemp methods of the same listbox).

    ENTRY:

    RETURN:
       The return value of Compare is similar to that of strcmp.  It should
       be:
          negative    if *this < *plbi
          0          if *this == *plbi
          positive    if *this > *plbi

    NOTES:
        This is a virtual method.

    HISTORY:
        rustanl     21-Feb-1991     Creation

**********************************************************************/

INT LBI::Compare( const LBI * plbi ) const
{
    //  This is the default implementation of Compare.  Since the base LBI
    //  object does not contain any private members, this method has nothing
    //  to compare.  Instead, simply return 0.

    UNREFERENCED( plbi );

    return 0;
}


/**********************************************************************

    NAME:       LBI::Compare_HAWforHawaii

    SYNOPSIS:   Called to compare an LBI item to a text prefix string.

       This method is ordinarily called only by
       BLT_LISTBOX::CD_Char_HAWforHawaii, which uses it to check whether
       a particular LBI matches a text prefix.  Listboxes which use
       CD_Char_HAWforHawaii are expected to redefine this method in
       the appropriate LBI class(es).

    ENTRY:

    RETURN:
       The return value of Compare is similar to that of strcmp.  It should
       be:
          negative    if *this < *plbi
          0          if *this == *plbi
          positive    if *this > *plbi

    NOTES:
        This is a virtual method.

    HISTORY:
        jonn        05-Aug-1992     HAW-for-Hawaii support

**********************************************************************/

INT LBI::Compare_HAWforHawaii( const NLS_STR & nls ) const
{
    //  This is the default implementation of Compare_HAwforHawaii.
    // Since the base LBI object does not contain any private members,
    // this method has nothing to compare.  Instead, simply return 0.

    UNREFERENCED( nls );

    TRACEEOL(   SZ("NETUI: Default LBI::Compare_HAWforHawaii(\"")
             << nls
             << SZ("\") called") );

    return 0;
}


/**********************************************************************

    NAME:       LBI::QueryLeadingChar

    SYNOPSIS:   Returns the leading character of the listbox item.
                This enables short-cut keys in the listbox.

    RETURN:     The leading character of the listbox item.

    NOTES:
        This is a virtual method which may be replaced in subclasses.

        CODEWORK - need to generalize

    HISTORY:
        rustanl     21-Feb-1991     Creation
        beng        20-May-1991     Returns WCHAR

**********************************************************************/

WCHAR LBI::QueryLeadingChar() const
{
    return TCH('\0');
}


/*******************************************************************

    NAME:       LBI::OnDeleteItem

    SYNOPSIS:   Response to WM_DELETEITEM message

    ENTRY:      wParam, lParam - as per winproc

    EXIT:

    NOTES:
        This is a static member function.

        The WM_DELETEITEM message may be sent during the DestroyWindow
        call.  At this point, DIALOG_WINDOW::HwndToWinPtr would always
        return NULL; fortunately we keep enough information around
        to clean up w/o that pointer.

    HISTORY:
        beng        20-May-1991     Created (from BltDlgProc code)
        kevinl      04-Nov-1991     Added the ability to override the
                                    destruction of the LBI.
        KeithMo     29-Oct-1992     Sanity check pointer before deleting.

********************************************************************/

VOID LBI::OnDeleteItem( WPARAM wParam, LPARAM lParam )
{
    UNREFERENCED(wParam);

    //  This message should only be called for deleting LBI objects.
    //
    UIASSERT( (((DELETEITEMSTRUCT *)lParam)->CtlType == ODT_LISTBOX) ||
              (((DELETEITEMSTRUCT *)lParam)->CtlType == ODT_COMBOBOX)  );

    //  Note.  Although the listbox AddItem methods attempt
    //  to ensure that NULL is never added as a listbox item,
    //  this function must not assume that plbi is non-NULL.
    //  (See LISTBOX::DeleteAllItems for more info).
    //  Either way, this doesn't really matter here, because
    //  'delete'-ing a NULL pointer is always valid (even for
    //  a pointer to a type with a virtual destructor, as is
    //  the case here).
    //
    LBI * plbi = (LBI *)((DELETEITEMSTRUCT *)lParam)->itemData;

    if( HIWORD( (ULONG_PTR)plbi ) != 0 )
    {
        if ( plbi->IsDestroyable() )
             delete plbi;
    }
}


/*******************************************************************

    NAME:       LBI::IsDestroyable

    SYNOPSIS:   This is called by LBI::OnDeleteItem.  This method
                returns a BOOL.  If TRUE is returned, then the
                LBI is deleted.  Otherwise, the LBI is not destructed.

    HISTORY:
        kevinl      04-Nov-1991     Created.

********************************************************************/

BOOL LBI::IsDestroyable()
{
    return TRUE;
}


/*******************************************************************

    NAME:       LBI::OnCompareItem

    SYNOPSIS:   Response to WM_COMPAREITEM message

    ENTRY:      wParam, lParam - as per winproc

    EXIT:

    RETURNS:

    NOTES:
        This is a static member function.

    HISTORY:
        beng        20-May-1991     Created (from BltDlgProc code)

********************************************************************/

INT LBI::OnCompareItem( WPARAM wParam, LPARAM lParam )
{
    UNREFERENCED(wParam);

    //  This message should only be called for comparing LBI objects.
    //
    UIASSERT( (((DELETEITEMSTRUCT *)lParam)->CtlType == ODT_LISTBOX) ||
              (((DELETEITEMSTRUCT *)lParam)->CtlType == ODT_COMBOBOX)  );

    LBI * plbi0 = (LBI *)((COMPAREITEMSTRUCT *)lParam)->itemData1;
    LBI * plbi1 = (LBI *)((COMPAREITEMSTRUCT *)lParam)->itemData2;

    if ( plbi0 == NULL )
        return -1;
    if ( plbi1 == NULL )
        return 1;

    return plbi0->Compare( plbi1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltlb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltlb.cxx
    BLT listbox control classes: implementation

    FILE HISTORY:
        RustanL     13-Feb-1991 Created
        RustanL     19-Feb-1991 Added meat for drawing
        rustanl     22-Mar-1991 Rolled in code review changes
                                from CR on 20-Mar-1991, attended by
                                JimH, GregJ, Hui-LiCh, RustanL.
        gregj       08-Apr-1991 Reintegrated caching listbox
        gregj       01-May-1991 Added GUILTT support
        beng        14-May-1991 Exploded blt.hxx into components
        beng        07-Nov-1991 Excised 2-pane listbox support
        beng        20-Apr-1992 Added lazy listbox support
        jonn        25-Apr-1992 Disabled LAZY_LISTBOX build fix
        beng        10-May-1992 Re-enabled (now that we have 1.264)
        Johnl       22-Jul-1992 Lifted Gregj's changes for owner draw combos
        Yi-HsinS    10-Dev-1992 Added support for LBS_OWNERDRAWVARIABLE
*/

#include "pchblt.hxx"   // Precompiled header

/*  The following macro is used to conveniently specify a LB_ or CB_
 *  manifest, depending on the value of _fCombo.  Note, although
 *  most (not all!) LB_ and CB_ manifests have the same name (apart from
 *  the prefix) and SendMessage semantics, they do not have the same values
 *  at all.  An experienced PM programmer may at this point be stunned.
 */
#define LC_MSG( suffix )    ( IsCombo() ? ( CB_##suffix ) : ( LB_##suffix ))

/*
 * Winclass name for all Windows listbox controls.
 */
static const TCHAR *const szClassName = SZ("listbox");

extern "C"
{
    #include <windowsx.h>   // For BLT_COMBOBOX
}

/**********************************************************************

    NAME:       HAW_FOR_HAWAII_INFO::HAW_FOR_HAWAII_INFO
                HAW_FOR_HAWAII_INFO::~HAW_FOR_HAWAII_INFO

    SYNOPSIS:

    ENTRY:

    EXIT:

    HISTORY:
        jonn        05-Aug-1992 Created

**********************************************************************/

HAW_FOR_HAWAII_INFO::HAW_FOR_HAWAII_INFO()
    :   BASE(),
        _nls(),
        _time( 0L )
{
    if ( _nls.QueryError() != NERR_Success )
        ReportError( _nls.QueryError() );
}

HAW_FOR_HAWAII_INFO::~HAW_FOR_HAWAII_INFO()
{
    // nothing to do here
}


/**********************************************************************

    NAME:       LISTBOX::LISTBOX

    SYNOPSIS:   Constructor for owner-draw listbox class

    ENTRY:

    EXIT:

    NOTES:      If the font doesn't construct, we will just continue
                and use the default font.

    HISTORY:
        beng        19-Apr-1992 Created

**********************************************************************/

LISTBOX::LISTBOX(
    OWNER_WINDOW * powin,
    CID            cid,
    BOOL           fReadOnly,
    enum FontType  fonttype,
    BOOL fIsCombo         )
    :   LIST_CONTROL( powin, cid, fIsCombo ),
        _fReadOnly( fReadOnly ),
        _fontListBox( fonttype ),
        _dxScroll( 0 )
{
    if ( QueryError() )
        return;

    //
    //  Enforce the assumption that all BLT_LISTBOXes are
    //  owner-draw (fixed).
    //

    UIASSERT(  ( QueryStyle() & LBS_OWNERDRAWFIXED )
            || ( QueryStyle() & LBS_OWNERDRAWVARIABLE ) );

    if ( !_fontListBox.QueryError() )
        Command( WM_SETFONT, (WPARAM)_fontListBox.QueryHandle(), (LPARAM)FALSE );
}

LISTBOX::LISTBOX(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    BOOL           fReadOnly,
    enum FontType  fonttype,
    BOOL fIsCombo   )
    :   LIST_CONTROL( powin, cid, FALSE, xy, dxy, flStyle, szClassName ),
        _fReadOnly( fReadOnly ),
        _fontListBox( fonttype ),
        _dxScroll( 0 )
{
    UNREFERENCED( fIsCombo ) ;

    if ( QueryError() )
        return;

    //
    //  Enforce the assumption that all BLT_LISTBOXes are
    //  owner-draw (fixed).
    //

    UIASSERT(  ( flStyle & LBS_OWNERDRAWFIXED )
            || ( flStyle & LBS_OWNERDRAWVARIABLE ) );

    // Yes, this deliberately continues if FONT fails.  See note above.
    //
    if ( !_fontListBox.QueryError() )
        Command( WM_SETFONT, (WPARAM)_fontListBox.QueryHandle(), (LPARAM)FALSE );
}


/**********************************************************************

    NAME:       LISTBOX::CD_Draw

    SYNOPSIS:   Implement painting a listbox, on request

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        RustanL     13-Feb-1991 Created
        gregj       01-May-1991 Added GUILTT support
        beng        07-Nov-1991 Tuned a bit
        beng        30-Mar-1992 Use COLORREF, DEVICE_CONTEXT types
        beng        20-Apr-1992 Generalized to BLT_LISTBOX and LAZY both
        beng        01-Jun-1992 GUILTT changes
        jonn        27-Mar-1996 Reset background and text colors

**********************************************************************/

BOOL LISTBOX::CD_Draw( DRAWITEMSTRUCT * pdis )
{
    UIASSERT( (pdis->CtlType == ODT_LISTBOX) ||
              (pdis->CtlType == ODT_COMBOBOX) );

    DEVICE_CONTEXT dc(pdis->hDC);

    //  Draw the focus, if required

//-ckm    if ( (pdis->itemAction & ODA_FOCUS) && !IsReadOnly() )
    if (pdis->itemAction & ODA_FOCUS)
    {
        dc.DrawFocusRect( &(pdis->rcItem) );
    }

    if ( pdis->itemAction & ( ODA_DRAWENTIRE | ODA_SELECT ) )
    {
        // itemID is -1 if asked to paint a focus rect at the first item
        // when the listbox is empty.  Then, itemAction should not
        // indicate painting the item itself.

        LBI * plbi = RequestLBI( pdis ); // virtually calc LBI from pdis
        if ( plbi != NULL )
        {
            // Set the color depending on if the item is selected
            // and it is read-only.

            COLORREF clrBackGround, clrText;
            HBRUSH hbr;

            if ( (pdis->itemState & ODS_SELECTED) && !IsReadOnly() )
            {
                clrBackGround = ::GetSysColor( COLOR_HIGHLIGHT );
                clrText       = ::GetSysColor( COLOR_HIGHLIGHTTEXT );
            }
            else
            {
                clrBackGround = ::GetSysColor( COLOR_WINDOW );
                clrText       = ::GetSysColor( COLOR_WINDOWTEXT );
            }

            hbr = ::CreateSolidBrush( clrBackGround );
            if ( hbr != NULL )
            {
                ::FillRect( dc.QueryHdc(), &(pdis->rcItem), hbr );
                ::DeleteObject( (HGDIOBJ)hbr );
            }

            /*
             *  We must reset the background and text colors, otherwise
             *  they will still be at their new values when GDI tries to
             *  erase an existing focus rectangle.  JonN 3/27/96
             */
            COLORREF clrPrevBackGround = dc.GetBkColor();
            COLORREF clrPrevText = dc.GetTextColor();

            dc.SetBkColor( clrBackGround );
            dc.SetTextColor( clrText );

            if ( (INT)(pdis->itemID) >= 0 )
            {
                plbi->Paint( this, dc.QueryHdc(), &(pdis->rcItem), NULL );
            }

            dc.SetBkColor( clrPrevBackGround );
            dc.SetTextColor( clrPrevText );

            ReleaseLBI(plbi); // dispose of as proper
        }
    }

    return TRUE;
}


/**********************************************************************

   NAME:        LISTBOX::CD_VKey

   SYNOPSIS:    Virtual key handler for listboxes

   ENTRY:       wVKey - virtual key code
                wLastPos - current caret position

   EXIT:        Return value appropriate to WM_VKEYTOITEM message:
                -2      ==> listbox should take no further action
                -1      ==> listbox should take default action
                other   ==> index of an item to perform default action on

   NOTES:
        The listbox must have LBS_WANTKEYBOARDINPUT style
        in order for this function to work (or even be called).

   HISTORY:
        gregj       4/18/91     Created
        beng        15-Oct-1991 Win32 conversion

**********************************************************************/

INT LISTBOX::CD_VKey( USHORT nVKey, USHORT nLastPos )
{
    UNREFERENCED( nLastPos );

    INT nRet;

    switch (nVKey)
    {
    case VK_LEFT:
        ::SendMessage(QueryOwnerHwnd(), WM_HSCROLL,
#if defined(WIN32)
                      MAKELONG(SB_LINEUP,0), (LPARAM)QueryHwnd()
#else
                      SB_LINEUP, MAKELONG(0,QueryHwnd())
#endif
                     );
        nRet = -2;      // no further action
        break;

    case VK_RIGHT:
        ::SendMessage(QueryOwnerHwnd(), WM_HSCROLL,
#if defined(WIN32)
                      MAKELONG(SB_LINEDOWN,0), (LPARAM)QueryHwnd()
#else
                      SB_LINEDOWN, MAKELONG(0,QueryHwnd())
#endif
                     );
        nRet = -2;      // no further action
        break;

    default:
        nRet = -1;      // take default action
        break;
    }

    return nRet;
}


/**********************************************************************

    NAME:       LISTBOX::InvalidateItem

    SYNOPSIS:   This method invalidates an item in the listbox.

    ENTRY:
        i       The index of the item
        fErase  Specifies whether the background of the item's region
                is to be erased.  fErase defaults to TRUE (do erase).

    EXIT:       Item has been invalidated

    HISTORY:
        RustanL     13-Feb-1991     Created
        beng        20-Apr-1992     Move into LISTBOX

**********************************************************************/

VOID LISTBOX::InvalidateItem( INT i, BOOL fErase )
{
    // This finds the item in question and invalidates it only.
    // (Cf. SetScrollPos.)

    RECT rect;

    if ( Command( LB_GETITEMRECT, i, (LPARAM)&rect ) == LB_ERR )
    {
        DBGEOL( "LISTBOX::InvalidateItem: possibly given an invalid index" );
        return;
    }

    ::InvalidateRect( QueryHwnd(), &rect, fErase );
}


/*******************************************************************

    NAME:       LISTBOX::SetScrollPos

    SYNOPSIS:   Sets the horizontal scroll increment of a listbox

    ENTRY:      dxNewPos - new increment, in pels;  defaults to 0

    EXIT:       Listbox is updated

    NOTES:      The scroll increment is typically produced by a
                separate scroll bar control.

    HISTORY:
        gregj       14-Apr-1991 Created
        beng        07-Nov-1991 Removed 2-pane support
        beng        20-Apr-1992 Move into LISTBOX

********************************************************************/

VOID LISTBOX::SetScrollPos( UINT dxNewPos )
{
    _dxScroll = dxNewPos;

    // Invalidate the entire shebang, so that we redraw it all

    Invalidate( FALSE );
}


/*******************************************************************

    NAME:       LISTBOX::QueryHorizontalExtent

    SYNOPSIS:   Returns the horizontal extent of the listbox.  This is
                the "virtual horizontal size" of a horizontally-scrollable
                listbox.

    RETURNS:    UINT                    - The horizontal extent (in pixels).

    HISTORY:
        KeithMo     09-Feb-1993 Created.

********************************************************************/

UINT LISTBOX::QueryHorizontalExtent( VOID ) const
{
    UINT dxExtent = (UINT)Command( LB_GETHORIZONTALEXTENT, 0, 0 );

    if( dxExtent == 0 )
    {
        //
        //  Win32 listboxen return a horizontal extent of 0 until
        //  it has been set with a previous WM_SETHORIZONTALEXTENT
        //  message.  If it would make life easier for the apps,
        //  we could map 0 to the actual width of the listbox window,
        //  like so:
        //
        //  dxExtent = QuerySize().QueryWidth();
        //
    }

    return dxExtent;
}


/*******************************************************************

    NAME:       LISTBOX::SetHorizontalExtent

    SYNOPSIS:   Sets the horizontal extent of the listbox.  This is the
                "virtual horizontal size" of a horizontally-scrollable
                listbox.

    ENTRY:      dxNewExtent             - The new horizontal extent
                                          (in pixels).
    HISTORY:
        KeithMo     09-Feb-1993 Created.

********************************************************************/

VOID LISTBOX::SetHorizontalExtent( UINT dxNewExtent )
{
    Command( LB_SETHORIZONTALEXTENT, (WPARAM)dxNewExtent, 0 );
}


/**********************************************************************

    NAME:       BLT_LISTBOX::BLT_LISTBOX

    SYNOPSIS:   Constructor for BLT listbox class

    ENTRY:

    EXIT:

    HISTORY:
        RustanL     13-Feb-1991 Created
        Johnl       05-Apr-1991 Added FontType parameter, made
                                default non-bold
        gregj       08-Apr-1991 Initialize two-column listbox members
        beng        17-May-1991 Added app-window constructor
        beng        17-Oct-1991 Win32 conversion
        beng        07-Nov-1991 Removed 2-pane support
        KeithMo     17-Jan-1992 Added asserts to ensure that the listbox
                                was created with LBS_OWNERDRAW.
        beng        19-Apr-1992 Factored out LISTBOX

**********************************************************************/

BLT_LISTBOX::BLT_LISTBOX( OWNER_WINDOW * powin,
                          CID            cid,
                          BOOL           fReadOnly,
                          enum FontType  fonttype,
                          BOOL           fIsCombo )
    : LISTBOX( powin, cid, fReadOnly, fonttype, fIsCombo ),
      _nSingleLineHeight( 0 )
{
    if ( QueryError() )
        return;

    APIERR err = CalcSingleLineHeight();
    if (err != NERR_Success)
    {
        ReportError( err );
        return;
    }
}

BLT_LISTBOX::BLT_LISTBOX( OWNER_WINDOW * powin,
                          CID            cid,
                          XYPOINT        xy,
                          XYDIMENSION    dxy,
                          ULONG          flStyle,
                          BOOL           fReadOnly,
                          enum FontType  fonttype,
                          BOOL           fIsCombo )
    : LISTBOX( powin, cid, xy, dxy, flStyle, fReadOnly, fonttype, fIsCombo ),
      _nSingleLineHeight( 0 )
{
    if ( QueryError() )
        return;

    APIERR err = CalcSingleLineHeight();
    if (err != NERR_Success)
    {
        ReportError( err );
        return;
    }
}

/**********************************************************************

   NAME:        BLT_LISTBOX::CalcSingleLineHeight

   SYNOPSIS:    (Re-)Calculate the height of a single item.  Call once
                when the listbox is constructed, and call again if
                the font is changed.

   RETURNS:     APIERR

   HISTORY:
       JonN             24-Sep-1993     Created

**********************************************************************/

APIERR BLT_LISTBOX::CalcSingleLineHeight( VOID )
{
    return (WINDOW::CalcFixedHeight( QueryHwnd(), &_nSingleLineHeight ))
                ? NERR_Success
                : ERROR_GEN_FAILURE;
}

/**********************************************************************

   NAME:        BLT_LISTBOX::CD_Measure

   SYNOPSIS:

   ENTRY:

   RETURNS:     TRUE if the message is processed, FALSE otherwise

   NOTES:

   HISTORY:
       Yi-HsinS         10-Dec-92       Created

**********************************************************************/

BOOL BLT_LISTBOX::CD_Measure( MEASUREITEMSTRUCT *pmis )
{
    UIASSERT( QueryStyle() & LBS_OWNERDRAWVARIABLE );

    LBI *plbi = QueryItem( pmis->itemID );
    UIASSERT( plbi != NULL );

    pmis->itemHeight = plbi->CalcHeight( _nSingleLineHeight );
    return TRUE;
}

/**********************************************************************

   NAME:        BLT_LISTBOX::AddItem

   SYNOPSIS:    Adds an LBI to a BLT_LISTBOX

   ENTRY:       plbi - pointer to newly created LBI

   RETURNS:     Index, or -1 if error

   NOTES:

   HISTORY:
        RustanL     13-Feb-1991 Created
        beng        20-Apr-1992 Header added

**********************************************************************/

INT BLT_LISTBOX::AddItem( LBI * plbi )
{
    if ( plbi == NULL )
        return -1;          //  Refuse to add NULL item.  This way, we can
                            //  guarantee that all items in the listbox
                            //  will be non-NULL.

    if ( plbi->QueryError() != NERR_Success )
    {
        //  Refuse to add an item that was not constructed correctly.
        //  This way, we can guarantee that all items in the listbox
        //  will be correctly constructed.
        //  Before returning, delete the item.
        //
        delete plbi;
        return -1;
    }

    INT i = AddItemData( (VOID *)plbi );
    if ( i < 0 )
    {
        //  Delete the item, since it could not be added.
        delete plbi;
    }

    return i;
}


/**********************************************************************

    NAME:       BLT_LISTBOX::AddItemIdemp

    SYNOPSIS:

    ENTRY:

    EXIT:

    NOTES:
        This method may delete plbi even if return is non-negative.

    HISTORY:
        RustanL         13-Feb-1991 Created

**********************************************************************/

INT BLT_LISTBOX::AddItemIdemp( LBI * plbi )
{
    if ( plbi == NULL )
        return -1;          //  Refuse to add NULL item.  This way, we can
                            //  guarantee that all items in the listbox
                            //  will be non-NULL.

    if ( plbi->QueryError() != NERR_Success )
    {
        // Refuse to add an item that was not constructed correctly.
        // This way, we can guarantee that all items in the listbox
        // will be correctly constructed.
        // Before returning, delete the item.

        delete plbi;
        return -1;
    }

    INT i = FindItem( *plbi );
    if ( i < 0 )
        return AddItem( plbi );

    // The item already exists in the list.  Therefore, delete the
    // given item, and return the index of the item in the listbox.

    delete plbi;
    return i;
}


/**********************************************************************

   NAME:        BLT_LISTBOX::InsertItem

   SYNOPSIS:    Inserts an LBI in a BLT_LISTBOX at a specific index.

   ENTRY:       i    - index for new item.

                plbi - pointer to newly created LBI

   RETURNS:     Index, or -1 if error

   NOTES:

   HISTORY:
        KeithMo     17-Dec-1992     Created.

**********************************************************************/

INT BLT_LISTBOX::InsertItem( INT i, LBI * plbi )
{
    //
    //  Refuse to insert badly constructed LBIs.
    //

    if( plbi == NULL )
    {
        return LB_ERR;
    }

    if( plbi->QueryError() != NERR_Success )
    {
        return LB_ERR;
    }

    //
    //  Insert the item into the listbox.
    //

    i = InsertItemData( i, (VOID *)plbi );

    if( i < 0 )
    {
        //
        //  Delete the LBI since we failed to insert it
        //  into the listbox.
        //

        delete plbi;
    }

    return i;
}


/**********************************************************************

   NAME:       BLT_LISTBOX::FindItem

   SYNOPSIS:   Finds an item in the listbox

   ENTRY:      lbi -        Reference to listbox item be used
                            as search criteria.  If this object
                            has an error, the search automatically
                            returns failure (negative number).

   RETURN:      The index of the item (a non-negative number), if
                found, or a negative number on failure.

   NOTES:       CODEWORK.  It is not clear if Windows makes use of the
                LBS_SORT style for owner-drawn listboxes.  Hence, the
                comparison below may not be needed.  If this is so, it is
                not clear whether or not this is documented Windows behavior
                or an error; in other words, this may change (be fixed?)
                in the future.

   HISTORY:
      RustanL   13-Feb-1991     Created
      DavidHov  10-Dec-1992     Changed to avoid Compare() when possible

**********************************************************************/

INT BLT_LISTBOX::FindItem( const LBI & lbi ) const
{
    if ( lbi.QueryError() != NERR_Success )
    {
        DBGEOL( "BLT_LISTBOX::FindItem called with invalid item" );
        return -1;
    }

    INT iLim = QueryCount();

    if ( QueryStyle() & LBS_SORT )
    {

        INT iMin = 0;

        //  Do binary search
        //  part of invariant:  0 <= iMin <= iLim <= QuerySize()
        //  bound function:     iLim - iMin

        while ( iMin < iLim )
        {
            INT i = ( iMin + iLim ) / 2;    // now, iMin <= i < iLim

            LBI * pLbiNext = QueryItem( i ) ;      // Get next item ptr

            INT nCmpResult = & lbi == pLbiNext     // Is it identical?
                           ? 0                     // Yes; else Compare().
                           : lbi.Compare( pLbiNext );

            if ( nCmpResult == 0 )
                return i;

            if ( nCmpResult < 0 )
                iLim = i;       // lbi < lb[ i ]    (this will definitely
                                //                  decrease iLim)
            else
                iMin = i + 1;   // lbi > lb[ i ]    (this will definitely
                                //                  increase iMin)
        }
    }
    else
    {
        //  Unsorted listbox.  Look for the item based on LBI pointer;
        //  failing that, use Compare() method.

        INT i ;
        for ( i = 0; i < iLim; i++ )
        {
            if ( & lbi == QueryItem( i ) )
                return i;
        }
        for ( i = 0; i < iLim; i++ )
        {
            if ( lbi.Compare( QueryItem( i )) == 0 )
                return i;
        }
    }

    return -1;      // search space exhausted; not found
}


/*******************************************************************

    NAME:       BLT_LISTBOX::ReplaceItem

    SYNOPSIS:   Replaces an LBI in the listbox with another one

    ENTRY:      i -         Valid index of item to be replaced

                plbiNew -   Pointer to new LBI.  If this is NULL,
                            it is assumed that the caller did
                            a:
                                err = lb.ReplaceItem( i, new MY_LBI(...));
                            and that the 'new' failed.  Hence,
                            this method will return ERROR_NOT_ENOUGH_MEMORY.

                pplbiOld -  Pointer to location that receives the
                            previous LBI * at position i in the
                            listbox.  A caller can pass pplbiOld as NULL
                            (its default value) to indicate a non-
                            interest in the previous value.  This
                            method will then delete the old item.

    EXIT:       On failure:  The listbox remains unchanged, plbiNew has
                been deleted, and *pplbiOld should not be used.

                On success:  Listbox item i will be *plbiNew.  If
                pplbiOld was NULL on entry, the previous listbox
                item i was deleted; if pplbiOld was non-NULL,
                *pplbiOld contains a pointer to the previous
                listbox item.

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        rustanl     04-Sep-1991     Created

********************************************************************/

APIERR BLT_LISTBOX::ReplaceItem( INT i, LBI * plbiNew, LBI * * pplbiOld )
{
    if ( ! ( 0 <= i && i < QueryCount()))
    {
        DBGEOL( "BLT_LISTBOX::ReplaceItem: given invalid index" );
        return ERROR_INVALID_PARAMETER;
    }

    // Mimic the semantics of the param to AddItem for the plbiNew parameter
    if ( plbiNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY; // assume caller did a 'new'
                                        // and ran out (like AddItem)

    APIERR err = plbiNew->QueryError();
    if ( err != NERR_Success )
    {
        delete plbiNew;
        return err;
    }

    LBI * plbiOld = QueryItem( i );
    UIASSERT( plbiOld != NULL );
    if ( pplbiOld == NULL )
    {
        //  caller is not interested in previous item
        delete plbiOld;
    }
    else
    {
        //  caller wants to torture the old item
        *pplbiOld = plbiOld;
    }

    SetItem( i, plbiNew );

    return NERR_Success;
}

/*******************************************************************

    NAME:       BLT_LISTBOX::RemoveItem

    SYNOPSIS:   Removes an LBI from a listbox w/o deleting the LBI

    ENTRY:      i -         Valid index of item to be removed

    EXIT:       The item will have been removed from the listbox

    RETURNS:    A pointer to the removed LBI

    HISTORY:
        johnl     27-Oct-1992     Created

********************************************************************/

LBI * BLT_LISTBOX::RemoveItem( INT i )
{
    if ( ! ( 0 <= i && i < QueryCount()))
    {
        DBGEOL( "BLT_LISTBOX::RemoveItem: given invalid index" );
        UIASSERT( FALSE ) ;
        return NULL ;
    }

    LBI * plbiOld = QueryItem( i );
    UIASSERT( plbiOld != NULL );

    SetItem( i, NULL );
    DeleteItem( i ) ;

    return plbiOld ;
}

/*******************************************************************

    NAME:       BLT_LISTBOX::RemoveAllItems

    SYNOPSIS:   Removes all items from the listbox without deleting the LBIs

    NOTES:

    HISTORY:
        Johnl   07-Dec-1992     Created

********************************************************************/

void BLT_LISTBOX::RemoveAllItems( void )
{
    INT cItems = QueryCount() ;

    for ( ; cItems > 0 ; cItems-- )
    {
        RemoveItem( cItems-1 ) ;
    }
}

/**********************************************************************

    NAME:       BLT_LISTBOX::QueryItem

    SYNOPSIS:   Returns pointer to i'th item in listbox

    ENTRY:      Index of item sought.
                If no index supplied, returns first selected item.

    RETURNS:    LBI*, or NULL if no item selected.

    NOTES:

    HISTORY:
        RustanL     13-Feb-1991     Created
        beng        21-Aug-1991     Removed LC_CURRENT_ITEM magic value

**********************************************************************/

LBI * BLT_LISTBOX::QueryItem( INT i ) const
{
    if (i < 0)
        return NULL;

    ULONG_PTR ul = Command( LC_MSG( GETITEMDATA ), (UINT)i );
    if ( ul == (ULONG)LB_ERR )
        return NULL;

    //  CODEWORK.  Could potentially do some debug version checking to
    //  verify that ul is a pointer to a real LBI.  E.g., call virtual
    //  method QueryLeadingChar.  This gives some kind of test.

    return (LBI *)ul;
}


/*********************************************************************

    NAME:       BLT_LISTBOX::CD_Guiltt

    SYNOPSIS:   Fetches data for GUILTT from a control

    ENTRY:
        ilb     - index into the listbox (or some other subsel)
        pnlsOut - string to hold the output data

    EXIT
        pnlsOut - no doubt has been scribbled into

    RETURN:     An error code - NERR_Success if successful.

    HISTORY:
        beng            01-Jun-1992 Created
        beng            11-Jun-1992 Fix bug

*********************************************************************/

APIERR BLT_LISTBOX::CD_Guiltt( INT ilb, NLS_STR * pnlsOut )
{
    LBI * plbi = QueryItem(ilb);
    if (plbi == NULL)
        return BLT::MapLastError(ERROR_INVALID_PARAMETER);

    // Bundle all the information the Paint routine needs.
    // (This "Paint" interface, while awkward, was inherited from old BLT
    // code; it has many clients, and so would be a pain to change
    // this late in the game.)

    GUILTT_INFO ginfo;
    ginfo.pnlsOut = pnlsOut;
    ginfo.errOut = NERR_Success;

    plbi->Paint( this, 0, 0, &ginfo );
    return ginfo.errOut;
}

/**********************************************************************

    NAME:       BLT_COMBOBOX::BLT_COMBOBOX

    SYNOPSIS:   Constructor for BLT combobox class

    ENTRY:      Same as for BLT_LISTBOX

    EXIT:

    HISTORY:
        Johnl       21-Oct-1992     Created

**********************************************************************/

WNDPROC BLT_COMBOBOX::_OldCBProc = NULL ;
UINT    BLT_COMBOBOX::_cReferences = 0 ;

BLT_COMBOBOX::BLT_COMBOBOX( OWNER_WINDOW * powin,
                          CID            cid,
                          BOOL           fReadOnly,
                          enum FontType  fonttype )
    : BLT_LISTBOX( powin, cid, fReadOnly, fonttype, TRUE )
{
    if ( QueryError() )
        return;

    if ( BLT_COMBOBOX::_OldCBProc == NULL )
        BLT_COMBOBOX::_OldCBProc = SubclassWindow( QueryHwnd(),
                                               BLT_COMBOBOX::CBSubclassProc ) ;
    BLT_COMBOBOX::_cReferences++ ;
}

BLT_COMBOBOX::BLT_COMBOBOX( OWNER_WINDOW * powin,
                          CID            cid,
                          XYPOINT        xy,
                          XYDIMENSION    dxy,
                          ULONG          flStyle,
                          BOOL           fReadOnly,
                          enum FontType  fonttype )
    : BLT_LISTBOX( powin, cid, xy, dxy, flStyle, fReadOnly, fonttype, TRUE )
{
    if ( QueryError() )
        return;

    if ( BLT_COMBOBOX::_OldCBProc == NULL )
        BLT_COMBOBOX::_OldCBProc = SubclassWindow( QueryHwnd(),
                                               BLT_COMBOBOX::CBSubclassProc ) ;
    BLT_COMBOBOX::_cReferences++ ;
}

BLT_COMBOBOX::~BLT_COMBOBOX()
{
    BLT_COMBOBOX::_cReferences-- ;

    if ( BLT_COMBOBOX::_OldCBProc != NULL &&
         BLT_COMBOBOX::_cReferences == 0 )
    {
        (void) SubclassWindow( QueryHwnd(), BLT_COMBOBOX::_OldCBProc ) ;
        BLT_COMBOBOX::_OldCBProc = NULL ;
    }
}

/*******************************************************************

    NAME:       BLT_COMBOBOX::IsDropped

    SYNOPSIS:   Determines if the listbox portion of this combobox is "dropped"

    RETURNS:    TRUE if dropped, FALSE otherwise

    NOTES:      This method can be copied w/o changes to the normal combox
                class.

    HISTORY:
        Johnl   13-Dec-1992     Created

********************************************************************/

BOOL BLT_COMBOBOX::IsDropped( void ) const
{
    return (BOOL)Command( CB_GETDROPPEDSTATE ) ;
}

/*******************************************************************

    NAME:       BLT_COMBOBOX::DevCBSubclassProc

    SYNOPSIS:   Subclass procedure for device combo boxes

    ENTRY:      as a window proc

    EXIT:       as a window proc

    NOTES:
        MAJOR HACK: Windows does not have a combo box analog to
        LBS_WANTKEYBOARDINPUT, so an owner-drawn drop-down list
        does not have letter jumps.  So we subclass the window
        and simulate what Windows does for listboxes.  The only
        subclass procedure in BLT.

    HISTORY:
        gregj   24-Feb-1992     Created
        Johnl                   Converted to Win32

********************************************************************/

LRESULT WINAPI BLT_COMBOBOX::CBSubclassProc( HWND hwnd,
                                             UINT msg,
                                             WPARAM wParam,
                                             LPARAM lParam )
{
    switch (msg) {
    case WM_CHAR:
        {
            if (lParam & (1L << 31))
                break;

            INT iItem = ComboBox_GetCurSel( hwnd ) ;
            iItem = (INT) ::SendMessage( ::GetParent(hwnd),
                                         WM_CHARTOITEM,
                                         (WPARAM) MAKELONG( wParam, iItem ),
                                         (LPARAM) hwnd );

            if (iItem < 0)
                break;

            ComboBox_SetCurSel( hwnd, iItem ) ;
            break;
        }

    case WM_KEYDOWN:
        {
            INT iItem = ComboBox_GetCurSel( hwnd ) ;

            iItem = (INT) ::SendMessage( ::GetParent(hwnd),
                                         WM_VKEYTOITEM,
                                         (WPARAM) MAKELONG( wParam, iItem ),
                                         (LPARAM) hwnd );

            if (iItem < 0)
                break;

            ComboBox_SetCurSel( hwnd, iItem ) ;
            break;
        }
    }

    return CallWindowProc( BLT_COMBOBOX::_OldCBProc, hwnd, msg, wParam, lParam );
}


/**********************************************************************

    NAME:       CalcCharUpper

    SYNOPSIS:   Uppercase a character

    NOTES:
        Think of this as a Unicode/DBCS-safe "toupper"

    HISTORY:
        beng        08-Jun-1992 Created

**********************************************************************/

static inline WCHAR CalcCharUpper( WCHAR wchGiven )
{
    ULONG ul = MAKELONG(wchGiven, 0);
#if !defined(UNICODE)
    return (WCHAR) LOWORD(::AnsiUpper((TCHAR*)ul));
#else
    return (WCHAR) LOWORD(::CharUpper((TCHAR*)UIntToPtr(ul)));
#endif
}


/**********************************************************************

    NAME:       IsCharPrintable

    SYNOPSIS:   Determine whether a character is printable or not

    NOTES:
        This of this as a Unicode/DBCS-safe "isprint"

    HISTORY:
        beng        08-Jun-1992 Created

**********************************************************************/

static WCHAR IsCharPrintable( WCHAR wch )
{
#if !defined(UNICODE)
    if (HIBYTE(wch) != 0)               // All double-byte chars are printable
        return TRUE;
    return (LOBYTE(wch) > (BYTE)' ');  // Otherwise, in Latin 1.
#else
    WORD nType;

    BOOL fOK = ::GetStringTypeW(CT_CTYPE1, &wch, 1, &nType);
    ASSERT(fOK);

    return (fOK && !(nType & (C1_CNTRL|C1_BLANK|C1_SPACE)));
#endif
}


/**********************************************************************

    NAME:       IsCharPrintableOrSpace

    SYNOPSIS:   Determine whether a character is printable or not

    NOTES:
        This of this as a Unicode/DBCS-safe "isprint"

    HISTORY:
        JonN        17-Aug-1992 Created

**********************************************************************/

static WCHAR IsCharPrintableOrSpace( WCHAR wch )
{
#if !defined(UNICODE)
    if (HIBYTE(wch) != 0)               // All double-byte chars are printable
        return TRUE;
    return (LOBYTE(wch) >= (BYTE)' ');  // Otherwise, in Latin 1.
#else
    WORD nType;

    BOOL fOK = ::GetStringTypeW(CT_CTYPE1, &wch, 1, &nType);
    ASSERT(fOK);

    return (fOK && !(nType & (C1_CNTRL|C1_BLANK)));
#endif
}


/**********************************************************************

    NAME:       BLT_LISTBOX::CD_Char

    SYNOPSIS:   Custom-draw code to respond to a typed character

    ENTRY:      wch      - Character typed
                nLastPos - Current caret position

    RETURNS:    As per WM_CHARTOITEM message (q.v.)

    NOTES:
        Does not assume that items are sorted.

    HISTORY:
        RustanL     13-Feb-1991 Created
        beng        20-May-1991 LBI::QueryLeadingChar now returns WCHAR
        beng        15-Oct-1991 Win32 conversion
        beng        08-Jun-1992 Locate lowercase entries correctly

**********************************************************************/

INT BLT_LISTBOX::CD_Char( WCHAR wch, USHORT nLastPos )
{
    // Filter characters which won't appear in keys

    if ( ! IsCharPrintable( wch ))
        return -2;  // take no other action

    // Cache the typed character's uppercase version, for repeated
    // case-insensitive comparisons.

    WCHAR wchUpper = CalcCharUpper(wch);

    INT clbi = QueryCount();
    if ( clbi == 0 )
    {
        // Should never get this message if no items;
        // 
        //
        return -2;  // take no other action
    }

    INT iLim = nLastPos + clbi + 1;     // iLim is the first index mode clbi
                                        // that we will not look at

    for ( INT iLoop = nLastPos + 1; iLoop < iLim; iLoop++ )
    {
        LBI * plbi = QueryItem( iLoop % clbi );
        WCHAR wchLeading = plbi->QueryLeadingChar();

        if (   (wch == wchLeading)
            || (wchUpper == CalcCharUpper(wchLeading)) )
        {
            //  Return index of item, on which the system listbox should
            //  perform the default action.
            //
            return ( iLoop % clbi );
        }
    }

    //  The character was not found as a first character of any listbox item

    return -2;  // take no other action
}


/**********************************************************************

    NAME:       BLT_LISTBOX::CD_Char_HAWforHawaii

    SYNOPSIS:   Custom-draw code to respond to a typed character
                for listboxes with HAW-for-Hawaii support

    ENTRY:      wch      - Character typed
                nLastPos - Current caret position
                phawinfo - Pointer to info buffer used internally
                           to keep track of HAW-for-Hawaii state.
                           This must have constructed successfully,
                           but the caller need not keep closer track.

    RETURNS:    As per WM_CHARTOITEM message (q.v.)

    NOTES:
        Does not assume that items are sorted.

    HISTORY:
        JonN        05-Aug-1992 Created
        JonN        13-Nov-1992 Reset search on timeout; still can't
                                recognize SPACEBAR
        JonN        22-Mar-1993 Move focus to first after string if miss

**********************************************************************/

INT BLT_LISTBOX::CD_Char_HAWforHawaii( WCHAR wch,
                                       USHORT nLastPos,
                                       HAW_FOR_HAWAII_INFO * phawinfo )
{
    UIASSERT( phawinfo != NULL && phawinfo->QueryError() == NERR_Success );

    if (wch == VK_BACK)
    {
        TRACEEOL( "NETUI:HAWforHawaii: hit BACKSPACE" );
        phawinfo->_time = 0L; // reset timer
        phawinfo->_nls = SZ("");
        UIASSERT( phawinfo->_nls.QueryError() == NERR_Success );
        return 0; // go to first LBI
    }

    // Filter characters which won't appear in keys

    if ( ! IsCharPrintableOrSpace( wch ))
        return -2;  // take no other action

    INT clbi = QueryCount();
    if ( clbi == 0 )
    {
        // Should never get this message if no items;
        // 
        //
        return -2;  // take no other action
    }

    LONG lTime = ::GetMessageTime();

#define ThresholdTime 2000

    // CODEWORK ignoring time wraparound effects for now
    if ( (lTime - phawinfo->_time) > ThresholdTime )
    {
        TRACEEOL( "NETUI:HAWforHawaii: threshold timeout" );
        nLastPos = 0;
        phawinfo->_nls = SZ("");
    }

    APIERR err = phawinfo->_nls.AppendChar( wch );
    if (err != NERR_Success)
    {
        DBGEOL( "NETUI:HAWforHawaii: could not extend phawinfo->_nls" );
        nLastPos = 0;
        phawinfo->_nls = SZ("");
    }

    UIASSERT( phawinfo->_nls.QueryError() == NERR_Success );

    TRACEEOL(   "NETUI:HAWforHawaii: phawinfo->_nls is \""
             << phawinfo->_nls.QueryPch()
             << "\"" );

    phawinfo->_time = lTime;

    INT nReturn = -2; // take no other action

    for ( INT iLoop = nLastPos; iLoop < clbi; iLoop++ )
    {
        LBI * plbi = QueryItem( iLoop );

        INT nCompare = plbi->Compare_HAWforHawaii( phawinfo->_nls );

        if ( nCompare == 0 )
        {
            TRACEEOL( "NETUI:HAWforHawaii: found match" );

            //  Return index of item, on which the system listbox should
            //  perform the default action.
            //
            TRACEEOL( "NETUI:HAWforHawaii: match at " << iLoop );
            return ( iLoop );
        }
        else if ( nCompare < 0 )
        {
            if ( nReturn < 0 )
                nReturn = iLoop;
        }
    }

    //  The character was not found as a leading prefix of any listbox item

    if (nReturn == -2)
    {
        nReturn = clbi-1;
        TRACEEOL(
            "NETUI:HAWforHawaii: no exact or subsequent match, returning last item "
            << nReturn );
    }
    else
    {
        TRACEEOL(
            "NETUI:HAWforHawaii: no exact match, returning subsequent match "
            << nReturn );
    }

    return nReturn;
}


/**********************************************************************

    NAME:       BLT_LISTBOX::RequestLBI

    SYNOPSIS:   Determine LBI from draw-item information

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        20-Apr-1992 Created

**********************************************************************/

LBI * BLT_LISTBOX::RequestLBI( const DRAWITEMSTRUCT * pdis )
{
    return (LBI *)pdis->itemData;
}


/**********************************************************************

    NAME:       BLT_LISTBOX::ReleaseLBI

    SYNOPSIS:   Dispose of LBI* from RequestLBI

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        20-Apr-1992 Created

**********************************************************************/

VOID BLT_LISTBOX::ReleaseLBI( LBI * plbi )
{
    UNREFERENCED(plbi);
}


/**********************************************************************

    NAME:       BLT_LISTBOX_HAW::BLT_LISTBOX_HAW

    SYNOPSIS:   Constructor for BLT listbox class with HAW-for-Hawaii

    HISTORY:
        jonn        11-Aug-1992 HAW-for-Hawaii for other LBs

**********************************************************************/

BLT_LISTBOX_HAW::BLT_LISTBOX_HAW( OWNER_WINDOW * powin,
                                  CID            cid,
                                  BOOL           fReadOnly,
                                  enum FontType  fonttype,
                                  BOOL           fIsCombo )
    : BLT_LISTBOX( powin, cid, fReadOnly, fonttype, fIsCombo ),
    _hawinfo()
{
    if ( QueryError() )
        return;

    APIERR err = _hawinfo.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}

BLT_LISTBOX_HAW::BLT_LISTBOX_HAW( OWNER_WINDOW * powin,
                                  CID            cid,
                                  XYPOINT        xy,
                                  XYDIMENSION    dxy,
                                  ULONG          flStyle,
                                  BOOL           fReadOnly,
                                  enum FontType  fonttype,
                                  BOOL           fIsCombo )
    : BLT_LISTBOX( powin, cid, xy, dxy, flStyle, fReadOnly, fonttype, fIsCombo ),
    _hawinfo()
{
    if ( QueryError() )
        return;

    APIERR err = _hawinfo.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/**********************************************************************

    NAME:       BLT_LISTBOX_HAW::CD_Char

    SYNOPSIS:   Custom-draw code to respond to a typed character

    ENTRY:      wch      - Character typed
                nLastPos - Current caret position

    RETURNS:    As per WM_CHARTOITEM message (q.v.)

    NOTES:
        Does not assume that items are sorted.

    HISTORY:
        jonn        11-Aug-1992 HAW-for-Hawaii for other LBs

**********************************************************************/

INT BLT_LISTBOX_HAW::CD_Char( WCHAR wch, USHORT nLastPos )
{
    return CD_Char_HAWforHawaii( wch, nLastPos, &_hawinfo );
}






#if defined(WIN32)
/**********************************************************************

    NAME:       LAZY_LISTBOX::LAZY_LISTBOX

    SYNOPSIS:   Constructor for BLT no-data listbox class

    HISTORY:
        beng        20-Apr-1992 Created

**********************************************************************/

LAZY_LISTBOX::LAZY_LISTBOX(
    OWNER_WINDOW * powin,
    CID            cid,
    BOOL           fReadOnly,
    enum FontType  fonttype )
    : LISTBOX( powin, cid, fReadOnly, fonttype )
{
    if ( QueryError() )
        return;

    ASSERT( QueryStyle() & LBS_NODATA );
}

LAZY_LISTBOX::LAZY_LISTBOX(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    BOOL           fReadOnly,
    enum FontType  fonttype )
    : LISTBOX( powin, cid, xy, dxy, flStyle, fReadOnly, fonttype )
{
    if ( QueryError() )
        return;

    ASSERT( flStyle & LBS_NODATA );
}


/**********************************************************************

    NAME:       LAZY_LISTBOX::RequestLBI

    SYNOPSIS:   Determine LBI from draw-item information

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        20-Apr-1992 Created

**********************************************************************/

LBI * LAZY_LISTBOX::RequestLBI( const DRAWITEMSTRUCT * pdis )
{
    return OnNewItem( pdis->itemID );
}


/**********************************************************************

    NAME:       LAZY_LISTBOX::ReleaseLBI

    SYNOPSIS:   Dispose of LBI* from RequestLBI

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        20-Apr-1992 Created

**********************************************************************/

VOID LAZY_LISTBOX::ReleaseLBI( LBI * plbi )
{
    OnDeleteItem( plbi );
}

/**********************************************************************

    NAME:       LAZY_LISTBOX::OnDeleteItem

    SYNOPSIS:   Dispose of LBI* from RequestLBI

    NOTES:
        This is a virtual member function.

    HISTORY:
        Yi-HsinS     20-Apr-1992 Created

**********************************************************************/

VOID LAZY_LISTBOX::OnDeleteItem( LBI * plbi )
{
    delete plbi;
}

/**********************************************************************

    NAME:       LAZY_LISTBOX::SetCount

    SYNOPSIS:   Set (or reset) the number of lines in a lazy listbox

    ENTRY:
        clbi    - New number of lines in the listbox

    HISTORY:
        beng        20-Apr-1992 Created

**********************************************************************/

VOID LAZY_LISTBOX::SetCount( UINT clbi )
{
    Command( LB_SETCOUNT, (WPARAM)clbi );
}


/*********************************************************************

    NAME:       LAZY_LISTBOX::CD_Guiltt

    SYNOPSIS:   Fetches data for GUILTT from a control

    ENTRY:
        ilb     - index into the listbox (or some other subsel)
        pnlsOut - string to hold the output data

    EXIT
        pnlsOut - no doubt has been scribbled into

    RETURN:     An error code - NERR_Success if successful.

    HISTORY:
        beng            01-Jun-1992 Created
        beng            11-Jun-1992 Fix bug
        KeithMo         21-Sep-1992 Fixed bug.

*********************************************************************/

APIERR LAZY_LISTBOX::CD_Guiltt( INT ilb, NLS_STR * pnlsOut )
{
    LBI * plbi = OnNewItem(ilb);
    if (plbi == NULL)
        return BLT::MapLastError(ERROR_INVALID_PARAMETER);

    // Bundle all the information the Paint routine needs.
    // (This "Paint" interface, while awkward, was inherited from old BLT
    // code; it has many clients, and so would be a pain to change
    // this late in the game.)

    GUILTT_INFO ginfo;
    ginfo.pnlsOut = pnlsOut;
    ginfo.errOut = NERR_Success;

    plbi->Paint( this, 0, 0, &ginfo );

//    delete plbi;
    OnDeleteItem( plbi );
    return ginfo.errOut;
}


#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltlocal.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltlocal.cxx
    Local BLT stuff: implementations

    FILE HISTORY:
	RustanL     04-Jan-91	    Created, adding BLT_SCRATCH
	beng	    11-Feb-1991     Uses lmui.hxx
	beng	    14-May-1991     Exploded blt.hxx into components

*/
#include "pchblt.hxx"   // Precompiled header


/**********************************************************************

    NAME:	BLT_SCRATCH::BLT_SCRATCH

    SYNOPSIS:	Constructor

    ENTRY:
	cbSize names desired amount of storage, in bytes

    EXIT:
	_cbSize set to passed parameter
	_pbStorage points to storage, either on the stack or heap

    NOTES:

    HISTORY:
	RustanL     04-Jan-91	Created, adding BLT_SCRATCH
	beng	    04-Oct-1991 Win32 conversion

**********************************************************************/

BLT_SCRATCH::BLT_SCRATCH( UINT cbSize )
    : _cbSize(cbSize),
      _pbStorage(0)
{
    _cbSize = cbSize;
    if ( cbSize > BLT_SCRATCH_STATIC_SIZE )
    {
	_pbStorage = new BYTE[ cbSize ];
	if ( _pbStorage == NULL )
	{
	    _cbSize = 0;
	    ReportError(ERROR_NOT_ENOUGH_MEMORY);
	}
    }
    else
    {
	_pbStorage = _abStaticBuffer;
    }
}


/**********************************************************************

    NAME:	BLT_SCRATCH::~BLT_SCRATCH

    SYNOPSIS:	Destructor

    HISTORY:
	RustanL     04-Jan-91	    Created, adding BLT_SCRATCH
	beng	    23-May-1991     Made zeroing DEBUG-only

**********************************************************************/

BLT_SCRATCH::~BLT_SCRATCH()
{
    if ( _pbStorage != _abStaticBuffer )
	delete _pbStorage;

#if defined(DEBUG)
    _pbStorage = NULL;
    _cbSize = 0;
#endif
}


/**********************************************************************

    NAME:	BLT_SCRATCH::QueryPtr

    SYNOPSIS:	Returns a pointer to the available storage

    HISTORY:
	RustanL     04-Jan-91	    Created, adding BLT_SCRATCH

**********************************************************************/

BYTE * BLT_SCRATCH::QueryPtr() const
{
    return _pbStorage;
}


/**********************************************************************

    NAME:	BLT_SCRATCH::QuerySize

    SYNOPSIS:	Returns amount of storage available, in bytes

    HISTORY:
	RustanL     04-Jan-91	Created, adding BLT_SCRATCH
	beng	    04-Oct-1991 Win32 conversion

**********************************************************************/

UINT BLT_SCRATCH::QuerySize() const
{
    return _cbSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltmain.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltmain.cxx
    BLT application startup code

    This file contains the C-linkage glue functions binding BLT to
    the application.


    FILE HISTORY:
        beng        01-Apr-1991     Created

*/

#include "pchblt.hxx"

/*******************************************************************

    NAME:       BltMain

    SYNOPSIS:   Glue function binding BLT to the application.

    NOTES:
        BltMain is generated by the SET_ROOT_OBJECT macro.  This
        implementation will only link into the application if the
        client neglected to set a root object.

    HISTORY:
        beng        01-Apr-1991 Created
        beng        14-Oct-1991 APPSTART deleted; now used to detect
                                a missing root object
        beng        24-Apr-1992 Removed pszCmdLine parameter

********************************************************************/

INT BltMain(
    HINSTANCE   hInstance,       // current instance
    HINSTANCE   hPrevInstance,   // previous instance
    INT      nCmdShow )       // show-window type (open/icon)
{
    UNREFERENCED(hInstance);
    UNREFERENCED(hPrevInstance);
    UNREFERENCED(nCmdShow);

    ::MessageBox(NULL, SZ("Client application never declared a root object"),
                 SZ("BLT"), (MB_TASKMODAL | MB_ICONSTOP | MB_OK) );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltmets.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltmets.cxx
    METALLIC_STR_DTE implementation

    FILE HISTORY:
        rustanl     22-Jul-1991     Created
        rustanl     07-Aug-1991     Added to BLT
        KeithMo     07-Aug-1992     STRICTified.

*/

#include "pchblt.hxx"   // Precompiled header

/*******************************************************************

    NAME:       METALLIC_STR_DTE::Paint

    SYNOPSIS:   Paints the 3D string DTE

    ENTRY:      hdc -       handle to DC to be used for painting
                prect -     pointer to rectangle in which to paint

    NOTES:      CODEWORK:  Are the below the right colors to use?
                This area is not push-able, so perhaps some hard-coded
                color should be used instead.  Win 3.1 File Man uses
                button colors for its status bar (which resembles this
                more than anything else), whereas Excel's ribbon of
                buttons seems to use some hard-coded colors.

    HISTORY:
        terryk      13-Jun-91   Created as COLUMN_HEADER control
        rustanl     12-Jul-1991 Modified for METALLIC_STR_DTE use
        beng        05-Oct-1991 Win32 conversion
        beng        08-Nov-1991 Unsigned widths
        KeithMo     21-Feb-1992 Use COLOR_BTNHIGHLIGHT instead of white.
                                Also fixed problem of deleting HPENs while
                                they're still selected in the DC.
        beng        30-Mar-1992 Use new DEVICE_CONTEXT wrappers
        beng        28-Jun-1992 Paint text in button colors

********************************************************************/

VOID METALLIC_STR_DTE::Paint( HDC hdc, const RECT * prect ) const
{
#if 0   // we just gotta keep this nifty comment for posterity...

/*
    //  This method will paint an area to look as follows.
    //
    //      .       Background (button face color)
    //      \       Dark shadow (button shadow color)
    //      /       Light shadow (buttin highlight color)
    //      t       text
    //
    //           dxMargin                             dxMargin
    //          /\                                   /\
    // Calc    /.......................................    \  _dyTopMargin
    // Top-   | .......................................    /
    // Text-   \..\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\...
    // Margin() ..\..ttttttttttttttttttttttttttttt../..
    //          ..\..ttttttttttttttttttttttttttttt../..
    //          ..\..ttttttttttttttttttttttttttttt../..
    //          ..\..ttttttttttttttttttttttttttttt../..
    //          ..\..ttttttttttttttttttttttttttttt../..
    // Calc-   /...//////////////////////////////////..
    // Bottom-| .......................................    \  _dyBottomMargin
    // Text-   \.......................................    /
    // Margin() \___/                             \___/
    //         dxTextMargin                      dxTextMargin
    //
    //
    //
    //
    //
    //  Note, depending on the size of the overall rectangle, the variable
    //  area (the area between the margins) may not fit at all.
    //
*/

    const UINT dxMargin = 3;
    const UINT dxTextMargin = dxMargin + 1 + 2;

    //  First draw the background
    {
        SOLID_BRUSH sbFace( COLOR_BTNFACE );
        if ( sbFace.QueryError() == NERR_Success )
            ::FillRect( hdc, (RECT*)prect, sbFace.QueryHandle());
    }

    //  If there's no space for the variable size region, bag out
    //  now.  The "+1"'s are for the light and dark lines, since the
    //  corners of the light/dark rectangle are not painted (so
    //  as to portray a 3D effect).

    if ( prect->right - prect->left <= 2 * dxMargin + 1 ||
         prect->bottom - prect->top <= _dyTopMargin + _dyBottomMargin + 1 )
    {
        return;
    }

    DEVICE_CONTEXT dc( hdc );

    //  Draw the two lines
    {
        HPEN hpenDark  = ::CreatePen( PS_SOLID, 1,
                                      ::GetSysColor( COLOR_BTNSHADOW ));
        if ( hpenDark == NULL )
        {
            DBGEOL( "METALLIC_STR_DTE::Paint: Pen creation failed" );
        }
        else
        {
            HPEN hpenOld = dc.SelectPen( hpenDark );
            ::MoveToEx( hdc,
                        (int)( prect->left + dxMargin ),
                        (int)( prect->bottom - _dyBottomMargin - 2 ),
                        NULL );
            ::LineTo( hdc,
                      (int)( prect->left + dxMargin ),
                      (int)( prect->top + _dyTopMargin ) );
            ::LineTo( hdc,
                      (int)( prect->right - dxMargin - 1 ),
                      (int)( prect->top + _dyTopMargin ) );

            dc.SelectPen( hpenOld );
            ::DeleteObject( (HGDIOBJ)hpenDark );
        }
    }
    {
        HPEN hpenLight = ::CreatePen( PS_SOLID, 1,
                                      ::GetSysColor( COLOR_BTNHIGHLIGHT ));
        if ( hpenLight == NULL )
        {
            DBGEOL( SZ("METALLIC_STR_DTE::Paint: Pen creation failed") );
        }
        else
        {
            HPEN hpenOld = dc.SelectPen( hpenLight );
            ::MoveToEx( hdc,
                        (int)( prect->left + dxMargin + 1 ),
                        (int)( prect->bottom - _dyBottomMargin - 1 ),
                        NULL );
            ::LineTo( hdc,
                      (int)( prect->right - dxMargin - 1 ),
                      (int)( prect->bottom - _dyBottomMargin - 1 ) );
            ::LineTo( hdc,
                      (int)( prect->right - dxMargin - 1 ),
                      (int)( prect->top + _dyTopMargin ) );

            dc.SelectPen( hpenOld );
            ::DeleteObject( (HGDIOBJ)hpenLight );
        }
    }


    //  Set the background of the area to be that color, so the text
    //  that will paint there will have the correct background.  Note,
    //  that the background mode and color is per dc, so make sure
    //  these are restored on exit.
    {
        INT nOldBkMode = dc.SetBkMode(OPAQUE);
        COLORREF rgbOldBkColor = dc.SetBkColor( ::GetSysColor(COLOR_BTNFACE) );
        COLORREF rgbTextPrev = dc.SetTextColor( ::GetSysColor(COLOR_BTNTEXT) );

        //  Call STR_DTE to paint the string
        RECT rect;
        rect.left =   prect->left   + dxTextMargin;
        rect.right =  prect->right  - dxTextMargin;
        rect.top =    prect->top    + CalcTopTextMargin();
        rect.bottom = prect->bottom - CalcBottomTextMargin();
        if ( rect.left <= rect.right )
            STR_DTE::Paint( hdc, &rect );

        //  Restore the old background mode and color for the dc

        dc.SetBkMode( nOldBkMode );
        dc.SetBkColor( rgbOldBkColor );
        dc.SetTextColor( rgbTextPrev );
    }

#else

/*
    //  This method will paint an area to look as follows.
    //
    //      .       Background (button face color)
    //      \       Dark shadow (button shadow color)
    //      /       Light shadow (buttin highlight color)
    //      t       text
    //
    //           dxMargin                       dxMargin+1
    //          /\                             /-\
    // Calc    /.................................\   \  _dyTopMargin
    // Top-   | .................................\   /
    // Text-   \..ttttttttttttttttttttttttttttt..\
    // Margin() ..ttttttttttttttttttttttttttttt..\
    //          ..ttttttttttttttttttttttttttttt..\
    //          ..ttttttttttttttttttttttttttttt..\
    //         /..ttttttttttttttttttttttttttttt..\
    // Calc-  | .................................\   \  _dyBottomMargin
    // Bottom- \.................................\   /
    // Text-
    // Margin()
    //
    //
    //
    //
    //
    //
    //  Note, depending on the size of the overall rectangle, the variable
    //  area (the area between the margins) may not fit at all.
    //
*/

    const UINT dxMargin = 2;

    //
    //  Draw the background.
    //

    {
        SOLID_BRUSH sbFace( COLOR_BTNFACE );

        //
        //  CODEWORK:  We should add FillRect to DEVICE_CONTEXT!
        //

        ::FillRect( hdc, (RECT *)prect, sbFace.QueryHandle() );
    }

    //
    //  If there's no space for the variable size region, bag out
    //  now.
    //

    if( ( prect->right - prect->left <= 2 * dxMargin + 1 ) ||
        ( prect->bottom - prect->top <= (INT)(_dyTopMargin + _dyBottomMargin) ) )
    {
        return;
    }

    DEVICE_CONTEXT dc( hdc );

    //
    //  Draw the right border (line).
    //

    {
        HPEN hpenDark = ::CreatePen( PS_SOLID,
                                     1,
                                     ::GetSysColor( COLOR_BTNSHADOW ) );

        if (NULL != hpenDark) // JonN 01/27/00: PREFIX bug 444900
        {
            HPEN hpenOld = dc.SelectPen( hpenDark );

            dc.MoveTo( (INT)prect->right - 1, 0 );
            dc.LineTo( (INT)prect->right - 1, (INT)prect->bottom );

            dc.SelectPen( hpenOld );
            ::DeleteObject( (HGDIOBJ)hpenDark );
        }
    }

    //
    //  Set the background of the area to be that color, so the text
    //  that will paint there will have the correct background.  Note,
    //  that the background mode and color is per dc, so make sure
    //  these are restored on exit.
    //

    {
        INT nOldBkMode = dc.SetBkMode(OPAQUE);
        COLORREF rgbOldBkColor = dc.SetBkColor( ::GetSysColor(COLOR_BTNFACE) );
        COLORREF rgbTextPrev = dc.SetTextColor( ::GetSysColor(COLOR_BTNTEXT) );

        //  Call STR_DTE to paint the string
        RECT rect;
        rect.left =   prect->left   + dxMargin;
        rect.right =  prect->right  - dxMargin - 1;
        rect.top =    prect->top    + CalcTopTextMargin();
        rect.bottom = prect->bottom - CalcBottomTextMargin();
        if ( rect.left <= rect.right )
            STR_DTE::Paint( hdc, &rect );

        //  Restore the old background mode and color for the dc

        dc.SetBkMode( nOldBkMode );
        dc.SetBkColor( rgbOldBkColor );
        dc.SetTextColor( rgbTextPrev );
    }

#endif

}


/*******************************************************************

    NAME:       METALLIC_STR_DTE::QueryLeftMargin

    SYNOPSIS:   Returns the left margin of this DTE

    RETURNS:    The left margin of this DTE

    HISTORY:
        rustanl     22-Jul-1991     Created

********************************************************************/

UINT METALLIC_STR_DTE::QueryLeftMargin() const
{
    return 0;
}


const UINT METALLIC_STR_DTE::_dyTopMargin = 1;
const UINT METALLIC_STR_DTE::_dyBottomMargin = 1;


/*******************************************************************

    NAME:       METALLIC_STR_DTE::CalcTopTextMargin

    SYNOPSIS:   Returns the top text margin

    RETURNS:    The top text margin

    NOTES:      See picture at top of METALLIC_STR_DTE::Paint
                function

    HISTORY:
        rustanl     07-Aug-1991 Created
        beng        08-Nov-1991 Unsigned widths

********************************************************************/

UINT METALLIC_STR_DTE::CalcTopTextMargin()
{
    return _dyTopMargin + 1;
}


/*******************************************************************

    NAME:       METALLIC_STR_DTE::CalcBottomTextMargin

    SYNOPSIS:   Returns the bottom text margin

    RETURNS:    The bottom text margin

    NOTES:      See picture at bottom of METALLIC_STR_DTE::Paint
                function

    HISTORY:
        rustanl     07-Aug-1991 Created
        beng        08-Nov-1991 Unsigned widths

********************************************************************/

UINT METALLIC_STR_DTE::CalcBottomTextMargin()
{
    return _dyBottomMargin + 1;
}


/*******************************************************************

    NAME:       METALLIC_STR_DTE::QueryVerticalMargins

    SYNOPSIS:   Returns the number of pixels taken up by vertical margins
                when the DTE is painted.  No text will be painted in
                these margins.

    RETURNS:    Said value

    HISTORY:
        rustanl     07-Aug-1991 Created
        beng        08-Nov-1991 Unsigned widths

********************************************************************/

UINT METALLIC_STR_DTE::QueryVerticalMargins()
{
    return CalcTopTextMargin() + CalcBottomTextMargin();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltmenu.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    bltmenu.cxx
    This file contains the class definitions for the MENU_BASE,
    POPUP_MENU, and SYSTEM_MENU classes.

    These classes are used to manipulate menus.  The classes are
    structured as follows:

                                MENU_BASE
                                /       \
                              /           \
                         POPUP_MENU   SYSTEM_MENU

    A POPUP_MENU represents any popup menu.  These menus may or may
    not actually be attached to a window.

    A SYSTEM_MENU represents the system menu of a particular window.


    FILE HISTORY:
        KeithMo     12-Oct-1992     Created.

*/

#include "pchblt.hxx"   // Precompiled header


//
//  This is the maximum size allowed for the text in a menu item.
//  This value is used in the NLS_STR form of QueryItemText.
//  If the need ever arises to get more robust, we could allocate
//  a buffer for the string, then grow it as needed until the
//  string will fit into the buffer.
//

#define CCH_MAX_ITEM    1024



//
//  MENU_BASE methods.
//

/*******************************************************************

    NAME:       MENU_BASE :: MENU_BASE

    SYNOPSIS:   MENU_BASE class constructor.

    ENTRY:      hMenu                   - Menu handle, defaults to NULL.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
MENU_BASE :: MENU_BASE( HMENU hMenu )
  : BASE(),
    _hMenu( hMenu )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // MENU_BASE :: MENU_BASE


/*******************************************************************

    NAME:       MENU_BASE :: ~MENU_BASE

    SYNOPSIS:   MENU_BASE class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
MENU_BASE :: ~MENU_BASE( VOID )
{
    _hMenu = NULL;

}   // MENU_BASE :: ~MENU_BASE


/*******************************************************************

    NAME:       MENU_BASE :: W_Append

    SYNOPSIS:   Append worker function, appends a new item onto
                the menu.

    ENTRY:      pItemData               - Contains either a string pointer,
                                          a bitmap handle, or a pointer to
                                          user-defined data.

                ItemIdOrHmenu           - Either a menu item identifier,
                                          or a menu handle (for popups).

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the new item has been appended to the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: W_Append( const VOID * pItemData,
                              UINT_PTR     ItemIdOrHmenu,
                              UINT         nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    APIERR err = NERR_Success;

    if( !::AppendMenu( QueryHandle(),
                       nFlags,
                       ItemIdOrHmenu,
                       (LPCTSTR)pItemData ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // MENU_BASE :: W_Append


/*******************************************************************

    NAME:       MENU_BASE :: W_Insert

    SYNOPSIS:   Insert worker function, inserts a new item into
                the menu.

    ENTRY:      pItemData               - Contains either a string pointer,
                                          a bitmap handle, or a pointer to
                                          user-defined data.

                nPosition               - Specifies the menu item before
                                          which the new item is to be
                                          inserted.

                ItemIdOrHmenu           - Either a menu item identifier,
                                          or a menu handle (for popups).

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the new item has been inserted to the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: W_Insert( const VOID * pItemData,
                              UINT         nPosition,
                              UINT_PTR     ItemIdOrHmenu,
                              UINT         nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    APIERR err = NERR_Success;

    if( !::InsertMenu( QueryHandle(),
                       nPosition,
                       nFlags,
                       ItemIdOrHmenu,
                       (LPCTSTR)pItemData ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // MENU_BASE :: W_Insert


/*******************************************************************

    NAME:       MENU_BASE :: W_Modify

    SYNOPSIS:   Modify worker function, modifies an existing menu item.

    ENTRY:      pItemData               - Contains either a string pointer,
                                          a bitmap handle, or a pointer to
                                          user-defined data.

                idItem                  - The item to modify.

                ItemIdOrHmenu           - Either a menu item identifier,
                                          or a menu handle (for popups).

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the item has been modified.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: W_Modify( const VOID * pItemData,
                              UINT         idItem,
                              UINT_PTR     ItemIdOrHmenu,
                              UINT         nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    APIERR err = NERR_Success;

    if( !::ModifyMenu( QueryHandle(),
                       idItem,
                       nFlags,
                       ItemIdOrHmenu,
                       (LPCTSTR)pItemData ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // MENU_BASE :: W_Modify


/*******************************************************************

    NAME:       MENU_BASE :: W_QueryItemText

    SYNOPSIS:   Worker function for querying the display string of a
                specific menu item.

    ENTRY:      pszBuffer               - Destination buffer for the string.

                cchBuffer               - Size of the desination buffer
                                          (in characters).

                nItem                   - Either the position or the ID
                                          of the item to query.

                nFlags                  - MF_* flags.  Should be either
                                          MF_BYPOSITION or MF_BYCOMMAND.

    RETURNS:    INT                     - Number of characters copied,
                                          not including the terminator.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
INT MENU_BASE :: W_QueryItemText( TCHAR * pszBuffer,
                                  UINT    cchBuffer,
                                  UINT    nItem,
                                  UINT    nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );
    UIASSERT( pszBuffer != NULL );
    UIASSERT( ( nFlags & ~( MF_BYCOMMAND | MF_BYPOSITION ) ) == 0 );

    return (INT)::GetMenuString( QueryHandle(),
                                 nItem,
                                 (LPTSTR)pszBuffer,
                                 (int)cchBuffer,
                                 nFlags );

}   // MENU_BASE :: W_QueryItemText


/*******************************************************************

    NAME:       MENU_BASE :: QueryItemCount

    SYNOPSIS:   Returns the number of items in the popup.

    RETURNS:    INT                     - Number of items in the popup menu.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
INT MENU_BASE :: QueryItemCount( VOID ) const
{
    UIASSERT( QueryHandle() != NULL );

    return (INT)::GetMenuItemCount( QueryHandle() );

}   // MENU_BASE :: QueryItemCount


/*******************************************************************

    NAME:       MENU_BASE :: QueryItemID

    SYNOPSIS:   Returns the ID of a specific menu item.

    ENTRY:      nPosition               - The position of the item to query.

    RETURNS:    UINT                    - The ID of the specified item.
                                          Will be -1L if item was a popup.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
UINT MENU_BASE :: QueryItemID( INT nPosition ) const
{
    UIASSERT( QueryHandle() != NULL );

    return (UINT)::GetMenuItemID( QueryHandle(),
                                  nPosition );

}   // MENU_BASE :: QueryItemID


/*******************************************************************

    NAME:       MENU_BASE :: QueryItemState

    SYNOPSIS:   Returns the state of a specific menu item.

    ENTRY:      nItem                   - Either the position or the ID
                                          of the item to query.

                nFlags                  - MF_* flags.  Should be either
                                          MF_BYPOSITION or MF_BYCOMMAND.

    RETURNS:    UINT                    - The state of the specified item.
                                          Will be -1L if item does not exist.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
UINT MENU_BASE :: QueryItemState( UINT nItem,
                                  UINT nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );
    UIASSERT( ( nFlags & ~( MF_BYCOMMAND | MF_BYPOSITION ) ) == 0 );

    return (UINT)::GetMenuState( QueryHandle(),
                                 nItem,
                                 nFlags );

}   // MENU_BASE :: QueryItemState


/*******************************************************************

    NAME:       MENU_BASE :: QueryItemText

    SYNOPSIS:   Returns the display string of a specific menu item.

    ENTRY:      pszBuffer               - Destination buffer for the string.

                cchBuffer               - Size of the desination buffer
                                          (in characters).

                nItem                   - Either the position or the ID
                                          of the item to query.

                nFlags                  - MF_* flags.  Should be either
                                          MF_BYPOSITION or MF_BYCOMMAND.

    RETURNS:    APIERR                  - NERR_Success if success,
                                          ERROR_NOT_ENOUGH_MEMORY otherwise.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: QueryItemText( TCHAR * pszBuffer,
                                   UINT    cchBuffer,
                                   UINT    nItem,
                                   UINT    nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );
    UIASSERT( pszBuffer != NULL );

    INT cchCopied = W_QueryItemText( pszBuffer,
                                     cchBuffer,
                                     nItem,
                                     nFlags );

    //
    //  The API gives us no easy way to determine the exact
    //  length of the string.  We'll assume that if the number
    //  of characters returned >= cchBuffer-1, then the buffer
    //  size was insufficient.
    //

    return ( cchCopied >= (INT)( cchBuffer - 1 ) ) ? ERROR_NOT_ENOUGH_MEMORY
                                              : NERR_Success;

}   // MENU_BASE :: QueryItemText


/*******************************************************************

    NAME:       MENU_BASE :: QueryItemText

    SYNOPSIS:   Returns the display string of a specific menu item.

    ENTRY:      pnls                    - The NLS_STR that will receive
                                          the text.

                nItem                   - Either the position or the ID
                                          of the item to query.

                nFlags                  - MF_* flags.  Should be either
                                          MF_BYPOSITION or MF_BYCOMMAND.

    RETURNS:    APIERR                  - NERR_Success if success,
                                          ERROR_NOT_ENOUGH_MEMORY otherwise.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: QueryItemText( NLS_STR * pnls,
                                   UINT      nItem,
                                   UINT      nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );
    UIASSERT( pnls != NULL );
    UIASSERT( pnls->QueryError() == NERR_Success );

    //
    //  Allocate some scratch space for the string.
    //

    BLT_SCRATCH scratch( CCH_MAX_ITEM * sizeof(TCHAR) );

    APIERR err = scratch.QueryError();

    if( err == NERR_Success )
    {
        //
        //  Query the string into the scratch buffer.
        //

        err = QueryItemText( (TCHAR *)scratch.QueryPtr(),
                             scratch.QuerySize() / sizeof(TCHAR),
                             nItem,
                             nFlags );
    }

    if( err == NERR_Success )
    {
        //
        //  Copy the scratch buffer into the NLS_STR.
        //

        err = pnls->CopyFrom( (TCHAR *)scratch.QueryPtr() );
    }

    return err;

}   // MENU_BASE :: QueryItemText


/*******************************************************************

    NAME:       MENU_BASE :: QuerySubMenu

    SYNOPSIS:   Returns the handle of a popup-menu within the current
                menu.

    ENTRY:      nPosition               - The position of the popup.

    RETURNS:    HMENU                   - Handle of the popup,
                                          NULL if the specified item
                                          is not a popup.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
HMENU MENU_BASE :: QuerySubMenu( INT nPosition ) const
{
    UIASSERT( QueryHandle() != NULL );

    return ::GetSubMenu( QueryHandle(),
                         nPosition );

}   // MENU_BASE :: QuerySubMenu


/*******************************************************************

    NAME:       MENU_BASE :: Append

    SYNOPSIS:   Append a new item onto the menu.

    ENTRY:      pszName                 - The name (display string) of the
                                          new menu item.

                idNewItem               - Menu ID of the new item.

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the new item has been appended to the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: Append( const TCHAR * pszName,
                            UINT          idNewItem,
                            UINT          nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    return W_Append( (const VOID *)pszName,
                     idNewItem,
                     nFlags );

}   // MENU_BASE :: Append


/*******************************************************************

    NAME:       MENU_BASE :: Append

    SYNOPSIS:   Append a new item onto the menu.

    ENTRY:      pszName                 - The name (display string) of the
                                          new menu item.

                hMenu                   - Menu handle of the new popup menu.

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the new item has been appended to the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: Append( const TCHAR * pszName,
                            HMENU         hMenu,
                            UINT          nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    return W_Append( (const VOID *)pszName,
                     (UINT_PTR)hMenu,
                     nFlags | MF_POPUP );

}   // MENU_BASE :: Append


/*******************************************************************

    NAME:       MENU_BASE :: AppendSeparator

    SYNOPSIS:   Appends a separator onto the menu.

    EXIT:       If successful, the separator has been appended to the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: AppendSeparator( VOID ) const
{
    UIASSERT( QueryHandle() != NULL );

    return W_Append( NULL,
                     0,
                     MF_SEPARATOR );

}   // MENU_BASE :: AppendSeparator


/*******************************************************************

    NAME:       MENU_BASE :: Delete

    SYNOPSIS:   Delete an existing item from the menu.

    ENTRY:      idItem                  - The item to delete.

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the item has been deleted from the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: Delete( UINT idItem,
                            UINT nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    APIERR err = NERR_Success;

    if( !::DeleteMenu( QueryHandle(),
                       idItem,
                       nFlags ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // MENU_BASE :: Delete


/*******************************************************************

    NAME:       MENU_BASE :: Insert

    SYNOPSIS:   Inserts a new item into the menu.

    ENTRY:      pszName                 - The name (display string) of the
                                          new menu item.

                nPosition               - Specifies the menu item before
                                          which the new item is to be
                                          inserted.

                idNewItem               - Menu ID of the new item.

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the new item has been inserted to the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: Insert( const TCHAR * pszName,
                            UINT          nPosition,
                            UINT          idNewItem,
                            UINT          nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    return W_Insert( (const VOID *)pszName,
                     nPosition,
                     idNewItem,
                     nFlags );

}   // MENU_BASE :: Insert


/*******************************************************************

    NAME:       MENU_BASE :: Insert

    SYNOPSIS:   Inserts a new item into the menu.

    ENTRY:      pszName                 - The name (display string) of the
                                          new menu item.

                nPosition               - Specifies the menu item before
                                          which the new item is to be
                                          inserted.

                hMenu                   - Menu handle of the new popup menu.

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the new item has been inserted to the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: Insert( const TCHAR * pszName,
                            UINT          nPosition,
                            HMENU         hMenu,
                            UINT          nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    return W_Insert( (const VOID *)pszName,
                     nPosition,
                     (UINT_PTR)hMenu,
                     nFlags | MF_POPUP );

}   // MENU_BASE :: Insert


/*******************************************************************

    NAME:       MENU_BASE :: InsertSeparator

    SYNOPSIS:   Inserts a separator into the menu.

    ENTRY:      nPosition               - Specifies the menu item before
                                          which the new item is to be
                                          inserted.

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the separator has been inserted to the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: InsertSeparator( UINT nPosition,
                                     UINT nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    return W_Insert( NULL,
                     nPosition,
                     0,
                     nFlags | MF_SEPARATOR );

}   // MENU_BASE :: InsertSeparator


/*******************************************************************

    NAME:       MENU_BASE :: Modify

    SYNOPSIS:   Modifies an existing menu item.

    ENTRY:      pszName                 - The new name (display string)
                                          for the menu item.

                idItem                  - The item to modify.

                idNewItem               - New menu ID for the item.

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the item has been modified.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: Modify( const TCHAR * pszName,
                            UINT          idItem,
                            UINT          idNewItem,
                            UINT          nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    return W_Modify( (const VOID *)pszName,
                     idItem,
                     idNewItem,
                     nFlags );

}   // MENU_BASE :: Modify


/*******************************************************************

    NAME:       MENU_BASE :: Modify

    SYNOPSIS:   Modifies an existing menu item.

    ENTRY:      pszName                 - The new name (display string)
                                          for the menu item.

                idItem                  - The item to modify.

                hMenu                   - New menu handle for the popup.

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the item has been modified.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: Modify( const TCHAR * pszName,
                            UINT          idItem,
                            HMENU         hMenu,
                            UINT          nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    return W_Modify( (const VOID *)pszName,
                     idItem,
                     (UINT_PTR)hMenu,
                     nFlags | MF_POPUP );

}   // MENU_BASE :: Modify


/*******************************************************************

    NAME:       MENU_BASE :: Remove

    SYNOPSIS:   Removes an existing item from the menu.

    ENTRY:      idItem                  - The item to remove.

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the item has been removed from the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: Remove( UINT idItem,
                            UINT nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    APIERR err = NERR_Success;

    if( !::RemoveMenu( QueryHandle(),
                       idItem,
                       nFlags ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // MENU_BASE :: Remove


/*******************************************************************

    NAME:       MENU_BASE :: CheckItem

    SYNOPSIS:   Checks/unchecks the specified menu item.

    ENTRY:      idItem                  - The item to check/uncheck.

                fCheck                  - Check item if TRUE,
                                          uncheck if FALSE.

                nFlags                  - Various & sundry MF_* menu flags.

    RETURNS:    UINT                    - Previous item state,
                                          -1 if item does not exist.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
UINT MENU_BASE :: CheckItem( UINT idItem,
                             BOOL fCheck,
                             UINT nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    if( fCheck )
    {
        nFlags |= MF_CHECKED;
    }
    else
    {
        nFlags &= ~MF_CHECKED;
    }

    return (UINT)::CheckMenuItem( QueryHandle(),
                                  idItem,
                                  nFlags );

}   // MENU_BASE :: CheckItem


/*******************************************************************

    NAME:       MENU_BASE :: EnableItem

    SYNOPSIS:   Enables/disables the specified menu item.

    ENTRY:      idItem                  - The item to check/uncheck.

                fEnable                 - Enable item if TRUE,
                                          disable if FALSE.

                nFlags                  - Various & sundry MF_* menu flags.

    RETURNS:    UINT                    - Previous item state,
                                          -1 if item does not exist.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
UINT MENU_BASE :: EnableItem( UINT idItem,
                              BOOL fEnable,
                              UINT nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    if( fEnable )
    {
        nFlags &= ~( MF_GRAYED | MF_DISABLED );
    }
    else
    {
        nFlags |= ( MF_GRAYED | MF_DISABLED );
    }

    return (UINT)::EnableMenuItem( QueryHandle(),
                                  idItem,
                                  nFlags );

}   // MENU_BASE :: EnableItem


/*******************************************************************

    NAME:       MENU_BASE :: IsPopup

    SYNOPSIS:   Determine if a particular menu item invokes a popup.

    ENTRY:      nPosition               - The relative position of the
                                          item in question.

    RETURNS:    BOOL                    - TRUE if the item invokes a popup,
                                          FALSE otherwise.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
BOOL MENU_BASE :: IsPopup( INT nPosition ) const
{
    UIASSERT( QueryHandle() != NULL );

    return (BOOL)( QuerySubMenu( nPosition ) != NULL );

}   // MENU_BASE :: IsPopup


/*******************************************************************

    NAME:       MENU_BASE :: IsSeparator

    SYNOPSIS:   Determine if a particular menu item is a separator.

    ENTRY:      nPosition               - The relative position of the
                                          item in question.

    RETURNS:    BOOL                    - TRUE if the item is a separator,
                                          FALSE otherwise.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
BOOL MENU_BASE :: IsSeparator( INT nPosition ) const
{
    UIASSERT( QueryHandle() != NULL );

    UINT nState = QueryItemState( nPosition, MF_BYPOSITION );

    return (BOOL)( ( nState & MF_SEPARATOR ) != 0 );

}   // MENU_BASE :: IsSeparator



//
//  POPUP_MENU methods.
//

/*******************************************************************

    NAME:       POPUP_MENU :: POPUP_MENU

    SYNOPSIS:   POPUP_MENU class constructor.  Creates a new (empty)
                popup menu.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
POPUP_MENU :: POPUP_MENU( VOID )
  : MENU_BASE()
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    //
    //  Create a new popup.
    //

    HMENU hMenu = ::CreatePopupMenu();

    if( hMenu == NULL )
    {
        //
        //  CreatePopupMenu failed.  Probably out of memory.
        //

        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        //
        //  We have a popup.  Finish construction.
        //

        err = CtAux( hMenu );

        if( err != NERR_Success )
        {
            //
            //  Something failed during construction.  Nuke
            //  the popup.
            //

            ::DestroyMenu( hMenu );
        }
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // POPUP_MENU :: POPUP_MENU


/*******************************************************************

    NAME:       POPUP_MENU :: POPUP_MENU

    SYNOPSIS:   POPUP_MENU class constructor.  Loads a menu from
                a resource template.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
POPUP_MENU :: POPUP_MENU( IDRESOURCE & id )
  : MENU_BASE()
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    //
    //  Load the menu.
    //

    HMODULE hMod = BLT::CalcHmodRsrc( id );
    UIASSERT( hMod != NULL );

    HMENU hMenu = ::LoadMenu( hMod, id.QueryPsz() );

    if( hMenu == NULL )
    {
        //
        //  LoadMenu failed.
        //

        err = (APIERR)::GetLastError();
    }
    else
    {
        //
        //  Popup loaded.  Finish construction.
        //

        err = CtAux( hMenu );

        if( err != NERR_Success )
        {
            //
            //  Something failed during construction.  Nuke
            //  the popup.
            //

            ::DestroyMenu( hMenu );
        }
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // POPUP_MENU :: POPUP_MENU


/*******************************************************************

    NAME:       POPUP_MENU :: POPUP_MENU

    SYNOPSIS:   POPUP_MENU class constructor.  Aliases an existing
                menu.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
POPUP_MENU :: POPUP_MENU( HMENU hMenu )
  : MENU_BASE()
{
    UIASSERT( hMenu != NULL );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = CtAux( hMenu );

    if( err != NERR_Success )
    {
        //
        //  Something failed during construction.
        //

        ReportError( err );
        return;
    }

}   // POPUP_MENU :: POPUP_MENU


/*******************************************************************

    NAME:       POPUP_MENU :: POPUP_MENU

    SYNOPSIS:   POPUP_MENU class constructor.  Aliases a window's
                menu.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
POPUP_MENU :: POPUP_MENU( const PWND2HWND & wnd )
  : MENU_BASE()
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    HMENU hMenu = ::GetMenu( wnd.QueryHwnd() );
    UIASSERT( hMenu != NULL );

    APIERR err = CtAux( hMenu );

    if( err != NERR_Success )
    {
        //
        //  Something failed during construction.
        //

        ReportError( err );
        return;
    }

}   // POPUP_MENU :: POPUP_MENU


/*******************************************************************

    NAME:       POPUP_MENU :: ~POPUP_MENU

    SYNOPSIS:   POPUP_MENU class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
POPUP_MENU :: ~POPUP_MENU( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // POPUP_MENU :: ~POPUP_MENU


/*******************************************************************

    NAME:       POPUP_MENU :: CtAux

    SYNOPSIS:   Constructor helper method.

    ENTRY:      hMenu                   - The new menu handle.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR POPUP_MENU :: CtAux( HMENU hMenu )
{
    UIASSERT( hMenu != NULL );

    //
    //  Not much to do here (yet).
    //

    SetHandle( hMenu );

    return NERR_Success;

}   // POPUP_MENU :: CtAux


/*******************************************************************

    NAME:       POPUP_MENU :: Destroy

    SYNOPSIS:   Destroys the current menu.

    EXIT:       The menu is destroyed, and the saved _hMenu is set
                to NULL.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR POPUP_MENU :: Destroy( VOID )
{
    UIASSERT( QueryHandle() != NULL );

    APIERR err = NERR_Success;

    //
    //  Destroy the menu.
    //

    if( !::DestroyMenu( QueryHandle() ) )
    {
        //
        //  The destroy failed, get the error code.
        //

        err = (APIERR)::GetLastError();
    }
    else
    {
        //
        //  Destroy successful, clear the handle.
        //

        SetHandle( NULL );
    }

    return err;

}   // POPUP_MENU :: Destroy


/*******************************************************************

    NAME:       POPUP_MENU :: Attach

    SYNOPSIS:   Attaches this POPUP_MENU object to a given window.

    ENTRY:      wnd                     - Either an HWND or APP_WINDOW *
                                          representing the target window.

    EXIT:       The current menu is destroyed, replaced by the given
                window's menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR POPUP_MENU :: Attach( const PWND2HWND & wnd )
{
    UIASSERT( QueryHandle() != NULL );

    //
    //  Get the window's menu handle.
    //

    HMENU hMenu = ::GetMenu( wnd.QueryHwnd() );
    UIASSERT( hMenu != NULL );

    //
    //  Destroy the menu.
    //

    APIERR err = Destroy();

    if( err == NERR_Success )
    {
        //
        //  Destroy successful, set the menu handle
        //  to the handle retrieved from the window.
        //

        SetHandle( hMenu );
    }

    return err;

}   // POPUP_MENU :: Attach


/*******************************************************************

    NAME:       POPUP_MENU :: Track

    SYNOPSIS:   Tracks a popup menu.  Used for "floating" menus.

    ENTRY:      wnd                     - Either an HWND or APP_WINDOW *
                                          representing the target window.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR POPUP_MENU :: Track( const PWND2HWND & wnd,
                            UINT              nFlags,
                            INT               x,
                            INT               y,
                            const RECT      * pRect ) const
{
    UIASSERT( QueryHandle() != NULL );

    APIERR err = NERR_Success;

    if( !::TrackPopupMenu( QueryHandle(),
                           nFlags,
                           x, y,
                           0,
                           wnd.QueryHwnd(),
                           pRect ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // POPUP_MENU :: Attach



//
//  SYSTEM_MENU methods.
//

/*******************************************************************

    NAME:       SYSTEM_MENU :: SYSTEM_MENU

    SYNOPSIS:   SYSTEM_MENU class constructor.  Creates an alias for
                a given window's system menu.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
SYSTEM_MENU :: SYSTEM_MENU( const PWND2HWND & wnd )
  : MENU_BASE()
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Get the system menu.
    //

    HMENU hMenu = ::GetSystemMenu( wnd.QueryHwnd(), FALSE );
    UIASSERT( hMenu != NULL );

    //
    //  Save it away.
    //

    SetHandle( hMenu );

}   // SYSTEM_MENU :: SYSTEM_MENU


/*******************************************************************

    NAME:       SYSTEM_MENU :: ~SYSTEM_MENU

    SYNOPSIS:   SYSTEM_MENU class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
SYSTEM_MENU :: ~SYSTEM_MENU( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // SYSTEM_MENU :: ~SYSTEM_MENU
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltmisc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltmisc.cxx
    Misc BLT windows definitions

    FILE HISTORY:
        rustanl     20-Nov-1990 Created
        beng        11-Feb-1991 Uses lmui.hxx
        rustanl     06-Mar-1991 Fixed up atom classes; made PROC_INSTANCE
                                        inherit from BASE
        rustanl     07-Mar-1991 Improved ATOM_BASE hierarchy
        rustanl     12-Mar-1991 Added CURSOR and AUTO_CURSOR
        beng        14-May-1991 Exploded blt.hxx into components;
                                        removed TABSTOP objects
        beng        09-Jul-1991 Added implementation of ACCELTABLE
        terryk      18-Jul-1991 Add more functions to DEVICE_CONTEXT
                                SetBkColor, SetTextColor, SetTextAlign,
                                and ExtTextOut
        terryk      20-Jul-1991 Add _fRelease to DISPLAY_CONTEXT
                                Add one more constructor in DISPLAY_CONTEXT
        rustanl     07-Aug-1991 Added SOLID_BRUSH
        rustanl     29-Aug-1991 ACCELTABLE ct now takes const TCHAR *
        beng        30-Sep-1991 PROC_INSTANCE removed elsewhere
        beng        30-Mar-1992 Outlined a couple more functions
        beng        28-Jul-1992 Add reference to hmodBlt
        KeithMo     07-Aug-1992 STRICTified.
*/
#include "pchblt.hxx"   // Precompiled header

/*******************************************************************

    NAME:       DEVICE_CONTEXT::DrawRect

    SYNOPSIS:   Draw a rectangle with the given attributes of the device
                context.

    ENTRY:      lpRect - pointer to rectangle to draw the focus rect

    NOTES:      See SDK help file for detail.

    HISTORY:
        Johnl       09-Sep-1991  Created
        beng        22-Jul-1992 "top" and "right" args swapped

********************************************************************/

VOID DEVICE_CONTEXT::DrawRect( const RECT * pRect ) const
{
    ::Rectangle(_hDC, pRect->left, pRect->top, pRect->right, pRect->bottom);
}


/*******************************************************************

    NAME:       DEVICE_CONTEXT::DrawFocusRect

    SYNOPSIS:   Draw the official windows focus rectangle.  This is an
                xor operation, so call once to put on, and another time
                to take off.

    ENTRY:      lpRect - pointer to rectangle to draw the focus rect

    NOTES:      See SDK help file for detail.

    HISTORY:
        Johnl       09-Sep-1991 Created
        beng        04-Oct-1991 Additional const parms

********************************************************************/

VOID DEVICE_CONTEXT::DrawFocusRect( const RECT * pRect ) const
{
    ::DrawFocusRect( _hDC, (RECT*)pRect );
}


/*******************************************************************

    NAME:       DEVICE_CONTEXT::FrameRect

    SYNOPSIS:   Draw an unfilled rectangle using the passed brush

    ENTRY:      lpRect - pointer to rectangle to draw the focus rect

    NOTES:      See SDK help file for detail.

    HISTORY:
        Johnl       12-Sep-1991 Created
        beng        04-Oct-1991 Additional const parms

********************************************************************/

VOID DEVICE_CONTEXT::FrameRect( const RECT * pRect, HBRUSH hBrush ) const
{
    ::FrameRect( _hDC, (RECT*)pRect, hBrush );
}


/**********************************************************************

    NAME:       DEVICE_CONTEXT::InvertRect

    SYNOPSIS:   Invert the color within a rectangle

    ENTRY:      LPRECT - pointer to the given rectangle data structure

    NOTES:      See SDK help file for detail

    HISTORY:
        terryk      10-Apr-1991 creation
        beng        04-Oct-1991 Additional const parms

**********************************************************************/

VOID DEVICE_CONTEXT::InvertRect( const RECT * pRect ) const
{
   ::InvertRect( _hDC, (RECT*)pRect );
}


#if 0 // polygon methods have been disabled

/*********************************************************************

   NAME:       DEVICE_CONTEXT::SetPolyFillMode

   SYNOPSIS:   set the polygon filling method

   ENTRY:      INT nPolyFillMode - either ALTERNATE oe WINDING

   NOTES:      See SDK help file for detail

   HISTORY:
        terryk      10-Apr-1991 creation
        beng        09-Oct-1991 Disabled

*********************************************************************/

INT DEVICE_CONTEXT::SetPolyFillMode( INT nPolyFillMode )
{
   return ( ::SetPolyFillMode( _hDC, nPolyFillMode ));
}


/**********************************************************************

    NAME:       DEVICE_CONTEXT::GetPolyFillMode

    SYNOPSIS:   get the current polygon fill mode

    RETURN:     return either ALTERNATE OR WINDING

    NOTES:      See SDK help file for detail

    HISTORY:
        terryk      10-Apr-1991 creation
        beng        09-Oct-1991 Disabled

***********************************************************************/

INT DEVICE_CONTEXT::GetPolyFillMode() const
{
    return( ::GetPolyFillMode( _hDC ));
}


/**********************************************************************

    NAME:       DEVICE_CONTEXT::Polygon

    SYNOPSIS:   build the polgyon and fill it out

    ENTRY:      POINT * pxyPoly - the points of the polygon
                INT     cxy     - nunber of vertices

    NOTES:      See SDK help file for detail

    HISTORY:
        terryk      10-Apr-1991 Creation
        beng        09-Oct-1991 Disabled

**********************************************************************/

BOOL DEVICE_CONTEXT::Polygon( POINT * pxyPoly, INT cxy ) const
{
    return( ::Polygon( _hDC, pxyPoly, cxy ));
}

#endif // disabled


/**********************************************************************

    NAME:       DEVICE_CONTEXT::SetTextAlign

    SYNOPSIS:   set the text alignment flags for the given device context

    ENTRY:      flag to be set. Specifies a mask of the values in the
                following list. Only one flag may be chosen from those that
                affect horizontal an dvertical alignment. In addition, only
                one of the two flags that alter the current position can be
                chosen:
                    TA_BASELINE
                    TA_BOTTOM
                    TA_CENTER
                    TA_LEFT
                    TA_NOUPDATECP
                    TA_RIGHT
                    TA_TOP
                    TA_UPDATECP
                The defaults are TA_LEFT, TA_TOP, and TA_NOUPDATECP

    RETURN:     the original wFlags

    HISTORY:
        terryk      18-Jul-91   Created
        beng        04-Oct-1991 Win32 conversion

**********************************************************************/

UINT DEVICE_CONTEXT::SetTextAlign( UINT wFlag )
{
    return( ::SetTextAlign( _hDC, wFlag ));
}


/*********************************************************************

    NAME:       DEVICE_CONTEXT::ExtTextOut

    SYNOPSIS:   write a character string to the specified
                display and position

    ENTRY:      INT x     - x-coordinate
                INT y     - y-coordinate
                WORD wOption - option, any combination of
                        ETO_CLIPPED
                        ETO_OPAQUE
                pRect     - the specified location
                pszString - the display string
                cch       - count of chars
                lpDx      - points to an array of values that indicate the
                             distance between origins of adjacent character
                             cells.

    RETURN:     TRUE if string is drawn

    HISTORY:
        terryk      18-Jul-91   Created
        beng        09-Oct-1991 Win32 conversion

*********************************************************************/

BOOL DEVICE_CONTEXT::ExtTextOut( INT x, INT y, UINT nOptions,
                                 const RECT * prect,
                                 const TCHAR * pszString,
                                 INT cch, INT *pDx )
{
    return( ::ExtTextOut( _hDC, x, y, nOptions, prect,
                          pszString, cch, pDx ));
}


/**********************************************************************

    NAME:       DEVICE_CONTEXT::QueryTextExtent

    SYNOPSIS:   This method computes the width and height in
                logical units of the line of text pointed to by psz.

    ENTRY:
        nls         String reference
            - or -
        psz         Pointer to a string
        cch         Length (NOT size) of string pointed to by psz, in TCHARs

    RETURN:
        Ax XYDIMENSION object

    NOTES:
        For more information, please consult the GetTextExtent description
        in the Windows SDK.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        15-May-1991 Returns a DIMENSION object
        beng        09-Oct-1991 Unicode fixes
        beng        17-Oct-1991 Win32 conversion
        beng        05-May-1992 API changes

**********************************************************************/

XYDIMENSION DEVICE_CONTEXT::QueryTextExtent( const TCHAR * psz,
                                             UINT cch ) const
{
    UIASSERT( _hDC != NULL );

#if defined(WIN32)
    SIZE size;
    ::GetTextExtentPoint( _hDC, (TCHAR*)psz, cch, &size );
    return XYDIMENSION(size);
#else
    ULONG ul = ::GetTextExtent( _hDC, (TCHAR*)psz, cch );
    return XYDIMENSION(ul);
#endif
}

XYDIMENSION DEVICE_CONTEXT::QueryTextExtent( const NLS_STR &nls ) const
{
    return QueryTextExtent(nls.QueryPch(), nls.QueryTextLength());
}


/**********************************************************************

    NAME:       DEVICE_CONTEXT::QueryTextMetrics

    SYNOPSIS:   Fills the given buffer with the metrics of the selected font.

    ENTRY:
       ptm      A pointer to a TEXTMETRIC structure.

    RETURNS:
       TRUE on success, FALSE otherwise

    NOTES:      See the Windows SDK for a description of
                the TEXTMETRIC structure.

    HISTORY:
        rustanl     20-Nov-1990     Created

***********************************************************************/

BOOL DEVICE_CONTEXT::QueryTextMetrics( TEXTMETRIC * ptm ) const
{
    UIASSERT(ptm != NULL);
    return ::GetTextMetrics( _hDC, ptm );
}


/*******************************************************************

    NAME:       DEVICE_CONTEXT::QueryFontHeight

    SYNOPSIS:   Returns the height metric of the current font

    RETURNS:    Height in logical units (0 if error)

    NOTES:
        Ad hoc, yet convenient.

        This ia a fairly expensive call; the client should cache
        its returned value.

    HISTORY:
        beng        10-Jul-1991     Created

********************************************************************/

INT DEVICE_CONTEXT::QueryFontHeight() const
{
    TEXTMETRIC tm;
    if (!QueryTextMetrics(&tm))
        return 0;

    return tm.tmHeight;
}


/*******************************************************************

    NAME:       DEVICE_CONTEXT::QueryAveCharWidth

    SYNOPSIS:   Returns the average-width metric of the current font

    RETURNS:    Width in logical units (0 if error)

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

INT DEVICE_CONTEXT::QueryAveCharWidth() const
{
    TEXTMETRIC tm;
    if (!QueryTextMetrics(&tm))
        return 0;

    return tm.tmAveCharWidth;
}


/*******************************************************************

    NAME:       DEVICE_CONTEXT::TextOut

    SYNOPSIS:   Writes a character string on a device

    ENTRY:
        nls         - NLS string
           or
        psz, cb     - pointer to a character string, and its byte count

        xLeft, yTop - position at which to start the string
           or
        xy

        prectClip   - rectangle within which to clear and clip


    RETURNS:    TRUE if string successfully written

    NOTES:

    HISTORY:
        beng        10-Jul-1991 Created
        beng        04-Oct-1991 Additional const args
        beng        01-May-1992 API changes

********************************************************************/

BOOL DEVICE_CONTEXT::TextOut( const TCHAR * psz, INT cch,
                              INT xLeft, INT yTop ) const
{
    return ::TextOut( _hDC, xLeft, yTop, psz, cch );
}


BOOL DEVICE_CONTEXT::TextOut( const NLS_STR &nls, XYPOINT xy ) const
{
    return ::TextOut( _hDC, xy.QueryX(), xy.QueryY(),
                      nls.QueryPch(), nls.QueryTextLength() );
}


BOOL DEVICE_CONTEXT::TextOut( const TCHAR * psz, INT cch,
                              INT xLeft, INT yTop,
                              const RECT * prcClip ) const
{
    return ::ExtTextOut( _hDC, xLeft, yTop, ETO_CLIPPED|ETO_OPAQUE,
                         prcClip, psz, cch, NULL);
}


BOOL DEVICE_CONTEXT::TextOut( const NLS_STR &nls,
                              XYPOINT xy,
                              const RECT * prcClip ) const
{
    return ::ExtTextOut( _hDC, xy.QueryX(), xy.QueryY(),
                         ETO_CLIPPED|ETO_OPAQUE,
                         prcClip, nls.QueryPch(),
                         nls.QueryTextLength(), NULL);
}


/**********************************************************************

    NAME:       DEVICE_CONTEXT::BitBlt

    SYNOPSIS:   Wrapper for Win BITBLT function.
                Moves a bitmap from the named source DC to
                the current DC.

    RETURN:     TRUE if bitmap is drawn; FALSE otherwise.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        10-Jul-1991 Update parms
        beng        04-Oct-1991 Additional const parms

**********************************************************************/

BOOL DEVICE_CONTEXT::BitBlt( INT xDest,   INT yDest,
                             INT dxWidth, INT dyHeight,
                       const DEVICE_CONTEXT & dcSource,
                             INT xSrc,    INT ySrc,
                             ULONG ulRasterOperation )
{
    return ::BitBlt( _hDC,
                     xDest,
                     yDest,
                     dxWidth,
                     dyHeight,
                     dcSource.QueryHdc(),
                     xSrc,
                     ySrc,
                     ulRasterOperation );
}

BOOL DEVICE_CONTEXT::BitBlt( const XYPOINT &  xyDest,
                             XYDIMENSION      dxyDest,
                       const DEVICE_CONTEXT & dcSource,
                             const XYPOINT &  xySource,
                             ULONG ulRasterOperation )
{
    return ::BitBlt( _hDC,
                     xyDest.QueryX(),
                     xyDest.QueryY(),
                     dxyDest.QueryWidth(),
                     dxyDest.QueryHeight(),
                     dcSource.QueryHdc(),
                     xySource.QueryX(),
                     xySource.QueryY(),
                     ulRasterOperation );
}


/**********************************************************************

    NAME:       DISPLAY_CONTEXT::DISPLAY_CONTEXT

    SYNOPSIS:   Make a DC corresponding to a window

    ENTRY:      pwnd - pointer to window
            or
                hwnd - Win handle

    HISTORY:
        rustanl     20-Nov-1990     Created
        terryk      20-Jul-1991     Add a constructor which take WINDOW *
                                    and DC all together.
                                    Also, add _fRelaseDC boolean

**********************************************************************/

DISPLAY_CONTEXT::DISPLAY_CONTEXT( HWND hwnd )
    : DEVICE_CONTEXT( ::GetDC(hwnd) ),
    _fReleaseDC( TRUE )
{
    _hwnd = hwnd;
}

DISPLAY_CONTEXT::DISPLAY_CONTEXT( WINDOW * pwnd )
    : DEVICE_CONTEXT( ::GetDC( pwnd->QueryHwnd() ) ),
    _fReleaseDC( TRUE )
{
    _hwnd = pwnd->QueryHwnd();
}

DISPLAY_CONTEXT::DISPLAY_CONTEXT( WINDOW * pwnd, HDC hdc )
    : DEVICE_CONTEXT( hdc ),
    _fReleaseDC( FALSE )
{
    _hwnd = pwnd->QueryHwnd();
}


/*********************************************************************

   NAME:       DISPLAY_CONTEXT::~DISPLAY_CONTEXT

   SYNOPSIS:   destructor of display context

   NOTES:      if _fReleaseDC is TRUE, release the dc, otherwise keep it.

   HISTORY:
      rustanl   20-Nov-1990     Created
      terryk    20-Jul-1991 Add _fReleaseDC boolean

*********************************************************************/

DISPLAY_CONTEXT::~DISPLAY_CONTEXT()
{
    if ( _fReleaseDC )
        ::ReleaseDC( _hwnd, QueryHdc() );
}


/**********************************************************************

   NAME:       DISPLAY_CONTEXT::QueryTextWidth

   SYNOPSIS:   return the width of the given string with the given length

   ENTRY:      PSZ - the given string
               UINT - the given length of the string

   RETURN:     return the text width of the given string

   HISTORY:
        terryk      4-Apr-1991  Creation
        beng        15-May-1991 Fix parms
        beng        14-Oct-1991 Unicode fixes
        beng        01-May-1992 API changes

**********************************************************************/

INT DISPLAY_CONTEXT::QueryTextWidth( const TCHAR * psz, UINT cch ) const
{
    RECT rectRect;

    ::GetClientRect( _hwnd, &rectRect );
    ::DrawText( QueryHdc(), (TCHAR*)psz, cch, &rectRect, DT_CALCRECT );

    return( rectRect.right - rectRect.left + 1 );
}

INT DISPLAY_CONTEXT::QueryTextWidth( const NLS_STR & nls ) const
{
    return QueryTextWidth(nls.QueryPch(), nls.QueryTextLength());
}


/*********************************************************************

    NAME:       SCREEN_DC::SCREEN_DC

    SYNOPSIS:   constructor

    NOTES:      call the GetDC with NULL parameter to get the screen HDC
                and pass it to DEVICE_CONTEXT

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

SCREEN_DC::SCREEN_DC()
    : DEVICE_CONTEXT( ::GetDC( NULL ))
{
    // Nothing else to do...
}


/*********************************************************************

    NAME:       SCREEN_DC::~SCREEN_DC

    SYNOPSIS:   destructor - release the dc.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

SCREEN_DC::~SCREEN_DC()
{
    ::ReleaseDC( NULL, QueryHdc() );
}


/*********************************************************************

    NAME:       MEMORY_DC::MEMORY_DC

    SYNOPSIS:   memory DC constructor

    ENTRY:      DEVICE_CONTEX &dc - device context to build
                compatibleDC

    NOTES:      Call createCamptibleDC to create another DC and pass
                the dc to DEVICE_CONTEXT

    HISTORY:
                rustanl 20-Nov-1990     Created

*********************************************************************/

MEMORY_DC::MEMORY_DC( DEVICE_CONTEXT & dc )
    : DEVICE_CONTEXT( ::CreateCompatibleDC( dc.QueryHdc() ))
{
    //  nothing to do here
}


/*********************************************************************

    NAME:       MEMORY_DC::~MEMORY_DC

    SYNOPSIS:   destructor - delete the dc

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

MEMORY_DC::~MEMORY_DC()
{
    ::DeleteDC( QueryHdc() );
}


/*********************************************************************

    NAME:       ATOM_BASE::ATOM_BASE

    SYNOPSIS:   constructor

    ENTRY:      nothing
                OR
                ATOM hAtom to create a compatible DC

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

ATOM_BASE::ATOM_BASE()
    :   _hAtom( NULL )
{
    //  nothing else to do
}


ATOM_BASE::ATOM_BASE( ATOM hAtom )
    :   _hAtom( hAtom )
{
    //  nothing else to do
}


/*********************************************************************

    NAME:       ATOM_BASE::~ATOM_BASE

    SYNOPSIS:   destructor

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

ATOM_BASE::~ATOM_BASE()
{
    _hAtom = NULL;
}


/**********************************************************************

    NAME:       ATOM_BASE::AssignAux

    SYNOPSIS:   Assign a new atom handle to the atom object.

       This protected method assumes that the currently stored atom
       handle can be overwritten, i.e., the caller first deleted this
       atom, if applicable.

    ENTRY:
       pch      Pointer to new string to be assigned.  May be NULL.
                If NULL, the atom treats it like the empty string,
                and guarantees that the assignment operation will succeed.

    RETURN:     pch, as passed in (i.e., the right hand sign of the op=)

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        07-Nov-1991 Error mapping

**********************************************************************/

const TCHAR * ATOM_BASE::AssignAux( const TCHAR * pch )
{
    _hAtom = NULL;
    if ( pch != NULL )
    {
        _hAtom = W_AddAtom( pch );
        if ( _hAtom == NULL )
        {
            ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
            return pch;
        }
    }

    ResetError();

    return pch;
}


/*********************************************************************

    NAME:       ATOM_BASE::QueryString

    SYNOPSIS:   Copies the string stored in the atom to the given buffer.

    ENTRY:
      pchBuffer     Pointer to buffer of size cbBuf
      cbBuf                 Size of buffer pointed to by pchBuffer

    RETURN:     An error value, which is NERR_Success on success.

    NOTES:
      Due to shortcomings in the Windows API, this method can not (easily)
      determine whether or not the given buffer was big enough.

    HISTORY:
      rustanl   20-Nov-1990 Created
      beng      04-Oct-1991 Win32 conversion

*********************************************************************/

APIERR ATOM_BASE::QueryString( TCHAR * pchBuffer, UINT cbBuf ) const
{
    UIASSERT( QueryError() == NERR_Success );

    if ( cbBuf == 0 )
        return NERR_BufTooSmall;

    if ( QueryHandle() == NULL )
    {
        //  Note, we already checked for buffer size of 0
        pchBuffer[ 0 ] = TCH('\0');
        return NERR_Success;
    }

    return W_QueryString( pchBuffer, cbBuf );
}


/*********************************************************************

    NAME:       GLOBAL_ATOM::GLOBAL_ATOM

    SYNOPSIS:
      This constructor first (implicitly) constructs an ATOM_BASE with
      a NULL handle.  Then, it checks the superclass for errors.        If
      none, it assigns pch as the string in this atom.

    ENTRY:
      pch       Pointer to string with which to set the atom.  If it is
              NULL, it is treated like the empty string is is guaranteed
              to succeed.

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

GLOBAL_ATOM::GLOBAL_ATOM( const TCHAR * pch )
{
    if ( QueryError() != NERR_Success )
        return;

    AssignAux( pch );
}


/*********************************************************************

    NAME:       GLOBAL_ATOM::~GLOBAL_ATOM

    SYNOPSIS:   This destructor deletes the atom unless the atom handle is NULL.

    HISTORY:
      rustanl   20-Nov-1990     Created
      KeithMo   13-Sep-1992     Delete the atom if the handle is *NOT* NULL...

*********************************************************************/

GLOBAL_ATOM::~GLOBAL_ATOM()
{
    if ( QueryHandle() != NULL )
    {
        REQUIRE( ::GlobalDeleteAtom( QueryHandle()) == NULL );
    }
}


/*********************************************************************

    NAME:       GLOBAL_ATOM::operator=

    SYNOPSIS:   This method is used to assign a new string to the object.
      The method first deletes the previous atom, if any, and then
      assigns the new one.

    ENTRY:
      pch       Pointer to string with which to set the atom.  If it is
              NULL, it is treated like the empty string is is guaranteed
              to succeed.

    RETURN:
      pch, as it was passed in (i.e., the right hand side of op=)

    NOTES:

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

const TCHAR * GLOBAL_ATOM::operator=( const TCHAR * pch )
{
    //  First, delete the old atom, if any
    if ( QueryHandle() != NULL )
    {
        REQUIRE( ::GlobalDeleteAtom( QueryHandle()) == NULL );
    }

    //  Set the new atom
    return AssignAux( pch );
}


/*********************************************************************

    NAME:       GLOBAL_ATOM::W_AddAtom

    SYNOPSIS:
      This virtual replacement worker routine calls out to the Windows API
      to add the atom.

    ENTRY:
      pch       Pointer to string to be added as an atom.  It must not
              be NULL.

    RETURN:
      The atom handle of the newly added atom.  On failure, this handle
      is NULL.

    NOTES:
      This method does not use any data member of the object.  Rather,
      the caller (the ATOM_BASE class) will modify the object accordingly.

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

ATOM GLOBAL_ATOM::W_AddAtom( const TCHAR * pch ) const
{
    UIASSERT( pch != NULL );

    return ::GlobalAddAtom( (TCHAR *)pch );
}


/*********************************************************************

    NAME:       GLOBAL_ATOM::W_QueryString

    SYNOPSIS:   Calls the Windows API to retrieve a string corresponding
                to an atom.

    ENTRY:
      pchBuffer Pointer to buffer which receives the atom string.
      cbBuf     Size of buffer pointed to by pchBuffer.  This size
                must be positive.

    RETURN:     An error value, which is NERR_Success on success.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        04-Oct-1991 Win32 conversion
        beng        07-Nov-1991 Error mapping
        beng        01-May-1992 API changes

*********************************************************************/

APIERR GLOBAL_ATOM::W_QueryString( TCHAR * pchBuffer, UINT cbBuf ) const
{
    UINT cchCopied = ::GlobalGetAtomName( QueryHandle(),
                                          pchBuffer, cbBuf/sizeof(TCHAR) );
    if ( cchCopied == 0 )
        return BLT::MapLastError(ERROR_GEN_FAILURE);

    return NERR_Success;
}


/*********************************************************************

    NAME:       LOCAL_ATOM::LOCAL_ATOM

    SYNOPSIS:   First, implicitly constructs an ATOM_BASE with
                a NULL handle.  Then, it checks the superclass for errors.
                If none, it assigns pch as the string in this atom.

    ENTRY:
      pch       Pointer to string with which to set the atom.  If it is
              NULL, it is treated like the empty string is is guaranteed
              to succeed.

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

LOCAL_ATOM::LOCAL_ATOM( const TCHAR * pch )
{
    if ( QueryError() != NERR_Success )
        return;

    AssignAux( pch );
}


/*********************************************************************

    NAME:       LOCAL_ATOM::~LOCAL_ATOM

    SYNOPSIS:   This destructor deletes the atom unless the atom handle is NULL.

    HISTORY:
      rustanl   20-Nov-1990     Created
      KeithMo   13-Sep-1992     Delete the atom if the handle is *NOT* NULL...

*********************************************************************/

LOCAL_ATOM::~LOCAL_ATOM()
{
    if ( QueryHandle() != NULL )
    {
        REQUIRE( ::DeleteAtom( QueryHandle()) == NULL );
    }
}


/*********************************************************************

    NAME:       LOCAL_ATOM::operator=

    SYNOPSIS:
      This method is used to assign a new string to the object.

      The method first deletes the previous atom, if any, and then
      assigns the new one.

    ENTRY:
      pch       Pointer to string with which to set the atom.  If it is
              NULL, it is treated like the empty string is is guaranteed
              to succeed.

    RETURN:     pch, as it was passed in (i.e., the right hand side of op=)

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

const TCHAR * LOCAL_ATOM::operator=( const TCHAR * pch )
{
    //  First, delete the old atom, if any
    if ( QueryHandle() != NULL )
    {
        REQUIRE( ::DeleteAtom( QueryHandle()) == NULL );
    }

    //  Set the new atom
    return AssignAux( pch );
}


/*********************************************************************

    NAME:       LOCAL_ATOM::W_AddAtom

    SYNOPSIS:   This virtual replacement worker routine calls out to the
                Windows API to add the atom.

    ENTRY:
      pch       Pointer to string to be added as an atom.  It must not
              be NULL.

    RETURN:
      The atom handle of the newly added atom.  On failure, this handle
      is NULL.

    NOTES:
      This method does not use any data member of the object.  Rather,
      the caller (the ATOM_BASE class) will modify the object accordingly.

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

ATOM LOCAL_ATOM::W_AddAtom( const TCHAR * pch ) const
{
    UIASSERT( pch != NULL );

    return ::AddAtom( (TCHAR *)pch );
}


/*********************************************************************

    NAME:       LOCAL_ATOM::W_QueryString

    SYNOPSIS:   This method calls the Windows API to retrieve a string '
                corresponding to an atom.

    ENTRY:
      pchBuffer Pointer to buffer which receives the atom string.
      cbBuf             Size of buffer pointed to by pchBuffer.  This size
                      must be positive.

    RETURN:     An error value, which is NERR_Success on success.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        04-Oct-1991 Win32 conversion
        beng        07-Nov-1991 Error mapping
        beng        01-May-1992 API changes

*********************************************************************/

APIERR LOCAL_ATOM::W_QueryString( TCHAR * pchBuffer, UINT cbBuf ) const
{
    UINT cchCopied = ::GetAtomName( QueryHandle(),
                                   pchBuffer, cbBuf/sizeof(TCHAR) );
    if ( cchCopied == 0 )
        return BLT::MapLastError(ERROR_GEN_FAILURE);

    return NERR_Success;
}


/*******************************************************************

    NAME:       CURSOR::Load

    SYNOPSIS:   Loads a cursor from the resource file

    ENTRY:      The new cursor, by name or number.

    RETURN:     Returns handle to the loaded cursor, or NULL on failure.

    NOTES:
        This is a static member function.

    HISTORY:
        rustanl     12-Mar-1991 Created
        beng        04-Oct-1991 Const parms
        beng        28-May-1992 Uses IDRESOURCE; sep'd LoadSystem
        beng        03-Aug-1992 Dllization delta

********************************************************************/

HCURSOR CURSOR::Load( const IDRESOURCE & idrsrcCursor )
{
    ASSERT( idrsrcCursor.QueryPsz() != NULL ); // Would be a LoadSystem instead

    HMODULE hmod = BLT::CalcHmodRsrc( idrsrcCursor );

    HCURSOR hcur = ::LoadCursor(hmod, idrsrcCursor.QueryPsz());
    if (hcur == NULL)
    {
#if defined(WIN32)
        DBGEOL( "BLT: CURSOR::Load() failed, err = " << ::GetLastError() );
#else
        DBGEOL( "BLT: CURSOR::Load() could not load cursor");
#endif
    }

    return hcur;
}


/*******************************************************************

    NAME:       CURSOR::LoadSystem

    SYNOPSIS:   Loads a cursor from the system

    ENTRY:      The new cursor, by name.  This should be one of the
                system predef'd cursors (e.g. IDC_WAIT).

    RETURN:     Returns handle to the loaded cursor, or NULL on failure.

    NOTES:
        This is a static member function.

    HISTORY:
        beng        28-May-1992 Created

********************************************************************/

HCURSOR CURSOR::LoadSystem( const IDRESOURCE & idrsrcCursor )
{
    ASSERT( idrsrcCursor.QueryPsz() != NULL );
    HCURSOR hcur = ::LoadCursor(NULL, idrsrcCursor.QueryPsz());

    if ( hcur == NULL )
    {
#if defined(WIN32)
        DBGEOL( "BLT: CURSOR::LoadSystem() failed, err = " << ::GetLastError() );
#else
        DBGEOL( "BLT: CURSOR::LoadSystem() could not load cursor");
#endif
    }

    return hcur;
}


/*******************************************************************

    NAME:       CURSOR::Set

    SYNOPSIS:   Sets the cursor

    ENTRY:      The new cursor, either by name or handle.

    RETURN:     Returns a handle to the previously used cursor

    NOTES:
        This is a static member function.

    HISTORY:
        rustanl     12-Mar-1991 Created
        beng        04-Oct-1991 Const parms
        beng        28-May-1992 Remove set-by-name

********************************************************************/

HCURSOR CURSOR::Set( HCURSOR hCursor )
{
    return ::SetCursor( hCursor );
}


/*******************************************************************

    NAME:       CURSOR::Query

    SYNOPSIS:   Returns the current cursor

    RETURN:     Returns a handle to the cursor

    NOTES:
        This is a static member function.

    HISTORY:
        beng        27-May-1992 Created

********************************************************************/

HCURSOR CURSOR::Query()
{
    return ::GetCursor();
}


/*******************************************************************

    NAME:       CURSOR::Show

    SYNOPSIS:   Increases or decreases the cursor display count

    ENTRY:      f - TRUE to increase cursor display count
                    FALSE to decrease cursor display count

    NOTES:
        This is a static member function.

        See Windows SDK for a description of the cursor display count.

    HISTORY:
        rustanl     12-Mar-1991     created

********************************************************************/

VOID CURSOR::Show( BOOL f )
{
    ::ShowCursor( f );
}


/*******************************************************************

    NAME:       CURSOR::QueryPos

    SYNOPSIS:   Returns the current position of the cursor

    RETURNS:    A XYPOINT, specifying the current pos in screen coords.

    NOTES:
        This is a static member function.

    HISTORY:
        beng        16-Oct-1991 Created

********************************************************************/

XYPOINT CURSOR::QueryPos()
{
    POINT pt;
    ::GetCursorPos(&pt);
    return XYPOINT(pt);
}


/*******************************************************************

    NAME:       CURSOR::SetPos

    SYNOPSIS:   Sets the cursor to the specified position

    ENTRY:      xy - desired position of cursor

    NOTES:
        This is a static member function.

    HISTORY:
        beng        16-Oct-1991 Created

********************************************************************/

VOID CURSOR::SetPos( const XYPOINT & xy )
{
    ::SetCursorPos(xy.QueryX(), xy.QueryY());
}


/*******************************************************************

    NAME:       AUTO_CURSOR::AUTO_CURSOR

    SYNOPSIS:   Sets the cursor to the one specified, and sets the state
                of the object to ON.

    ENTRY:      lpCursorName - specifies cursor to be used, either NULL
                to use hourglass, or else some other system cursor.

    HISTORY:
        rustanl     12-Mar-1991 created
        beng        04-Oct-1991 Const parms
        beng        28-May-1992 Changes to CURSOR::Load

********************************************************************/

AUTO_CURSOR::AUTO_CURSOR( const TCHAR * pszCursorName )
{
    _hOnCursor = LoadSystem( (pszCursorName == NULL)
                              ? IDC_WAIT
                              : pszCursorName );
    _hOffCursor = Set( _hOnCursor );
    _fState = TRUE;         // to indicate state = ON

    //  Discover the inital cursor count, which is one less than
    //  the value return by ShowCursor().  Immediately restore the
    //  cursor count back to what it was.

    _cCurs = ::ShowCursor( TRUE ) - 1 ;
    ::ShowCursor( FALSE ) ;

    if ( _cCurs >= 0 )
    {
        Show( TRUE );
    }
}


/*******************************************************************

    NAME:       AUTO_CURSOR::~AUTO_CURSOR

    SYNOPSIS:   Sets the cursor back to the one used before the
                constructor was called, and then destroys the
                AUTO_CURSOR object.

    HISTORY:
        rustanl     12-Mar-1991     created

********************************************************************/

AUTO_CURSOR::~AUTO_CURSOR()
{
    TurnOff();
}


/*******************************************************************

    NAME:       AUTO_CURSOR::TurnOn

    SYNOPSIS: