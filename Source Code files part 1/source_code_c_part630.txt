   return FALSE;
        }
        if (MADCAP_ACK_MESSAGE != MadcapMessage->MessageType) {
            return FALSE;
        }
        if (SelectedServer && SelectedServer != *MadcapOptions->ServerIdentifier) {
            return FALSE;
        }
        if (!MadcapOptions->LeaseTime) {
            return FALSE;
        }
        if (!MadcapOptions->AddrRangeList) {
            return FALSE;
        }
        if (!MadcapOptions->McastScope) {
            return FALSE;
        }
        break;
    case MADCAP_RELEASE_MESSAGE:
        if (MADCAP_ACK_MESSAGE != MadcapMessage->MessageType) {
            return FALSE;
        }

        break;
    default:
        DhcpAssert( FALSE );
        DhcpPrint(( DEBUG_PROTOCOL, "Received Unknown Message.\n"));
        return FALSE;

    }
    // Is this really necessary?
    if (MadcapOptions->Error) {
        return FALSE;
    }

    return TRUE; // accept this message.
}

VOID
MadcapExtractOptions(                     // Extract some important options alone or ALL
    IN      PDHCP_CONTEXT          DhcpContext,   // input context
    IN      LPBYTE                 OptStart,      // start of the options stuff
    IN      DWORD                  MessageSize,   // # of bytes of options
    OUT     PMADCAP_OPTIONS        MadcapOptions,   // this is where the options would be stored
    IN OUT  PLIST_ENTRY            RecdOptions,   // if !LiteOnly this gets filled with all incoming options
    IN      DWORD                  ServerId       // if !LiteOnly this specifies the server which gave this
) {
    WIDE_OPTION UNALIGNED*         NextOpt;
    BYTE        UNALIGNED*         EndOpt;
    WORD                           Size;
    DWORD                          OptionType;
    DWORD                          Error;
    WORD                           AddrFamily;


    EndOpt = OptStart + MessageSize;              // all options should be < EndOpt;
    RtlZeroMemory((LPBYTE)MadcapOptions, sizeof(*MadcapOptions));

    if( 0 == MessageSize ) goto DropPkt;          // nothing to do in this case

    NextOpt = (WIDE_OPTION UNALIGNED*)OptStart;
    while( NextOpt->OptionValue <= EndOpt &&
           MADCAP_OPTION_END != (OptionType = ntohs(NextOpt->OptionType)) ) {

        Size = ntohs(NextOpt->OptionLength);
        if ((NextOpt->OptionValue + Size) > EndOpt) {
            goto DropPkt;
        }

        switch( OptionType ) {
        case MADCAP_OPTION_LEASE_TIME:
            if( Size != sizeof(DWORD) ) goto DropPkt;
            MadcapOptions->LeaseTime = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_SERVER_ID:
            if (Size != 6) goto DropPkt;
            AddrFamily = ntohs(*(WORD UNALIGNED *)NextOpt->OptionValue);
            if ( MADCAP_ADDR_FAMILY_V4 != AddrFamily ) goto DropPkt;
            MadcapOptions->ServerIdentifier = (DHCP_IP_ADDRESS UNALIGNED *)(NextOpt->OptionValue+2);
            break;
        case MADCAP_OPTION_LEASE_ID:
            if( 0 == Size ) goto DropPkt;
            MadcapOptions->ClientGuidLength = Size;
            MadcapOptions->ClientGuid = NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_MCAST_SCOPE:
            if( Size != sizeof(DWORD) ) goto DropPkt;
            MadcapOptions->McastScope = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_START_TIME:
            if ( Size != sizeof(DATE_TIME) ) goto DropPkt;
            MadcapOptions->MCastLeaseStartTime = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_ADDR_LIST:
            if( Size % 6 ) goto DropPkt;
            MadcapOptions->AddrRangeList = NextOpt->OptionValue;
            MadcapOptions->AddrRangeListSize = Size;
            break;
        case MADCAP_OPTION_TIME:
            if( Size != sizeof(DWORD) ) goto DropPkt;
            MadcapOptions->Time = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_FEATURE_LIST:
            break;
        case MADCAP_OPTION_RETRY_TIME:
            if( Size != sizeof(DWORD) ) goto DropPkt;
            MadcapOptions->RetryTime = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_ERROR:
            if( Size != sizeof(DWORD) ) goto DropPkt;
            MadcapOptions->Error = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;


        default:
            // unknowm message, nothing to do.. especially dont log this
            break;
        }
        if (RecdOptions) {
            DhcpAssert(ServerId);
            Error = MadcapAddIncomingOption(        // Now add this option to the list
                RecdOptions,
                OptionType,
                ServerId,
                NextOpt->OptionValue,
                Size,
                (DWORD)INFINIT_TIME
            );
            if (ERROR_SUCCESS != Error) {
                goto DropPkt;
            }
        }
        NextOpt = (WIDE_OPTION UNALIGNED*)(NextOpt->OptionValue + Size);
    } // while NextOpt < EndOpt

    return;

  DropPkt:
    RtlZeroMemory(MadcapOptions, sizeof(MadcapOptions));
    if(RecdOptions) DhcpFreeAllOptions(RecdOptions);// ok undo the options that we just added
}

DWORD
MadcapDoInform(
    IN PDHCP_CONTEXT DhcpContext
)
/*++

Routine Description:

    This routine does the inform part by sending inform messages and
    collecting responses etc. on  given context.
    In case of no-response, no error is returned as a timeout is not
    considered an error.

Arguments:

    DhcpContext -- context to dhcp struct
    fBroadcast -- should the inform be broadcast or unicast?

Return Values:

    Win32 errors

--*/
{
    time_t                         StartTime;
    time_t                         TimeNow;
    time_t                         TimeToWait;
    DWORD                          Error;
    DWORD                          Xid;
    DWORD                          MessageSize;
    DWORD                          RoundNum;
    DWORD                          MessageCount;
    DWORD                          LeaseExpirationTime;
    MADCAP_OPTIONS                 MadcapOptions;
    BOOL                           GotAck;
#define MIN_ACKS_FOR_INFORM        MADCAP_QUERY_SCOPE_LIST_RETRIES
    DWORD                          MadcapServers[MIN_ACKS_FOR_INFORM];

    DhcpPrint((DEBUG_PROTOCOL, "MadcapDoInform entered\n"));


    Xid                           = 0;            // Will be generated by first SendDhcpPacket
    MessageCount                  = 0;            // total # of messages we have got

    TimeToWait = MADCAP_QUERY_SCOPE_LIST_TIME * 1000;
    TimeToWait += ((rand() * ((DWORD) 1000))/RAND_MAX);
    TimeToWait /= 1000;

    for( RoundNum = 0; RoundNum <= MADCAP_QUERY_SCOPE_LIST_RETRIES;  RoundNum ++ ) {

        if( RoundNum != MADCAP_QUERY_SCOPE_LIST_RETRIES ) {
            Error = SendMadcapInform(DhcpContext, &Xid);
            if( ERROR_SUCCESS != Error ) {
                DhcpPrint((DEBUG_ERRORS, "SendMadcapInform: %ld\n", Error));
                goto Cleanup;
            } else {
                DhcpPrint((DEBUG_PROTOCOL, "Sent DhcpInform\n"));
            }
        }

        StartTime  = time(NULL);
        while ( TRUE ) {                          // wiat for the specified wait time
            MessageSize =  DHCP_RECV_MESSAGE_SIZE;

            DhcpPrint((DEBUG_TRACE, "Waiting for ACK[Xid=%x]: %ld seconds\n",Xid, TimeToWait));
            Error = GetSpecifiedMadcapMessage(      // try to receive an ACK
                DhcpContext,
                &MessageSize,
                Xid,
                (DWORD)TimeToWait
            );
            if ( Error == ERROR_TIMEOUT ) break;
            if( Error != ERROR_SUCCESS ) {
                DhcpPrint((DEBUG_ERRORS, "GetSpecifiedMadcapMessage: %ld\n", Error));
                goto Cleanup;
            }

            MadcapExtractOptions(         // Need to see if this is an ACK
                DhcpContext,
                (LPBYTE)&DhcpContext->MadcapMessageBuffer->Option,
                MessageSize - MADCAP_MESSAGE_FIXED_PART_SIZE,
                &MadcapOptions,                 // check for only expected options
                NULL,                             // unused
                0                                 // unused
            );

            GotAck = AcceptMadcapMsg(       // check up and see if we find this offer kosher
                MADCAP_INFORM_MESSAGE,
                DhcpContext,
                &MadcapOptions,
                0,
                &Error
            );

            if (GotAck) {
                ULONG i;

                for( i = 0; i < MessageCount ; i ++ ) {
                    if( MadcapServers[i] == *MadcapOptions.ServerIdentifier ) {
                        break;
                    }
                }

                if( i == MessageCount && MessageCount < MIN_ACKS_FOR_INFORM ) {
                    MessageCount ++;
                    MadcapServers[i] = *MadcapOptions.ServerIdentifier;
                }

                DhcpPrint((DEBUG_TRACE, "Received %ld ACKS so far\n", MessageCount));
                MadcapExtractOptions(     // do FULL options..
                    DhcpContext,
                    (LPBYTE)&DhcpContext->MadcapMessageBuffer->Option,
                    MessageSize - MADCAP_MESSAGE_FIXED_PART_SIZE,
                    &MadcapOptions,
                    &(DhcpContext->RecdOptionsList),
                    *MadcapOptions.ServerIdentifier
                );
            }

            TimeNow     = time(NULL);             // Reset the time values to reflect new time
            if( TimeToWait < (TimeNow - StartTime) ) {
                break;                            // no more time left to wait..
            }
            TimeToWait -= (TimeNow - StartTime);  // recalculate time now
            StartTime   = TimeNow;                // reset start time also
        } // end of while ( TimeToWait > 0)


        if( MessageCount >= MIN_ACKS_FOR_INFORM ) goto Cleanup;
        if( RoundNum != 0 && MessageCount != 0 ) goto Cleanup;

        TimeToWait = MADCAP_QUERY_SCOPE_LIST_TIME ;
    } // for (RoundNum = 0; RoundNum < nInformsToSend ; RoundNum ++ )

  Cleanup:
    CloseDhcpSocket(DhcpContext);
    if( MessageCount ) Error = ERROR_SUCCESS;
    DhcpPrint((DEBUG_PROTOCOL, "MadcapDoInform: got %d ACKS (returning %ld)\n", MessageCount,Error));
    return Error;
}

DWORD
CopyMScopeList(
    IN OUT PMCAST_SCOPE_ENTRY       pScopeList,
    IN OUT PDWORD             pScopeLen,
    OUT    PDWORD             pScopeCount
    )
/*++

Routine Description:

    This routine obtains the multicast scope list from the Madcap
    server. It sends DHCPINFORM to Madcap multicast address and
    collects all the responses.

Arguments:


Return Value:

    The status of the operation.

--*/
{
    PMCAST_SCOPE_ENTRY pScopeSource;
    DWORD i;

    LOCK_MSCOPE_LIST();
    if ( *pScopeLen >= gMadcapScopeList->ScopeLen ) {
        RtlCopyMemory( pScopeList, gMadcapScopeList->pScopeBuf, gMadcapScopeList->ScopeLen );
        *pScopeLen = gMadcapScopeList->ScopeLen;
        *pScopeCount = gMadcapScopeList->ScopeCount;
        // remember the start pointer because we need to remap all the buffers into client space.
        pScopeSource = gMadcapScopeList->pScopeBuf;

        UNLOCK_MSCOPE_LIST();
        // now remap UNICODE_STRING scope desc to client address space.
        for (i=0;i<*pScopeCount;i++) {
            pScopeList[i].ScopeDesc.Buffer = (USHORT *) ((PBYTE)pScopeList +
                                              ((PBYTE)pScopeList[i].ScopeDesc.Buffer - (PBYTE)pScopeSource));
        }

        return ERROR_SUCCESS;
    } else {
        UNLOCK_MSCOPE_LIST();
        return ERROR_INSUFFICIENT_BUFFER;
    }

}


DWORD
StoreMScopeList(
    IN PDHCP_CONTEXT    pContext,
    IN BOOL             NewList
    )
/*++

Routine Description:

    This routine stores the scope list it retrieved from the inform requests
    into the global scope list..

        the scope option is of the following form.

        ---------------------------------
        | code (2 byte) | length (2byte)|
        ---------------------------------
        | count  ( 4 bytes )            |
        ---------------------------------
        | Scope list
        ---------------------------------

        where scope list is of the following form

        --------------------------------------------------------------------------
        | scope ID(4 byte) | Last Addr(4/16) |TTL(1) | Count (1) | Description...|
        --------------------------------------------------------------------------

        where scope description is of the following form


                    Language Tag
        --------------------------------------------------------------
        | Flags(1) | Tag Length(1) | Tag...| Name Length(1) | Name...|
        --------------------------------------------------------------
Arguments:

    pContext - pointer to the context to be used during inform

    NewList  - TRUE if a new list is to be created o/w prepend the
                current list.

Return Value:

    The status of the operation.

--*/
{
    PBYTE               pOptBuf;
    PBYTE               pOptBufEnd;
    PLIST_ENTRY         pOptionList;
    PDHCP_OPTION        pScopeOption, pFirstOption, pPrevOption;
    DWORD               TotalNewScopeDescLen;
    DWORD               TotalNewScopeCount;
    DWORD               TotalNewScopeListMem;
    PMCAST_SCOPE_LIST   pScopeList;
    PMCAST_SCOPE_ENTRY        pNextScope;
    LPWSTR              pNextUnicodeBuf;
    DWORD               TotalCurrScopeListMem;
    DWORD               TotalCurrScopeCount;
    DWORD               Error;
    DWORD               IpAddrLen;
    BOOL                WellFormed;

    // MBUG - make sure we collect options from all the servers when
    // we do dhcpinform.

    // initialize variables.
    TotalNewScopeCount = TotalCurrScopeCount = 0;
    TotalNewScopeDescLen = 0;
    pScopeList = NULL;
    Error = ERROR_SUCCESS;

    LOCK_MSCOPE_LIST();
    if (FALSE == NewList) {
        TotalCurrScopeListMem = gMadcapScopeList->ScopeLen;
        TotalCurrScopeCount = gMadcapScopeList->ScopeCount;
        DhcpPrint(( DEBUG_API, "StoreMScopeList: appending to CurrScopeLen %ld, ScopeCount %ld\n",
                    gMadcapScopeList->ScopeLen, gMadcapScopeList->ScopeCount ));
    }



    // First calculate the space required for the scope list.
    // pFirstOption is used to track that we traverse the list only once
    pOptionList = &pContext->RecdOptionsList;
    pFirstOption = NULL;
    WellFormed = TRUE;
    while ( ( pScopeOption = DhcpFindOption(
                                pOptionList,
                                MADCAP_OPTION_MCAST_SCOPE_LIST,
                                FALSE,
                                NULL,
                                0,
                                0                    //dont care about serverid
                                )) &&
            ( pScopeOption != pFirstOption ) ) {
        DWORD   ScopeCount;
        DWORD   i;

        // point to the next entry in the list.
        pOptionList = &pScopeOption->OptionList;

        // set the pFirstOption if it is not set already.
        if ( !pFirstOption ) {
            pFirstOption = pScopeOption;
            IpAddrLen = (pScopeOption->OptionVer.Proto == PROTO_MADCAP_V6 ? 16 : 4);
        }

        // if the last option was not well formatted from the list
        // then remove it from the list.
        if (!WellFormed) {
            DhcpDelOption(pPrevOption);

            //we may need to reset first option pointer.
            if (pPrevOption == pFirstOption) {
                pFirstOption = pScopeOption;
            }
        } else {

            WellFormed = FALSE;          // set it back to false for this iteration.
        }
        // save the prev option pointer
        pPrevOption = pScopeOption;

        pOptBuf = pScopeOption->Data;
        pOptBufEnd = pScopeOption->Data + pScopeOption->DataLen;

        ScopeCount = 0;

        // Read the scope count
        if ( pOptBuf  < pOptBufEnd ) {
            ScopeCount = *pOptBuf;
            pOptBuf ++;
        }
        else continue;

        for ( i=0;i<ScopeCount;i++ ) {
            DWORD   ScopeDescLen;
            DWORD   ScopeDescWLen;
            PBYTE   pScopeDesc;
            DWORD   NameCount, TagLen;
            // skip the scopeid, last addr and ttl
            pOptBuf += (2*IpAddrLen + 1);
            // read name count
            if (pOptBuf < pOptBufEnd) {
                NameCount = *pOptBuf;
                pOptBuf++;
            } else break;
            if (0 == NameCount) {
                break;
            }
            do {
                // Skip flags
                pOptBuf++;
                // read language tag len
                if (pOptBuf < pOptBufEnd) {
                    TagLen = *pOptBuf;
                    pOptBuf++;
                }else break;

                // skip the tag
                pOptBuf += TagLen;
                // Read the name length
                if (pOptBuf < pOptBufEnd) {
                    ScopeDescLen = *pOptBuf;
                    ScopeDescWLen = ConvertUTF8ToUnicode(pOptBuf+1, *pOptBuf, NULL, 0);
                    pOptBuf ++;
                } else break;

                // pick the scope name
                pScopeDesc = pOptBuf;
                pOptBuf += ScopeDescLen;
            }while(--NameCount);

            // if formatted correctly namecount should drop to 0
            if (0 != NameCount) {
                break;
            }
            // update total desc len count.
            if ( pOptBuf <= pOptBufEnd ) {
                if (pScopeDesc[ScopeDescLen-1]) { // if not NULL terminated.
                    ScopeDescWLen++;
                }
                TotalNewScopeDescLen += ScopeDescWLen * sizeof(WCHAR);
                TotalNewScopeCount++;
                // Set the wellformed to true so that this option stays
                WellFormed = TRUE;
            }
            else break;

        }

    }

    if ( !TotalNewScopeCount ) {
        DhcpPrint((DEBUG_ERRORS, "StoreMScopeList - no scopes found in the options, bad format..\n"));
        Error = ERROR_BAD_FORMAT;
        goto Cleanup;
    }

    DhcpPrint(( DEBUG_API, "TotalNewScopeCount %d, TotalNewScopeDescLen %d\n",TotalNewScopeCount,TotalNewScopeDescLen));

    // now allocate the memory.
    TotalNewScopeListMem = ROUND_UP_COUNT( sizeof(MCAST_SCOPE_LIST)  +  // scope list struct
                                        sizeof(MCAST_SCOPE_ENTRY) * (TotalNewScopeCount -1),
                                        ALIGN_WORST) + // scope buffers.
                        TotalNewScopeDescLen; // scope descriptors,

    if (FALSE == NewList) {
        TotalNewScopeListMem += TotalCurrScopeListMem;
        TotalNewScopeCount += TotalCurrScopeCount;
    }
    pScopeList = DhcpAllocateMemory( TotalNewScopeListMem );
    if ( !pScopeList ) {
        UNLOCK_MSCOPE_LIST();
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory( pScopeList, TotalNewScopeListMem );

    pScopeList->ScopeCount = 0; // we will fill this up as we go.
    pScopeList->ScopeLen = TotalNewScopeListMem - sizeof(MCAST_SCOPE_LIST) + sizeof(MCAST_SCOPE_ENTRY);

    // set the first scope pointer.
    pNextScope = pScopeList->pScopeBuf;

    // unicode strings starts after all the fixed sized scope structures.
    pNextUnicodeBuf = (LPWSTR)((PBYTE)pScopeList +
                               ROUND_UP_COUNT( sizeof(MCAST_SCOPE_LIST)  +  // scope list struct
                                               sizeof(MCAST_SCOPE_ENTRY) * (TotalNewScopeCount -1),
                                               ALIGN_WORST));  // scope buffers.

    DhcpPrint(( DEBUG_API, "ScopeList %lx TotalNewScopeListMem %d, ScopeDescBuff %lx\n",
                pScopeList, TotalNewScopeListMem,pNextUnicodeBuf));
    // now repeat the loop and fill up the scopelist.
    pOptionList = &pContext->RecdOptionsList;
    pFirstOption = NULL;

    while ( ( pScopeOption = DhcpFindOption(
                                pOptionList,
                                MADCAP_OPTION_MCAST_SCOPE_LIST,
                                FALSE,
                                NULL,
                                0,
                                0                    //dont care about serverid
                                )) &&
            ( pScopeOption != pFirstOption ) ) {
        DWORD   ScopeCount;
        DWORD   i;
        DHCP_IP_ADDRESS    ServerIpAddr;

        // point to the next entry in the list.
        pOptionList = &pScopeOption->OptionList;

        // set the pFirstOption if it is not set already.
        if ( !pFirstOption ) {
            pFirstOption = pScopeOption;
        }

        pOptBuf = pScopeOption->Data;
        DhcpPrint(( DEBUG_API, "MScopeOption - Data %lx\n", pOptBuf ));
        pOptBufEnd = pScopeOption->Data + pScopeOption->DataLen;


        // store ipaddr
        ServerIpAddr = pScopeOption->ServerId;
        DhcpPrint(( DEBUG_API, "MScopeOption - ServerIpAddr %lx\n", ServerIpAddr ));

        // read the scope count.
        ScopeCount = *pOptBuf; pOptBuf++;
        DhcpPrint(( DEBUG_API, "MScopeOption - ScopeCount %ld\n", ScopeCount ));

        for ( i=0;i<ScopeCount;i++ ) {
            BYTE    ScopeDescLen;
            PBYTE   pScopeDesc;
            IPNG_ADDRESS   ScopeID, LastAddr;
            DWORD   NameCount, TagLen;
            DWORD   TTL;

            // read the scopeid, last addr.
            RtlZeroMemory (&ScopeID, sizeof (ScopeID));
            RtlCopyMemory (&ScopeID, pOptBuf, IpAddrLen);
            pOptBuf += IpAddrLen;

            RtlZeroMemory (&LastAddr, sizeof (ScopeID));
            RtlCopyMemory (&LastAddr, pOptBuf, IpAddrLen);
            pOptBuf += IpAddrLen;

            DhcpPrint(( DEBUG_API, "MScopeOption - ScopeID %lx\n", ntohl(ScopeID.IpAddrV4) ));
            DhcpPrint(( DEBUG_API, "MScopeOption - LastAddr %lx\n", ntohl(LastAddr.IpAddrV4) ));

            TTL = *pOptBuf++;
            NameCount = *pOptBuf++;

            while (NameCount--) {
                // MBUG ignore the flags for now
                pOptBuf++;
                TagLen = *pOptBuf++;
                // MBUG ignore lang tag also
                pOptBuf += TagLen;
                ScopeDescLen = *pOptBuf++;
                pScopeDesc = pOptBuf;
                DhcpPrint(( DEBUG_API, "MScopeOption - ScopeDesc %lx ScopeDescLen %ld\n", pScopeDesc, ScopeDescLen ));

                pOptBuf += ScopeDescLen;
            }

            if ( ScopeDescLen ) {
                BYTE    ScopeDescWLen;
                WORD    MaximumLength;
/*                CHAR    DescAnsi[256];
                WORD    MaximumLength;
                RtlCopyMemory(DescAnsi, pScopeDesc, ScopeDescLen );
                // null terminate it if necessary.
                if ( pScopeDesc[ScopeDescLen - 1] ) {
                    DescAnsi[ScopeDescLen] = '\0';
                    MaximumLength = (ScopeDescLen + 1) * sizeof(WCHAR);
                } else {
                    MaximumLength = (ScopeDescLen) * sizeof(WCHAR);
                }
                pNextUnicodeBuf = DhcpOemToUnicode( DescAnsi, pNextUnicodeBuf ); */
                ScopeDescWLen = (BYTE)ConvertUTF8ToUnicode(pScopeDesc, ScopeDescLen, pNextUnicodeBuf, TotalNewScopeDescLen);
                if ( pNextUnicodeBuf[ScopeDescWLen - 1] ) {
                    pNextUnicodeBuf[ScopeDescWLen] = L'\0';
                    MaximumLength = (ScopeDescWLen + 1) * sizeof(WCHAR);
                } else {
                    MaximumLength = (ScopeDescWLen) * sizeof(WCHAR);
                }
                TotalNewScopeDescLen -= MaximumLength;
                DhcpPrint(( DEBUG_API, "MScopeOption - UnicodeScopeDesc %lx %ws\n",pNextUnicodeBuf, pNextUnicodeBuf));
                RtlInitUnicodeString(&pNextScope->ScopeDesc, pNextUnicodeBuf );
                pNextScope->ScopeDesc.MaximumLength = MaximumLength;
                pNextUnicodeBuf = (LPWSTR)((PBYTE)pNextUnicodeBuf + MaximumLength);
                DhcpAssert((PBYTE)pNextUnicodeBuf <= ((PBYTE)pScopeList + TotalNewScopeListMem));
            } else {
                // set the unicode descriptor string to NULL;
                pNextScope->ScopeDesc.Length = pNextScope->ScopeDesc.MaximumLength = 0;
                pNextScope->ScopeDesc.Buffer = NULL;
            }
            // everything looks good, now fill up the NextScope
            pNextScope->ScopeCtx.ScopeID = ScopeID;
            pNextScope->ScopeCtx.ServerID.IpAddrV4 = ServerIpAddr;
            pNextScope->ScopeCtx.Interface.IpAddrV4 = pContext->IpAddress;
            pNextScope->LastAddr = LastAddr;
            pNextScope->TTL = TTL;

            pNextScope++;
            pScopeList->ScopeCount++;

        }

    }

    DhcpAssert( pScopeList->ScopeCount == (TotalNewScopeCount - TotalCurrScopeCount) );

    // now append the previous scope list if exist.
    if (FALSE == NewList) {
        DWORD           CurrScopeCount;
        PMCAST_SCOPE_ENTRY    CurrScopeNextPtr;

        CurrScopeCount = gMadcapScopeList->ScopeCount;
        CurrScopeNextPtr = gMadcapScopeList->pScopeBuf;
        while(CurrScopeCount--) {
            *pNextScope = *CurrScopeNextPtr;
            // now copy the unicode strings also.
            RtlCopyMemory( pNextUnicodeBuf, CurrScopeNextPtr->ScopeDesc.Buffer, CurrScopeNextPtr->ScopeDesc.MaximumLength);
            pNextScope->ScopeDesc.Buffer = pNextUnicodeBuf ;

            pNextUnicodeBuf = (LPWSTR)((PBYTE)pNextUnicodeBuf + CurrScopeNextPtr->ScopeDesc.MaximumLength);
            pNextScope++; CurrScopeNextPtr++;
        }
        pScopeList->ScopeCount += gMadcapScopeList->ScopeCount;
        DhcpAssert( pScopeList->ScopeCount == TotalNewScopeCount);
    }
    // Finally copy this buffer to our global pointer.
    // first free the existing list.
    if (gMadcapScopeList) DhcpFreeMemory( gMadcapScopeList );
    gMadcapScopeList = pScopeList;



Cleanup:

    UNLOCK_MSCOPE_LIST();
    return Error;
}

DWORD
ObtainMScopeList(
    )
/*++

Routine Description:

    This routine obtains the multicast scope list from the Madcap
    server. It sends DHCPINFORM to Madcap multicast address and
    collects all the responses.

Arguments:


Return Value:

    The status of the operation.

--*/
{
    MCAST_CLIENT_UID             RequestID;
    BYTE                        IDBuf[MCAST_CLIENT_ID_LEN];
    PDHCP_CONTEXT              pContext;
    DWORD                       Error;
    PMIB_IPADDRTABLE            pIpAddrTable;
    PLOCAL_CONTEXT_INFO         localInfo;
    DWORD                       i;
    BOOL                        NewList;

    pContext = NULL;
    Error = ERROR_SUCCESS;
    pIpAddrTable = NULL;

    if ( !ShouldRequeryMScopeList() ) {
        return ERROR_SUCCESS;
    } else {
        RequestID.ClientUID = IDBuf;
        RequestID.ClientUIDLength = MCAST_CLIENT_ID_LEN;

        Error = GenMadcapClientUID( RequestID.ClientUID, &RequestID.ClientUIDLength );
        if ( ERROR_SUCCESS != Error)
            goto Exit;

        Error = CreateMadcapContext(&pContext, &RequestID, INADDR_ANY );
        if ( ERROR_SUCCESS != Error )
            goto Exit;
        APICTXT_ENABLED(pContext);  // mark the context as being created by the API

        localInfo = pContext->LocalInformation;

        // now get primary ipaddresses on each adapter.

        Error = GetIpPrimaryAddresses(&pIpAddrTable);
        if ( ERROR_SUCCESS != Error ) {
            goto Exit;
        }

        DhcpPrint((DEBUG_API, "ObtainMScopeList: ipaddress table has %d addrs\n",
                   pIpAddrTable->dwNumEntries));

        NewList = TRUE;
        Error = ERROR_TIMEOUT;
        for (i = 0; i < pIpAddrTable->dwNumEntries; i++) {
            DWORD           LocalError;
            PMIB_IPADDRROW  pAddrRow;

            pAddrRow = &pIpAddrTable->table[i];
            // if primary bit set this is a primary address.
            if (0 == (pAddrRow->wType & MIB_IPADDR_PRIMARY) ||
                0 == pAddrRow->dwAddr ||
                htonl(INADDR_LOOPBACK) == pAddrRow->dwAddr) {
                continue;
            }

            DhcpPrint((DEBUG_API, "ObtainMScopeList: DoInform on %s interface\n",
                       DhcpIpAddressToDottedString(ntohl(pAddrRow->dwAddr)) ));

            LocalError = ReInitializeMadcapSocket(&localInfo->Socket, pAddrRow->dwAddr);
            if (ERROR_SUCCESS != LocalError) {
                continue;
            }
            pContext->IpAddress = pAddrRow->dwAddr;
            // now do the inform and get scope list.
            LocalError = MadcapDoInform(pContext);
            if ( ERROR_SUCCESS == LocalError ) {
                // now copy the scope list.
                LocalError = StoreMScopeList(pContext, NewList);
                if (ERROR_SUCCESS == LocalError ) {
                    NewList = FALSE;
                    Error = ERROR_SUCCESS;
                }
            }

            LOCK_OPTIONS_LIST();
            DhcpDestroyOptionsList(&pContext->SendOptionsList, &DhcpGlobalClassesList);
            DhcpDestroyOptionsList(&pContext->RecdOptionsList, &DhcpGlobalClassesList);
            UNLOCK_OPTIONS_LIST();

        }

Exit:
        // signal the thread could be waiting on this.
        LOCK_MSCOPE_LIST();
        gMScopeQueryInProgress = FALSE;
        UNLOCK_MSCOPE_LIST();

        SetEvent( gMScopeQueryEvent );

        if ( pContext ) {
            DhcpDestroyContext( pContext );
        }

        if (pIpAddrTable) {
            DhcpFreeMemory( pIpAddrTable );
        }
        return Error;
    }


}

DWORD
GenMadcapClientUID(
    OUT    PBYTE    pRequestID,
    IN OUT PDWORD   pRequestIDLen
)
/*++

Routine Description:

    This routine generates a client UID.

Arguments:

    pRequestID - pointer where client UID is to be stored.

    pRequestIDLen - pointer where the length of request id is stored.

Return Value:


--*/

{
    PULONG     UID;
    RPC_STATUS Status;
    GUID       RequestGuid;

    DhcpAssert( pRequestID && pRequestIDLen );

    if (*pRequestIDLen < MCAST_CLIENT_ID_LEN) {
        DhcpPrint((DEBUG_ERRORS,"GenMadcapId - IDLen too small, %ld\n", *pRequestIDLen ));
        return ERROR_INVALID_PARAMETER;
    }
    Status = UuidCreate( &RequestGuid );
    if (Status != RPC_S_OK) {
        Status = ERROR_LUIDS_EXHAUSTED;
    }
    *pRequestID++ = 0;  // first octet is type and for guid the type is 0
    *((GUID UNALIGNED *)pRequestID) = RequestGuid;
    return Status;
}


DWORD
ObtainMadcapAddress(
    IN     PDHCP_CONTEXT DhcpContext,
    IN     PIPNG_ADDRESS           pScopeID,
    IN     PMCAST_LEASE_REQUEST    pAddrRequest,
    IN OUT PMCAST_LEASE_RESPONSE   pAddrResponse
    )
/*++

Routine Description:

    This routine attempts to obtains a new lease from a DHCP server.

Arguments:

    DhcpContext - Points to a DHCP context block for the NIC to initialize.

    MadcapOptions - Returns DHCP options returned by the DHCP server.

Return Value:


--*/
{
    MADCAP_OPTIONS                 MadcapOptions;
    DATE_TIME                      HostOrderLeaseTime;
    DWORD                          Error;
    time_t                         StartTime;
    time_t                         InitialStartTime;
    time_t                         TimeNow;
    time_t                         TimeToWait;
    DWORD                          Xid;
    DWORD                          RoundNum;
    DWORD                          MessageSize;
    DWORD                          SelectedServer;
    DWORD                          SelectedAddress;
    DWORD                          LeaseExpiryTime;
    BOOL                           GotOffer;
    PMCAST_LEASE_REQUEST           pRenewRequest;

    Xid                            = 0;           // generate xid on first send.  keep it same throughout
    SelectedServer                 = (DWORD)-1;
    SelectedAddress                = (DWORD)-1;
    GotOffer                       = FALSE;
    InitialStartTime               = time(NULL);
    Error                          = ERROR_SEM_TIMEOUT;

    // Make private copy of the request so that we don't modify original request.
    pRenewRequest = DhcpAllocateMemory(
                        sizeof(*pAddrRequest) +
                        sizeof(DWORD)*(pAddrRequest->AddrCount));
    if (NULL == pRenewRequest) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    memcpy(pRenewRequest,pAddrRequest,sizeof(*pAddrRequest) );
    pRenewRequest->pAddrBuf = (PBYTE)pRenewRequest + sizeof(*pRenewRequest);
    if (pAddrRequest->pAddrBuf) {
        memcpy(pRenewRequest->pAddrBuf, pAddrRequest->pAddrBuf, sizeof(DWORD)*(pAddrRequest->AddrCount));
    }

    for (RoundNum = 0; RoundNum < MADCAP_MAX_RETRIES; RoundNum++ ) {
        Error = SendMadcapDiscover(                 // send a discover packet
            DhcpContext,
            pScopeID,
            pAddrRequest,
            &Xid
        );
        if ( Error != ERROR_SUCCESS ) {           // can't really fail here
            DhcpPrint((DEBUG_ERRORS, "Send Dhcp Discover failed, %ld.\n", Error));
            return Error ;
        }

        DhcpPrint((DEBUG_PROTOCOL, "Sent DhcpDiscover Message.\n"));

        TimeToWait = DhcpCalculateWaitTime(RoundNum, NULL);
        StartTime  = time(NULL);

        while ( TimeToWait > 0 ) {                // wait for specified time
            MessageSize = DHCP_RECV_MESSAGE_SIZE;

            DhcpPrint((DEBUG_TRACE, "Waiting for Offer: %ld seconds\n", TimeToWait));
            Error = GetSpecifiedMadcapMessage(      // try to receive an offer
                DhcpContext,
                &MessageSize,
                Xid,
                (DWORD)TimeToWait
            );

            if ( Error == ERROR_TIMEOUT ) {   // get out and try another discover
                DhcpPrint(( DEBUG_PROTOCOL, "Dhcp offer receive Timeout.\n" ));
                break;
            }

            if ( ERROR_SUCCESS != Error ) {       // unexpected error
                DhcpPrint(( DEBUG_PROTOCOL, "Dhcp Offer receive failed, %ld.\n", Error ));
                return Error ;
            }

            MadcapExtractOptions(         // now extract basic information
                DhcpContext,
                (LPBYTE)&DhcpContext->MadcapMessageBuffer->Option,
                MessageSize - MADCAP_MESSAGE_FIXED_PART_SIZE,
                &MadcapOptions,
                NULL,
                0
            );

            GotOffer = AcceptMadcapMsg(       // check up and see if we find this offer kosher
                MADCAP_DISCOVER_MESSAGE,
                DhcpContext,
                &MadcapOptions,
                0,
                &Error
            );
            DhcpAssert(ERROR_SUCCESS == Error);
            Error = ExpandMadcapAddressList(
                        MadcapOptions.AddrRangeList,
                        MadcapOptions.AddrRangeListSize,
                        (DWORD UNALIGNED *)pRenewRequest->pAddrBuf,
                        &pRenewRequest->AddrCount
                        );
            if (ERROR_SUCCESS != Error) {
                GotOffer = FALSE;
            }

            if (GotOffer) {
                break;
            }

            TimeNow     = time( NULL );           // calc the remaining wait time for this round
            TimeToWait -= ((TimeNow - StartTime));
            StartTime   = TimeNow;

        } // while (TimeToWait > 0 )

        if(GotOffer) {                            // if we got an offer, everything should be fine
            DhcpAssert(ERROR_SUCCESS == Error);
            break;
        }

    } // for n tries... send discover.

    if(!GotOffer ) { // did not get any valid offers
        DhcpPrint((DEBUG_ERRORS, "ObtainMadcapAddress timed out\n"));
        Error = ERROR_TIMEOUT ;
        goto Cleanup;
    }

    DhcpPrint((DEBUG_PROTOCOL, "Successfully received a DhcpOffer (%s) ",
                   inet_ntoa(*(struct in_addr *)pRenewRequest->pAddrBuf) ));

    DhcpPrint((DEBUG_PROTOCOL, "from %s.\n",
                   inet_ntoa(*(struct in_addr*)MadcapOptions.ServerIdentifier) ));
    SelectedServer = *MadcapOptions.ServerIdentifier;

    Error = RenewMadcapAddress(
                DhcpContext,
                pScopeID,
                pRenewRequest,
                pAddrResponse,
                SelectedServer
                );
Cleanup:
    if (pRenewRequest) {
        DhcpFreeMemory(pRenewRequest);
    }
    return Error;
}

DWORD
RenewMadcapAddress(
    IN     PDHCP_CONTEXT          DhcpContext,
    IN     PIPNG_ADDRESS          pScopeID,
    IN     PMCAST_LEASE_REQUEST   pAddrRequest,
    IN OUT PMCAST_LEASE_RESPONSE  pAddrResponse,
    IN     DHCP_IP_ADDRESS        SelectedServer
    )
/*++

Routine Description:

    This routine is called for two different purposes.
    1. To request an address for which we got offer.
    2. To renew an address.

Arguments:

    DhcpContext - Points to a DHCP context block for the NIC to initialize.

    pScopeID - ScopeId from which the address is to be renewed. for renewals
                this is passed as null.

    pAddrRequest - The lease info structure describing the request.

    pAddrResponse - The lease info structure which receives the response data.

    SelectedServer - If we are sending REQUEST message then this describes the server
                        from which we accepted the offer originally.
Return Value:

    The status of the operation.

--*/
{
    MADCAP_OPTIONS                 MadcapOptions;
    DWORD                          Error;
    DWORD                          Xid;
    DWORD                          RoundNum;
    size_t                         TimeToWait;
    DWORD                          MessageSize;
    DWORD                          LeaseTime;
    DWORD                          LeaseExpiryTime;
    time_t                         InitialStartTime;
    time_t                         StartTime;
    time_t                         TimeNow;
    BOOL                           GotAck;
    DATE_TIME                      HostOrderLeaseTime;
    BOOL                           Renew;

    Xid = 0;                                     // new Xid will be generated first time
    InitialStartTime = time(NULL);
    GotAck = FALSE;
    Error = ERROR_TIMEOUT;

    Renew = (0 == SelectedServer);
    for ( RoundNum = 0; RoundNum < MADCAP_MAX_RETRIES; RoundNum ++ ) {
        if (Renew) {
            Error = SendMadcapRenew(
                        DhcpContext,
                        pAddrRequest,
                        &Xid
                        );
        } else {
            Error = SendMadcapRequest(                 // send a request
                        DhcpContext,
                        pScopeID,
                        pAddrRequest,
                        SelectedServer,               //
                        &Xid
                        );
        }

        if ( Error != ERROR_SUCCESS ) {          // dont expect send to fail
            DhcpPrint(( DEBUG_ERRORS,"Send request failed, %ld.\n", Error));
            return Error ;
        }

        TimeToWait = DhcpCalculateWaitTime(RoundNum, NULL);
        StartTime  = time(NULL);
        while ( TimeToWait > 0 ) {               // try to recv message for this full period
            MessageSize = DHCP_RECV_MESSAGE_SIZE;
            Error = GetSpecifiedMadcapMessage(     // expect to recv an ACK
                DhcpContext,
                &MessageSize,
                Xid,
                TimeToWait
            );

            if ( Error == ERROR_TIMEOUT ) {  // No response, so resend DHCP REQUEST.
                DhcpPrint(( DEBUG_PROTOCOL, "Dhcp ACK receive Timeout.\n" ));
                break;
            }

            if ( ERROR_SUCCESS != Error ) {      // unexpected error
                DhcpPrint(( DEBUG_PROTOCOL, "Dhcp ACK receive failed, %ld.\n", Error ));
                return Error ;
            }

            MadcapExtractOptions(         // now extract basic information
                DhcpContext,
                (LPBYTE)&DhcpContext->MadcapMessageBuffer->Option,
                MessageSize - MADCAP_MESSAGE_FIXED_PART_SIZE,
                &MadcapOptions,
                NULL,
                0
            );

            GotAck = AcceptMadcapMsg(       // check up and see if we find this offer kosher
                Renew ? MADCAP_RENEW_MESSAGE : MADCAP_REQUEST_MESSAGE,
                DhcpContext,
                &MadcapOptions,
                SelectedServer,
                &Error
            );
            if (ERROR_SUCCESS != Error) {
                return Error;
            }
            // check that the ack came from the same server as the selected server.
            if ( SelectedServer && SelectedServer != *MadcapOptions.ServerIdentifier ) {
                GotAck = FALSE;
            }
            Error = ExpandMadcapAddressList(
                        MadcapOptions.AddrRangeList,
                        MadcapOptions.AddrRangeListSize,
                        (DWORD UNALIGNED *)pAddrResponse->pAddrBuf,
                        &pAddrResponse->AddrCount
                        );
            if (ERROR_SUCCESS != Error) {
                GotAck = FALSE;
            }

            if ( GotAck ) {
                break;
            }

            TimeNow     = time( NULL );
            TimeToWait -= (TimeNow - StartTime);
            StartTime   = TimeNow;

        } // while time to wait
        if(TRUE == GotAck) {                      // if we got an ack, everything must be good
            DhcpAssert(ERROR_SUCCESS == Error);   // cannot have any errors
            break;
        }
        DhcpContext->SecondsSinceBoot = (DWORD)(time(NULL) - InitialStartTime);
    } // for RoundNum < MAX_RETRIES

    if(!GotAck) {
        DhcpPrint((DEBUG_ERRORS, "RenewMadcapAddress timed out\n"));
        return ERROR_TIMEOUT;
    }

    if (0 == SelectedServer ) SelectedServer = *MadcapOptions.ServerIdentifier;
    if( MadcapOptions.LeaseTime ) LeaseTime = ntohl(*MadcapOptions.LeaseTime);
    else LeaseTime = 0;

    pAddrResponse->ServerAddress.IpAddrV4 = SelectedServer;

    time( &TimeNow );
    pAddrResponse->LeaseStartTime = (LONG)TimeNow;
    pAddrResponse->LeaseEndTime = (LONG)(TimeNow+LeaseTime);


    DhcpPrint((DEBUG_PROTOCOL, "Accepted ACK (%s) ",
               inet_ntoa(*(struct in_addr *)pAddrResponse->pAddrBuf) ));
    DhcpPrint((DEBUG_PROTOCOL, "from %s.\n",
               inet_ntoa(*(struct in_addr *)&SelectedServer)));
    DhcpPrint((DEBUG_PROTOCOL, "Lease is %ld secs.\n", LeaseTime));

    return ERROR_SUCCESS;
}



DWORD
ReleaseMadcapAddress(
    PDHCP_CONTEXT DhcpContext
    )
/*++

Routine Description:

    This routine to releases a lease for an IP address.  Since the
    packet we send is not responded to, we assume that the release
    works.

Arguments:

    DhcpContext - Points to a DHCP context block for the NIC to initialize.

Return Value:

    None.

--*/
{
    DWORD                          Xid;
    MADCAP_OPTIONS                 MadcapOptions;
    DWORD                          Error;
    time_t                         StartTime;
    time_t                         InitialStartTime;
    time_t                         TimeNow;
    time_t                         TimeToWait;
    DWORD                          RoundNum;
    DWORD                          MessageSize;
    BOOL                           GotAck;


    Xid = 0;                                     // new Xid will be generated first time
    GotAck                         = FALSE;
    InitialStartTime               = time(NULL);
    Error                          = ERROR_TIMEOUT;

    for (RoundNum = 0; RoundNum < MADCAP_MAX_RETRIES; RoundNum++ ) {
        Error = SendMadcapRelease(                 // send a discover packet
            DhcpContext,
            &Xid
        );
        if ( Error != ERROR_SUCCESS ) {           // can't really fail here
            DhcpPrint((DEBUG_ERRORS, "Send Dhcp Release failed, %ld.\n", Error));
            return Error ;
        }

        DhcpPrint((DEBUG_PROTOCOL, "Sent DhcpRelease Message.\n"));

        TimeToWait = DhcpCalculateWaitTime(RoundNum, NULL);
        StartTime  = time(NULL);

        while ( TimeToWait > 0 ) {                // wait for specified time
            MessageSize = DHCP_RECV_MESSAGE_SIZE;

            DhcpPrint((DEBUG_TRACE, "Waiting for Ack: %ld seconds\n", TimeToWait));
            Error = GetSpecifiedMadcapMessage(      // try to receive an offer
                DhcpContext,
                &MessageSize,
                Xid,
                (DWORD)TimeToWait
            );

            if ( Error == ERROR_TIMEOUT ) {   // get out and try another discover
                DhcpPrint(( DEBUG_PROTOCOL, "Dhcp Ack receive Timeout.\n" ));
                break;
            }

            if ( ERROR_SUCCESS != Error ) {       // unexpected error
                DhcpPrint(( DEBUG_PROTOCOL, "Dhcp Ack receive failed, %ld.\n", Error ));
                return Error ;
            }

            MadcapExtractOptions(         // now extract basic information
                DhcpContext,
                (LPBYTE)&DhcpContext->MadcapMessageBuffer->Option,
                MessageSize - MADCAP_MESSAGE_FIXED_PART_SIZE,
                &MadcapOptions,
                NULL,
                0
            );

            GotAck = AcceptMadcapMsg(       // check up and see if we find this offer kosher
                MADCAP_RELEASE_MESSAGE,
                DhcpContext,
                &MadcapOptions,
                DhcpContext->DhcpServerAddress,
                &Error
            );
            DhcpAssert(ERROR_SUCCESS == Error);
            if (GotAck) {
                break;
            }

            TimeNow     = time( NULL );           // calc the remaining wait time for this round
            TimeToWait -= ((TimeNow - StartTime));
            StartTime   = TimeNow;

        } // while (TimeToWait > 0 )

        if(GotAck) {                            // if we got an offer, everything should be fine
            DhcpAssert(ERROR_SUCCESS == Error);
            break;
        }

    } // for n tries... send discover.

    if(!GotAck ) { // did not get any valid offers
        DhcpPrint((DEBUG_ERRORS, "MadcapReleaseAddress timed out\n"));
        Error = ERROR_TIMEOUT ;
    } else {
        DhcpPrint((DEBUG_PROTOCOL, "Successfully released the address\n" ));
        Error = ERROR_SUCCESS;
    }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\client\nt\precomp.h ===
#include <dhcpcli.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\client\nt\leaseapi.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    leaseapi.c

Abstract:

    This file contains apis that obtains/releases ip address from a
    dhcpserver. These apis can be called by any apps that needs an ip
    address for lease.


Author:

    Madan Appiah (madana)  30-Nov-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include "precomp.h"
#include "dhcpglobal.h"
#include <dhcploc.h>
#include <dhcppro.h>
#include <align.h>

#include <dhcpcapi.h>
#include <iphlpapi.h>

#define  DEFAULT_RAS_CLASS         "RRAS.Microsoft"

//
// Helper routine
//

VOID
GetHardwareAddressForIpAddress(
    IN ULONG IpAddress,
    IN OUT LPBYTE Buf,
    IN OUT PULONG BufSize
)
/*++

Routine Description:

    This routine calls into iphlpapi to try to figure out the hardware
    address for an adapter with the given Ip address..
    In case of failure, it sets the BufSize to zero.

Arguments:

    IpAddress -- N/W order IpAddress of context for which h/w addr is needed.
    Buf -- buffer to fill hardware address 
    BufSize -- input size of buffer, and on output how much of buffer is
    used.

--*/
{
    MIB_IPADDRTABLE *AddrTable;
    MIB_IFTABLE *IfTable;
    ULONG Error, i, Index, OldBufSize;
    ULONG AllocateAndGetIpAddrTableFromStack( 
        MIB_IPADDRTABLE **, BOOL, HANDLE, ULONG 
        );
    ULONG AllocateAndGetIfTableFromStack( 
        MIB_IFTABLE **, BOOL, HANDLE, ULONG, BOOL
        );

    IpAddress = ntohl(IpAddress);
    OldBufSize = (*BufSize);
    (*BufSize) = 0;
    AddrTable = NULL;
    IfTable = NULL;

    do {
        Error = AllocateAndGetIpAddrTableFromStack(
            &AddrTable,
            FALSE,
            GetProcessHeap(),
            0
            );
        if( ERROR_SUCCESS != Error ) break;

        Error = AllocateAndGetIfTableFromStack(
            &IfTable,
            FALSE,
            GetProcessHeap(),
            0,
            FALSE
            );
        if( ERROR_SUCCESS != Error ) break;

        //
        // Got both tables.. Now walk the ip addr table to get the index.
        //

        for( i = 0; i < AddrTable->dwNumEntries ; i ++ ) {
            if( AddrTable->table[i].dwAddr == IpAddress ) break;
        }

        if( i >= AddrTable->dwNumEntries ) break;
        Index = AddrTable->table[i].dwIndex;

        //
        // Now walk the iftable to find the hwaddr entyr.
        //
        
        for( i = 0; i < IfTable->dwNumEntries ; i ++ ) {
            if( IfTable->table[i].dwIndex == Index ) {
                break;
            }
        }

        if( i >= IfTable->dwNumEntries ) break;

        //
        // Copy the hw address if there is space.
        //

        if( OldBufSize <= IfTable->table[i].dwPhysAddrLen ) break;
        *BufSize = IfTable->table[i].dwPhysAddrLen;

        RtlCopyMemory( Buf, IfTable->table[i].bPhysAddr, *BufSize );
        
        //
        // done
        //
    } while ( 0 );

    if( NULL != AddrTable ) HeapFree( GetProcessHeap(), 0, AddrTable );
    if( NULL != IfTable ) HeapFree( GetProcessHeap(), 0, IfTable );
    return ;
}

ULONG
GetSeed(
    VOID
    )
/*++

Routine Description:
    This routine returns a rand number seed that can be used on
    any thread... (If the routine is called on multiple threads,
    it tries to make sure that the same number isn't returned in
    different threads).

--*/
{
    static LONG Seed = 0;
    LONG OldSeed;

    OldSeed = InterlockedIncrement(&Seed) - 1;
    if( 0 == OldSeed ) {
        OldSeed = Seed = (LONG) time(NULL);
    }

    srand((OldSeed << 16) + (LONG)time(NULL));
    OldSeed = (rand() << 16) + (rand());
    Seed = (rand() << 16) + (rand());
    return OldSeed;
}
        
DWORD
DhcpLeaseIpAddressEx(
    IN DWORD AdapterIpAddress,
    IN LPDHCP_CLIENT_UID ClientUID,
    IN DWORD DesiredIpAddress OPTIONAL,
    IN OUT LPDHCP_OPTION_LIST OptionList,
    OUT LPDHCP_LEASE_INFO *LeaseInfo,
    IN OUT LPDHCP_OPTION_INFO *OptionInfo,
    IN LPBYTE ClassId OPTIONAL,
    IN ULONG ClassIdLen
    )
/*++

Routine Description:

    This api obtains an IP address lease from a dhcp server. The
    caller should specify the client uid and a desired ip address.
    The client uid must be globally unique. Set the desired ip address
    to zero if you can accept any ip address. Otherwise this api will
    try to obtain the ip address you have specified, but not guaranteed.

    The caller may optionally requtest additional option info from the
    dhcp server, The caller should specify the list in OptionList
    parameter and the api will return the available option data in
    OptionInfo structure.

    ?? Option retrival is not implemented in the first phase. This
    requires several modification in the dhcp client code.

    WSAStartup must haave been successfully called before this function
    can be called.

Arguments:

    AdapterIpAddress - IpAddress of the adapter. On a multi-homed
        machined this specifies the subnet from which an address is
        requested. This value can be set to zero if the machine is a
        non-multi-homed machine or you like to get ip address from any
        of the subnets. This must be network byte order..

    ClientUID - pointer to a client UID structure.

    DesiredIpAddress - the ip address you prefer.

    OptionList - list of option ids.

    LeaseInfo - pointer to a location where the lease info structure
        pointer is retured. The caller should free up this structure
        after use.

    OptionInfo - pointer to a location where the option info structure
        pointer is returned. The caller should free up this structure
        after use.

    ClassId - a byte sequence for user class

    ClassIdLen - number of bytes present in ClassId

Return Value:

    Windows Error.

--*/
{
    DWORD                          Error;
    PDHCP_CONTEXT                  DhcpContext = NULL;
    ULONG                          DhcpContextSize;
    PLOCAL_CONTEXT_INFO            LocalInfo = NULL;
    LPVOID                         Ptr;
    DHCP_OPTIONS                   DhcpOptions;
    LPDHCP_LEASE_INFO              LocalLeaseInfo = NULL;
    time_t                         LeaseObtained;
    DWORD                          T1, T2, Lease;
    BYTE                           DefaultParamRequests[] = { 0x2E, 0x2C, 0x0F, 0x01, 0x03, 0x06, 0x2F };
    DWORD                          nDefaultParamRequests = sizeof(DefaultParamRequests);
    ULONG                          HwAddrSize;
    BYTE                           HwAddrBuf[200];
    BOOL                           fAutoConfigure = TRUE;
    DHCP_OPTION                    ParamRequestList = {
        { NULL, NULL /* List entry */},
        OPTION_PARAMETER_REQUEST_LIST,
        FALSE /* not a vendor specific option */,
        NULL,
        0 /* no class id */,
        0 /* expiration time useless */,
        DefaultParamRequests,
        nDefaultParamRequests
    };

    if( NULL == ClassId && 0 != ClassIdLen || 0 == ClassIdLen && NULL != ClassId ) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpCommonInit();
    if( ERROR_SUCCESS != Error ) return Error;

    HwAddrSize = 0;
    if( INADDR_ANY != AdapterIpAddress 
        && INADDR_LOOPBACK  != AdapterIpAddress ) {
        HwAddrSize = sizeof(HwAddrBuf);
        GetHardwareAddressForIpAddress( AdapterIpAddress, HwAddrBuf, &HwAddrSize );
    }

    if( 0 == HwAddrSize ) {
        HwAddrSize = ClientUID->ClientUIDLength;
        if( HwAddrSize > sizeof(HwAddrBuf) ) return ERROR_INVALID_DATA;
        RtlCopyMemory(HwAddrBuf, ClientUID->ClientUID, HwAddrSize );
    }

    DhcpContextSize =                             // allocate memory for dhcpcontext, in one blob
        ROUND_UP_COUNT(sizeof(DHCP_CONTEXT), ALIGN_WORST) +
        ROUND_UP_COUNT(ClientUID->ClientUIDLength, ALIGN_WORST) + 
        ROUND_UP_COUNT(HwAddrSize, ALIGN_WORST ) +
        ROUND_UP_COUNT(sizeof(LOCAL_CONTEXT_INFO), ALIGN_WORST) +
        ROUND_UP_COUNT(DHCP_RECV_MESSAGE_SIZE, ALIGN_WORST);

    Ptr = DhcpAllocateMemory( DhcpContextSize );
    if ( Ptr == NULL ) return( ERROR_NOT_ENOUGH_MEMORY );

    memset(Ptr, 0, DhcpContextSize);

    DhcpContext = Ptr;                            // align up the pointers
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + sizeof(DHCP_CONTEXT), ALIGN_WORST);
    DhcpContext->ClientIdentifier.pbID = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + ClientUID->ClientUIDLength, ALIGN_WORST);
    DhcpContext->HardwareAddress = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + HwAddrSize, ALIGN_WORST);
    DhcpContext->LocalInformation = Ptr;
    LocalInfo = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + sizeof(LOCAL_CONTEXT_INFO), ALIGN_WORST);
    DhcpContext->MessageBuffer = Ptr;

    //
    // initialize fields.
    //

    DhcpContext->HardwareAddressType = HARDWARE_TYPE_10MB_EITHERNET;
    DhcpContext->HardwareAddressLength = HwAddrSize;
    DhcpContext->RefCount = 1 ;
    RtlCopyMemory(DhcpContext->HardwareAddress,HwAddrBuf, HwAddrSize);

    DhcpContext->ClientIdentifier.cbID = ClientUID->ClientUIDLength;
    DhcpContext->ClientIdentifier.bType = HARDWARE_TYPE_10MB_EITHERNET;
    DhcpContext->ClientIdentifier.fSpecified = TRUE;
    RtlCopyMemory(
        DhcpContext->ClientIdentifier.pbID, 
        ClientUID->ClientUID, 
        ClientUID->ClientUIDLength
        );

    DhcpContext->IpAddress = 0;
    DhcpContext->SubnetMask = DhcpDefaultSubnetMask(0);
    DhcpContext->DhcpServerAddress = 0xFFFFFFFF;
    DhcpContext->DesiredIpAddress = DesiredIpAddress;

    DhcpContext->Lease = 0;
    DhcpContext->LeaseObtained = 0;
    DhcpContext->T1Time = 0;
    DhcpContext->T2Time = 0;
    DhcpContext->LeaseExpires = 0;

    INIT_STATE(DhcpContext);
    AUTONET_ENABLED(DhcpContext);
    APICTXT_ENABLED(DhcpContext);                 // mark the context as being created by the API

    DhcpContext->IPAutoconfigurationContext.Address = 0;
    DhcpContext->IPAutoconfigurationContext.Subnet  = inet_addr(DHCP_IPAUTOCONFIGURATION_DEFAULT_SUBNET);
    DhcpContext->IPAutoconfigurationContext.Mask    = inet_addr(DHCP_IPAUTOCONFIGURATION_DEFAULT_MASK);
    DhcpContext->IPAutoconfigurationContext.Seed    = GetSeed();

    InitializeListHead(&DhcpContext->RecdOptionsList);
    InitializeListHead(&DhcpContext->SendOptionsList);
    InsertHeadList(&DhcpContext->SendOptionsList, &ParamRequestList.OptionList);

    DhcpContext->ClassId = ClassId;
    DhcpContext->ClassIdLength = ClassIdLen;

    //
    // copy local info.
    //

    //
    // unused portion of the local info.
    //

    LocalInfo->IpInterfaceContext = 0xFFFFFFFF;
    LocalInfo->AdapterName= NULL;
    //LocalInfo->DeviceName= NULL;
    LocalInfo->NetBTDeviceName= NULL;
    LocalInfo->RegistryKey= NULL;
    LocalInfo->DefaultGatewaysSet = FALSE;

    // used portion of the local info.
    LocalInfo->Socket = INVALID_SOCKET;

    // if AdapterIpAddress is loopback addr then, the client just wants us to
    // fabricate autonet address. The client can do this if there is no interface
    // available on this machine to autonet on.
    if (INADDR_LOOPBACK == AdapterIpAddress) {
        DhcpContext->IpAddress = GrandHashing(
            DhcpContext->HardwareAddress,
            DhcpContext->HardwareAddressLength,
            &DhcpContext->IPAutoconfigurationContext.Seed,
            DhcpContext->IPAutoconfigurationContext.Mask,
            DhcpContext->IPAutoconfigurationContext.Subnet
            );
        DhcpContext->SubnetMask = DhcpContext->IPAutoconfigurationContext.Mask;
        ACQUIRED_AUTO_ADDRESS(DhcpContext);
    } else {
        //
        // open socket now. receive any.
        //

        Error = InitializeDhcpSocket(&LocalInfo->Socket,ntohl( AdapterIpAddress ), IS_APICTXT_ENABLED(DhcpContext) );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // now discover an ip address.
        //

        Error = ObtainInitialParameters( DhcpContext, &DhcpOptions, &fAutoConfigure );
        if( ERROR_SEM_TIMEOUT == Error ) {
            DhcpPrint((DEBUG_PROTOCOL, "RAS: No server found, trying to autoconfigure\n"));
            if( fAutoConfigure ) {
                Error = DhcpPerformIPAutoconfiguration(DhcpContext);
            }
            if( ERROR_SUCCESS != Error ) {
                DhcpPrint((DEBUG_ERRORS, "Autoconfiguration for RAS failed: 0x%lx\n", Error));
            }
        }

        //
        // no matter what happens here, freeup the list of options as that is not really needed..
        //

        LOCK_OPTIONS_LIST();
        (void) DhcpDestroyOptionsList(&DhcpContext->RecdOptionsList, &DhcpGlobalClassesList);
        UNLOCK_OPTIONS_LIST();

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
    }

    //
    // allocate memory for the return client info structure.
    //

    LocalLeaseInfo = DhcpAllocateMemory( sizeof(DHCP_LEASE_INFO) );

    if( LocalLeaseInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    LocalLeaseInfo->ClientUID = *ClientUID;
    LocalLeaseInfo->IpAddress = ntohl( DhcpContext->IpAddress );

    if( IS_ADDRESS_AUTO(DhcpContext) ) {
        LocalLeaseInfo->SubnetMask = ntohl(DhcpContext->SubnetMask);
        LocalLeaseInfo->DhcpServerAddress = ntohl(DhcpContext->DhcpServerAddress);
        LocalLeaseInfo->Lease = DhcpContext->Lease;
        LocalLeaseInfo->LeaseObtained = DhcpContext->LeaseObtained;
        LocalLeaseInfo->T1Time = DhcpContext->T1Time;
        LocalLeaseInfo->T2Time = DhcpContext->T2Time;
        LocalLeaseInfo->LeaseExpires = DhcpContext->LeaseExpires;
        Error = ERROR_SUCCESS;
        *LeaseInfo = LocalLeaseInfo;
        goto Cleanup;
    }

    if ( DhcpOptions.SubnetMask != NULL ) {

        LocalLeaseInfo->SubnetMask= ntohl( *DhcpOptions.SubnetMask );
    }
    else {

        LocalLeaseInfo->SubnetMask =
            ntohl(DhcpDefaultSubnetMask( DhcpContext->IpAddress ));
    }


    LocalLeaseInfo->DhcpServerAddress =
        ntohl( DhcpContext->DhcpServerAddress );

    if ( DhcpOptions.LeaseTime != NULL) {

        LocalLeaseInfo->Lease = ntohl( *DhcpOptions.LeaseTime );
    } else {

        LocalLeaseInfo->Lease = DHCP_MINIMUM_LEASE;
    }

    Lease = LocalLeaseInfo->Lease;
    LeaseObtained = time( NULL );
    LocalLeaseInfo->LeaseObtained = LeaseObtained;

    T1 = 0;
    if ( DhcpOptions.T1Time != NULL ) {
        T1 = ntohl( *DhcpOptions.T1Time );
    }

    T2 = 0;
    if ( DhcpOptions.T2Time != NULL ) {
        T2 = ntohl( *DhcpOptions.T2Time );
    }

    //
    // make sure T1 < T2 < Lease
    //

    if( (T2 == 0) || (T2 > Lease) ) {
        T2 = Lease * 7 / 8; // default 87.7 %.
    }

    if( (T1 == 0) || (T1 > T2) ) {
        T1 = (T2 > Lease / 2) ? (Lease / 2) : (T2 - 1);
        // default 50 %.;
    }

    LocalLeaseInfo->T1Time = LeaseObtained  + T1;
    if ( LocalLeaseInfo->T1Time < LeaseObtained ) {
        LocalLeaseInfo->T1Time = INFINIT_TIME;  // over flow.
    }

    LocalLeaseInfo->T2Time = LeaseObtained + T2;
    if ( LocalLeaseInfo->T2Time < LeaseObtained ) {
        LocalLeaseInfo->T2Time = INFINIT_TIME;
    }

    LocalLeaseInfo->LeaseExpires = LeaseObtained + Lease;
    if ( LocalLeaseInfo->LeaseExpires < LeaseObtained ) {
        LocalLeaseInfo->LeaseExpires = INFINIT_TIME;
    }

    *LeaseInfo = LocalLeaseInfo;
    Error = ERROR_SUCCESS;

Cleanup:
    if( OptionInfo ) *OptionInfo = NULL;          // not implemented.

    //
    // close socket.
    //

    if( (LocalInfo != NULL) && (LocalInfo->Socket != INVALID_SOCKET) ) {
        closesocket( LocalInfo->Socket );
    }

    if( DhcpContext != NULL ) {
        DhcpFreeMemory( DhcpContext );
    }

    if( Error != ERROR_SUCCESS ) {

        //
        // free locally allocated memory, if we aren't successful.
        //

        if( LocalLeaseInfo != NULL ) {
            DhcpFreeMemory( LocalLeaseInfo );
            *LeaseInfo = NULL;
        }

    }

    return( Error );
}

DWORD
DhcpRenewIpAddressLeaseEx(
    DWORD AdapterIpAddress,
    LPDHCP_LEASE_INFO ClientLeaseInfo,
    LPDHCP_OPTION_LIST OptionList,
    LPDHCP_OPTION_INFO *OptionInfo,
    LPBYTE ClassId OPTIONAL,
    ULONG ClassIdLen
    )
/*++

Routine Description:

    This api renews an ip address that the client already has. When a
    client gets an ip address, it can use the address until the lease
    expires. The client should stop using the ip address after that.
    Also the client should renew the address after T1 time if the client
    is planning to use the address longer than the current lease time.

    WSAStartup must have been successfully called before this function
    can be called.

Arguments:

    AdapterIpAddress - IpAddress of the adapter. On a multi-homed
        machined this specifies the subnet from which an address is
        renewed. This value can be set to zero if the machine is
        non-multi-homed machine.

    ClientLeaseInfo : pointer to the client lease info structure. On
        entry the structure should contain the information that was
        returned by the DhcpLeaseIpAddress or DhcpRenewIpAddressLease
        apis. On return this structure is updated to reflect the lease
        extension.

    OptionList - list of option ids.

    OptionInfo - pointer to a location where the option info structure
        pointer is returned. The caller should free up this structure
        after use.

    ClassId - a byte sequence for user class

    ClassIdLen - number of bytes present in ClassId

Return Value:

    Windows Error.

--*/
{
    DWORD                          Error;
    PDHCP_CONTEXT                  DhcpContext = NULL;
    ULONG                          DhcpContextSize;
    PLOCAL_CONTEXT_INFO            LocalInfo;
    LPVOID                         Ptr;
    DHCP_OPTIONS                   DhcpOptions;
    time_t                         LeaseObtained;
    DWORD                          T1, T2, Lease;
    BYTE                           DefaultParamRequests[] = { 0x2E, 0x2C, 0x0F, 0x01, 0x03, 0x06, 0x2F };
    DWORD                          nDefaultParamRequests = sizeof(DefaultParamRequests);
    LPDHCP_CLIENT_UID              ClientUID = &(ClientLeaseInfo->ClientUID);
    ULONG                          HwAddrSize;
    BYTE                           HwAddrBuf[200];
    DHCP_OPTION                    ParamRequestList = {
        { NULL, NULL /* List entry */},
        OPTION_PARAMETER_REQUEST_LIST,
        FALSE /* not a vendor specific option */,
        NULL,
        0 /* no class id */,
        0 /* expiration time useless */,
        DefaultParamRequests,
        nDefaultParamRequests
    };

    if( NULL == ClassId && 0 != ClassIdLen || 0 == ClassIdLen && NULL != ClassId) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpCommonInit();
    if( ERROR_SUCCESS != Error ) return Error;

    //
    // prepare dhcp context structure.
    //

    HwAddrSize = 0;
    if( INADDR_ANY != AdapterIpAddress 
        && INADDR_LOOPBACK  != AdapterIpAddress ) {
        HwAddrSize = sizeof(HwAddrBuf);
        GetHardwareAddressForIpAddress( AdapterIpAddress, HwAddrBuf, &HwAddrSize );
    }

    if( 0 == HwAddrSize ) {
        HwAddrSize = ClientUID->ClientUIDLength;
        if( HwAddrSize > sizeof(HwAddrBuf) ) return ERROR_INVALID_DATA;
        RtlCopyMemory(HwAddrBuf, ClientUID->ClientUID, HwAddrSize );
    }

    DhcpContextSize =                             // allocate memory for dhcpcontext, in one blob
        ROUND_UP_COUNT(sizeof(DHCP_CONTEXT), ALIGN_WORST) +
        ROUND_UP_COUNT(ClientUID->ClientUIDLength, ALIGN_WORST) + 
        ROUND_UP_COUNT(HwAddrSize, ALIGN_WORST ) +
        ROUND_UP_COUNT(sizeof(LOCAL_CONTEXT_INFO), ALIGN_WORST) +
        ROUND_UP_COUNT(DHCP_RECV_MESSAGE_SIZE, ALIGN_WORST);

    Ptr = DhcpAllocateMemory( DhcpContextSize );
    if ( Ptr == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // make sure the pointers are aligned.
    //

    DhcpContext = Ptr;                            // align up the pointers
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + sizeof(DHCP_CONTEXT), ALIGN_WORST);
    DhcpContext->ClientIdentifier.pbID = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + ClientUID->ClientUIDLength, ALIGN_WORST);
    DhcpContext->HardwareAddress = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + HwAddrSize, ALIGN_WORST);
    DhcpContext->LocalInformation = Ptr;
    LocalInfo = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + sizeof(LOCAL_CONTEXT_INFO), ALIGN_WORST);
    DhcpContext->MessageBuffer = Ptr;

    //
    // initialize fields.
    //

    DhcpContext->HardwareAddressType = HARDWARE_TYPE_10MB_EITHERNET;
    DhcpContext->HardwareAddressLength = HwAddrSize;
    RtlCopyMemory(DhcpContext->HardwareAddress,HwAddrBuf, HwAddrSize);
    DhcpContext->RefCount = 1 ;

    DhcpContext->ClientIdentifier.cbID = ClientUID->ClientUIDLength;
    DhcpContext->ClientIdentifier.bType = HARDWARE_TYPE_10MB_EITHERNET;
    DhcpContext->ClientIdentifier.fSpecified = TRUE;
    RtlCopyMemory(
        DhcpContext->ClientIdentifier.pbID, 
        ClientUID->ClientUID, 
        ClientUID->ClientUIDLength
        );

    DhcpContext->IpAddress = htonl( ClientLeaseInfo->IpAddress );
    DhcpContext->SubnetMask = htonl( ClientLeaseInfo->SubnetMask );
    if( time(NULL) > ClientLeaseInfo->T2Time ) {
        DhcpContext->DhcpServerAddress = 0xFFFFFFFF;
    }
    else {
        DhcpContext->DhcpServerAddress =
            htonl( ClientLeaseInfo->DhcpServerAddress );
    }

    DhcpContext->DesiredIpAddress = DhcpContext->IpAddress;


    DhcpContext->Lease = ClientLeaseInfo->Lease;
    DhcpContext->LeaseObtained = ClientLeaseInfo->LeaseObtained;
    DhcpContext->T1Time = ClientLeaseInfo->T1Time;
    DhcpContext->T2Time = ClientLeaseInfo->T2Time;
    DhcpContext->LeaseExpires = ClientLeaseInfo->LeaseExpires;

    INIT_STATE(DhcpContext);
    AUTONET_ENABLED(DhcpContext);
    CTXT_WAS_LOOKED(DhcpContext);                 // this is to prevent PING from happeneing.
    APICTXT_ENABLED(DhcpContext);                 // mark the context as being created by the API

    DhcpContext->DontPingGatewayFlag = TRUE;      // double assurance against the former..
    DhcpContext->IPAutoconfigurationContext.Address = 0;
    DhcpContext->IPAutoconfigurationContext.Subnet  = inet_addr(DHCP_IPAUTOCONFIGURATION_DEFAULT_SUBNET);
    DhcpContext->IPAutoconfigurationContext.Mask    = inet_addr(DHCP_IPAUTOCONFIGURATION_DEFAULT_MASK);
    DhcpContext->IPAutoconfigurationContext.Seed    = GetSeed();

    InitializeListHead(&DhcpContext->RecdOptionsList);
    InitializeListHead(&DhcpContext->SendOptionsList);
    InsertHeadList(&DhcpContext->SendOptionsList, &ParamRequestList.OptionList);

    DhcpContext->ClassId = ClassId;
    DhcpContext->ClassIdLength = ClassIdLen;


    //
    // copy local info.
    //

    //
    // unused portion of the local info.
    //

    LocalInfo->IpInterfaceContext = 0xFFFFFFFF;
    LocalInfo->AdapterName= NULL;
    //LocalInfo->DeviceName= NULL;
    LocalInfo->NetBTDeviceName= NULL;
    LocalInfo->RegistryKey= NULL;

    //
    // used portion of the local info.
    //

    LocalInfo->Socket = INVALID_SOCKET;
    LocalInfo->DefaultGatewaysSet = FALSE;

    //
    // open socket now.
    //

    Error =  InitializeDhcpSocket(
                &LocalInfo->Socket,
                htonl( AdapterIpAddress ),
                IS_APICTXT_ENABLED(DhcpContext));

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // now discover ip address.
    //

    Error = RenewLease( DhcpContext, &DhcpOptions );

    //
    // no matter what happens here, freeup the list of options as that is not really needed..
    //

    LOCK_OPTIONS_LIST();
    (void) DhcpDestroyOptionsList(&DhcpContext->RecdOptionsList, &DhcpGlobalClassesList);
    UNLOCK_OPTIONS_LIST();


    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    ClientLeaseInfo->DhcpServerAddress =
        ntohl( DhcpContext->DhcpServerAddress );

    if ( DhcpOptions.LeaseTime != NULL) {

        ClientLeaseInfo->Lease = ntohl( *DhcpOptions.LeaseTime );
    } else {

        ClientLeaseInfo->Lease = DHCP_MINIMUM_LEASE;
    }

    Lease = ClientLeaseInfo->Lease;
    LeaseObtained = time( NULL );
    ClientLeaseInfo->LeaseObtained = LeaseObtained;

    T1 = 0;
    if ( DhcpOptions.T1Time != NULL ) {
        T1 = ntohl( *DhcpOptions.T1Time );
    }

    T2 = 0;
    if ( DhcpOptions.T2Time != NULL ) {
        T2 = ntohl( *DhcpOptions.T2Time );
    }

    //
    // make sure T1 < T2 < Lease
    //

    if( (T2 == 0) || (T2 > Lease) ) {
        T2 = Lease * 7 / 8; // default 87.7 %.
    }

    if( (T1 == 0) || (T1 > T2) ) {
        T1 = (T2 > Lease / 2) ? (Lease / 2) : (T2 - 1); // default 50 %.
    }

    ClientLeaseInfo->T1Time = LeaseObtained  + T1;
    if ( ClientLeaseInfo->T1Time < LeaseObtained ) {
        ClientLeaseInfo->T1Time = INFINIT_TIME; // over flow.
    }

    ClientLeaseInfo->T2Time = LeaseObtained + T2;
    if ( ClientLeaseInfo->T2Time < LeaseObtained ) {
        ClientLeaseInfo->T2Time = INFINIT_TIME;
    }

    ClientLeaseInfo->LeaseExpires = LeaseObtained + Lease;
    if ( ClientLeaseInfo->LeaseExpires < LeaseObtained ) {
        ClientLeaseInfo->LeaseExpires = INFINIT_TIME;
    }

    Error = ERROR_SUCCESS;

Cleanup:

    if( OptionInfo ) *OptionInfo = NULL;          // not implemented.

    if( (LocalInfo != NULL) && (LocalInfo->Socket != INVALID_SOCKET) ) {
        closesocket( LocalInfo->Socket );
    }

    if( DhcpContext != NULL ) {
        DhcpFreeMemory( DhcpContext );
    }

    return( Error );
}

DWORD
DhcpReleaseIpAddressLeaseEx(
    DWORD AdapterIpAddress,
    LPDHCP_LEASE_INFO ClientLeaseInfo,
    LPBYTE ClassId OPTIONAL,
    ULONG ClassIdLen
    )
/*++

Routine Description:

    This function releases an ip address the client has.
    WSAStartup must have already been called before this function can be called.

Arguments:

    AdapterIpAddress - IpAddress of the adapter. On a multi-homed
        machined this specifies the subnet to which an address is
        released. This value can be set to zero if the machine is
        non-multi-homed machine.

    ClientLeaseInfo : pointer to the client lease info structure. On
        entry the structure should contain the information that was
        returned by the DhcpLeaseIpAddress or DhcpRenewIpAddressLease
        apis.

    ClassId - a byte sequence for user class

    ClassIdLen - number of bytes present in ClassId

Return Value:

    Windows Error.

--*/
{
    DWORD Error;
    PDHCP_CONTEXT DhcpContext = NULL;
    ULONG DhcpContextSize;
    PLOCAL_CONTEXT_INFO LocalInfo;
    LPDHCP_CLIENT_UID ClientUID = &(ClientLeaseInfo->ClientUID);
    ULONG HwAddrSize;
    BYTE HwAddrBuf[200];
    LPVOID Ptr;

    if( NULL == ClassId && 0 != ClassIdLen || 0 == ClassIdLen && NULL != ClassId ) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpCommonInit();
    if( ERROR_SUCCESS != Error ) return Error;

    if( (DWORD) -1 == ClientLeaseInfo->DhcpServerAddress ) {
        // this means the address was autoconfigured, nothing to release..
        return ERROR_SUCCESS;
    }

    //
    // prepare dhcp context structure.
    //
    HwAddrSize = 0;
    if( INADDR_ANY != AdapterIpAddress 
        && INADDR_LOOPBACK  != AdapterIpAddress ) {
        HwAddrSize = sizeof(HwAddrBuf);
        GetHardwareAddressForIpAddress( AdapterIpAddress, HwAddrBuf, &HwAddrSize );
    }

    if( 0 == HwAddrSize ) {
        HwAddrSize = ClientUID->ClientUIDLength;
        if( HwAddrSize > sizeof(HwAddrBuf) ) return ERROR_INVALID_DATA;
        RtlCopyMemory(HwAddrBuf, ClientUID->ClientUID, HwAddrSize );
    }

    DhcpContextSize =                             // allocate memory for dhcpcontext, in one blob
        ROUND_UP_COUNT(sizeof(DHCP_CONTEXT), ALIGN_WORST) +
        ROUND_UP_COUNT(ClientUID->ClientUIDLength, ALIGN_WORST) + 
        ROUND_UP_COUNT(HwAddrSize, ALIGN_WORST ) +
        ROUND_UP_COUNT(sizeof(LOCAL_CONTEXT_INFO), ALIGN_WORST) +
        ROUND_UP_COUNT(DHCP_RECV_MESSAGE_SIZE, ALIGN_WORST);

    Ptr = DhcpAllocateMemory( DhcpContextSize );
    if ( Ptr == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // make sure the pointers are aligned.
    //

    DhcpContext = Ptr;                            // align up the pointers
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + sizeof(DHCP_CONTEXT), ALIGN_WORST);
    DhcpContext->ClientIdentifier.pbID = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + ClientUID->ClientUIDLength, ALIGN_WORST);
    DhcpContext->HardwareAddress = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + HwAddrSize, ALIGN_WORST);
    DhcpContext->LocalInformation = Ptr;
    LocalInfo = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + sizeof(LOCAL_CONTEXT_INFO), ALIGN_WORST);
    DhcpContext->MessageBuffer = Ptr;

    //
    // initialize fields.
    //

    DhcpContext->HardwareAddressType = HARDWARE_TYPE_10MB_EITHERNET;
    DhcpContext->HardwareAddressLength = HwAddrSize;
    RtlCopyMemory(DhcpContext->HardwareAddress,HwAddrBuf, HwAddrSize);
    DhcpContext->RefCount = 1 ;

    DhcpContext->ClientIdentifier.cbID = ClientUID->ClientUIDLength;
    DhcpContext->ClientIdentifier.bType = HARDWARE_TYPE_10MB_EITHERNET;
    DhcpContext->ClientIdentifier.fSpecified = TRUE;
    RtlCopyMemory(
        DhcpContext->ClientIdentifier.pbID, 
        ClientUID->ClientUID, 
        ClientUID->ClientUIDLength
        );

    DhcpContext->IpAddress = htonl( ClientLeaseInfo->IpAddress );
    DhcpContext->SubnetMask = htonl( ClientLeaseInfo->SubnetMask );
    DhcpContext->DhcpServerAddress = htonl( ClientLeaseInfo->DhcpServerAddress );

    DhcpContext->DesiredIpAddress = DhcpContext->IpAddress;

    DhcpContext->Lease = ClientLeaseInfo->Lease;
    DhcpContext->LeaseObtained = ClientLeaseInfo->LeaseObtained;
    DhcpContext->T1Time = ClientLeaseInfo->T1Time;
    DhcpContext->T2Time = ClientLeaseInfo->T2Time;
    DhcpContext->LeaseExpires = ClientLeaseInfo->LeaseExpires;

    INIT_STATE(DhcpContext);
    APICTXT_ENABLED(DhcpContext);                 // mark the context as being created by the API

    DhcpContext->IPAutoconfigurationContext.Address = 0;
    DhcpContext->IPAutoconfigurationContext.Subnet  = inet_addr(DHCP_IPAUTOCONFIGURATION_DEFAULT_SUBNET);
    DhcpContext->IPAutoconfigurationContext.Mask    = inet_addr(DHCP_IPAUTOCONFIGURATION_DEFAULT_MASK);
    DhcpContext->IPAutoconfigurationContext.Seed    = GetSeed();

    InitializeListHead(&DhcpContext->RecdOptionsList);
    InitializeListHead(&DhcpContext->SendOptionsList);

    DhcpContext->ClassId = ClassId;
    DhcpContext->ClassIdLength = ClassIdLen;

    //
    // copy local info.
    //

    //
    // unused portion of the local info.
    //

    LocalInfo->IpInterfaceContext = 0xFFFFFFFF;
    LocalInfo->AdapterName= NULL;
    //LocalInfo->DeviceName= NULL;
    LocalInfo->NetBTDeviceName= NULL;
    LocalInfo->RegistryKey= NULL;

    //
    // used portion of the local info.
    //

    LocalInfo->Socket = INVALID_SOCKET;
    LocalInfo->DefaultGatewaysSet = FALSE;

    //
    // open socket now.
    //

    Error =  InitializeDhcpSocket(
                &LocalInfo->Socket,
                htonl( AdapterIpAddress ),
                IS_APICTXT_ENABLED(DhcpContext));

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // now release ip address.
    //

    Error = ReleaseIpAddress( DhcpContext );

    ClientLeaseInfo->IpAddress = 0;
    ClientLeaseInfo->SubnetMask = DhcpDefaultSubnetMask( 0 );
    ClientLeaseInfo->DhcpServerAddress = 0xFFFFFFFF;
    ClientLeaseInfo->Lease = 0;

    ClientLeaseInfo->LeaseObtained =
        ClientLeaseInfo->T1Time =
        ClientLeaseInfo->T2Time =
        ClientLeaseInfo->LeaseExpires = time( NULL );

    //
    // recd options list cannot have any elements now..!
    //
    DhcpAssert(IsListEmpty(&DhcpContext->RecdOptionsList));

  Cleanup:

    if( (LocalInfo != NULL) && (LocalInfo->Socket != INVALID_SOCKET) ) {
        closesocket( LocalInfo->Socket );
    }

    if( DhcpContext != NULL ) {
        DhcpFreeMemory( DhcpContext );
    }

    return( Error );
}

DWORD
DhcpLeaseIpAddress(
    DWORD AdapterIpAddress,
    LPDHCP_CLIENT_UID ClientUID,
    DWORD DesiredIpAddress,
    LPDHCP_OPTION_LIST OptionList,
    LPDHCP_LEASE_INFO *LeaseInfo,
    LPDHCP_OPTION_INFO *OptionInfo
    )
/*++

Routine Description:

    This api obtains an IP address lease from a dhcp server. The
    caller should specify the client uid and a desired ip address.
    The client uid must be globally unique. Set the desired ip address
    to zero if you can accept any ip address. Otherwise this api will
    try to obtain the ip address you have specified, but not guaranteed.

    The caller may optionally requtest additional option info from the
    dhcp server, The caller should specify the list in OptionList
    parameter and the api will return the available option data in
    OptionInfo structure.

    ?? Option retrival is not implemented in the first phase. This
    requires several modification in the dhcp client code.

    Please do not use this function -- this is deprecated. Use the
    Ex functions instead.

Arguments:

    AdapterIpAddress - IpAddress of the adapter. On a multi-homed
        machined this specifies the subnet from which an address is
        requested. This value can be set to zero if the machine is a
        non-multi-homed machine or you like to get ip address from any
        of the subnets. This must be network byte order..

    ClientUID - pointer to a client UID structure.

    DesiredIpAddress - the ip address you prefer.

    OptionList - list of option ids.

    LeaseInfo - pointer to a location where the lease info structure
        pointer is retured. The caller should free up this structure
        after use.

    OptionInfo - pointer to a location where the option info structure
        pointer is returned. The caller should free up this structure
        after use.

Return Value:

    Windows Error.

--*/
{

    return DhcpLeaseIpAddressEx(
        AdapterIpAddress,
        ClientUID,
        DesiredIpAddress,
        OptionList,
        LeaseInfo,
        OptionInfo,
        DEFAULT_RAS_CLASS,
        strlen(DEFAULT_RAS_CLASS)
    );
}

DWORD
DhcpRenewIpAddressLease(
    DWORD AdapterIpAddress,
    LPDHCP_LEASE_INFO ClientLeaseInfo,
    LPDHCP_OPTION_LIST OptionList,
    LPDHCP_OPTION_INFO *OptionInfo
    )
/*++

Routine Description:

    This api renews an ip address that the client already has. When a
    client gets an ip address, it can use the address until the lease
    expires. The client should stop using the ip address after that.
    Also the client should renew the address after T1 time if the client
    is planning to use the address longer than the current lease time.

Arguments:

    AdapterIpAddress - IpAddress of the adapter. On a multi-homed
        machined this specifies the subnet from which an address is
        renewed. This value can be set to zero if the machine is
        non-multi-homed machine.

    ClientLeaseInfo : pointer to the client lease info structure. On
        entry the structure should contain the information that was
        returned by the DhcpLeaseIpAddress or DhcpRenewIpAddressLease
        apis. On return this structure is updated to reflect the lease
        extension.

    OptionList - list of option ids.

    OptionInfo - pointer to a location where the option info structure
        pointer is returned. The caller should free up this structure
        after use.

Return Value:

    Windows Error.

--*/
{
    return DhcpRenewIpAddressLeaseEx(
        AdapterIpAddress,
        ClientLeaseInfo,
        OptionList,
        OptionInfo,
        DEFAULT_RAS_CLASS,
        strlen(DEFAULT_RAS_CLASS)
    );
}

DWORD
DhcpReleaseIpAddressLease(
    DWORD AdapterIpAddress,
    LPDHCP_LEASE_INFO ClientLeaseInfo
    )
/*++

Routine Description:

    This function releases an ip address the client has.

Arguments:

    AdapterIpAddress - IpAddress of the adapter. On a multi-homed
        machined this specifies the subnet to which an address is
        released. This value can be set to zero if the machine is
        non-multi-homed machine.

    ClientLeaseInfo : pointer to the client lease info structure. On
        entry the structure should contain the information that was
        returned by the DhcpLeaseIpAddress or DhcpRenewIpAddressLease
        apis.

Return Value:

    Windows Error.

--*/
{
    return DhcpReleaseIpAddressLeaseEx(
        AdapterIpAddress,
        ClientLeaseInfo,
        DEFAULT_RAS_CLASS,
        strlen(DEFAULT_RAS_CLASS)
    );
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\client\nt\mdhcptst.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    mdhcptst.c

--*/

#include "precomp.h"

// only when the api is defined!
#include <dhcploc.h>
#include <dhcppro.h>
#include <mdhcpcli.h>

#define CREATE_NEW_REQUEST_FROM_RESPONSE(pRequest, pResponse) {  \
    (pRequest)->LeaseStartTime = (pRequest)->MaxLeaseStartTime = 0; \
    (pRequest)->LeaseDuration = (pRequest)->MinLeaseDuration = 0; \
    (pRequest)->MinAddrCount = (pRequest)->AddrCount = (pResponse)->AddrCount;    \
    (pRequest)->ServerAddress = (pResponse)->ServerAddress; \
    memcpy((pRequest)->pAddrBuf, (pResponse)->pAddrBuf, sizeof (DWORD)*(pRequest)->AddrCount); \
}

typedef enum _cmd{
    EnumScope    = 1,
    RequestAddr  = 2,
    RenewAddr    = 3,
    ReleaseAddr  = 4,
    ExitLoop     = 99
} COMMAND;

PMCAST_SCOPE_ENTRY    gScopeList = NULL;
DWORD                 gScopeCount = 0;
LPMCAST_CLIENT_UID    gAddrRequestId = NULL;

typedef struct _LeaseEntry {
    IPNG_ADDRESS            ScopeID;
    PMCAST_LEASE_RESPONSE   pLeaseInfo;
    LPMCAST_CLIENT_UID      pRequestID;
    LIST_ENTRY              Linkage;
} LEASE_ENTRY, *PLEASE_ENTRY;

LIST_ENTRY gLeaseList;

void
InitializeGlobalData()
{
    InitializeListHead(&gLeaseList);
    return;
}

void
DisplayMenu()
{
    printf("MDHCP Test Menu\n");
    printf("===============\n");
    printf("[1] - Enumerate Scopes:\n");
    printf("[2] - Request Address:\n");
    printf("[3] - Renew Address:\n");
    printf("[4] - Release Address: \n");
    printf("[99] - Exit:\n");
}
int
GetCommand()
{
    DWORD   cmd;
    printf("Enter choice:");
    if(scanf("%d",&cmd)) return cmd;
    return 0;
}

DWORD
EnumScopes()
{
    DWORD Error;
    DWORD BufLen;

    if ( gScopeList ) {
        DhcpFreeMemory( gScopeList );
        gScopeList = NULL;
    }
    Error = McastEnumerateScopes(
                AF_INET,
                TRUE,
                NULL,
                &BufLen,
                &gScopeCount
                );
    if (ERROR_SUCCESS != Error) {
        printf("Could not get the scope buf length, %ld\n",Error );
        return Error;
    }

    gScopeList = DhcpAllocateMemory( BufLen );
    Error = McastEnumerateScopes(
                AF_INET,
                FALSE,
                gScopeList,
                &BufLen,
                &gScopeCount);
    if (ERROR_SUCCESS != Error) {
        printf("Could not get the scope list- 2nd call, %ld\n",Error );
        DhcpFreeMemory( gScopeList );
        gScopeList = NULL;
        return Error;
    }
    DhcpAssert( gScopeCount > 0 );
    return Error;
}


void
DisplayScopes()
{
    DWORD i;
    PMCAST_SCOPE_ENTRY pScope = gScopeList;

    for (i = 0;i<gScopeCount; i++,pScope++) {
        printf("[%d] - ScopeId %lx, LastAddr %lx, ttl %d, Name %ws\n",
               i+1,ntohl(pScope->ScopeCtx.ScopeID.IpAddrV4),
               ntohl(pScope->LastAddr.IpAddrV4), pScope->TTL,  pScope->ScopeDesc.Buffer);
    }
    return;
}


void
PrintLeaseInfo(PMCAST_LEASE_RESPONSE pLeaseInfo, BOOL Verbose )
{
    DHCP_IP_ADDRESS IpAddress = *(DWORD UNALIGNED *)pLeaseInfo->pAddrBuf;
    time_t tempTime;

    printf("Obtained IPAddress - %s\n",inet_ntoa(*(struct in_addr *)&IpAddress));
    if ( Verbose ) {
        tempTime = pLeaseInfo->LeaseEndTime;

        printf("Expires - %.19s", asctime(localtime(&tempTime)));
    }
}

VOID
DisplayCurrentLeases()
{
    PLEASE_ENTRY        pLeaseEntry;
    PLIST_ENTRY         p;
    DWORD               i;

    for (p = gLeaseList.Flink,i=1; p != &gLeaseList; p = p->Flink,i++ ) {
        pLeaseEntry = CONTAINING_RECORD(p, LEASE_ENTRY, Linkage);
        printf("[%d] ", i);PrintLeaseInfo( pLeaseEntry->pLeaseInfo, FALSE );
    }
    return;
}

PLEASE_ENTRY
SelectFromCurrentLease(COMMAND cmd)
{
    PLIST_ENTRY p;
    DWORD       index;
    DWORD       i;
    PLEASE_ENTRY    pLeaseEntry = NULL;
    if (cmd != RenewAddr && cmd != ReleaseAddr) {
        DhcpAssert( FALSE );
    }
    printf("CURRENT LEASE ASSIGNMENTS\n");
    printf("-------------------------\n");

    DisplayCurrentLeases();
    printf("Select the lease you want to %s\n", RenewAddr == cmd ? "Renew" : "Release" );
    index = GetCommand();
    if ( !index ) {
        printf("Lease index invalid\n");
        return NULL;
    }
    for (p = gLeaseList.Flink,i=0; p != &gLeaseList; p = p->Flink ) {
        if (++i == index) {
            pLeaseEntry = CONTAINING_RECORD(p, LEASE_ENTRY, Linkage);
            return pLeaseEntry;
        }
    }
    printf("Error:invalid selection, choose the index from the list of the leases above\n");
    return NULL;
}

DWORD
ReleaseAddress()
{
    PLEASE_ENTRY            pLeaseEntry;
    PMCAST_LEASE_REQUEST    AddrRequest;
    DWORD                   Error;
    DWORD                   i;


    pLeaseEntry = SelectFromCurrentLease(ReleaseAddr);

    if (!pLeaseEntry) {
        return ERROR_FILE_NOT_FOUND;
    }
    AddrRequest = DhcpAllocateMemory( sizeof( *AddrRequest ) + sizeof(DHCP_IP_ADDRESS));
    if (!AddrRequest) {
        printf("Failed to allocate lease info struct\n");
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory(AddrRequest, sizeof(*AddrRequest) + sizeof(DHCP_IP_ADDRESS));
    AddrRequest->pAddrBuf = (PBYTE) AddrRequest + sizeof(*AddrRequest);

    CREATE_NEW_REQUEST_FROM_RESPONSE(AddrRequest, pLeaseEntry->pLeaseInfo);

    Error = McastReleaseAddress(
                AF_INET,
                pLeaseEntry->pRequestID,
                AddrRequest
                );

    if (ERROR_SUCCESS == Error ) {
        printf("Lease Released successfully\n");
        RemoveEntryList( &pLeaseEntry->Linkage );
        // free the old lease structure.
        DhcpFreeMemory( pLeaseEntry->pRequestID );
        DhcpFreeMemory( pLeaseEntry->pLeaseInfo );
    }
    DhcpFreeMemory(AddrRequest);
    return Error;
}

DWORD
RenewAddress()
{
    PLEASE_ENTRY pLeaseEntry;
    PMCAST_LEASE_REQUEST    AddrRequest;
    PMCAST_LEASE_RESPONSE  AddrResponse;
    PMCAST_LEASE_RESPONSE  pLeaseInfo;
    PMCAST_SCOPE_ENTRY        Scope;
    DWORD               Error;
    DWORD               i;

    pLeaseEntry = SelectFromCurrentLease(RenewAddr);
    if (!pLeaseEntry) {
        return ERROR_FILE_NOT_FOUND;
    }

    pLeaseInfo = pLeaseEntry->pLeaseInfo;
    // find the scope ctx for this scope id.
    if (pLeaseEntry->ScopeID.IpAddrV4) {
        for (i=0;i<gScopeCount;i++) {
            if (pLeaseEntry->ScopeID.IpAddrV4 == gScopeList[i].ScopeCtx.ScopeID.IpAddrV4) {
                Scope = &gScopeList[i];
                break;
            }
        }
        if (i >= gScopeCount) {
            printf("Could not find the scope ctx for the scope id %ld of this address\n",pLeaseEntry->ScopeID.IpAddrV4);
            return ERROR_FILE_NOT_FOUND;
        }
    } else {
        // default scope
        Scope = NULL;
    }

    AddrRequest = DhcpAllocateMemory( sizeof( *AddrRequest ) + sizeof(DHCP_IP_ADDRESS));
    if (!AddrRequest) {
        printf("Failed to allocate lease info struct\n");
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory(AddrRequest, sizeof(*AddrRequest) + sizeof(DHCP_IP_ADDRESS));
    AddrRequest->pAddrBuf = (PBYTE) AddrRequest + sizeof(*AddrRequest);

    CREATE_NEW_REQUEST_FROM_RESPONSE(AddrRequest, pLeaseInfo);
    AddrResponse = DhcpAllocateMemory( sizeof( *AddrResponse ) + sizeof(DHCP_IP_ADDRESS));
    if (!AddrResponse) {
        printf("Failed to allocate lease info struct\n");
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory(AddrResponse, sizeof(*AddrResponse) + sizeof(DHCP_IP_ADDRESS));
    AddrResponse->pAddrBuf = (PBYTE) AddrResponse + sizeof(*AddrResponse);
    AddrResponse->AddrCount = 1;
    Error = McastRenewAddress(
                AF_INET,
                pLeaseEntry->pRequestID,
                AddrRequest,
                AddrResponse
                );

    if (ERROR_SUCCESS == Error ) {
        printf("Lease Renew'd successfully\n");
        PrintLeaseInfo( AddrResponse, TRUE );
        pLeaseEntry->pLeaseInfo = AddrResponse;
        // free the old lease structure.
        DhcpFreeMemory( pLeaseInfo );
    } else {
        DhcpFreeMemory( AddrResponse );
    }

    DhcpFreeMemory( AddrRequest );
    return Error;
}

DWORD
RequestAddress()
{
    PMCAST_LEASE_REQUEST   AddrRequest;
    PMCAST_LEASE_RESPONSE AddrResponse;
    LPMCAST_CLIENT_UID   pRequestID;
    DWORD               index;
    DWORD               Error;
    PLEASE_ENTRY         pLeaseEntry;

    DisplayScopes();
    printf("Select the scope entry(0 for default scope)\n");
    index = GetCommand();
    if ( index > gScopeCount ) {
        printf("Scope index out of range\n");
        return ERROR_INVALID_PARAMETER;
    }


    AddrResponse = DhcpAllocateMemory( sizeof( *AddrResponse ) + sizeof(DHCP_IP_ADDRESS));
    if (!AddrResponse) {
        printf("Failed to allocate lease info struct\n");
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory(AddrResponse, sizeof(*AddrResponse)+ sizeof(DHCP_IP_ADDRESS));
    AddrResponse->pAddrBuf = (PBYTE) AddrResponse + sizeof(*AddrResponse);

    AddrRequest = DhcpAllocateMemory( sizeof( *AddrRequest ));
    if (!AddrRequest) {
        printf("Failed to allocate lease info struct\n");
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory(AddrRequest, sizeof(*AddrRequest));

    AddrRequest->AddrCount = AddrResponse->AddrCount = 1;


    pRequestID = DhcpAllocateMemory(sizeof(*pRequestID) + MCAST_CLIENT_ID_LEN);
    if (!pRequestID) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    pRequestID->ClientUID = (char *)pRequestID + sizeof(*pRequestID);
    pRequestID->ClientUIDLength = MCAST_CLIENT_ID_LEN;

    Error = McastGenUID( pRequestID );
    DhcpAssert( ERROR_SUCCESS == Error );

    Error = McastRequestAddress(
                AF_INET,
                pRequestID,
                index ? &gScopeList[index-1].ScopeCtx : NULL,
                AddrRequest,
                AddrResponse
                );

    if (ERROR_SUCCESS == Error ) {
        printf("Lease obtained successfully\n");
        PrintLeaseInfo( AddrResponse, TRUE );

        // now copy this lease into our global structure.
        pLeaseEntry = DhcpAllocateMemory( sizeof(LEASE_ENTRY) );
        if (!pLeaseEntry) {
            printf("Failed to allocate lease entry item\n");
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        pLeaseEntry->pLeaseInfo = AddrResponse;
        pLeaseEntry->ScopeID.IpAddrV4    = index ? gScopeList[index-1].ScopeCtx.ScopeID.IpAddrV4 : 0;
        pLeaseEntry->pRequestID = pRequestID;

        InsertTailList(&gLeaseList, &pLeaseEntry->Linkage);

    } else {
        DhcpFreeMemory( pRequestID );
        DhcpFreeMemory( AddrResponse );
    }
    DhcpFreeMemory( AddrRequest );
    return Error;

}
int
__cdecl
main( int argc, char *argv[])
{
    DWORD   cmd;
    DWORD   Error;
    DWORD   Version;

    InitializeGlobalData();

    Version = MCAST_API_CURRENT_VERSION;
    if (ERROR_SUCCESS != McastApiStartup(&Version)) {
        printf("Current version %d not supported, Api Impl version %d\n",
               MCAST_API_CURRENT_VERSION, Version);
        return 0;
    }
    DisplayMenu();
    while(cmd = GetCommand() ){
        switch (cmd) {
        case EnumScope:
             Error = EnumScopes();
             if (ERROR_SUCCESS != Error ) {
                 printf("Enumerate Scope returned failures, %ld\n",Error);
             } else {
                 DisplayScopes();
             }
             break;
        case RequestAddr:
            Error = RequestAddress();
            if (ERROR_SUCCESS != Error ) {
                printf("RequestAddress returned failures, %ld\n",Error);
            }
            break;
        case RenewAddr:
            Error = RenewAddress();
            if (ERROR_SUCCESS != Error ) {
                printf("RenewAddress returned failures, %ld\n",Error);
            }
            break;
        case ReleaseAddr:
            Error = ReleaseAddress();
            if (ERROR_SUCCESS != Error ) {
                printf("ReleaseAddress returned failures, %ld\n",Error);
            }
            break;
        case ExitLoop:
            printf("Exiting\n");
            return 0;
        default:
            printf("invalid choice\n");
            break;
        }
        DisplayMenu();
    }
    return 0;
}

#if DBG

VOID
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length = 0;

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    va_end(arglist);

    DhcpAssert(length <= MAX_PRINTF_LEN);

    //
    // Output to the debug terminal,
    //

    printf( "%s", OutputBuffer);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\client\nt\nlanotif.c ===
#include "precomp.h"
#include "nlasvc.h"
#include "nlanotif.h"

CRITICAL_SECTION gNLA_LPC_CS;
HANDLE ghNLA_LPC_Port = NULL;

HANDLE
NLAConnectLPC()
{
    // Connect via LPC to the Winsock Mobility system service.
    HANDLE h = NULL;
    SECURITY_QUALITY_OF_SERVICE DynamicQoS = 
        {
            sizeof(SECURITY_QUALITY_OF_SERVICE),
            SecurityAnonymous,
            SECURITY_DYNAMIC_TRACKING,
            FALSE
        };
    WSM_LPC_DATA        data;
    ULONG               dataLength = sizeof(data);
    UNICODE_STRING      portName;
    DWORD               retCode;

    DhcpPrint((DEBUG_TRACK, "Entering NLAConnectLPC.\n"));

    RtlZeroMemory(&data, sizeof(data));
    data.signature = WSM_SIGNATURE;
    data.connect.version.major = WSM_VERSION_MAJOR;
    data.connect.version.minor = WSM_VERSION_MINOR;

    RtlInitUnicodeString(&portName, WSM_PRIVATE_PORT_NAME);

    retCode = NtConnectPort(
                    &h,
                    &portName,
                    &DynamicQoS,
                    NULL,
                    NULL, 
                    NULL,
                    &data, &dataLength);

    if ( retCode != STATUS_SUCCESS)
    {
        DhcpPrint((DEBUG_TRACK, "NtConnectPort failed with errCode 0x%08x.\n", retCode));

        if (h != NULL)
        {
            CloseHandle(h);
            h = NULL;
        }
    }

    DhcpPrint((DEBUG_TRACK, "Exiting NLAConnectLPC.\n"));

    return (h);

} // NLAConnectLPC

void
NLANotifyDHCPChange() 
{
    WSM_LPC_MESSAGE message;
    DWORD           retCode;

    DhcpPrint((DEBUG_TRACK, "Entering NLANotifyDHCPChange.\n"));

    EnterCriticalSection(&gNLA_LPC_CS);

    // Connect to the NLA service if necessary.
    if (ghNLA_LPC_Port == NULL)
    {
        if ((ghNLA_LPC_Port = NLAConnectLPC()) == NULL)
        {
            LeaveCriticalSection(&gNLA_LPC_CS);

            DhcpPrint((DEBUG_TRACK, "Exiting NLANotifyDHCPChange as 1st call to NLAConnectLPC() failed.\n"));

	    return;
        }
    }

    // Send change notification to the NLA service.
    RtlZeroMemory(&message, sizeof(message));
    message.portMsg.u1.s1.TotalLength = sizeof(message);
    message.portMsg.u1.s1.DataLength = sizeof(message.data);
    message.data.signature = WSM_SIGNATURE;
    message.data.request.type = DHCP_NOTIFY_CHANGE; //WSM_LPC_REQUEST::DHCP_NOTIFY_CHANGE;

    retCode = NtRequestPort(ghNLA_LPC_Port, (PPORT_MESSAGE)&message);
    if (retCode != STATUS_SUCCESS) 
    {
        DhcpPrint((DEBUG_TRACK, "NLANotifyDHCPChange: NtRequestPort failed with errCode 0x%08x.\n", retCode));

	// It's possible the service was stopped and restarted.
	// Ditch the old LPC connection.
        CloseHandle(ghNLA_LPC_Port);
	
	// Create a new LPC connection.
	if ((ghNLA_LPC_Port = NLAConnectLPC()) == NULL) 
        {
            LeaveCriticalSection(&gNLA_LPC_CS);

            DhcpPrint((DEBUG_TRACK, "Exiting NLANotifyDHCPChange as 2nd call to NLAConnectLPC() failed.\n"));

	    return;
	}

	// Try the notification one last time.
        NtRequestPort(ghNLA_LPC_Port, (PPORT_MESSAGE)&message);
    }

    LeaveCriticalSection(&gNLA_LPC_CS);

    DhcpPrint((DEBUG_TRACK, "Exiting NLANotifyDHCPChange.\n"));

} // NLANotifyDHCPChange
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\client\nt\nlanotif.h ===
#pragma once

//-------- exported variables --------
extern CRITICAL_SECTION gNLA_LPC_CS;
extern HANDLE ghNLA_LPC_Port;

//-------- exported functions --------
HANDLE NLAConnectLPC();
void NLANotifyDHCPChange();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\client\nt\optapi.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    optapi.c

--*/
/*--------------------------------------------------------------------------------
  This program is used to test the api options part of the api.
  Date: April 15 1997
  Author: RameshV (VK)
  Description: This program is used to test the options api part of the client
  options.
--------------------------------------------------------------------------------*/

#include "precomp.h"
#include <dhcploc.h>
#include <dhcppro.h>

#include <lmcons.h>
#include <align.h>

#include <apiappl.h>
#include <dhcpcapi.h>

#include <string.h>
#include <winbase.h>
#include <iphlpapi.h>

//--------------------------------------------------------------------------------
//  Some variables.
//--------------------------------------------------------------------------------

#define OMAP_MAX_OPTIONS 256

// The options to request.
BYTE Request[OMAP_MAX_OPTIONS];
int  nGlobalOptionsRequested = 0;

// The return values
BYTE *pObtained = NULL;
int   nObtained = 0, opt_data_size = 0;
BYTE *options_data;

// USAGE
#define USAGE  "Usage: %s <cmd> <arguments>\n\t"       \
"The currently supported cmd's and arguments are:\n\t" \
"\t<cmd>                        <arguments>\n\t"       \
"\tGetOptions         RequestList_in_Hex // such as 010503a1\n\t" \
"\tTestEvents         RequestList_in_Hex // such as 010503a1\n\t" \
"\tRelease            AdapterName                    // ipconfig /release\n\t" \
"\tRenew              AdapterName                    // ipconfig /renew  \n\t" \
"\tEnumClasses        AdapterName                    // enumerate dhcpclasses\n\t"\
"\tSetClass           AdapterName ClassName          // set user class\n\t"\
"\n\n"

//--------------------------------------------------------------------------------
//  Parse a hex list of options. (such as 0105434421 )
//--------------------------------------------------------------------------------
int // nOptionsRequested;
GetOptionList(char *s, char *Request) {
    int nOptionsRequested = 0;

    while(s && *s & *(s+1)) {
        *s = (UCHAR) tolower(*s);
            if(!isdigit(*s) && ((*s) < 'a' || (*s) > 'f') ) {
                fprintf(stderr, "found obscene character <%c> when looking for hex!\n", *s);
                fprintf(stderr, "bye\n");
                exit(1);
            }
            if(isdigit(*s))
                Request[nOptionsRequested] = (*s) - '0';
            else Request[nOptionsRequested] = (*s) - 'a' + 10;

            Request[nOptionsRequested] *= 0x10;
            // Now do the same for the next digit.
            s ++;

            *s = (UCHAR) tolower(*s);
            if(!isdigit(*s) && (*s) < 'a' && (*s) > 'f' ) {
                fprintf(stderr, "found obscene character <%c> when looking for hex!\n", *s);
                fprintf(stderr, "bye\n");
                exit(1);
            }
            if(isdigit(*s))
                Request[nOptionsRequested] += (*s) - '0';
            else Request[nOptionsRequested] += (*s) - 'a' + 10;

            s ++;
            nOptionsRequested ++;
    }

    if(*s) {
        fprintf(stderr, "ignoring character <%c>\n", *s);
    }
    return nOptionsRequested;
}

//--------------------------------------------------------------------------------
//  Here is the function that does the GetOptions command.
//  It parses the adaptername and then converts it to LPWSTR and
//  it also parses the requestlist and then it calls DhcpRequestOptions.
//  It prints out the data it gets back.
//--------------------------------------------------------------------------------
void
OptApiGetOptions(int argc, char *argv[]) {
    WCHAR AdapterName[100];
    PIP_INTERFACE_INFO IfInfo;
    UCHAR Buffer[4000];
    ULONG BufLen = sizeof(Buffer);
    DWORD Error;

    // first check if we have the right command.
    if(_stricmp(argv[1], "GetOptions")) {
        fprintf(stderr, "Internal inconsistency in OptApiGetOptions\n");
        exit(1);
    }

    // Now check and see if there are the correct number of arguments.
    if(argc != 3 ) {
        fprintf(stderr, USAGE, argv[0]);
        exit(1);
    }

    // Now first get the list of options requested.
    {
        nGlobalOptionsRequested = GetOptionList(argv[2], Request);
        {
            int i;
            printf("Requesting %d options: ", nGlobalOptionsRequested);
            for( i = 0 ; i < nGlobalOptionsRequested; i ++)
                printf("%02x ", (int)Request[i]);
        }

    }

    //
    // get the adaptername
    //
    IfInfo = (PIP_INTERFACE_INFO)Buffer;
    Error = GetInterfaceInfo(IfInfo, &BufLen);
    if( NO_ERROR != Error ) {
        printf("GetInterfaceInfo: 0x%lx\n", Error);
        exit(1);
    }

    if( IfInfo->NumAdapters == 0 ) {
        printf("No adapters !!\n");
        exit(1);
    }

    if( wcslen(IfInfo->Adapter[0].Name) <= 14 ) {
        printf("Invalid adapter name? : %ws\n", IfInfo->Adapter[0].Name);
        exit(1);
    }

    wcscpy(AdapterName, &IfInfo->Adapter[0].Name[14]);

    // now call the function to get options.
    printf(" from adapter <%ws>\n", AdapterName);

    {
        DWORD result;

        result = DhcpRequestOptions(
            //L"El59x1",    RAMESHV-P200's adapter
            // L"IEEPRO1",  SUNBEAM, KISSES (or CltApi) machine's adapter
            //L"NdisWan4",    // SUNBEAM, KISSES's wan adapter: does not have ip address.
            AdapterName,
            Request, nGlobalOptionsRequested,
            &options_data, &opt_data_size,
            &pObtained, &nObtained
            );
        printf("Result is: %d; Obtained: %d\nList size is %d\n",
               result,
               nObtained,
               opt_data_size);

        if(result) {
            fprintf(stderr, "function call failed\n");
            return;
        }

        printf("Data: ");
        while(opt_data_size--)
            printf("%02x ", *options_data++);
        printf("\n");
    }

    // done
    printf("bye\n");
}
void
OptApiRelease(int argc, char *argv[]) {
    WCHAR AdapterName[256];

    // Check for the size and # of arguments.
    if( argc != 3 ) {
        fprintf(stderr, USAGE , argv[0]);
        exit(1);
    }

    // Now create a WSTR out of argv[2].
    if( strlen(argv[2]) != mbstowcs(AdapterName, argv[2], strlen(argv[2]))) {
        fprintf(stderr, "Could not convert %s to LPWSTR! sorry\n", argv[2]);
        exit(1);
    }
    AdapterName[strlen(argv[2])] = L'\0';

    printf("Return Value = %ld\n", DhcpReleaseParameters(AdapterName));
}

void
OptApiRenew(int argc, char *argv[]) {
    WCHAR AdapterName[256];

    // Check for the size and # of arguments.
    if( argc != 3 ) {
        fprintf(stderr, USAGE , argv[0]);
        exit(1);
    }

    // Now create a WSTR out of argv[2].
    if( strlen(argv[2]) != mbstowcs(AdapterName, argv[2], strlen(argv[2]))) {
        fprintf(stderr, "Could not convert %s to LPWSTR! sorry\n", argv[2]);
        exit(1);
    }
    AdapterName[strlen(argv[2])] = L'\0';

    printf("Return Value = %ld\n", DhcpAcquireParameters(AdapterName));
}

void
OptApiTestEvents(int argc, char *argv[]) {
    WCHAR AdapterName[100];

    // first check if we have the right command.
    if(_stricmp(argv[1], "TestEvents")) {
        fprintf(stderr, "Internal inconsistency in OptApiGetOptions\n");
        exit(1);
    }

    // Now check and see if there are the correct number of arguments.
    if(argc != 4 ) {
        fprintf(stderr, USAGE, argv[0]);
        exit(1);
    }

    // Now first get the list of options requested.
    {
        nGlobalOptionsRequested = GetOptionList(argv[3], Request);
        {
            int i;
            printf("Testing Events for %d options: ", nGlobalOptionsRequested);
            for( i = 0 ; i < nGlobalOptionsRequested; i ++)
                printf("%02x ", (int)Request[i]);
        }

    }

    // Now get the adapter.
    if(strlen(argv[2]) != mbstowcs(AdapterName, argv[2], strlen(argv[2]))) {
        fprintf(stderr, "Could not convert %s to LPWSTR! sorry\n", argv[2]);
        exit(1);
    }

    // null terminate the string.
    AdapterName[strlen(argv[2])] = L'\0' ;

    // now call the function to get options.
    printf(" from adapter <%s>\n", argv[2]);

    {
        DWORD result;
        HANDLE Handle;

        result = DhcpRegisterOptions(
            AdapterName,
            Request, nGlobalOptionsRequested, &Handle
            );

        printf("result is %d, Handle = 0x%p\n", result, Handle);

        if(result) {
            fprintf(stderr, "function call failed\n");
            return;
        }

        printf("Please use another window to do a ipconfig /renew and obtain\n");
        printf("one of the above options...\n");
        printf("WaitForSingleObject(Handle,INFINITE) = ");
        switch(WaitForSingleObject(Handle, INFINITE)) {
        case WAIT_ABANDONED: printf("WAIT_ABANDONED! Giving up\n"); return;
        case WAIT_OBJECT_0 : printf("WAIT_OBJECT_0 ! proceeding\n"); break;
        case WAIT_TIMEOUT  : printf("WAIT_TIMEOUT  ! Giving up\n"); return;
        case WAIT_FAILED   : printf("WAIT_FAILED (%d); giving up\n", GetLastError()); return;
        default: printf("XXXX; this should not happen at all!\n"); return;
        }

        // Okay the object was signalled. So, now we have to do a request on this.
        result = DhcpRequestOptions(
            AdapterName,
            Request, nGlobalOptionsRequested,
            &options_data, &opt_data_size,
            &pObtained, &nObtained
            );
        printf("Result is: %d; Obtained: %d\nList size is %d\n",
               result,
               nObtained,
               opt_data_size);

        if(result) {
            fprintf(stderr, "function call failed\n");
            return;
        }

        printf("Data: ");
        while(opt_data_size--)
            printf("%02x ", *options_data++);
        printf("\n");

        // Now deregister this object.
        result = DhcpDeRegisterOptions(Handle);
        printf("DeRegister(0x%p) = %ld\n", Handle, result);
    }

    // done
    printf("bye\n");
}

void
OptApiEnumClasses(int argc, char *argv[]) {
    WCHAR AdapterName[256];
    DHCP_CLASS_INFO *Classes;
    ULONG Size, RetVal;
    ULONG i;

    // Check for the size and # of arguments.
    if( argc != 3 ) {
        fprintf(stderr, USAGE , argv[0]);
        exit(1);
    }

    // Now create a WSTR out of argv[2].
    if( strlen(argv[2]) != mbstowcs(AdapterName, argv[2], strlen(argv[2]))) {
        fprintf(stderr, "Could not convert %s to LPWSTR! sorry\n", argv[2]);
        exit(1);
    }
    AdapterName[strlen(argv[2])] = L'\0';

    Size = 0;
    Classes = NULL;
    RetVal = DhcpEnumClasses( 0, AdapterName, &Size, Classes);
    if( ERROR_MORE_DATA != RetVal ) {
        printf("Return Value for first call = %ld\n", RetVal);
        return;
    }

    printf("Size required is %ld\n", Size);
    if( 0 == Size ) return ;

    Classes = LocalAlloc(LMEM_FIXED, Size);
    if( NULL == Classes ) {
        printf("Could not allocate memory: %ld\n", GetLastError());
        return;
    }

    RetVal = DhcpEnumClasses(0, AdapterName, &Size, Classes);
    if( ERROR_SUCCESS != RetVal ) {
        printf("Return value for second call = %ld\n", RetVal);
        return;
    }

    printf("Returned # of classes = %ld\n", Size);

    for( i = 0; i != Size ; i ++ ) {
        ULONG j;

        printf("Class [%ld] = <%ws, %ws> Data[%ld] : ", i, Classes[i].ClassName, Classes[i].ClassDescr, Classes[i].ClassDataLen);
        for( j = 0; j != Classes[i].ClassDataLen ; j ++ ) {
            printf("%02X ", Classes[i].ClassData[j]);
        }
        printf("\n");
    }
}

void
OptApiSetClass(int argc, char *argv[]) {
    WCHAR AdapterName[256];
    WCHAR UserClass[256];
    HKEY InterfacesKey, AdapterKey;
    DHCP_PNP_CHANGE Changes = {
        0,
        0,
        0,
        0,
        TRUE
    };
        
    ULONG Size, RetVal;
    ULONG i;

    // check for the size and # of arguments
    if( argc != 4 ) {
        fprintf(stderr, USAGE, argv[0]);
        exit(1);
    }

    // Now create a WSTR out of argv[2] and argv[3]
    if( strlen(argv[2]) != mbstowcs(AdapterName, argv[2], strlen(argv[2]))) {
        fprintf(stderr, "Could not convert %s to LPwSTR! sorry\n", argv[2]);
        exit(1);
    }

    UserClass[strlen(argv[3])] = L'\0';
    if( strlen(argv[3]) != mbstowcs(UserClass, argv[3], strlen(argv[3]))) {
        fprintf(stderr, "Could not convert %s to LPwSTR! sorry\n", argv[3]);
        exit(1);
    }
    UserClass[strlen(argv[3])] = L'\0';

    RetVal = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,
        L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces",
        0,
        KEY_ALL_ACCESS,
        &InterfacesKey
        );
    if( ERROR_SUCCESS != RetVal ) {
        printf("Couldn't open Tcpip\\Interfaces key: %ld\n", RetVal);
        return;
    }

    RetVal = RegOpenKeyExW(
        InterfacesKey,
        AdapterName,
        0,
        KEY_ALL_ACCESS,
        &AdapterKey
        );
    if( ERROR_SUCCESS != RetVal ) {
        printf("Couldn't open Tcpip\\Interfaces\\%ws key : %ld\n", AdapterName, RetVal);
        return;
    }

    RetVal = RegSetValueExW(
        AdapterKey,
        L"DhcpClassId",
        0,
        REG_SZ,
        (LPBYTE)UserClass,
        (wcslen(UserClass)+1)*sizeof(WCHAR)
        );

    if( ERROR_SUCCESS != RetVal ) {
        printf("RegSetValueExW(DhcpClassId): %ld\n", RetVal);
        return;
    }

    RetVal = DhcpHandlePnPEvent(
        0,
        1,
        AdapterName,
        &Changes,
        NULL
        );
    printf("DhcpHandlePnPEvent: %ld\n", RetVal);
    
}

void __cdecl
main(int argc, char *argv[]) {
    if(argc < 2) {
        fprintf(stderr, USAGE, argv[0]);
        exit(1);
    }

    if(!_stricmp(argv[1], "GetOptions")) {
        OptApiGetOptions(argc, argv);
    } else if(!_stricmp(argv[1], "TestEvents")) {
        OptApiTestEvents(argc, argv);
    } else if(!_stricmp(argv[1], "Release") ) {
        OptApiRelease(argc, argv);
    } else if(!_stricmp(argv[1], "Renew") ) {
        OptApiRenew(argc, argv);
    } else if(!_stricmp(argv[1], "EnumClasses" ) ){
        OptApiEnumClasses(argc, argv);
    } else if(!_stricmp(argv[1], "SetClass" ) ) {
        OptApiSetClass(argc, argv);
    } else {
        // currently support for no other command.
        fprintf(stderr, USAGE, argv[0]);
        exit(1);
    }

    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\client\rogue\dhcploc.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcploc.c

Abstract:

    This apps is used to detect the rogue DHCP server on a subnet.

    To build, 'nmake UMTEST=dhcpcli'

Author:

    Madan Appiah (madana)  21-Oct-1993

Environment:

    User Mode - Win32

Revision History:

  Oct 1996, (a-martih) Martin Holladay
		Corrected AV bug when passed an unknown cmd-line parameter.

--*/

#include <dhcpcli.h>
#include <conio.h>
#include <locmsg.h>
#include <time.h>
#include <lmcons.h>
#include <lmmsg.h>

#define RECEIVE_TIMEOUT                 5           // in secs. 5 secs
#define THREAD_TERMINATION_TIMEOUT      10000       // in msecs. 10 secs
#define SOCKET_RECEIVE_BUFFER_SIZE      1024 * 4    // 4K max.
#define AUTH_SERVERS_MAX                64
#define SMALL_BUFFER_SIZE               32
#define ALERT_INTERVAL                  5 * 60      // 5 mins
#define ALERT_MESSAGE_LENGTH            256
#define MAX_ALERT_NAMES                 256

DWORD GlobalAuthServers[AUTH_SERVERS_MAX];
BOOL GlobalNoAuthPrint = FALSE;
DWORD GlobalAuthServersCount = 0;
HANDLE GlobalRecvThreadHandle = NULL;
BOOL GlobalTerminate = FALSE;
DWORD GlobalIpAddress = 0;
time_t GlobalLastAlertTime = 0;
DWORD GlobalAlertInterval = ALERT_INTERVAL;
LPWSTR GlobalAlertNames[MAX_ALERT_NAMES];
DWORD GlobalAlertNamesCount = 0;

#if DBG

VOID
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length = 0;

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    va_end(arglist);

    DhcpAssert(length <= MAX_PRINTF_LEN);

    //
    // Output to the debug terminal,
    //

    printf( "%s", OutputBuffer);
}

#endif // DBG

DWORD
OpenSocket(
    SOCKET *Socket,
    DWORD IpAddress,
    DWORD Port
    )
{
    DWORD Error;
    SOCKET Sock;
    DWORD OptValue;

    struct sockaddr_in SocketName;

    //
    // Create a socket
    //

    Sock = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );

    if ( Sock == INVALID_SOCKET ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    //
    // Make the socket share-able
    //

    OptValue = TRUE;
    Error = setsockopt(
                Sock,
                SOL_SOCKET,
                SO_REUSEADDR,
                (LPBYTE)&OptValue,
                sizeof(OptValue) );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    OptValue = TRUE;
    Error = setsockopt(
                Sock,
                SOL_SOCKET,
                SO_BROADCAST,
                (LPBYTE)&OptValue,
                sizeof(OptValue) );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    OptValue = SOCKET_RECEIVE_BUFFER_SIZE;
    Error = setsockopt(
                Sock,
                SOL_SOCKET,
                SO_RCVBUF,
                (LPBYTE)&OptValue,
                sizeof(OptValue) );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    SocketName.sin_family = PF_INET;
    SocketName.sin_port = htons( (unsigned short)Port );
    SocketName.sin_addr.s_addr = IpAddress;
    RtlZeroMemory( SocketName.sin_zero, 8);

    //
    // Bind this socket to the DHCP server port
    //

    Error = bind(
               Sock,
               (struct sockaddr FAR *)&SocketName,
               sizeof( SocketName )
               );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    *Socket = Sock;
    Error = ERROR_SUCCESS;

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // if we aren't successful, close the socket if it is opened.
        //

        if( Sock != INVALID_SOCKET ) {
            closesocket( Sock );
        }
    }

    return( Error );
}

BOOL
IsAuthServer(
    DWORD IpAddress
    )
{
    DWORD i;

    for( i = 0; i < GlobalAuthServersCount; i++ ) {
        if( IpAddress == GlobalAuthServers[i] ){
            return( TRUE );
        }
    }

    return( FALSE );
}


VOID
ExtractOptions1(
    POPTION Option,
    PDHCP_OPTIONS DhcpOptions,
    DWORD MessageSize
    )
{
    POPTION start = Option;
    POPTION nextOption;
    LPBYTE MagicCookie;

    //
    // initialize option data.
    //

    RtlZeroMemory( DhcpOptions, sizeof( DHCP_OPTIONS ) );

    if ( MessageSize == 0 ) {
        return;
    }

    //
    // check magic cookie.
    //

    MagicCookie = (LPBYTE) Option;

    if( (*MagicCookie != (BYTE)DHCP_MAGIC_COOKIE_BYTE1) ||
        (*(MagicCookie+1) != (BYTE)DHCP_MAGIC_COOKIE_BYTE2) ||
        (*(MagicCookie+2) != (BYTE)DHCP_MAGIC_COOKIE_BYTE3) ||
        (*(MagicCookie+3) != (BYTE)DHCP_MAGIC_COOKIE_BYTE4)) {

        return;
    }

    Option = (LPOPTION) (MagicCookie + 4);

    while ( Option->OptionType != OPTION_END ) {

        if ( Option->OptionType == OPTION_PAD ||
             Option->OptionType == OPTION_END ) {

            nextOption = (LPOPTION)( (LPBYTE)(Option) + 1);

        } else {

            nextOption = (LPOPTION)( (LPBYTE)(Option) + Option->OptionLength + 2);

        }

        //
        // Make sure that we don't walk off the edge of the message, due
        // to a forgotten OPTION_END option.
        //

        if ((PCHAR)nextOption - (PCHAR)start > (long)MessageSize ) {
            return;
        }

        switch ( Option->OptionType ) {

        case OPTION_MESSAGE_TYPE:
            DhcpAssert( Option->OptionLength == sizeof(BYTE) );
            DhcpOptions->MessageType =
                (BYTE UNALIGNED *)&Option->OptionValue;
            break;

        case OPTION_SUBNET_MASK:
            DhcpAssert( Option->OptionLength == sizeof(DWORD) );
            DhcpOptions->SubnetMask =
                (DHCP_IP_ADDRESS UNALIGNED *)&Option->OptionValue;
            break;

        case OPTION_LEASE_TIME:
            DhcpAssert( Option->OptionLength == sizeof(DWORD) );
            DhcpOptions->LeaseTime =
                (DWORD UNALIGNED *)&Option->OptionValue;
            break;

        case OPTION_SERVER_IDENTIFIER:
            DhcpAssert( Option->OptionLength == sizeof(DWORD) );
            DhcpOptions->ServerIdentifier =
                (DHCP_IP_ADDRESS UNALIGNED *)&Option->OptionValue;
            break;

        case OPTION_RENEWAL_TIME:
            DhcpAssert( Option->OptionLength == sizeof(DWORD) );
            DhcpOptions->T1Time =
                (DWORD UNALIGNED *)&Option->OptionValue;
            break;

        case OPTION_REBIND_TIME:
            DhcpAssert( Option->OptionLength == sizeof(DWORD) );
            DhcpOptions->T2Time =
                (DWORD UNALIGNED *)&Option->OptionValue;
            break;

        default:
            break;
        }

        Option = nextOption;
    }

    return;
}

DWORD
SendDiscovery(
    VOID
    )
{
    DWORD Error;
    BYTE MessageBuffer[DHCP_SEND_MESSAGE_SIZE];
    PDHCP_MESSAGE dhcpMessage = (PDHCP_MESSAGE)MessageBuffer;
    LPOPTION option;
    LPBYTE OptionEnd;
    BYTE value;

    BYTE *HardwareAddress = "123456";
    BYTE HardwareAddressLength = 6;
    LPSTR HostName = "ROGUE";

    SOCKET Sock;
    struct sockaddr_in socketName;
    DWORD i;

    //
    // prepare message.
    //

    RtlZeroMemory( dhcpMessage, DHCP_SEND_MESSAGE_SIZE );

    dhcpMessage->Operation = BOOT_REQUEST;
    dhcpMessage->HardwareAddressType = 1;

    //
    // Transaction ID is filled in during send
    //

    dhcpMessage->SecondsSinceBoot = 60; // random value ??
    dhcpMessage->Reserved = htons(DHCP_BROADCAST);

    memcpy(
        dhcpMessage->HardwareAddress,
        HardwareAddress,
        HardwareAddressLength
        );

    dhcpMessage->HardwareAddressLength = (BYTE)HardwareAddressLength;

    option = &dhcpMessage->Option;
    OptionEnd = (LPBYTE)dhcpMessage + DHCP_SEND_MESSAGE_SIZE;

    //
    // always add magic cookie first
    //

    option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) option, OptionEnd );

    value = DHCP_DISCOVER_MESSAGE;
    option = DhcpAppendOption(
                option,
                OPTION_MESSAGE_TYPE,
                &value,
                1,
                OptionEnd );


    //
    // Add client ID Option.
    //

    option = DhcpAppendClientIDOption(
                option,
                1,
                HardwareAddress,
                HardwareAddressLength,
                OptionEnd );

    //
    // add Host name and comment options.
    //

    option = DhcpAppendOption(
                 option,
                 OPTION_HOST_NAME,
                 (LPBYTE)HostName,
                 (BYTE)((strlen(HostName) + 1) * sizeof(CHAR)),
                 OptionEnd );

    //
    // Add END option.
    //

    option = DhcpAppendOption( option, OPTION_END, NULL, 0, OptionEnd );

    //
    // Send the message
    //

    //
    // open socket.
    //

    Error = OpenSocket(
                &Sock,
                GlobalIpAddress,
                DHCP_SERVR_PORT );

    if( Error != ERROR_SUCCESS ) {

        printf("OpenReceiveSocket failed %ld.", Error );
        return( Error );
    }

    //
    // Initialize the outgoing address.
    //

    socketName.sin_family = PF_INET;
    socketName.sin_port = htons( DHCP_SERVR_PORT );
    socketName.sin_addr.s_addr = (DHCP_IP_ADDRESS)(INADDR_BROADCAST);

    for ( i = 0; i < 8 ; i++ ) {
        socketName.sin_zero[i] = 0;
    }

    Error = sendto(
                Sock,
                (PCHAR)MessageBuffer,
                DHCP_SEND_MESSAGE_SIZE,
                0,
                (struct sockaddr *)&socketName,
                sizeof( struct sockaddr )
                );

    if ( Error == SOCKET_ERROR ) {
        Error = WSAGetLastError();
        printf("sendto failed %ld\n", Error );
        return( Error );
    }

    return( ERROR_SUCCESS );
}

VOID
LogEvent(
    LPSTR MsgTypeString,
    LPSTR IpAddressString,
    LPSTR ServerAddressString
    )
{
    HANDLE EventlogHandle;
    LPSTR Strings[3];

    //
    // open event registry.
    //

    EventlogHandle = RegisterEventSourceA(
                        NULL,
                        "DhcpTools" );

    if (EventlogHandle == NULL) {

        printf("RegisterEventSourceA failed %ld.", GetLastError() );
        return;
    }

    Strings[0] = MsgTypeString;
    Strings[1] = ServerAddressString;
    Strings[2] = IpAddressString;

    if( !ReportEventA(
            EventlogHandle,
            (WORD)EVENTLOG_INFORMATION_TYPE,
            0,            // event category
            DHCP_ROGUE_SERVER_MESSAGE,
            NULL,
            (WORD)3,
            0,
            Strings,
            NULL
            ) ) {

        printf("ReportEventA failed %ld.", GetLastError() );
    }

    DeregisterEventSource(EventlogHandle);

    return;
}

VOID
RaiseAlert(
    LPSTR MsgTypeString,
    LPSTR IpAddressString,
    LPSTR ServerAddressString
    )
{

    time_t TimeNow;
    DWORD Error;

    TimeNow = time( NULL );

    if( TimeNow > (time_t)(GlobalLastAlertTime + GlobalAlertInterval) ) {

        WCHAR uIpAddressString[SMALL_BUFFER_SIZE];
        WCHAR uServerAddressString[SMALL_BUFFER_SIZE];
        WCHAR uMsgTypeString[SMALL_BUFFER_SIZE];
        DWORD i;

        LPWSTR MessageParams[3];
        WCHAR AlertMessage[ ALERT_MESSAGE_LENGTH ];
        DWORD MsgLength;

        MessageParams[0] =
            DhcpOemToUnicode( MsgTypeString, uMsgTypeString );
        MessageParams[1] =
            DhcpOemToUnicode( ServerAddressString, uServerAddressString );
        MessageParams[2] =
            DhcpOemToUnicode( IpAddressString, uIpAddressString );

        MsgLength = FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        NULL,
                        DHCP_ROGUE_SERVER_MESSAGE,
                        0,                          // language id.
                        AlertMessage,               // return buffer place holder.
                        ALERT_MESSAGE_LENGTH,       // minimum buffer size (in characters) to allocate.
                        (va_list *)MessageParams    // insert strings.
                    );

        if( MsgLength == 0 ) {

            printf("FormatMessage failed %ld.", GetLastError() );
        }
        else {

            //
            // send alert message.
            //

            for( i = 0; i < GlobalAlertNamesCount; i++) {

                Error = NetMessageBufferSend(
                            NULL,
                            GlobalAlertNames[i],
                            NULL,
                            (LPBYTE)AlertMessage,
                            MsgLength * sizeof(WCHAR) );

                if( Error != ERROR_SUCCESS ) {

                    printf("NetMessageBufferSend failed %ld.", Error );
                    break;
                }
            }
        }

        GlobalLastAlertTime = TimeNow;
    }
}

VOID
DisplayMessage(
    LPSTR MessageBuffer,
    DWORD BufferLength,
    struct sockaddr_in *source
    )
{
    DHCP_OPTIONS DhcpOptions;
    PDHCP_MESSAGE DhcpMessage;
    SYSTEMTIME SystemTime;
    DWORD MessageType;
    LPSTR MessageTypeString;

    BOOL AuthServer = FALSE;

    CHAR IpAddressString[SMALL_BUFFER_SIZE];
    CHAR ServerAddressString[SMALL_BUFFER_SIZE];

    //
    // check to see this is valid DHCP packet.
    //

    if( BufferLength < DHCP_MESSAGE_FIXED_PART_SIZE ) {
        return;
    }

    DhcpMessage = (LPDHCP_MESSAGE) MessageBuffer;

    if( (DhcpMessage->Operation != BOOT_REQUEST) &&
        (DhcpMessage->Operation != BOOT_REPLY) ) {

        return;
    }

    //
    // extract options.
    //

    ExtractOptions1(
        &DhcpMessage->Option,
        &DhcpOptions,
        BufferLength - DHCP_MESSAGE_FIXED_PART_SIZE );

    if( DhcpOptions.MessageType == NULL ) {
        return;
    }

    MessageType = *DhcpOptions.MessageType;

    if( (MessageType < DHCP_DISCOVER_MESSAGE ) ||
            (MessageType > DHCP_RELEASE_MESSAGE ) ) {
        return;
    }

    //
    // packet is valid dhcp packet, print info.
    //

    //
    // if this packet is from one of the auth server and we are asked
    // not to print auth servers packet, so so.
    //


    if( DhcpOptions.ServerIdentifier != NULL ) {
        AuthServer = IsAuthServer(*DhcpOptions.ServerIdentifier);
    }

    if( GlobalNoAuthPrint && AuthServer ) {
        return;
    }

    GetLocalTime( &SystemTime );
    printf("%02u:%02u:%02u ",
                SystemTime.wHour,
                SystemTime.wMinute,
                SystemTime.wSecond );


    switch ( MessageType ) {
    case DHCP_DISCOVER_MESSAGE:
        MessageTypeString = "DISCOVER";

    case DHCP_OFFER_MESSAGE:
        MessageTypeString = "OFFER";
        break;

    case DHCP_REQUEST_MESSAGE:
        MessageTypeString = "REQUEST";
        break;

    case DHCP_DECLINE_MESSAGE:
        MessageTypeString = "DECLINE";
        break;

    case DHCP_ACK_MESSAGE:
        MessageTypeString = "ACK";
        break;

    case DHCP_NACK_MESSAGE:
        MessageTypeString = "NACK";
        break;

    case DHCP_RELEASE_MESSAGE:
        MessageTypeString = "RELEASE";
        break;

    default:
        MessageTypeString = "UNKNOWN";
        break;

    }

    printf("%8s ", MessageTypeString);

    strcpy(
        IpAddressString,
        inet_ntoa(*(struct in_addr *)&DhcpMessage->YourIpAddress) );

    printf("(IP)%-15s ", IpAddressString );

    if(DhcpOptions.ServerIdentifier != NULL ) {

        DWORD ServerId;

        ServerId = *DhcpOptions.ServerIdentifier;
        strcpy( ServerAddressString, inet_ntoa(*(struct in_addr *)&ServerId) );

        printf("(S)%-15s ", ServerAddressString );

        if( source->sin_addr.s_addr != ServerId ) {

            printf("(S1)%-15s ",
                inet_ntoa(*(struct in_addr *)&source->sin_addr.s_addr) );
        }
    }

    //
    // beep if this it is a non-auth server.
    //

    if( AuthServer == FALSE ) {
        printf("***");
        MessageBeep( MB_ICONASTERISK );

        //
        // log an event.
        //

        LogEvent(
            MessageTypeString,
            IpAddressString,
            ServerAddressString );

        RaiseAlert(
            MessageTypeString,
            IpAddressString,
            ServerAddressString );
    }

    printf("\n");
}


DWORD
ReceiveDatagram(
    VOID
    )
{
    DWORD Error;
    SOCKET Sock;
    BOOL SocketOpened = FALSE;
    fd_set readSocketSet;
    struct timeval timeout;
    struct sockaddr socketName;
    int socketNameSize = sizeof( socketName );

    CHAR MessageBuffer[DHCP_MESSAGE_SIZE];

    Error = OpenSocket(
                &Sock,
                GlobalIpAddress,
                DHCP_CLIENT_PORT );

    if( Error != ERROR_SUCCESS ) {

        printf("OpenReceiveSocket failed %ld.", Error );
        goto Cleanup;
    }

    SocketOpened = TRUE;

    //
    // receive message.
    //

    while( GlobalTerminate != TRUE ) {

        FD_ZERO( &readSocketSet );
        FD_SET( Sock, &readSocketSet );

        timeout.tv_sec = RECEIVE_TIMEOUT;
        timeout.tv_usec = 0;

        Error = select( 0, &readSocketSet, NULL, NULL, &timeout);

        if ( Error == 0 ) {

            //
            // Timeout before read data is available.
            //

            // printf("Receive timeout.\n");
        }
        else {

            //
            // receive available message.
            //

            Error = recvfrom(
                        Sock,
                        MessageBuffer,
                        sizeof(MessageBuffer),
                        0,
                        &socketName,
                        &socketNameSize
                        );

            if ( Error == SOCKET_ERROR ) {

                Error = WSAGetLastError();
                printf("recvfrom failed %ld\n", Error );
                goto Cleanup;
            }

            if( GlobalTerminate == TRUE ) {
                break;
            }

            DisplayMessage(
                MessageBuffer,
                Error, // buffer length returned.
                (struct sockaddr_in *)&socketName );
        }
    }

Cleanup:

    if( SocketOpened == TRUE ) {

        //
        // close socket.
        //

        closesocket( Sock );
    }

    GlobalTerminate = TRUE;
    return( Error );
}



DWORD __cdecl
main(
    int argc,
    char **argv
    )
{

    DWORD Error;
    LPSTR AppName = NULL;
    WSADATA wsaData;
    DWORD ThreadId;

    //
    // parse input parameters.
    //

    if( argc < 1 ) {
        goto Usage;
    }

    AppName = argv[0];
    argv++;
    argc--;

    if( argc < 1 ) {
        goto Usage;
    }

    //
    // parse flag parameter.
    //

    while( (argv[0][0] == '-') || (argv[0][0] == '/') ) {

        switch (argv[0][1] ) {
        case 'p':
            GlobalNoAuthPrint = TRUE;
            break;

        case 'i':
            GlobalAlertInterval = atoi( &argv[0][3] ) * 60;
            break;

        case 'a': {

            LPSTR NextName;
            LPSTR Ptr;

            Ptr = &argv[0][3];

            //
            // skip blanks.
            //

            while( *Ptr == ' ' ) {
                Ptr++;
            }
            NextName = Ptr;

            while( *Ptr != '\0' ) {

                if( *Ptr == ' ' ) {

                    //
                    // found another name.
                    //

                    *Ptr++ = '\0';

                    GlobalAlertNames[GlobalAlertNamesCount] =
                        DhcpOemToUnicode( NextName, NULL );
                    GlobalAlertNamesCount++;

                    if( GlobalAlertNamesCount >= MAX_ALERT_NAMES ) {
                        break;
                    }

                    //
                    // skip blanks.
                    //

                    while( *Ptr == ' ' ) {
                        Ptr++;
                    }
                    NextName = Ptr;
                }
                else {

                    Ptr++;
                }
            }

            if( GlobalAlertNamesCount < MAX_ALERT_NAMES ) {
                if( NextName != Ptr ) {
                    GlobalAlertNames[GlobalAlertNamesCount] =
                        DhcpOemToUnicode( NextName, NULL );
                    GlobalAlertNamesCount++;
                }
            }

            break;
        }
 
		//
		// (a-martih) - Bug Fix
		//
        default:
			if ((_stricmp(argv[0], "/?")) &&
				(_stricmp(argv[0], "-?")) &&
				(_stricmp(argv[0], "/h")) &&
				(_stricmp(argv[0], "-h")) ) {
					printf( "\nunknown flag, %s \n", argv[0] );
			}
			goto Usage;
    		break;
        }

        argv++;
        argc--;
    }

    if( argc < 1 ) {
        goto Usage;
    }

    //
    // read ipaddress parameter.
    //

    GlobalIpAddress = inet_addr( argv[0] );

    argv++;
    argc--;

    //
    // now read auth dhcp servers ipaddresses.
    //

    while( (argc > 0) && (GlobalAuthServersCount < AUTH_SERVERS_MAX) ) {

        GlobalAuthServers[GlobalAuthServersCount++] =
            inet_addr( argv[0] );

        argv++;
        argc--;
    }


    //
    // init socket.
    //

    Error = WSAStartup( WS_VERSION_REQUIRED, &wsaData);

    if( Error != ERROR_SUCCESS ) {
        printf( "WSAStartup failed %ld.\n", Error );
        return(1);
    }

    //
    // create receive datagrams thread.
    //

    GlobalRecvThreadHandle =
        CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE)ReceiveDatagram,
            NULL,
            0,
            &ThreadId );

    if( GlobalRecvThreadHandle == NULL ) {
        printf("CreateThread failed %ld.\n", GetLastError() );
        return(1);
    }


    //
    // read input.
    //

    while ( GlobalTerminate != TRUE ) {
        CHAR ch;

        ch = (CHAR)_getch();

        switch( ch ) {
        case 'q':
        case 'Q':
        // case '\c':
            GlobalTerminate = TRUE;
            break;

        case 'd':
        case 'D':

            //
            // send out discover message.
            //

            Error = SendDiscovery();

            if(Error != ERROR_SUCCESS ) {
                printf("SendDiscover failed %ld.\n", Error );
            }

            break;

        case 'h':
        case 'H':
        default:

            printf("Type d - to discover; q - to quit; h - for help.\n");

            //
            // print out help message.
            //

            break;
        }
    }

    //
    // terminate receive thread.
    //

    WaitForSingleObject(
            GlobalRecvThreadHandle,
            THREAD_TERMINATION_TIMEOUT );


    CloseHandle( GlobalRecvThreadHandle );

// Cleanup:

    return(0);

Usage:
	printf("\nUSAGE:\n\n");
    printf("%s [-p] [-a:\"list-of-alertnames\"] [-i:alertinterval] "
            "machine-ip-address "
            "[list of valid dhcp servers ip addresses]", AppName );

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\client\nt\util.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcp.c

Abstract:

    This file contains utility functions.

Author:

    Madan Appiah (madana) 7-Dec-1993.

Environment:

    User Mode - Win32

Revision History:

--*/

#include "precomp.h"
#include "dhcpglobal.h"
#include <dhcploc.h>
#include <dhcppro.h>

#define  MESSAGE_BOX_WIDTH_IN_CHARS 65

typedef struct _POPUP_THREAD_PARAM {
    LPWSTR Title;
    LPWSTR Message;
    ULONG  Flags;
} POPUP_THREAD_PARAM, *LPPOPUP_THREAD_PARAM;

POPUP_THREAD_PARAM PopupThreadParam = { NULL, NULL, 0 };


DWORD
DoPopup(
    PVOID Buffer
    )
/*++

Routine Description:

    This function pops up a message to the user.  It must run it's own
    thread.  When the user acknowledge the popup, the thread
    deallocates the message buffer and returns.

Arguments:

    Buffer - A pointer to a NULL terminated message buffer.

Return Values:

    Always returns 0
    
--*/
{
    DWORD Result;
    LPPOPUP_THREAD_PARAM Params = Buffer;

    Result = MessageBox(
        NULL, // no owner
        Params->Message, 
        Params->Title,
        ( MB_OK | Params->Flags |
          MB_SERVICE_NOTIFICATION |
          MB_SYSTEMMODAL |
          MB_SETFOREGROUND |
          MB_DEFAULT_DESKTOP_ONLY
            )
        );


    LOCK_POPUP();

    if( Params->Message != NULL ) {
        LocalFree( Params->Message );
        Params->Message = NULL;
    }

    if( Params->Title != NULL ) {
        LocalFree( Params->Title );
        Params->Title = NULL;
    }

    //
    // close the global handle, so that we will not consume this
    // thread resource until another popup.
    //

    CloseHandle( DhcpGlobalMsgPopupThreadHandle );
    DhcpGlobalMsgPopupThreadHandle = NULL;

    UNLOCK_POPUP();

    //
    // Always return 0
    //
    
    return 0;
}


DWORD
DisplayUserMessage(
    IN PDHCP_CONTEXT DhcpContext,
    IN DWORD MessageId,
    IN DHCP_IP_ADDRESS IpAddress
)
/*++

Routine Description:

    This function starts a new thread to display a message box.

    N.B.  If a thread already exists which is waiting for user input
    on a message box, then this routine does not create another
    thread.

Arguments:

    DhcpContext -- the context to display messages for
    
    MessageId - The ID of the message to display.
        (The actual message string is obtained from the dhcp module).

    IpAddress - Ip address involved.

--*/
{
    DWORD ThreadID, TitleLength, MsgLength, Flags;
    LPWSTR Title = NULL, Message = NULL;

    switch(MessageId) {

    case MESSAGE_FAILED_TO_OBTAIN_LEASE:
        Flags = MB_ICONSTOP;
        break;

    case MESSAGE_SUCCESSFUL_LEASE :
        Flags = MB_ICONINFORMATION;
        break;

    default:
        DhcpAssert(FALSE);
        Flags = MB_ICONSTOP;
        break;
    }

    LOCK_POPUP();

    //
    // if we are asked to display no message popup, simply return.
    //

    if ( DhcpGlobalDisplayPopup == FALSE ) {
        goto Cleanup;
    }

    //
    // if the message popup thread handle is non-null, check to see
    // the thread is still running, if so don't display another popup,
    // otherwise close the last popup handle and create another popup 
    // thread for new message.
    //

    if( DhcpGlobalMsgPopupThreadHandle != NULL ) {
        DWORD WaitStatus;

        //
        // Time out immediately if the thread is still running.
        //

        WaitStatus = WaitForSingleObject(
            DhcpGlobalMsgPopupThreadHandle,
            0 );
        
        if ( WaitStatus == WAIT_TIMEOUT ) {
            goto Cleanup;

        } else if ( WaitStatus == 0 ) {

            //
            // This shouldn't be a case, because we close this handle at
            // the end of popup thread.
            //

            DhcpAssert( WaitStatus == 0 );

            CloseHandle( DhcpGlobalMsgPopupThreadHandle );
            DhcpGlobalMsgPopupThreadHandle = NULL;

        } else {
            DhcpPrint((
                DEBUG_ERRORS,
                    "Cannot WaitFor message popup thread: %ld\n",
                        WaitStatus ));
            goto Cleanup;
        }
    }


    MsgLength = FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE
        | FORMAT_MESSAGE_ARGUMENT_ARRAY 
        | FORMAT_MESSAGE_ALLOCATE_BUFFER
        | MESSAGE_BOX_WIDTH_IN_CHARS,
        (LPVOID)DhcpGlobalMessageFileHandle,
        MessageId,
        0,  // language id.
        (LPWSTR)&Message, // return buffer place holder.
        0,  // minimum buffer size to allocate.
        NULL   // No Params
    );

    if ( MsgLength == 0) {
        DhcpPrint(( DEBUG_ERRORS,
            "FormatMessage failed, err = %ld.\n", GetLastError()));
        goto Cleanup;
    }

    DhcpAssert( Message != NULL );
    DhcpAssert( (wcslen(Message)) == MsgLength );

    //
    // get message box title.
    //

    TitleLength = FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE |
        FORMAT_MESSAGE_ALLOCATE_BUFFER,
        (LPVOID)DhcpGlobalMessageFileHandle,
        MESSAGE_POPUP_TITLE,
        0, // language id.
        (LPWSTR)&Title,  // return buffer place holder.
        0, // minimum buffer size to allocate.
        NULL  // insert strings.
    );

    if ( TitleLength == 0) {
        DhcpPrint(( DEBUG_ERRORS,
            "FormatMessage to Message box Title failed, err = %ld.\n",
                GetLastError()));
        goto Cleanup;
    }

    DhcpAssert( Title != NULL );
    DhcpAssert( (wcslen(Title)) == TitleLength );

    PopupThreadParam.Title = Title;
    PopupThreadParam.Message = Message;
    PopupThreadParam.Flags = Flags;


    //
    // Create a thread, to display a message box to the user.  We need
    // a new thread because MessageBox() blocks until the user clicks
    // on the OK button, and we can't block this thread.
    //
    // DoPopup frees the buffer.
    //

    DhcpGlobalMsgPopupThreadHandle = CreateThread(
        NULL,    // no security.
        0,       // default stack size.
        DoPopup, // entry point.
        (PVOID)&PopupThreadParam,
        0, 
        &ThreadID
    );

    if ( DhcpGlobalMsgPopupThreadHandle == NULL ) {
        DhcpPrint((
            DEBUG_ERRORS,
            "DisplayUserMessage:  Could not create thread, err = %ld.\n",
            GetLastError() ));
    }

Cleanup:

    UNLOCK_POPUP();

    return 0;
}

VOID
DhcpLogEvent(
    IN PDHCP_CONTEXT DhcpContext, OPTIONAL
    IN DWORD EventNumber,
    IN DWORD ErrorCode OPTIONAL
)
/*++

Routine Description:

    This functions formats and writes an event log entry.

Arguments:

    DhcpContext - The context for the event. Optional parameter.

    EventNumber - The event to log.

    ErrorCode - Windows Error code to record. Optional parameter.

--*/
{
    LPWSTR HWAddressBuffer = NULL;
    LPWSTR IPAddressBuffer = NULL;
    LPWSTR IPAddressBuffer2 = NULL;
    CHAR ErrorCodeOemStringBuf[32 + 1];
    WCHAR ErrorCodeStringBuf[32 + 1];
    LPWSTR ErrorCodeString = NULL;
    LPWSTR Strings[10];
    DHCP_IP_ADDRESS IpAddr;

    if( DhcpContext != NULL ) {

        if( EVENT_NACK_LEASE == EventNumber ) {
            IpAddr = DhcpContext->NackedIpAddress;
        } if( EVENT_ADDRESS_CONFLICT == EventNumber ) {
            IpAddr = DhcpContext->ConflictAddress;
        } else {
            IpAddr = DhcpContext->IpAddress;
        }
        
        HWAddressBuffer = DhcpAllocateMemory(
            (DhcpContext->HardwareAddressLength * 2 + 1) *
            sizeof(WCHAR)
            );

        if( HWAddressBuffer == NULL ) {
            DhcpPrint(( DEBUG_MISC, "Out of memory." ));
            goto Cleanup;
        }

        DhcpHexToString(
            HWAddressBuffer,
            DhcpContext->HardwareAddress,
            DhcpContext->HardwareAddressLength
            );

        HWAddressBuffer[DhcpContext->HardwareAddressLength * 2] = '\0';

        IPAddressBuffer = DhcpOemToUnicode(
            inet_ntoa( *(struct in_addr *)&IpAddr ),
            NULL
            );

        if( IPAddressBuffer == NULL ) {
            DhcpPrint(( DEBUG_MISC, "Out of memory." ));
            goto Cleanup;
        }

        if( EVENT_NACK_LEASE == EventNumber ) {
            IPAddressBuffer2 = DhcpOemToUnicode(
                inet_ntoa( *(struct in_addr *)&DhcpContext->DhcpServerAddress ),
                NULL
            );

            if( NULL == IPAddressBuffer2 ) goto Cleanup;
        }
    }

    strcpy( ErrorCodeOemStringBuf, "%%" );
    _ultoa( ErrorCode, ErrorCodeOemStringBuf + 2, 10 );

    ErrorCodeString = DhcpOemToUnicode(
                        ErrorCodeOemStringBuf,
                        ErrorCodeStringBuf );

    //
    // Log an event
    //

    switch ( EventNumber ) {

    case EVENT_LEASE_TERMINATED:

        DhcpAssert( HWAddressBuffer != NULL );
        DhcpAssert( IPAddressBuffer != NULL );

        Strings[0] = HWAddressBuffer;
        Strings[1] = IPAddressBuffer;

        DhcpReportEventW(
            DHCP_EVENT_CLIENT,
            EVENT_LEASE_TERMINATED,
            EVENTLOG_ERROR_TYPE,
            2,
            0,
            Strings,
            NULL );

        break;

    case EVENT_FAILED_TO_OBTAIN_LEASE:

        DhcpAssert( HWAddressBuffer != NULL );
        DhcpAssert( ErrorCodeString != NULL );

        Strings[0] = HWAddressBuffer;
        Strings[1] = ErrorCodeString;

        DhcpReportEventW(
            DHCP_EVENT_CLIENT,
            EVENT_FAILED_TO_OBTAIN_LEASE,
            EVENTLOG_ERROR_TYPE,
            2,
            sizeof(ErrorCode),
            Strings,
            &ErrorCode );

        break;

    case EVENT_NACK_LEASE:

        DhcpAssert( HWAddressBuffer != NULL );
        DhcpAssert( IPAddressBuffer != NULL );
        DhcpAssert( IPAddressBuffer2 != NULL );

        Strings[0] = IPAddressBuffer;
        Strings[1] = HWAddressBuffer;
        Strings[2] = IPAddressBuffer2;

        DhcpReportEventW(
            DHCP_EVENT_CLIENT,
            EVENT_NACK_LEASE,
            EVENTLOG_ERROR_TYPE,
            3,
            0,
            Strings,
            NULL );

        break;

    case EVENT_ADDRESS_CONFLICT:
        DhcpAssert( IPAddressBuffer != NULL );
        DhcpAssert( HWAddressBuffer != NULL );

        Strings[0] = IPAddressBuffer;
        Strings[1] = HWAddressBuffer;

        DhcpReportEventW(
            DHCP_EVENT_CLIENT,
            EVENT_ADDRESS_CONFLICT,
            EVENTLOG_WARNING_TYPE,
            2,
            0,
            Strings,
            NULL );
        break;

    case EVENT_IPAUTOCONFIGURATION_FAILED:
        DhcpAssert( HWAddressBuffer != NULL );
        DhcpAssert( ErrorCodeString != NULL );

        Strings[0] = HWAddressBuffer;
        Strings[1] = ErrorCodeString;

        DhcpReportEventW(
            DHCP_EVENT_CLIENT,
            EVENT_IPAUTOCONFIGURATION_FAILED,
            EVENTLOG_WARNING_TYPE,
            2,
            sizeof(ErrorCode),
            Strings,
            &ErrorCode );

        break;

     case EVENT_FAILED_TO_RENEW:

        // The 'timeout' event should be logged only if there is no PPP
        // adapter up. It is so because having a PPP adapter means the
        // routes are hijacked, hence renewals up to T2 are expected to
        // fail.
        if (ErrorCode != ERROR_SEM_TIMEOUT ||
            DhcpGlobalNdisWanAdaptersCount == 0 ||
            time(NULL) >= DhcpContext->T2Time)
        {
            DhcpAssert( HWAddressBuffer != NULL );
            DhcpAssert( ErrorCodeString != NULL );

            Strings[0] = HWAddressBuffer;
            Strings[1] = ErrorCodeString;

            DhcpReportEventW(
                DHCP_EVENT_CLIENT,
                EVENT_FAILED_TO_RENEW,
                EVENTLOG_WARNING_TYPE,
                2,
                sizeof(ErrorCode),
                Strings,
                &ErrorCode );
        }

        break;

    case EVENT_DHCP_SHUTDOWN:

        DhcpAssert( ErrorCodeString != NULL );

        Strings[0] = ErrorCodeString;

        DhcpReportEventW(
            DHCP_EVENT_CLIENT,
            EVENT_DHCP_SHUTDOWN,
            EVENTLOG_WARNING_TYPE,
            1,
            sizeof(ErrorCode),
            Strings,
            &ErrorCode );

        break;

    case EVENT_IPAUTOCONFIGURATION_SUCCEEDED :

        Strings[0] = HWAddressBuffer;
        Strings[1] = IPAddressBuffer;

        DhcpReportEventW(
            DHCP_EVENT_CLIENT,
            EVENT_IPAUTOCONFIGURATION_SUCCEEDED,
            EVENTLOG_WARNING_TYPE,
            2,
            sizeof(ErrorCode),
            Strings,
            &ErrorCode
        );
        break;

    case EVENT_COULD_NOT_INITIALISE_INTERFACE :

        DhcpAssert( NULL != ErrorCodeString);
        Strings[0] = ErrorCodeString;
        DhcpReportEventW(
            DHCP_EVENT_CLIENT,
            EVENT_COULD_NOT_INITIALISE_INTERFACE,
            EVENTLOG_ERROR_TYPE,
            1,
            sizeof(ErrorCode),
            Strings,
            &ErrorCode
        );

        break;

    case EVENT_NET_ERROR:
        DhcpAssert( NULL != ErrorCodeString);
        Strings[0] = ErrorCodeString;
        DhcpReportEventW(
            DHCP_EVENT_CLIENT,
            EVENT_NET_ERROR,
            EVENTLOG_WARNING_TYPE,
            1,
            sizeof(ErrorCode),
            Strings,
            &ErrorCode
        );
        break;

    default:

        DhcpPrint(( DEBUG_MISC, "Unknown event." ));
        break;
   }

Cleanup:

    if( HWAddressBuffer != NULL ) {
        DhcpFreeMemory( HWAddressBuffer );
    }

    if( IPAddressBuffer != NULL ) {
        DhcpFreeMemory( IPAddressBuffer );
    }

    if( IPAddressBuffer2 != NULL ) {
        DhcpFreeMemory( IPAddressBuffer2 );
    }

}

#if DBG

VOID
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length;
    static BeginningOfLine = TRUE;
    LPSTR Text;

    //
    // If we aren't debugging this functionality, just return.
    //

    if ( DebugFlag != 0 && (DhcpGlobalDebugFlag & DebugFlag) == 0 ) {
        return;
    }

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    // EnterCriticalSection( &DhcpGlobalDebugFileCritSect );

    length = 0;

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        length += (ULONG) sprintf( &OutputBuffer[length], "[Dhcp] " );

        //
        // Put the timestamp at the begining of the line.
        //
        IF_DEBUG( TIMESTAMP ) {
            SYSTEMTIME SystemTime;
            GetLocalTime( &SystemTime );
            length += (ULONG) sprintf( &OutputBuffer[length],
                                  "%02u/%02u %02u:%02u:%02u ",
                                  SystemTime.wMonth,
                                  SystemTime.wDay,
                                  SystemTime.wHour,
                                  SystemTime.wMinute,
                                  SystemTime.wSecond );
        }

        //
        // Indicate the type of message on the line
        //
        switch (DebugFlag) {
        case DEBUG_ERRORS:
            Text = "ERRR";
            break;

        case DEBUG_PROTOCOL:
            Text = "PROT";
            break;

        case DEBUG_LEASE:
            Text = "LEAS";
            break;

        case DEBUG_PROTOCOL_DUMP:
            Text = "DUMP";
            break;

        case DEBUG_MISC:
            Text = "MISC";
            break;

        default:
            Text = "DHCP";
            break;
        }

        if ( Text != NULL ) {
            length += (ULONG) sprintf( &OutputBuffer[length], "[%s] ", Text );
        }
    }

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);

    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    BeginningOfLine = (length > 0 && OutputBuffer[length-1] == '\n' );

    va_end(arglist);

    DhcpAssert(length <= MAX_PRINTF_LEN);


    //
    // Output to the debug terminal,
    //

    if (NULL == DhcpGlobalDebugFile) {
        (void) DbgPrint( (PCH) OutputBuffer);
    } else {

        //
        // Note: other process can still write to the log file. This should be OK since
        // only the Dhcp client service is supposed to write to the log file.
        //
        EnterCriticalSection( &DhcpGlobalDebugFileCritSect );
        SetFilePointer(DhcpGlobalDebugFile, 0, NULL, FILE_END);
        WriteFile(DhcpGlobalDebugFile, OutputBuffer, length, &length, NULL);
        LeaveCriticalSection( &DhcpGlobalDebugFileCritSect );
    }

    // LeaveCriticalSection( &DhcpGlobalDebugFileCritSect );

}

#endif // DBG


PDHCP_CONTEXT
FindDhcpContextOnNicList(
    IN LPCWSTR AdapterName, OPTIONAL
    IN DWORD InterfaceContext
    )
/*++

Routine Description:

    This function finds the DHCP_CONTEXT for the specified
    adapter name on the Nic list.

    This function must be called with LOCK_RENEW_LIST().

Arguments:

    AdapterName - name of the adapter.
    HardwareAddress - The hardware address to look for.

Return Value:

    A pointer to the desired DHCP work context.
    NULL - If the specified work context block cannot be found.

--*/
{
    PLIST_ENTRY listEntry;
    PDHCP_CONTEXT dhcpContext;
    PLOCAL_CONTEXT_INFO LocalInfo;

    listEntry = DhcpGlobalNICList.Flink;
    while ( listEntry != &DhcpGlobalNICList ) {
        dhcpContext = CONTAINING_RECORD( listEntry, DHCP_CONTEXT, NicListEntry );

        LocalInfo = dhcpContext->LocalInformation;
        if ( AdapterName ) {
            if( _wcsicmp( LocalInfo->AdapterName, AdapterName ) == 0 ) {
                return( dhcpContext );
            }

        } else {
            if( LocalInfo->IpInterfaceContext == InterfaceContext ) {
                return( dhcpContext );
            }
        }

        listEntry = listEntry->Flink;
    }

    return( NULL );
}

//
// End of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\client\nt\tdhcpcapi.c ===
//================================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: Tests the dhcp api as exported in dhcpsdk.h
//================================================================================
#include "precomp.h"
#include <dhcpcsdk.h>
#include <wchar.h>

HANDLE      tGlobalHandle = INVALID_HANDLE_VALUE;

#define     fatal(str, err) do{  printf("%s: %ld (0x%lx)\n", (#str), (err), (err)); exit(1); }while(0)
#define     error(str, err) do{ printf("%s: %ld (0x%lx)\n", (#str), (err), (err)); }while(0)

ULONG
MakeDword(
    IN      LPWSTR                 Arg
)
{
    LPWSTR                         ArgEnd;
    ULONG                          Ret;

    Ret = wcstoul(Arg, &ArgEnd, 0);
    if( *ArgEnd ) {
        printf("[%ws] is not a valid number, assumed 0 instead\n", Arg);
        return 0;
    }

    return Ret;
}

LPWSTR
MakeLpwstr(
    IN      LPWSTR                 Arg
)
{
    if( 0 == _wcsicmp(Arg, L"NULL") ) {
        return NULL;
    }

    return Arg;
}

VOID
MakeHexBytes(
    IN OUT  LPBYTE                *HexBytes,
    IN OUT  DWORD                 *nHexBytes,
    IN OUT  LPWSTR                 HexStr
)
{
    CHAR                           Low, High;
    LPBYTE                         HexByteString;

    if( wcslen(HexStr) % 2 ) {
        fatal(MakeHexBytes expects a even number of hex bytes!!!, ERROR_INVALID_DATA);
    }

    *nHexBytes = 0;
    *HexBytes = HexByteString = (LPBYTE)HexStr;

    while(*HexStr) {
        Low = (CHAR)*HexStr++;
        High = (CHAR)*HexStr++;

        if( Low >= '0' && Low <= '9' ) Low -= '0';
        else if( Low >= 'A' && Low <= 'F' ) Low = Low - 'A' + 10;
        else if( Low >= 'a' && Low <= 'f' ) Low = Low - 'a' + 10;
        else fatal(MakeHexBytes expects number in range 0 to 9 and A to F only, 0);

        if( High >= '0' && High <= '9' ) High -= '0';
        else if( High >= 'A' && Low <= 'F' ) High = High - 'A' + 10;
        else if( High >= 'a' && Low <= 'f' ) High = High - 'a' + 10;
        else fatal(MakeHexBytes expects number in range 0 to 9 and A to F only, 0);

        *HexByteString ++ = (BYTE)((Low<<4)|High);
        (*nHexBytes) ++;
    }
    if( 0 == *nHexBytes ) *HexBytes = NULL;
}

VOID
MakeParams(
    IN OUT  PDHCPCAPI_PARAMS_ARRAY Params,
    IN      LPWSTR                 Str
)
{
    ULONG                          i, Count, Mod;
    LPWSTR                         Start, First, Second,Third;

    if( L'\0' == *Str ) {
        Params->nParams = 0;
        Params->Params = NULL;
        return ;
    }

    Count = 1; Mod = 0;
    Start = Str;
    while(*Str) {
        if(L',' == *Str) {
            Mod ++;
            if( Mod == 3 ) {
                Mod = 0;
                Count ++;
            }
            *Str = L'\0';
        }
        Str ++;
    }

    if( 2 != Mod ) {
        printf("Invalid DHCPCAPI_PARAMS_ARRAY data! Ignored\n");
        Params->nParams = 0;
        Params->Params = NULL;
        return ;
    }

    Params->nParams = Count;
    Params->Params = LocalAlloc(LMEM_FIXED, sizeof(DHCPCAPI_PARAMS)*Count);
    if( NULL == Params->Params ) {
        fatal(MakeParams-not enough memory, ERROR_NOT_ENOUGH_MEMORY);
    }

    Str = Start;
    for( i = 0; i < Count ; i ++ ) {
        First = Str;
        Second = wcslen(Str)+Str+1; Str = Second;
        Third = wcslen(Str)+Str+1; Str = Third + wcslen(Third) + 1;

        Params->Params[i].Flags = MakeDword(First);
        if( 'v' == *Second || 'V' == *Second ) {
            Params->Params[i].IsVendor = TRUE;
            Second ++;
        } else {
            Params->Params[i].IsVendor = FALSE;
        }
        Params->Params[i].OptionId = MakeDword(Second);
        MakeHexBytes(&Params->Params[i].Data, &Params->Params[i].nBytesData, Third);
    }
}

VOID
UnMakeParams(
    IN      PDHCPCAPI_PARAMS_ARRAY Params
)
{
    if( NULL != Params->Params ) {
        LocalFree(Params->Params);
    }
}

VOID
PrintHex(
    IN      ULONG                  Count,
    IN      LPBYTE                 Data
)
{
    BYTE                           cData;

    while(Count --) {
        cData = *Data++;
        if( (cData>>4) < 10 ) printf("%c", '0' + (cData>>4));
        else printf("%c", 'A' + (cData>>4) - 10 );
        if( (cData& 0xF) < 10 ) printf("%c", '0' + (cData&0xF));
        else printf("%c", 'A' + (cData&0xF) - 10 );
    }
}

VOID
PrintParams(
    IN      PDHCPCAPI_PARAMS_ARRAY Params
)
{
    ULONG                          Count;
    printf("\t{%ld,", Params->nParams);
    if( Params->nParams ) {
        printf("{");
        for( Count = 0; Count < Params->nParams ; Count ++ ) {
            printf("[0x%lx,%ld,", Params->Params[Count].Flags, Params->Params[Count].OptionId);
            PrintHex(Params->Params[Count].nBytesData, Params->Params[Count].Data);
            printf("] ");
        }
        printf("}");
    }
    printf("}\n");
}

ULONG
TestRequestParams(
    IN      LPWSTR                *Args,
    IN      ULONG                  nArgs
)
{
    DWORD                          Error;
    DWORD                          Flags;
    LPVOID                         Reserved;
    LPWSTR                         AdapterName, AppName;
    LPDHCPCAPI_CLASSID             ClassId;
    DHCPCAPI_PARAMS_ARRAY          SendParams;
    DHCPCAPI_PARAMS_ARRAY          RecdParams;
    BYTE                           Buffer[5000];
    DWORD                          Size;

    if( 8 != nArgs ) {
        printf("Usage: DhcpRequestParams Flags Reserved AdapterName ClassId SendParams RecdParams Size lpAppName\n");
        return ERROR_INVALID_PARAMETER;
    }

    Flags = MakeDword(Args[0]);
    Reserved = ULongToPtr(MakeDword(Args[1]));
    AdapterName = MakeLpwstr(Args[2]);
    ClassId = ULongToPtr(MakeDword(Args[3]));
    MakeParams(&SendParams, Args[4]);
    MakeParams(&RecdParams, Args[5]);
    Size = MakeDword(Args[6]);
    AppName = MakeLpwstr(Args[7]);

    printf("DhcpRequestParams(\n\t0x%lx,\n\t0x%p,\n\t%ws,\n\t0x%p,\n",
           Flags, Reserved, AdapterName, ClassId
    );
    PrintParams(&SendParams);
    PrintParams(&RecdParams);
    printf("\t0x%p,\n\t[Size = %ld],\n\t%ws\n\t);\n", (Size?Buffer:0), Size, AppName);

    Error = DhcpRequestParams(
        Flags,
        Reserved,
        AdapterName,
        ClassId,
        SendParams,
        RecdParams,
        Size?Buffer:0,
        &Size,
        AppName
    );

    printf("DhcpRequestParams: %ld (0x%lx) [Size = %ld]\n", Error, Error, Size);

    printf("Send, Recd Params are:\n");
    PrintParams(&SendParams);
    PrintParams(&RecdParams);
    UnMakeParams(&SendParams);
    UnMakeParams(&RecdParams);

    return 0;
}

ULONG
TestUndoRequestParams(
    IN      LPWSTR                *Args,
    IN      ULONG                  nArgs
)
{
    ULONG                          Flags;
    LPVOID                         Reserved;
    LPWSTR                         AdapterName, AppName;
    ULONG                          Error;

    if( nArgs != 4 ) {
        printf("usage: DhcpUndoRequestParams dwFlags dwReserved lpwAdapterName lpwAppName\n");
        return 0;
    }

    Flags = MakeDword(Args[0]);
    Reserved = ULongToPtr(MakeDword(Args[1]));
    AdapterName = MakeLpwstr(Args[2]);
    AppName = MakeLpwstr(Args[3]);

    printf("DhcpUndoRequestParams(\n\t0x%lx,\n\t%p,\n\t%ws,\n\t%ws\n\t);\n", Flags, Reserved, AdapterName, AppName);
    Error = DhcpUndoRequestParams(
        Flags,
        Reserved,
        AdapterName,
        AppName
    );

    printf("DhcpUndoRequestParams: %ld (0x%lx)\n", Error, Error);
    return 0;
}

ULONG
TestRegisterParamChange(
    IN      LPWSTR                *Args,
    IN      ULONG                  nArgs
)
{
    DWORD                          Error;
    DWORD                          Flags;
    LPVOID                         Reserved;
    LPWSTR                         AdapterName;
    LPDHCPCAPI_CLASSID             ClassId;
    DHCPCAPI_PARAMS_ARRAY          Params;
    HANDLE                         Handle;

    if( nArgs != 6 ) {
        printf("usage: DhcpRegisterParamChange dwFlags dwReserved lpwAdapterName dwClassId Params Handle\n");
        return 0;
    }
    printf("Handle of 0 causes NULL to be used, any other Handle will use default ptr\n");

    Flags = MakeDword(Args[0]);
    Reserved = ULongToPtr(MakeDword(Args[1]));
    AdapterName = MakeLpwstr(Args[2]);
    ClassId = ULongToPtr(MakeDword(Args[3]));
    MakeParams(&Params, Args[4]);
    Handle = ULongToPtr(MakeDword(Args[5]));

    printf("DhcpRegisterParamChange(\n\t0x%lx,\n\t%p,\n\t%ws,\n\t0x%p,\n", Flags, Reserved, AdapterName, ClassId);
    PrintParams(&Params);
    printf("0x%px\n\t);", Handle?&Handle: NULL);

    Error = DhcpRegisterParamChange(
        Flags,
        Reserved,
        AdapterName,
        ClassId,
        Params,
        (LPVOID)(Handle?&Handle:NULL)
    );

    printf("DhcpRegisterParamChange: %ld (0x%lx)\n", Error, Error);
    if( ERROR_SUCCESS == Error ) {
        tGlobalHandle = Handle;
    }

    printf("Handle: 0x%p\n", Handle);
    UnMakeParams(&Params);
    return 0;
}

ULONG
TestDeRegisterParamChange(
    IN      LPWSTR                *Args,
    IN      ULONG                  nArgs
)
{
    DWORD                          Error;
    DWORD                          Flags;
    LPVOID                         Reserved;
    HANDLE                         Handle;

    if( nArgs != 3 ) {
        printf("usage: DhcpRegisterParamChange dwFlags dwReserved Handle\n");
        return 0;
    }

    Flags = MakeDword(Args[0]);
    Reserved = ULongToPtr(MakeDword(Args[1]));
    Handle = ULongToPtr(MakeDword(Args[2]));

    printf("DhcpRegisterParamChange(\n\t0x%lx,\n\t%p,\n\t0x%p,\n\t);", Flags, Reserved, Handle);

    Error = DhcpDeRegisterParamChange(
        Flags,
        Reserved,
        Handle
    );
    printf("DhcpDeRegisterParamChange: %ld (0x%lx)\n", Error, Error);
    return 0;
}

ULONG
TestStaticRefreshParams(
    IN      LPWSTR                *Args,
    IN      ULONG                  nArgs
)
{
    DWORD                          Error;
    ULONG                          DhcpStaticRefreshParams( LPWSTR AdapterName );

    if( nArgs != 1 ) {
        printf("usage: DhcpStaticRefresh lpwAdapterName\n");
        return 0;
    }

    Error = DhcpStaticRefreshParams( MakeLpwstr(*Args) );
    printf("DhcpStaticRefreshParams( %ws ) : %ld\n", *Args, Error );

    return Error;
}

ULONG
DhcpApiTestLine(
    IN      LPWSTR                 Buf
)
{
    ULONG                          Error;
    LPWSTR                         Words[100];
    ULONG                          nWords;
    BOOL                           LastCharWasSpace = TRUE;

    nWords = 0;
    while( *Buf ) {                               // process each character till end
        if( *Buf == L'\t' || *Buf == L' ' || *Buf == L'\n' ) {
            if( FALSE == LastCharWasSpace ) {     // this char is space but last wasnt
                *Buf = L'\0' ;                    // terminate the run
                LastCharWasSpace = TRUE;          // change state
            }
        } else if( TRUE == LastCharWasSpace ) {   // this char is not space but last was
            Words[nWords++] = Buf;                // mark this as beginning of new string
            LastCharWasSpace = FALSE;             // change state
        }

        Buf ++;                                   // next character
    }

    if( 0 == nWords ) {
        error(Incorrect command. Please type help, 0);
        return 0;
    }

    if( 0 == _wcsicmp(Words[0], L"DhcpRequestParams") ) {
        return TestRequestParams(&Words[1], nWords-1);
    }
    if( 0 == _wcsicmp(Words[0], L"DhcpUndoRequestParams") ) {
        return TestUndoRequestParams(&Words[1], nWords-1);
    }
    if( 0 == _wcsicmp(Words[0], L"DhcpRegisterParamChange") ) {
        return TestRegisterParamChange(&Words[1], nWords-1);
    }
    if( 0 == _wcsicmp(Words[0], L"DhcpDeRegisterParamChange") ) {
        return TestDeRegisterParamChange(&Words[1], nWords-1);
    }
    if( 0 == _wcsicmp(Words[0], L"DhcpStaticRefresh") ) {
        return TestStaticRefreshParams(&Words[1], nWords-1);
    }

    printf("Unknown command!");
    while(nWords--) {
        printf("First word: %ws\n", Words[0]);
    }
    return 0;
}

ULONG
DhcpApiTestLoop(
    VOID
)
{
    ULONG                          Error;
    WCHAR                          Buffer[1000];
    int                             len = 0;

    printf("Usage:\n");
    printf(" For AdapterName use NULL to indicate NULL adaptername.\n");
    printf(" For Params, use a dash (-) to indcate no params.\n");
    printf(" For Params, syntax: flags,optid,[sequence of hex bytes or empty] {,flags,optid,[sequence of hex bytes]}*\n");
    printf(" For Params, prepend OptId with the character 'v' to make it vendor option.\n");
    printf(" Flags values -- DHCPCAPI_REQUEST_PERSISTENT - %ld\n", DHCPCAPI_REQUEST_PERSISTENT);
    printf(" Flags values -- DHCPCAPI_REQUEST_SYNCHRONOUS - %ld\n", DHCPCAPI_REQUEST_SYNCHRONOUS);
    printf(" Flags values -- DHCPCAPI_REGISTER_HANDLE_EVENT - %ld\n", DHCPCAPI_REGISTER_HANDLE_EVENT);
    printf("\n\n");
    printf("1)  DhcpRequestParams dwFlags dwReserved lpwAdapterName dwClassId SendParams RecdParams dwSize lpwAppName\n");
    printf("2)  DhcpUndoRequestParams dwFlags dwReserved lpwAdapterName lpwAppName\n");
    printf("3)  DhcpRegisterParamChange dwFlags dwReserved lpwAdapterName pClassId Params pHandle\n");
    printf("4)  DhcpDeRegisterParamChange dwFlags dwReserved dwEvent\n");
    printf("5)  DhcpStaticRefresh lpwAdapterName\n");

    do {
        printf("DHCP> ");
        if( NULL ==  fgetws(Buffer, 1000, stdin) ) break;

        len = wcslen(Buffer);
        if (Buffer[len] == '\n') {
            Buffer[len] = 0;
        }

        Error = DhcpApiTestLine(Buffer);
        if( ERROR_SUCCESS != Error ) {
            error(DhcpApiTestLine, Error);
        }
    } while(1);

    return 0;
}

void _cdecl main(void) {
    DWORD                          Error;

    Error = DhcpCApiInitialize(NULL);
    if( ERROR_SUCCESS != Error ) {
        fatal(DhcpApiInitialize, Error);
    }

    Error = DhcpApiTestLoop();
    if( ERROR_SUCCESS != Error ) {
        error(DhcpApiTestLoop, Error);
    }

    DhcpCApiCleanup();
    exit(0);
}

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\client\nt\rastest.c ===
//==================================================================
//  Copyright (C) Microsoft 1998.  
//  Author: RameshV
//  Desription: test program to test the lease APIs for RAS.
//===================================================================

#include "precomp.h"
#include <dhcploc.h>
#include <dhcppro.h>

DHCP_OPTION_LIST DhcpOptList;
DWORD  AdapterAddress;
DWORD  Error;
DHCP_CLIENT_UID ClientUID;
LPDHCP_LEASE_INFO LeaseInfo;
DHCP_LEASE_INFO   LeaseInfo2;
LPDHCP_OPTION_INFO OptionInfo;

void
PrintLeaseInfo(
    LPDHCP_LEASE_INFO LeaseInfo
)
{
    DWORD Address, Mask, ServerAddress;

    if( NULL == LeaseInfo ) {
        printf("LeaseInfo = NULL\n");
        return;
    }

    Address = htonl(LeaseInfo->IpAddress);
    Mask = htonl(LeaseInfo->SubnetMask);
    ServerAddress = htonl(LeaseInfo->DhcpServerAddress);

    printf("LeaseInfo: \n");
    printf("\tIpAddress: %s\n", inet_ntoa(*(struct in_addr *)&Address));
    printf("\tSubnetMask: %s\n", inet_ntoa(*(struct in_addr *)&Mask));
    printf("\tDhcpServerAddress: %s\n", inet_ntoa(*(struct in_addr *)&ServerAddress));
    printf("\tLease: 0x%lx\n", LeaseInfo->Lease);
}

void
AcquireX(LPSTR clientid)
{

    ClientUID.ClientUIDLength = strlen(clientid);
    ClientUID.ClientUID = clientid;
    Error = DhcpLeaseIpAddress(
        AdapterAddress,
        &ClientUID,
        0,
        NULL,
        &LeaseInfo,
        &OptionInfo
    );

    if( ERROR_SUCCESS != Error ) {
        printf("DhcpLeaseIpAddress: 0x%lx (%ld)\n", Error, Error);
        return;
    }

    PrintLeaseInfo(LeaseInfo);

}

void
ReleaseOrRenew(BOOL fRelease, DWORD ipaddr, DWORD servaddr, LPSTR clientid)
{

    ClientUID.ClientUIDLength = strlen(clientid);
    ClientUID.ClientUID = clientid;
    
    AcquireX(clientid);

    if( fRelease ) {
        Error = DhcpReleaseIpAddressLease(
            AdapterAddress,
            LeaseInfo
        );
    } else {
        Error = DhcpRenewIpAddressLease(
            AdapterAddress,
            LeaseInfo,
            NULL,
            &OptionInfo
        );
    }

    if( ERROR_SUCCESS != Error ) {
        printf("Error; 0x%lx (%ld)\n", Error, Error);
        return;
    }

    printf("After the renew: \n");
    PrintLeaseInfo(LeaseInfo);

}

void
ReleaseX(DWORD ipaddr, DWORD servaddr, LPSTR clientid)
{
    ReleaseOrRenew(TRUE, ipaddr, servaddr, clientid);
}

void
RenewX(DWORD ipaddr, DWORD servaddr, LPSTR clientid)
{
    ReleaseOrRenew(FALSE, ipaddr, servaddr, clientid);
}

void
Release(
    int  argc,
    char *argv[]
)
{
    if( argc != 3 ) {
        printf("usage: Release ip-address server-address client-id-string\n");
        return;
    }
    ReleaseX(inet_addr(argv[0]), inet_addr(argv[1]), argv[2]);
}

void
Renew(
    int argc,
    char *argv[]
)
{
    if( argc != 3 ) {
        printf("usage: Renew ip-address server-address client-id-string\n");
        return;
    }
    RenewX(inet_addr(argv[0]), inet_addr(argv[1]), argv[2]);
}

void
Acquire(
    int  argc,
    char * argv[]
)
{
    if( argc != 1 ) {
        printf("usage: acquire client-id-string\n");
        return;
    }
    AcquireX(argv[0]);
}


void _cdecl main(int argc, char *argv[]) {
    WSADATA WsaData;
    
    WSAStartup( 0x0101, &WsaData );

    if( argc < 3 ) {
        printf("Usage: %s [adapter-address] cmd <options>"
               "\n\t where cmd is one of Release,Acquire,Renew\n", argv[0]);
        return;
    }  

    AdapterAddress = htonl(inet_addr(argv[1]));
    argv ++; argc --;

    if( 0 == _stricmp(argv[1], "Release") ) {
        Release(argc-2, &argv[2]);
    } else if( 0 == _stricmp(argv[1], "Renew") ) {
        Renew(argc-2, &argv[2]);
    } else if( 0 == _stricmp(argv[1], "Acquire") ) {
        Acquire(argc-2, &argv[2]);
    } else {
        printf("Usage: %s cmd <options>"
                "\n\t where cmd is one of Release,Acquire,Renew\n", argv[0]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\dhcpmib\dhcpmib.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dhcpmib.h

Abstract:

    Sample SNMP Extension Agent for Windows NT.

    These files (dhcpmibm.c, dhcpmib.c, and dhcpmib.h) provide an example of 
    how to structure an Extension Agent DLL which works in conjunction with 
    the SNMP Extendible Agent for Windows NT.

    Extensive comments have been included to describe its structure and
    operation.  See also "Microsoft Windows/NT SNMP Programmer's Reference".

Created:

    12-jan-1994

Revision History:

--*/

#ifndef dhcpmib_h
#define dhcpmib_h

// Necessary includes.

#include <snmp.h>


// MIB Specifics.

#define MIB_PREFIX_LEN            MIB_OidPrefix.idLength
#define MAX_STRING_LEN            255


// Ranges and limits for specific MIB variables.





#define NON_ASN_USED_RANGE_START	0xe0	//high 3 bits not used by
						//ASN
//
// MIB function actions.
//

#define MIB_GET         ASN_RFC1157_GETREQUEST
#define MIB_SET         ASN_RFC1157_SETREQUEST
#define MIB_GETNEXT     ASN_RFC1157_GETNEXTREQUEST
#define MIB_GETFIRST	(ASN_PRIVATE | ASN_CONSTRUCTOR | 0x0)


// MIB Variable access privileges.

#define MIB_ACCESS_READ        0
#define MIB_ACCESS_WRITE       1
#define MIB_ACCESS_READWRITE   2
#define MIB_NOACCESS  	       3	


// Macro to determine number of sub-oid's in array.

#define OID_SIZEOF( Oid )      ( sizeof Oid / sizeof(UINT) )


// MIB variable ENTRY definition.  This structure defines the format for
// each entry in the MIB.

typedef struct mib_entry
           {
	   AsnObjectIdentifier Oid;
	   void *              Storage;
	   BYTE                Type;
	   UINT                Access;
	   UINT                (*MibFunc)( UINT, struct mib_entry *,
	                                   RFC1157VarBind * );
	   struct mib_entry *  MibNext;
	   } MIB_ENTRY, *PMIB_ENTRY;

typedef struct table_entry
           {
	   UINT                (*MibFunc)( UINT, struct mib_entry *,
	                                   RFC1157VarBind * );
	   struct mib_entry *  Mibptr;
	   } TABLE_ENTRY, *PTABLE_ENTRY;


// Internal MIB structure.

extern UINT      MIB_num_variables;

// Prefix to every variable in the MIB.

extern AsnObjectIdentifier MIB_OidPrefix;
extern BOOL		   fDhcpMibVarsAccessed;

//extern MIB_ENTRY	Mib[];
extern MIB_ENTRY	*pWinsMib;
// Function Prototypes.

extern
UINT ResolveVarBind(
        IN OUT RFC1157VarBind *VarBind, // Variable Binding to resolve
	IN UINT PduAction               // Action specified in PDU
	);

#endif /* dhcpmib_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\dhcpmib\dhcpmib.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dhcpmib.c

Abstract:

    DHCP SNMP Extension Agent for Windows NT.

    These files (dhcpmibm.c, dhcpmib.c, and dhcpmib.h) provide an example of 
    how to structure an Extension Agent DLL which works in conjunction with 
    the SNMP Extendible Agent for Windows NT.

    Extensive comments have been included to describe its structure and
    operation.  See also "Microsoft Windows/NT SNMP Programmer's Reference".

Created:

   15-Jan-1994 

Revision History:

        Pradeep Bahl                        1/11/94
--*/



// This Extension Agent implements the DHCP MIB.  It's  
// definition follows here:
//
//

// Necessary includes.

#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbase.h>                         //for SYSTEMTIME def
#include <rpc.h>

#include "dhcpapi.h"

#include <string.h>
#include <time.h>
#include <search.h>


// Contains definitions for the table structure describing the MIB.  This
// is used in conjunction with winsmib.c where the MIB requests are resolved.

#include "dhcpmib.h"


// If an addition or deletion to the MIB is necessary, there are several
// places in the code that must be checked and possibly changed.
//
// The last field in each MIB entry is used to point to the NEXT
// leaf variable.  If an addition or deletetion is made, these pointers
// may need to be updated to reflect the modification.



#define LOCAL_ADD        L"127.0.0.1"


//
// Used by MIBStat
//
#define TMST(x)        x.wHour,\
                x.wMinute,\
                x.wSecond,\
                x.wMonth,\
                x.wDay,\
                x.wYear

#define PRINTTIME(Var, x)      sprintf(Var, "%02u:%02u:%02u on %02u:%02u:%04u.\n", TMST(x))

//
// All MIB variables in the common group have 1 as their first id
//
#define COMMON_VAL_M(pMib)         ((pMib)->Oid.ids[0] == 1) 

//
// All MIB variables in the scope group have 2 as their first id
//
#define SCOPE_VAL_M(pMib)         ((pMib)->Oid.ids[0] == 2) 

static LPDHCP_MIB_INFO        spMibInfo = NULL;

//
// The prefix to all of the DHCP MIB variables is 1.3.6.1.4.1.311.1.3
//
// The last digit -- 3 is for the DHCP MIB
//

UINT OID_Prefix[] = { 1, 3, 6, 1, 4, 1, 311, 1, 3 };
AsnObjectIdentifier MIB_OidPrefix = { OID_SIZEOF(OID_Prefix), OID_Prefix };
BOOL        fDhcpMibVarsAccessed = FALSE;
        



//
// Definition of the Dhcp MIB  (not used)
//

//UINT MIB_Dhcp[]  = { 3 };

//                        
// OID definitions for MIB
//                        

//
// Definition of group and leaf variables under the wins group
// All leaf variables have a zero appended to their OID to indicate
// that it is the only instance of this variable and it exists.
//

UINT MIB_Parameters[]                        = { 1 }; 
UINT MIB_DhcpStartTime[]                     = { 1, 1, 0 };
UINT MIB_NoOfDiscovers[]                = { 1, 2, 0 };
UINT MIB_NoOfRequests[]                        = { 1, 3, 0 };
UINT MIB_NoOfReleases[]                        = { 1, 4, 0 };
UINT MIB_NoOfOffers[]                        = { 1, 5, 0 };
UINT MIB_NoOfAcks[]                        = { 1, 6, 0 };
UINT MIB_NoOfNacks[]                        = { 1, 7, 0 };
UINT MIB_NoOfDeclines[]                        = { 1, 8, 0 };

//
// Scope table
//
UINT MIB_Scope[]                        = { 2 }; 
UINT MIB_ScopeTable[]                        = { 2, 1};
UINT MIB_ScopeTableEntry[]                = { 2, 1, 1};

//
//                             //
// Storage definitions for MIB //
//                             //
char            MIB_DhcpStartTimeStore[80];
AsnCounter MIB_NoOfDiscoversStore;
AsnCounter MIB_NoOfRequestsStore;
AsnCounter MIB_NoOfReleasesStore;
AsnCounter MIB_NoOfOffersStore;
AsnCounter MIB_NoOfAcksStore;
AsnCounter MIB_NoOfNacksStore;
AsnCounter MIB_NoOfDeclinesStore;





static
UINT 
MIB_Table(
        IN DWORD           Index, 
        IN UINT            Action,
        IN PMIB_ENTRY           pMibPtr,
        IN RFC1157VarBind *VarBind
        );

static
UINT 
ScopeTable(
        IN UINT           Action,
        IN PMIB_ENTRY           pMibPtr,
        IN RFC1157VarBind *VarBind
                );

static
UINT 
MIB_leaf_func(
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
        );


static
UINT 
MIB_Stat(
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
        );
static
DWORD 
GetMibInfo (
        LPWSTR                        DhcpAdd,
        LPDHCP_MIB_INFO                *ppMibInfo
        );
//
// MIB definiton
//

MIB_ENTRY Mib[] = {
//parameters
      { { OID_SIZEOF(MIB_Parameters), MIB_Parameters },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_NOACCESS, NULL, &Mib[1] },

      { { OID_SIZEOF(MIB_DhcpStartTime), MIB_DhcpStartTime },
        &MIB_DhcpStartTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[2] },

      { { OID_SIZEOF(MIB_NoOfDiscovers), MIB_NoOfDiscovers },
        &MIB_NoOfDiscoversStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[3] },

      { { OID_SIZEOF(MIB_NoOfRequests), MIB_NoOfRequests },
        &MIB_NoOfRequestsStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[4] },

      { { OID_SIZEOF(MIB_NoOfReleases), MIB_NoOfReleases },
        &MIB_NoOfReleasesStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[5] },

      { { OID_SIZEOF(MIB_NoOfOffers), MIB_NoOfOffers },
        &MIB_NoOfOffersStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[6] },

      { { OID_SIZEOF(MIB_NoOfAcks), MIB_NoOfAcks },
        &MIB_NoOfAcksStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[7] },

      { { OID_SIZEOF(MIB_NoOfNacks), MIB_NoOfNacks },
        &MIB_NoOfNacksStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[8] },

      { { OID_SIZEOF(MIB_NoOfDeclines), MIB_NoOfDeclines },
        &MIB_NoOfDeclinesStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[9] },

//
// Scope
//
      { { OID_SIZEOF(MIB_Scope), MIB_Scope },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_NOACCESS, NULL, &Mib[10] },


      { { OID_SIZEOF(MIB_ScopeTable), MIB_ScopeTable },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_ACCESS_READ, NULL, &Mib[11] },

      { { OID_SIZEOF(MIB_ScopeTableEntry), MIB_ScopeTableEntry },
        NULL, ASN_SEQUENCE,
        MIB_ACCESS_READ, ScopeTable, NULL }
      };



//
//  defines pertaining to tables
//
#define SCOPE_OIDLEN                 (MIB_PREFIX_LEN + OID_SIZEOF(MIB_ScopeTableEntry))        

#define NO_FLDS_IN_SCOPE_ROW        4
#define SCOPE_TABLE_INDEX        0

#define NUM_TABLES                sizeof(Tables)/sizeof(TAB_INFO_T)

UINT MIB_num_variables = sizeof Mib / sizeof( MIB_ENTRY );

//
// table structure containing the functions to invoke for different actions
// on the table
//
typedef struct _TAB_INFO_T {
        UINT (*ti_get)(
                RFC1157VarBind *VarBind
                     );
        UINT (*ti_getf)(
                RFC1157VarBind *VarBind,
                PMIB_ENTRY        pMibEntry
                     );
        UINT (*ti_getn)(
                RFC1157VarBind *VarBind,
                PMIB_ENTRY        pMibEntry
                    );
        UINT (*ti_set)(
                RFC1157VarBind *VarBind
                    );

        PMIB_ENTRY pMibPtr;
        } TAB_INFO_T, *PTAB_INFO_T;




static
UINT
ScopeGetNext(
       IN RFC1157VarBind *VarBind,
       IN PMIB_ENTRY          pMibPtr
        );


static
UINT
ScopeGet(
       IN RFC1157VarBind *VarBind
);


static
UINT
ScopeGetFirst(
       IN RFC1157VarBind *VarBind,
       IN PMIB_ENTRY          pMibPtr
        );


static
UINT
ScopeMatch(
       IN RFC1157VarBind          *VarBind,
       IN LPDWORD                  pIndex,
       IN LPDWORD                 pField,
       IN UINT                          PduAction,
       IN LPBOOL                 pfFirst
        );

extern
UINT
ScopeFindNext(
        INT                   SubnetIndex        
        );



static
int 
__cdecl
CompareScopes(
        const VOID *pKey1,
        const VOID *pKey2
        );
static
UINT
GetNextVar(
        IN RFC1157VarBind *pVarBind,
        IN PMIB_ENTRY          pMibPtr
);

TAB_INFO_T Tables[] = {
                        ScopeGet, 
                        ScopeGetFirst, 
                        ScopeGetNext, 
                        NULL,
                        &Mib[11]
        };






UINT 
ResolveVarBind(
        IN OUT RFC1157VarBind *VarBind, // Variable Binding to resolve
        IN UINT PduAction               // Action specified in PDU
        )
//
// ResolveVarBind
//    Resolves a single variable binding.  Modifies the variable on a GET
//    or a GET-NEXT.
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
{
   MIB_ENTRY            *MibPtr;
   AsnObjectIdentifier  TempOid;
   int                  CompResult;
   UINT                 I;
   UINT                 nResult;
   DWORD TableIndex;
   BOOL  fTableMatch = FALSE;

   //
   // Check the Tables array
   //
   // See if the prefix of the variable matches the prefix of
   // any of the tables
   //
   for (TableIndex = 0; TableIndex < NUM_TABLES; TableIndex++)
   {
        //
           // Construct OID with complete prefix for comparison purposes
        //
           SnmpUtilOidCpy( &TempOid, &MIB_OidPrefix );
           SnmpUtilOidAppend( &TempOid,  &Tables[TableIndex].pMibPtr->Oid );

        //
        // is there a match with the prefix oid of a table entry
        //
        if (
                SnmpUtilOidNCmp(
                            &VarBind->name, 
                             &TempOid,                
                             MIB_PREFIX_LEN + 
                                Tables[TableIndex].pMibPtr->Oid.idLength
                               )  == 0
           )
        {

                //
                // the prefix string of the var. matched the oid
                // of a table.
                //
                MibPtr = Tables[TableIndex].pMibPtr;
                fTableMatch = TRUE;
                break;
        }

           // Free OID memory before checking with another table entry
           SnmpUtilOidFree( &TempOid );
   }
   //
   // There was an exact match with a table entry's prefix. 
   //
   if ( fTableMatch)
   {
        
        if (
                (SnmpUtilOidCmp(
                        &VarBind->name, 
                        &TempOid
                               ) == 0)
           )
           {
           //
           // The oid specified is a prefix of a table entry. if the operation
           // is not GETNEXT, return NOSUCHNAME
           //
           if (PduAction != MIB_GETNEXT) 
           {
                           SnmpUtilOidFree( &TempOid );
                             nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
                              goto Exit;
           }
           else
           {
                UINT           TableEntryIds[1];
                AsnObjectIdentifier TableEntryOid = { 
                                OID_SIZEOF(TableEntryIds), TableEntryIds };
                //
                // Replace var bind name with new name
                //

                //
                // A sequence item oid always starts with a field no.
                // The first item has a field no of 1. 
                //
                TableEntryIds[0] = 1;
                SnmpUtilOidAppend( &VarBind->name, &TableEntryOid);

                //
                // Get the first entry in the table
                //
                PduAction = MIB_GETFIRST;
           }
        }
           SnmpUtilOidFree( &TempOid );
        //
        //  if there was no exact match with a prefix entry, then we
        //  don't touch the PduAction value specified. 
        //
   }
   else
   {
        
      //
      // There was no match with any table entry.  Let us see if there is
      // a match with a group entry, a table, or a leaf variable
      //

      //
      // Search for var bind name in the MIB
      //
      I      = 0;
      MibPtr = NULL;
      while ( MibPtr == NULL && I < MIB_num_variables )
      {

         //
         // Construct OID with complete prefix for comparison purposes
         //
         SnmpUtilOidCpy( &TempOid, &MIB_OidPrefix );
         SnmpUtilOidAppend( &TempOid, &Mib[I].Oid );

         //
         //Check for OID in MIB - On a GET-NEXT the OID does not have to exactly
         // match a variable in the MIB, it must only fall under the MIB root.
         //
         CompResult = SnmpUtilOidCmp( &VarBind->name, &TempOid );

        //
        // If CompResult is negative, the only valid operation is GET_NEXT
        //
        if (  CompResult  < 0)
        {

                //
                // This could be the oid of a leaf (without a 0)
                // or it could be  an invalid oid (in between two valid oids) 
                // The next oid might be that of a group or a table or table
                // entry.  In that case, we do not change the PduAction
                //
                if (PduAction == MIB_GETNEXT)
                {
                       MibPtr = &Mib[I];
                             SnmpUtilOidFree( &VarBind->name );
                       SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix );
                       SnmpUtilOidAppend( &VarBind->name, &MibPtr->Oid );
                       if (
                                (MibPtr->Type != ASN_RFC1155_OPAQUE)
                                         &&
                                (MibPtr->Type != ASN_SEQUENCE)
                          )
                       {
                                 PduAction = MIB_GET;
                       }
                }
                else
                {
                  nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
                        SnmpUtilOidFree( &TempOid );
                  goto Exit;
                }

                      SnmpUtilOidFree( &TempOid );
                break;
      }
      else
      {
         //
         // An exact match was found ( a group, table, or leaf).
         //
         if ( CompResult == 0)
         {
            MibPtr = &Mib[I];
         }
      }

      //
      // Free OID memory before checking another variable
      //
      SnmpUtilOidFree( &TempOid );
      I++;
    } // while
   } // end of else

   //
   // if there was a match
   //
   if (MibPtr != NULL)
   {
        //
        // the function will be NULL only if the match was with a group
        // or a sequence (table). If the match was with a table entry
        // (entire VarBind string match or partial string match), we
        // function would be a table function
        //
        if (MibPtr->MibFunc == NULL) 
        {
                if(PduAction != MIB_GETNEXT) 
                {
                              nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
                              goto Exit;
                }
                else
                {
                        //
                        // Get the next variable which allows access 
                        //
                         nResult = GetNextVar(VarBind, MibPtr);
                        goto Exit;
                }
        }
   }
   else
   {
              nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
              goto Exit;
   }

   //
   // Call function to process request.  Each MIB entry has a function pointer
   // that knows how to process its MIB variable.
   //
   nResult = (*MibPtr->MibFunc)( PduAction, MibPtr, VarBind );

Exit:
   return nResult;
} // ResolveVarBind
//
// MIB_leaf_func
//    Performs generic actions on LEAF variables in the MIB.
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
UINT MIB_leaf_func(
        IN UINT            Action,
        IN MIB_ENTRY            *MibPtr,
        IN RFC1157VarBind  *VarBind
        )

{
   UINT   ErrStat;

   switch ( Action )
   {
      case MIB_GETNEXT:
         //
         // If there is no GET-NEXT pointer, this is the end of this MIB
         //
         if ( MibPtr->MibNext == NULL )
         {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
         }
         ErrStat = GetNextVar(VarBind, MibPtr);
         if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
         {
                goto Exit;
         }
         break;

      case MIB_GETFIRST: // fall through 
      case MIB_GET:

         // Make sure that this variable's ACCESS is GET'able
         if ( MibPtr->Access != MIB_ACCESS_READ &&
              MibPtr->Access != MIB_ACCESS_READWRITE )
         {
               ErrStat = SNMP_ERRORSTATUS_NOACCESS;
               goto Exit;
         }

         // Setup varbind's return value
         VarBind->value.asnType = MibPtr->Type;
         switch ( VarBind->value.asnType )
         {
            case ASN_RFC1155_COUNTER:
               VarBind->value.asnValue.number = *(AsnCounter *)(MibPtr->Storage);
               break;
            case ASN_RFC1155_GAUGE:
            case ASN_INTEGER:
               VarBind->value.asnValue.number = *(AsnInteger *)(MibPtr->Storage);
               break;

            case ASN_RFC1155_IPADDRESS:
                                //
                                // fall through
                                //
                                
            case ASN_OCTETSTRING: 
               if (VarBind->value.asnType == ASN_RFC1155_IPADDRESS)
               {
                               VarBind->value.asnValue.string.length = 4;
               }
               else
               {
                               VarBind->value.asnValue.string.length =
                                 strlen( (LPSTR)MibPtr->Storage );
               }

               if ( NULL == 
                    (VarBind->value.asnValue.string.stream =
                    SnmpUtilMemAlloc(VarBind->value.asnValue.string.length *
                           sizeof(char))) )
               {
                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                  goto Exit;
               }

               memcpy( VarBind->value.asnValue.string.stream,
                       (LPSTR)MibPtr->Storage,
                       VarBind->value.asnValue.string.length );
               VarBind->value.asnValue.string.dynamic = TRUE;
        
               break;

                

            default:
               ErrStat = SNMP_ERRORSTATUS_GENERR;
               goto Exit;
         }

         break;

      case MIB_SET:

         // Make sure that this variable's ACCESS is SET'able
         if ( MibPtr->Access != MIB_ACCESS_READWRITE &&
              MibPtr->Access != MIB_ACCESS_WRITE )
         {
            ErrStat = SNMP_ERRORSTATUS_NOTWRITABLE;
            goto Exit;
         }

         // Check for proper type before setting
         if ( MibPtr->Type != VarBind->value.asnType )
         {
            ErrStat = SNMP_ERRORSTATUS_WRONGTYPE;
            goto Exit;
         }

         // Save value in MIB
         switch ( VarBind->value.asnType )
         {
            case ASN_RFC1155_COUNTER:
               *(AsnCounter *)(MibPtr->Storage) = VarBind->value.asnValue.number;
               break;
            case ASN_RFC1155_GAUGE:
            case ASN_INTEGER:
               *(AsnInteger *)(MibPtr->Storage) = VarBind->value.asnValue.number;
               break;

            case ASN_RFC1155_IPADDRESS:
                                //
                                // fall through
                                //
            case ASN_OCTETSTRING:
               // The storage must be adequate to contain the new string
               // including a NULL terminator.
               memcpy( (LPSTR)MibPtr->Storage,
                       VarBind->value.asnValue.string.stream,
                       VarBind->value.asnValue.string.length );

               ((LPSTR)MibPtr->Storage)[VarBind->value.asnValue.string.length] =
                                                                          '\0';
               if ( VarBind->value.asnValue.string.dynamic)
               {
                  SnmpUtilMemFree( VarBind->value.asnValue.string.stream);
               }
               break;

            default:
               ErrStat = SNMP_ERRORSTATUS_GENERR;
               goto Exit;
            }

         break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
         goto Exit;
      } // switch

   // Signal no error occurred
   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_leaf_func

//
// MIB_Stat
//    Performs specific actions on the different MIB variable
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
UINT MIB_Stat(
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
        )

{
DWORD                        Status;
UINT                           ErrStat;
SYSTEMTIME                DhcpStartTime;



   switch ( Action )
      {
      case MIB_SET:
                   ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );
                break;
      case MIB_GETNEXT:
                   ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );
                break;
                
      case MIB_GETFIRST:
                //
                // fall through
                //
      case MIB_GET:
        //
        // Call the DhcpStatus function to get the statistics
        //
        Status = GetMibInfo(LOCAL_ADD, &spMibInfo);

        
        if (Status == ERROR_SUCCESS) 
        {
            if (FileTimeToSystemTime( 
                                (FILETIME *)&spMibInfo->ServerStartTime,  
                                &DhcpStartTime
                                   ) == FALSE)
            {
                goto Exit;
            }
           
            if (MibPtr->Storage  == &MIB_DhcpStartTimeStore) 
            {
                PRINTTIME(MIB_DhcpStartTimeStore, DhcpStartTime);
                goto LEAF1;
            }

            if (MibPtr->Storage  == &MIB_NoOfDiscoversStore) 
            {
                MIB_NoOfDiscoversStore =  spMibInfo->Discovers;
                goto LEAF1;
            }
            if (MibPtr->Storage  == &MIB_NoOfRequestsStore) 
            {
                MIB_NoOfRequestsStore =  spMibInfo->Requests;
                goto LEAF1;
            }
            if (MibPtr->Storage  == &MIB_NoOfReleasesStore) 
            {
                MIB_NoOfReleasesStore =  spMibInfo->Releases;
                goto LEAF1;
            }
            if (MibPtr->Storage  == &MIB_NoOfOffersStore) 
            {
                MIB_NoOfOffersStore =  spMibInfo->Offers;
                goto LEAF1;
            }
            if (MibPtr->Storage  == &MIB_NoOfAcksStore) 
            {
                MIB_NoOfAcksStore =  spMibInfo->Acks;
                goto LEAF1;
            }
            if (MibPtr->Storage  == &MIB_NoOfNacksStore) 
            {
                MIB_NoOfNacksStore =  spMibInfo->Naks;
                goto LEAF1;
            }
            if (MibPtr->Storage  == &MIB_NoOfDeclinesStore) 
            {
                MIB_NoOfNacksStore =  spMibInfo->Naks;
                goto LEAF1;
            }
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
         }
         else
         {
           printf("Error from DhcpStatus = (%d)\n", Status);
           ErrStat = (Status == RPC_S_SERVER_UNAVAILABLE) ? 
                        SNMP_ERRORSTATUS_NOSUCHNAME :
                        SNMP_ERRORSTATUS_GENERR;
           goto Exit;
         }        
LEAF1:
         // Call the more generic function to perform the action
         ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );

         break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
         goto Exit;
      } // switch

Exit:
   return ErrStat;
} // MIB_Stat



DWORD GetMibInfo (
        LPWSTR                        DhcpAdd,
        LPDHCP_MIB_INFO                *ppMibInfo
        )
{
        DWORD  Status = ERROR_SUCCESS;
        if (!fDhcpMibVarsAccessed)
        {
           //
           // The Dhcp server does a single node allocation. So we
           // we need to free only spMibInfo.
           //
           if (spMibInfo != NULL)
           {
#if 0
                if (spMibInfo->ScopeInfo != NULL)
                {
                        DhcpRpcFreeMemory(spMibInfo->ScopeInfo);
                        spMibInfo->ScopeInfo = NULL; 
                }
#endif
                DhcpRpcFreeMemory(spMibInfo);
                spMibInfo            = NULL;
           }
           Status = DhcpGetMibInfo(LOCAL_ADD, &spMibInfo);
           if (Status == ERROR_SUCCESS)
           {
                if (spMibInfo->Scopes > 1)
                {
          ASSERT(spMibInfo->ScopeInfo != NULL);
                  qsort(spMibInfo->ScopeInfo,(size_t)spMibInfo->Scopes,
                        sizeof(SCOPE_MIB_INFO),CompareScopes );
                }
                fDhcpMibVarsAccessed = TRUE;
           }
           else
           {
                fDhcpMibVarsAccessed = FALSE;
           }
        }
        return(Status);
}

int 
__cdecl
CompareScopes(
        const VOID *pKey1,
        const VOID *pKey2
        )

{
        const LPSCOPE_MIB_INFO        pScopeKey1 = (LPSCOPE_MIB_INFO)pKey1;
        const LPSCOPE_MIB_INFO        pScopeKey2 = (LPSCOPE_MIB_INFO)pKey2;


        if( pScopeKey1->Subnet < pScopeKey2->Subnet) 
            return -1;
        if (pScopeKey1->Subnet != pScopeKey2->Subnet )
            return 1;
        return 0;
}

UINT
GetNextVar(
        IN RFC1157VarBind *pVarBind,
        IN MIB_ENTRY          *pMibPtr
)
{
       UINT                ErrStat;

       while (pMibPtr != NULL)
       {
         if (pMibPtr->MibNext != NULL)
         {
            //
            // Setup var bind name of NEXT MIB variable
            //
            SnmpUtilOidFree( &pVarBind->name );
            SnmpUtilOidCpy( &pVarBind->name, &MIB_OidPrefix );
            SnmpUtilOidAppend( &pVarBind->name, &pMibPtr->MibNext->Oid );

            //
            // If the func. ptr is  NULL and the type of the mib variable
            // is anything but OPAQUE, call function to process the
            // MIB variable
            //
            if (
                 (pMibPtr->MibNext->MibFunc != NULL) 
                        && 
                 (pMibPtr->MibNext->Type !=  ASN_RFC1155_OPAQUE)
               )
                
            {
                ErrStat = (*pMibPtr->MibNext->MibFunc)( MIB_GETFIRST,
                                                pMibPtr->MibNext, pVarBind );
                if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
                {
                        goto Exit;
                }
                break;
            }
            else
            {
                pMibPtr = pMibPtr->MibNext;        
            }
          }
          else
          {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            break;
          }
         } 

         if (pMibPtr == NULL)
         {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
         }
Exit:
        return(ErrStat);
}

UINT 
ScopeTable(
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
)
{
        DWORD status;

        if (Action == MIB_SET)
        {
                return(SNMP_ERRORSTATUS_READONLY);
        }

        //
        // if the length indicates a 0 or partial key, then only the get next 
        // operation is allowed.  The field and the full key
        // have a length of 5
        //
        if (VarBind->name.idLength <= (SCOPE_OIDLEN + 4))
        {
                if ((Action == MIB_GET) || (Action == MIB_SET))
                {
                        return(SNMP_ERRORSTATUS_NOSUCHNAME);
                }
        }
        status = GetMibInfo(LOCAL_ADD, &spMibInfo);
        if (status != ERROR_SUCCESS)
        {
                if (Action == MIB_GETNEXT)
                {
                        return(GetNextVar(VarBind, MibPtr));
                }
                else
                {
                        return (status == RPC_S_SERVER_UNAVAILABLE) ?
                                    SNMP_ERRORSTATUS_NOSUCHNAME :
                                    SNMP_ERRORSTATUS_GENERR;
                }
        }
        return( MIB_Table(SCOPE_TABLE_INDEX, Action, MibPtr, VarBind) );
}

UINT 
MIB_Table(
        IN DWORD            Index,
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
       )
{
        UINT        ErrStat;
        switch(Action)
        {
                case(MIB_GET):
                        ErrStat = (*Tables[Index].ti_get)(VarBind);
                        break;
                        
                case(MIB_GETFIRST):
                        ErrStat = (*Tables[Index].ti_getf)(VarBind, MibPtr);
                        break;

                case(MIB_GETNEXT):
                        ErrStat = (*Tables[Index].ti_getn)(VarBind, MibPtr);
                        break;
                case(MIB_SET):
                        ErrStat = (*Tables[Index].ti_set)(VarBind);
                        break;
                default:
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                        break;

        }

        return(ErrStat);

}  //MIB_Table



UINT
ScopeGet(
       IN RFC1157VarBind *VarBind
    )
{
        UINT                ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD           Field;
        DWORD                Index;
        LPSCOPE_MIB_INFO pScope = spMibInfo->ScopeInfo;


        ErrStat = ScopeMatch(VarBind, &Index, &Field, MIB_GET, NULL);
             if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
             {
                return(ErrStat);
             }

        switch(Field)
        {
                case 1:                //subnet itself

                        VarBind->value.asnType        = ASN_RFC1155_IPADDRESS;
                               VarBind->value.asnValue.string.length = sizeof(ULONG);
                        
                               if ( NULL == 
                                    (VarBind->value.asnValue.string.stream =
                                    SnmpUtilMemAlloc(VarBind->value.asnValue.string.length
                                   )) )
                          {
                                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                                  goto Exit;
                          }
                        
                        //
                        // SNMP expects the MSB to be in the first byte, MSB-1
                        // to be in the second, ....
                        //
                        VarBind->value.asnValue.string.stream[0] =
                                        (BYTE)((pScope + Index)->Subnet >> 24);
                        VarBind->value.asnValue.string.stream[1] =
                                (BYTE)(((pScope + Index)->Subnet >> 16) & 0xFF);
                        VarBind->value.asnValue.string.stream[2] =
                                (BYTE)(((pScope + Index)->Subnet >> 8) & 0xFF);
                        VarBind->value.asnValue.string.stream[3] =
                                (BYTE)((pScope + Index)->Subnet & 0xFF );
                        VarBind->value.asnValue.address.dynamic = TRUE;
                        break;

                case 2:                // NumAddressesInUse
                        VarBind->value.asnType        = ASN_RFC1155_COUNTER;
                               VarBind->value.asnValue.number = 
                                        (AsnCounter)((pScope + Index)->
                                                        NumAddressesInuse);
                               break;
                case 3:                // NumAddressesFree
                        VarBind->value.asnType        = ASN_RFC1155_COUNTER;
                               VarBind->value.asnValue.number = 
                                        (AsnCounter)((pScope + Index)->
                                                        NumAddressesFree);
                               break;
                case 4:                // NumPendingOffers
                        VarBind->value.asnType        = ASN_RFC1155_COUNTER;
                               VarBind->value.asnValue.number = 
                                        (AsnCounter)((pScope + Index)->
                                                        NumPendingOffers);
                               break;

                default:
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        break;

        }
Exit:
        return(ErrStat); 
} // ScopeGet 

          
UINT
ScopeGetNext(
       IN RFC1157VarBind *VarBind,
       IN MIB_ENTRY          *MibPtr
          )
{
     DWORD          OidIndex;
     INT            Index;
     DWORD         FieldNo;
     UINT         ErrStat = SNMP_ERRORSTATUS_NOERROR;
     BOOL         fFirst;
     LPSCOPE_MIB_INFO pScope = spMibInfo->ScopeInfo;
        

     //
     // Check if the name passed matches any in the table (i.e. table of
     // of ADD_KEY_T structures.  If there is a match, the address
     // of the ip address key and the matching field's no. are returned 
     //
     ErrStat = ScopeMatch(VarBind,  &Index,  &FieldNo,  MIB_GETNEXT, &fFirst); 
     if (        
                (ErrStat != SNMP_ERRORSTATUS_NOERROR)
                        &&
                (ErrStat != SNMP_ERRORSTATUS_NOSUCHNAME)
        )
     {
                return(GetNextVar(VarBind, MibPtr));
     }

     //
     // We were passed an oid that is less than all oids in the table. Set
     // the Index to -1 so that we retrieve the first record in the table
     //
     if (fFirst)
     {
        Index = -1;
     }
     //
     // Since the operation is GETNEXT, get the next IP address (i.e. one
     // that is lexicographically bigger.  If there is none, we must increment
     // the field value and move back to the lexically first item in the table
     // If the new field value is more than the largest supported, we call
     // the MibFunc of the next MIB entry.
     //
     if ((Index = ScopeFindNext(Index)) < 0) 
     {
          
          //
          // if we were trying to retrieve the second or subsequent record
          // we must increment the field number nd get the first record in 
          // the table.  If we were retrieving the first record, then 
          // we should get the next var.
          //
          if (!fFirst)
          {
            Index = ScopeFindNext(-1);
          }
          else
          {
                return(GetNextVar(VarBind, MibPtr));
          }

          //
          // If either there is no entry in the table or if we have
          // exhausted all fields of the entry, call the function
          // of the next mib entry.
          //
          if (
                (++FieldNo > NO_FLDS_IN_SCOPE_ROW) || (Index < 0)
             )
          {                
                return(GetNextVar(VarBind, MibPtr));
          }
     }
                
     if (VarBind->name.idLength <= (SCOPE_OIDLEN + 4))
     {
         UINT TableEntryIds[5];  //field and subnet mask have a length of 5
         AsnObjectIdentifier  TableEntryOid = {OID_SIZEOF(TableEntryIds),
                                             TableEntryIds };
         SnmpUtilOidFree( &VarBind->name);
         SnmpUtilOidCpy(&VarBind->name, &MIB_OidPrefix);
         SnmpUtilOidAppend(&VarBind->name, &MibPtr->Oid);
         TableEntryIds[0] = (UINT)FieldNo;
         OidIndex                  = 1;
         TableEntryIds[OidIndex++] = (UINT)((pScope + Index)->Subnet >> 24);
         TableEntryIds[OidIndex++] = (UINT)((pScope + Index)->Subnet >> 16 & 0xFF);
         TableEntryIds[OidIndex++] = (UINT)((pScope + Index)->Subnet >> 8 & 0xFF);
         TableEntryIds[OidIndex++] = (UINT)((pScope + Index)->Subnet & 0xFF);
         TableEntryOid.idLength    = OidIndex;
         SnmpUtilOidAppend(&VarBind->name, &TableEntryOid);
     }
     else
     {
        //
        // The fixed part of the objid is corect. Update the rest.
        //
        OidIndex = SCOPE_OIDLEN;
        VarBind->name.ids[OidIndex++] = (UINT)FieldNo;
        VarBind->name.ids[OidIndex++] = (UINT)((pScope + Index)->Subnet >> 24);
        VarBind->name.ids[OidIndex++] = (UINT)(((pScope + Index)->Subnet >> 16) & 0xFF);
        VarBind->name.ids[OidIndex++] = (UINT)(((pScope + Index)->Subnet >> 8) & 0xFF);
        VarBind->name.ids[OidIndex++] = (UINT)((pScope + Index)->Subnet & 0xFF);
        VarBind->name.idLength        = OidIndex;
    }

     //
     // Get the value
     //
     ErrStat = ScopeGet(VarBind);

     return(ErrStat);
}

  

UINT
ScopeMatch(
       IN RFC1157VarBind *VarBind,
       IN LPDWORD         pIndex,
       IN LPDWORD         pField,
       IN UINT                  PduAction,
       IN LPBOOL         pfFirst
        )
{
        DWORD                         OidIndex;
        DWORD                         Index;
        DWORD                         ScopeIndex;
        DWORD                          Add = 0;
        UINT                         ErrStat = SNMP_ERRORSTATUS_NOERROR;
        INT                          CmpVal;
        DWORD                         AddLen;
        LPSCOPE_MIB_INFO         pScope = spMibInfo->ScopeInfo;

        ASSERT(PduAction != MIB_SET);

        if (pfFirst != NULL)
        {
                *pfFirst = FALSE;
        } 
        //
        // If there are no keys, return error
        //
        if (spMibInfo->Scopes == 0)
        {
                if (PduAction == MIB_GETNEXT)
                {
                        *pfFirst = TRUE;
                }
                else
                {
                        ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
                }
                goto Exit;
        }

        //
        // fixed part of the PullPnr table entries
        //
        OidIndex = SCOPE_OIDLEN;

        //
        // if the field specified is more than the max. in the table entry
        // barf
        //
        if (
                (*pField = VarBind->name.ids[OidIndex++]) > 
                        (DWORD)NO_FLDS_IN_SCOPE_ROW
           )
        {
                if (PduAction == MIB_GETNEXT)
                {
                        *pIndex = spMibInfo->Scopes - 1;
                        goto Exit;
                }
                else
                {
                        ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
                        goto Exit;
                }
        }

        //
        // get the length of key specified
        //
        AddLen = VarBind->name.idLength - (SCOPE_OIDLEN + 1);
        
        ScopeIndex = OidIndex;
        for (Index = 0; Index < AddLen; Index++)
        {
           Add = Add | (((BYTE)(VarBind->name.ids[ScopeIndex++])) << (24 - (Index * 8)));
        } 

        //
        // Check if the address specified matches with one of the keys
        //
        for (Index = 0; Index < spMibInfo->Scopes; Index++, pScope++)
        {
                if (Add == pScope->Subnet)
                {
                        *pIndex = Index;
                        return(SNMP_ERRORSTATUS_NOERROR);
                }
                else
                {
                        //
                        // if passed in value is greater, continue on to
                        // the next item.  The list is in ascending order
                        //
                        if (Add > pScope->Subnet)
                        {
                                continue;
                        }
                        else
                        {
                                //
                                // the list element is > passed in value, 
                                // break out of the loop
                                //
                                break;
                        }
                }
        }

        //
        // if no match, but field is GetNext, return the (highest index - 1)
        // reached above.  This is because, ScopeFindNext will be called by
        // the caller 
        //
        if (PduAction == MIB_GETNEXT)
        {
                if (Index == 0)
                {
                        *pfFirst = TRUE;
                }
                else
                {
                        *pIndex = Index - 1;
                } 
                ErrStat =  SNMP_ERRORSTATUS_NOERROR;
        }
        else
        {
                ErrStat =  SNMP_ERRORSTATUS_NOSUCHNAME;
        }
Exit:
        return(ErrStat);
}

UINT
ScopeFindNext(
        INT           SubKeyIndex
        )
{
        DWORD i;
        LONG  nextif;
        LPSCOPE_MIB_INFO        pScope = spMibInfo->ScopeInfo;
        
        //
        // if SubKeyIndex is 0  or more, search for the key next to
        // the key passed.
        //
        for (nextif =  -1, i = 0 ; i < spMibInfo->Scopes; i++)
        {
                if (SubKeyIndex >= 0) 
                {
                        if (
                                (pScope + i)->Subnet <= 
                                        (pScope + SubKeyIndex)->Subnet
                           )
                        {
                           //
                           // This item is lexicographically less or equal, 
                           // continue 
                           //
                           continue;
                        }
                        else
                        {
                          //
                          // We found an item that is > than the item indicated
                          // to us.  Break out of the loop
                          //
                          nextif = i;
                          break;
                        }
                }
                else
                {

#if 0
                   //
                   // if we want the first entry, then continue until
                   // we get an entry that is lexicographically same or
                   // greater
                   //
                   if (
                        (nextif < 0) 
                           ||
                        (pScope + (i - 1))->Subnet < (pScope + nextif)->Subnet
                    )
                  {
                        nextif = i;
                  }
#endif
                    nextif = 0;
                    break;
                }
        }
        return(nextif);
}        

UINT
ScopeGetFirst(
       IN RFC1157VarBind *VarBind,
       IN MIB_ENTRY        *MibPtr
        )
{

        LPSCOPE_MIB_INFO pScope = spMibInfo->ScopeInfo;
        INT           Iface;
        UINT           TableEntryIds[5];
        AsnObjectIdentifier        TableEntryOid = { OID_SIZEOF(TableEntryIds),
                                                        TableEntryIds };
           UINT   ErrStat;

        
        //
        // If there is no entry in the table, go to the next MIB variable 
        //
        if (spMibInfo->Scopes == 0)
        {
                 return(GetNextVar(VarBind, MibPtr));
        }
        //
        // Get the first entry in the table
        //
        Iface = ScopeFindNext(-1);


        //
        // Write the object Id into the binding list and call get
        // func
        //
        SnmpUtilOidFree( &VarBind->name );
        SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix );
        SnmpUtilOidAppend( &VarBind->name, &MibPtr->Oid );

        //
        // The fixed part of the objid is correct. Update the rest.
        //
        
        TableEntryIds[0] = 1;
        TableEntryIds[1] = (UINT)((pScope + Iface)->Subnet >> 24);
        TableEntryIds[2] = (UINT)(((pScope + Iface)->Subnet >> 16)  & 0xFF);
        TableEntryIds[3] = (UINT)(((pScope + Iface)->Subnet >> 8)  & 0xFF);
        TableEntryIds[4] = (UINT)((pScope + Iface)->Subnet & 0xFF);
        SnmpUtilOidAppend( &VarBind->name, &TableEntryOid );

        ErrStat = ScopeGet(VarBind);
        return(ErrStat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\dhcpmib\makefile.inc ===
obj\$(TARGET_DIRECTORY)\dhcptst.res: dhcptst.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\inc\dhcpbinl.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dhcpbinl.h

Abstract:

    This file defines the interface between the DHCP server service
    and the BINL service (used to setup and load NetPC machines).

Author:

    Colin Watson (colinw)  28-May-1997

Environment:

    User Mode - Win32

Revision History:

--*/

//
// Constants for communicating with BINL and common data structures
//

#define DHCP_STOPPED        0
#define DHCP_STARTING       1

#define DHCP_NOT_AUTHORIZED 2
#define DHCP_AUTHORIZED     3

#define DHCP_READY_TO_UNLOAD 4

#define BINL_LIBRARY_NAME L"binlsvc.dll"
#define BINL_STATE_ROUTINE_NAME "TellBinlState"
#define BINL_READ_STATE_ROUTINE_NAME "BinlState"
#define BINL_DISCOVER_CALLBACK_ROUTINE_NAME "ProcessBinlDiscoverInDhcp"
#define BINL_REQUEST_CALLBACK_ROUTINE_NAME "ProcessBinlRequestInDhcp"

typedef
VOID
(*DhcpStateChange) (
        int NewState
        );

typedef
BOOL
(*ReturnBinlState) (
        VOID
        );

typedef
DWORD
(*ProcessBinlDiscoverCallback) (
    LPDHCP_MESSAGE DhcpReceiveMessage,
    LPDHCP_SERVER_OPTIONS DhcpOptions
    );

typedef
DWORD
(*ProcessBinlRequestCallback) (
    LPDHCP_MESSAGE DhcpReceiveMessage,
    LPDHCP_SERVER_OPTIONS DhcpOptions,
    PCHAR HostName,
    PCHAR BootFileName,
    DHCP_IP_ADDRESS *BootstrapServerAddress,
    LPOPTION *Option,
    PBYTE OptionEnd
    );

DWORD
ExtractOptions(
    LPDHCP_MESSAGE DhcpReceiveMessage,
    LPDHCP_SERVER_OPTIONS DhcpOptions,
    DWORD ReceiveMessageSize
);

PCHAR
GetDhcpDomainName(
    VOID
);

LPOPTION
FormatDhcpInformAck(
    IN      LPDHCP_MESSAGE         Request,
    OUT     LPDHCP_MESSAGE         Response,
    IN      DHCP_IP_ADDRESS        IpAddress,
    IN      DHCP_IP_ADDRESS        ServerAddress
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\inc\dhcp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcp.h

Abstract:

    This module defines the DHCP server service definitions and structures.

Author:

    Manny Weiser  (mannyw)  11-Aug-1992

Revision History:

    Madan Appiah (madana) 10-Oct-1993

--*/


#ifndef _DHCP_
#define _DHCP_

#ifdef __cplusplus
extern "C"{
#endif

#define WS_VERSION_REQUIRED     MAKEWORD( 1, 1)

//
// update dhcpapi.h also if you modify the following three typedefs.
//

typedef DWORD DHCP_IP_ADDRESS, *PDHCP_IP_ADDRESS, *LPDHCP_IP_ADDRESS;
typedef DWORD DHCP_OPTION_ID;

typedef struct _DATE_TIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} DATE_TIME, *PDATE_TIME, *LPDATE_TIME;

#define DHCP_DATE_TIME_ZERO_HIGH        0
#define DHCP_DATE_TIME_ZERO_LOW         0

#define DHCP_DATE_TIME_INFINIT_HIGH     0x7FFFFFFF
#define DHCP_DATE_TIME_INFINIT_LOW      0xFFFFFFFF

#define DOT_IP_ADDR_SIZE                16          // XXX.XXX.XXX.XXX + '\0'
#define NO_DHCP_IP_ADDRESS              ((DHCP_IP_ADDRESS)-1)
#define DHCP_IP_KEY_LEN                 32          //arbitary size.

#define INFINIT_TIME                    MAXINT_PTR // time_t is int_ptr
#define INFINIT_LEASE                   0xFFFFFFFF  // in secs. (unsigned int.)

// MDHCP server well known address. Relative "1" assignment in IPv4 local scope.
/* FROM RFC 2365
The high order /24 in every scoped region is reserved for relative
   assignments. A relative assignment is an integer offset from highest
   address in the scope and represents a 32-bit address (for IPv4). For
   example, in the Local Scope defined above, 239.255.255.0/24 is
   reserved for relative allocations. The de-facto relative assignment
   "0", (i.e., 239.255.255.255 in the Local Scope) currently exists for
   SAP [SAP]. The next relative assignment, "1", corresponds to the
   address 239.255.255.254 in the Local Scope. The rest of a scoped
   region below the reserved /24 is available for dynamic assignment
   (presumably by an address allocation protocol).
*/
#define MADCAP_SERVER_IP_ADDRESS         0xfeffffef // 239.255.255.254
//
// hardware types.
//
#define HARDWARE_TYPE_NONE              0 // used for non-hardware type client id
#define HARDWARE_TYPE_10MB_EITHERNET    1
#define HARDWARE_TYPE_IEEE_802          6
#define HARDWARE_ARCNET                 7
#define HARDWARE_PPP                    8
#define HARDWARE_1394                   24

//
// Client-server protoocol reserved ports
//

#define DHCP_CLIENT_PORT    68
#define DHCP_SERVR_PORT     67
#define MADCAP_SERVER_PORT 2535
//
// DHCP BROADCAST flag.
//

#define DHCP_BROADCAST      0x8000
#define DHCP_NO_BROADCAST   0x0000

// MDHCP flag
#define DHCP_MBIT           0x4000
#define IS_MDHCP_MESSAGE( _msg ) ( ntohs((_msg)->Reserved) & DHCP_MBIT ? TRUE : FALSE )
#define MDHCP_MESSAGE( _msg ) ( (_msg)->Reserved |= htons(DHCP_MBIT) )

#define CLASSD_NET_ADDR(a)   ((a & 0xf0) == 0xe0)
#define CLASSD_HOST_ADDR(a)  ((a & 0xf0000000) == 0xe0000000)

#define CLASSE_HOST_ADDR(a)  ((a & 0xf0000000) == 0xf0000000)
#define CLASSE_NET_ADDR(a)   ((a & 0xf0) == 0xf0)

#define DHCP_MESSAGE_SIZE       576
#define DHCP_RECV_MESSAGE_SIZE  4096
#define DHCP_SEND_MESSAGE_SIZE  4096
#define BOOTP_MESSAGE_SIZE      300 // the options field for bootp is 64 bytes.

//
// The amount of time to wait for a DHCP response after a request
// has been sent.
//

#if !DBG
#define WAIT_FOR_RESPONSE_TIME          5
#else
#define WAIT_FOR_RESPONSE_TIME          10
#endif

//
// DHCP Operations
//

#define BOOT_REQUEST   1
#define BOOT_REPLY     2

//
// DHCP Standard Options.
//

#define OPTION_PAD                      0
#define OPTION_SUBNET_MASK              1
#define OPTION_TIME_OFFSET              2
#define OPTION_ROUTER_ADDRESS           3
#define OPTION_TIME_SERVERS             4
#define OPTION_IEN116_NAME_SERVERS      5
#define OPTION_DOMAIN_NAME_SERVERS      6
#define OPTION_LOG_SERVERS              7
#define OPTION_COOKIE_SERVERS           8
#define OPTION_LPR_SERVERS              9
#define OPTION_IMPRESS_SERVERS          10
#define OPTION_RLP_SERVERS              11
#define OPTION_HOST_NAME                12
#define OPTION_BOOT_FILE_SIZE           13
#define OPTION_MERIT_DUMP_FILE          14
#define OPTION_DOMAIN_NAME              15
#define OPTION_SWAP_SERVER              16
#define OPTION_ROOT_DISK                17
#define OPTION_EXTENSIONS_PATH          18

//
// IP layer parameters - per host
//

#define OPTION_BE_A_ROUTER              19
#define OPTION_NON_LOCAL_SOURCE_ROUTING 20
#define OPTION_POLICY_FILTER_FOR_NLSR   21
#define OPTION_MAX_REASSEMBLY_SIZE      22
#define OPTION_DEFAULT_TTL              23
#define OPTION_PMTU_AGING_TIMEOUT       24
#define OPTION_PMTU_PLATEAU_TABLE       25

//
// Link layer parameters - per interface.
//

#define OPTION_MTU                      26
#define OPTION_ALL_SUBNETS_MTU          27
#define OPTION_BROADCAST_ADDRESS        28
#define OPTION_PERFORM_MASK_DISCOVERY   29
#define OPTION_BE_A_MASK_SUPPLIER       30
#define OPTION_PERFORM_ROUTER_DISCOVERY 31
#define OPTION_ROUTER_SOLICITATION_ADDR 32
#define OPTION_STATIC_ROUTES            33
#define OPTION_TRAILERS                 34
#define OPTION_ARP_CACHE_TIMEOUT        35
#define OPTION_ETHERNET_ENCAPSULATION   36

//
// TCP Paramters - per host
//

#define OPTION_TTL                      37
#define OPTION_KEEP_ALIVE_INTERVAL      38
#define OPTION_KEEP_ALIVE_DATA_SIZE     39

//
// Application Layer Parameters
//

#define OPTION_NETWORK_INFO_SERVICE_DOM 40
#define OPTION_NETWORK_INFO_SERVERS     41
#define OPTION_NETWORK_TIME_SERVERS     42

//
// Vender specific information option
//

#define OPTION_VENDOR_SPEC_INFO         43

//
// NetBIOS over TCP/IP Name server option
//

#define OPTION_NETBIOS_NAME_SERVER      44
#define OPTION_NETBIOS_DATAGRAM_SERVER  45
#define OPTION_NETBIOS_NODE_TYPE        46
#define OPTION_NETBIOS_SCOPE_OPTION     47

//
// X Window System Options.
//

#define OPTION_XWINDOW_FONT_SERVER      48
#define OPTION_XWINDOW_DISPLAY_MANAGER  49

//
// Other extensions
//

#define OPTION_REQUESTED_ADDRESS        50
#define OPTION_LEASE_TIME               51
#define OPTION_OK_TO_OVERLAY            52
#define OPTION_MESSAGE_TYPE             53
#define OPTION_SERVER_IDENTIFIER        54
#define OPTION_PARAMETER_REQUEST_LIST   55
#define OPTION_MESSAGE                  56
#define OPTION_MESSAGE_LENGTH           57
#define OPTION_RENEWAL_TIME             58      // T1
#define OPTION_REBIND_TIME              59      // T2
#define OPTION_CLIENT_CLASS_INFO        60
#define OPTION_CLIENT_ID                61

#define OPTION_TFTP_SERVER_NAME         66
#define OPTION_BOOTFILE_NAME            67

//
//  user class id
//
#define OPTION_USER_CLASS               77

//
//  Dynamic DNS Stuff.  Tells if we should do both A+PTR updates?
//
#define OPTION_DYNDNS_BOTH              81

//
//  used by binl
//
#define OPTION_NETWORK_INTERFACE_TYPE   91
#define OPTION_SYSTEM_ARCHITECTURE      93
#define OPTION_CLIENT_GUID              97

// Multicast options.
#define OPTION_MCAST_SCOPE_ID           101
#define OPTION_MCAST_LEASE_START        102
#define OPTION_MCAST_TTL                103
#define OPTION_CLIENT_PORT              105
#define OPTION_MCAST_SCOPE_LIST         107

// disable autoconfiguration
#define OPTION_IETF_AUTOCONF            116

// special option to extend options
#define OPTION_LARGE_OPTION             127
#define OPTION_CLASSLESS_ROUTES         249

#define OPTION_END                      255

// MADCAP OPTIONS
#define MADCAP_OPTION_END               0
#define MADCAP_OPTION_LEASE_TIME        1
#define MADCAP_OPTION_SERVER_ID         2
#define MADCAP_OPTION_LEASE_ID          3
#define MADCAP_OPTION_MCAST_SCOPE       4
#define MADCAP_OPTION_REQUEST_LIST      5
#define MADCAP_OPTION_START_TIME        6
#define MADCAP_OPTION_ADDR_COUNT        7
#define MADCAP_OPTION_REQUESTED_LANG    8
#define MADCAP_OPTION_MCAST_SCOPE_LIST  9
#define MADCAP_OPTION_ADDR_LIST         10
#define MADCAP_OPTION_TIME              11
#define MADCAP_OPTION_FEATURE_LIST      12
#define MADCAP_OPTION_RETRY_TIME        13
#define MADCAP_OPTION_MIN_LEASE_TIME    14
#define MADCAP_OPTION_MAX_START_TIME    15
#define MADCAP_OPTION_ERROR             16
// update the total whenever changes
#define MADCAP_OPTION_TOTAL             17
#define MADCAP_OPTION_NONE              0xffff

// MADCAP error option codes
#define MADCAP_NAK_REQ_NOT_COMPLETED    0
#define MADCAP_NAK_INVALID_REQ          1
#define MADCAP_NAK_CLOCK_SKEW           2
#define MADCAP_NAK_INVALID_LEASE_ID     3
#define MADCAP_NAK_UNSUPPORTED_FEATURE  4



//
// MADCAP Message types
//


#define MADCAP_DISCOVER_MESSAGE  1
#define MADCAP_OFFER_MESSAGE     2
#define MADCAP_REQUEST_MESSAGE   3
#define MADCAP_RENEW_MESSAGE     4
#define MADCAP_ACK_MESSAGE       5
#define MADCAP_NACK_MESSAGE      6
#define MADCAP_RELEASE_MESSAGE   7
#define MADCAP_INFORM_MESSAGE    8
// update the total when above changes
#define MADCAP_TOTAL_MESSAGE     9

// MADCAP version constants
#define MADCAP_VERSION           0
enum {
    MADCAP_ADDR_FAMILY_V4 = 1,
    MADCAP_ADDR_FAMILY_V6
};

// The following definations specify how the options are
// formatted based on different versions and protocols

enum {
    PROTO_DHCP,
    PROTO_MADCAP_V4,
    PROTO_MADCAP_V6
};

typedef struct _OPTION_VERSION {
    WORD    Proto;
    WORD    Version;
} OPTION_VERSION, *POPTION_VERSION;

#define OPT_VER_DHCP {PROTO_DHCP, 1 }
#define OPT_VER_MADCAP_V4 {PROTO_MADCAP_V4, 0 }
#define OPT_VER_MADCAP_V6 {PROTO_MADCAP_V6, 0 }

// default mcast_ttl value.
#define DEFAULT_MCAST_TTL               32

//
// Different option values for the DYNDNS_BOTH option ...
//

#define DYNDNS_S_BIT 0x01
#define DYNDNS_O_BIT 0x02
#define DYNDNS_E_BIT 0x04

#define IS_CLIENT_DOING_A_AND_PTR(X)  (((X)&DYNDNS_S_BIT)== 0)

#define DYNDNS_REGISTER_AT_CLIENT       0     // Client will do both registrations
#define DYNDNS_REGISTER_AT_SERVER       1     // Server will do registrations
#define DYNDNS_DOWNLEVEL_CLIENT         0xFFFF// arbitraty # diff from above

//
// Microsoft-specific options
//
#define OPTION_MSFT_DSDOMAINNAME_REQ    94    // send me your DS Domain name
#define OPTION_MSFT_DSDOMAINNAME_RESP   95    // sending my DS Domain name

#define OPTION_MSFT_CONTINUED           250   // the previous option is being continued..
#define OPTION_MSFT_AUTOCONF            251   // enable disable autoconf
#define OPTION_MSFT_IE_PROXY            252   // IE5 proxy <string type>
#define OPTION_MSFT_SERVER_APPL         253   // has a struct.

#define OPTION_MSFT_VENDOR_NETBIOSLESS  1     // vendor option # 1
#define OPTION_MSFT_VENDOR_FEATURELIST  2     // vendor option # 2
#define BIT_RELEASE_ON_SHUTDOWN         0x01  // release on shutdown bit in feature list
#define OPTION_MSFT_VENDOR_METRIC_BASE  3     // default gateway base metric.

#define AUTOCONF_ENABLED                1
#define AUTOCONF_DISABLED               0

//
// DHCP Message types
//

#define DHCP_DISCOVER_MESSAGE  1
#define DHCP_OFFER_MESSAGE     2
#define DHCP_REQUEST_MESSAGE   3
#define DHCP_DECLINE_MESSAGE   4
#define DHCP_ACK_MESSAGE       5
#define DHCP_NACK_MESSAGE      6
#define DHCP_RELEASE_MESSAGE   7
#define DHCP_INFORM_MESSAGE    8

#define DHCP_MAGIC_COOKIE_BYTE1     99
#define DHCP_MAGIC_COOKIE_BYTE2     130
#define DHCP_MAGIC_COOKIE_BYTE3     83
#define DHCP_MAGIC_COOKIE_BYTE4     99

#define BOOT_FILE_SIZE          128
#define BOOT_SERVER_SIZE        64
#define BOOT_FILE_SIZE_W        ( BOOT_FILE_SIZE * sizeof( WCHAR ))
#define BOOT_SERVER_SIZE_W      ( BOOT_SERVER_SIZE * sizeof( WCHAR ))

//
// DHCP APP names - used to indentify to the eventlogger.
//

#define DHCP_EVENT_CLIENT     TEXT("Dhcp")
#define DHCP_EVENT_SERVER     TEXT("DhcpServer")


typedef struct _OPTION {
    BYTE OptionType;
    BYTE OptionLength;
    BYTE OptionValue[1];
} OPTION, *POPTION, *LPOPTION;

typedef struct _WIDE_OPTION {
    WORD OptionType;
    WORD OptionLength;
    BYTE OptionValue[1];
} WIDE_OPTION, *PWIDE_OPTION, *LPWIDE_OPTION;

//
// A DHCP message buffer
//


#pragma pack(1)         /* Assume byte packing */
typedef struct _DHCP_MESSAGE {
    BYTE Operation;
    BYTE HardwareAddressType;
    BYTE HardwareAddressLength;
    BYTE HopCount;
    DWORD TransactionID;
    WORD SecondsSinceBoot;
    WORD Reserved;
    DHCP_IP_ADDRESS ClientIpAddress;
    DHCP_IP_ADDRESS YourIpAddress;
    DHCP_IP_ADDRESS BootstrapServerAddress;
    DHCP_IP_ADDRESS RelayAgentIpAddress;
    BYTE HardwareAddress[16];
    BYTE HostName[ BOOT_SERVER_SIZE ];
    BYTE BootFileName[BOOT_FILE_SIZE];
    OPTION Option;
} DHCP_MESSAGE, *PDHCP_MESSAGE, *LPDHCP_MESSAGE;

typedef struct _MADCAP_MESSAGE {
    BYTE Version;
    BYTE MessageType;
    WORD AddressFamily;
    DWORD TransactionID;
//    DHCP_IP_ADDRESS ClientIpAddress;
//    DHCP_IP_ADDRESS YourIpAddress;
    WIDE_OPTION Option;
} MADCAP_MESSAGE, *PMADCAP_MESSAGE, *LPMADCAP_MESSAGE;
#pragma pack()

#define DHCP_MESSAGE_FIXED_PART_SIZE \
            (sizeof(DHCP_MESSAGE) - sizeof(OPTION))
#define MADCAP_MESSAGE_FIXED_PART_SIZE \
            (sizeof(MADCAP_MESSAGE) - sizeof (WIDE_OPTION))

#define DHCP_MIN_SEND_RECV_PK_SIZE \
            (DHCP_MESSAGE_FIXED_PART_SIZE + 64)

//
// Per message structure... Most of the structures here point within the
// message.

typedef struct _DHCP_SERVER_OPTIONS {
    BYTE                       *MessageType;
    DHCP_IP_ADDRESS UNALIGNED  *SubnetMask;
    DHCP_IP_ADDRESS UNALIGNED  *RequestedAddress;
    DWORD UNALIGNED            *RequestLeaseTime;
    BYTE                       *OverlayFields;
    DHCP_IP_ADDRESS UNALIGNED  *RouterAddress;
    DHCP_IP_ADDRESS UNALIGNED  *Server;
    BYTE                       *ParameterRequestList;
    DWORD                       ParameterRequestListLength;
    CHAR                       *MachineName;
    DWORD                       MachineNameLength;
    BYTE                        ClientHardwareAddressType;
    BYTE                        ClientHardwareAddressLength;
    BYTE                       *ClientHardwareAddress;
    CHAR                       *ClassIdentifier;
    DWORD                       ClassIdentifierLength;
    BYTE                       *VendorClass;
    DWORD                       VendorClassLength;
    DWORD                       DNSFlags;
    DWORD                       DNSNameLength;
    LPBYTE                      DNSName;
    BOOLEAN                     DSDomainNameRequested;
    CHAR                       *DSDomainName;
    DWORD                       DSDomainNameLen;
    USHORT                      SystemArchitecture;
    DWORD                       SystemArchitectureLength;
    CHAR                       *NetworkInterfaceType;
    DWORD                       NetworkInterfaceTypeLength;
    CHAR                       *Guid;
    DWORD                       GuidLength;
} DHCP_SERVER_OPTIONS, *LPDHCP_SERVER_OPTIONS;

typedef struct _MADCAP_SERVER_OPTIONS {
    BYTE  UNALIGNED            *AddrRangeList;
    WORD                        AddrRangeListSize;
    DWORD UNALIGNED            *RequestLeaseTime;
    DWORD UNALIGNED            *LeaseStartTime;
    DHCP_IP_ADDRESS UNALIGNED  *Server;
    BYTE                       *RequestList;
    WORD                        RequestListLength;
    DWORD   UNALIGNED          *ScopeId;
    CHAR                       *Guid;
    WORD                        GuidLength;
    WORD    UNALIGNED          *MinAddrCount;
    WORD    UNALIGNED          *AddrCount;
    BYTE                       *RequestLang;
    WORD                        RequestLangLength;
    DWORD   UNALIGNED          *Time;
    WORD    UNALIGNED          *Features[3];
    WORD                        FeatureCount[3];
    DWORD   UNALIGNED          *RetryTime;
    DWORD   UNALIGNED          *MinLeaseTime;
    DWORD   UNALIGNED          *MaxStartTime;
    BOOL                        OptPresent[MADCAP_OPTION_TOTAL];
} MADCAP_SERVER_OPTIONS, *LPMADCAP_SERVER_OPTIONS;

// the indices for Features array above
enum {
    SUPPORTED_FEATURES, REQUESTED_FEATURES, REQUIRED_FEATURES
};
//
// JET - DHCP database constants.
//

#define DB_TABLE_SIZE       10      // table size in 4K pages.
#define DB_TABLE_DENSITY    80      // page density
#define DB_LANGID           0x0409  // language id
#define DB_CP               1252    // code page

#if DBG

//
// debug functions.
//

#ifdef CHICAGO // No Tracing available on CHICAGO
#define DhcpPrintTrace
#endif

#define IF_DEBUG(flag) if (DhcpGlobalDebugFlag & (DEBUG_ ## flag))
#define DhcpPrint(_x_) DhcpPrintRoutine _x_
#define Trace          DhcpPrintTrace

#ifndef CHICAGO
VOID
DhcpPrintTrace(
    IN LPSTR Format,
    ...
    );

#endif

VOID
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    );

#else

#define IF_DEBUG(flag) if (FALSE)
#define DhcpPrint(_x_)
#define Trace       (void)

#endif // DBG

#define OpenDriver     DhcpOpenDriver

#ifdef __cplusplus
}
#endif

#endif // _DHCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\inc\dhcplib.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcplib.h

Abstract:

    This file contains proto type definitions for the dhcp lib
    functions.

Author:

    Madan Appiah  (madana)  12-Aug-1993

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/
#ifndef DHCPLIB_H_INCLUDED
#define DHCPLIB_H_INCLUDED
#include <madcapcl.h>

#undef DhcpAllocateMemory
#undef DhcpFreeMemory

//
// network.c
//

DHCP_IP_ADDRESS
DhcpDefaultSubnetMask(
    DHCP_IP_ADDRESS IpAddress
    );

//
// dhcp.c
//


PVOID
DhcpAllocateMemory(
    DWORD Size
    );

VOID
DhcpFreeMemory(
    PVOID Memory
    );


#if DBG

#ifndef DEBUG_ALLOC
#define DEBUG_ALLOC 0x02000000
#endif

PVOID _inline
DhcpAllocateMemoryEx(
    DWORD Size,
    DWORD LineNo,
    LPSTR FileName
) {
    LPVOID Ptr = DhcpAllocateMemory(Size);

    DhcpPrint((DEBUG_ALLOC, "Allocate %010x %04x %04d %s\n", Ptr, Size, LineNo, FileName));
    return Ptr;
}

VOID _inline
DhcpFreeMemoryEx(
    LPVOID Ptr,
    DWORD  LineNo,
    LPSTR  FileName
) {
    DhcpFreeMemory(Ptr);
    DhcpPrint((DEBUG_ALLOC, "Free %010x %04x %04d %s\n", Ptr, 0, LineNo, FileName));
}


#define DhcpAllocateMemory(Sz)    DhcpAllocateMemoryEx(Sz, __LINE__, __FILE__)
#define DhcpFreeMemory(Ptr)       DhcpFreeMemoryEx(Ptr, __LINE__, __FILE__)

#endif

LPOPTION
DhcpAppendOption(
    LPOPTION Option,
    BYTE OptionType,
    PVOID OptionValue,
    ULONG OptionLength,
    LPBYTE OptionEnd
    );

WIDE_OPTION UNALIGNED *
AppendWideOption(
    WIDE_OPTION UNALIGNED *Option,
    WORD  OptionType,
    PVOID OptionValue,
    WORD OptionLength,
    LPBYTE OptionEnd
);

WIDE_OPTION UNALIGNED *
AppendMadcapAddressList(
    WIDE_OPTION UNALIGNED *Option,
    DWORD UNALIGNED *AddrList,
    WORD            AddrCount,
    LPBYTE          OptionEnd
);

DWORD
ExpandMadcapAddressList(
    PBYTE   AddrRangeList,
    WORD    AddrRangeListSize,
    DWORD  UNALIGNED *ExpandList,
    WORD   *ExpandListSize
    );


LPOPTION
DhcpAppendClientIDOption(
    LPOPTION Option,
    BYTE ClientHWType,
    LPBYTE ClientHWAddr,
    BYTE ClientHWAddrLength,
    LPBYTE OptionEnd

    );

LPBYTE
DhcpAppendMagicCookie(
    LPBYTE Option,
    LPBYTE OptionEnd

    );

LPOPTION
DhcpAppendEnterpriseName(
    LPOPTION Option,
    PCHAR    DSEnterpriseName,
    LPBYTE   OptionEnd
    );

DATE_TIME
DhcpCalculateTime(
    DWORD RelativeTime
    );

DATE_TIME
DhcpGetDateTime(
    VOID
    );

DWORD
DhcpReportEventW(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPWSTR *Strings,
    LPVOID Data
    );

DWORD
DhcpReportEventA(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    );

DWORD
DhcpLogUnknownOption(
    LPWSTR Source,
    DWORD EventID,
    LPOPTION Option
    );

VOID
DhcpCancelWaitableTimer(
    HANDLE TimerHandle
    );

DWORD
DhcpStartWaitableTimer(
    HANDLE TimerHandle,
    DWORD SleepTime);


//
// convert.c
//

LPWSTR
DhcpOemToUnicodeN(
    IN      LPSTR   Ansi,
    IN OUT  LPWSTR  Unicode,
    IN      USHORT  cChars
    );

LPWSTR
DhcpOemToUnicode(
    IN LPSTR Ansi,
    IN OUT LPWSTR Unicode
    );

LPSTR
DhcpUnicodeToOem(
    IN LPWSTR Unicode,
    IN LPSTR Ansi
    );

ULONG
DhcpUnicodeToOemSize(
    IN LPWSTR Unicode
    );

DWORD
ConvertUTF8ToUnicode(
    LPBYTE  UTF8String,
    DWORD   UTF8Length,
    LPWSTR  UnicodeString,
    DWORD   UnicodeLength
    );

DWORD
ConvertUnicodeToUTF8(
    LPWSTR  UnicodeString,
    DWORD   UnicodeLength,
    LPBYTE  UTF8String,
    DWORD   UTF8Length
    );

#if 0

VOID
DhcpIpAddressToString(
    LPWSTR Buffer,
    DWORD HexNumber
    );

VOID
DhcpStringToIpAddress(
    LPSTR Buffer,
    LPDHCP_IP_ADDRESS IpAddress,
    BOOL NetOrder
    );

#endif

VOID
DhcpHexToString(
    LPWSTR Buffer,
    LPBYTE HexNumber,
    DWORD Length
    );

VOID
DhcpHexToAscii(
    LPSTR Buffer,
    LPBYTE HexNumber,
    DWORD Length
    );

VOID
DhcpDecimalToString(
    LPWSTR Buffer,
    BYTE Number
    );

DWORD
DhcpDottedStringToIpAddress(
    LPSTR String
    );

LPSTR
DhcpIpAddressToDottedString(
    DWORD IpAddress
    );

DWORD
DhcpStringToHwAddress(
    LPSTR AddressBuffer,
    LPSTR AddressString
    );

#if 0

DHCP_IP_ADDRESS
DhcpHostOrder(
    DHCP_IP_ADDRESS NetworkOrderAddress
    );

DHCP_IP_ADDRESS
DhcpNetworkOrder(
    DHCP_IP_ADDRESS NetworkOrderAddress
    );

#endif

LPWSTR
DhcpRegIpAddressToKey(
    DHCP_IP_ADDRESS IpAddress,
    LPWSTR KeyBuffer
    );

DWORD
DhcpRegKeyToIpAddress(
    LPWSTR Key
    );

LPWSTR
DhcpRegOptionIdToKey(
    DHCP_OPTION_ID OptionId,
    LPWSTR KeyBuffer
    );

DHCP_OPTION_ID
DhcpRegKeyToOptionId(
    LPWSTR Key
    );

#if DBG

VOID
DhcpDumpMessage(
    DWORD DhcpDebugFlag,
    LPDHCP_MESSAGE DhcpMessage,
    ULONG MessageSize
    );

VOID
MadcapDumpMessage(
    DWORD DhcpDebugFlag,
    LPMADCAP_MESSAGE MadcapMessage,
    ULONG MessageSize
    );

VOID
DhcpAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    );

#define DhcpAssert(Predicate) \
    { \
        if (!(Predicate)) \
            DhcpAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#define DhcpVerify(Predicate) \
    { \
        if (!(Predicate)) \
            DhcpAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#else

#define DhcpAssert(_x_)
#define DhcpDumpMessage(_x_, _y_, _z_)
#define MadcapDumpMessage(_x_, _y_, _z_)
#define DhcpVerify(_x_) (_x_)

#endif // not DBG

VOID
DhcpNTToNTPTime(
    LPDATE_TIME AbsNTTime,
    DWORD       Offset,
    PULONG      NTPTimeStamp
    );

VOID
DhcpNTPToNTTime(
    PULONG          NTPTimeStamp,
    DWORD           Offset,
    DATE_TIME       *NTTime
    );


#endif DHCPLIB_H_INCLUDED

//------------------------------------------------------------------------
// End of file
//------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\dhcpmib\dhcpmibm.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dhcpmibm.c

Abstract:

    Sample SNMP Extension Agent for Windows NT.

    These files (dhcpdll.c, dhcpsmib.c, and dhcpmib.h) provide an example of 
    how to structure an Extension Agent DLL which works in conjunction with 
    the SNMP Extendible Agent for Windows NT.

    Extensive comments have been included to describe its structure and
    operation.  See also "Microsoft Windows/NT SNMP Programmer's Reference".

Created:

    28-Jun-1991

Revision History:

--*/


#ifdef UNICODE
#undef UNICODE
#endif

// General notes:
//
//   Microsoft's Extendible Agent for Windows NT is implemented by dynamically
// linking to Extension Agent DLLs that implement portions of the MIB.  These
// Extension Agents are configured in the Windows NT Registration Database.
// When the Extendible Agent Service is started, it queries the registry to
// determine which Extension Agent DLLs have been installed and need to be
// loaded and initialized.  The Extendible Agent invokes various DLL entry
// points (examples follow in this file) to request MIB queries and obtain
// Extension Agent generated traps.


// Necessary includes.

#include <windows.h>

#include <snmp.h>


// Contains definitions for the table structure describing the MIB.  This
// is used in conjunction with dhcpmib.c where the MIB requests are resolved.

#include "dhcpmib.h"


// Extension Agent DLLs need access to elapsed time agent has been active.
// This is implemented by initializing the Extension Agent with a time zero
// reference, and allowing the agent to compute elapsed time by subtracting
// the time zero reference from the current system time.  This example
// Extension Agent implements this reference with dwTimeZero.

DWORD dwTimeZero = 0;


// Extension Agent DLLs that generate traps must create a Win32 Event object
// to communicate occurence of traps to the Extendible Agent.  The event
// handle is given to the Extendible Agent when the Extension Agent is 
// initialized, it should be NULL if traps will not be generated.  This
// example Extension Agent simulates the occurance of traps with hSimulateTrap.

HANDLE hSimulateTrap = NULL;


// This is a standard Win32 DLL entry point.  See the Win32 SDK for more
// information on its arguments and their meanings.  This example DLL does 
// not perform any special actions using this mechanism.

BOOL WINAPI DllMain(
    HANDLE hDll,
    DWORD  dwReason,
    LPVOID lpReserved)
    {
    switch(dwReason)
        {
        case DLL_PROCESS_ATTACH:
        case DLL_PROCESS_DETACH:
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            break;

        } // end switch()

    return TRUE;

    } // end DllEntryPoint()


// Extension Agent DLLs provide the following entry point to coordinate the
// initializations of the Extension Agent and the Extendible Agent.  The
// Extendible Agent provides the Extension Agent with a time zero reference;
// and the Extension Agent provides the Extendible Agent with an Event handle 
// for communicating occurence of traps, and an object identifier representing
// the root of the MIB subtree that the Extension Agent supports.

BOOL SnmpExtensionInit(
    IN  DWORD               dwTimeZeroReference,
    OUT HANDLE              *hPollForTrapEvent,
    OUT AsnObjectIdentifier *supportedView)
    {

    // Record the time reference provided by the Extendible Agent.

    dwTimeZero = dwTimeZeroReference;


    // Create an Event that will be used to communicate the occurence of traps
    // to the Extendible Agent.  The Extension Agent will assert this Event
    // when a trap has occured.  This is explained further later in this file.

    if ((*hPollForTrapEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
        {
        // Indicate error?, be sure that NULL is returned to Extendible Agent.
        }


    // Indicate the MIB view supported by this Extension Agent, an object
    // identifier representing the sub root of the MIB that is supported.

    *supportedView = MIB_OidPrefix; // NOTE!  structure copy


    // Record the trap Event.  This example Extension Agent simulates traps by 
    // generating a trap after every given number of processed requests.

    hSimulateTrap = *hPollForTrapEvent;


    // Indicate that Extension Agent initialization was sucessfull.

    return TRUE;

    } // end SnmpExtensionInit()


// Extension Agent DLLs provide the following entry point to communcate traps
// to the Extendible Agent.  The Extendible Agent will query this entry point
// when the trap Event (supplied at initialization time) is asserted, which
// indicates that zero or more traps may have occured.  The Extendible Agent 
// will repetedly call this entry point until FALSE is returned, indicating 
// that all outstanding traps have been processed.

BOOL SnmpExtensionTrap(
    OUT AsnObjectIdentifier *enterprise,
    OUT AsnInteger          *genericTrap,
    OUT AsnInteger          *specificTrap,
    OUT AsnTimeticks        *timeStamp,
    OUT RFC1157VarBindList  *variableBindings)
    {
    // The body of this routine is an extremely simple example/simulation of
    // the trap functionality.  A real implementation will be more complex.


    // The following define data inserted into the trap below.  The Lan Manager
    // bytesAvailAlert from the Lan Manager Alerts-2 MIB is generated with an
    // empty variable bindings list.

    static UINT OidList[]  = { 1, 3, 6, 1, 4, 1, 311, 2 };
    static UINT OidListLen = 8;


    // The following variable is used for the simulation, it allows a single
    // trap to be generated and then causes FALSE to be returned indicating
    // no more traps.

    static whichTime = 0;


    // The following if/else support the simulation.

    if (whichTime == 0)
        {
        whichTime = 1;    // Supports the simulation.


        // Communicate the trap data to the Extendible Agent.

        enterprise->idLength = OidListLen;
        enterprise->ids = (UINT *)SnmpUtilMemAlloc(sizeof(UINT) * OidListLen);

	if (NULL == enterprise->ids) {
	    whichTime = 0;
	    return FALSE;
	}
        memcpy(enterprise->ids, OidList, sizeof(UINT) * OidListLen);

        *genericTrap      = SNMP_GENERICTRAP_ENTERSPECIFIC;

        *specificTrap     = 1;                    // the bytesAvailAlert trap

        *timeStamp        = GetCurrentTime() - dwTimeZero;

        variableBindings->list = NULL;
        variableBindings->len  = 0;


        // Indicate that valid trap data exists in the parameters.

        return TRUE;
        }
    else
        {
        whichTime = 0;    // Supports the simulation.


        // Indicate that no more traps are available and parameters do not
        // refer to any valid data.

        return FALSE;
        }

    } // end SnmpExtensionTrap()


// Extension Agent DLLs provide the following entry point to resolve queries
// for MIB variables in their supported MIB view (supplied at initialization
// time).  The requestType is Get/GetNext/Set.

BOOL SnmpExtensionQuery(
    IN BYTE                   requestType,
    IN OUT RFC1157VarBindList *variableBindings,
    OUT AsnInteger            *errorStatus,
    OUT AsnInteger            *errorIndex)
{
    static unsigned long requestCount = 0;  // Supports the trap simulation.
    UINT    I;


try {
    //
    // Iterate through the variable bindings list to resolve individual
    // variable bindings.
    //

    fDhcpMibVarsAccessed = FALSE;
    for ( I=0;I < variableBindings->len;I++ )
    {
        *errorStatus = ResolveVarBind( &variableBindings->list[I],
                                       requestType );


	//
        // Test and handle case where Get Next past end of MIB view supported
        // by this Extension Agent occurs.  Special processing is required to 
        // communicate this situation to the Extendible Agent so it can take 
        // appropriate action, possibly querying other Extension Agents.
	//

        if ( *errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME &&
             requestType == MIB_GETNEXT )
           {
           *errorStatus = SNMP_ERRORSTATUS_NOERROR;


           // Modify variable binding of such variables so the OID points
           // just outside the MIB view supported by this Extension Agent.
           // The Extendible Agent tests for this, and takes appropriate
           // action.

           SnmpUtilOidFree( &variableBindings->list[I].name );
           SnmpUtilOidCpy( &variableBindings->list[I].name, &MIB_OidPrefix );
           variableBindings->list[I].name.ids[MIB_PREFIX_LEN-1] ++;
           }


        // If an error was indicated, communicate error status and error
        // index to the Extendible Agent.  The Extendible Agent will ensure
        // that the origional variable bindings are returned in the response
        // packet.

        if ( *errorStatus != SNMP_ERRORSTATUS_NOERROR )
        {
	   *errorIndex = I+1;
	//   goto Exit;
	}
	else
	{
	   *errorIndex = 0;
	}
   }

} // end of try
except(EXCEPTION_EXECUTE_HANDLER) {
	//
	// for now do nothing
	//	
	}

#if 0
    // Supports the trap simulation.

    if (++requestCount % 3 == 0 && hSimulateTrap != NULL)
        SetEvent(hSimulateTrap);


    // Indicate that Extension Agent processing was sucessfull.


#if 0
      if (*errorStatus != SNMP_ERRORSTATUS_NOERROR)
      {
	 return(FALSE);
      }	

    return TRUE;
#endif
#endif
    return SNMPAPI_NOERROR;

} // end SnmpExtensionQuery()


//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\inc\dhcpexim.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    dhcpexim.h

Abstract:

    Routines that are exported out of the exim.lib

--*/

#ifndef DHCPEXIM_H
#define DHCPEXIM_H

typedef struct _DHCPEXIM_CONTEXT {
    LPWSTR FileName;
    BOOL fExport;
    BOOL fDisableExportedScopes;
    HANDLE hFile;
    LPBYTE Mem;
    DWORD MemSize;
    PVOID SvcConfig;
    PVOID FileConfig;
    DWORD nScopes;
    struct {
        BOOL fSelected;
        LPWSTR SubnetName;
        DWORD SubnetAddress;
    } *Scopes;
    

} DHCPEXIM_CONTEXT, *PDHCPEXIM_CONTEXT;

    
DWORD
DhcpEximInitializeContext(
    IN OUT PDHCPEXIM_CONTEXT Ctxt,
    IN LPWSTR FileName,
    IN BOOL fExport
    );

DWORD
DhcpEximCleanupContext(
    IN OUT PDHCPEXIM_CONTEXT Ctxt,
    IN BOOL fAbort
    );


DWORD
CmdLineDoImport(
    IN LPWSTR *Args,
    IN ULONG nArgs
    );

DWORD
CmdLineDoExport(
    IN LPWSTR *Args,
    IN ULONG nArgs
    );

//
// the following functions are not implemented in the exim.lib,
// but these should be implemented by whoever uses exim.lib
//

VOID
DhcpEximErrorClassConflicts(
    IN LPWSTR SvcClass,
    IN LPWSTR ConfigClass
    );

VOID
DhcpEximErrorOptdefConflicts(
    IN LPWSTR SvcOptdef,
    IN LPWSTR ConfigOptdef
    );

VOID
DhcpEximErrorOptionConflits(
    IN LPWSTR SubnetName OPTIONAL,
    IN LPWSTR ResAddress OPTIONAL,
    IN LPWSTR OptId,
    IN LPWSTR UserClass OPTIONAL,
    IN LPWSTR VendorClass OPTIONAL
    );

VOID
DhcpEximErrorSubnetNotFound(
    IN LPWSTR SubnetAddress
    );

VOID
DhcpEximErrorSubnetAlreadyPresent(
    IN LPWSTR SubnetAddress,
    IN LPWSTR SubnetName OPTIONAL
    );

VOID
DhcpEximErrorDatabaseEntryFailed(
    IN LPWSTR ClientAddress,
    IN LPWSTR ClientHwAddress,
    IN DWORD Error,
    OUT BOOL *fAbort
    );







#endif  DHCPEXIM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\inc\heapx.h ===
//
// Copyright (C) 1995 Microsoft Corporation
//
//

#ifndef __HEAPX_H__

#define __HEAPX_H__

#ifdef DBG
#ifdef __DHCP_USE_DEBUG_HEAP__

#include <stdlib.h>
#include <malloc.h>

#define _DEBUG
#define _CRTDBG_MAP_ALLOC
#include <crtdbg.h>

#define HEAPX_NORMAL    0
#define HEAPX_VERIFY    1
#define HEAPX_RETAIN    3


#define INIT_DEBUG_HEAP( Level ) \
{  \
    int nDbgFlags; \
   _CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_DEBUG );\
   _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_DEBUG );\
   _CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_DEBUG );\
   nDbgFlags = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG ); \
   \
   if ( Level & HEAPX_VERIFY ) \
   { \
       nDbgFlags |= _CRTDBG_CHECK_ALWAYS_DF; \
   } \
   if ( Level & HEAPX_RETAIN ) \
   { \
       nDbgFlags |= _CRTDBG_DELAY_FREE_MEM_DF; \
   } \
   _CrtSetDbgFlag( nDbgFlags ); \
}

#define UNINIT_DEBUG_HEAP() \
 _ASSERT( _CrtCheckMemory() ); \
 _ASSERT( !_CrtDumpMemoryLeaks() );

#else // #ifdef __DHCP_USE_DEBUG_HEAP__
#define INIT_DEBUG_HEAP( Level )
#define UNINIT_DEBUG_HEAP()
#endif




#else // #ifdef DBG

#define INIT_DEBUG_HEAP( Level )
#define UNINIT_DEBUG_HEAP()

#endif






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\inc\dhcprog.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcprog.h

Abstract:

    This file contain function prototypes for the DHCP server rogue detection
    routines.

Author:

    Ramesh Vyaghrapuri (rameshv) 17-Aug-1998

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/
#ifndef ROGUE_H_INCLUDED
#define ROGUE_H_INCLUDED

//
// Structure that holds the state information for Rogue detection
//

#define         MAX_DNS_NAME_LEN                 260

typedef enum {
    ROLE_DOMAIN = 0,
    ROLE_NT4_DOMAIN,
    ROLE_WORKGROUP,
    ROLE_SBS,

    ROLE_INVALID
} ROLE_TYPE;

typedef struct {
    SOCKET socket;
    DHCP_IP_ADDRESS IpAddr;
    DHCP_IP_ADDRESS SubnetAddr;
} ROGUE_ENDPOINT, *PROGUE_ENDPOINT;

typedef struct {
    BOOL        fInitialized;
    HANDLE      TerminateEvent;
    HANDLE      WaitHandle;

    ROLE_TYPE   eRole;
    BOOL        fDhcp;
    DWORD       fLogEvents;  // this is tri-state 
    ULONG       NoNetTriesCount;
    ULONG       GetDsDcNameRetries;
    BOOL        fJustUpgraded;
    BOOL        fAuthorized;
    ULONG       CachedAuthStatus;
    ULONG       RogueState;
    ULONG       InformsSentCount;
    DWORD       TransactionID;
    ULONG       SleepTime;
    ULONG       ReceiveTimeLimit;
    ULONG       ProcessAckRetries;
    ULONG       WaitForAckRetries;
    ULONG       nResponses;

    ULONG       StartTime;
    ULONG       LastUnauthLogTime;

    WCHAR       DomainDnsName[MAX_DNS_NAME_LEN];
    WCHAR       DnsForestName[MAX_DNS_NAME_LEN];
    DWORD       nBoundEndpoints;
    PROGUE_ENDPOINT pBoundEP;
    SOCKET      RecvSocket;
    BOOL        fFormattedMessage;
    BYTE        SendMessage[DHCP_MESSAGE_SIZE];
    UUID        FakeHardwareAddress;
    ULONG       SendMessageSize;
    BYTE        RecvMessage[DHCP_MESSAGE_SIZE];

    ULONG       LastSeenIpAddress;
    WCHAR       LastSeenDomain[MAX_DNS_NAME_LEN];

}   DHCP_ROGUE_STATE_INFO, *PDHCP_ROGUE_STATE_INFO;


//
// Rogue.C
//

DWORD
APIENTRY
DhcpRogueInit(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info OPTIONAL,
    IN      HANDLE                 WaitEvent,
    IN      HANDLE                 TerminateEvent
);

VOID
APIENTRY
DhcpRogueCleanup(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info OPTIONAL
);

ULONG
APIENTRY
RogueDetectStateMachine(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info OPTIONAL
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\inc\gmacros.h ===
/*================================================================================
$ Copyright (C) 1997 Microsoft Corporation
  File: gmacros.h
  Contains: Macros used in common by both the DHCP Server and the DHCP Client.
  	Most of them are inlines for sake of elegance and ease of usage.
  Author: RameshV
  Created: 04-Jun-97 00:01

================================================================================*/
#include <align.h>

//  Some block macros; usage at end

//  Disable the warning about unreference labels.
#pragma warning(disable : 4102)

#define _shorten(string)    ( strrchr(string, '\\')? strrchr(string, '\\') : (string) )

// print a message and the file and line # of whoever is printing this.
#define _TracePrintLine(Msg)  DhcpPrint((DEBUG_TRACE_CALLS, "%s:%d %s\n", _shorten(__FILE__), __LINE__, Msg))

#define BlockBegin(Name)    { BlockStart_ ## Name : _TracePrintLine( "Block -> " #Name );
#define BlockEnd(Name)      BlockEnd_ ## Name : _TracePrintLine( "Block <- " #Name ) ;}
#define BlockContinue(Name) do { _TracePrintLine( "Continue to " #Name); goto BlockStart_ ## Name; } while (0)
#define BlockBreak(Name)    do { _TracePrintLine( "Breaking out of " #Name); goto BlockEnd_ ## Name; } while (0)
#define RetFunc(F,Ret)      do {_TracePrintLine( "Quitting function " #F ); return Ret ; } while (0)

// The way to use the above set of simple block macros is as follows: (example usage)
#if     0
int
DummyFunction(VOID) {
    BlockBegin(DummyFunctionMain) {
        if(GlobalCount > 0 )
            BlockContinue(DummyFunctionMain);
        else GlobalCount ++;

        if(GlobalCount > GlobalCountMax)
            BlockBreak(DummyFunctionMain);
    } BlockEnd(DummyFunctionMain);

    RetFunc(DummyFunction, RetVal);
}
#endif

// now come some little more complicated functions..
// note that these can be freely mixed with the above set of simple functions.
#define BlockBeginEx(Name, String)    {BlockStart_ ## Name : _TracePrintLine( #String );
#define BlockEndEx(Name, String)      BlockEnd_## Name : _TracePrintLine( #String );}
#define BlockContinueEx(Name, String) do {_TracePrintLine( #String); goto BlockStart_ ## Name; } while (0)
#define BlockBreakEx(Name, String)    do {_TracePrintLine( #String); goto BlockEnd_ ## Name; } while(0)

#define RetFuncEx(Name,Ret,DebMsg)    do {_TracePrintLine( "QuittingFunction " #Name); DhcpPrint(DebMsg); return Ret;} while(0)

// usage example:

#if 0
int
DummyFunction(VOID) {
    BlockBeginEx(Main, "Entering Dummy Function" ) {
        if( GlobalCount > 0)
            BlockContinueEx(Main, GlobalCount > 0);
        else GlobalCount ++;

        if(GlobalCount > GlobalCountMax)
            BlockBreak(Main);
    } BlockEndEx(Main, "Done Dummy Function");

    RetFunc(DummyFunc, RetVal);
    // OR
    RetFuncEx(DummyFunc, RetVal, (DEBUG_ERRROS, "Function returning, gcount = %ld\n", GlobalCount));

}

#endif 0


#define NOTHING

// Now if a VOID function (procedure) returns, we can say RetFunc(VoidFunc, NOTHING) and things will work.


//================================================================================
//  Now some useful inlines.
//================================================================================

VOID _inline
FreeEx(LPVOID Ptr) {
    if(Ptr) DhcpFreeMemory(Ptr);
}

VOID _inline
FreeEx2(LPVOID Ptr1, LPVOID Ptr2) {
    FreeEx(Ptr1); FreeEx(Ptr2);
}

VOID _inline
FreeEx3(LPVOID Ptr1, LPVOID Ptr2, LPVOID Ptr3) {
    FreeEx(Ptr1); FreeEx(Ptr2); FreeEx(Ptr3);
}

VOID _inline
FreeEx4(LPVOID Ptr1, LPVOID Ptr2, LPVOID Ptr3, LPVOID Ptr4) {
    FreeEx2(Ptr1, Ptr2); FreeEx2(Ptr3, Ptr4);
}

//--------------------------------------------------------------------------------
//  All the alloc functions below, allocate in one shot a few pointers,
//  and initialize them.. aligning them correctly.
//--------------------------------------------------------------------------------
LPVOID _inline
AllocEx(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) + Size2;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);

    return Ptr;
}

LPVOID _inline
AllocEx2(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) + Size2;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);

    return Ptr;
}

LPVOID _inline
AllocEx3(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2, LPVOID *Ptr3, DWORD Size3) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) + ROUND_UP_COUNT(Size2, ALIGN_WORST) + Size3;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);
    (*Ptr3) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST) + ROUND_UP_COUNT(Size2, ALIGN_WORST);
    return Ptr;
}

LPVOID _inline
AllocEx4(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2,
         LPVOID *Ptr3, DWORD Size3, LPVOID *Ptr4, DWORD Size4) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) +
    	ROUND_UP_COUNT(Size2, ALIGN_WORST) + ROUND_UP_COUNT(Size3, ALIGN_WORST) + Size4;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);
    (*Ptr3) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST) + ROUND_UP_COUNT(Size2, ALIGN_WORST);
    (*Ptr4) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST) +
    	ROUND_UP_COUNT(Size2, ALIGN_WORST) + ROUND_UP_COUNT(Size3, ALIGN_WORST);
    return Ptr;
}

//--------------------------------------------------------------------------------
//  This function takes an input string and a static buffer and if the input
//  string is not nul terminated, copies it to the static buffer and then null
//  terminates it.  It also change the size to reflect the new size..
//--------------------------------------------------------------------------------
LPBYTE _inline
AsciiNulTerminate(LPBYTE Input, DWORD *Size, LPBYTE StaticBuf, DWORD BufSize) {
    if( 0 == *Size) return Input;   // nothing to copy
    if(!Input[(*Size)-1]) return Input; // Everything is fine.

    if(*Size >= BufSize) {
        // Nothing much can be done here.. this is an error.. insufficient buffer space.
        DhcpAssert(FALSE);

        *Size = BufSize - 1;
    }

    memcpy(StaticBuf, Input, (*Size));
    StaticBuf[*Size] = '\0';
    (*Size) ++;
    return StaticBuf;
}

#if DBG
#define INLINE
#else
#define INLINE _inline
#endif

#define BEGIN_EXPORT
#define END_EXPORT

#define AssertReturn(Condition, RetVal )    do { DhcpAssert(Condition); return RetVal ;} while(0)

//================================================================================
//  End of File.
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\lib\dhcpcom.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpcom.c

Abstract:

    This module contains OS independent routines


Author:

    John Ludeman (johnl) 13-Nov-1993
        Broke out independent routines from existing files

Revision History:


--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <dhcpl.h>



LPOPTION
DhcpAppendOption(
    LPOPTION Option,
    BYTE OptionType,
    PVOID OptionValue,
    ULONG OptionLength,
    LPBYTE OptionEnd
)
/*++

Routine Description:

    This function writes a DHCP option to message buffer.

Arguments:

    Option - A pointer to a message buffer.

    OptionType - The option number to append.

    OptionValue - A pointer to the option data.

    OptionLength - The lenght, in bytes, of the option data.

    OptionEnd - End of Option Buffer.

Return Value:

    A pointer to the end of the appended option.

--*/
{
    DWORD  i;

    if ( OptionType == OPTION_END ) {

        //
        // we should alway have atleast one BYTE space in the buffer
        // to append this option.
        //

        DhcpAssert( (LPBYTE)Option < OptionEnd );


        Option->OptionType = OPTION_END;
        return( (LPOPTION) ((LPBYTE)(Option) + 1) );

    }

    if ( OptionType == OPTION_PAD ) {

        //
        // add this option only iff we have enough space in the buffer.
        //

        if(((LPBYTE)Option + 1) < (OptionEnd - 1) ) {
            Option->OptionType = OPTION_PAD;
            return( (LPOPTION) ((LPBYTE)(Option) + 1) );
        }

        DhcpPrint(( 0, "DhcpAppendOption failed to append Option "
                    "%ld, Buffer too small.\n", OptionType ));
        return Option;
    }


    //
    // add this option only iff we have enough space in the buffer.
    //

    if(((LPBYTE)Option + 2 + OptionLength) >= (OptionEnd - 1) ) {
        DhcpPrint(( 0, "DhcpAppendOption failed to append Option "
                    "%ld, Buffer too small.\n", OptionType ));
        return Option;
    }

    if( OptionLength <= 0xFF ) {
        // simple option.. no need to use OPTION_MSFT_CONTINUED
        Option->OptionType = OptionType;
        Option->OptionLength = (BYTE)OptionLength;
        memcpy( Option->OptionValue, OptionValue, OptionLength );
        return( (LPOPTION) ((LPBYTE)(Option) + Option->OptionLength + 2) );
    }

    // option size is > 0xFF --> need to continue it using multiple ones..
    // there are OptionLenght / 0xFF occurances using 0xFF+2 bytes + one
    // using 2 + (OptionLength % 0xFF ) space..

    // check to see if we have the space first..

    if( 2 + (OptionLength%0xFF) + 0x101*(OptionLength/0xFF)
        + (LPBYTE)Option >= (OptionEnd - 1) ) {
        DhcpPrint(( 0, "DhcpAppendOption failed to append Option "
                    "%ld, Buffer too small.\n", OptionType ));
        return Option;
    }

    // first finish off all chunks of 0xFF size that we can do..

    i = OptionLength/0xFF;
    while(i --) {
        Option->OptionType = OptionType;
        Option->OptionLength = 0xFF;
        memcpy(Option->OptionValue, OptionValue, 0xFF);
        OptionValue = 0xFF+(LPBYTE)OptionValue;
        Option = (LPOPTION)(0x101 + (LPBYTE)Option);
        OptionType = OPTION_MSFT_CONTINUED;       // all but the first use this ...
        OptionLength -= 0xFF;
    }

    // now finish off the remaining stuff..
    DhcpAssert(OptionLength <= 0xFF);
    Option->OptionType = OPTION_MSFT_CONTINUED;
    Option->OptionLength = (BYTE)OptionLength;
    memcpy(Option->OptionValue, OptionValue, OptionLength);
    Option = (LPOPTION)(2 + OptionLength + (LPBYTE)Option);
    DhcpAssert((LPBYTE)Option < OptionEnd);

    return Option;
}

WIDE_OPTION UNALIGNED *
AppendWideOption(
    WIDE_OPTION UNALIGNED *Option,
    WORD  OptionType,
    PVOID OptionValue,
    WORD OptionLength,
    LPBYTE OptionEnd
)
/*++

Routine Description:

    This function writes a DHCP option to message buffer.

Arguments:

    Option - A pointer to a message buffer.

    OptionType - The option number to append.

    OptionValue - A pointer to the option data.

    OptionLength - The lenght, in bytes, of the option data.

    OptionEnd - End of Option Buffer.

Return Value:

    A pointer to the end of the appended option.

--*/
{
    DWORD  i;


    //
    // add this option only iff we have enough space in the buffer.
    //

    if(((LPBYTE)&Option->OptionValue + OptionLength) >= (OptionEnd - FIELD_OFFSET(WIDE_OPTION, OptionValue)) ) {
        DhcpPrint(( 0, "AppendWideOption failed to append Option "
                    "%ld, Buffer too small.\n", OptionType ));
        return Option;
    }


    Option->OptionType = ntohs(OptionType);
    Option->OptionLength = ntohs(OptionLength);
    memcpy(Option->OptionValue, OptionValue, OptionLength);
    Option = (WIDE_OPTION UNALIGNED *)((PBYTE)&Option->OptionValue + OptionLength );
    DhcpAssert((LPBYTE)Option < OptionEnd);

    return Option;
}

WIDE_OPTION UNALIGNED *
AppendMadcapAddressList(
    WIDE_OPTION UNALIGNED * Option,
    DWORD UNALIGNED *AddrList,
    WORD            AddrCount,
    LPBYTE          OptionEnd
)
/*++

Routine Description:

    This function appends madcap address list option.

Arguments:

    Option - A pointer to a message buffer.

    AddrList - The list of the addresses to be attached.

    AddrCount - Count of addresses in above list.

    OptionEnd - End of Option Buffer.

Return Value:

    A pointer to the end of the appended option.

--*/
{
    DWORD StartAddr;
    WORD i;
    WORD BlockCount,BlockSize;
    PBYTE Buff;
    WORD  OptionLength;

    if (AddrCount < 1) {
        return Option;
    }
    // First find out how many blocks do we need
    for (BlockCount = i = 1; i<AddrCount; i++  ) {
        if (ntohl(AddrList[i]) != ntohl(AddrList[i-1]) + 1 ) {
            BlockCount++;
        }
    }

    OptionLength = BlockCount*6;
    if(((LPBYTE)&Option->OptionValue + OptionLength) >= (OptionEnd - FIELD_OFFSET(WIDE_OPTION, OptionValue)) ) {
        DhcpPrint(( 0, "AppendMadcapAddressList failed to append Option "
                    "Buffer too small\n" ));
        return Option;
    }

    StartAddr = AddrList[0];
    BlockSize = 1;
    Buff = Option->OptionValue;
    for (i = 1; i<AddrCount; i++  ) {
        if (ntohl(AddrList[i]) != ntohl(AddrList[i-1]) + 1 ) {
            BlockCount--;
            *(DWORD UNALIGNED *)Buff = StartAddr;
            Buff += 4;
            *(WORD UNALIGNED *)Buff = htons(BlockSize);
            Buff += 2;
            BlockSize = 1;
            StartAddr = AddrList[i];
        } else {
            BlockSize++;
        }
    }
    BlockCount--;
    DhcpAssert(0==BlockCount);
    *(DWORD UNALIGNED *)Buff = StartAddr;
    Buff += 4;
    *(WORD UNALIGNED *)Buff = htons(BlockSize);
    Buff += 2;

    Option->OptionType = ntohs(MADCAP_OPTION_ADDR_LIST);
    Option->OptionLength = htons(OptionLength);
    Option = (WIDE_OPTION UNALIGNED *)Buff;
    DhcpAssert((LPBYTE)Option < OptionEnd);

    return Option;

}

DWORD
ExpandMadcapAddressList(
    PBYTE   AddrRangeList,
    WORD    AddrRangeListSize,
    DWORD UNALIGNED *ExpandList,
    WORD   *ExpandListSize
    )

/*++

Routine Description:

    This function expands AddrRangeList from the wire format to array of
    addresses.

Arguments:

    AddrRangeList - pointer to the AddrRangeList option Buffer.

    AddrRangeListSize - size of the above buffer.

    ExpandList - the pointer to the array where addresses are to be expanded.
                   pass NULL if you want to determine the size of the expanded list.

    ExpandListSize - No. of elements in above array.

Return Value:

    Win32 ErrorCode
--*/
{
    WORD TotalCount, BlockSize;
    PBYTE ListEnd, Buff;
    DWORD StartAddr;

    // first count how many addresses we have in the list
    ListEnd = AddrRangeList + AddrRangeListSize;
    Buff = AddrRangeList;
    TotalCount = 0;
    while ((Buff + 6 ) <= ListEnd) {
        StartAddr = *(DWORD UNALIGNED *) Buff;
        Buff += 4;
        BlockSize = ntohs(*(WORD UNALIGNED *)Buff);
        Buff += 2;
        if (!CLASSD_NET_ADDR(StartAddr) || !CLASSD_NET_ADDR(htonl(ntohl(StartAddr)+BlockSize-1)) ) {
            return ERROR_BAD_FORMAT;
        }
        TotalCount += BlockSize;
    }
    if (NULL == ExpandList) {
        *ExpandListSize = TotalCount;
        return ERROR_BUFFER_OVERFLOW;
    }
    if (Buff != ListEnd || TotalCount > *ExpandListSize || 0 == TotalCount) {
        return ERROR_BAD_FORMAT;
    }
    // now expand the actual list.
    ListEnd = AddrRangeList + AddrRangeListSize;
    Buff = AddrRangeList;

    while ((Buff + 6 ) <= ListEnd) {
        StartAddr = *(DWORD UNALIGNED *) Buff;
        Buff += 4;
        BlockSize = ntohs(*(WORD UNALIGNED *)Buff);
        Buff += 2;
        StartAddr = ntohl(StartAddr);
        while (BlockSize--) {
            *ExpandList = htonl(StartAddr);
            StartAddr++;
            ExpandList++;
        }
    }
    DhcpAssert(Buff == ListEnd);
    *ExpandListSize = TotalCount;
    return ERROR_SUCCESS;
}


LPOPTION
DhcpAppendClientIDOption(
    LPOPTION Option,
    BYTE ClientHWType,
    LPBYTE ClientHWAddr,
    BYTE ClientHWAddrLength,
    LPBYTE OptionEnd

    )
/*++

Routine Description:

    This routine appends client ID option to a DHCP message.

History:
    8/26/96 Frankbee    Removed 16 byte limitation on the hardware
                        address

Arguments:

    Option - A pointer to the place to append the option request.

    ClientHWType - Client hardware type.

    ClientHWAddr - Client hardware address

    ClientHWAddrLength - Client hardware address length.

    OptionEnd - End of Option buffer.

Return Value:

    A pointer to the end of the newly appended option.

    Note : The client ID option will look like as below in the message:

     -----------------------------------------------------------------
    | OpNum | Len | HWType | HWA1 | HWA2 | .....               | HWAn |
     -----------------------------------------------------------------

--*/
{
    struct _CLIENT_ID {
        BYTE    bHardwareAddressType;
        BYTE    pbHardwareAddress[0];
    } *pClientID;

    LPOPTION lpNewOption;

    pClientID = DhcpAllocateMemory( sizeof( struct _CLIENT_ID ) + ClientHWAddrLength );

    //
    // currently there is no way to indicate failure.  simply return unmodified option
    // list
    //

    if ( !pClientID )
        return Option;

    pClientID->bHardwareAddressType    = ClientHWType;
    memcpy( pClientID->pbHardwareAddress, ClientHWAddr, ClientHWAddrLength );

    lpNewOption =  DhcpAppendOption(
                         Option,
                         OPTION_CLIENT_ID,
                         (LPBYTE)pClientID,
                         (BYTE)(ClientHWAddrLength + sizeof(BYTE)),
                         OptionEnd );

    DhcpFreeMemory( pClientID );

    return lpNewOption;
}



LPBYTE
DhcpAppendMagicCookie(
    LPBYTE Option,
    LPBYTE OptionEnd
    )
/*++

Routine Description:

    This routine appends magic cookie to a DHCP message.

Arguments:

    Option - A pointer to the place to append the magic cookie.

    OptionEnd - End of Option buffer.

Return Value:

    A pointer to the end of the appended cookie.

    Note : The magic cookie is :

     --------------------
    | 99 | 130 | 83 | 99 |
     --------------------

--*/
{
    DhcpAssert( (Option + 4) < (OptionEnd - 1) );
    if( (Option + 4) < (OptionEnd - 1) ) {
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE1;
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE2;
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE3;
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE4;
    }

    return( Option );
}



LPOPTION
DhcpAppendEnterpriseName(
    LPOPTION Option,
    PCHAR    DSEnterpriseName,
    LPBYTE   OptionEnd
    )
/*++

Routine Description:

    This routine appends the name of the enterprise as a MSFT-option to the
    DHCP message.

Arguments:

    Option - A pointer to the place to append the magic cookie.
    DSEnterpriseName - null-terminated string containing name of enterprise
    OptionEnd - End of Option buffer.

Return Value:

    A pointer to the end of the appended cookie.
--*/
{

    CHAR        Buffer[260];    // enough room?  should we malloc?
    DWORD       DSEnpriNameLen;
    LPOPTION    RetOpt;


    Buffer[0] = OPTION_MSFT_DSDOMAINNAME_RESP;

    if (DSEnterpriseName)
    {
        // how big is the enterprise name? (include the null terminator)
        DSEnpriNameLen = strlen(DSEnterpriseName) + 1;

        Buffer[1] = (BYTE)DSEnpriNameLen;

        strcpy(&Buffer[2],DSEnterpriseName);
    }

    //
    // if we are not part of any enterprise then DSEnterpriseName will be NULL
    // In that case, just return a null-string, so the receiver can positively
    // say we are a standalone server (as opposed to ignoring the option)
    //
    else
    {
        DSEnpriNameLen = 1;
        Buffer[1] = 1;
        Buffer[2] = '\0';
    }

    RetOpt = DhcpAppendOption(
                 Option,
                 OPTION_VENDOR_SPEC_INFO,
                 Buffer,
                 (BYTE)(DSEnpriNameLen + 2),  // include Buffer[0] and Buffer[1]
                 OptionEnd );

    return(RetOpt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\lib\dhcpdump.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpprt.c

Abstract:

    This module contains DHCP specific utility routines used by the
    DHCP components.

Author:

    Madan Appiah (madana) 16-Sep-1993

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <dhcpl.h>


#if DBG

VOID
DhcpDumpMessage(
    DWORD DhcpDebugFlag,
    LPDHCP_MESSAGE DhcpMessage,
    ULONG MessageSize
    )
/*++

Routine Description:

    This function dumps a DHCP packet in human readable form.

Arguments:

    DhcpDebugFlag - debug flag that indicates what we are debugging.

    DhcpMessage - A pointer to a DHCP message.

Return Value:

    None.

--*/
{
    LPOPTION option;
    BYTE i;

    DhcpPrint(( DhcpDebugFlag, "Dhcp message: \n\n"));

    DhcpPrint(( DhcpDebugFlag, "Operation              :"));
    if ( DhcpMessage->Operation == BOOT_REQUEST ) {
        DhcpPrint(( DhcpDebugFlag,  "BootRequest\n"));
    } else if ( DhcpMessage->Operation == BOOT_REPLY ) {
        DhcpPrint(( DhcpDebugFlag,  "BootReply\n"));
    } else {
        DhcpPrint(( DhcpDebugFlag,  "Unknown\n"));
    }

    DhcpPrint(( DhcpDebugFlag, "Hardware Address type  : %d\n", DhcpMessage->HardwareAddressType));
    DhcpPrint(( DhcpDebugFlag, "Hardware Address Length: %d\n", DhcpMessage->HardwareAddressLength));
    DhcpPrint(( DhcpDebugFlag, "Hop Count              : %d\n", DhcpMessage->HopCount ));
    DhcpPrint(( DhcpDebugFlag, "Transaction ID         : %lx\n", DhcpMessage->TransactionID ));
    DhcpPrint(( DhcpDebugFlag, "Seconds Since Boot     : %d\n", DhcpMessage->SecondsSinceBoot ));
    DhcpPrint(( DhcpDebugFlag, "Client IP Address      : " ));
    DhcpPrint(( DhcpDebugFlag, "%s\n",
        inet_ntoa(*(struct in_addr *)&DhcpMessage->ClientIpAddress ) ));

    DhcpPrint(( DhcpDebugFlag, "Your IP Address        : " ));
    DhcpPrint(( DhcpDebugFlag, "%s\n",
        inet_ntoa(*(struct in_addr *)&DhcpMessage->YourIpAddress ) ));

    DhcpPrint(( DhcpDebugFlag, "Server IP Address      : " ));
    DhcpPrint(( DhcpDebugFlag, "%s\n",
        inet_ntoa(*(struct in_addr *)&DhcpMessage->BootstrapServerAddress ) ));

    DhcpPrint(( DhcpDebugFlag, "Relay Agent IP Address : " ));
    DhcpPrint(( DhcpDebugFlag, "%s\n",
        inet_ntoa(*(struct in_addr *)&DhcpMessage->RelayAgentIpAddress ) ));

    DhcpPrint(( DhcpDebugFlag, "Hardware Address       : "));
    for ( i = 0; i < DhcpMessage->HardwareAddressLength; i++ ) {
        DhcpPrint(( DhcpDebugFlag, "%2.2x", DhcpMessage->HardwareAddress[i] ));
    }

    option = &DhcpMessage->Option;

    DhcpPrint(( DhcpDebugFlag, "\n\n"));
    DhcpPrint(( DhcpDebugFlag, "Magic Cookie: "));
    for ( i = 0; i < 4; i++ ) {
        DhcpPrint(( DhcpDebugFlag, "%d ", *((LPBYTE)option)++ ));
    }
    DhcpPrint(( DhcpDebugFlag, "\n\n"));

    DhcpPrint(( DhcpDebugFlag, "Options:\n"));
    while ( option->OptionType != 255 ) {
        DhcpPrint(( DhcpDebugFlag, "\tType = %d ", option->OptionType ));
        for ( i = 0; i < option->OptionLength; i++ ) {
            DhcpPrint(( DhcpDebugFlag, "%2.2x", option->OptionValue[i] ));
        }
        DhcpPrint(( DhcpDebugFlag, "\n"));

        if ( option->OptionType == OPTION_PAD ||
             option->OptionType == OPTION_END ) {

            option = (LPOPTION)( (LPBYTE)(option) + 1);

        } else {

            option = (LPOPTION)( (LPBYTE)(option) + option->OptionLength + 2);

        }

        if ( (ULONG)((LPBYTE)option - (LPBYTE)DhcpMessage) > MessageSize ) {
            DhcpPrint(( DhcpDebugFlag, "End of message, but no trailer found!\n"));
            break;
        }
    }
}

VOID
MadcapDumpMessage(
    DWORD DhcpDebugFlag,
    LPMADCAP_MESSAGE MadcapMessage,
    ULONG MessageSize
    )
/*++

Routine Description:

    This function dumps a DHCP packet in human readable form.

Arguments:

    DhcpDebugFlag - debug flag that indicates what we are debugging.

    MadcapMessage - A pointer to a DHCP message.

Return Value:

    None.

--*/
{
    WIDE_OPTION UNALIGNED*         NextOpt;
    BYTE        UNALIGNED*         EndOpt;
    DWORD                          Size;
    DWORD                          OptionType;
    BYTE i;

    DhcpPrint(( DhcpDebugFlag, "Madcap message: \n\n"));

    DhcpPrint(( DhcpDebugFlag, "Version                : %d\n",MadcapMessage->Version));
    DhcpPrint(( DhcpDebugFlag, "MessageType            : %d\n",MadcapMessage->MessageType));
    DhcpPrint(( DhcpDebugFlag, "AddressFamily          : %d\n",ntohs(MadcapMessage->AddressFamily)));
    DhcpPrint(( DhcpDebugFlag, "TransactionId          : %d\n",MadcapMessage->TransactionID));

    DhcpPrint(( DhcpDebugFlag, "\n\n"));
    DhcpPrint(( DhcpDebugFlag, "Options:\n"));
    // MBUG CHANGE 255 TO end option
    NextOpt = (WIDE_OPTION UNALIGNED*)&MadcapMessage->Option;
    EndOpt = (PBYTE)MadcapMessage + MessageSize;
    while( NextOpt->OptionValue <= EndOpt &&
           MADCAP_OPTION_END != (OptionType = ntohs(NextOpt->OptionType)) ) {

        Size = ntohs(NextOpt->OptionLength);
        if ((NextOpt->OptionValue + Size) > EndOpt) {
            break;
        }

        DhcpPrint(( DhcpDebugFlag, "\tType = %d ", OptionType ));
        for ( i = 0; i < Size; i++ ) {
            DhcpPrint(( DhcpDebugFlag, "%2.2x", NextOpt->OptionValue[i] ));
        }
        DhcpPrint(( DhcpDebugFlag, "\n"));

        NextOpt = (WIDE_OPTION UNALIGNED*)(NextOpt->OptionValue + Size);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\lib\network.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    network.c

Abstract:

    This module contains network specific utility routines used by the
    DHCP components.

Author:

    Manny Weiser (mannyw) 12-Aug-1992

Revision History:

--*/

#include "dhcpl.h"


DHCP_IP_ADDRESS
DhcpDefaultSubnetMask(
    DHCP_IP_ADDRESS IpAddress
    )
/*++

Routine Description:

    This function calculates the default subnet mask for a given IP
    address.

Arguments:

    IpAddress - The address for which a subnet mask is needed.

Return Value:

    The default subnet mask.
    -1, if the supplied IP address is invalid.

--*/
{
    if ( IN_CLASSA( IpAddress ) ) {
        return( IN_CLASSA_NET );
    } else if ( IN_CLASSB( IpAddress ) ) {
        return( IN_CLASSB_NET );
    } else if ( IN_CLASSC( IpAddress ) ) {
        return( IN_CLASSC_NET );
    } else {
        return( (DHCP_IP_ADDRESS)-1 );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\common\precomp.h ===
/*++

Copyright (C) 1999 Microsoft corporation

--*/

#define MAX_DLL_NAME    48

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>

#include <winsock2.h>
#include <ws2tcpip.h>

#include <dhcpapi.h>

#include <mdhcsapi.h>

#include <tchar.h>
#include <wchar.h>

#include <netsh.h>
#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\lib\convert.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    convert.c

Abstract:

    This module contains miscellaneous utility routines used by the
    DHCP server service.

Author:

    Manny Weiser (mannyw) 12-Aug-1992

Revision History:

    Madan Appiah (madana) 21-Oct-1992

--*/

#include "dhcpl.h"
#include <winnls.h>

LPWSTR
DhcpOemToUnicodeN(
    IN      LPSTR   Ansi,
    IN OUT  LPWSTR  Unicode,
    IN      USHORT  cChars
    )
{

    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitString( &AnsiString, Ansi );

    UnicodeString.MaximumLength =
        cChars * sizeof( WCHAR );

    if( Unicode == NULL ) {
        UnicodeString.Buffer =
            DhcpAllocateMemory( UnicodeString.MaximumLength );
    }
    else {
        UnicodeString.Buffer = Unicode;
    }

    if ( UnicodeString.Buffer == NULL ) {
        return NULL;
    }

    if(!NT_SUCCESS( RtlOemStringToUnicodeString( &UnicodeString,
                                                  &AnsiString,
                                                  FALSE))){
        if( Unicode == NULL ) {
            DhcpFreeMemory( UnicodeString.Buffer );
        }
        return NULL;
    }

    return UnicodeString.Buffer;

}



LPWSTR
DhcpOemToUnicode(
    IN      LPSTR Ansi,
    IN OUT  LPWSTR Unicode
    )
/*++

Routine Description:

    Convert an OEM (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Ansi - Specifies the ASCII zero terminated string to convert.

    Unicode - Specifies the pointer to the unicode buffer. If this
        pointer is NULL then this routine allocates buffer using
        DhcpAllocateMemory and returns. The caller should freeup this
        memory after use by calling DhcpFreeMemory.

Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer can be freed using DhcpFreeMemory.

--*/
{
    OEM_STRING  AnsiString;

    RtlInitString( &AnsiString, Ansi );

    return DhcpOemToUnicodeN(
                Ansi,
                Unicode,
                (USHORT) RtlOemStringToUnicodeSize( &AnsiString )
                );
}


ULONG
DhcpUnicodeToOemSize(
    IN LPWSTR Unicode
    )
/*++

Routine Description:

    This routine returns the number of bytes requried
    to store the OEM string equivalent of the provided
    UNICODE string.

Arguments:

    Unicode -- the input unicode string.

Return Values:

    0 -- if the string cannot be converted or is NULL
    number of bytes of storage required

--*/
{
    UNICODE_STRING UnicodeString;

    if( NULL == Unicode ) return 0;
    
    RtlInitUnicodeString( &UnicodeString, Unicode );
    return (USHORT) RtlUnicodeStringToOemSize( &UnicodeString );
}

    


LPSTR
DhcpUnicodeToOem(
    IN LPWSTR Unicode,
    IN LPSTR Ansi
    )

/*++

Routine Description:

    Convert an UNICODE (zero terminated) string to the corresponding OEM
    string.

Arguments:

    Ansi - Specifies the UNICODE zero terminated string to convert.

    Ansi - Specifies the pointer to the oem buffer. If this
        pointer is NULL then this routine allocates buffer using
        DhcpAllocateMemory and returns. The caller should freeup this
        memory after use by calling DhcpFreeMemory.

Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated OEM string in
    an allocated buffer.  The buffer can be freed using DhcpFreeMemory.

--*/

{
    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, Unicode );

    AnsiString.MaximumLength =
        (USHORT) RtlUnicodeStringToOemSize( &UnicodeString );

    if( Ansi == NULL ) {
        AnsiString.Buffer = DhcpAllocateMemory( AnsiString.MaximumLength
    ); }
    else {
        AnsiString.Buffer = Ansi;
    }

    if ( AnsiString.Buffer == NULL ) {
        return NULL;
    }

    if(!NT_SUCCESS( RtlUnicodeStringToOemString( &AnsiString,
                                                  &UnicodeString,
                                                  FALSE))){
        if( Ansi == NULL ) {
            DhcpFreeMemory( AnsiString.Buffer );
        }

        return NULL;
    }

    return AnsiString.Buffer;
}

DWORD
ConvertUnicodeToUTF8(
    LPWSTR  UnicodeString,
    DWORD   UnicodeLength,
    LPBYTE  UTF8String,
    DWORD   UTF8Length
    )
/*++

Routine Description:

    This functions converts Unicodestring into Utf8 format.
    The unicodestring must be NULL terminated.

Arguments:

    Unicodestring - Pointer to the unicodestring

    UnicodeLength - Length of above string, or pass -1 if the above string is
                    NULL terminated.

    UTF8String - Buffer to receive UTF8String. If this is null then the function
                    returns the # of bytes needed for this buffer for conversion.

    UTF8Length - Length of the above buffer. if this is 0, the function
                will return the required length.

Return Value:

    No. of bytes converted.

--*/
{
    DWORD   Result;
    Result = WideCharToMultiByte(
                CP_UTF8,
                0,
                UnicodeString,
                UnicodeLength,
                UTF8String,
                UTF8Length,
                NULL,
                NULL
                );
    if (Result == 0 ) {
        DhcpPrint((0, "WideCharToMultiByte returned %ld\n", GetLastError()));
        DhcpAssert(0);
    }
    return Result;
}

DWORD
ConvertUTF8ToUnicode(
    LPBYTE  UTF8String,
    DWORD   UTF8Length,
    LPWSTR  UnicodeString,
    DWORD   UnicodeLength
    )
/*++

Routine Description:

    This functions converts Unicodestring into Utf8 format.
    The unicodestring must be NULL terminated.

Arguments:

    UTF8String - Buffer to UTFString.

    UTF8Length - Length of above buffer ; or pass -1 if the above string is NULL terminated.

    Unicodestring - Pointer to the buffer receiving unicodestring.

    UnicodeLength - Length of the above buffer. if this is 0, the function
                will return the required length.

Return Value:

    No. of bytes converted.

--*/
{
    DWORD Result;
    Result = MultiByteToWideChar(
                CP_UTF8,
                0,
                UTF8String,
                UTF8Length,
                UnicodeString,
                UnicodeLength
                );
    if (Result == 0 ) {
        DhcpPrint((0, "MultiByteToWideChar returned %ld\n", GetLastError()));
        DhcpAssert(0);
    }
    return Result;

}



VOID
DhcpHexToString(
    LPWSTR Buffer,
    LPBYTE HexNumber,
    DWORD Length
    )
/*++

Routine Description:

    This functions converts are arbitrary length hex number to a Unicode
    string.  The string is not NULL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least Length * 2 characters in size.

    HexNumber - The hex number to convert.

    Length - The length of HexNumber, in bytes.


Return Value:

    None.

--*/
{
    DWORD i;
    int j;

    for (i = 0; i < Length * 2; i+=2 ) {

        j = *HexNumber & 0xF;
        if ( j <= 9 ) {
            Buffer[i+1] = j + L'0';
        } else {
            Buffer[i+1] = j + L'A' - 10;
        }

        j = *HexNumber >> 4;
        if ( j <= 9 ) {
            Buffer[i] = j + L'0';
        } else {
            Buffer[i] = j + L'A' - 10;
        }

        HexNumber++;
    }

    return;
}



VOID
DhcpHexToAscii(
    LPSTR Buffer,
    LPBYTE HexNumber,
    DWORD Length
    )
/*++

Routine Description:

    This functions converts are arbitrary length hex number to an ASCII
    string.  The string is not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least Length * 2 characters in size.

    HexNumber - The hex number to convert.

    Length - The length of HexNumber, in bytes.

Return Value:

    None.

--*/
{
    DWORD i;
    int j;

    for (i = 0; i < Length; i+=1 ) {

        j = *HexNumber & 0xF;
        if ( j <= 9 ) {
            Buffer[i+1] = j + '0';
        } else {
            Buffer[i+1] = j + 'A' - 10;
        }

        j = *HexNumber >> 4;
        if ( j <= 9 ) {
            Buffer[i] = j + '0';
        } else {
            Buffer[i] = j + 'A' - 10;
        }

        HexNumber++;
    }

    return;
}



VOID
DhcpDecimalToString(
    LPWSTR Buffer,
    BYTE Number
    )
/*++

Routine Description:

    This functions converts a single byte decimal digit to a 3 character
    Unicode string.  The string not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least 3 characters in size.

    Number - The number to convert.

Return Value:

    None.

--*/
{
    Buffer[2] = Number % 10 + L'0';
    Number /= 10;

    Buffer[1] = Number % 10 + L'0';
    Number /= 10;

    Buffer[0] = Number + L'0';

    return;
}



DWORD
DhcpDottedStringToIpAddress(
    LPSTR String
    )
/*++

Routine Description:

    This functions converts a dotted decimal form ASCII string to a
    Host order IP address.

Arguments:

    String - The address to convert.

Return Value:

    The corresponding IP address.

--*/
{
    struct in_addr addr;

    addr.s_addr = inet_addr( String );
    return( ntohl(*(LPDWORD)&addr) );
}



LPSTR
DhcpIpAddressToDottedString(
    DWORD IpAddress
    )
/*++

Routine Description:

    This functions converts a Host order IP address to a dotted decimal
    form ASCII string.

Arguments:

    IpAddress - Host order IP Address.

Return Value:

    String for IP Address.

--*/
{
    DWORD NetworkOrderIpAddress;

    NetworkOrderIpAddress = htonl(IpAddress);
    return(inet_ntoa( *(struct in_addr *)&NetworkOrderIpAddress));
}



DWORD
DhcpStringToHwAddress(
    LPSTR AddressBuffer,
    LPSTR AddressString
    )
/*++

Routine Description:

    This functions converts an ASCII string to a hex number.

Arguments:

    AddressBuffer - A pointer to a buffer which will contain the hex number.

    AddressString - The string to convert.

Return Value:

    The number of bytes written to AddressBuffer.

--*/
{
    int i = 0;
    char c1, c2;
    int value1, value2;

    while ( *AddressString != 0) {

        c1 = (char)toupper(*AddressString);

        if ( isdigit(c1) ) {
            value1 = c1 - '0';
        } else if ( c1 >= 'A' && c1 <= 'F' ) {
            value1 = c1 - 'A' + 10;
        }
        else {
            break;
        }

        c2 = (char)toupper(*(AddressString+1));

        if ( isdigit(c2) ) {
            value2 = c2 - '0';
        } else if ( c2 >= 'A' && c2 <= 'F' ) {
            value2 = c2 - 'A' + 10;
        }
        else {
            break;
        }

        AddressBuffer [i] = value1 * 16 + value2;
        AddressString += 2;
        i++;
    }

    return( i );
}


#if 0



DHCP_IP_ADDRESS
DhcpHostOrder(
    DHCP_IP_ADDRESS NetworkOrderAddress
    )
/*++

Routine Description:

    This functions converts a network order IP address to host order.

Arguments:

    NetworkOrderAddress - A network order IP address.

Return Value:

    The host order IP address.

--*/
{
    return( ntohl( NetworkOrderAddress ) );
}



DHCP_IP_ADDRESS
DhcpNetworkOrder(
    DHCP_IP_ADDRESS HostOrderAddress
    )
/*++

Routine Description:

    This functions converts a network order IP address to host order.

Arguments:

    HostOrderAddress - A host order IP address.

Return Value:

    The network order IP address.

--*/
{
    return( htonl( HostOrderAddress ) );
}



VOID
DhcpIpAddressToString(
    LPWSTR Buffer,
    DWORD IpAddress
    )
/*++

Routine Description:

    This function converts an IP address from host order ASCII form.

Arguments:

    Buffer - Points to a buffer to the receive the ASCII form.  The
        buffer must be at least 8 WCHARs long.

    IpAddress - The IP address to convert.

Return Value:

    Nothing.

--*/
{
    int i;
    int j;

    for (i = 7; i >= 0; i-- ) {
        j = IpAddress & 0xF;
        if ( j <= 9 ) {
            Buffer[i] = j + L'0';
        } else {
            Buffer[i] = j + L'A' - 10;
        }

        IpAddress >>=4;
    }

    return;
}




VOID
DhcpStringToIpAddress(
    LPSTR Buffer,
    LPDHCP_IP_ADDRESS IpAddress,
    BOOL NetOrder
    )
/*++

Routine Description:

    This function converts an ASCII string IP Address to binary format.

Arguments:

    Buffer - Pointer to buffer containing the IP address.

    IpAddress - Points to a buffer to contain the binary format IP address.

    NetOrder - If TRUE, the address is converted to a network order address.
               If FALSE, the address is converted to a host order address.

Return Value:

    None.

--*/
{
    DWORD value;

    value = strtol( Buffer, NULL, 16 );

    if ( NetOrder ) {
        *IpAddress = htonl( value );
    } else {
        *IpAddress = value;
    }

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\common\common.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    common.c

Abstract:

    This module contains miscellaneous utility routines used by the
    DHCP server service. Code is hacked from convert.c

Author:

    Shubho Bhattacharya (a-sbhatt) 11/17/98

Revision History:

   

--*/

#include <precomp.h>
#include <svcguid.h>
#include <iphlpapi.h>

PVOID
DhcpAllocateMemory(
    DWORD Size
    )
/*++

Routine Description:

    This function allocates the required size of memory by calling
    LocalAlloc.

Arguments:

    Size - size of the memory block required.

Return Value:

    Pointer to the allocated block.

--*/
{

    return calloc(1, Size);
}

#undef DhcpFreeMemory

VOID
DhcpFreeMemory(
    PVOID Memory
    )
/*++

Routine Description:

    This function frees up the memory that was allocated by
    DhcpAllocateMemory.

Arguments:

    Memory - pointer to the memory block that needs to be freed up.

Return Value:

    none.

--*/
{

    LPVOID Ptr;

    ASSERT( Memory != NULL );
    free( Memory );
}


LPWSTR
DhcpOemToUnicodeN(
    IN      LPCSTR  Ansi,
    IN OUT  LPWSTR  Unicode,
    IN      USHORT  cChars
    )
{

    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitString( &AnsiString, Ansi );

    UnicodeString.MaximumLength =
        cChars * sizeof( WCHAR );

    if( Unicode == NULL ) {
        UnicodeString.Buffer =
            DhcpAllocateMemory( UnicodeString.MaximumLength );
    }
    else {
        UnicodeString.Buffer = Unicode;
    }

    if ( UnicodeString.Buffer == NULL ) {
        return NULL;
    }

    if(!NT_SUCCESS( RtlOemStringToUnicodeString( &UnicodeString,
                                                  &AnsiString,
                                                  FALSE))){
        if( Unicode == NULL ) {
            DhcpFreeMemory( UnicodeString.Buffer );
            UnicodeString.Buffer = NULL;
        }
        return NULL;
    }

    return UnicodeString.Buffer;
}



LPWSTR
DhcpOemToUnicode(
    IN      LPCSTR Ansi,
    IN OUT  LPWSTR Unicode
    )
{
    OEM_STRING  AnsiString;

    RtlInitString( &AnsiString, Ansi );

    return DhcpOemToUnicodeN(
                Ansi,
                Unicode,
                (USHORT) RtlOemStringToUnicodeSize( &AnsiString )
                );
}

/*++

Routine Description:

    Convert an OEM (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Ansi - Specifies the ASCII zero terminated string to convert.

    Unicode - Specifies the pointer to the unicode buffer. If this
        pointer is NULL then this routine allocates buffer using
        DhcpAllocateMemory and returns. The caller should freeup this
        memory after use by calling DhcpFreeMemory.

Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer can be freed using DhcpFreeMemory.

--*/



LPSTR
DhcpUnicodeToOem(
    IN  LPCWSTR Unicode,
    OUT LPSTR   Ansi
    )

/*++

Routine Description:

    Convert an UNICODE (zero terminated) string to the corresponding OEM
    string.

Arguments:

    Ansi - Specifies the UNICODE zero terminated string to convert.

    Ansi - Specifies the pointer to the oem buffer. If this
        pointer is NULL then this routine allocates buffer using
        DhcpAllocateMemory and returns. The caller should freeup this
        memory after use by calling DhcpFreeMemory.

Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated OEM string in
    an allocated buffer.  The buffer can be freed using DhcpFreeMemory.

--*/

{

    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, Unicode );

    AnsiString.MaximumLength =
        (USHORT) RtlUnicodeStringToOemSize( &UnicodeString );

    if( Ansi == NULL ) {
        AnsiString.Buffer = DhcpAllocateMemory( AnsiString.MaximumLength
    ); }
    else {
        AnsiString.Buffer = Ansi;
    }

    if ( AnsiString.Buffer == NULL ) {
        return NULL;
    }

    if(!NT_SUCCESS( RtlUnicodeStringToOemString( &AnsiString,
                                                  &UnicodeString,
                                                  FALSE))){
        if( Ansi == NULL ) {
            DhcpFreeMemory( AnsiString.Buffer );
            AnsiString.Buffer = NULL;
        }

        return NULL;
    }

    return AnsiString.Buffer;
}



VOID
DhcpHexToString(
    OUT LPWSTR  Buffer,
    IN  const BYTE * HexNumber,
    IN  DWORD Length
    )
/*++

Routine Description:

    This functions converts are arbitrary length hex number to a Unicode
    string.  The string is not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least Length * 2 characters in size.

    HexNumber - The hex number to convert.

    Length - The length of HexNumber, in bytes.


Return Value:

    None.

--*/
{
    DWORD i;
    int j;

    for (i = 0; i < Length * 2; i+=2 ) {

        j = *HexNumber & 0xF;
        if ( j <= 9 ) {
            Buffer[i+1] = j + L'0';
        } else {
            Buffer[i+1] = j + L'A' - 10;
        }

        j = *HexNumber >> 4;
        if ( j <= 9 ) {
            Buffer[i] = j + L'0';
        } else {
            Buffer[i] = j + L'A' - 10;
        }

        HexNumber++;
    }

    return;
}



VOID
DhcpHexToAscii(
    OUT LPSTR Buffer,
    IN  LPBYTE HexNumber,
    IN  DWORD Length
    )
/*++

Routine Description:

    This functions converts are arbitrary length hex number to an ASCII
    string.  The string is not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least Length * 2 characters in size.

    HexNumber - The hex number to convert.

    Length - The length of HexNumber, in bytes.

Return Value:

    None.

--*/
{
    DWORD i;
    int j;

    for (i = 0; i < Length; i+=1 ) {

        j = *HexNumber & 0xF;
        if ( j <= 9 ) {
            Buffer[i+1] = j + '0';
        } else {
            Buffer[i+1] = j + 'A' - 10;
        }

        j = *HexNumber >> 4;
        if ( j <= 9 ) {
            Buffer[i] = j + '0';
        } else {
            Buffer[i] = j + 'A' - 10;
        }

        HexNumber++;
    }

    return;
}



VOID
DhcpDecimalToString(
    OUT LPWSTR Buffer,
    IN  BYTE Number
    )
/*++

Routine Description:

    This functions converts a single byte decimal digit to a 3 character
    Unicode string.  The string not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least 3 characters in size.

    Number - The number to convert.

Return Value:

    None.

--*/
{
    Buffer[2] = Number % 10 + L'0';
    Number /= 10;

    Buffer[1] = Number % 10 + L'0';
    Number /= 10;

    Buffer[0] = Number + L'0';

    return;
}



DWORD
DhcpDottedStringToIpAddress(
    LPSTR String
    )
/*++

Routine Description:

    This functions converts a dotted decimal form ASCII string to a
    Host order IP address.

Arguments:

    String - The address to convert.

Return Value:

    The corresponding IP address.

--*/
{
    struct in_addr addr;

    addr.s_addr = inet_addr( String );
    return( ntohl(*(LPDWORD)&addr) );
}



LPSTR
DhcpIpAddressToDottedString(
    IN DWORD IpAddress
    )
/*++

Routine Description:

    This functions converts a Host order IP address to a dotted decimal
    form ASCII string.

Arguments:

    IpAddress - Host order IP Address.

Return Value:

    String for IP Address.

--*/
{
    DWORD NetworkOrderIpAddress;

    NetworkOrderIpAddress = htonl(IpAddress);
    return(inet_ntoa( *(struct in_addr *)&NetworkOrderIpAddress));
}



DWORD
DhcpStringToHwAddress(
    OUT LPSTR  AddressBuffer,
    IN  LPCSTR AddressString
    )
/*++

Routine Description:

    This functions converts an ASCII string to a hex number.

Arguments:

    AddressBuffer - A pointer to a buffer which will contain the hex number.

    AddressString - The string to convert.

Return Value:

    The number of bytes written to AddressBuffer.

--*/
{
    int i = 0;
    char c1, c2;
    int value1, value2;

    while ( *AddressString != 0) {

        c1 = (char)toupper(*AddressString);

        if ( isdigit(c1) ) {
            value1 = c1 - '0';
        } else if ( c1 >= 'A' && c1 <= 'F' ) {
            value1 = c1 - 'A' + 10;
        }
        else {
            break;
        }

        c2 = (char)toupper(*(AddressString+1));

        if ( isdigit(c2) ) {
            value2 = c2 - '0';
        } else if ( c2 >= 'A' && c2 <= 'F' ) {
            value2 = c2 - 'A' + 10;
        }
        else {
            break;
        }

        AddressBuffer [i] = value1 * 16 + value2;
        AddressString += 2;
        i++;
    }

    return( i );
}

#if DBG

VOID
DhcpAssertFailed(
    IN LPCSTR FailedAssertion,
    IN LPCSTR FileName,
    IN DWORD LineNumber,
    IN LPSTR Message
    )
/*++

Routine Description:

    Assertion failed.

Arguments:

    FailedAssertion :

    FileName :

    LineNumber :

    Message :

Return Value:

    none.

--*/
{
#ifndef DHCP_NOASSERT
    RtlAssert(
            (PVOID)FailedAssertion,
            (PVOID)FileName,
            (ULONG) LineNumber,
            (PCHAR) Message);
#endif

    DhcpPrint(( 0, "Assert @ %s \n", FailedAssertion ));
    DhcpPrint(( 0, "Assert Filename, %s \n", FileName ));
    DhcpPrint(( 0, "Line Num. = %ld.\n", LineNumber ));
    DhcpPrint(( 0, "Message is %s\n", Message ));

}

VOID
DhcpPrintRoutine(
    IN DWORD  DebugFlag,
    IN LPCSTR Format,
    ...
)

{

#define WSTRSIZE( wsz ) ( ( wcslen( wsz ) + 1 ) * sizeof( WCHAR ) )

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length = 0;

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    va_end(arglist);

#if DBG
    DhcpAssert(length <= MAX_PRINTF_LEN);
#endif //DBG


    //
    // Output to the debug terminal,
    //

    DbgPrint( "%s", OutputBuffer);
}

#endif // DBG

DWORD
CreateDumpFile(
    IN  PWCHAR  pwszName,
    OUT PHANDLE phFile
    )
{
    HANDLE  hFile;

    *phFile = NULL;

    hFile = CreateFileW(pwszName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if(hFile == INVALID_HANDLE_VALUE)
        return GetLastError();

    *phFile = hFile;

    return NO_ERROR;
}

VOID
CloseDumpFile(
    IN HANDLE  hFile
)
{
    if( hFile )
        CloseHandle(hFile);
}





DWORD
DhcpDottedStringToIpAddressW(
    IN LPCWSTR pwszString
)
{
    DWORD dwStrlen = 0;
    DWORD dwLen = 0;
    DWORD dwRes = 0;
    LPSTR pszString = NULL;
    if( pwszString == NULL )
        return dwRes;

    pszString = DhcpUnicodeToOem(pwszString, NULL);
    if( pszString )
    {
        dwRes = DhcpDottedStringToIpAddress(pszString);
    }
    
    return dwRes;
}


LPWSTR
DhcpIpAddressToDottedStringW(
    IN DWORD   IpAddress
)
{
    DWORD dwStrlen = 0;
    DWORD dwLen = 0;
    DWORD dwRes = 0;
    LPWSTR pwszString = NULL;
    LPSTR  pszString = NULL;
    
    pszString = DhcpIpAddressToDottedString(IpAddress);

    pwszString = DhcpOemToUnicode(pszString, NULL);

    return pwszString;
}

BOOL
IsIpAddress(
    IN LPCWSTR pwszAddress
)
{
    LPSTR pszAdd = NULL;
    LPSTR pszTemp = NULL;

    if( IsBadStringPtr(pwszAddress, MAX_IP_STRING_LEN+1) is TRUE )
         return FALSE;
    if( wcslen(pwszAddress) < 3 )
        return FALSE;
    
    pszAdd = DhcpUnicodeToOem(pwszAddress, NULL);

    pszTemp = strtok(pszAdd, ".");
    while(pszTemp isnot NULL )
    {
        DWORD i=0;
      
        for(i=0; i<strlen(pszTemp); i++)
        {
            if( tolower(pszTemp[i]) < L'0' or
                tolower(pszTemp[i]) > L'9' )
            return FALSE;
        }

        if( atol(pszTemp) < 0 or
            atol(pszTemp) > 255 )
        {
            return FALSE;
        }
        pszTemp = strtok(NULL, ".");
    }


    if( INADDR_NONE is inet_addr(pszAdd) )
    {
        DhcpFreeMemory(pszAdd);
        pszAdd = NULL;
        return FALSE;
    }
    else
    {
        DhcpFreeMemory(pszAdd);
        pszAdd = NULL;
        return TRUE;
    }
}

BOOL
IsValidScope(
    IN LPCWSTR pwszServer,
    IN LPCWSTR pwszAddress
)
{
    if( ( pwszServer is NULL ) or ( pwszAddress is NULL ) )
        return FALSE;

    if( IsIpAddress(pwszAddress) )
    {
        LPDHCP_SUBNET_INFO SubnetInfo = NULL;
        DHCP_IP_ADDRESS    IpAddress = StringToIpAddress(pwszAddress);
        DWORD              dwError = NO_ERROR;
        
        dwError = DhcpGetSubnetInfo((LPWSTR)pwszServer,
                                    IpAddress,
                                    &SubnetInfo);
        if(dwError is NO_ERROR )
        {
            DWORD SubnetAddress = SubnetInfo->SubnetAddress;
            DhcpRpcFreeMemory(SubnetInfo);
            return (IpAddress == SubnetAddress);
        }
        else
            return FALSE;

    }
    return FALSE;
}

BOOL
IsValidMScope(
    IN LPCWSTR   pwszServer,
    IN LPCWSTR   pwszMScope
)
{
    DWORD   Error = NO_ERROR;
    LPDHCP_MSCOPE_INFO  MScopeInfo = NULL;

    if( ( pwszMScope is NULL ) or ( pwszServer is NULL ) )
        return FALSE;
    
    Error = DhcpGetMScopeInfo( (LPWSTR)pwszServer,
                               (LPWSTR)pwszMScope,
                               &MScopeInfo);
    
    if( Error isnot NO_ERROR )
        return FALSE;

    DhcpRpcFreeMemory(MScopeInfo);
    return TRUE;
}

BOOL
IsValidServer(
   IN LPCWSTR pwszServer
)
{
    PHOSTENT pHost;

    if ( NULL == pwszServer ) {
        return FALSE;
    }

    // ignore leading backslashes
    if (( pwszServer[ 0 ] == L'\\' ) &&
        ( pwszServer[ 1 ] == L'\\' )) {
        pHost = UnicodeGetHostByName( &pwszServer[ 2 ], NULL );
    }
    else if ( IsIpAddress( pwszServer )) {
        pHost = UnicodeGetHostByName( pwszServer, NULL );
    }
    else {
	return FALSE;
    }

    if ( NULL == pHost ) {
        return FALSE;
    }

    LocalFree( pHost );
    return TRUE;
} // IsValidServer()

BOOL
IsLocalServer(IN LPCWSTR pwszServer)
{
    BOOL             fReturn;
    PHOSTENT         pHostEnt;
    PMIB_IPADDRTABLE pIpAddr = NULL;
    DWORD            Error, i, j;
    ULONG            Size = 0, Ip;

    fReturn = FALSE;
    do {
        // Obtain the addressess of the provided server
        pHostEnt = UnicodeGetHostByName( pwszServer, NULL );
        if ( pHostEnt == NULL ) {
            break;
        }

        // Get the IP addresses of the local host
        Error = GetIpAddrTable( NULL, &Size, FALSE );
        ASSERT( ERROR_INSUFFICIENT_BUFFER == Error );
        pIpAddr = DhcpAllocateMemory( Size );
        if ( NULL == pIpAddr ) {
            break;
        }

        Error = GetIpAddrTable( pIpAddr, &Size, FALSE );
        ASSERT( ERROR_SUCCESS == Error );
        if ( ERROR_SUCCESS != Error ) {
            break;
        }

        // Scan through both tables and see if any matches
        for ( i = 0; i < pIpAddr->dwNumEntries; i++ ) {

            for ( j = 0; 0 != pHostEnt->h_addr_list[ j ]; j++ ) {
                Ip = *(( u_long * )( pHostEnt->h_addr_list )[ j ]);
                if ( pIpAddr->table[ i ].dwAddr == Ip ) {
                    fReturn = TRUE;
                    break;
                }

            } // for host entries


            if ( fReturn ) {
                break;
            }
        } // for IP addr table

    } while ( FALSE );

    LocalFree( pHostEnt );
    DhcpFreeMemory( pIpAddr );

    return fReturn;
} // IsLocalServer()

BOOL
IsPureNumeric(IN LPCWSTR  pwszStr)
{
    DWORD   dwLen = 0,
            i;

    if( pwszStr is NULL )
        return FALSE;

    dwLen = wcslen(pwszStr);

    for(i=0; i<dwLen; i++ )
    {
        if( pwszStr[i] >= L'0' and
            pwszStr[i] <= L'9' )
        {
            continue;
        }
        else
            return FALSE;
            
    }
    return TRUE;
}

#define CHARTONUM(chr) (isalpha(chr)?(tolower(chr)-'a')+10:chr-'0')

WCHAR  StringToHex(IN LPCWSTR pwcString)
{
    LPSTR   pcInput = NULL;
    LPWSTR  pwcOut = NULL;
    int     i = 0,
            len = 0;
    UCHAR   tmp[2048] = {L'\0'};


    pcInput = DhcpUnicodeToOem(pwcString, NULL);
    
    if(pcInput is NULL )
        return (WCHAR)0x00;

    len = strlen(pcInput);

    for (i=0;i<(len-1);i+=2)
    {
        UCHAR hi=CHARTONUM(pcInput[i])*16;
        UCHAR lo=CHARTONUM(pcInput[i+1]);
        tmp[(i)/2]=hi+lo;
    }

    //
    // The last byte...
    //
    if (i<len)
    {
        tmp[(i)/2]=CHARTONUM(pcInput[i]);
        i+=2;
    }
    
    pwcOut = DhcpOemToUnicode(tmp, NULL);

    if( pwcOut is NULL )
        return (WCHAR)0x00;

    return pwcOut[0];

}

LPSTR
StringToHexString(IN LPCSTR pszInput)
{
    int     i = 0,
            len = 0;
    
    LPSTR   pcOutput = NULL;


    if(pszInput is NULL )
    {
        return NULL;
    }

   

    len = strlen(pszInput);

    pcOutput = DhcpAllocateMemory(len);

    if( pcOutput is NULL )
    {
        return NULL;
    }

    for (i=0;i<(len-1);i+=2)
    {
        UCHAR hi=CHARTONUM(pszInput[i])*16;
        UCHAR lo=CHARTONUM(pszInput[i+1]);
        pcOutput[(i)/2]=hi+lo;
    }

    //
    // The last byte...
    //
    if (i<len)
    {
        pcOutput[(i)/2]=CHARTONUM(pszInput[i]);
        i+=2;
    }

    return pcOutput;

}

BOOL
IsPureHex(
    IN LPCWSTR pwszString
)
{
    DWORD dw = 0,
          i = 0;

    BOOL  fResult = TRUE;

    if( pwszString is NULL )
        return FALSE;

    dw = wcslen(pwszString);

    if( 0 == dw ) {
        return FALSE;
    }

    for( i=0; i<dw; i++ )
    {
        WCHAR wc = pwszString[i];
        
        if( iswxdigit(wc) )
        {
            continue;
        }
        else
        {
            fResult = FALSE;
            break;
        }            
    }
    return fResult;

}

DATE_TIME
DhcpCalculateTime(
    IN DWORD RelativeTime
    )
/*++

Routine Description:

    The function calculates the absolute time of a time RelativeTime
    seconds from now.

Arguments:

    RelativeTime - Relative time, in seconds.

Return Value:

    The time in RelativeTime seconds from the current system time.

--*/
{
    SYSTEMTIME systemTime;
    ULONGLONG absoluteTime;

    if( RelativeTime == INFINIT_LEASE ) {
        ((DATE_TIME *)&absoluteTime)->dwLowDateTime =
            DHCP_DATE_TIME_INFINIT_LOW;
        ((DATE_TIME *)&absoluteTime)->dwHighDateTime =
            DHCP_DATE_TIME_INFINIT_HIGH;
    }
    else {

        GetSystemTime( &systemTime );
        SystemTimeToFileTime(
            &systemTime,
            (FILETIME *)&absoluteTime );

        absoluteTime = absoluteTime + RelativeTime * (ULONGLONG)10000000; }

    return( *(DATE_TIME *)&absoluteTime );
}

PBYTE
GetLangTagA(
    )
{
    char b1[8], b2[8];
    static char buff[80];

    GetLocaleInfoA(LOCALE_SYSTEM_DEFAULT, LOCALE_SISO639LANGNAME, b1, sizeof(b1));

    GetLocaleInfoA(LOCALE_SYSTEM_DEFAULT, LOCALE_SISO3166CTRYNAME, b2, sizeof(b2));

    if (_stricmp(b1, b2))
        sprintf(buff, "%s-%s", b1, b2);
    else
        strcpy(buff, b1);

    return buff;
}


LPWSTR
MakeDayTimeString(
               IN DWORD dwTime
)
{
    LPWSTR  pwszTime = NULL;
    WCHAR   wcDay[4] = {L'\0'},
            wcHr[3] = {L'\0'},
            wcMt[3] = {L'\0'};
    DWORD   dwDay = 0,
            dwHr = 0,
            dwMt = 0,
            dw = 0;

    pwszTime = malloc(10*sizeof(WCHAR));
    

    if( pwszTime )
    {
        for( dw=0; dw < 10; dw++ )
            pwszTime[dw] = L'0';


        pwszTime[3] = L':';
        pwszTime[6] = L':';
        pwszTime[9] = L'\0';

        dwDay = dwTime/(24*60*60);
        dwTime = dwTime - dwDay*24*60*60;

        dwHr = dwTime/(60*60);
        dwTime = dwTime - dwHr*60*60;

        dwMt = dwTime/60;
        dwTime = dwTime - dwMt*60;

        _itow(dwDay, wcDay,10);
        _itow(dwHr, wcHr, 10);
        _itow(dwMt, wcMt, 10);

        if( dwDay isnot 0 )
        {
            wcsncpy(pwszTime+3-wcslen(wcDay), wcDay, wcslen(wcDay));
        }

        if( dwHr isnot 0 )
        {
            wcsncpy(pwszTime+6-wcslen(wcHr), wcHr, wcslen(wcHr));
        }

        if( dwMt isnot 0 )
        {
            wcsncpy(pwszTime+9-wcslen(wcMt), wcMt, wcslen(wcMt));
        }
    }
    return pwszTime;
}

DWORD
GetDateTimeInfo(IN     LCTYPE          lcType,
                IN     LPSYSTEMTIME    lpSystemTime,
                OUT    LPWSTR          pwszBuffer,
                IN OUT DWORD           *pdwBufferLen)
{
    DWORD   dwError = NO_ERROR;
    BOOL    fQueryLen = FALSE;
    int     cchFormat = 0,
            cchData = 0;
    
    PVOID   pfnPtr = NULL;
    DWORD   dwBuff = 0,
            dwInputBuff = 0;


    LPWSTR  pwszFormat = NULL,
            pwszData = NULL;


    if( pdwBufferLen is NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwInputBuff = *pdwBufferLen;
    *pdwBufferLen = 0;

    if( pwszBuffer is NULL or
        dwInputBuff is 0 )
    {
        fQueryLen = TRUE;
    }

    cchFormat = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT,
                            lcType,
                            NULL,
                            0);

    if( cchFormat is 0 )
    {
        dwError = GetLastError();
        goto RETURN;
    }

    pwszFormat = DhcpAllocateMemory(cchFormat*sizeof(WCHAR));
    if( pwszFormat is NULL )
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto RETURN;
    }

    cchFormat = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT,
                              lcType,
                              pwszFormat,
                              cchFormat);

    if( cchFormat is 0 )
    {
        dwError = GetLastError();
        goto RETURN;
    }
    
    if( lcType isnot LOCALE_STIMEFORMAT )
    {
        cchData = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                0,
                                lpSystemTime,
                                pwszFormat,
                                NULL,
                                0);

        if( cchData is 0 )
        {
            dwError = GetLastError();
            goto RETURN;
        }
    
        if( fQueryLen is FALSE )
        {    
            if( cchData > (int)dwInputBuff )
            {
                dwError = ERROR_INSUFFICIENT_BUFFER;
                goto RETURN;
            }

            cchData = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                    0,
                                    lpSystemTime,
                                    pwszFormat,
                                    pwszBuffer,
                                    (int)dwInputBuff);

            if( cchData is 0 )
            {
                dwError = GetLastError();
                goto RETURN;
            }   
        }
    }
    else
    {
        cchData = GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
                                0,
                                lpSystemTime,
                                pwszFormat,
                                NULL,
                                0);

        if( cchData is 0 )
        {
            dwError = GetLastError();
            goto RETURN;
        }
    
        if( fQueryLen is FALSE )
        {    
            if( cchData > (int)dwInputBuff )
            {
                dwError = ERROR_INSUFFICIENT_BUFFER;
                goto RETURN;
            }

            cchData = GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
                                    0,
                                    lpSystemTime,
                                    pwszFormat,
                                    pwszBuffer,
                                    (int)dwInputBuff);

            if( cchData is 0 )
            {
                dwError = GetLastError();
                goto RETURN;
            }   
        }
    }

    dwBuff += cchData;
    *pdwBufferLen = dwBuff;

RETURN:
    if( pwszFormat )
    {
        DhcpFreeMemory(pwszFormat);
        pwszFormat = NULL;
    }
    return dwError;

}

DWORD
FormatDateTimeString( IN  FILETIME ftTime,
                      IN  BOOL    fShort,
                      OUT LPWSTR  pwszBuffer,
                      OUT DWORD  *pdwBuffLen)
{
    BOOL        fQueryLen = FALSE;
    DWORD       dwError = NO_ERROR,
                dwBufferLen = 0;
    DWORD       dwBuff = 0,
                dwInputBuff = 0;
    FILETIME    ftLocalTime = {0};
    SYSTEMTIME  stTime = {0};

    if( pdwBuffLen is NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    dwInputBuff = *pdwBuffLen;

    if( pwszBuffer is NULL or
        dwInputBuff is 0 )
    {
        fQueryLen = TRUE;
    }
    

    if( !FileTimeToLocalFileTime(&ftTime, &ftLocalTime) )
    {
        dwError = GetLastError();
        goto RETURN;
    }

    if( !FileTimeToSystemTime(&ftLocalTime, &stTime) )
    {
        dwError = GetLastError();
        goto RETURN;
    }
    
    if( fQueryLen is TRUE )
    {
        dwError = GetDateTimeInfo(fShort ? LOCALE_SSHORTDATE : LOCALE_SLONGDATE,
                                  &stTime,
                                  NULL,
                                  &dwBuff);

        if( dwError isnot NO_ERROR )
            goto RETURN;

    }
    else
    {
        dwBuff = dwInputBuff;
        dwError = GetDateTimeInfo(fShort ? LOCALE_SSHORTDATE : LOCALE_SLONGDATE,
                                  &stTime,
                                  pwszBuffer,
                                  &dwBuff);
    }

    dwBufferLen += dwBuff;

    //Increment to add a space between date and time
    dwBufferLen ++;

    if( fQueryLen is TRUE )
    {
        dwBuff = 0;
        dwError = GetDateTimeInfo(LOCALE_STIMEFORMAT,
                                  &stTime,
                                  NULL,
                                  &dwBuff);
        if( dwError isnot NO_ERROR )
            goto RETURN;
    }
    else
    {
        if( dwBufferLen > dwInputBuff )
        {
            dwError = ERROR_INSUFFICIENT_BUFFER;
            goto RETURN;
        }

        wcscat( pwszBuffer, L" ");
        dwBuff = dwInputBuff - dwBufferLen;
        dwError = GetDateTimeInfo(LOCALE_STIMEFORMAT,
                                  &stTime,
                                  pwszBuffer + dwBufferLen - 1,
                                  &dwBuff);
        if( dwError isnot NO_ERROR )
            goto RETURN;
    }

    dwBufferLen += dwBuff;
    
    *pdwBuffLen = dwBufferLen;
    
RETURN:
    return dwError;
}

LPWSTR
GetDateTimeString(IN FILETIME  ftTime,
                  IN BOOL      fShort,
                  OUT int     *piType
                  )
{

    DWORD       Status = NO_ERROR, i=0,
                dwTime = 0;

    LPWSTR      pwszTime = NULL;

    int         iType = 0;
    DWORD       dwLen = 0;

    Status = FormatDateTimeString(ftTime,
                                  fShort,
                                  NULL,
                                  &dwTime);

    if( Status is NO_ERROR )
    {
        dwLen = ( 23 > dwTime ) ? 23 : dwTime;
        pwszTime = DhcpAllocateMemory((dwLen+1)*sizeof(WCHAR));

        if( pwszTime is NULL )
        {
            iType = 1;
        }
        else
        {
            dwTime++;
            Status = FormatDateTimeString(ftTime,
                                          fShort,
                                          pwszTime,
                                          &dwTime);

            if( Status is NO_ERROR )
            {
                iType = 0;
            }
            else
            {
                DhcpFreeMemory(pwszTime);
                pwszTime = NULL;
                iType = 1;
            }
        }
    }
    else
    {
        pwszTime = NULL;
        iType = 1;
    }

    if( pwszTime )
    {
        for( i=wcslen(pwszTime); i<dwLen; i++ )
                pwszTime[i] = L' ';
    }

    *piType = iType;
    
    return pwszTime;
}

///
/// This code is stolen from net/ias/services/dll_bld/iasapi.cpp
/// 

/////////
// Unicode version of gethostbyname. The caller must free the returned hostent
// struct by calling LocalFree.
/////////
PHOSTENT
UnicodeGetHostByName(
    IN PCWSTR name,
    IN OUT LPWSTR *FqdnName
)
{
   // We put these at function scope, so we can clean them up on the way out.
   DWORD error = NO_ERROR;
   HANDLE lookup = NULL;
   union
   {
      WSAQUERYSETW querySet;
      BYTE buffer[512];
   } u;
   PWSAQUERYSETW result = NULL;
   PHOSTENT retval = NULL;

   PWSTR buf = NULL;
   DWORD length, naddr, i;
   SIZE_T nbyte;
   u_long *nextAddr;

   GUID hostAddrByNameGuid = SVCID_INET_HOSTADDRBYNAME;
   AFPROTOCOLS protocols[2] = {
       { AF_INET, IPPROTO_UDP },
       { AF_INET, IPPROTO_TCP }
   };

   do
   {
      if (!name)
      {
         // A NULL name means use the local host, so allocate a buffer ...
         DWORD size = 0;
         GetComputerNameEx(
             ComputerNamePhysicalDnsFullyQualified,
             NULL,
             &size
             );
         buf = (PWSTR) DhcpAllocateMemory( size * sizeof( WCHAR ));
         if ( NULL == buf ) {
             *FqdnName = NULL;
             return NULL;
         }

         // ... and get the local DNS name.
         if (!GetComputerNameEx(
                  ComputerNamePhysicalDnsFullyQualified,
                  buf,
                  &size
                  ))
         {
            error = GetLastError();
            break;
         }

         name = buf;
      }

      //////////
      // Create the query set
      //////////

      memset(&u.querySet, 0, sizeof(u.querySet));
      u.querySet.dwSize = sizeof(u.querySet);
      u.querySet.lpszServiceInstanceName = (PWSTR)name;
      u.querySet.lpServiceClassId = &hostAddrByNameGuid;
      u.querySet.dwNameSpace = NS_ALL;
      u.querySet.dwNumberOfProtocols = 2;
      u.querySet.lpafpProtocols = protocols;

      //////////
      // Execute the query.
      //////////

      error = WSALookupServiceBeginW(
                  &u.querySet,
                  LUP_RETURN_ADDR | LUP_RETURN_NAME,
                  &lookup
                  );
      if (error)
      {
         error = WSAGetLastError();
         break;
      }

      //////////
      // How much space do we need for the result?
      //////////

      length = sizeof(u.buffer);
      error = WSALookupServiceNextW(
                    lookup,
                    0,
                    &length,
                    &u.querySet
                    );
      if (!error)
      {
         result = &u.querySet;
      }
      else
      {
         error = WSAGetLastError();
         if (error != WSAEFAULT)
         {
            break;
         }

         /////////
         // Allocate memory to hold the result.
         /////////

         result = (PWSAQUERYSETW)LocalAlloc(0, length);
         if (!result)
         {
            error = WSA_NOT_ENOUGH_MEMORY;
            break;
         }

         /////////
         // Get the result.
         /////////

         error = WSALookupServiceNextW(
                     lookup,
                     0,
                     &length,
                     result
                     );
         if (error)
         {
            error = WSAGetLastError();
            break;
         }
      }

      if (result->dwNumberOfCsAddrs == 0)
      {
         error = WSANO_DATA;
         break;
      }

      ///////
      // Allocate memory to hold the hostent struct
      ///////

      naddr = result->dwNumberOfCsAddrs;
      nbyte = sizeof(struct hostent) +
                     (naddr + 1) * sizeof(char*) +
                     naddr * sizeof(struct in_addr);
      retval = (PHOSTENT)LocalAlloc(0, nbyte);
      if (!retval)
      {
         error = WSA_NOT_ENOUGH_MEMORY;
         break;
      }

      ///////
      // Initialize the hostent struct.
      ///////

      retval->h_name = NULL;
      retval->h_aliases = NULL;
      retval->h_addrtype = AF_INET;
      retval->h_length = sizeof(struct in_addr);
      retval->h_addr_list = (char**)(retval + 1);

      ///////
      // Store the addresses.
      ///////

      nextAddr = ( u_long *) (retval->h_addr_list + naddr + 1);
      for (i = 0; i < naddr; ++i)
      {
         struct sockaddr_in* sin = (struct sockaddr_in*)
            result->lpcsaBuffer[i].RemoteAddr.lpSockaddr;

         retval->h_addr_list[ i ]  = ( char * ) nextAddr;
         *nextAddr++ = sin->sin_addr.S_un.S_addr;
      }

      ///////
      // NULL terminate the address list.
      ///////

      retval->h_addr_list[i] = NULL;

   } while (FALSE);

   //////////
   // Clean up and return.
   //////////

   if (( NULL != FqdnName ) &&
       ( NULL != result ) &&
       ( NULL != result->lpszServiceInstanceName )) {
       length = wcslen( result->lpszServiceInstanceName );
       length = sizeof( WCHAR ) * ( length + 1 );

       *FqdnName = ( LPWSTR ) DhcpAllocateMemory( length );
       if ( NULL == *FqdnName ) {
	   SetLastError( ERROR_NOT_ENOUGH_MEMORY );
       }
       else {
	   wcscpy( *FqdnName, result->lpszServiceInstanceName );
       }
   } // if 

   if (result && result != &u.querySet) { LocalFree(result); }

   if (lookup) { WSALookupServiceEnd(lookup); }

   if (error)
   {
      if (error == WSASERVICE_NOT_FOUND) { error = WSAHOST_NOT_FOUND; }

      WSASetLastError(error);
   }

   if ( NULL != buf ) {
       DhcpFreeMemory( buf );
   }
   return retval;
} // UnicodeGetHostByName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\lib\dhcp.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcp.c

Abstract:

    This module contains DHCP specific utility routines used by the
    DHCP components.

Author:

    Manny Weiser (mannyw) 12-Aug-1992

Revision History:

    Madan Appiah (madana) 21-Oct-1992

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <dhcpl.h>

DWORD
NTTimeToNTPTime(PULONG pTime,
                PFILETIME pft OPTIONAL);

DWORD
NTPTimeToNTFileTime(PLONG pTime, PFILETIME pft, BOOL bHostOrder);

#undef DhcpAllocateMemory
#undef DhcpFreeMemory


PVOID
DhcpAllocateMemory(
    DWORD Size
    )
/*++

Routine Description:

    This function allocates the required size of memory by calling
    LocalAlloc.

Arguments:

    Size - size of the memory block required.

Return Value:

    Pointer to the allocated block.

--*/
{

    return( LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Size ) );
}

#undef DhcpFreeMemory

VOID
DhcpFreeMemory(
    PVOID Memory
    )
/*++

Routine Description:

    This function frees up the memory that was allocated by
    DhcpAllocateMemory.

Arguments:

    Memory - pointer to the memory block that needs to be freed up.

Return Value:

    none.

--*/
{

    LPVOID Ptr;

    ASSERT( Memory != NULL );
    Ptr = LocalFree( Memory );

    ASSERT( Ptr == NULL );
}



DATE_TIME
DhcpCalculateTime(
    DWORD RelativeTime
    )
/*++

Routine Description:

    The function calculates the absolute time of a time RelativeTime
    seconds from now.

Arguments:

    RelativeTime - Relative time, in seconds.

Return Value:

    The time in RelativeTime seconds from the current system time.

--*/
{
    SYSTEMTIME systemTime;
    ULONGLONG absoluteTime;

    if( RelativeTime == INFINIT_LEASE ) {
        ((DATE_TIME *)&absoluteTime)->dwLowDateTime =
            DHCP_DATE_TIME_INFINIT_LOW;
        ((DATE_TIME *)&absoluteTime)->dwHighDateTime =
            DHCP_DATE_TIME_INFINIT_HIGH;
    }
    else {

        GetSystemTime( &systemTime );
        SystemTimeToFileTime(
            &systemTime,
            (FILETIME *)&absoluteTime );

        absoluteTime = absoluteTime + RelativeTime * (ULONGLONG)10000000; }

    return( *(DATE_TIME *)&absoluteTime );
}


DATE_TIME
DhcpGetDateTime(
    VOID
    )
/*++

Routine Description:

    This function returns FILETIME.

Arguments:

    none.

Return Value:

    FILETIME.

--*/
{
    SYSTEMTIME systemTime;
    DATE_TIME Time;

    GetSystemTime( &systemTime );
    SystemTimeToFileTime( &systemTime, (FILETIME *)&Time );

    return( Time );
}

VOID
DhcpNTToNTPTime(
    LPDATE_TIME AbsNTTime,
    DWORD       Offset,
    PULONG      NTPTimeStamp
    )
/*++

Routine Description:

    The function calculates the absolute NTP timestamp from AbsTime on
    NT added by given offset.

Arguments:

    AbsNTTime - AbsTime on NT. If 0, it will use current time.

    RelativeOffset - offset to be added to AnsNTTime (in seconds.)

Return Value:

    The time in RelativeTime seconds from the current system time.

--*/
{
    ULONGLONG   LocalAbsNTTime;
    DWORD       Error;

    if ( AbsNTTime == 0 ) {
        GetSystemTimeAsFileTime((FILETIME *)&LocalAbsNTTime );
    } else {
        LocalAbsNTTime = *(ULONGLONG *)AbsNTTime;
    }

    // add offset
    LocalAbsNTTime += Offset * (ULONGLONG)10000000;

    // now convert to NT timestamp
    Error = NTTimeToNTPTime( NTPTimeStamp, (PFILETIME)&LocalAbsNTTime );

    DhcpAssert( ERROR_SUCCESS == Error );
    return;
}

VOID
DhcpNTPToNTTime(
    PULONG          NTPTimeStamp,
    DWORD           Offset,
    DATE_TIME       *NTTime
    )
/*++

Routine Description:

    The function calculates the absolute NTP timestamp from AbsTime on
    NT added by given offset.

Arguments:

    AbsNTTime - AbsTime on NT. If 0, it will use current time.

    RelativeOffset - offset to be added to AnsNTTime (in seconds.)

Return Value:

    The time in RelativeTime seconds from the current system time.

--*/
{
    ULONGLONG LocalAbsNTTime;
    DWORD       Error;

    Error = NTPTimeToNTFileTime(
                NTPTimeStamp,
                (FILETIME *)&LocalAbsNTTime,
                FALSE                           // not in host order.
                );

    DhcpAssert( ERROR_SUCCESS == Error );

    // add offset
    LocalAbsNTTime += Offset * (ULONGLONG)10000000;

    // now convert to NT timestamp
    // MBUG

    *(ULONGLONG *)NTTime = LocalAbsNTTime;
    return;
}


DWORD
DhcpReportEventW(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPWSTR *Strings,
    LPVOID Data
    )
/*++

Routine Description:

    This function writes the specified (EventID) log at the end of the
    eventlog.

Arguments:

    Source - Points to a null-terminated string that specifies the name
             of the module referenced. The node must exist in the
             registration database, and the module name has the
             following format:

                \EventLog\System\Lanmanworkstation

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event

    NumStrings - Specifies the number of strings that are in the array
                    at 'Strings'. A value of zero indicates no strings
                    are present.

    DataLength - Specifies the number of bytes of event-specific raw
                    (binary) data to write to the log. If cbData is
                    zero, no event-specific data is present.

    Strings - Points to a buffer containing an array of null-terminated
                strings that are merged into the message before
                displaying to the user. This parameter must be a valid
                pointer (or NULL), even if cStrings is zero.

    Data - Buffer containing the raw data. This parameter must be a
            valid pointer (or NULL), even if cbData is zero.


Return Value:

    Returns the WIN32 extended error obtained by GetLastError().

    NOTE : This function works slow since it calls the open and close
            eventlog source everytime.

--*/
{
    HANDLE EventlogHandle;
    DWORD ReturnCode;


    //
    // open eventlog section.
    //

    EventlogHandle = RegisterEventSourceW(
                    NULL,
                    Source
                    );

    if (EventlogHandle == NULL) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }


    //
    // Log the error code specified
    //

    if( !ReportEventW(
            EventlogHandle,
            (WORD)EventType,
            0,            // event category
            EventID,
            NULL,
            (WORD)NumStrings,
            DataLength,
            Strings,
            Data
            ) ) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }

    ReturnCode = NO_ERROR;

Cleanup:

    if( EventlogHandle != NULL ) {

        DeregisterEventSource(EventlogHandle);
    }

    return ReturnCode;
}


DWORD
DhcpReportEventA(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    )
/*++

Routine Description:

    This function writes the specified (EventID) log at the end of the
    eventlog.

Arguments:

    Source - Points to a null-terminated string that specifies the name
             of the module referenced. The node must exist in the
             registration database, and the module name has the
             following format:

                \EventLog\System\Lanmanworkstation

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event

    NumStrings - Specifies the number of strings that are in the array
                    at 'Strings'. A value of zero indicates no strings
                    are present.

    DataLength - Specifies the number of bytes of event-specific raw
                    (binary) data to write to the log. If cbData is
                    zero, no event-specific data is present.

    Strings - Points to a buffer containing an array of null-terminated
                strings that are merged into the message before
                displaying to the user. This parameter must be a valid
                pointer (or NULL), even if cStrings is zero.

    Data - Buffer containing the raw data. This parameter must be a
            valid pointer (or NULL), even if cbData is zero.


Return Value:

    Returns the WIN32 extended error obtained by GetLastError().

    NOTE : This function works slow since it calls the open and close
            eventlog source everytime.

--*/
{
    HANDLE EventlogHandle;
    DWORD ReturnCode;


    //
    // open eventlog section.
    //

    EventlogHandle = RegisterEventSourceW(
                    NULL,
                    Source
                    );

    if (EventlogHandle == NULL) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }


    //
    // Log the error code specified
    //

    if( !ReportEventA(
            EventlogHandle,
            (WORD)EventType,
            0,            // event category
            EventID,
            NULL,
            (WORD)NumStrings,
            DataLength,
            Strings,
            Data
            ) ) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }

    ReturnCode = NO_ERROR;

Cleanup:

    if( EventlogHandle != NULL ) {

        DeregisterEventSource(EventlogHandle);
    }

    return ReturnCode;
}


DWORD
DhcpLogUnknownOption(
    LPWSTR Source,
    DWORD EventID,
    LPOPTION Option
    )
/*++

Routine Description:

    This routine logs an unknown DHCP option to event log.

Arguments:

    Source - name of the app that logs this error. it should be either
        "DhcpClient" or "DhcpServer".

    EventID - Event identifier number.

    Option - pointer to the unknown option structure.

Return Value:

    Windows Error code.

--*/
{
    LPWSTR  Strings[2];
    WCHAR StringsBuffer[ 2 * (3 + 1) ];
        // for two string each is 1byte decimal number (0 - 255).

    LPWSTR StringsPtr = StringsBuffer;

    //
    // convert option number.
    //

    Strings[0] = StringsPtr;
    DhcpDecimalToString( StringsPtr, Option->OptionType );
    StringsPtr += 3;

    *StringsPtr++ = L'\0';

    //
    // convert option length.
    //
    Strings[1] = StringsPtr;
    DhcpDecimalToString( StringsPtr, Option->OptionLength );
    StringsPtr += 3;

    *StringsPtr++ = L'\0';


    //
    // log error.
    //

    return(
        DhcpReportEventW(
            Source,
            EventID,
            EVENTLOG_WARNING_TYPE,
            2,
            (DWORD)Option->OptionLength,
            Strings,
            (PVOID)Option->OptionValue )
        );
}

#if DBG

VOID
DhcpAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    )
/*++

Routine Description:

    Assertion failed.

Arguments:

    FailedAssertion :

    FileName :

    LineNumber :

    Message :

Return Value:

    none.

--*/
{
#ifndef DHCP_NOASSERT
    RtlAssert(
            FailedAssertion,
            FileName,
            (ULONG) LineNumber,
            (PCHAR) Message);
#endif

    DhcpPrint(( 0, "Assert @ %s \n", FailedAssertion ));
    DhcpPrint(( 0, "Assert Filename, %s \n", FileName ));
    DhcpPrint(( 0, "Line Num. = %ld.\n", LineNumber ));
    DhcpPrint(( 0, "Message is %s\n", Message ));

}

#endif



LPWSTR
DhcpRegIpAddressToKey(
    DHCP_IP_ADDRESS IpAddress,
    LPWSTR KeyBuffer
    )
/*++

Routine Description:

    This function converts an IpAddress to registry key. The registry
    key is unicode string of IpAddress in dotted form.

Arguments:

    IpAddress : IpAddress that needs conversion. The IpAddress is in
                host order.

    KeyBuffer : pointer a buffer that will hold the converted
                registry key. The buffer should be big enough to
                converted key.

Return Value:

    Pointer to the key the buffer.

--*/
{
    LPSTR OemKey;
    LPWSTR UnicodeKey;
    DWORD NetworkOrderIpAddress;

    NetworkOrderIpAddress = htonl(IpAddress);

    OemKey = inet_ntoa( *(struct in_addr *)&NetworkOrderIpAddress );
    UnicodeKey = DhcpOemToUnicode( OemKey, KeyBuffer );

    DhcpAssert( UnicodeKey == KeyBuffer );

    return( UnicodeKey );

}



DHCP_IP_ADDRESS
DhcpRegKeyToIpAddress(
    LPWSTR Key
    )
/*++

Routine Description:

    This function converts registry key to Ip Address.

Arguments:

    Key : Pointer to registry key.

Return Value:

    Converted IpAddress.

--*/
{
    CHAR OemKeyBuffer[DHCP_IP_KEY_LEN];
    LPSTR OemKey;


    OemKey = DhcpUnicodeToOem( Key, OemKeyBuffer );
    DhcpAssert( OemKey == OemKeyBuffer );

    return( ntohl(inet_addr( OemKey )) );
}



LPWSTR
DhcpRegOptionIdToKey(
    DHCP_OPTION_ID OptionId,
    LPWSTR KeyBuffer
    )
/*++

Routine Description:

    This function converts an OptionId to registry key. The registry
    key is unicode string of OptionId, 3 unicode char. long and of the
    form L"000".

Arguments:

    IpAddress : IpAddress that needs conversion.

    KeyBuffer : pointer a buffer that will hold the converted
                registry key. The buffer should be at least 8 char.
                long.

Return Value:

    Pointer to the key the buffer.

--*/

{
    int i;

    for (i = 2; i >= 0; i--) {
        KeyBuffer[i] = L'0' + (BYTE)(OptionId % 10 );
        OptionId /= 10;
    }
    KeyBuffer[3] = L'\0';

    return( KeyBuffer );
}



DHCP_OPTION_ID
DhcpRegKeyToOptionId(
    LPWSTR Key
    )
/*++

Routine Description:

    This function converts registry key to OptionId.

Arguments:

    Key : Pointer to registry key.

Return Value:

    Converted OptionId.

--*/

{
    DHCP_OPTION_ID OptionId = 0;
    int i;

    for (i = 0; i < 3 && Key[i] != L'\0'; i++) {
        OptionId = (OptionId * 10) + (Key[i] - L'0');
    }
    return( OptionId );
}

DWORD
DhcpStartWaitableTimer(
    HANDLE TimerHandle,
    DWORD SleepTime)
/*++

Routine Description:

    This routine starts the waitable timer. This timer fires off even
    when the system is in hibernate state.

Arguments

    TimerHandle - Waitable Timer Handle

    SleepTime   - Sleep Time in seconds.

Return Value:

    Status of the operation.

--*/
{
    DATE_TIME       SleepTimeInNSec; // sleep time in nano seconds since Jan 1 1901
    DWORD           Error;
    BOOL            Result;

    Error = STATUS_SUCCESS;
    SleepTimeInNSec = DhcpCalculateTime( SleepTime );

    Result = SetWaitableTimer(
                TimerHandle,            // handle to timer object
                (LARGE_INTEGER *)&SleepTimeInNSec,       // due time.
                0,                      // not periodic
                NULL,                   // completion routine
                NULL,                   // completion routine arg
                TRUE                    // resume power state when due
                );
    if ( !Result ) {
        DhcpPrint((0, "SetWaitableTimer reported Error = %d\n",Error=GetLastError()));
    }
    return Error;
}

VOID
DhcpCancelWaitableTimer(
    HANDLE TimerHandle
    )
/*++

Routine Description:

    This routine cancels the waitable timer.

Arguments

    TimerHandle - Waitable Timer Handle

Return Value:


--*/
{
    BOOL Result;

    Result = CancelWaitableTimer( TimerHandle );
    if ( !Result ) {
        DhcpPrint((0,"SetWaitableTimer reported Error = %lx\n",GetLastError()));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\lib\dhcpl.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpl.h

Abstract:

    This file is the main header file for the dhcp library functions.

Author:

    Manny Weiser (mannyw) 12-Oct-1992

Revision History:

--*/

//#define __DHCP_USE_DEBUG_HEAP__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <winsock.h>

#include <stdlib.h>

#include <dhcp.h>
#include <dhcplib.h>

//
// debug heap support
//

#include <heapx.h>

#ifdef DBG
#ifdef __DHCP_USE_DEBUG_HEAP__

#pragma message ( "*** DHCP Library will use debug heap ***" )

#define DhcpAllocateMemory(x) calloc(1,x)
#define DhcpFreeMemory(x)     free(x)

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\dhcp\dhcphandle.c ===
#include "precomp.h"
#include <dnsapi.h>

#pragma hdrstop


extern ULONG g_ulNumTopCmds;
extern ULONG g_ulNumGroups;
extern ULONG g_ulNumSubContext;

extern CMD_GROUP_ENTRY                  g_DhcpCmdGroups[];
extern CMD_ENTRY                        g_DhcpCmds[];
extern DHCPMON_SUBCONTEXT_TABLE_ENTRY   g_DhcpSubContextTable[];

DWORD
HandleDhcpList(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    i, j;

    for(i = 0; i < g_ulNumTopCmds-2; i++)
    {
        DisplayMessage(g_hModule, g_DhcpCmds[i].dwShortCmdHelpToken);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    for(i = 0; i < g_ulNumGroups; i++)
    {
        for(j = 0; j < g_DhcpCmdGroups[i].ulCmdGroupSize; j++)
        {
            DisplayMessage(g_hModule, g_DhcpCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);

            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
        }
    }

    for(i=0; i < g_ulNumSubContext; i++)
    {
        DisplayMessage(g_hModule, g_DhcpSubContextTable[i].dwShortCmdHlpToken);

        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    return NO_ERROR;
}


DWORD
HandleDhcpHelp(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    i, j;

    for(i = 0; i < g_ulNumTopCmds-2; i++)
    {
        if(g_DhcpCmds[i].dwCmdHlpToken != MSG_DHCP_NULL)
        {
            DisplayMessage(g_hModule, g_DhcpCmds[i].dwShortCmdHelpToken);
        }
    }

    for(i = 0; i < g_ulNumGroups; i++)
    {
        DisplayMessage(g_hModule, g_DhcpCmdGroups[i].dwShortCmdHelpToken);
    }
    
    for(i=0; i < g_ulNumSubContext; i++)
    {
        DisplayMessage(g_hModule, g_DhcpSubContextTable[i].dwShortCmdHlpToken);

        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    }    
    
    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    return NO_ERROR;
}

DWORD
HandleDhcpContexts(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return NO_ERROR;
}

extern
LPCWSTR g_DhcpGlobalServerName;

BOOL
ValidateServerName( LPWSTR ServerName )
{
    DNS_STATUS status;


    status = DnsValidateName( ServerName, DnsNameDomain );
    
    if (( ERROR_SUCCESS == status ) ||
	( DNS_ERROR_NUMERIC_NAME == status ) ||
	( DNS_ERROR_NON_RFC_NAME == status )) {
	return TRUE;
    }
    else {
	return FALSE;
    }

} // ValidateServerName()

DWORD
HandleDhcpAddServer(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                          Error = NO_ERROR;
    DHCP_SERVER_INFO               Server;
    BOOL                           fDsInit = FALSE;
    
    memset(&Server, 0x00, sizeof(DHCP_SERVER_INFO));
    
    if ( dwArgCount < dwCurrentIndex + 2 )
    {
        DisplayMessage(g_hModule,
                       HLP_DHCP_ADD_SERVER_EX);

        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

#ifdef NT5
    Error = DhcpDsInit();
    if( Error isnot NO_ERROR )
    {
        //DisplayMessage(g_hModule, EMSG_DHCP_DSINIT_FAILED, Error);
        //fDsInit = FALSE;
        goto ErrorReturn;
//        return Error;
    }
    fDsInit = TRUE;
#endif //NT5

    Server.ServerName = ppwcArguments[dwCurrentIndex];
    if ( !ValidateServerName( Server.ServerName )) {
	Error = ERROR_INVALID_PARAMETER;
	goto ErrorReturn;
    }
    Server.ServerAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);
    Server.Version = 0;
    Server.Flags = 0;
    Server.State = 0;
    Server.DsLocation = NULL;
    Server.DsLocType = 0;


    DisplayMessage(g_hModule,
                   MSG_DHCP_SERVER_ADDING, 
                   ppwcArguments[dwCurrentIndex], 
                   ppwcArguments[dwCurrentIndex+1]);

    Error = DhcpAddServer(0, NULL, &Server, NULL, NULL);
  
    if( NO_ERROR isnot Error ) 
    {
        // could not add the server
        goto ErrorReturn;
    }

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, 
                       EMSG_DHCP_ERROR_SUCCESS);

    if( fDsInit )
    {
        DhcpDsCleanup();
    }

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                   EMSG_DHCP_ADD_SERVER,
                   Error);
    goto CommonReturn;
}

#if 0
DWORD
HandleDhcpAddHelper(
    PWCHAR    pwszMachineName,
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwCmdFlags,
    PVOID     pvData,
    BOOL      *pbDone
)
{
     DWORD   dwErr;

    if (dwArgCount-dwCurrentIndex != 3)
    {
        //
        // Install requires name of helper, dll name, entry point
        //

        DisplayMessage(g_hModule,
                       HLP_DHCP_ADD_HELPER_EX);

        return NO_ERROR;
    }

    if(IsReservedKeyWord(ppwcArguments[dwCurrentIndex]))
    {
        DisplayMessage(g_hModule, EMSG_RSVD_KEYWORD,
                       ppwcArguments[dwCurrentIndex]);

        return ERROR_INVALID_PARAMETER;
    }

    dwErr = InstallHelper(REG_KEY_DHCPMGR_HELPER,
                          ppwcArguments[dwCurrentIndex],
                          ppwcArguments[dwCurrentIndex+1],
                          ppwcArguments[dwCurrentIndex+2],
                          &g_HelperTable,
                          &g_dwNumTableEntries);

    if (dwErr is ERROR_NOT_ENOUGH_MEMORY)
    {
        DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
    }

    return dwErr;
}
#endif //0

DWORD
HandleDhcpDeleteServer(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                  Error = NO_ERROR;
    DHCP_SERVER_INFO       Server;
    BOOL                   fDsInit = FALSE;

    memset(&Server, 0x00, sizeof(DHCP_SERVER_INFO));

    if( dwArgCount < dwCurrentIndex + 2 )
    {
        DisplayMessage(g_hModule,
                       HLP_DHCP_DELETE_SERVER_EX);

        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
#ifdef NT5
    Error = DhcpDsInit();
    if( Error isnot NO_ERROR )
    {
        goto ErrorReturn;
    }
    fDsInit = TRUE;
#endif //NT5
    
    Server.Version = 0;
    Server.ServerName = ppwcArguments[dwCurrentIndex];
    Server.ServerAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);
    Server.Flags = 0;
    Server.State = 0;
    Server.DsLocation = NULL;
    Server.DsLocType = 0;

	DisplayMessage(g_hModule,
                   MSG_DHCP_SERVER_DELETING, 
                   ppwcArguments[dwCurrentIndex], 
                   ppwcArguments[dwCurrentIndex+1]);


    Error = DhcpDeleteServer(0, NULL, &Server, NULL, NULL);
    
    if( NO_ERROR isnot Error ) 
    {   
        // could not delete the server
        goto ErrorReturn;
    }

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if( fDsInit)
    {
        DhcpDsCleanup();
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                   EMSG_DHCP_DELETE_SERVER,
                   Error);
    goto CommonReturn;
}

#if 0

DWORD
HandleDhcpDeleteHelper(
    PWCHAR    pwszMachineName,
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwCmdFlags,
    PVOID     pvData,
    BOOL      *pbDone
)
{
    DWORD   dwErr;

    if (dwArgCount-dwCurrentIndex != 1)
    {
        //
        // Uninstall requires name of helper
        //

        DisplayMessage(g_hModule, 
                       HLP_DHCP_DELETE_HELPER_EX);

        return NO_ERROR;
    }

    dwErr = UninstallHelper(REG_KEY_DHCPMGR_HELPER,
                            ppwcArguments[dwCurrentIndex],
                            &g_HelperTable,
                            &g_dwNumTableEntries);

    if (dwErr is ERROR_NOT_ENOUGH_MEMORY)
    {
        DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
    }

    return dwErr;
}
#endif //0

DWORD
HandleDhcpShowServer(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                       Error = NO_ERROR;
    LPDHCP_SERVER_INFO_ARRAY    Servers = NULL;
    BOOL                        fDsInit = FALSE;

#ifdef NT5
    Error = DhcpDsInit();
    if( Error isnot NO_ERROR )
    {
        goto ErrorReturn;
    }
    fDsInit = TRUE;
#endif //NT5

    Error = DhcpEnumServers(0, NULL, &Servers, NULL, NULL);
    
    if( NO_ERROR isnot Error ) 
    {
        goto ErrorReturn;
    }

    PrintServerInfoArray(Servers);

CommonReturn:
    if( Error is NO_ERROR)
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if(Servers)
    {
        DhcpRpcFreeMemory(Servers);
        Servers = NULL;
    }

    if( fDsInit )
    {
        DhcpDsCleanup();
    }

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_DHCP_SHOW_SERVER, 
                        Error);
    goto CommonReturn;
}


#if 0
DWORD
HandleDhcpShowHelper(
    PWCHAR    pwszMachineName,
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount
    DWORD     dwCmdFlags,
    PVOID     pvData,
    BOOL      *pbDone
)
{
    DWORD    i;

    for (i = 0; i < g_dwNumTableEntries; i++)
    {
        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_STRING, g_HelperTable[i].pwszHelper);
        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    }

    return NO_ERROR;
}

#endif //0

VOID
PrintServerInfo(                                  // print server information
    LPDHCP_SERVER_INFO       Server
)
{
    DHCP_IP_ADDRESS ServerAddress = (Server->ServerAddress);

    if( Server->DsLocation )
    {
        DisplayMessage(g_hModule, 
                       MSG_DHCP_SERVER_SHOW_INFO,
                       Server->ServerName,
                       IpAddressToString(ServerAddress),
                       Server->DsLocation
                       );
    }
    else
    {
        DisplayMessage(g_hModule, 
                       MSG_DHCP_SERVER_SHOW_INFO,
                       Server->ServerName,
                       IpAddressToString(ServerAddress)
                       );
    }
}

VOID
PrintServerInfoArray(                             // print list of servers
    LPDHCP_SERVER_INFO_ARRAY Servers
)
{
    DWORD   i;

    DisplayMessage(g_hModule, 
                   MSG_DHCP_SERVER_SHOW_INFO_ARRAY, 
                   Servers->NumElements);

    for( i = 0; i < Servers->NumElements; i ++ ) 
    {
        PrintServerInfo(&Servers->Servers[i]);
    }
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\dhcp\dump.c ===
//
// Copyright (C) 1999 Microsoft Corporation
//
//Implementation of dump functionality for DHCP

#include "precomp.h"

// Do not deprecate the string functions
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

DWORD
ConvertToExternalState(
   IN DWORD State
)
{
    DWORD retval = 0;

    switch ( State ) {
    case DhcpSubnetEnabled : retval = 1;         break;
    case DhcpSubnetDisabled: retval = 0;         break;
    case DhcpSubnetEnabledSwitched: retval = 3;  break;
    case DhcpSubnetDisabledSwitched:retval = 2;  break;
    default: DhcpAssert( FALSE );                break;
    } // switch

    return retval;

} // ConvertToExternalState()

DWORD
DhcpDumpServer(
               IN LPCWSTR  pwszIpAddress,
               IN DWORD    dwMajor,
               IN DWORD    dwMinor
               )
{
    DWORD                       Error = NO_ERROR;
    DHCP_RESUME_HANDLE          ResumeHandle = 0;
    LPDHCP_CLASS_INFO_ARRAY     ClassInfoArray = NULL;
    LPDHCP_OPTION_ARRAY         OptionsArray = NULL;
    LPDHCP_ALL_OPTIONS          OptionsAll = NULL;
    LPDHCP_ALL_OPTION_VALUES    OptionValues = NULL;
    LPDHCP_OPTION_VALUE         OptionValue = NULL;
    DHCP_OPTION_SCOPE_INFO      ScopeInfo = {0};
    LPDHCP_OPTION_VALUE_ARRAY   OptionArray = NULL;
    LPDHCP_IP_ARRAY             IpArray = NULL;
    LPDHCP_MSCOPE_TABLE         MScopeTable = NULL;

    DWORD                       nRead = 0,
                                dw = 0,
                                nCount = 0,
                                nTotal = 0;


    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DhcpDumpServerScriptHeader(pwszIpAddress);

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);


    DhcpDumpServerClassHeader();

    if( dwMajor >= CLASS_ID_VERSION )
    {
        //Dump Class Information script.

        while(TRUE)
        {
            Error = DhcpEnumClasses(
                        (LPWSTR)pwszIpAddress,
                        0,
                        &ResumeHandle,
                        ~0,
                        &ClassInfoArray,
                        &nRead,
                        &nTotal);

            if( Error is ERROR_NO_MORE_ITEMS)
                break;

            if( Error is NO_ERROR or
                Error is ERROR_MORE_DATA )
            {
                for( dw=0; dw<nRead; dw++ )
                {
                    DhcpDumpServerClass(pwszIpAddress,
                                        ClassInfoArray->Classes[dw]
                                       );
                }
            
                nCount += nRead;

                if( Error is ERROR_MORE_DATA )
                {
                    DhcpRpcFreeMemory(ClassInfoArray);
                    ClassInfoArray = NULL;
                    continue;
                }
                else
                    break;
            }
            else
                goto ErrorReturn;
        }
    }

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DhcpDumpServerClassFooter();

    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    //Dump Optiondefs


    DhcpDumpServerOptiondefHeader();

    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);


    ResumeHandle = 0;
    nRead = nTotal = nCount = 0;

    while(TRUE)
    {
        if( dwMajor >= CLASS_ID_VERSION )
        {
            Error = DhcpGetAllOptions(
                           (LPWSTR)pwszIpAddress,
                           0,
                           &OptionsAll);
            if( Error is ERROR_NO_MORE_ITEMS )
            {
                break;
            }
            
            if( Error is NO_ERROR or
                Error is ERROR_MORE_DATA )
            {
                DhcpDumpServerOptiondefV5(pwszIpAddress,
                                          OptionsAll);
                if( Error is NO_ERROR )
                    break;
                else
                {
                    DhcpRpcFreeMemory(OptionsAll);
                    OptionsAll = NULL;
                    continue;
                }
            }
            else
                goto ErrorReturn;
        }
        else
        {
            Error = DhcpEnumOptions(
                           (LPWSTR)pwszIpAddress,
                           &ResumeHandle,
                           ~0,
                           &OptionsArray,
                           &nRead,
                           &nTotal);

            if( Error is ERROR_NO_MORE_ITEMS )
            {
                break;
            }

            if( Error is NO_ERROR or
                Error is ERROR_MORE_DATA )
            {

                DhcpDumpServerOptiondef(pwszIpAddress,
                                        OptionsArray);
                if( Error is NO_ERROR )
                    break;
                else
                {
                    DhcpRpcFreeMemory(OptionsArray);
                    OptionsArray = NULL;
                    continue;
                }
            }
        }                        
    }

    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);


    DhcpDumpServerOptiondefFooter();
    
    
    //Dump Option Values set


    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DhcpDumpServerOptionvalueHeader();

    ResumeHandle = 0;
    nRead = nTotal = nCount = 0;

    ScopeInfo.ScopeType = DhcpGlobalOptions;

    while(TRUE)
    {
        if( dwMajor >= CLASS_ID_VERSION )
        {
            Error = DhcpGetAllOptionValues(
                            (LPWSTR)pwszIpAddress,
                            DHCP_OPT_ENUM_IGNORE_VENDOR,
                            &ScopeInfo,
                            &OptionValues
                            );

            if( Error is ERROR_NO_MORE_ITEMS )
            {
                break;
            }
            
            if( Error is NO_ERROR or
                Error is ERROR_MORE_DATA )
            {
                DhcpDumpServerOptionValuesV5(pwszIpAddress,
                                             NULL,
                                             NULL,
                                             OptionValues);
                if( Error is NO_ERROR )
                    break;
                else
                {
                    DhcpRpcFreeMemory(OptionValues);
                    OptionValues = NULL;
                    continue;
                }
            }
            else
                goto ErrorReturn;
        }
        else
        {
             Error = DhcpEnumOptions(
                            (LPWSTR)pwszIpAddress,
                            &ResumeHandle,
                            ~0,
                            &OptionsArray,
                            &nRead,
                            &nTotal);
        
            if( Error is ERROR_NO_MORE_ITEMS )
            {
                Error = NO_ERROR;
                break;
            }

            if( Error isnot NO_ERROR  &&
                Error isnot ERROR_MORE_DATA )
                goto ErrorReturn;

            for( dw = 0; dw < nRead; dw++ )
            {
                DHCP_OPTION_ID OptionId = OptionsArray->Options[dw].OptionID;
                DWORD          dwError = NO_ERROR;
                dwError = DhcpGetOptionValue(
                                             (LPWSTR)pwszIpAddress,
                                             OptionId,
                                             &ScopeInfo,
                                             &OptionValue);
                               
                if( dwError isnot NO_ERROR )
                {
                    continue;
                }
        
                if( OptionValue )
                {
                    DhcpDumpServerOptionValue(pwszIpAddress,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL,
                                              FALSE,
                                              *OptionValue);
                    DhcpRpcFreeMemory(OptionValue);
                    OptionValue = NULL;
                }
            }
    
            if( OptionsArray )
            {
                DhcpRpcFreeMemory(OptionsArray);
                OptionsArray = NULL;
            }

            if( Error is NO_ERROR )
                break;
            else
                continue;
        }
                        
    }


    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    
    DhcpDumpServerOptionvalueFooter();

    //Dump Audit Log Information
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    {
        LPWSTR pwszLogDir = NULL;
        DWORD  DiskCheckInterval=0, MaxLogFileSize=0, MinSpaceOnDisk=0;

        Error = DhcpAuditLogGetParams( g_ServerIpAddressUnicodeString,
                                       0,
                                       &pwszLogDir,
                                       &DiskCheckInterval,
                                       &MaxLogFileSize,
                                       &MinSpaceOnDisk);
        
        if( Error is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_AUDITLOG,
                           g_ServerIpAddressUnicodeString,
                           pwszLogDir);
        }

        if( pwszLogDir )
        {
            DhcpRpcFreeMemory(pwszLogDir);
            pwszLogDir = NULL;
        }

    }

    //Dump Dns Information
    {
        DHCP_OPTION_ID         OptionId = 81;

        DWORD   dwValue = 0;

        ScopeInfo.ScopeType = DhcpGlobalOptions;

        if( g_dwMajorVersion >= CLASS_ID_VERSION )
        {
            Error = DhcpGetOptionValueV5(g_ServerIpAddressUnicodeString,
                                         0,
                                         OptionId,    //DYNDNS option
                                         NULL,
                                         NULL,
                                         &ScopeInfo,
                                         &OptionValue);
        }
        else
        {
            Error = DhcpGetOptionValue(g_ServerIpAddressUnicodeString,
                                       OptionId,//81,
                                       &ScopeInfo,
                                       &OptionValue);
        }

        if( Error is NO_ERROR )
        {
            dwValue = OptionValue->Value.Elements->Element.DWordOption;

            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_DNSCONFIG,
                           g_ServerIpAddressUnicodeString,
                           ( dwValue & DNS_FLAG_ENABLED ) ? 1 : 0,
                           ( dwValue & DNS_FLAG_UPDATE_BOTH_ALWAYS ) ? 1 : 0,
                           ( dwValue & DNS_FLAG_CLEANUP_EXPIRED ) ? 1 : 0,
                           ( dwValue & DNS_FLAG_UPDATE_DOWNLEVEL ) ? 1 : 0 );

        }

        if( OptionValue )
        {
            DhcpRpcFreeMemory(OptionValue);
            OptionValue = NULL;
        }

    }
       
    //Dump database configuration information

    {
        LPDHCP_SERVER_CONFIG_INFO_V4    ConfigInfo = NULL;

        Error = DhcpServerGetConfigV4(g_ServerIpAddressUnicodeString,
                                      &ConfigInfo);

        if( Error is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_BACKUPINTERVAL,
                           g_ServerIpAddressUnicodeString,
                           ConfigInfo->BackupInterval);

            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_BACKUPPATH,
                           g_ServerIpAddressUnicodeString,
                           ConfigInfo->BackupPath);

            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_DATABASECLEANUPINTERVAL,
                           g_ServerIpAddressUnicodeString,
                           ConfigInfo->DatabaseCleanupInterval);

            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_DATABASELOGGINGFLAG,
                           g_ServerIpAddressUnicodeString,
                           ConfigInfo->DatabaseLoggingFlag);

            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_DATABASENAME,
                           g_ServerIpAddressUnicodeString,
                           ConfigInfo->DatabaseName);

            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_DATABASEPATH,
                           g_ServerIpAddressUnicodeString,
                           ConfigInfo->DatabasePath);

            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_DATABASERESTOREFLAG,
                           g_ServerIpAddressUnicodeString,
                           ConfigInfo->RestoreFlag);

            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_DETECTCONFLICTRETRY,
                           g_ServerIpAddressUnicodeString,
                           ConfigInfo->dwPingRetries);
        }

        if( ConfigInfo )
        {
            DhcpRpcFreeMemory(ConfigInfo);
            ConfigInfo = NULL;
        }
    }
    //Dump Scope Information

    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DhcpDumpServerScopeHeader();

    nRead = nTotal = 0;
    ResumeHandle = 0;


    while(TRUE)
    {

        Error = DhcpEnumSubnets(
                    (LPWSTR)pwszIpAddress,
                    &ResumeHandle,
                    ~0,
                    &IpArray,
                    &nRead,
                    &nTotal
                    );
        
        if( Error is ERROR_NO_MORE_ITEMS )
        {
            Error = NO_ERROR;
            break;
        }
        if( Error isnot NO_ERROR and
            Error isnot ERROR_MORE_DATA )
        {
            goto ErrorReturn;
        }

       
        for( dw=0; dw<nRead; dw++ )
        {
            Error = DhcpDumpScope(pwszIpAddress,
                          dwMajor,
                          dwMinor,
                          IpArray->Elements[dw]);
            if( Error is ERROR_NOT_ENOUGH_MEMORY )
                goto ErrorReturn;
        }
        if( Error is NO_ERROR )
            break;
        else
        {
            DhcpRpcFreeMemory(IpArray);
            IpArray = NULL;
            continue;
        }

     }    

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);


    DhcpDumpServerScopeFooter();

    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);


    // Dump SuperScopes

    DhcpDumpSuperScopes(( LPWSTR ) pwszIpAddress,
			dwMajor, dwMinor );


    // Dump Multicast Scopes


    DhcpDumpServerMScopeHeader();

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);


    nRead = nTotal = 0;
    ResumeHandle = 0;

    {
        while(TRUE)
        {
            Error = DhcpEnumMScopes((LPWSTR)pwszIpAddress,
                                    &ResumeHandle,
                                    ~0,
                                    &MScopeTable,
                                    &nRead,
                                    &nTotal);

            if( Error is ERROR_NO_MORE_ITEMS )
            {
                if( MScopeTable )
                {
                    DhcpRpcFreeMemory(MScopeTable);
                    MScopeTable = NULL;                            
                }
                break;
            }
            
            if( Error isnot NO_ERROR and
                Error isnot ERROR_MORE_DATA )
            {
                goto ErrorReturn;
            }


            for( dw=0; dw<nRead; dw++ )
            {
                DWORD   dwError = NO_ERROR;
                dwError = DhcpDumpServerMScope(pwszIpAddress,
                                               dwMajor,
                                               dwMinor,
                                               MScopeTable->pMScopeNames[dw]);
                if( dwError is ERROR_NOT_ENOUGH_MEMORY )
                {
                    Error = dwError;
                    goto ErrorReturn;
                }
            }
            
            DhcpRpcFreeMemory(MScopeTable);
            MScopeTable = NULL;

            if( Error is NO_ERROR )
                break;
            else
                continue;                                    
        }
    } // while

    // There is no error since it got this far
    Error = NO_ERROR;

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DhcpDumpServerMScopeFooter();

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DhcpDumpServerScriptFooter(pwszIpAddress);
    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);
CommonReturn:
    if( ClassInfoArray )
    {
        DhcpRpcFreeMemory(ClassInfoArray);
        ClassInfoArray = NULL;
    }
    
    if( OptionsAll )
    {
        DhcpRpcFreeMemory(OptionsAll);
        OptionsAll = NULL;
    }

    if( OptionsArray )
    {
        DhcpRpcFreeMemory(OptionsArray);
        OptionsArray = NULL;
    }

    if( OptionValue )
    {
        DhcpRpcFreeMemory(OptionValue);
        OptionValue = NULL;
    }

    if( OptionValues )
    {
        DhcpRpcFreeMemory(OptionValues);
        OptionValues = NULL;
    }

    if( OptionArray )
    {
        DhcpRpcFreeMemory(OptionArray);
        OptionArray = NULL;
    }

    if( IpArray )
    {
        DhcpRpcFreeMemory(IpArray);
        IpArray = NULL;
    }

    return Error;

ErrorReturn:
    goto CommonReturn;

} // DhcpDumpServer()

VOID
DhcpDumpScriptHeader()
{
    DisplayMessage(g_hModule,
                   DMP_DHCP_SCRIPTHEADER);
}

VOID
DhcpDumpServerScriptHeader(IN LPCWSTR pwszServer)
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_SERVER_HEADER,
                   pwszServer);
}


VOID
DhcpDumpServerClass(
                    IN LPCWSTR          pwszServer,
                    IN DHCP_CLASS_INFO ClassInfo
                   )
{
    WCHAR       Comment[256] = {L'\0'},
                Name[256] = {L'\0'},
                Data[1024] = {L'\0'};
    DWORD       dw = 0;
    

    Name[0] = L'\"';
    dw = wcslen(ClassInfo.ClassName);
    wcsncpy(Name+1, ClassInfo.ClassName, (dw>252)? 252 : dw);
    dw = wcslen(Name);
    Name[dw] = L'\"';
    Name[dw+1] = L'\0';

    if( ClassInfo.ClassComment )
    {
        Comment[0] = L'\"';
        dw = wcslen(ClassInfo.ClassComment);
        wcsncpy(Comment+1, ClassInfo.ClassComment, (dw>252)? 252 : dw);
        dw = wcslen(Comment);
        Comment[dw] = L'\"';        
        Comment[dw+1] = L'\0';
    }
    
    for( dw=0; dw<ClassInfo.ClassDataLength && dw<1020/sizeof(WCHAR); dw++ )
    {
        wsprintf(Data+dw*sizeof(WCHAR), L"%.02x", ClassInfo.ClassData[dw]);
    }
    
    Data[dw*sizeof(WCHAR)] = L'\0';
    
    DisplayMessage(g_hModule,
                   DMP_SRVR_ADD_CLASS,
                   pwszServer,
                   ClassInfo.ClassName,
                   Comment,
                   Data,
                   ClassInfo.IsVendor ? L"1" : L"0" );
}

DWORD
DumpOptiondef(
    LPCWSTR       pServerIp,
    LPDHCP_OPTION pOption,
    LPWSTR        pVendorName,
    LPWSTR        pClassName
)
{
    DWORD      Error = NO_ERROR;
    DWORD      i, BufLen;
    LPWSTR     ArrayType;
    LPWSTR     pBuffer = NULL;
    LPWSTR     pwszType, pwszDefData;
    LPWSTR     pComment;

    const int MAX_DWORDDWORD_BUF_SIZE = 25; // 21 decimal digits + spare

    DHCP_OPTION_DATA Data = pOption->DefaultValue;

    //
    // Do nothing if NumElements == 0
    //
    if ( 0 == Data.NumElements ) {
        return ERROR_INVALID_PARAMETER;
    }


    ArrayType = ( DhcpArrayTypeOption == pOption->OptionType ) ? L"1" : L"0";

    //
    // Calculate the size needed for option buffer
    //
    
    BufLen = 0;
    for ( i = 0; i < Data.NumElements; i++ ) {
	switch ( Data.Elements[ i ].OptionType ) {
	case DhcpBinaryDataOption:
	case DhcpEncapsulatedDataOption: {
	    BufLen += Data.Elements[ i ].Element.BinaryDataOption.DataLength;
	    BufLen *= 2; // each byte takes 2 hex digits
	    break;
	} 

	case DhcpStringDataOption: {
	    BufLen += wcslen( Data.Elements[ i ].Element.StringDataOption );
	    break;
	} 

	case DhcpByteOption: case DhcpWordOption:
	case DhcpDWordOption: case DhcpDWordDWordOption:
	case DhcpIpAddressOption: {
	    BufLen += MAX_DWORDDWORD_BUF_SIZE;
	    break;
	}

	default: {
	    DhcpAssert( FALSE );
	    break;
	}
	} // switch

	// Add space for quotes and space
	BufLen += 3;
    } // for

    BufLen *= sizeof( WCHAR );

    //
    // Allocate space for the buffer
    //
    pBuffer = DhcpAllocateMemory( BufLen );
    if ( NULL == pBuffer ) {
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    // data type 
    pwszType = TagOptionType[ Data.Elements[ 0 ].OptionType ].pwcTag;


    pwszDefData = pBuffer;

    for ( i = 0; i < Data.NumElements; i++ ) {

	switch ( Data.Elements[ i ].OptionType ) {

	    case DhcpByteOption: {
                _ultow(( int )( Data.Elements[ i ].Element.ByteOption ),
		       pBuffer, 10 );
                break;
            }
	    case DhcpWordOption: {
                _ultow(( int )( Data.Elements[ i ].Element.WordOption ),
		       pBuffer, 10);
                break;
            }
	    case DhcpDWordOption: {
                _ultow(( int )( Data.Elements[ i ].Element.DWordOption ),
		       pBuffer, 10);
                break;
            }
	    case DhcpDWordDWordOption: {
		wsprintf( pBuffer, L"%08x%08x",
			  Data.Elements[ i ].Element.DWordDWordOption.DWord1,
			  Data.Elements[ i ].Element.DWordDWordOption.DWord2 );
                break;
            }
	    case DhcpIpAddressOption: {
		LPWSTR IpAddrStr;
                IpAddrStr = IpAddressToString( Data.Elements[ i ].Element.IpAddressOption );
		if ( NULL != IpAddrStr ) {
		    wcscpy( pBuffer, IpAddrStr );
		    DhcpFreeMemory( IpAddrStr );
		}
                break;
            }
	    case DhcpStringDataOption: {
		wsprintf( pBuffer, L"\"%ws\"",
			Data.Elements[ i ].Element.StringDataOption );
                break;
            }
	    case DhcpBinaryDataOption:
	    case DhcpEncapsulatedDataOption: {
		DWORD k;
		DWORD Len;

		Len = Data.Elements[ i ].Element.BinaryDataOption.DataLength;
		for ( k = 0; k < Len; k++, pBuffer += 2 ) {
		    wsprintf( pBuffer, L"%02x", 
			      Data.Elements[ i ].Element.BinaryDataOption.Data[ k ]);
		} // for 

		break;
            }
	    default: {
		// We should always handle our data types
		DhcpAssert( FALSE );
                break;
            } // default
	} // switch


	// Move to end of string and add a space 
	while ( *pBuffer++ != L'\0' );
	*( pBuffer - 1 ) = L' ';
	
    } // for 

    // Null terminate the string
    *( pBuffer - 1 ) = L'\0';

    if ( NULL == pOption->OptionComment ) {
	pComment = L"";
    }
    else {
	pComment = pOption->OptionComment;
    }

    if ( NULL != pVendorName ) {
	
	DisplayMessage( g_hModule, DMP_SRVR_ADD_OPTIONDEF_VENDOR,
			pServerIp, pOption->OptionID, 
			pOption->OptionName, pwszType, ArrayType,
			pwszDefData, pVendorName, pComment );
    }
    else {
	DisplayMessage( g_hModule, DMP_SRVR_ADD_OPTIONDEF,
			pServerIp, pOption->OptionID, 
			pOption->OptionName, pwszType, ArrayType,
			pwszDefData, pComment );
    }

    DhcpFreeMemory( pwszDefData );
    return Error;
} // DumpOptiondef()

DWORD
DhcpDumpServerOptiondefV5(
    IN LPCWSTR             pwszServerIp,
    IN LPDHCP_ALL_OPTIONS OptionsAll
)
{
    DWORD       Error = NO_ERROR;
    DWORD       dw = 0, j;
    DWORD       dwOption = 0;

    if( OptionsAll is NULL ) {
        return Error;
    }

    Error = DhcpDumpServerOptiondef(pwszServerIp,
                                    OptionsAll->NonVendorOptions);

    if( Error is ERROR_NOT_ENOUGH_MEMORY ) {
        return Error;
    }
    else {
        Error = NO_ERROR; 
    }

    for( dw = 0; dw < OptionsAll->NumVendorOptions; dw++ ) {
        
        DHCP_OPTION Option = OptionsAll->VendorOptions[dw].Option;

	Error = DumpOptiondef( pwszServerIp, &Option,
			       OptionsAll->VendorOptions[ dw ].VendorName,
			       OptionsAll->VendorOptions[ dw ].ClassName );
	if ( NO_ERROR != Error ) {
	    break;
	}
	    
    } // for
    return Error;
}


DWORD
DhcpDumpServerOptiondef(
   IN LPCWSTR              pwszServer,
   IN LPDHCP_OPTION_ARRAY  OptionArray
)
{
    DWORD       Error, i;

    if ( OptionArray is NULL ) {
        return NO_ERROR;
    }

    DisplayMessage(g_hModule, 
                   DMP_SRVR_OPTION_NONVENDOR);

    // for all optiondefs
    for( i=0; i<OptionArray->NumElements; i++ ) {
        DHCP_OPTION Option = OptionArray->Options[ i ];

	Error = DumpOptiondef( pwszServer, &Option, NULL, NULL );
	if ( NO_ERROR != Error ) {
	    break;
	}
    } // for

    return Error;
}

DWORD
DhcpDumpServerOptionValuesV5(
                             IN LPCWSTR                  pwszServer,
                             IN LPCWSTR                  pwszScope,
                             IN LPCWSTR                  pwszReserved,
                             IN LPDHCP_ALL_OPTION_VALUES OptionValues
                            )
{
    DWORD                       Error = NO_ERROR,
                                dwOptionCount = 0,
                                dw = 0,
                                dwNum = 0,
                                i = 0;

    LPDHCP_OPTION_VALUE_ARRAY   Array = NULL;
    DHCP_OPTION_DATA_TYPE       eType = DhcpDWordOption;
    LPWSTR                      pwcUser = NULL,
                                pwcVendor = NULL;
    BOOL                        fVendor = FALSE;

    if( OptionValues is NULL )
        return Error;

    dwOptionCount = OptionValues->NumElements;
    
    if( dwOptionCount < 1 )
        return Error;


    for( i=0; i<dwOptionCount; i++ )
    {
        DWORD   dwCount = 0,
                j = 0;
        DHCP_OPTION_VALUE   Value = {0};

        pwcUser = OptionValues->Options[i].ClassName;
        pwcVendor = OptionValues->Options[i].VendorName;
        fVendor = OptionValues->Options[i].IsVendor;
        Array = OptionValues->Options[i].OptionsArray;
    
        if( Array is NULL )
            continue;

        dwCount = Array->NumElements;

        for( j=0; j<dwCount; j++ )
        {
            Value = Array->Values[j];
            if( Value.OptionID is 81 )
                continue;
            Error = DhcpDumpServerOptionValue(pwszServer,
                                              pwszScope,
                                              pwszReserved,
                                              pwcUser,
                                              pwcVendor,
                                              TRUE,
                                              Value);

            if( Error is ERROR_NOT_ENOUGH_MEMORY )
            {
                return Error;
            }
                                        
        }

        pwcUser = pwcVendor = NULL;
        Array = NULL;
        fVendor = FALSE;

    }
    return Error;
}

DWORD
DhcpDumpServerOptionValue(
                          IN LPCWSTR                     pwszServer,
                          IN LPCWSTR                     pwszScope,
                          IN LPCWSTR                     pwszReserved,
                          IN LPCWSTR                     pwcUser,
                          IN LPCWSTR                     pwcVendor,
                          IN BOOL                        fIsV5,
                          IN DHCP_OPTION_VALUE           OptionValue
                         )
{
    DWORD                   Error = NO_ERROR,
                            dw = 0, 
                            dwNum = 0,
                            i=0;
    DHCP_OPTION_DATA        Data;
    DHCP_OPTION_DATA_TYPE   eType = DhcpDWordOption;
    WCHAR                   wcString[1024] = {L'\0'}; 
    LPWSTR                  pwcType = NULL;
    WCHAR                   wcVendor[256] = {L'\0'},
                            wcUser[256] = {L'\0'};

    Data = OptionValue.Value;


    //Form optionvalue string..

    dwNum = Data.NumElements;

    if( dwNum <= 0 )
        return Error;;

    eType = Data.Elements[0].OptionType;
    
    dw = 0;

    while(dwNum>i)
    {
        WCHAR   Buffer[ 35 ] = {L'\0'};

        wcscpy(wcString+dw, L"\""); dw ++;
        switch(eType)
        {
        case DhcpByteOption:
            {
                _itow((int)Data.Elements[i].Element.ByteOption, Buffer, 10);
                wcscpy(wcString+dw, Buffer );
                break;
            }
        case DhcpWordOption:
            {
                _itow((int)Data.Elements[i].Element.WordOption, Buffer, 10);
                wcscpy(wcString+dw, Buffer);
                break;
            }
	case DhcpBinaryDataOption:
	case DhcpEncapsulatedDataOption:
	    {
		DWORD j;
                DWORD Length;
		
                Length = Data.Elements[ i ].Element.BinaryDataOption.DataLength;
                for( j = 0; j < Length; j++ ) {
		    wsprintf( &wcString[ dw + sizeof( WCHAR ) * j ], L"%02x",
			      Data.Elements[ i ].Element.BinaryDataOption.Data[ j ]);
                }
		wcString[ dw + sizeof( WCHAR ) * Length] = L'\0';
		break;
	    }

        case DhcpDWordOption:
            {
                _itow((int)Data.Elements[i].Element.DWordOption, Buffer, 10);
                wcscpy(wcString+dw, Buffer );
		if ( DhcpDWordOption != eType ) {
		    eType = DhcpDWordOption ;
		}
                break;
            }
        case DhcpStringDataOption:
            {
                wcscpy(wcString+dw, Data.Elements[i].Element.StringDataOption);
                break;
            }
        case DhcpIpAddressOption:
            {
		LPWSTR tmp;

		tmp =  IpAddressToString(Data.Elements[i].Element.IpAddressOption);
		if ( NULL != tmp ) {
		    wcscpy( wcString+dw, tmp );
		}
                break;
            }
	case DhcpDWordDWordOption: {
	    wsprintf( wcString + dw, L"%08x%08x", 
		      Data.Elements[ i ].Element.DWordDWordOption.DWord1,
		      Data.Elements[ i ].Element.DWordDWordOption.DWord2 );
	    break;
	}
        default: 
	    {
		DhcpAssert( FALSE );
		break;
	    }
        } // switch

	if ( NULL == pwcType ) {
	    pwcType = TagOptionType[ eType ].pwcTag;
	}

        dw = wcslen(wcString);

        wcString[dw] = L'\"';
        dw++;
        wcString[dw] = L' ';
        dw++;
        i++;
    }

    if( fIsV5 is FALSE )
    {
        
        if( pwszScope is NULL )
        {


            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_OPTIONVALUE,
                           pwszServer,
                           OptionValue.OptionID,
                           pwcType,
                           wcString);
            return Error;
        }

        if( pwszReserved is NULL and
            pwszScope isnot NULL )
        {
            DisplayMessage(g_hModule,
                           DMP_SCOPE_SET_OPTIONVALUE,
                           pwszServer,
                           pwszScope,
                           OptionValue.OptionID,
                           pwcType,
                           wcString);
            return Error;
        }

        DisplayMessage(g_hModule,
                       DMP_SCOPE_SET_RESERVEDOPTIONVALUE,
                       pwszServer,
                       pwszScope,
                       pwszReserved,
                       OptionValue.OptionID,
                       pwcType,
                       wcString);
        return Error;

    }
    else
    {
        if( pwcUser )
        {
            wcUser[0] = L'\"';
            dw = wcslen(pwcUser);
            wcsncpy(wcUser+1, pwcUser, (dw>252) ? 252:dw);
            dw = wcslen(wcUser);
            wcUser[dw] = L'\"';
            wcUser[dw+1] = L'\0';
        }

        if( pwcVendor )
        {
            wcVendor[0] = L'\"';
            dw = wcslen(pwcVendor);
            wcsncpy(wcVendor+1, pwcVendor, (dw>252) ? 252:dw);
            dw = wcslen(wcVendor);
            wcVendor[dw] = L'\"';
            wcVendor[dw+1] = L'\0';
        }
        if( pwszScope is NULL )
        {
            
            if( pwcUser && pwcVendor )
            {

                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_OPTIONVALUE_CLASS,
                               pwszServer,
                               OptionValue.OptionID,
                               pwcType,
                               wcUser,
                               wcVendor,
                               wcString);
            }
            else if( ( pwcUser ) && 
                     ( pwcVendor is NULL ) )
            {
                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_OPTIONVALUE_USER,
                               pwszServer,
                               OptionValue.OptionID,
                               pwcType,
                               wcUser,
                               wcString);
            }
            else if( ( pwcUser is NULL ) &&
                     ( pwcVendor ) )
            {
                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_OPTIONVALUE_VENDOR,
                               pwszServer,
                               OptionValue.OptionID,
                               pwcType,
                               wcVendor,
                               wcString);
            }
            else
            {
                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_OPTIONVALUE,
                               pwszServer,
                               OptionValue.OptionID,
                               pwcType,
                               wcString);
            }

            return Error;
        }

        if( pwszReserved is NULL and
            pwszScope isnot NULL )
        {
            if( pwcUser && pwcVendor )
            {
                DisplayMessage(g_hModule,
                               DMP_SCOPE_SET_OPTIONVALUE_CLASS,
                               pwszServer,
                               pwszScope,
                               OptionValue.OptionID,
                               pwcType,
                               wcUser,
                               wcVendor,
                               wcString);
            }
            else if( ( pwcUser ) &&
                     ( pwcVendor is NULL ) )
            {
                DisplayMessage(g_hModule,
                               DMP_SCOPE_SET_OPTIONVALUE_USER,
                               pwszServer,
                               pwszScope,
                               OptionValue.OptionID,
                               pwcType,
                               wcUser,
                               wcString);
            }
            else if ( ( pwcUser is NULL ) &&
                      ( pwcVendor ) )
            {
                DisplayMessage(g_hModule,
                               DMP_SCOPE_SET_OPTIONVALUE_VENDOR,
                               pwszServer,
                               pwszScope,
                               OptionValue.OptionID,
                               pwcType,
                               wcVendor,
                               wcString);
            }
            else
            {
                DisplayMessage(g_hModule,
                               DMP_SCOPE_SET_OPTIONVALUE,
                               pwszServer,
                               pwszScope,
                               OptionValue.OptionID,
                               pwcType,
                               wcString);

            }
            return Error;
        }

        if( pwcUser && pwcVendor )
        {
            DisplayMessage(g_hModule,
                           DMP_SCOPE_SET_RESERVEDOPTIONVALUE_CLASS,
                           pwszServer,
                           pwszScope,
                           pwszReserved,
                           OptionValue.OptionID,
                           pwcType,
                           wcUser,
                           wcVendor,
                           wcString);
        }
        else if( ( pwcUser ) &&
                 ( pwcVendor is NULL ) )
        {
            DisplayMessage(g_hModule,
                           DMP_SCOPE_SET_RESERVEDOPTIONVALUE_USER,
                           pwszServer,
                           pwszScope,
                           pwszReserved,
                           OptionValue.OptionID,
                           pwcType,
                           wcUser,
                           wcString);
        }
        else if( ( pwcUser is NULL ) &&
                 ( pwcVendor ) )
        {
            DisplayMessage(g_hModule,
                           DMP_SCOPE_SET_RESERVEDOPTIONVALUE_VENDOR,
                           pwszServer,
                           pwszScope,
                           pwszReserved,
                           OptionValue.OptionID,
                           pwcType,
                           wcVendor,
                           wcString);
        }
        else
        {
            DisplayMessage(g_hModule,
                           DMP_SCOPE_SET_RESERVEDOPTIONVALUE,
                           pwszServer,
                           pwszScope,
                           pwszReserved,
                           OptionValue.OptionID,
                           pwcType,
                           wcString);
        }
        return Error;

    }
}

DWORD
DhcpDumpScope(
              IN LPCWSTR pwszServerIp,
              IN DWORD   dwMajor,
              IN DWORD   dwMinor,
              IN DWORD   ScopeIp)
{
    DWORD                               Error = NO_ERROR,
                                        dwLen = 0,
                                        dwRead = 0,
                                        dwTotal = 0,
                                        dw = 0, i = 0, j = 0;
                        
    LPDHCP_SUBNET_INFO                  SubnetInfo = NULL;
    DHCP_OPTION_SCOPE_INFO              ScopeInfo = {0};


    WCHAR                               Name[256] = {L'\0'},
                                        Comment[256] = {L'\0'};

    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY    Elem = NULL;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Elements4 = NULL;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 Elements5 = NULL;
    LPDHCP_ALL_OPTION_VALUES            OptionValues = NULL;
    LPDHCP_OPTION_VALUE_ARRAY           OptionArray = NULL;
    LPDHCP_OPTION_VALUE                 OptionValue = NULL;
    DHCP_RESUME_HANDLE                  Resume = 0;
    LPDHCP_OPTION_ARRAY                 OptionsArray = NULL;
    ULONG                               MajorVersion = 0, NumElements = 0;
    BOOL                                fIsV5Call;
    DWORD                               State;
    
    //First Dhcp Server Add Scope

    Error = DhcpGetSubnetInfo(
                              (LPWSTR)pwszServerIp,                              
                              ScopeIp,
                              &SubnetInfo);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;


    if( SubnetInfo->SubnetName )
    {
        Name[0] = L'\"';
        dwLen = wcslen(SubnetInfo->SubnetName);
        wcsncpy(Name+1, SubnetInfo->SubnetName, (dwLen>252)? 252:dwLen);
        dwLen = wcslen(Name);
        Name[dwLen] = L'\"';
        Name[dwLen+1] = L'\0';
    }

    if( SubnetInfo->SubnetComment )
    {
        Comment[0] = L'\"';
        dwLen = wcslen(SubnetInfo->SubnetComment);
        wcsncpy(Comment+1, SubnetInfo->SubnetComment, (dwLen>252)? 252:dwLen);
        dwLen = wcslen(Comment);
        Comment[dwLen] = L'\"';
        Comment[dwLen+1] = L'\0';
    }

    MajorVersion = g_dwMajorVersion;
    
    if( MajorVersion >= CLASS_ID_VERSION )
    {
        fIsV5Call = TRUE;
    }
    else
    {
        fIsV5Call = FALSE;
    }
    
    DisplayMessage(g_hModule,
                   DMP_SRVR_ADD_SCOPE,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress),
                   IpAddressToString(SubnetInfo->SubnetMask),
                   Name,
                   Comment);

    //Set the state of the Scope

    // Adjust the state value since it's flipped in the 
    // state enum
    State = ConvertToExternalState( SubnetInfo->SubnetState );
    DisplayMessage(g_hModule,
                   DMP_SCOPE_SET_STATE,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress),
                   State );



    Resume = 0;
    dwRead = dwTotal = 0;

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule,
                   DMP_SCOPE_ADD_IPRANGES_HEADER,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress));

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    //Add IPRanges
    {

        while(TRUE)
        {
            if( FALSE == fIsV5Call ) 
            {
                Error = DhcpEnumSubnetElements(
                                                (LPWSTR)pwszServerIp, 
                                                SubnetInfo->SubnetAddress,
                                                DhcpIpRanges, 
                                                &Resume,
                                                ~0, 
                                                &Elem,
                                                &dwRead,
                                                &dwTotal
                                                );
            } 
            else 
            {
                Error = DhcpEnumSubnetElementsV5(
                                                (LPWSTR)pwszServerIp, 
                                                SubnetInfo->SubnetAddress,
                                                DhcpIpRangesDhcpBootp, 
                                                &Resume,
                                                ~0, 
                                                &Elements5,
                                                &dwRead, 
                                                &dwTotal
                                                );
            }

            if( Error is ERROR_NO_MORE_ITEMS )
            {
                if( Elem )
                {
                    DhcpRpcFreeMemory(Elem);
                    Elem = NULL;
                }

                if( Elements5 )
                {
                    DhcpRpcFreeMemory(Elements5);
                    Elements5 = NULL;
                }
                
                break;
            }

            if( Error is ERROR_NOT_ENOUGH_MEMORY )
            {
                goto ErrorReturn;
            }

            if( Error isnot NO_ERROR and
                Error isnot ERROR_MORE_DATA )
                break;

            if( fIsV5Call ) 
                NumElements = Elements5->NumElements;
            else 
                NumElements = Elem->NumElements;
            
            for( dw=0; dw<dwRead && dw < NumElements ; dw++ )
            {
                LPTSTR ElementType, StartAddress, EndAddress;
                
                if( fIsV5Call ) {
                    if( Elements5->Elements[dw].ElementType == DhcpIpRangesDhcpOnly ) {
                        ElementType = TEXT("");
                    } else if( Elements5->Elements[dw].ElementType == DhcpIpRangesBootpOnly ) {
                        ElementType = TEXT("BOOTP");
                    } else {
                        ElementType = TEXT("BOTH");
                    }
                    StartAddress = IpAddressToString(
                        Elements5->Elements[dw].Element.IpRange->StartAddress
                        );
                    EndAddress = IpAddressToString(
                        Elements5->Elements[dw].Element.IpRange->EndAddress
                        );
                    
                } else {
                    ElementType = TEXT("");
                    StartAddress = IpAddressToString(Elem->Elements[dw].Element.IpRange->StartAddress);
                    EndAddress = IpAddressToString(Elem->Elements[dw].Element.IpRange->EndAddress);
                }
                
                DisplayMessage(
                    g_hModule,
                    DMP_SCOPE_ADD_IPRANGE,
                    pwszServerIp,
                    IpAddressToString(SubnetInfo->SubnetAddress),
                    StartAddress,
                    EndAddress,
                    ElementType
                    );
            }

            if( Error is NO_ERROR )
                break;
            else
            {
                if( Elem ) DhcpRpcFreeMemory(Elem);
                if( Elements5 ) DhcpRpcFreeMemory(Elements5);
                Elem = NULL; Elements5 = NULL;
                continue;
            }
        }
                                             
    } // Add IP Ranges

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule,
                   DMP_SCOPE_ADD_IPRANGES_FOOTER,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress));

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule,
                   DMP_SCOPE_ADD_EXCLUDERANGES_HEADER,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress));

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);


    Resume = 0;
    dwRead = dwTotal = 0;
    
    //Add ExcludeRanges
    {
 
        while(TRUE)
        {
            Error = DhcpEnumSubnetElements((LPWSTR)pwszServerIp,
                                           SubnetInfo->SubnetAddress,
                                           DhcpExcludedIpRanges,
                                           &Resume,
                                           ~0,
                                           &Elem,
                                           &dwRead,
                                           &dwTotal);

            if( Error is ERROR_NO_MORE_ITEMS )
                break;

            if( Error is ERROR_NOT_ENOUGH_MEMORY )
            {
                goto ErrorReturn;
            }

            if( Error isnot NO_ERROR and
                Error isnot ERROR_MORE_DATA )
                break;



            for( dw=0; dw<dwRead && dw<Elem->NumElements ; dw++ )
            {
                DisplayMessage(g_hModule,
                               DMP_SCOPE_ADD_EXCLUDERANGE,
                               pwszServerIp,
                               IpAddressToString(SubnetInfo->SubnetAddress),
                               IpAddressToString(Elem->Elements[dw].Element.ExcludeIpRange->StartAddress),
                               IpAddressToString(Elem->Elements[dw].Element.ExcludeIpRange->EndAddress));


            }

            if( Error is NO_ERROR )
                break;
            else
            {
                DhcpRpcFreeMemory(Elem);
                Elem = NULL;
                continue;
            }
        }                                        
    }

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule,
                   DMP_SCOPE_ADD_EXCLUDERANGES_FOOTER,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress));

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    
    DisplayMessage(g_hModule,
                   DMP_SCOPE_SET_OPTIONVALUE_HEADER,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress));


    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);


    //Set Scope Optionvalues
    
    Resume = 0;
    dwRead = dwTotal = 0;

    ScopeInfo.ScopeType = DhcpSubnetOptions;
    ScopeInfo.ScopeInfo.SubnetScopeInfo = SubnetInfo->SubnetAddress;

    while(TRUE)
    {
        if( dwMajor >= CLASS_ID_VERSION )
        {
            Error = DhcpGetAllOptionValues(
                                            (LPWSTR)pwszServerIp,
                                            DHCP_OPT_ENUM_IGNORE_VENDOR,
                                            &ScopeInfo,
                                            &OptionValues
                                            );

            if( Error is ERROR_NO_MORE_ITEMS )
            {
                if( OptionValues )
                {
                    DhcpRpcFreeMemory(OptionValues);
                    OptionValues = NULL;
                }
                break;
            }
            
            if( Error is ERROR_NOT_ENOUGH_MEMORY )
            {
                goto ErrorReturn;
            }

            if( Error is NO_ERROR or
                Error is ERROR_MORE_DATA )
            {
                DhcpDumpServerOptionValuesV5(pwszServerIp,
                                             IpAddressToString(SubnetInfo->SubnetAddress),
                                             NULL,
                                             OptionValues);

                if( OptionValues )
                {
                    DhcpRpcFreeMemory(OptionValues);
                    OptionValues = NULL;
                }

                if( Error is NO_ERROR )
                    break;
                else
                {
                    continue;
                }
            }
            else
                break;
        }
        else
        {
             Error = DhcpEnumOptions(
                            (LPWSTR)pwszServerIp,
                            &Resume,
                            ~0,
                            &OptionsArray,
                            &dwRead,
                            &dwTotal);
        
            if( Error is ERROR_NO_MORE_ITEMS )
            {
                Error = NO_ERROR;
                if( OptionsArray )
                {
                    DhcpRpcFreeMemory(OptionsArray);
                    OptionsArray = NULL;
                }
                break;
            }

            if( Error is ERROR_NOT_ENOUGH_MEMORY )
            {
                goto ErrorReturn;
            }

            if( Error isnot NO_ERROR  &&
                Error isnot ERROR_MORE_DATA )
                break;

            for( dw = 0; dw < dwRead; dw++ )
            {
                DHCP_OPTION_ID OptionId = OptionsArray->Options[dw].OptionID;
                DWORD          dwError = NO_ERROR;
                dwError = DhcpGetOptionValue(
                                             (LPWSTR)pwszServerIp,
                                             OptionId,
                                             &ScopeInfo,
                                             &OptionValue);
                               
                if( dwError isnot NO_ERROR )
                {
                    continue;
                }
        
                if( OptionValue )
                {
                    dwError = DhcpDumpServerOptionValue(pwszServerIp,
                                              IpAddressToString(SubnetInfo->SubnetAddress),
                                              NULL,
                                              NULL,
                                              NULL,
                                              FALSE,
                                              *OptionValue);
                    DhcpRpcFreeMemory(OptionValue);
                    OptionValue = NULL;
                    if( dwError is ERROR_NOT_ENOUGH_MEMORY )
                    {
                        Error = dwError;
                        goto ErrorReturn;
                    }
                }
            }
    
            if( OptionsArray )
            {
                DhcpRpcFreeMemory(OptionsArray);
                OptionsArray = NULL;
            }
            if( Error is NO_ERROR )
                break;
            else
                continue;
        }
                        
    }

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule,
                   DMP_SCOPE_SET_OPTIONVALUE_FOOTER,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress));

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    
    DisplayMessage(g_hModule,
                   DMP_SCOPE_SET_RESERVEDIP_HEADER,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress));


    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    Resume = 0;
    dwRead = dwTotal = 0;
    
    while( TRUE ) 
    {
        Elements5 = NULL;
        Elements4 = NULL;
        dwRead = dwTotal = 0;
        
        if( dwMajor >= CLASS_ID_VERSION ) 
        {
            Error = DhcpEnumSubnetElementsV5(
                (LPWSTR)pwszServerIp,
                SubnetInfo->SubnetAddress,
                DhcpReservedIps,
                &Resume,
                ~0,
                &Elements5,
                &dwRead,
                &dwTotal
                );
        } 
        else 
        {
            Error = DhcpEnumSubnetElementsV4(
                (LPWSTR)pwszServerIp,
                SubnetInfo->SubnetAddress,
                DhcpReservedIps,
                &Resume,
                ~0,
                &Elements4,
                &dwRead,
                &dwTotal
                );
        }

        if( Error is ERROR_NO_MORE_ITEMS )
        {
            if( Elements5 )
            {
                DhcpRpcFreeMemory(Elements5);
                Elements5 = NULL;
            }

            if( Elements4 )
            {
                DhcpRpcFreeMemory(Elements4);
                Elements4 = NULL;
            }

            break;
        }

        if( Error is ERROR_NOT_ENOUGH_MEMORY )
        {
            goto ErrorReturn;
        }

        if( Error isnot NO_ERROR and
            Error isnot ERROR_MORE_DATA )
        {
            break;
        }

        // dump reservations
        do {

            for( i = 0; i < dwRead ; i ++ ) 
            {
                DWORD DataLength, AllocLen, n = 0;
                LPBYTE Data;
                DWORD  k=0;
                WCHAR  IpAddress[MAX_IP_STRING_LEN+1] = {L'\0'};
                LPWSTR pwszComment = L"";
                LPWSTR pwszName = L"";
                LPWSTR pwszType = L"";
                LPWSTR wcData = NULL;
                DHCP_SEARCH_INFO SearchInfo = {0};
                LPDHCP_CLIENT_INFO_V4 ClientInfo = NULL;
                DHCP_IP_RESERVATION_V4 *pResrv;

                if( dwMajor >= CLASS_ID_VERSION )
                {
                    DataLength = Elements5->Elements[i].Element.ReservedIp->ReservedForClient->DataLength;
                    Data = Elements5->Elements[i].Element.ReservedIp->ReservedForClient->Data;
                    pResrv = Elements5->Elements[ i ].Element.ReservedIp;
                }
                else {
                    DataLength = Elements4->Elements[i].Element.ReservedIp->ReservedForClient->DataLength;
                    Data = Elements4->Elements[i].Element.ReservedIp->ReservedForClient->Data;
                    pResrv = Elements4->Elements[ i ].Element.ReservedIp;
                }

                // Allocate space for 2 hex chars + NULL
                AllocLen = DataLength * 2 + 1;
                wcData = DhcpAllocateMemory( AllocLen * sizeof( WCHAR ));
                if ( NULL == wcData ) {
                    continue;
                }

                j=0;

                while( j < DataLength )
                {
                    // Ignore result
                    StringCchPrintf( wcData + n, AllocLen - n,
                                     L"%.2x", ( DWORD ) Data[ j ]);
                    n +=2; // xx
                    j++;
                }

                memcpy( IpAddress, IpAddressToString( pResrv->ReservedIpAddress ),
                        sizeof( IpAddress ) - sizeof( WCHAR ));

                IpAddress[ 15 ] = L'\0';

                SearchInfo.SearchType = DhcpClientIpAddress;
                SearchInfo.SearchInfo.ClientIpAddress = pResrv->ReservedIpAddress;

                Error = DhcpGetClientInfoV4( g_ServerIpAddressUnicodeString,
                                             &SearchInfo,
                                             &ClientInfo);

                if( Error isnot NO_ERROR ) {
                    DhcpFreeMemory( wcData );
                    continue;
                }

                pwszName = ClientInfo->ClientName;
                ClientInfo->bClientType = pResrv->bAllowedClientTypes;

                if( pwszName is NULL )
                {
                    pwszName = L"";
                    pwszComment = L"";
                    pwszType = L"";
                }
                else
                {
                    pwszComment = ClientInfo->ClientComment;
                    if( pwszComment is NULL )
                    {
                        pwszComment = L"";
                        pwszType = L"";
                    }
                    else
                    {
                        switch(ClientInfo->bClientType)
                        {
                        case CLIENT_TYPE_DHCP:
                        {
                            pwszType = L"DHCP";
                            break;
                        }
                        case CLIENT_TYPE_BOOTP:
                        {
                            pwszType = L"BOOTP";
                            break;
                        }
                        case CLIENT_TYPE_BOTH:
                        default:
                        {
                            pwszType = L"BOTH";
                            break;
                        }
                        }
                    }
                } // else
                DisplayMessage(g_hModule, 
                               DMP_SCOPE_ADD_RESERVEDIP,
                               pwszServerIp,
                               IpAddressToString(SubnetInfo->SubnetAddress),
                               IpAddress,
                               wcData+10,
                               pwszName,
                               pwszComment,
                               pwszType);

                Error = DhcpDumpReservedOptionValues(pwszServerIp,
                                                     dwMajor,
                                                     dwMinor,
                                                     IpAddressToString(SubnetInfo->SubnetAddress),
                                                     IpAddress);

                if( ClientInfo )
                {
                    DhcpRpcFreeMemory(ClientInfo);
                    ClientInfo = NULL;
                }


                if( Error is ERROR_NOT_ENOUGH_MEMORY )
                {
                    DhcpFreeMemory( wcData );
                    goto ErrorReturn;
                }
            } // for

        } while ( 0 ); // print UID

        if( Elements4 ) 
        {
            DhcpRpcFreeMemory( Elements4 );
            Elements4 = NULL;
        }

        if( Elements5 )
        {
            DhcpRpcFreeMemory( Elements5 );
            Elements5 = NULL;
        }
        
        if( Error is NO_ERROR )
        {
             break;
        }
        else
            continue;
    }

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule,
                   DMP_SCOPE_SET_RESERVEDIP_FOOTER,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress));

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

CommonReturn:

    if( Elem )
    {
        DhcpRpcFreeMemory(Elem);
        Elem = NULL;
    }

    if( Elements4 )
    {
        DhcpRpcFreeMemory(Elements4);
        Elements4 = NULL;
    }

    if( Elements5 )
    {
        DhcpRpcFreeMemory(Elements5);
        Elements5 = NULL;
    }

    if( OptionValues )
    {
        DhcpRpcFreeMemory(OptionValues);
        OptionValues = NULL;
    }

    if( OptionArray )
    {
        DhcpRpcFreeMemory(OptionArray);
        OptionArray = NULL;
    }
    
    if( OptionValue )
    {
        DhcpRpcFreeMemory(OptionValue);
        OptionValue = NULL;
    }

    if( SubnetInfo )
    {
        DhcpRpcFreeMemory(SubnetInfo);
        SubnetInfo = NULL;
    }
    if( OptionsArray )
    {
        DhcpRpcFreeMemory(OptionsArray);
        OptionsArray = NULL;
    }
    return Error;

ErrorReturn:
    goto CommonReturn;

}


DWORD
DhcpDumpServerMScope(
                     IN LPCWSTR pwszServer,
                     IN DWORD   dwMajor,
                     IN DWORD   dwMinor,
                     IN LPCWSTR pwszMScope)
{

    DWORD                               Error = NO_ERROR;
    LPDHCP_MSCOPE_INFO                  MScopeInfo = NULL;
    DHCP_RESUME_HANDLE                  Resume = 0;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Element = NULL;
    DWORD                               dw = 0,
                                        dwRead = 0,
                                        dwTotal = 0,
                                        dwLen = 0;
    WCHAR                               Name[256] = {L'\0'},
                                        Comment[256] = {L'\0'};
    LPWSTR                              pwcTemp = NULL;
    DHCP_OPTION_SCOPE_INFO              ScopeInfo = {0};
    LPDHCP_OPTION_VALUE                 Value = NULL;
    DHCP_OPTION_ID                      OptionId = 1; //Lease time    
    DATE_TIME                           InfTime;

    if( pwszMScope is NULL )
        return NO_ERROR;
    
    Error = DhcpGetMScopeInfo((LPWSTR)pwszServer,
                              (LPWSTR)pwszMScope,
                              &MScopeInfo);

    if( Error isnot NO_ERROR )
        return Error;


    if( MScopeInfo->MScopeComment )
    {
        Comment[0] = L'\"';
        dw = wcslen(MScopeInfo->MScopeComment);
        wcsncpy(Comment+1, MScopeInfo->MScopeComment, (dw>252)?252:dw);
        dw = wcslen(Comment);
        Comment[dw] = L'\"';
        Comment[dw+1] = L'\0';
    }


    if( MScopeInfo->MScopeName )
    {
        Name[0] = L'\"';
        dw = wcslen(MScopeInfo->MScopeName);
        wcsncpy(Name+1, MScopeInfo->MScopeName, (dw>252)?252:dw);
        dw = wcslen(Name);
        Name[dw] = L'\"';
        Name[dw+1] = L'\0';
    }

    DisplayMessage(g_hModule,
                   DMP_SRVR_ADD_MSCOPE,
                   pwszServer,
                   Name,
                   Comment,
                   (DWORD)MScopeInfo->TTL);

    DisplayMessage(g_hModule,
                   DMP_MSCOPE_SET_STATE,
                   pwszServer,
                   Name,
                   ( MScopeInfo->MScopeState == DhcpSubnetEnabled ) ? 1 : 0);

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    

    InfTime = DhcpCalculateTime(INFINIT_LEASE);
    if( !memcmp(&InfTime, &MScopeInfo->ExpiryTime, sizeof(InfTime)) )
    {
        //
        // No expiry time set.. 
        //
    }
    else
    {
        DisplayMessage(
            g_hModule,
            DMP_SRVR_MSCOPE_SET_EXPIRY,
            pwszServer,
            MScopeInfo->MScopeName,
            MScopeInfo->ExpiryTime.dwHighDateTime,
            MScopeInfo->ExpiryTime.dwLowDateTime
            );
    }
    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    Resume = 0;
    dwRead = dwTotal = 0;

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule,
                   DMP_MSCOPE_ADD_IPRANGES_HEADER,
                   pwszServer,
                   Name);

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    //Add ipranges
    {
        while(TRUE)
        {
            Error = DhcpEnumMScopeElements((LPWSTR)pwszServer,
                                           MScopeInfo->MScopeName,
                                           DhcpIpRanges,
                                           &Resume,
                                           ~0,
                                           &Element,
                                           &dwRead,
                                           &dwTotal);

            if( Error is ERROR_NO_MORE_ITEMS )
            {
                if( Element )
                {
                    DhcpRpcFreeMemory(Element);
                    Element = NULL;
                }
                break;
            }

            if( Error is ERROR_NOT_ENOUGH_MEMORY )
                goto CommonReturn;

            if( Error isnot NO_ERROR and
                Error isnot ERROR_MORE_DATA )
            {
                if( Element )
                {
                    DhcpRpcFreeMemory(Element);
                    Element = NULL;
                }
                break;
            }

            //Now get the default Lease duration
            {

                ScopeInfo.ScopeType = DhcpMScopeOptions;
                ScopeInfo.ScopeInfo.MScopeInfo =  MScopeInfo->MScopeName;

                Error = DhcpGetOptionValue(g_ServerIpAddressUnicodeString,
                                           OptionId,
                                           &ScopeInfo,
                                           &Value);
                if( Error isnot NO_ERROR )
                {
                    DisplayErrorMessage(g_hModule,
                                        EMSG_SCOPE_DEFAULT_LEASE_TIME,
                                        Error);
                    goto CommonReturn;
                }
            }
            
            for( dw=0; dw<dwRead && dw<Element->NumElements; dw++ )
            {

                DisplayMessage(g_hModule,
                               DMP_MSCOPE_ADD_IPRANGE,
                               pwszServer,
                               Name,
                               IpAddressToString(Element->Elements[dw].Element.IpRange->StartAddress),
                               IpAddressToString(Element->Elements[dw].Element.IpRange->EndAddress),
                               Value ? Value->Value.Elements[0].Element.DWordOption : DEFAULT_BOOTP_LEASE);
            }
            
            DhcpRpcFreeMemory(Element);
            Element = NULL;

            if( Error is NO_ERROR )
                break;
            else
                continue;

        }
                                        
    }

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule,
                   DMP_MSCOPE_ADD_IPRANGES_FOOTER,
                   pwszServer,
                   Name);


    DisplayMessage(g_hModule,
                   DMP_MSCOPE_ADD_EXCLUDERANGES_HEADER,
                   pwszServer,
                   Name);

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    Resume = 0;
    //Add ipranges
    {
        while(TRUE)
        {
            Error = DhcpEnumMScopeElements((LPWSTR)pwszServer,
                                           MScopeInfo->MScopeName,
                                           DhcpExcludedIpRanges,
                                           &Resume,
                                           ~0,
                                           &Element,
                                           &dwRead,
                                           &dwTotal);

            if( Error is ERROR_NO_MORE_ITEMS )
            {
                if( Element )
                {
                    DhcpRpcFreeMemory(Element);
                    Element = NULL;
                }
                break;
            }

            if( Error is ERROR_NOT_ENOUGH_MEMORY )
                goto CommonReturn;

            if( Error isnot NO_ERROR and
                Error isnot ERROR_MORE_DATA )
            {
                if( Element )
                {
                    DhcpRpcFreeMemory(Element);
                    Element = NULL;
                }
                break;
            }
            
            for( dw=0; dw<dwRead && dw<Element->NumElements; dw++ )
            {
                DisplayMessage(g_hModule,
                               DMP_MSCOPE_ADD_EXCLUDERANGE,
                               pwszServer,
                               Name,
                               IpAddressToString(Element->Elements[dw].Element.ExcludeIpRange->StartAddress),
                               IpAddressToString(Element->Elements[dw].Element.ExcludeIpRange->EndAddress));
            }

            DhcpRpcFreeMemory(Element);
            Element = NULL;

            if( Error is NO_ERROR )
                break;
            else
                continue;

        }
                                        
    }

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule,
                   DMP_MSCOPE_ADD_EXCLUDERANGES_FOOTER,
                   pwszServer,
                   Name);

    memset(Name, 0x00, sizeof(Name));
    memset(Comment, 0x00, sizeof(Comment));

CommonReturn:
    
    if( MScopeInfo )
    {
        DhcpRpcFreeMemory(MScopeInfo);
        MScopeInfo = NULL;
    }

    if( Element )
    {
        DhcpRpcFreeMemory(Element);
        Element = NULL;
    }

    return Error;
}

DWORD
DhcpDumpReservedOptionValues(
                             IN LPCWSTR    pwszServer,
                             IN DWORD      dwMajor,
                             IN DWORD      dwMinor,
                             IN LPCWSTR    pwszScope,
                             IN LPCWSTR    pwszReservedIp
                             )
{

    DWORD                               Error = NO_ERROR,
                                        dw = 0, 
                                        dwLen = 0,
                                        dwRead = 0,
                                        dwTotal = 0,
                                        i =0, j = 0;
    DHCP_OPTION_SCOPE_INFO              ScopeInfo = {0};
    LPDHCP_ALL_OPTION_VALUES            OptionValues = NULL;
    LPDHCP_OPTION_VALUE_ARRAY           OptionArray = NULL;
    LPDHCP_OPTION_VALUE                 OptionValue = NULL;
    DHCP_RESUME_HANDLE                  Resume = 0;
    LPDHCP_OPTION_ARRAY                 OptionsArray = NULL;

    ScopeInfo.ScopeType = DhcpReservedOptions;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
    	StringToIpAddress(pwszScope);
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
    	StringToIpAddress( pwszReservedIp );

    if( ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress is INADDR_NONE )
    {
        return Error;
    }



    if( dwMajor >= CLASS_ID_VERSION )
    {
        Error = DhcpGetAllOptionValues(
                    (LPWSTR)pwszServer,
                    DHCP_OPT_ENUM_IGNORE_VENDOR,
                    &ScopeInfo,
                    &OptionValues
                    );

        if( Error isnot NO_ERROR and 
            Error isnot ERROR_MORE_DATA )
            return Error;
        
        if( OptionValues )
        {
            Error = DhcpDumpServerOptionValuesV5(pwszServer,
                                                 pwszScope,
                                                 pwszReservedIp,
                                                 OptionValues);    
            DhcpRpcFreeMemory(OptionValues);
            OptionValues = NULL;
        }
        return Error;
    }

    else
    {
        while( TRUE )
        {
            Error = DhcpEnumOptionValues(
                            (LPWSTR)pwszServer,
                            &ScopeInfo,
                            &Resume,
                            ~0,
                            &OptionArray,
                            &dwRead,
                            &dwTotal);
  
            if( Error is ERROR_NO_MORE_ITEMS )
            {
                if( OptionArray )
                {
                    DhcpRpcFreeMemory(OptionArray);
                    OptionArray = NULL;
                }
                Error = NO_ERROR;
                return Error;
            }

            if( Error isnot NO_ERROR and
                Error isnot ERROR_MORE_DATA )
            {
                return Error;
            }
        
            for( dw = 0; dw < dwRead; dw++ )
            {                      
               Error = DhcpDumpServerOptionValue(pwszServer,
                                                 pwszScope,
                                                 pwszReservedIp,
                                                 NULL,
                                                 NULL,
                                                 FALSE,
                                                 OptionArray->Values[dw]);

               if( Error isnot NO_ERROR )
                   break;
            }

            if( OptionArray )
            {
                DhcpRpcFreeMemory(OptionArray);
                OptionArray = NULL;
            }

            if( Error isnot NO_ERROR and
                Error isnot ERROR_MORE_DATA )
                return Error;

            if( Error is NO_ERROR )
                break;
            else
                continue;
        }
        
    }
    return Error;
}

VOID
DhcpDumpServerConfig(IN LPCWSTR pwszServer)
{
}

VOID
DhcpDumpScriptFooter()
{
    DisplayMessage(g_hModule,
                   DMP_DHCP_SCRIPTFOOTER);
}

VOID
DhcpDumpServerScriptFooter(IN LPCWSTR   pwszServer)
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_SERVER_FOOTER,
                   pwszServer);
 
}

DWORD
WINAPI
DhcpDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    return ERROR_SUCCESS;
}

VOID
DhcpDumpServerClassHeader()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_CLASS_HEADER);
}
VOID
DhcpDumpServerClassFooter()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_CLASS_FOOTER);
}

VOID
DhcpDumpServerOptiondefHeader()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_OPTIONDEF_HEADER);
}

VOID
DhcpDumpServerOptiondefFooter()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_OPTIONDEF_FOOTER);
}

VOID
DhcpDumpServerOptionvalueHeader()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_OPTIONVALUE_HEADER);
}

VOID
DhcpDumpServerOptionvalueFooter()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_OPTIONVALUE_FOOTER);
}

VOID
DhcpDumpServerScopeHeader()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_SCOPE_HEADER);
}

VOID
DhcpDumpServerScopeFooter()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_SCOPE_FOOTER);
}

VOID
DhcpDumpServerMScopeHeader()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_MSCOPE_HEADER);
}

VOID
DhcpDumpServerMScopeFooter()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_MSCOPE_FOOTER);
}

VOID
DhcpDumpServerSScopeHeader()
{
    DisplayMessage( g_hModule,
		    DMP_SRVR_SUPER_SCOPE_HEADER );
}

VOID
DhcpDumpServerSScopeFooter()
{
    DisplayMessage( g_hModule,
		    DMP_SRVR_SUPER_SCOPE_FOOTER );
}

VOID
DhcpDumpSuperScopes( IN LPCWSTR pwszServer, 
		     IN DWORD dwMajor, 
		     IN DWORD dwMinor )
{
    LPDHCP_SUPER_SCOPE_TABLE pTable;
    DWORD dwResult, i;

    const int OUT_STR_LEN = 256;
    pTable = NULL;
    
    DhcpDumpServerSScopeHeader();

    dwResult = DhcpGetSuperScopeInfoV4( (LPWSTR) pwszServer, &pTable );
    if ( ERROR_SUCCESS == dwResult ) {

	for ( i = 0; i < pTable->cEntries; i++ ) {

	    if ( NULL != pTable->pEntries[ i ].SuperScopeName ) {
		DisplayMessage( g_hModule,
				DMP_SRVR_ADD_SUPER_SCOPE,
				pwszServer,
				IpAddressToString( pTable->pEntries[ i ].SubnetAddress ),
				pTable->pEntries[ i ].SuperScopeName,
				1 );
	    } // if 
	} // for
    } // if 

    DisplayMessage( g_hModule,
		    MSG_DHCP_FORMAT_LINE );
    DhcpDumpServerSScopeFooter();
} // DhcpDumpSuperScopes()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\dhcp\mscopehndl.c ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/
#include "precomp.h"


extern ULONG g_ulMScopeNumTopCmds;
extern ULONG g_ulMScopeNumGroups;

extern CMD_GROUP_ENTRY      g_MScopeCmdGroups[];
extern CMD_ENTRY            g_MScopeCmds[];

extern DWORD  GlobalClientCount;

extern BOOL    GlobalVerbose;

#define DHCP_INFINIT_LEASE  0xffffffff  // Inifinite lease LONG value


DWORD
HandleMScopeList(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    i, j;

    for(i = 0; i < g_ulMScopeNumTopCmds-2; i++)
    {
        DisplayMessage(g_hModule, g_MScopeCmds[i].dwShortCmdHelpToken);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);


    for(i = 0; i < g_ulMScopeNumGroups; i++)
    {
        for(j = 0; j < g_MScopeCmdGroups[i].ulCmdGroupSize; j++)
        {
            DisplayMessage(g_hModule, g_MScopeCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);

            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
        }
        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    }

    return NO_ERROR;
}

DWORD
HandleMScopeHelp(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    i, j;

    for(i = 0; i < g_ulMScopeNumTopCmds-2; i++)
    {
        if(g_MScopeCmds[i].dwCmdHlpToken != MSG_DHCP_NULL)
        {
            DisplayMessage(g_hModule, g_MScopeCmds[i].dwShortCmdHelpToken);
        }
    }

    for(i = 0; i < g_ulMScopeNumGroups; i++)
    {
        DisplayMessage(g_hModule, g_MScopeCmdGroups[i].dwShortCmdHelpToken);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    return NO_ERROR;
}

DWORD
HandleMScopeDump(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD       Error = NO_ERROR;

    // 
    // Expected args :
    //    0 : mscope
    //    1 : "mscope name" 
    //    2 : dump 
    //

    if ( dwArgCount > 3 ) {
	DisplayErrorMessage( g_hModule, MSG_DHCP_NULL,
			     ERROR_INVALID_PARAMETER );
	Error = ERROR_INVALID_PARAMETER;
    }
    else {
	Error = DhcpDumpServerMScope( g_ServerIpAddressUnicodeString,
				      g_dwMajorVersion,
				      g_dwMinorVersion,
				      g_MScopeNameUnicodeString );
    }
    return Error;

} // HandleMScopeDump()

DWORD
HandleMScopeContexts(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return NO_ERROR;
    }

DWORD
HandleMScopeAddIprange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{ 
    DWORD                       Error = NO_ERROR;
    DHCP_IP_RANGE               IpRange;
    DHCP_SUBNET_ELEMENT_DATA_V4 Element;
    LPDHCP_MSCOPE_INFO MScopeInfo = NULL;
    DWORD                       dwExpiry = DEFAULT_BOOTP_LEASE;
    BOOL                        fExpiry = FALSE;
    //
    // Expected Parameters are : <MScopeName IpRangeStart IpRangeEnd [Expiry]>
    //

    memset(&Element, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));

    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_MSCOPE_ADD_IPRANGE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }


    IpRange.StartAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);
    IpRange.EndAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);

    if( IpRange.StartAddress is INADDR_NONE or 
        IpRange.EndAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    if( IpRange.StartAddress < MSCOPE_START_RANGE or
        IpRange.StartAddress > MSCOPE_END_RANGE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( IpRange.EndAddress < MSCOPE_START_RANGE or
        IpRange.EndAddress > MSCOPE_END_RANGE or
        IpRange.EndAddress < IpRange.StartAddress )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    Element.ElementType = DhcpIpRanges;
    Element.Element.IpRange = &IpRange;

    if( dwArgCount > 2 )
    {
        if( IsPureNumeric( ppwcArguments[dwCurrentIndex+2] ) is FALSE )
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        dwExpiry = STRTOUL(ppwcArguments[dwCurrentIndex+2], NULL, 10);
        if( dwExpiry <= 0 )
            dwExpiry = DEFAULT_BOOTP_LEASE;
        if( dwExpiry > INFINIT_LEASE )
            dwExpiry = INFINIT_LEASE;

        fExpiry = TRUE;
    }

    //Set the MScopeID & Expiry
    {

        Error = DhcpGetMScopeInfo(g_ServerIpAddressUnicodeString,
                                  g_MScopeNameUnicodeString,
                                  &MScopeInfo
                                  );

        if( Error isnot NO_ERROR )
        {
            goto ErrorReturn;
        }

        MScopeInfo->MScopeId = IpRange.StartAddress;

        //Since we are setting the MSCopeID here, let us first delete the MScope
        //and recreate it again.

        Error = DhcpDeleteMScope(g_ServerIpAddressUnicodeString,
                                 g_MScopeNameUnicodeString,
                                 DhcpFullForce);

        if( Error isnot NO_ERROR )
            goto ErrorReturn;

        Error = DhcpSetMScopeInfo(g_ServerIpAddressUnicodeString,
                                  g_MScopeNameUnicodeString,
                                  MScopeInfo,
                                  TRUE);
        if( Error isnot NO_ERROR )
            goto ErrorReturn;

        Error = DhcpAddMScopeElement( g_ServerIpAddressUnicodeString,
                                      g_MScopeNameUnicodeString,
                                      &Element );
    
        if( Error isnot NO_ERROR )
            goto ErrorReturn;

    }

    //Now set the default lease duration
    {
        DHCP_OPTION_SCOPE_INFO   ScopeInfo = {0};
        DHCP_OPTION_DATA_ELEMENT OptionData = {0};
        DHCP_OPTION_DATA         Option = {0};
        DHCP_OPTION_ID           OptionId = 1; //Lease time

        ScopeInfo.ScopeType = DhcpMScopeOptions;
        ScopeInfo.ScopeInfo.MScopeInfo =  g_MScopeNameUnicodeString;

        OptionData.OptionType = DhcpDWordOption;
        OptionData.Element.DWordOption = dwExpiry;


        Option.NumElements = 1;
        Option.Elements = &OptionData;

        Error = DhcpSetOptionValue(g_ServerIpAddressUnicodeString,
                                   OptionId,
                                   &ScopeInfo,
                                   &Option);
        if( Error isnot NO_ERROR )
        {
            DisplayErrorMessage(g_hModule,
                                EMSG_SCOPE_DEFAULT_LEASE_TIME,
                                Error);
            goto CommonReturn;
        }
    }

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if( MScopeInfo )
    {
        DhcpRpcFreeMemory(MScopeInfo);
        MScopeInfo = NULL;
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_MSCOPE_ADD_IPRANGE,
                        Error );
    goto CommonReturn;


}

DWORD
HandleMScopeAddExcluderange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                       Error = NO_ERROR;
    DHCP_IP_RANGE               ExcludeRange;
    DHCP_SUBNET_ELEMENT_DATA_V4 Element;
    BOOL                        fPresent = FALSE;

    //
    // Expected Parameters are : <MScopeName IpRangeStart IpRangeEnd>
    //
    
    memset(&Element, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));


    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_MSCOPE_ADD_EXCLUDERANGE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
        
    }
    ExcludeRange.StartAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);
    ExcludeRange.EndAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);

    if( ExcludeRange.StartAddress is INADDR_NONE or 
        ExcludeRange.EndAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }


    //Check to see if this is a valid exclusion range.
    {
        ULONG                               nRead, nTotal, i, nCount;
        ULONG                               Resume;
        LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Elements = NULL;
        BOOL                                fTable = FALSE;


        Resume = 0;
        nRead = nTotal = nCount = 0;

        while( TRUE ) 
        {
            Elements = NULL;
            nRead = nTotal = 0;
        
            Error = DhcpEnumMScopeElements(
                    g_ServerIpAddressUnicodeString,
                    g_MScopeNameUnicodeString,
                    DhcpIpRanges,
                    &Resume,
                    ~0,
                    &Elements,
                    &nRead,
                    &nTotal
                    );
        
            if( Error is ERROR_NO_MORE_ITEMS )
            {
                Error = NO_ERROR;
                break;
            }

            nCount+= nRead;

           
            if( ERROR isnot NO_ERROR and
                ERROR isnot ERROR_MORE_DATA )
            {
                DisplayMessage(g_hModule,
                               EMSG_MSCOPE_IPRANGE_VERIFY);
            }

            if( NO_ERROR is Error or
                ERROR_MORE_DATA is Error ) 
            {
                for( i = 0; i < nRead ; i ++ ) 
                {
                    if( ExcludeRange.StartAddress >= Elements->Elements[i].Element.IpRange->StartAddress and
                        ExcludeRange.EndAddress <= Elements->Elements[i].Element.IpRange->EndAddress )
                    {
                        fPresent = TRUE;
                    }
                }
            }

            DhcpRpcFreeMemory( Elements );
        
            Elements = NULL;

            if( Error is ERROR_MORE_DATA )
            {
                continue;
            }
            else
                break;
        }
        if( fPresent is FALSE )
        {
            DisplayMessage(g_hModule,
                           EMSG_SCOPE_INVALID_EXCLUDERANGE);

            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }



    Element.ElementType = DhcpExcludedIpRanges;
    Element.Element.IpRange = &ExcludeRange;
    


    Error = DhcpAddMScopeElement(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                &Element );

    if( Error isnot NO_ERROR )
        goto ErrorReturn;
CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_ADD_EXCLUDERANGE,
                        Error);
    goto CommonReturn;
}


DWORD
HandleMScopeCheckDatabase(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD            Error = NO_ERROR;
    LPDHCP_SCAN_LIST ScanList    = NULL;
   
   //
   // Expected Parameters are : <MScopeName>
   //

   Error = DhcpScanMDatabase(
               g_ServerIpAddressUnicodeString,
               g_MScopeNameUnicodeString,
               TRUE,        // fix bad entries.
               &ScanList );

   if( Error isnot ERROR_SUCCESS )
       goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if (ScanList) 
    {
        DhcpRpcFreeMemory( ScanList );
    }

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_CHECK_DATABASE,
                        Error);
    goto CommonReturn;

}

DWORD
HandleMScopeDeleteIprange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                         Error = NO_ERROR;
    DHCP_SUBNET_ELEMENT_DATA_V4   RemoveElementInfo;
    DHCP_FORCE_FLAG               bFlag = DhcpFullForce;
    DHCP_IP_RANGE                 IpRange;
    //
    //Expected parameters <start-ip-range> <end-ip-range>
    //

    memset(&RemoveElementInfo, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));
    memset(&IpRange, 0x00, sizeof(DHCP_IP_RANGE));
    
    if( dwArgCount < 2 )
    {
        DisplayMessage(g_hModule, HLP_MSCOPE_DELETE_IPRANGE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    IpRange.StartAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);
    IpRange.EndAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);

    if( IpRange.StartAddress is INADDR_NONE or 
        IpRange.EndAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    RemoveElementInfo.ElementType = DhcpIpRanges;
    RemoveElementInfo.Element.IpRange = &IpRange;

    Error = DhcpRemoveMScopeElement(g_ServerIpAddressUnicodeString,
                                    g_MScopeNameUnicodeString, 
                                    &RemoveElementInfo,
                                    bFlag);
    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;
CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return Error;

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_DELETE_IPRANGE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleMScopeDeleteExcluderange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                         Error = NO_ERROR;
    DHCP_SUBNET_ELEMENT_DATA_V4   RemoveElementInfo;
    DHCP_FORCE_FLAG               bFlag = DhcpFullForce;
    DHCP_IP_RANGE                 IpRange;
    //
    //Expected parameters <start-ip-range> <end-ip-range>
    //

    memset(&RemoveElementInfo, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));
    memset(&IpRange, 0x00, sizeof(DHCP_IP_RANGE));

    if( dwArgCount < 2 )
    {
        DisplayMessage(g_hModule, HLP_MSCOPE_DELETE_EXCLUDERANGE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    IpRange.StartAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);
    IpRange.EndAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);

    if( IpRange.StartAddress is INADDR_NONE or 
        IpRange.EndAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    RemoveElementInfo.ElementType = DhcpExcludedIpRanges;
    RemoveElementInfo.Element.ExcludeIpRange = &IpRange;

    Error = DhcpRemoveMScopeElement(g_ServerIpAddressUnicodeString,
                                    g_MScopeNameUnicodeString, 
                                    &RemoveElementInfo,
                                    bFlag);
    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;
CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return Error;

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_DELETE_EXCLUDERANGE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleMScopeDeleteOptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD             Error = NO_ERROR;
    DHCP_OPTION_ID          OptionID;
    DHCP_OPTION_SCOPE_INFO  ScopeInfo;
    

    LPWSTR         pwcTag = NULL;
    LPWSTR         pwcUser = NULL;   
    LPWSTR         pwcVendor = NULL;
    LPWSTR         pwcTemp = NULL;

    BOOL           fUser = FALSE;
    BOOL           fVendor = FALSE;

    DWORD          dwIndex = 0;

    //
    // Expected Parameters are :
    // subnet-address <OptionID>
    //

    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));


    if( dwArgCount < 1 ) 
    {
        DisplayMessage(g_hModule, HLP_MSCOPE_DELETE_OPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    ScopeInfo.ScopeType = DhcpMScopeOptions;
    ScopeInfo.ScopeInfo.MScopeInfo =  g_MScopeNameUnicodeString;

    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    OptionID = STRTOUL( ppwcArguments[dwCurrentIndex], NULL, 10 );

    dwIndex = 1;
    while( TRUE )
    {
        LPWSTR      pwcStr = NULL;
        if( dwArgCount <= dwIndex )
            break;

        if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER)  )
            break;

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
        {
            if( fUser is TRUE ) //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcUser = NULL;
                else
                {
                    pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcUser is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcUser, pwcStr);
                }
                fUser = TRUE;
            }
        }
        else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
            return ERROR_INVALID_PARAMETER;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }
        
        dwIndex++;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }

    Error = RemoveOptionValue(
        g_ServerIpAddressUnicodeString,
        0,
        (DHCP_OPTION_ID)OptionID,
        pwcUser,
        pwcVendor,
        &ScopeInfo
    );
       
    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if( pwcUser )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    if( pwcVendor )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_DELETE_OPTIONVALUE,
                        Error);

    goto CommonReturn;
}


DWORD
HandleMScopeSetState(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD               Error = NO_ERROR;
    LPDHCP_MSCOPE_INFO  MScopeInfo = NULL;
    DWORD               State = 0;
    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_MSCOPE_SET_STATE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( IsPureNumeric( ppwcArguments[dwCurrentIndex] ) is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    Error = DhcpGetMScopeInfo( g_ServerIpAddressUnicodeString,
                               g_MScopeNameUnicodeString,
                               &MScopeInfo);
    
    if( Error isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    State = STRTOUL( ppwcArguments[dwCurrentIndex], NULL, 0 );

    if( State == 0 ) 
    {
        if( MScopeInfo->MScopeState == DhcpSubnetDisabled ) 
        {
            Error = NO_ERROR;
            goto CommonReturn;
        }
        MScopeInfo->MScopeState = DhcpSubnetDisabled;
    }
    else if( State == 1 )
    {
        if( MScopeInfo->MScopeState == DhcpSubnetEnabled ) 
        {
            Error = NO_ERROR;
            goto CommonReturn;
        }
        MScopeInfo->MScopeState = DhcpSubnetEnabled;
    }
    else
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    Error = DhcpSetMScopeInfo( g_ServerIpAddressUnicodeString,
                               g_MScopeNameUnicodeString,
                               MScopeInfo,
                               FALSE);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( MScopeInfo )
    {
        DhcpRpcFreeMemory(MScopeInfo);
        MScopeInfo = NULL;
    }
    DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    return Error;

ErrorReturn:
    
    DisplayErrorMessage(g_hModule, 
                        EMSG_MSCOPE_SET_STATE,
                        Error);

    goto CommonReturn;
}   

DWORD
HandleMScopeSetOptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD              Error = NO_ERROR;
    DHCP_OPTION_ID           OptionID;
    DHCP_OPTION_SCOPE_INFO   ScopeInfo;
    DHCP_OPTION_DATA         OptionValue;
    DHCP_OPTION_DATA_ELEMENT OptionData;
    DHCP_OPTION_DATA_TYPE    OptionType;
    LPWSTR                   UnicodeOptionValueString = NULL;
    LPDHCP_OPTION            OptionInfo = NULL;
    LPWSTR                   OptionTypeString = NULL;

    LPWSTR                   pwcTag = NULL;
    LPWSTR                   pwcUser = NULL;
    LPWSTR                   pwcVendor = NULL;
    LPWSTR                   pwcTemp = NULL;

    BOOL                     fUser = FALSE;
    BOOL                     fVendor = FALSE;
    BOOL                     fValidType = FALSE;

    DWORD                    i = 0;
    DWORD                    dwIndex = 0;

    //
    // Expected Parameters are :
    // subnet-address <OptionID OptionType OptionValue>
    //

    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));
    memset(&OptionValue, 0x00, sizeof(DHCP_OPTION_DATA));
    memset(&OptionData, 0x00, sizeof(DHCP_OPTION_DATA_ELEMENT));


    if( dwArgCount < 3 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_SET_OPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    
    ScopeInfo.ScopeType = DhcpMScopeOptions;
    ScopeInfo.ScopeInfo.MScopeInfo =  g_MScopeNameUnicodeString;

    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex+dwIndex]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    OptionID = STRTOUL( ppwcArguments[dwCurrentIndex+dwIndex], NULL, 10 );
    
    dwIndex++;

    OptionTypeString = ppwcArguments[dwCurrentIndex+dwIndex];

    dwIndex++;

    while( NULL isnot wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER) )
    {
        LPWSTR  pwcStr = NULL;
        if( dwArgCount <= dwIndex + 1 )
        {
            DisplayMessage(g_hModule, HLP_SRVR_SET_OPTIONVALUE_EX);
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
        {
            if( fUser is TRUE ) //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcUser = NULL;
                else
                {
                    pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcUser is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcUser, pwcStr);
                }
                fUser = TRUE;
            }
        }
        else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
            return ERROR_INVALID_PARAMETER;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }
        
        dwIndex++;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }

    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {
        Error = DhcpGetOptionInfoV5(g_ServerIpAddressUnicodeString,
                                    fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                    OptionID,
                                    NULL,
                                    pwcVendor,
                                    &OptionInfo);
    }
    else
    {
    
        Error = DhcpGetOptionInfo(g_ServerIpAddressUnicodeString,
                                  OptionID,
                                  &OptionInfo);
    }

    if( Error isnot NO_ERROR )
        return Error;

    //Check if OptionType supplied is the same as defined.

    //Find out the OptionType
    for(i=0; i < sizeof(TagOptionType)/sizeof(COMMAND_OPTION_TYPE); i++)
    {
        if( MatchToken(OptionTypeString, TagOptionType[i].pwszTagID) )
        {
            OptionType = TagOptionType[i].DataType;
            fValidType = TRUE;
            break;
        }
    }
    
    if( fValidType is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( OptionType isnot OptionInfo->DefaultValue.Elements[0].OptionType )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_INVALID_OPTIONTYPE);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    
    switch(OptionInfo->OptionType)
    {
    case DhcpArrayTypeOption:
        {
            Error = SetOptionDataTypeArray(
                            OptionType,
                            ppwcArguments+dwCurrentIndex,
                            dwIndex,
                            dwArgCount, //Corrections
                            &OptionValue);
            if( Error isnot NO_ERROR )
                goto ErrorReturn;
            break;
        }
    case DhcpUnaryElementTypeOption:
    default:
        {

            Error = SetOptionDataType(
                        OptionType,
                        ppwcArguments[dwCurrentIndex+dwIndex],
                        &OptionData,
                        &UnicodeOptionValueString );

            if( Error != NO_ERROR ) 
            {
                goto ErrorReturn;
            }

            OptionValue.NumElements = 1;
            OptionValue.Elements = &OptionData;
            break;
        }
    }
        
    Error = SetOptionValue(
        g_ServerIpAddressUnicodeString,
        fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
        (DHCP_OPTION_ID)OptionID,
        pwcUser,
        pwcVendor,
        &ScopeInfo,
        &OptionValue
    );

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    
    if( OptionInfo )
    {
        if(OptionInfo->OptionType is DhcpArrayTypeOption)
        {
            if( OptionValue.Elements isnot NULL )
            {
                free(OptionValue.Elements);
                OptionValue.Elements = NULL;
            }
        }
    }

    if( pwcUser )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    if( pwcVendor )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                   EMSG_SCOPE_SET_OPTIONVALUE,
                   Error);

    goto CommonReturn;

}


DWORD
HandleMScopeSetMScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_MSCOPE_SET_MSCOPE_EX);
        DisplayErrorMessage(g_hModule,
                            EMSG_MSCOPE_SET_MSCOPE,
                            ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
                            
    }
    if( SetMScopeInfo(ppwcArguments[dwCurrentIndex]))
    {
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
        return NO_ERROR;
    }
    else
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_MSCOPE_SET_MSCOPE,
                            ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }
}

DWORD
HandleMScopeSetName(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD              Error = ERROR_SUCCESS;
    LPDHCP_MSCOPE_INFO MScopeInfo = NULL;
    
    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_MSCOPE_SET_NAME_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    Error = DhcpGetMScopeInfo(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                &MScopeInfo );

    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;
    
    DhcpAssert(MScopeInfo isnot NULL);

    
    MScopeInfo->MScopeName = ppwcArguments[dwCurrentIndex];

    Error = DhcpSetMScopeInfo(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                MScopeInfo,
				FALSE);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    SetMScopeInfo(ppwcArguments[dwCurrentIndex]);

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if( MScopeInfo != NULL )
    {
        DhcpRpcFreeMemory( MScopeInfo );
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_MSCOPE_SET_NAME,
                        Error);
    goto CommonReturn;
}

DWORD
HandleMScopeSetComment(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD              Error = ERROR_SUCCESS;
    LPDHCP_MSCOPE_INFO MScopeInfo = NULL;

    Error = DhcpGetMScopeInfo(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                &MScopeInfo );
    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;
    
    DhcpAssert(MScopeInfo isnot NULL);

    
    if( dwArgCount < 1 )
    {
        MScopeInfo->MScopeComment = NULL;
    }
    else
    {
        MScopeInfo->MScopeComment = ppwcArguments[dwCurrentIndex];
    }

    Error = DhcpSetMScopeInfo(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                MScopeInfo,
				FALSE);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    if( MScopeInfo != NULL )
    {
        DhcpRpcFreeMemory( MScopeInfo );
    }
    return( Error );

ErrorReturn:

    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_SET_COMMENT,
                        Error);
    
    goto CommonReturn;
}

DWORD
HandleMScopeSetTTL(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD              Error = ERROR_SUCCESS;
    LPDHCP_MSCOPE_INFO MScopeInfo = NULL;
    DWORD              dwTTL = 255;
    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_MSCOPE_SET_TTL_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( IsPureNumeric(ppwcArguments[dwCurrentIndex]) is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwTTL = STRTOUL(ppwcArguments[dwCurrentIndex], NULL, 10);

    if( dwTTL <= 0 )
        dwTTL = 1;

    if( dwTTL > 255 )
        dwTTL = 255;

    Error = DhcpGetMScopeInfo(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                &MScopeInfo );

    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;
    
    
    MScopeInfo->TTL = (BYTE)dwTTL;

    Error = DhcpSetMScopeInfo(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                MScopeInfo,
				FALSE);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if( MScopeInfo != NULL )
    {
        DhcpRpcFreeMemory( MScopeInfo );
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_MSCOPE_SET_TTL,
                        Error);
    goto CommonReturn;
}

DWORD
HandleMScopeSetExpiry(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD              Error = ERROR_SUCCESS;
    LPDHCP_MSCOPE_INFO MScopeInfo = NULL;
    DWORD              dwExpiry = 0;
    DWORD              dwExpiry2 = 0;

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_MSCOPE_SET_EXPIRY_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( IsPureNumeric(ppwcArguments[dwCurrentIndex]) is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( dwArgCount >= 2 &&
        IsPureNumeric(ppwcArguments[dwCurrentIndex]) is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
                                   
    Error = DhcpGetMScopeInfo(
        g_ServerIpAddressUnicodeString,
        g_MScopeNameUnicodeString,
        &MScopeInfo
        );
    
    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;        
    
    dwExpiry = STRTOUL(ppwcArguments[dwCurrentIndex], NULL, 10);

    if( dwArgCount >= 2 )
    {
        //
        // One more arg -- this is absolute time 
        //

        dwExpiry2 = STRTOUL(ppwcArguments[dwCurrentIndex+1], NULL, 10);

        MScopeInfo->ExpiryTime.dwHighDateTime = dwExpiry;
        MScopeInfo->ExpiryTime.dwLowDateTime = dwExpiry2;
        
    } else {

        //
        // Only one parameter -- relative time in hours
        //
        
        if( dwExpiry == 0 ) {
            dwExpiry = INFINIT_LEASE;
        } else {
            dwExpiry *= 60 * 60;
        }

        MScopeInfo->ExpiryTime = DhcpCalculateTime(dwExpiry);
    }
    
    Error = DhcpSetMScopeInfo(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                MScopeInfo,
				FALSE);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if( MScopeInfo != NULL )
    {
        DhcpRpcFreeMemory( MScopeInfo );
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_MSCOPE_SET_EXPIRY,
                        Error);
    goto CommonReturn;
}

DWORD
HandleMScopeSetLease(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                    Error = ERROR_SUCCESS;
    DHCP_OPTION_SCOPE_INFO   ScopeInfo = {0};
    DHCP_OPTION_DATA_ELEMENT OptionData = {0};
    DHCP_OPTION_DATA         Option = {0};
    DHCP_OPTION_ID           OptionId = 1; //Lease time
    DWORD                    dwExpiry = 0;

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_MSCOPE_SET_LEASE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //if -1 => Infinite lease
    if( wcscmp(ppwcArguments[dwCurrentIndex], L"-1") is 0 )
    {
        dwExpiry = DHCP_INFINIT_LEASE;
    }
    //else if not proper numeric value, return Bad parameter
    else if( IsPureNumeric(ppwcArguments[dwCurrentIndex]) is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    else
    {
        dwExpiry = STRTOUL(ppwcArguments[dwCurrentIndex], NULL, 10);
    }

    ScopeInfo.ScopeType = DhcpMScopeOptions;
    ScopeInfo.ScopeInfo.MScopeInfo =  g_MScopeNameUnicodeString;

    OptionData.OptionType = DhcpDWordOption;
    OptionData.Element.DWordOption = dwExpiry;


    Option.NumElements = 1;
    Option.Elements = &OptionData;

    Error = DhcpSetOptionValue(g_ServerIpAddressUnicodeString,
                               OptionId,
                               &ScopeInfo,
                               &Option);
    if( Error isnot ERROR_SUCCESS )
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_MSCOPE_SET_LEASE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleMScopeShowClients(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                     Error = NO_ERROR;
    DHCP_RESUME_HANDLE        ResumeHandle = 0;
    LPDHCP_MCLIENT_INFO_ARRAY ClientEnumInfo = NULL;
    DWORD                     ClientsRead = 0;
    DWORD                     ClientsTotal = 0;
    DWORD                     nCount = 0;
    DWORD                     i;

    //
    // Expected Parameters are : <MScopeNames>
    //
    
    GlobalClientCount = 1;

    for(;;) 
    {

        ClientEnumInfo = NULL;
        Error = DhcpEnumMScopeClients(
                    g_ServerIpAddressUnicodeString,
                    g_MScopeNameUnicodeString,
                    &ResumeHandle,
                    ~0,
                    &ClientEnumInfo,
                    &ClientsRead,
                    &ClientsTotal );

        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule,
                           MSG_MSCOPE_CLIENTS_COUNT,
                           nCount,
                           g_MScopeNameUnicodeString);

            Error = NO_ERROR;
            break;
        }

        if( Error isnot ERROR_SUCCESS and
            Error isnot ERROR_MORE_DATA ) 
        {
            goto ErrorReturn;
        }

        DhcpAssert( ClientEnumInfo != NULL );
        DhcpAssert( ClientEnumInfo->NumElements == ClientsRead );
        
        nCount += ClientsRead;

        if( GlobalVerbose )
        {

            for( i = 0; i < ClientsRead; i++ )
            {
                PrintMClientInfo(ClientEnumInfo->Clients[i]);
            }
        }
        else
        {
            for( i = 0; i < ClientsRead; i++ ) 
            {
                PrintMClientInfoShort(ClientEnumInfo->Clients[i]);
            }
            
        }
        

        DhcpRpcFreeMemory( ClientEnumInfo );
        ClientEnumInfo = NULL;


        if( Error is ERROR_MORE_DATA ) 
        {
            continue;
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_MSCOPE_CLIENTS_COUNT,
                           nCount,
                           g_MScopeNameUnicodeString);
            break;
        }

    }
    if( Error isnot ERROR_SUCCESS )
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_SHOW_CLIENTS,
                        Error);

    goto CommonReturn;
}


DWORD
HandleMScopeShowIprange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                               Error = NO_ERROR;
    ULONG                               nRead, nTotal, i, nCount;
    ULONG                               Resume;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Elements = NULL;
    BOOL                                fTable = FALSE;


    Resume = 0;
    nRead = nTotal = nCount = 0;

    while( TRUE ) 
    {
        Elements = NULL;
        nRead = nTotal = 0;
        
        Error = DhcpEnumMScopeElements(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                DhcpIpRanges,
                &Resume,
                ~0,
                &Elements,
                &nRead,
                &nTotal
                );
        
        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule,
                           MSG_MSCOPE_IPRANGE_COUNT,
                           nCount,
                           g_MScopeNameUnicodeString);
            Error = NO_ERROR;
            break;
        }

        nCount+= nRead;

        if( fTable is FALSE )
        {

            DisplayMessage(g_hModule,
                           MSG_SCOPE_IPRANGE_TABLE);

            fTable = TRUE;
        }

        if( NO_ERROR == Error || ERROR_MORE_DATA == Error ) 
        {
            for( i = 0; i < nRead ; i ++ ) 
            {
                PrintRange(
                    Elements->Elements[i].ElementType,
                    Elements->Elements[i].Element.IpRange->StartAddress,
                    Elements->Elements[i].Element.IpRange->EndAddress,
                    0,
                    0,
                    FALSE);
            }
        }

        DhcpRpcFreeMemory( Elements );
        
        Elements = NULL;

        if( Error is ERROR_MORE_DATA )
        {
            continue;
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_MSCOPE_IPRANGE_COUNT,
                           nCount,
                           g_MScopeNameUnicodeString);
            break;
        }
    }

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_SHOW_IPRANGE,
                        Error);

    goto CommonReturn;
}

DWORD
HandleMScopeShowExcluderange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                               Error = NO_ERROR;
    ULONG                               nRead, nTotal, i, nCount;
    ULONG                               Resume;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Elements = NULL;
    BOOL                                fTable = FALSE;

    Resume = 0;
    nCount = 0;

    while( TRUE ) 
    {
        Elements = NULL;
        nRead = nTotal = 0;
        
        Error = DhcpEnumMScopeElements(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                DhcpExcludedIpRanges,
                &Resume,
                ~0,
                &Elements,
                &nRead,
                &nTotal
                );
    
        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule, 
                           MSG_MSCOPE_EXCLUDERANGE_COUNT,
                           nCount,
                           g_MScopeNameUnicodeString);

            Error = NO_ERROR;

            break;
        }


        if( fTable is FALSE )
        {
            DisplayMessage(g_hModule,
                           MSG_SCOPE_EXCLUDERANGE_TABLE);

            fTable = TRUE;
        }

        if( NO_ERROR is Error or
            ERROR_MORE_DATA is Error ) 
        {
            
            nCount+= nRead;

            for( i = 0; i < nRead ; i ++ ) 
            {
                PrintRange(
                    Elements->Elements[i].ElementType,
                    Elements->Elements[i].Element.IpRange->StartAddress,
                    Elements->Elements[i].Element.IpRange->EndAddress,
                    0,
                    0,
                    TRUE);
            }
        }

        DhcpRpcFreeMemory( Elements );

        Elements = NULL;
        
        if( Error is ERROR_MORE_DATA )
        {
            continue;
        }
        else
        {
            DisplayMessage(g_hModule, 
                           MSG_MSCOPE_EXCLUDERANGE_COUNT,
                           nCount,
                           g_MScopeNameUnicodeString);

            break;
        }
        
    }

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_MSCOPE_SHOW_IPRANGE,
                        Error);

    goto CommonReturn;


}

DWORD
HandleMScopeShowState(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD               Error = NO_ERROR;
    LPDHCP_MSCOPE_INFO  MScopeInfo = NULL;
    BOOL                fActive = FALSE;


    Error = DhcpGetMScopeInfo( g_ServerIpAddressUnicodeString,
                               g_MScopeNameUnicodeString,
                               &MScopeInfo);
    
    if( Error isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    if( MScopeInfo->MScopeState is DhcpSubnetEnabled )
    {
        fActive = TRUE;
    }
    else
    {
        fActive = FALSE;
    }

    if( fActive )
    {
        DisplayMessage(g_hModule,
                       MSG_MSCOPE_STATE_ACTIVE,
                       g_MScopeNameUnicodeString);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_MSCOPE_STATE_NOTACTIVE,
                       g_MScopeNameUnicodeString);
    }

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    
    if( MScopeInfo )
    {
        DhcpRpcFreeMemory(MScopeInfo);
        MScopeInfo = NULL;
    }
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_SHOW_STATE,
                        Error);

    goto CommonReturn;

}

DWORD
HandleMScopeShowMibinfo(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                   Error = NO_ERROR;
    LPDHCP_MCAST_MIB_INFO   MScopeMib = NULL;
    FILETIME                ftTime;
    LPMSCOPE_MIB_INFO       ScopeInfo = NULL;
    DWORD                   i=0;
    LPWSTR                  pwszTime = NULL;

    Error = DhcpGetMCastMibInfo( g_ServerIpAddressUnicodeString,
                                 &MScopeMib);

    if( Error isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    DhcpAssert(MScopeMib isnot NULL);

    DisplayMessage(g_hModule, MSG_MSCOPE_MIB);
    DisplayMessage(g_hModule, MSG_MSCOPE_MIB_DISCOVERS, MScopeMib->Discovers);
    DisplayMessage(g_hModule, MSG_MSCOPE_MIB_OFFERS, MScopeMib->Offers);
    DisplayMessage(g_hModule, MSG_MSCOPE_MIB_REQUESTS, MScopeMib->Requests);
    DisplayMessage(g_hModule, MSG_MSCOPE_MIB_RENEWS, MScopeMib->Renews);
    DisplayMessage(g_hModule, MSG_MSCOPE_MIB_ACKS, MScopeMib->Acks);
    DisplayMessage(g_hModule, MSG_MSCOPE_MIB_NAKS, MScopeMib->Naks);
    DisplayMessage(g_hModule, MSG_MSCOPE_MIB_RELEASES, MScopeMib->Releases);
    DisplayMessage(g_hModule, MSG_MSCOPE_MIB_INFORMS, MScopeMib->Informs);
    
    ftTime = *(FILETIME *)(&MScopeMib->ServerStartTime);

    i=0;
    pwszTime = GetDateTimeString(ftTime,
                                 FALSE,
                                 &i);

    DisplayMessage(g_hModule,
                   MSG_MSCOPE_MIB_SERVERSTARTTIME,
                   pwszTime ? pwszTime : L" ");

    if( pwszTime ) 
    {
        DhcpFreeMemory(pwszTime);
        pwszTime = NULL;
    }

    
    DisplayMessage(g_hModule, MSG_SRVR_MIB_SCOPES, MScopeMib->Scopes);

    ScopeInfo = MScopeMib->ScopeInfo;


    for ( i = 0; i < MScopeMib->Scopes; i++ ) 
    {
        DisplayMessage(g_hModule, MSG_MSCOPE_MIB_MSCOPEID, ScopeInfo[i].MScopeId);
        DisplayMessage(g_hModule, MSG_MSCOPE_MIB_MSCOPENAME, ScopeInfo[i].MScopeName);
                   
        DisplayMessage(g_hModule, MSG_MSCOPE_MIB_SCOPES_SUBNET_NUMADDRESSESINUSE,
                    ScopeInfo[i].NumAddressesInuse );
        DisplayMessage(g_hModule, MSG_MSCOPE_MIB_SCOPES_SUBNET_NUMADDRESSESFREE,
                    ScopeInfo[i].NumAddressesFree );
        DisplayMessage(g_hModule, MSG_MSCOPE_MIB_SCOPES_SUBNET_NUMPENDINGOFFERS,
                    ScopeInfo[i].NumPendingOffers );
        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    }

    DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);

CommonReturn:

    DhcpRpcFreeMemory( MScopeMib );
    return Error;
ErrorReturn:
    DisplayMessage(g_hModule,
                   EMSG_SRVR_SHOW_MIBINFO,
                   Error);
    goto CommonReturn;

}

DWORD
HandleMScopeShowMScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DisplayMessage(g_hModule,
                   MSG_MSCOPE_MSCOPE,
                   g_MScopeNameUnicodeString,
                   g_ServerIpAddressUnicodeString);
    return NO_ERROR;
}

DWORD
HandleMScopeShowExpiry(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD               Error = NO_ERROR;
    LPDHCP_MSCOPE_INFO  MScopeInfo = NULL;
    FILETIME            ftTime;
    DATE_TIME           InfTime;
    LPWSTR              pwszTime = NULL;
    
    Error = DhcpGetMScopeInfo( g_ServerIpAddressUnicodeString,
                               g_MScopeNameUnicodeString,
                               &MScopeInfo);
    
    if( Error isnot NO_ERROR )
    {
        goto ErrorReturn;
    }


    InfTime = DhcpCalculateTime(INFINIT_LEASE);

    if( !memcmp(&InfTime, &MScopeInfo->ExpiryTime, sizeof(InfTime)) )
    {
        DisplayMessage(
            g_hModule, MSG_MSCOPE_INFINITE_EXPIRATION
            );

    } 
    else
    {
        int i=0;
        ftTime = *(FILETIME *)(&MScopeInfo->ExpiryTime);

        pwszTime = GetDateTimeString(ftTime,
                                     FALSE,
                                     &i);

        DisplayMessage(g_hModule, 
                       MSG_MSCOPE_EXPIRY,
                       pwszTime ? pwszTime : L" ");

        if( pwszTime )
        {   
            DhcpFreeMemory(pwszTime);
            pwszTime = NULL;
        }

    }

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    
    if( MScopeInfo )
    {
        DhcpRpcFreeMemory(MScopeInfo);
        MScopeInfo = NULL;
    }
    return Error;

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_SHOW_EXPIRY,
                        Error);

    goto CommonReturn;

}

DWORD
HandleMScopeShowTTL(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD               Error = NO_ERROR;
    LPDHCP_MSCOPE_INFO  MScopeInfo = NULL;
    

    Error = DhcpGetMScopeInfo( g_ServerIpAddressUnicodeString,
                               g_MScopeNameUnicodeString,
                               &MScopeInfo);
    
    if( Error isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    DisplayMessage(g_hModule,
                   MSG_MSCOPE_TTL,
                   (DWORD)MScopeInfo->TTL);

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    
    if( MScopeInfo )
    {
        DhcpRpcFreeMemory(MScopeInfo);
        MScopeInfo = NULL;
    }
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_SHOW_TTL,
                        Error);

    goto CommonReturn;

}

DWORD
HandleMScopeShowLease(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                               Error = NO_ERROR;
    DHCP_OPTION_SCOPE_INFO              ScopeInfo = {0};
    LPDHCP_OPTION_VALUE                 Value = NULL;
    DHCP_OPTION_ID                      OptionId = 1; //Lease time
    LPWSTR                              pwszTime = NULL;

    ScopeInfo.ScopeType = DhcpMScopeOptions;
    ScopeInfo.ScopeInfo.MScopeInfo =  g_MScopeNameUnicodeString;

    Error = DhcpGetOptionValue(g_ServerIpAddressUnicodeString,
                               OptionId,
                               &ScopeInfo,
                               &Value);

    if(Error is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       EMSG_MSCOPE_LEASE_NOTSET);
        goto CommonReturn;
    }
    if( Error isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    if( DHCP_INFINIT_LEASE isnot Value->Value.Elements[0].Element.DWordOption )
    {
        pwszTime = MakeDayTimeString(Value->Value.Elements[0].Element.DWordOption);
        DisplayMessage(g_hModule,
                       MSG_MSCOPE_LEASE,
                       pwszTime);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_MSCOPE_INFINITE_LEASE);
    }


CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    
    if( pwszTime )
    {
        free(pwszTime);
        pwszTime = NULL;
    }
    if( Value )
    {
        DhcpRpcFreeMemory(Value);
        Value = NULL;
    }
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_SHOW_TTL,
                        Error);

    goto CommonReturn;

}



VOID
PrintMClientInfo(
    LPDHCP_MCLIENT_INFO ClientInfo
    )
{
    DWORD i = 0;
    DWORD DataLength = 0;
    LPBYTE Data = NULL;
    FILETIME ftTime = {0};
    char *szClientType = NULL;
    LPWSTR  pwszTime = NULL;

    DisplayMessage(g_hModule, MSG_MSCOPE_CLIENT_INFO);
    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_IPADDRESS,
        IpAddressToString(ClientInfo->ClientIpAddress));
    DisplayMessage(g_hModule, MSG_SCOPE_MULTICAST_SCOPEID,
        ClientInfo->MScopeId);

    DataLength = ClientInfo->ClientId.DataLength;
    Data = ClientInfo->ClientId.Data;
    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_HWADDRESS);
    for( i = 0; i < DataLength; i++ ) 
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_HWADDRESS_FORMAT, (DWORD)Data[i]);
        if( (i+1) < DataLength ) 
        {
            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_DASH);
        }
    }
    
    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_NAME, ClientInfo->ClientName);

    
    if ( ClientInfo->ClientLeaseStarts.dwLowDateTime ==
            DHCP_DATE_TIME_INFINIT_LOW &&
         ClientInfo->ClientLeaseStarts.dwHighDateTime ==
            DHCP_DATE_TIME_INFINIT_HIGH )
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_DURATION_STR);
    }


    else
    {
        ftTime = *(FILETIME *)(&ClientInfo->ClientLeaseStarts);
        i=0;
        pwszTime = GetDateTimeString(ftTime,
                                     TRUE,
                                     &i);
        DisplayMessage(g_hModule,
                       MSG_SCOPE_CLIENT_DURATION_DATE_STARTS,
                       pwszTime ? pwszTime : L" ");

        if( pwszTime )
        {
            DhcpFreeMemory(pwszTime);
            pwszTime = NULL;
        }


    }
    
    if ( ClientInfo->ClientLeaseEnds.dwLowDateTime ==
            DHCP_DATE_TIME_INFINIT_LOW &&
         ClientInfo->ClientLeaseEnds.dwHighDateTime ==
            DHCP_DATE_TIME_INFINIT_HIGH )
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_DURATION_STR);
    }
    else
    {
        ftTime = *(FILETIME *)(&ClientInfo->ClientLeaseEnds);
        i=0;
        pwszTime = GetDateTimeString(ftTime,
                                     TRUE,
                                     &i);

       DisplayMessage(g_hModule,
                      MSG_SCOPE_CLIENT_DURATION_DATE_EXPIRES,
                      pwszTime ? pwszTime : L" ");

       if( pwszTime )
       {
           DhcpFreeMemory(pwszTime);
           pwszTime = NULL;
       }

    }
    DisplayMessage(g_hModule, 
                   MSG_SCOPE_OWNER_IPADDRESS,
                   IpAddressToString(ClientInfo->OwnerHost.IpAddress));

    DisplayMessage(g_hModule, 
                   MSG_SCOPE_OWNER_NETBIOSNAME,
                   ClientInfo->OwnerHost.NetBiosName );

    DisplayMessage(g_hModule, 
                   MSG_SCOPE_OWNER_NAME,
                   ClientInfo->OwnerHost.HostName );

    DisplayMessage(g_hModule, 
                   MSG_SCOPE_CLIENT_STATE, 
                   ClientInfo->AddressState );
}

DWORD
HandleMScopeShowOptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                       Error = NO_ERROR;
    DWORD                       Major;
    LPDHCP_ALL_OPTION_VALUES    OptionValues = NULL;
    DHCP_OPTION_SCOPE_INFO      ScopeInfo;
    LPDHCP_OPTION_VALUE_ARRAY   OptionArray = NULL;
    DHCP_RESUME_HANDLE          Resume = 0;
    
    LPWSTR                      pwcTag = NULL;
    LPWSTR                      pwcUser = NULL;
    LPWSTR                      pwcVendor = NULL;
    LPWSTR                      pwcTemp = NULL;

    BOOL                        fUser = FALSE;
    BOOL                        fVendor = FALSE;

    DWORD                       dwRead = 0;
    DWORD                       dwTotal = 0;
    DWORD                       dwCount = 0;

    BOOL                        fTable = FALSE;

    DWORD                       dwIndex=0;
    enum                        { all=0, user, vendor, both}eDisplay;

    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));
    
    ScopeInfo.ScopeType = DhcpMScopeOptions;
    ScopeInfo.ScopeInfo.MScopeInfo = g_MScopeNameUnicodeString;

    eDisplay = all;

    if( dwArgCount > dwIndex )
    {
        if( _wcsicmp(ppwcArguments[dwCurrentIndex], L"all") is 0 )
        {
            eDisplay = all;
        }
        else
        {
            while( TRUE )
            {
                LPWSTR  pwcStr = NULL;
        
                if( dwArgCount <= dwIndex )
                    break;
                if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER) )
                    break;
    
                pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
                if( pwcTemp is NULL )
                {
                    Error = ERROR_OUT_OF_MEMORY;
                    goto ErrorReturn;
                }
                wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

                pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
                if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
                {
                    if( fUser is TRUE ) //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcUser = NULL;
                        else
                        {
                            pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcUser is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcUser, pwcStr);
                        }
                        eDisplay = user;
                        fUser = TRUE;
                    }
                }
                else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
                {
                    if( fVendor is TRUE )   //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcVendor = NULL;
                        else
                        {
                            pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcVendor is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcVendor, pwcStr);
                        }
                        eDisplay = vendor;
                        fVendor = TRUE;
                    }
                }
                else
                {
                    DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
                    return ERROR_INVALID_PARAMETER;
                }

                if( pwcTemp )
                {
                    DhcpFreeMemory(pwcTemp);
                    pwcTemp = NULL;
                }
        
                dwIndex++;
            }

        }
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }    

    if( fUser && fVendor )
    {
        eDisplay = both;
    }

    switch( eDisplay )
    {
    case all:
        {
            Error = DhcpGetAllOptionValues(
                        g_ServerIpAddressUnicodeString,
                        0,
                        &ScopeInfo,
                        &OptionValues
                        );
            if( Error is ERROR_NO_MORE_ITEMS )
            {
                DisplayMessage(g_hModule, EMSG_DHCP_NO_MORE_ITEMS);
                goto CommonReturn;
            }
            if( Error isnot NO_ERROR )
                goto ErrorReturn;
            
            if( OptionValues )
            {
                DisplayMessage(g_hModule, MSG_MSCOPE_OPTION_ALL, g_MScopeNameUnicodeString);
                PrintAllOptionValues(OptionValues);
                DhcpRpcFreeMemory(OptionValues);
            }

            break;
        }
    default:
        {
            dwRead = dwTotal = dwCount = 0;

            while(TRUE)
            {
                if( g_dwMajorVersion >= CLASS_ID_VERSION )
                {
                    Error = DhcpEnumOptionValuesV5(
                                g_ServerIpAddressUnicodeString,
                                0,
                                pwcUser,
                                pwcVendor,
                                &ScopeInfo,
                                &Resume,
                                ~0,
                                &OptionArray,
                                &dwRead,
                                &dwTotal);
                }
                else
                {
                    Error = DhcpEnumOptionValues(
                                g_ServerIpAddressUnicodeString,
                                &ScopeInfo,
                                &Resume,
                                ~0,
                                &OptionArray,
                                &dwRead,
                                &dwTotal);
                }
            
                if( Error is ERROR_NO_MORE_ITEMS )
                {
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_OPTIONVAL_COUNT,
                                   dwCount);
                    Error = NO_ERROR;
                    break;

                }
                if( ( Error isnot NO_ERROR ) and
                    ( Error isnot ERROR_MORE_DATA ) )
                {
                    goto ErrorReturn;
                }
            
                dwCount += dwRead;

                if( OptionArray )
                {
                    DisplayMessage(g_hModule, MSG_MSCOPE_OPTION_ALL, g_MScopeNameUnicodeString);
                    PrintOptionValuesArray(OptionArray);
                    DhcpRpcFreeMemory(OptionArray);
                    OptionArray = NULL;
                }
                
                if( Error is NO_ERROR )
                {
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_OPTIONVAL_COUNT,
                                   dwCount);
                    break;
                }
                else
                {
                    continue;
                }

            }
            break;
        }
    }    

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if( pwcUser )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    if( pwcVendor )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_MSCOPE_SHOW_OPTIONVALUE,
                        Error);
    goto CommonReturn;
}


VOID
PrintMClientInfoShort(
    LPDHCP_MCLIENT_INFO ClientInfo
    )
{

    FILETIME ftTime = {0};
    LPWSTR   pwszTime = NULL;
    int      i = 0;

    DisplayMessage(g_hModule,
                MSG_SCOPE_CLIENT,
                GlobalClientCount++,
                IpAddressToString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );
    if ( ClientInfo->ClientLeaseEnds.dwLowDateTime ==
        DHCP_DATE_TIME_INFINIT_LOW &&
     ClientInfo->ClientLeaseEnds.dwHighDateTime ==
        DHCP_DATE_TIME_INFINIT_HIGH )
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_DURATION_STR);
    }
    else 
    {
        ftTime = *(FILETIME *)(&ClientInfo->ClientLeaseEnds);

        pwszTime = GetDateTimeString(ftTime,
                                     TRUE,
                                     &i);

        DisplayMessage(g_hModule,
                       MSG_SCOPE_CLIENT_DURATION_DATE_EXPIRES,
                       pwszTime ? pwszTime : L" ");

        if( pwszTime )
        {
            DhcpFreeMemory(pwszTime);
            pwszTime = NULL;
        }
                          
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\dhcp\scopehndl.c ===
#include "precomp.h"

// Do not deprecate the string functions
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

extern ULONG g_ulScopeNumTopCmds;
extern ULONG g_ulScopeNumGroups;

extern CMD_GROUP_ENTRY      g_ScopeCmdGroups[];
extern CMD_ENTRY            g_ScopeCmds[];

DWORD  GlobalClientCount = 0;
BOOL    GlobalNoRPC = FALSE;
BOOL    GlobalVerbose = TRUE;

// Maximum length of the UID
#define MAX_ADDRESS_LENGTH  255  // 255 bytes

LPWSTR
GetDynBootpClassName();

DWORD
ConvertToInternalState(
   IN DWORD State
)
{
    DWORD retval;

    switch ( State ) {
    case 0 : retval = DhcpSubnetDisabled;         break;
    case 1 : retval = DhcpSubnetEnabled;          break;
    case 2 : retval = DhcpSubnetDisabledSwitched; break;
    case 3 : retval = DhcpSubnetEnabledSwitched;  break;
    default: retval = DhcpSubnetInvalidState;     break;
    } // switch

    return retval;
} // ConvertToInternalState()

DWORD
HandleScopeList(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    i, j;

    for(i = 0; i < g_ulScopeNumTopCmds-2; i++)
    {
        DisplayMessage(g_hModule, g_ScopeCmds[i].dwShortCmdHelpToken);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    for(i = 0; i < g_ulScopeNumGroups; i++)
    {
        for(j = 0; j < g_ScopeCmdGroups[i].ulCmdGroupSize; j++)
        {
            DisplayMessage(g_hModule, g_ScopeCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);

            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
        }
        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    }

    return NO_ERROR;
}

DWORD
HandleScopeHelp(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    i, j;

    for(i = 0; i < g_ulScopeNumTopCmds-2; i++)
    {
        if(g_ScopeCmds[i].dwCmdHlpToken != MSG_DHCP_NULL)
        {
            DisplayMessage(g_hModule, g_ScopeCmds[i].dwShortCmdHelpToken);
        }
    }

    for(i = 0; i < g_ulScopeNumGroups; i++)
    {
        DisplayMessage(g_hModule, g_ScopeCmdGroups[i].dwShortCmdHelpToken);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    return NO_ERROR;
}

DWORD
HandleScopeDump(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD       Error = NO_ERROR;

    // 
    // Expected args :
    //    0 : scope 
    //    1 : "scope name"
    //    2 : dump
    //
    
    if ( dwArgCount > 3 ) {
	DisplayErrorMessage( g_hModule, MSG_DHCP_NULL,
			     ERROR_INVALID_PARAMETER );
	Error = ERROR_INVALID_PARAMETER;
    }
    else {
	Error = DhcpDumpScope( g_ServerIpAddressUnicodeString,
			       g_dwMajorVersion,
			       g_dwMinorVersion,
			       g_ScopeIpAddress );
    }
    return Error;

} // HandleScopeDump()

DWORD
HandleScopeContexts(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return NO_ERROR;
}

DWORD
HandleScopeAddIprange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{ 
    DWORD                    Error = NO_ERROR;
    ULONG                    Resume;
    DHCP_IP_RANGE            IpRange;
    DHCP_SUBNET_ELEMENT_DATA Element;
    DHCP_SUBNET_ELEMENT_TYPE ElementType;
    LPDHCP_SUBNET_INFO       SubnetInfo = NULL;
    DWORD                    DhcpMask = 0;

    //
    // Expected Parameters are : <SubnetAddress IpRangeStart IpRangeEnd>
    //
    
    memset(&Element, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA));
    memset(&ElementType, 0x00, sizeof(DHCP_SUBNET_ELEMENT_TYPE));

    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_ADD_IPRANGE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    IpRange.StartAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);
    IpRange.EndAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);

    //If either of the addresses is invalid, return
    if( IpRange.StartAddress is INADDR_NONE or 
        IpRange.EndAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    //Make sure the start address is < EndAddress
    if( IpRange.StartAddress > IpRange.EndAddress )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPRANGE);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //Make sure the address range is not in the Multicast area
    if( ( IpRange.StartAddress >= MSCOPE_START_RANGE and
          IpRange.StartAddress <= MSCOPE_END_RANGE ) or
        ( IpRange.EndAddress >= MSCOPE_START_RANGE and
          IpRange.EndAddress <= MSCOPE_END_RANGE ) )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPRANGE);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }


    Error = DhcpGetSubnetInfo(
                    g_ServerIpAddressUnicodeString,
                    g_ScopeIpAddress,
                    &SubnetInfo);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    DhcpMask = (DWORD)SubnetInfo->SubnetMask;
    
    //Make sure starting Address isnot subnet address
    if( ( IpRange.StartAddress & ~DhcpMask ) is (DWORD) 0 )
    {
        DisplayMessage(g_hModule, 
                       EMSG_SCOPE_INVALID_STARTADDRESS, 
                       IpAddressToString(IpRange.StartAddress));
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //Make sure the subnet broadcast address isnot the ending address
    if( ( IpRange.EndAddress & ~DhcpMask ) is ~DhcpMask )
    {
        DisplayMessage(g_hModule, 
                       EMSG_SCOPE_INVALID_ENDADDRESS, 
                       IpAddressToString(IpRange.EndAddress));
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;

    }

    Element.ElementType = DhcpIpRanges;
    Element.Element.IpRange = &IpRange;

    if( g_dwMajorVersion >= CLASS_ID_VERSION ) {
        if( dwArgCount > 2 ) 
        {
            DHCP_BOOTP_IP_RANGE ThisRange = {IpRange.StartAddress, IpRange.EndAddress, 0, ~0};
            
            Element.Element.IpRange = (PVOID)&ThisRange;

            if( g_dwMajorVersion >= CLASS_ID_VERSION ) 
            {
                if( dwArgCount > 3 ) 
                {
                    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex+3]) )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    ThisRange.MaxBootpAllowed = STRTOUL( ppwcArguments[dwCurrentIndex+3], NULL, 10 ) ;
                }
                
                if( 0 is STRICMP(ppwcArguments[dwCurrentIndex+2], TEXT("DHCP")) ) 
                {
                    Element.ElementType = DhcpIpRangesDhcpOnly;
                } 
                else if( 0 is STRICMP(ppwcArguments[dwCurrentIndex+2], TEXT("BOOTP")) ) 
                {
                    Element.ElementType = DhcpIpRangesBootpOnly;
                } 
                else if( ( 0 is STRICMP(ppwcArguments[dwCurrentIndex+2], TEXT("DHCPBOOTP") ) ) or 
                         ( 0 is STRICMP(ppwcArguments[dwCurrentIndex+2], TEXT("BOTH")) ) )
                {
                    Element.ElementType = DhcpIpRangesDhcpBootp;
                } 
                else 
                {
                    DisplayMessage(g_hModule, HLP_SCOPE_ADD_IPRANGE_EX);
                    goto CommonReturn;
                }
            
                Error = DhcpAddSubnetElementV5(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                (PVOID)&Element
                    );
                if( Error isnot NO_ERROR )
                    goto ErrorReturn;
                
            }
        }
        else
        {
            Error = DhcpAddSubnetElementV5(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                (PVOID)&Element);
            
            if( Error isnot NO_ERROR )
                goto ErrorReturn;
        }
    } else {
        
        Error = DhcpAddSubnetElement(
            g_ServerIpAddressUnicodeString,
            g_ScopeIpAddress,
            &Element );
        
        if( Error isnot NO_ERROR )
            goto ErrorReturn;
    }

    // Now set the default lease duration if needed

    {
        DHCP_OPTION_SCOPE_INFO   ScopeInfo = {0};
        DHCP_OPTION_DATA_ELEMENT OptionData = {0};
        DHCP_OPTION_DATA         Option = {0};
        DHCP_OPTION_ID           OptionId = 51; //Lease time
        LPWSTR                   pwszUser = NULL;
	LPDHCP_OPTION_VALUE      OptionValue = NULL;


        ScopeInfo.ScopeType = DhcpSubnetOptions;
        ScopeInfo.ScopeInfo.SubnetScopeInfo =  g_ScopeIpAddress;


	//
	// Do we need to set the default lease duration? 
	// 
	
	Error = DhcpGetOptionValueV5( g_ServerIpAddressUnicodeString,
				      0, OptionId, pwszUser, NULL,
				      &ScopeInfo, &OptionValue );
	if ( ERROR_SUCCESS != Error ) {
	    
	    switch(Element.ElementType)	{
	    case DhcpIpRangesBootpOnly: {
		OptionData.OptionType = DhcpDWordOption;
                OptionData.Element.DWordOption = DEFAULT_BOOTP_LEASE;
                pwszUser = GetDynBootpClassName();
                break;
            }
	    default: {
                OptionData.OptionType = DhcpDWordOption;
                OptionData.Element.DWordOption = DEFAULT_DHCP_LEASE;
                break;
            }
	    } // switch

	    Option.NumElements = 1;
	    Option.Elements = &OptionData;
	    
	    if( g_dwMajorVersion >= CLASS_ID_VERSION ) {
		Error = DhcpSetOptionValueV5( g_ServerIpAddressUnicodeString,
					      0, OptionId, pwszUser,
					      NULL,  &ScopeInfo, &Option );
	    } else {
		Error = DhcpSetOptionValue( g_ServerIpAddressUnicodeString,
					    OptionId, &ScopeInfo, &Option);
	    }
	    
	    if( Error isnot NO_ERROR ) {
		DisplayErrorMessage(g_hModule,
				    EMSG_SCOPE_DEFAULT_LEASE_TIME,
				    Error);
		goto CommonReturn;
	    }
	} // if creating default lease time
	
	if ( NULL != OptionValue ) {
	    DhcpRpcFreeMemory( OptionValue );
	}
    } // set lease duration


    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

CommonReturn:
       if( SubnetInfo )
       {
           DhcpRpcFreeMemory(SubnetInfo);
           SubnetInfo = NULL;
       }
       return( Error );
ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_ADD_IPRANGE,
                        Error);

    goto CommonReturn; 

}

DWORD
HandleScopeAddExcluderange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{

    DWORD              Error = NO_ERROR;
    DHCP_IP_RANGE            IpRange;
    DHCP_SUBNET_ELEMENT_DATA Element;

    //
    // Expected Parameters are : <SubnetAddress IpRangeStart IpRangeEnd>
    //

    memset(&Element, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA));

    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_ADD_EXCLUDERANGE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    IpRange.StartAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);
    IpRange.EndAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);

    if( IpRange.StartAddress is INADDR_NONE or 
        IpRange.EndAddress is INADDR_NONE or
        IpRange.StartAddress > IpRange.EndAddress )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( IpRange.StartAddress > IpRange.EndAddress )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPRANGE);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    

    //Now check to see if it is really an exclusion range for a valid Ip range
    {
        DWORD                               MajorVersion;
        ULONG                               nRead, nTotal, i, nCount;
        ULONG                               Resume;
        BOOL                                fIsV5Call = TRUE,
                                            fPresent = FALSE;

        DHCP_SUBNET_ELEMENT_TYPE            ElementType;
        LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Elements4 = NULL;
        LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 Elements5 = NULL;

        memset(&ElementType, 0x00, sizeof(DHCP_SUBNET_ELEMENT_TYPE));

        nRead = nTotal = nCount = 0;

        MajorVersion = g_dwMajorVersion;
    
        if( MajorVersion >= CLASS_ID_VERSION ) 
        {
            fIsV5Call = TRUE;
        } 
        else 
        {
            fIsV5Call = FALSE;
        }

        Resume = 0;
    
        while( TRUE ) 
        {
            Elements5 = NULL;
            Elements4 = NULL;
            nRead = nTotal = 0;
        
            if( fIsV5Call ) 
            {
                Error = DhcpEnumSubnetElementsV5(
                    (LPWSTR)g_ServerIpAddressUnicodeString,
                    g_ScopeIpAddress,
                    DhcpIpRangesDhcpBootp,
                    &Resume,
                    ~0,
                    &Elements5,
                    &nRead,
                    &nTotal
                    );
            } 
            else 
            {
                Error = DhcpEnumSubnetElementsV4(
                    g_ServerIpAddressUnicodeString,
                    g_ScopeIpAddress,
                    DhcpIpRanges,
                    &Resume,
                    ~0,
                    &Elements4,
                    &nRead,
                    &nTotal
                    );
            }

            if( (Error isnot NO_ERROR) and
                (Error isnot ERROR_MORE_DATA) ) 
            {
                goto ErrorReturn;
            }
            for( i = 0; i < nRead ; i ++ ) 
            {
                if( fIsV5Call ) 
                {
                    if( IpRange.StartAddress >= Elements5->Elements[i].Element.IpRange->StartAddress and
                        IpRange.EndAddress <= Elements5->Elements[i].Element.IpRange->EndAddress )
                    {
                        fPresent = TRUE;
                    }
                } 
                else 
                {
                    if( IpRange.StartAddress >= Elements4->Elements[i].Element.IpRange->StartAddress and
                        IpRange.EndAddress <= Elements4->Elements[i].Element.IpRange->EndAddress )
                    {
                        fPresent = TRUE;
                    }
                   
                }
            }

            if( Elements4 ) 
            {
                DhcpRpcFreeMemory( Elements4 );
                Elements4 = NULL;
            }

            if( Elements5 ) 
            {
                DhcpRpcFreeMemory( Elements5 );
                Elements5 = NULL;
            }

            if( Error is ERROR_MORE_DATA )
            {
                continue;
            }
            else
                break;
        }

        if( fPresent is FALSE )
        {
            DisplayMessage(g_hModule,
                           EMSG_SCOPE_INVALID_EXCLUDERANGE);

            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;


        }
    }
    


    Element.ElementType = DhcpExcludedIpRanges;
    Element.Element.IpRange = &IpRange;
    
    if( g_dwMajorVersion < CLASS_ID_VERSION )
    {
        Error = DhcpAddSubnetElement(
                        g_ServerIpAddressUnicodeString,
                        g_ScopeIpAddress,
                        &Element );
    }
    else
    {
        Error = DhcpAddSubnetElementV5(
                        g_ServerIpAddressUnicodeString,
                        g_ScopeIpAddress,
                        (PVOID)&Element);
    }
    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;
CommonReturn:

    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_ADD_EXCLUDERANGE,
                        Error);
                    
    goto CommonReturn;
}

DWORD
HandleScopeAddReservedip(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
#define COMMAND_ARG_CLIENT_COMMENT  4

    DWORD                 Error = NO_ERROR;
    DHCP_SUBNET_ELEMENT_DATA_V4 Element = {0};
    DHCP_SUBNET_ELEMENT_DATA_V5 ElementV5 = {0};
    DHCP_IP_RESERVATION_V4      ReserveElement={0};
    DHCP_CLIENT_UID             ClientUID;
    BYTE                        Address[MAX_ADDRESS_LENGTH];
    DWORD                       i = 0;
    DHCP_IP_ADDRESS             ReservedIpAddress;
    BOOL                        fIsV5 = TRUE;
    LPWSTR                      pwszName = L"",
                                pwszComment = L"";

    memset(&Element, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));
    memset(&ReserveElement, 0x00, sizeof(DHCP_IP_RESERVATION_V4));
    memset(&ClientUID, 0x00, sizeof(DHCP_CLIENT_UID));
    memset(&ReservedIpAddress, 0x00, sizeof(DHCP_IP_ADDRESS));


    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_ADD_RESERVEDIP_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //
    // make HardwareAddress.
    //

    ClientUID.DataLength = STRLEN(ppwcArguments[dwCurrentIndex+1]);
    if( ClientUID.DataLength % 2 != 0 ) 
    {
        //
        // address must be even length.
        //

        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_HARDWAREADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    ClientUID.DataLength /= 2;

    if ( ClientUID.DataLength > MAX_ADDRESS_LENGTH ) {
        DisplayMessage( g_hModule, EMSG_SCOPE_INVALID_HARDWAREADDRESS );
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

#ifdef UNICODE
    {
        LPSTR    pszAddString = NULL;
        pszAddString = DhcpUnicodeToOem(ppwcArguments[dwCurrentIndex+1], NULL);
        if( NULL == pszAddString ) i = 0;
        else i = DhcpStringToHwAddress((LPSTR)Address, pszAddString);
        DhcpFreeMemory(pszAddString);
        pszAddString = NULL;
    }
#else
    i = DhcpStringToHwAddress( (LPSTR)Address, ppwcArguments[dwCurrentIndex+1] );
    
#endif //UNICODE
    
    if( i != ClientUID.DataLength )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;        
    }

    ClientUID.Data = Address;

    
    //
    // make reserve element.
    //

    ReservedIpAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);

    if( ReservedIpAddress is INADDR_NONE or
        ReservedIpAddress is g_ScopeIpAddress )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    ReserveElement.ReservedIpAddress = ReservedIpAddress;
    ReserveElement.ReservedForClient = &ClientUID;

    if( dwArgCount > 4 )
    {
        
        Error = ProcessBootpParameters( ( dwArgCount > 2 ) ? (dwArgCount - 2) : 0, 
                                        ( dwArgCount > 2 ) ? ppwcArguments+dwCurrentIndex+2 : NULL,
                                        &ReserveElement );
        if ( NO_ERROR isnot Error )
        {
            goto ErrorReturn;        
        }
    }
    else
    {
        ReserveElement.bAllowedClientTypes = CLIENT_TYPE_DHCP;
    }


    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {
        ElementV5.ElementType = DhcpReservedIps;
        ElementV5.Element.ReservedIp = &ReserveElement;

        Error = DhcpAddSubnetElementV5(
                    g_ServerIpAddressUnicodeString,
                    g_ScopeIpAddress,
                    &ElementV5 );
    }
    else
    {
        Element.ElementType = DhcpReservedIps;
        Element.Element.ReservedIp = &ReserveElement;

        Error = DhcpAddSubnetElementV4(
                    g_ServerIpAddressUnicodeString,
                    g_ScopeIpAddress,
                    &Element );
        fIsV5 = FALSE;
    }
    
    if( Error isnot NO_ERROR ) 
    {
        goto ErrorReturn;
    }

    //
    // if we are asked to set the client name, do so.
    //

    if( dwArgCount > 2 )
    {
        pwszName = ppwcArguments[dwCurrentIndex+2];
    }

    if( dwArgCount > 3 )
    {
        pwszComment = ppwcArguments[dwCurrentIndex+3];
    }

    //Set the name and comment for this reservation address
    {

        DHCP_SEARCH_INFO      ClientSearchInfo;
        LPDHCP_CLIENT_INFO_V4 ClientInfo = NULL;
        
        memset(&ClientSearchInfo, 0x00, sizeof(DHCP_SEARCH_INFO));

        //
        // set client name.
        //

        ClientSearchInfo.SearchType = DhcpClientIpAddress;
        ClientSearchInfo.SearchInfo.ClientIpAddress = ReservedIpAddress;

        do 
        {
            Error = DhcpGetClientInfoV4(
                        g_ServerIpAddressUnicodeString,
                        &ClientSearchInfo,
                        &ClientInfo );

            if( Error isnot NO_ERROR ) 
            {
                break;
            }

            if ( ( wcslen( pwszName ) + 1 ) * sizeof(WCHAR) > JET_cbColumnMost ) 
            {
                DisplayMessage(g_hModule, EMSG_DHCP_CLIENT_NAME_TOOLONG);
                Error = ERROR_INVALID_PARAMETER;
                break;
            }

            //
            // if client comment is also given in the argument, store that
            // as well.
            //
            if ( ( wcslen( pwszComment ) + 1 ) * sizeof(WCHAR) > JET_cbColumnMost ) 
            {
                DisplayMessage(g_hModule, EMSG_DHCP_CLIENT_COMMENT_TOOLONG);
                Error = ERROR_INVALID_PARAMETER;
                break;
            }

            ClientInfo->ClientComment = pwszComment;


            ClientInfo->ClientName = pwszName;

            ClientInfo->bClientType = ReserveElement.bAllowedClientTypes;

        } while ( FALSE );

        if ( Error is NO_ERROR ) 
        {

            Error = DhcpSetClientInfoV4(
                        g_ServerIpAddressUnicodeString,
                        ClientInfo );
    
        } 
        else 
        {
             //
            // Cleanup.
            //
            if ( ClientInfo ) 
            {
                DhcpRpcFreeMemory( ClientInfo );
                ClientInfo = NULL;
            }
        }

    } // if( (dwArgCount - dwCurrentIndex) > 3 )

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:

    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SCOPE_ADD_RESERVEDIP,
                        Error);
    goto CommonReturn;
}


DWORD
HandleScopeCheckDatabase(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD      Error = NO_ERROR;
    LPDHCP_SCAN_LIST ScanList = NULL;
    BOOL             FixFlag = FALSE;

    if( dwArgCount > 0 ) 
    {
        //
        // parse fix parameter.
        //

        if( STRICMP(ppwcArguments[dwCurrentIndex], TEXT("fix") ) is 0 ) 
        {
            FixFlag = TRUE;
        }
    }

    //
    // scan dhcp database and registry, check consistency and get bad
    // entries if any.
    //

    Error = DhcpScanDatabase(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                FixFlag,
                &ScanList
                );

    if( Error isnot NO_ERROR ) 
    {
        goto ErrorReturn;
    }

    if( FixFlag )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_RECONCILE_SCOPE,
                       IpAddressToString(g_ScopeIpAddress));
    }
    
    //
    // display bad entries.
    //

    if( (ScanList != NULL) &&
        (ScanList->NumScanItems != 0) &&
        (ScanList->ScanItems != NULL) ) 
    {

        LPDHCP_SCAN_ITEM ScanItem;
        LPDHCP_SCAN_ITEM ScanItemEnd;
        DWORD i = 1;

        if( !FixFlag ) {
            DisplayMessage(
                g_hModule,
                MSG_SRVR_RECONCILE_SCOPE_NEEDFIX,
                IpAddressToString(g_ScopeIpAddress)
                );
        }
                
        ScanItemEnd =
            ScanList->ScanItems +
            ScanList->NumScanItems;

        for( ScanItem = ScanList->ScanItems;
                ScanItem < ScanItemEnd; ScanItem++ ) 
        {

            DisplayMessage(g_hModule, MSG_SCOPE_IPADDRESS,
                i++,
                IpAddressToString(ScanItem->IpAddress) );

            if( ScanItem->ScanFlag == DhcpRegistryFix ) 
            {
                DisplayMessage(g_hModule, MSG_SCOPE_FIX_REGISTRY);
            }
            else if( ScanItem->ScanFlag == DhcpDatabaseFix ) 
            {
                DisplayMessage(g_hModule, MSG_SCOPE_FIX_DATABASE);
            }
            else 
            {
                DisplayMessage(g_hModule, MSG_SCOPE_FIX_UNKNOWN);
            }
        }
    }
    else
    {
        if( !FixFlag ) {
            DisplayMessage(
                g_hModule,
                MSG_SRVR_RECONCILE_SCOPE_NOFIX,
                IpAddressToString(g_ScopeIpAddress)
                );
        }
    }        

CommonReturn:

    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_RECONCILE_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_CHECK_DATABASE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleScopeDeleteIprange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD              Error = NO_ERROR;
    DWORD                    MajorVersion;
    DHCP_IP_RANGE            IpRange;
    DHCP_SUBNET_ELEMENT_DATA Element;
    DHCP_SUBNET_ELEMENT_TYPE ElementType;

    //
    // Expected Parameters are : <SubnetAddress IpRangeStart IpRangeEnd>
    //

    memset(&Element, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA));
    memset(&ElementType, 0x00, sizeof(DHCP_SUBNET_ELEMENT_TYPE));


    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_DELETE_IPRANGE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    IpRange.StartAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);
    IpRange.EndAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);

    if( IpRange.StartAddress is INADDR_NONE or 
        IpRange.EndAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    Element.ElementType = DhcpIpRanges;
    Element.Element.IpRange = &IpRange;

    MajorVersion = g_dwMajorVersion;

    if( MajorVersion >= CLASS_ID_VERSION ) 
    {

        if( dwArgCount > 2) 
        {
            if( 0 == STRICMP(ppwcArguments[dwCurrentIndex+2], TEXT("DHCP")) ) 
            {
                Element.ElementType = DhcpIpRangesDhcpOnly;
            } 
            else if( 0 == STRICMP(ppwcArguments[dwCurrentIndex+2], TEXT("BOOTP")) ) 
            {
                Element.ElementType = DhcpIpRangesBootpOnly;
            } 
            else if( 0 == STRICMP(ppwcArguments[dwCurrentIndex+2], TEXT("DHCPBOOTP") ) ) 
            {
                Element.ElementType = DhcpIpRangesDhcpBootp;
            } 
            else 
            {
                DisplayMessage(g_hModule, HLP_SCOPE_DELETE_IPRANGE_EX);
                return ERROR_INVALID_PARAMETER;
            }
            
            Error = DhcpRemoveSubnetElementV5(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                (PVOID)&Element,
                FALSE
                );
            if( Error is NO_ERROR )
                goto CommonReturn;
            else 
                goto ErrorReturn;
        }
    }

    Error = DhcpRemoveSubnetElement(
        g_ServerIpAddressUnicodeString,
        g_ScopeIpAddress,
        &Element,
        FALSE
        );
    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:

    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_DELETE_IPRANGE,
                        Error);
                   
    goto CommonReturn;
}

DWORD
HandleScopeDeleteExcluderange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD              Error = NO_ERROR;
    DHCP_SUBNET_ELEMENT_DATA Element;
    DHCP_IP_RANGE            IpRange;

    //
    // Expected Parameters are : <SubnetAddress IpRangeStart IpRangeEnd>
    //

    memset(&Element, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA));
    memset(&IpRange, 0x00, sizeof(DHCP_IP_RANGE));

    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_DELETE_EXCLUDERANGE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    IpRange.StartAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);
    IpRange.EndAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);

    if( IpRange.StartAddress is INADDR_NONE or 
        IpRange.EndAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    Element.ElementType = DhcpExcludedIpRanges;
    Element.Element.ExcludeIpRange = &IpRange;

    Error = DhcpRemoveSubnetElement(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                &Element,
                DhcpFullForce );
    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:

    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayMessage(g_hModule, 
                   EMSG_SCOPE_DELETE_EXCLUDERANGE,
                   Error);
    goto CommonReturn;

}

DWORD
HandleScopeDeleteReservedip(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                 Error = NO_ERROR;
    DHCP_SUBNET_ELEMENT_DATA_V4 Element;
    DHCP_IP_RESERVATION_V4      ReserveElement;
    DHCP_CLIENT_UID             ClientUID;
    BYTE                        Address[MAX_ADDRESS_LENGTH] = {L'\0'};
    DWORD                       i = 0;

    //
    // Expected Parameters are : <SubnetAddress ReservedIp HWAddressString>
    //

    memset(&Element, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));
    memset(&ReserveElement, 0x00, sizeof(DHCP_IP_RESERVATION_V4));
    memset(&ClientUID, 0x00, sizeof(DHCP_CLIENT_UID));

    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_DELETE_RESERVEDIP_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //
    // make HardwareAddress.
    //

    ClientUID.DataLength = STRLEN(ppwcArguments[dwCurrentIndex+1]);
    if( ClientUID.DataLength % 2 != 0 ) 
    {
        //
        // address must be even length.
        //

        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_HARDWAREADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    ClientUID.DataLength /= 2;

    DhcpAssert( ClientUID.DataLength < MAX_ADDRESS_LENGTH );

#ifdef UNICODE
    {
        LPSTR    pszAddString = NULL;
        pszAddString = DhcpUnicodeToOem(ppwcArguments[dwCurrentIndex+1], NULL);
        if( NULL == pszAddString ) i = 0;
        else i = DhcpStringToHwAddress((LPSTR)Address, pszAddString);
        DhcpFreeMemory(pszAddString);
        pszAddString = NULL;
    }
#else
    i = DhcpStringToHwAddress( (LPSTR)Address, ppwcArguments[dwCurrentIndex+1] );
    
#endif //UNICODE


//    i = DhcpStringToHwAddress( (LPSTR)Address, ppwcArguments[dwCurrentIndex+1] );

    DhcpAssert( i == ClientUID.DataLength );

    ClientUID.Data = Address;

    //
    // make reserve element.
    //

    ReserveElement.ReservedIpAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);

    if( ReserveElement.ReservedIpAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    ReserveElement.ReservedForClient = &ClientUID;

    Element.ElementType = DhcpReservedIps;
    Element.Element.ReservedIp = &ReserveElement;

    Error = DhcpRemoveSubnetElementV4(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                &Element,
                DhcpFullForce );

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_DELETE_RESERVEDIP,
                        Error);
    goto CommonReturn;
}


DWORD
HandleScopeDeleteOptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD             Error = NO_ERROR;
    DHCP_OPTION_ID          OptionID;
    DHCP_OPTION_SCOPE_INFO  ScopeInfo;
    

    LPWSTR         pwcTag = NULL;
    LPWSTR         pwcUser = NULL;   
    LPWSTR         pwcVendor = NULL;
    LPWSTR         pwcTemp = NULL;

    BOOL           fUser = FALSE;
    BOOL           fVendor = FALSE;

    DWORD          dwIndex = 0;

    //
    // Expected Parameters are :
    // subnet-address <OptionID>
    //

    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));


    if( dwArgCount < 1 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_DELETE_OPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    ScopeInfo.ScopeType = DhcpSubnetOptions;
    ScopeInfo.ScopeInfo.SubnetScopeInfo =  g_ScopeIpAddress;

    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    OptionID = STRTOUL( ppwcArguments[dwCurrentIndex], NULL, 10 );

    dwIndex = 1;
    while( TRUE )
    {
        LPWSTR      pwcStr = NULL;
        if( dwArgCount <= dwIndex )
            break;

        if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER)  )
            break;

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
        {
            if( fUser is TRUE ) //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcUser = NULL;
                else
                {
                    pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcUser is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcUser, pwcStr);
                }
                fUser = TRUE;
            }
        }
        else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
            return ERROR_INVALID_PARAMETER;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }
        
        dwIndex++;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }

    Error = RemoveOptionValue(
        g_ServerIpAddressUnicodeString,
        fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
        (DHCP_OPTION_ID)OptionID,
        pwcUser,
        pwcVendor,
        &ScopeInfo
    );
       
    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if( pwcUser && pwcUser != g_UserClass )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    if( pwcVendor && pwcVendor != g_VendorClass )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_DELETE_OPTIONVALUE,
                        Error);

    goto CommonReturn;
}

DWORD
HandleScopeDeleteReservedoptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD             Error = NO_ERROR; 
    DHCP_OPTION_ID          OptionID;
    DHCP_OPTION_SCOPE_INFO  ScopeInfo;

    LPWSTR         pwcTag = NULL;
    LPWSTR         pwcUser = NULL;   
    LPWSTR         pwcVendor = NULL;
    LPWSTR         pwcTemp = NULL;

    BOOL           fUser = FALSE;
    BOOL           fVendor = FALSE;

    DWORD          dwIndex = 0;

    //
    // Expected Parameters are :
    // subnet-address reservation-address <OptionID>
    //

    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));

    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_DELETE_RESERVEDOPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    ScopeInfo.ScopeType = DhcpReservedOptions;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
    	g_ScopeIpAddress;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
    	StringToIpAddress( ppwcArguments[dwCurrentIndex] );
    
    if( ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress is INADDR_NONE )        
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwIndex++;

    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex+1]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    OptionID = STRTOUL( ppwcArguments[dwCurrentIndex+1], NULL, 10 );
    dwIndex++;

    while( TRUE )
    {
        LPWSTR      pwcStr = NULL;
        if( dwArgCount <= dwIndex )
            break;

        if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER)  )
            break;

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
        {
            if( fUser is TRUE ) //If already set
            {
                DisplayMessage(g_hModule,
                               EMSG_DHCP_DUPLICATE_TAG, 
                               pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcUser = NULL;
                else
                {
                    pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcUser is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcUser, pwcStr);
                }
                fUser = TRUE;
            }
        }
        else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
            return ERROR_INVALID_PARAMETER;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }
        
        dwIndex++;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }


    Error = RemoveOptionValue(
        g_ServerIpAddressUnicodeString,
        fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
        (DHCP_OPTION_ID)OptionID,
        pwcUser,
        pwcVendor,
        &ScopeInfo
    );

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    
    if( pwcUser && pwcUser != g_UserClass )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    if( pwcVendor && pwcVendor != g_VendorClass )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SCOPE_DELETE_RESERVEDOPTIONVALUE,
                        Error);

    goto CommonReturn;
}

DWORD
HandleScopeSetState(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD        Error = NO_ERROR;
    LPDHCP_SUBNET_INFO SubnetInfo = NULL;
    DHCP_SUBNET_STATE State = 0;

    //
    // Expected Parameters are : <0|1|2|3>
    //
    
    do {
	
	if( dwArgCount < 1 ) {
	    DisplayMessage(g_hModule, HLP_SCOPE_SET_STATE_EX);
	    Error = ERROR_INVALID_PARAMETER;
	    break;
	}
       
	Error = DhcpGetSubnetInfo(
				  g_ServerIpAddressUnicodeString,
				  g_ScopeIpAddress,
				  &SubnetInfo );
	
	if( Error isnot NO_ERROR ) {
	    break;
	}
    
	if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex]) ) {
	    Error = ERROR_INVALID_PARAMETER;
	    break;
	}

	State = STRTOUL( ppwcArguments[dwCurrentIndex], NULL, 10 );
	
	// Adjust the state value since it's flipped in the 
	// state enum
	State = ConvertToInternalState( State );
	if ( State >= DhcpSubnetInvalidState ) {
	    Error = ERROR_INVALID_PARAMETER;
	    break;
	}


	SubnetInfo->SubnetState = State;
	Error = DhcpSetSubnetInfo( g_ServerIpAddressUnicodeString,
				   g_ScopeIpAddress,
				   SubnetInfo );

    } while ( FALSE );

    if ( NO_ERROR != Error ) {
	DisplayErrorMessage(g_hModule, 
			    EMSG_SCOPE_SET_STATE,
			    Error);
    }
    else {
	DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    }

    if( SubnetInfo != NULL ) {
	DhcpRpcFreeMemory( SubnetInfo );
	SubnetInfo = NULL;
    }
    return( Error );
} // HandleScopeSetState()

DWORD
HandleScopeSetScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD       Error = NO_ERROR;
    if( dwArgCount < 1)
    {
        DisplayMessage(g_hModule, HLP_SCOPE_SET_SCOPE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( IsIpAddress(ppwcArguments[dwCurrentIndex]) is FALSE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    if( SetScopeInfo(ppwcArguments[dwCurrentIndex] ) )
    {
        Error = NO_ERROR;
    }
    else
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

CommonReturn:
    return Error;

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SCOPE_SET_SCOPE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleScopeSetOptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD              Error = NO_ERROR;
    DHCP_OPTION_ID           OptionID;
    DHCP_OPTION_SCOPE_INFO   ScopeInfo;
    DHCP_OPTION_DATA         OptionValue;
    DHCP_OPTION_DATA_ELEMENT OptionData;
    LPWSTR                   UnicodeOptionValueString = NULL;
    LPDHCP_OPTION            OptionInfo = NULL;
    DHCP_OPTION_DATA_TYPE    OptionType;

    LPWSTR                   OptionTypeString = NULL;
    DWORD                    OptionArrayType;

    LPWSTR                   pwcTag = NULL;
    LPWSTR                   pwcUser = NULL;
    LPWSTR                   pwcVendor = NULL;
    LPWSTR                   pwcTemp = NULL;

    BOOL                     fUser = FALSE;
    BOOL                     fVendor = FALSE;
    BOOL                     fValidType = FALSE;

    DWORD                    dwIndex = 0;
    DWORD                    i = 0;

    //
    // Expected Parameters are :
    // subnet-address <OptionID OptionType OptionValue>
    //

    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));
    memset(&OptionValue, 0x00, sizeof(DHCP_OPTION_DATA));
    memset(&OptionData, 0x00, sizeof(DHCP_OPTION_DATA_ELEMENT));


    if( dwArgCount < 3 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_SET_OPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    
    ScopeInfo.ScopeType = DhcpSubnetOptions;
    ScopeInfo.ScopeInfo.SubnetScopeInfo =  g_ScopeIpAddress;

    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex+dwIndex]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    OptionID = STRTOUL( ppwcArguments[dwCurrentIndex+dwIndex], NULL, 10 );
    
    dwIndex++;

    OptionTypeString = ppwcArguments[dwCurrentIndex+dwIndex];

    dwIndex++;

    //
    //Check to see if VendorClass or UserClass is specified or not
    //
    while (( dwIndex < dwArgCount ) &&
            ( NULL != wcsstr( ppwcArguments[ dwCurrentIndex + dwIndex ],
                              DHCP_ARG_DELIMITER )))
    {
        LPWSTR  pwcStr = NULL;

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
        {
            if( fUser is TRUE ) //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcUser = NULL;
                else
                {
                    pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcUser is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcUser, pwcStr);
                }
                fUser = TRUE;
            }
        }
        else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else
        {
            // Free allocated memory
            if ( NULL != pwcTemp ) {
                DhcpFreeMemory( pwcTemp );
                pwcTemp = NULL;
            }
            break;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }

        dwIndex++;
    }

    // Check if we still have any option value
    if( dwIndex >= dwArgCount ) {
        DisplayMessage(g_hModule, HLP_SCOPE_SET_OPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }

    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {
        Error = DhcpGetOptionInfoV5(g_ServerIpAddressUnicodeString,
                                    fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                    OptionID,
                                    NULL,
                                    pwcVendor,
                                    &OptionInfo);
    }
    else
    {
    
        Error = DhcpGetOptionInfo(g_ServerIpAddressUnicodeString,
                                  OptionID,
                                  &OptionInfo);
    }

    if( Error isnot NO_ERROR or OptionInfo is NULL ) 
    {
        //
        // if no option template is present,
        // assume it is unary if only one option, assume array if more
        //
        goto ErrorReturn;
    }
    else 
    {
        OptionArrayType = OptionInfo->OptionType;
    }

    //Check if OptionType supplied is the same as defined.

    //Find out the OptionType
    for(i=0; i < sizeof(TagOptionType)/sizeof(COMMAND_OPTION_TYPE); i++)
    {
        if( MatchToken(OptionTypeString, TagOptionType[i].pwszTagID) )
        {
            OptionType = TagOptionType[i].DataType;
            fValidType = TRUE;
            break;
        }
    }
    
    if( fValidType is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( OptionType isnot OptionInfo->DefaultValue.Elements[0].OptionType )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_INVALID_OPTIONTYPE);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }


    switch(OptionArrayType)
    {
    case DhcpArrayTypeOption:
        {
            Error = SetOptionDataTypeArray(
                            OptionType,
                            ppwcArguments+dwCurrentIndex,
                            dwIndex,
                            dwArgCount, //Corrections
                            &OptionValue);
            if( Error isnot NO_ERROR )
                goto ErrorReturn;
            break;
        }
    case DhcpUnaryElementTypeOption:
    default:
        {

            Error = SetOptionDataType(
                        OptionType,
                        ppwcArguments[dwCurrentIndex+dwIndex],
                        &OptionData,
                        &UnicodeOptionValueString );

            if( Error != NO_ERROR ) 
            {
                goto ErrorReturn;
            }

            OptionValue.NumElements = 1;
            OptionValue.Elements = &OptionData;
            break;
        }
    }
        
    Error = SetOptionValue(
        g_ServerIpAddressUnicodeString,
        fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
        (DHCP_OPTION_ID)OptionID,
        pwcUser,
        pwcVendor,
        &ScopeInfo,
        &OptionValue
    );

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    
    if( OptionInfo )
    {
        if(OptionInfo->OptionType is DhcpArrayTypeOption)
        {
            if( OptionValue.Elements isnot NULL )
            {
                free(OptionValue.Elements);
                OptionValue.Elements = NULL;
            }
        }
    }

    if( pwcUser && pwcUser != g_UserClass )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    if( pwcVendor && pwcVendor != g_VendorClass )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                   EMSG_SCOPE_SET_OPTIONVALUE,
                   Error);

    goto CommonReturn;

}

DWORD
HandleScopeSetReservedoptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                       Error = NO_ERROR;
    DHCP_OPTION_ID              OptionID;
    DHCP_OPTION_SCOPE_INFO      ScopeInfo;
    DHCP_OPTION_DATA            OptionValue;
    DHCP_OPTION_DATA_ELEMENT    OptionData;
    DHCP_OPTION_DATA_TYPE       OptionType;
    LPWSTR                      UnicodeOptionValueString = NULL;
    LPWSTR                      OptionTypeString = NULL;
    LPDHCP_OPTION               OptionInfo = NULL;
    DWORD                       OptionArrayType;

    LPWSTR                      pwcTag = NULL;
    LPWSTR                      pwcUser = NULL;
    LPWSTR                      pwcVendor = NULL;
    LPWSTR                      pwcTemp = NULL;

    BOOL                        fUser = FALSE;
    BOOL                        fVendor = FALSE;
    BOOL                        fValidType = FALSE;

    DWORD                       dwIndex = 0;
    DWORD                       i = 0;
    //
    // Expected Parameters are :
    // subnet-address reservation-address <OptionID OptionType OptionValue>
    //


    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));
    memset(&OptionValue, 0x00, sizeof(DHCP_OPTION_DATA));
    memset(&OptionData, 0x00, sizeof(DHCP_OPTION_DATA_ELEMENT));

    if( dwArgCount < 4 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_SET_RESERVEDOPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    ScopeInfo.ScopeType = DhcpReservedOptions;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
    	g_ScopeIpAddress;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
    	StringToIpAddress( ppwcArguments[dwCurrentIndex+dwIndex] );

    if( ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwIndex++;

    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex+dwIndex]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    OptionID = STRTOUL( ppwcArguments[dwCurrentIndex+dwIndex], NULL, 10 );
    
    dwIndex++;

    OptionTypeString = ppwcArguments[dwCurrentIndex+dwIndex];

    dwIndex++;

    while( NULL isnot wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER) )
    {
        LPWSTR  pwcStr = NULL;
        if( dwArgCount <= dwIndex + 1 )
        {
            DisplayMessage(g_hModule, HLP_SCOPE_SET_RESERVEDOPTIONVALUE_EX);
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
        {
            if( fUser is TRUE ) //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcUser = NULL;
                else
                {
                    pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcUser is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcUser, pwcStr);
                }
                fUser = TRUE;
            }
        }
        else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
            return ERROR_INVALID_PARAMETER;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }
        
        dwIndex++;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }

    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {
        Error = DhcpGetOptionInfoV5(g_ServerIpAddressUnicodeString,
                                    fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                    OptionID,
                                    NULL,
                                    pwcVendor,
                                    &OptionInfo);
    }
    else
    {
        Error = DhcpGetOptionInfo(
                                    g_ServerIpAddressUnicodeString,
                                    OptionID,
                                    &OptionInfo);
    }

    if( Error isnot NO_ERROR or OptionInfo is NULL ) 
    {
        //
        // if no option template is present,
        // assume it is unary if only one option, assume array if more
        //
        goto ErrorReturn;
    }
    else 
    {
        OptionArrayType = OptionInfo->OptionType;
    }

    //Check if OptionType supplied is the same as defined.

    //Find out the OptionType
    for(i=0; i < sizeof(TagOptionType)/sizeof(COMMAND_OPTION_TYPE); i++)
    {
        if( MatchToken(OptionTypeString, TagOptionType[i].pwszTagID) )
        {
            OptionType = TagOptionType[i].DataType;
            fValidType = TRUE;
            break;
        }
    }
    
    if( fValidType is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( OptionType isnot OptionInfo->DefaultValue.Elements[0].OptionType )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_INVALID_OPTIONTYPE);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }


    switch(OptionArrayType)
    {
    case DhcpArrayTypeOption:
        {
            Error = SetOptionDataTypeArray(
                                OptionType,
                                ppwcArguments+dwCurrentIndex,
                                dwIndex,
                                dwArgCount, //Corrections
                                &OptionValue);
            if( Error isnot NO_ERROR )
                goto ErrorReturn;
            break;
        }
    case DhcpUnaryElementTypeOption:
        {
            Error = SetOptionDataType(
                OptionType,
                ppwcArguments[dwCurrentIndex+dwIndex],
                &OptionData,
                &UnicodeOptionValueString
            );

            if( Error != NO_ERROR ) 
            {
                goto ErrorReturn;
            }

            OptionValue.NumElements = 1;
            OptionValue.Elements = &OptionData;
            break;
        }
    }

    Error = SetOptionValue(
        g_ServerIpAddressUnicodeString,
        fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
        (DHCP_OPTION_ID)OptionID,
        pwcUser,
        pwcVendor,
        &ScopeInfo,
        &OptionValue
    );
    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if( OptionInfo )
    {
        if( OptionInfo->OptionType is DhcpArrayTypeOption)
        {
            if( OptionValue.Elements isnot NULL )
            {
                free(OptionValue.Elements);
                OptionValue.Elements = NULL;
            }
        }
    }

    if( pwcUser && pwcUser != g_UserClass )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    if( pwcVendor && pwcVendor != g_VendorClass )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SET_RESERVEDOPTIONVALUE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleScopeSetName(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD        Error = NO_ERROR;
    LPDHCP_SUBNET_INFO SubnetInfo = NULL;
    DWORD              State;


    Error = DhcpGetSubnetInfo(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                &SubnetInfo );

    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;
    
    DhcpAssert(SubnetInfo isnot NULL);
    
    if( dwArgCount < 1 )
        SubnetInfo->SubnetName = NULL;
    else
    {
        SubnetInfo->SubnetName = ppwcArguments[dwCurrentIndex];
    }

    Error = DhcpSetSubnetInfo(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                SubnetInfo );

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    if( SubnetInfo != NULL )
    {
        DhcpRpcFreeMemory( SubnetInfo );
        SubnetInfo = NULL;
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SET_NAME,
                        Error);
    goto CommonReturn;

}

DWORD
HandleScopeSetComment(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD        Error = NO_ERROR;
    LPDHCP_SUBNET_INFO SubnetInfo = NULL;
    DWORD              State;

    //
    // Expected Parameters are :  <SubnetComment>
    //
        
    Error = DhcpGetSubnetInfo(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                &SubnetInfo );

    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;
    
    DhcpAssert(SubnetInfo isnot NULL);

    
    if( dwArgCount < 1 )
        SubnetInfo->SubnetComment = NULL;
    else
    {
        SubnetInfo->SubnetComment = ppwcArguments[dwCurrentIndex];
    }

    Error = DhcpSetSubnetInfo(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                SubnetInfo );
CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    if( SubnetInfo != NULL )
    {
        DhcpRpcFreeMemory( SubnetInfo );
        SubnetInfo = NULL;
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SET_COMMENT,
                        Error);
    goto CommonReturn;

}


DWORD
HandleScopeSetSuperscope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DHCP_IP_ADDRESS SubnetAddress;
    WCHAR           *pwszSuperScopeName;
    BOOL            fAdd;
    DWORD     Error = NO_ERROR;

    memset(&SubnetAddress, 0x00, sizeof(DHCP_IP_ADDRESS));

    if (( dwArgCount < 2 )||
        (( *(ppwcArguments[ dwCurrentIndex + 1 ]) != L'0' ) &&
         ( *(ppwcArguments[ dwCurrentIndex + 1 ]) != L'1' ))) {
        DisplayMessage(g_hModule, HLP_SCOPE_SET_SUPERSCOPE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    pwszSuperScopeName = ppwcArguments[dwCurrentIndex];

    fAdd = (BOOL) ( *(ppwcArguments[dwCurrentIndex+1]) - L'0');

    Error = DhcpSetSuperScopeV4( g_ServerIpAddressUnicodeString,
                                 g_ScopeIpAddress,
                                 fAdd ? pwszSuperScopeName : NULL,
                                 1 );

    if( Error isnot NO_ERROR )
        goto ErrorReturn;
CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SET_SUPERSCOPE,
                        Error);

    goto CommonReturn;
}

DWORD
HandleScopeShowClients(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                 Error = NO_ERROR;
    DHCP_RESUME_HANDLE          ResumeHandle = 0;
    LPDHCP_CLIENT_INFO_ARRAY_V4 ClientEnumInfo = NULL;
    DWORD                       ClientsRead = 0;
    DWORD                       ClientsTotal = 0;
    DWORD                       i = 0;
    DWORD                       dwCount = 0, Level = 0;
    

    if( dwArgCount >= 1 )
    {
        if( !IsPureNumeric( ppwcArguments[dwCurrentIndex ] ) )
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
        
        Level = ATOI( ppwcArguments[dwCurrentIndex]);
    }

  
    GlobalClientCount = 1;

    if( Level == 0 )
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_TABLE);
    }
    else
    {
        DisplayMessage( g_hModule, MSG_SCOPE_CLIENT_TABLE2);
    }
    
    for(;;) 
    {

        ClientEnumInfo = NULL;
        Error = DhcpEnumSubnetClientsV4(
                    g_ServerIpAddressUnicodeString,
                    g_ScopeIpAddress,
                    &ResumeHandle,
                    (DWORD)(-1),
                    &ClientEnumInfo,
                    &ClientsRead,
                    &ClientsTotal );

        if( Error is ERROR_NO_MORE_ITEMS )
        {
    
            DisplayMessage(g_hModule, 
                           MSG_SCOPE_CLIENTS_COUNT,
                           dwCount,//ClientsTotal,
                           g_ScopeIpAddressUnicodeString);

            Error = NO_ERROR;

            break;
        }

        if( (Error isnot NO_ERROR) and
            (Error isnot ERROR_MORE_DATA) ) 
        {
            goto ErrorReturn;
        }


        if( GlobalVerbose )
        {
            dwCount+= ClientsRead;
            for( i = 0; i < ClientsRead; i++ ) 
            {
                LPDHCP_CLIENT_INFO_V4 TempClientInfo = NULL;
                DWORD                 dwError = NO_ERROR;
                DHCP_SEARCH_INFO      SearchInfo = {0};

                SearchInfo.SearchType = DhcpClientIpAddress;
                SearchInfo.SearchInfo.ClientIpAddress = ClientEnumInfo->Clients[i]->ClientIpAddress;
                dwError = DhcpGetClientInfoV4(
                                     g_ServerIpAddressUnicodeString,
                                     &SearchInfo,
                                     &TempClientInfo);

                if( dwError isnot NO_ERROR )
                    continue;

                PrintClientInfo( TempClientInfo, Level );
                DhcpRpcFreeMemory(TempClientInfo);
                TempClientInfo = NULL;
            }
        }
        else
        {
            dwCount+= ClientsRead;

            for( i = 0; i < ClientsRead; i++ ) 
            {
                LPDHCP_CLIENT_INFO_V4 TempClientInfo = NULL;
                DWORD                 dwError = NO_ERROR;
                DHCP_SEARCH_INFO      SearchInfo = {0};

                SearchInfo.SearchType = DhcpClientIpAddress;
                SearchInfo.SearchInfo.ClientIpAddress = ClientEnumInfo->Clients[i]->ClientIpAddress;
                dwError = DhcpGetClientInfoV4(
                                     g_ServerIpAddressUnicodeString,
                                     &SearchInfo,
                                     &TempClientInfo);

                if( dwError isnot NO_ERROR )
                    continue;

                PrintClientInfoShort( TempClientInfo);
                DhcpRpcFreeMemory(TempClientInfo);
                TempClientInfo = NULL;
            }
        }

        DhcpRpcFreeMemory( ClientEnumInfo );
        ClientEnumInfo = NULL;

        if( Error isnot ERROR_MORE_DATA ) 
        {
            DisplayMessage(g_hModule, 
                           MSG_SCOPE_CLIENTS_COUNT,
                           dwCount,
                           g_ScopeIpAddressUnicodeString);

            break;
        }
        else
        {
            continue;
        }
    }
    


CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SHOW_CLIENTS,
                        Error);

    goto CommonReturn;
}

DWORD
HandleScopeShowClientsv5(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                       Error = NO_ERROR;
    DHCP_RESUME_HANDLE          ResumeHandle = 0;
    LPDHCP_CLIENT_INFO_ARRAY_V5 ClientEnumInfo = NULL;
    DWORD                       ClientsRead = 0;
    DWORD                       ClientsTotal = 0;
    DWORD                       i, dwCount = 0, Level = 0;
    BOOL                        fTable = FALSE;


    if( dwArgCount >= 1 )
    {
        if( !IsPureNumeric( ppwcArguments[dwCurrentIndex ] ) )
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
        
        Level = ATOI( ppwcArguments[dwCurrentIndex]);
    }

    if( g_dwMajorVersion < CLASS_ID_VERSION )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_INVALID_VERSION,
                       g_ServerIpAddressUnicodeString,
                       g_dwMajorVersion,
                       g_dwMinorVersion);
        return NO_ERROR;
    }

    GlobalClientCount = 1;

    if( Level == 0 )
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_TABLE);
    }
    else
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_TABLE2 );
    }
    
    for(;;) 
    {

        ClientEnumInfo = NULL;
        Error = DhcpEnumSubnetClientsV5(
                    g_ServerIpAddressUnicodeString,
                    g_ScopeIpAddress,
                    &ResumeHandle,
                    (DWORD)(-1),
                    &ClientEnumInfo,
                    &ClientsRead,
                    &ClientsTotal );

        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule, 
                           MSG_SCOPE_CLIENTSV5_COUNT,
                           dwCount,
                           g_ScopeIpAddressUnicodeString);
            
            Error = NO_ERROR;

            break;
        }

        if( (Error isnot NO_ERROR) and
            (Error isnot ERROR_MORE_DATA) ) 
        {
            goto ErrorReturn;
        }

        DhcpAssert( ClientEnumInfo != NULL );
        DhcpAssert( ClientEnumInfo->NumElements == ClientsRead );

        if( GlobalVerbose )
        {
            dwCount += ClientsRead;
        
            for( i=0; i< ClientsRead; i++)
            {
                LPDHCP_CLIENT_INFO_V4 TempClientInfo = NULL;
                DWORD                 dwError = NO_ERROR;
                DHCP_SEARCH_INFO      SearchInfo = {0};

                SearchInfo.SearchType = DhcpClientIpAddress;
                SearchInfo.SearchInfo.ClientIpAddress = ClientEnumInfo->Clients[i]->ClientIpAddress;
                dwError = DhcpGetClientInfoV4(
                                      g_ServerIpAddressUnicodeString,
                                      &SearchInfo,
                                      &TempClientInfo);

                if( dwError isnot NO_ERROR )
                    continue;

                PrintClientInfo( TempClientInfo, Level );
                DhcpRpcFreeMemory(TempClientInfo);
                TempClientInfo = NULL;
            }

        }
        else
        {
            dwCount += ClientsRead;

            for( i = 0; i < ClientsRead; i++ ) 
            {
                LPDHCP_CLIENT_INFO_V4 TempClientInfo = NULL;
                DWORD                 dwError = NO_ERROR;
                DHCP_SEARCH_INFO      SearchInfo = {0};

                SearchInfo.SearchType = DhcpClientIpAddress;
                SearchInfo.SearchInfo.ClientIpAddress = ClientEnumInfo->Clients[i]->ClientIpAddress;
                dwError = DhcpGetClientInfoV4(
                                      g_ServerIpAddressUnicodeString,
                                      &SearchInfo,
                                      &TempClientInfo);

                if( dwError isnot NO_ERROR )
                    continue;

                PrintClientInfo( TempClientInfo, Level );
                DhcpRpcFreeMemory(TempClientInfo);
                TempClientInfo = NULL;
            }
        }

        DhcpRpcFreeMemory( ClientEnumInfo );
        ClientEnumInfo = NULL;

        if( Error isnot ERROR_MORE_DATA ) 
        {
            DisplayMessage(g_hModule, 
                           MSG_SCOPE_CLIENTSV5_COUNT,
                           dwCount,
                           g_ScopeIpAddressUnicodeString);
            break;
        }
        else
            continue;
    }
    if (Error isnot NO_ERROR )
        goto ErrorReturn;
CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SHOW_CLIENTSV5,
                        Error);
    goto CommonReturn;
}

DWORD
HandleScopeShowIprange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                               Error = NO_ERROR;
    DWORD                               MajorVersion;
    ULONG                               nRead, nTotal, i, nCount;
    ULONG                               Resume;
    BOOL                                fIsV5Call = TRUE,
                                        fTable = FALSE;

    DHCP_SUBNET_ELEMENT_TYPE            ElementType;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Elements4 = NULL;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 Elements5 = NULL;

    memset(&ElementType, 0x00, sizeof(DHCP_SUBNET_ELEMENT_TYPE));

    nRead = nTotal = nCount = 0;

    MajorVersion = g_dwMajorVersion;
    
    if( MajorVersion >= CLASS_ID_VERSION ) 
    {
        fIsV5Call = TRUE;
    } 
    else 
    {
        fIsV5Call = FALSE;
    }

    Resume = 0;
    
    while( TRUE ) 
    {
        Elements5 = NULL;
        Elements4 = NULL;
        nRead = nTotal = 0;
        
        if( fIsV5Call ) 
        {
            Error = DhcpEnumSubnetElementsV5(
                (LPWSTR)g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                DhcpIpRangesDhcpBootp,
                &Resume,
                ~0,
                &Elements5,
                &nRead,
                &nTotal
                );
        } 
        else 
        {
            Error = DhcpEnumSubnetElementsV4(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                DhcpIpRanges,
                &Resume,
                ~0,
                &Elements4,
                &nRead,
                &nTotal
                );
        }

        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule, 
                           MSG_SCOPE_IPRANGE_COUNT,
                           nCount,
                           g_ScopeIpAddressUnicodeString);
            
            Error = NO_ERROR;

            break;
        }

        if( (Error isnot NO_ERROR) and
            (Error isnot ERROR_MORE_DATA) ) 
        {
            goto ErrorReturn;
        }

        nCount+= nRead;

        if( fTable is FALSE )
        {
         
            DisplayMessage(g_hModule, MSG_SCOPE_IPRANGE_TABLE);
            
            fTable = TRUE;
        }

        for( i = 0; i < nRead ; i ++ ) 
        {
            if( fIsV5Call ) 
            {
                PrintRange(
                    Elements5->Elements[i].ElementType,
                    Elements5->Elements[i].Element.IpRange->StartAddress,
                    Elements5->Elements[i].Element.IpRange->EndAddress,
                    Elements5->Elements[i].Element.IpRange->BootpAllocated,
                    Elements5->Elements[i].Element.IpRange->MaxBootpAllowed,
                    FALSE
                    );
            } 
            else 
            {
                PrintRange(
                    Elements4->Elements[i].ElementType,
                    Elements4->Elements[i].Element.IpRange->StartAddress,
                    Elements4->Elements[i].Element.IpRange->EndAddress,
                    0,
                    0,
                    FALSE
                    );
            }
        }

        if( Elements4 ) 
        {
            DhcpRpcFreeMemory( Elements4 );
            Elements4 = NULL;
        }

        if( Elements5 ) 
        {
            DhcpRpcFreeMemory( Elements5 );
            Elements5 = NULL;
        }

        if( Error is ERROR_MORE_DATA )
        {
            continue;
        }
        else
        {
            DisplayMessage(g_hModule, 
                           MSG_SCOPE_IPRANGE_COUNT,
                           nCount,
                           g_ScopeIpAddressUnicodeString);
            break;
        }

    }

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SHOW_IPRANGE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleScopeShowExcluderange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                               Error = NO_ERROR;
    DWORD                               MajorVersion;
    ULONG                               nRead, nTotal, i, nCount;
    ULONG                               Resume;
    BOOL                                fIsV5Call = TRUE,
                                        fTable = FALSE;
    DHCP_SUBNET_ELEMENT_TYPE            ElementType;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Elements4 = NULL;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 Elements5 = NULL;

    memset(&ElementType, 0x00, sizeof(DHCP_SUBNET_ELEMENT_TYPE));

    nRead = nTotal = nCount = 0;

    MajorVersion = g_dwMajorVersion;
    if( MajorVersion >= CLASS_ID_VERSION ) 
    {
        fIsV5Call = TRUE;
    } 
    else 
    {
        fIsV5Call = FALSE;
    }

    Resume = 0;
    while( TRUE ) 
    {
        Elements5 = NULL;
        Elements4 = NULL;
        
        if( fIsV5Call ) 
        {
            Error = DhcpEnumSubnetElementsV5(
                (LPWSTR)g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                DhcpExcludedIpRanges,
                &Resume,
                ~0,
                &Elements5,
                &nRead,
                &nTotal
                );
        } 
        else 
        {
            Error = DhcpEnumSubnetElementsV4(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                DhcpExcludedIpRanges,
                &Resume,
                ~0,
                &Elements4,
                &nRead,
                &nTotal
                );
        }

        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule, 
                           MSG_SCOPE_EXCLUDERANGE_COUNT,
                           nCount,
                           g_ScopeIpAddressUnicodeString);
            break;
        }

        if( (Error isnot NO_ERROR) and
            (Error isnot ERROR_MORE_DATA) ) 
        {
            goto ErrorReturn;
        }

        nCount += nRead;

        if( fTable is FALSE )
        {
            DisplayMessage(g_hModule, MSG_SCOPE_EXCLUDERANGE_TABLE);

            fTable = TRUE;
        }

        for( i = 0; i < nRead ; i ++ ) 
        {
            if( fIsV5Call ) 
            {
                PrintRange(
                    Elements5->Elements[i].ElementType,
                    Elements5->Elements[i].Element.ExcludeIpRange->StartAddress,
                    Elements5->Elements[i].Element.ExcludeIpRange->EndAddress,
                    0,
                    0,
                    TRUE
                    );
            } 
            else 
            {
                PrintRange(
                    Elements4->Elements[i].ElementType,
                    Elements4->Elements[i].Element.IpRange->StartAddress,
                    Elements4->Elements[i].Element.IpRange->EndAddress,
                    0,
                    0,
                    TRUE
                    );
            }
        }

        if( Elements4 ) 
        {
            DhcpRpcFreeMemory( Elements4 );
            Elements4 = NULL;
        }

        if( Elements5 ) 
        {
            DhcpRpcFreeMemory( Elements5 );
            Elements5 = NULL;
        }

        if( Error is ERROR_MORE_DATA )
        {
            continue;
        }
        else
        {
            DisplayMessage(g_hModule, 
                           MSG_SCOPE_EXCLUDERANGE_COUNT,
                           nCount,
                           g_ScopeIpAddressUnicodeString);
            break;
        }
    }

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SCOPE_SHOW_EXCLUDERANGE,
                        Error);
    goto CommonReturn;

}

DWORD
HandleScopeShowReservedip(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                         Error = NO_ERROR;
    DWORD                               MajorVersion;
    ULONG                               nRead, nTotal, i, j, nCount;
    ULONG                               Resume;
    BOOL                                fIsV5Call;
    DHCP_SUBNET_ELEMENT_TYPE            ElementType;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Elements4 = NULL;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 Elements5 = NULL;
    BOOL                                fTable = FALSE;

    memset(&ElementType, 0x00, sizeof(DHCP_SUBNET_ELEMENT_TYPE));

    MajorVersion = g_dwMajorVersion;
    if( MajorVersion >= CLASS_ID_VERSION ) 
    {
        fIsV5Call = TRUE;
    } 
    else 
    {
        fIsV5Call = FALSE;
    }

    Resume = 0;
    nCount = 0;

    while( TRUE ) 
    {
        Elements5 = NULL;
        Elements4 = NULL;
        nRead = nTotal = 0;
        
        if( fIsV5Call ) 
        {
            Error = DhcpEnumSubnetElementsV5(
                (LPWSTR)g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                DhcpReservedIps,
                &Resume,
                ~0,
                &Elements5,
                &nRead,
                &nTotal
                );
        } 
        else 
        {
            Error = DhcpEnumSubnetElementsV4(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                DhcpReservedIps,
                &Resume,
                ~0,
                &Elements4,
                &nRead,
                &nTotal
                );
        }

        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule,
                           MSG_SCOPE_RESERVEDIP_COUNT,
                           nCount,
                           g_ScopeIpAddressUnicodeString);
            Error = NO_ERROR;
            break;
        }

        if( Error isnot NO_ERROR and
            Error isnot ERROR_MORE_DATA )
        {
            goto ErrorReturn;
        }

        if( fTable is FALSE )
        {
            DisplayMessage(g_hModule, MSG_SCOPE_RESERVEDIP_TABLE);
            fTable = TRUE;
        }

        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

        nCount += nRead;

        do { // PRINT UID

            for( i = 0; i < nRead ; i ++ ) 
            {
                DWORD DataLength, AllocLen, n = 0;
                LPBYTE Data;
                DWORD dw=0, k=0;
                WCHAR  IpAddress[23] = {L'\0'};
                DHCP_IP_RESERVATION_V4 *pResrv;

                LPWSTR wcData;

                if( fIsV5Call )
                {
                    DataLength = Elements5->Elements[i].Element.ReservedIp->ReservedForClient->DataLength;
                    Data = Elements5->Elements[i].Element.ReservedIp->ReservedForClient->Data;
                    pResrv = Elements5->Elements[ i ].Element.ReservedIp;
                    j = 5;
                }
                else {
                    DataLength = Elements4->Elements[i].Element.ReservedIp->ReservedForClient->DataLength;
                    Data = Elements4->Elements[i].Element.ReservedIp->ReservedForClient->Data;
                    pResrv = Elements4->Elements[ i ].Element.ReservedIp;
                    j = 0;
                }

                // Allocate space for 2 hex chars + '-' and a NULL
                AllocLen = DataLength * 3 + 1 ;
                wcData = DhcpAllocateMemory( AllocLen * sizeof( WCHAR ));
                if ( NULL == wcData ) {
                    continue;
                }

                // Truncate excessively long UIDs
                while ( j < DataLength )
                {
                    // Ignore result
                    StringCchPrintf( wcData + n, AllocLen - n,
                                     L"%.2x-", ( DWORD ) Data[ j ]);
                    n += 3; // xx-
                    j++;
                }

                wsprintf(IpAddress, L"    %s", IpAddressToString( pResrv->ReservedIpAddress ));
                for( dw = wcslen(IpAddress); dw < 23; dw++)
                {
                    IpAddress[dw] = L' ';
                }
                IpAddress[22] = L'\0';

                DisplayMessage(g_hModule, 
                               MSG_SCOPE_RESERVEDIP_INFO,
                               IpAddress,
                               wcData);

                DhcpFreeMemory( wcData );
            } // for
            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
        } while ( 0 ); // Print UID

        if( Elements4 ) 
        {
            DhcpRpcFreeMemory( Elements4 );
            Elements4 = NULL;
        }

        if( Elements5 )
        {
            DhcpRpcFreeMemory( Elements5 );
            Elements5 = NULL;
        }

        if( Error is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SCOPE_RESERVEDIP_COUNT,
                           nCount,
                           g_ScopeIpAddressUnicodeString);
            break;
        }
        else
            continue;
    }

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SHOW_RESERVEDIP,
                        Error);
    goto CommonReturn;
}

DWORD
HandleScopeShowOptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                       Error = NO_ERROR;
    DWORD                       Major;
    LPDHCP_ALL_OPTION_VALUES    OptionValues = NULL;
    DHCP_OPTION_SCOPE_INFO      ScopeInfo;
    LPDHCP_OPTION_VALUE_ARRAY   OptionArray = NULL;
    DHCP_RESUME_HANDLE          Resume = 0;
    
    LPWSTR                      pwcTag = NULL;
    LPWSTR                      pwcUser = NULL;
    LPWSTR                      pwcVendor = NULL;
    LPWSTR                      pwcTemp = NULL;

    BOOL                        fUser = FALSE;
    BOOL                        fVendor = FALSE;

    DWORD                       dwRead = 0;
    DWORD                       dwTotal = 0;
    DWORD                       dwCount = 0;
    DWORD                       dwOption = 0;

    BOOL                        fTable = FALSE;

    DWORD                       dwIndex=0;
    enum                        { all=0, user, vendor, both}eDisplay;

    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));
    
    ScopeInfo.ScopeType = DhcpSubnetOptions;
    ScopeInfo.ScopeInfo.SubnetScopeInfo = g_ScopeIpAddress;

    eDisplay = all;

    if( dwArgCount > dwIndex )
    {
        if( _wcsicmp(ppwcArguments[dwCurrentIndex], L"all") is 0 )
        {
            eDisplay = all;
        }
        else
        {
            while( TRUE )
            {
                LPWSTR  pwcStr = NULL;
        
                if( dwArgCount <= dwIndex )
                    break;
                if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER) )
                    break;
    
                pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
                if( pwcTemp is NULL )
                {
                    Error = ERROR_OUT_OF_MEMORY;
                    goto ErrorReturn;
                }
                wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

                pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
                if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
                {
                    if( fUser is TRUE ) //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcUser = NULL;
                        else
                        {
                            pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcUser is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcUser, pwcStr);
                        }
                        eDisplay = user;
                        fUser = TRUE;
                    }
                }
                else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
                {
                    if( fVendor is TRUE )   //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcVendor = NULL;
                        else
                        {
                            pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcVendor is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcVendor, pwcStr);
                        }
                        eDisplay = vendor;
                        fVendor = TRUE;
                    }
                }
                else
                {
                    DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
                    return ERROR_INVALID_PARAMETER;
                }

                if( pwcTemp )
                {
                    DhcpFreeMemory(pwcTemp);
                    pwcTemp = NULL;
                }
        
                dwIndex++;
            }

        }
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }    

    if( fUser && fVendor )
    {
        eDisplay = both;
    }


    switch( eDisplay )
    {
    case all:
        {
            if( g_dwMajorVersion >= CLASS_ID_VERSION )
            {
                Error = DhcpGetAllOptionValues(
                            g_ServerIpAddressUnicodeString,
                            0,
                            &ScopeInfo,
                            &OptionValues
                            );
                if( Error is ERROR_NO_MORE_ITEMS )
                {
                    DisplayMessage(g_hModule, EMSG_DHCP_NO_MORE_ITEMS);
                    goto CommonReturn;
                }
                if( Error isnot NO_ERROR )
                    goto ErrorReturn;
        
                if( OptionValues )
                {
                    DisplayMessage(g_hModule, MSG_SCOPE_OPTION_ALL, g_ScopeIpAddressUnicodeString);
                    dwOption += PrintAllOptionValues(OptionValues);
                    dwCount = OptionValues->NumElements;
                    DhcpRpcFreeMemory(OptionValues);
                    OptionValues = NULL;
                }
            }
            else
            {
                Error = ShowOptionValues4(g_ServerIpAddressUnicodeString,
                                         &ScopeInfo,
                                         &dwOption);
                if( Error isnot NO_ERROR )
                    goto ErrorReturn;
            }
            break;
        }
    default:
        {
            dwRead = dwTotal = dwCount = 0;

            while(TRUE)
            {
                if( g_dwMajorVersion >= CLASS_ID_VERSION )
                {
                    Error = DhcpEnumOptionValuesV5(
                                g_ServerIpAddressUnicodeString,
                                0,
                                pwcUser,
                                pwcVendor,
                                &ScopeInfo,
                                &Resume,
                                ~0,
                                &OptionArray,
                                &dwRead,
                                &dwTotal);
                }
                else
                {
                    Error = DhcpEnumOptionValues(
                                g_ServerIpAddressUnicodeString,
                                &ScopeInfo,
                                &Resume,
                                ~0,
                                &OptionArray,
                                &dwRead,
                                &dwTotal);
                }
        
                if( Error is ERROR_NO_MORE_ITEMS )
                {
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_OPTIONVAL_COUNT,
                                   dwCount);
                    Error = NO_ERROR;
                    dwOption += dwCount;
                    break;

                }
                if( ( Error isnot NO_ERROR ) and
                    ( Error isnot ERROR_MORE_DATA ) )
                {
                    goto ErrorReturn;
                }
        
                dwCount += dwRead;

                if( OptionArray )
                {
                    DisplayMessage(g_hModule, MSG_SCOPE_OPTION_ALL, g_ScopeIpAddressUnicodeString);
                    PrintOptionValuesArray(OptionArray);
                    DhcpRpcFreeMemory(OptionArray);
                    OptionArray = NULL;
                }
            
                if( Error is NO_ERROR )
                {
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_OPTIONVAL_COUNT,
                                   dwCount);
                    dwOption += dwCount;
                    break;
                }
                else
                {
                    continue;
                }

            }
            break;
        }
    }
    

CommonReturn:
    if( Error is NO_ERROR )
    {
        if( dwOption is 0 )
        {
            DisplayMessage(g_hModule,
                           MSG_DHCP_NO_OPTIONVALUE_SET);
        }
        
        {
            DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
        }
    }

    if( pwcUser && pwcUser != g_UserClass )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    if( pwcVendor && pwcVendor != g_VendorClass )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SHOW_OPTIONVALUE,
                        Error);
    goto CommonReturn;
}


DWORD
HandleScopeShowReservedoptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                       Error = NO_ERROR;
    DWORD                       Major;
    LPDHCP_ALL_OPTION_VALUES    OptionValues = NULL;
    DHCP_OPTION_SCOPE_INFO      ScopeInfo;
    LPDHCP_OPTION_VALUE_ARRAY   OptionArray = NULL;
    DHCP_RESUME_HANDLE          Resume = 0;

    LPWSTR                      pwcTag = NULL;
    LPWSTR                      pwcUser = NULL;
    LPWSTR                      pwcVendor = NULL;
    LPWSTR                      pwcTemp = NULL;

    BOOL                        fUser = FALSE;
    BOOL                        fVendor = FALSE;

    DWORD                       dwRead = 0;
    DWORD                       dwTotal = 0;
    DWORD                       dwCount = 0;
    DWORD                       dwOption = 0;
    DWORD                       dwIndex=0;

    enum                        { all=0, user, vendor, both}eDisplay;

    eDisplay = all;
    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SCOPE_SHOW_RESERVEDOPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;        
    }


    ScopeInfo.ScopeType = DhcpReservedOptions;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
    	g_ScopeIpAddress;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
    	StringToIpAddress( ppwcArguments[dwCurrentIndex] );

    if( ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwIndex++;

    if( dwArgCount > dwIndex )
    {
        if( _wcsicmp(ppwcArguments[dwCurrentIndex+dwIndex], L"all") is 0 )
        {
            eDisplay = all;
        }
        else
        {
            while( TRUE )
            {
                LPWSTR  pwcStr = NULL;
        
                if( dwArgCount <= dwIndex )
                    break;
                if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER) )
                    break;
    
                pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
                if( pwcTemp is NULL )
                {
                    Error = ERROR_OUT_OF_MEMORY;
                    goto ErrorReturn;
                }
                wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

                pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
                if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
                {
                    if( fUser is TRUE ) //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcUser = NULL;
                        else
                        {
                            pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcUser is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcUser, pwcStr);
                        }
                        eDisplay = user;
                        fUser = TRUE;
                    }
                }
                else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
                {
                    if( fVendor is TRUE )   //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcVendor = NULL;
                        else
                        {
                            pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcVendor is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcVendor, pwcStr);
                        }
                        eDisplay = vendor;
                        fVendor = TRUE;
                    }
                }
                else
                {
                    DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
                    return ERROR_INVALID_PARAMETER;
                }

                if( pwcTemp )
                {
                    DhcpFreeMemory(pwcTemp);
                    pwcTemp = NULL;
                }
        
                dwIndex++;
            }

        }
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }    

    if( fUser && fVendor )
    {
        eDisplay = both;
    }

    switch( eDisplay )
    {
    case all:
        {
            if( g_dwMajorVersion >= CLASS_ID_VERSION )
            {
                Error = DhcpGetAllOptionValues(
                            g_ServerIpAddressUnicodeString,
                            0,
                            &ScopeInfo,
                            &OptionValues
                            );
                if( Error is ERROR_NO_MORE_ITEMS )
                {
                    DisplayMessage(g_hModule, EMSG_DHCP_NO_MORE_ITEMS);
                    goto CommonReturn;
                }

                if( Error isnot NO_ERROR )
                    goto ErrorReturn;
            
                if( OptionValues )
                {
                    DisplayMessage(g_hModule, 
                        MSG_SCOPE_RESERVEDOPTION_ALL, 
                        g_ScopeIpAddressUnicodeString, 
                        ppwcArguments[dwCurrentIndex] );
                    dwOption += PrintAllOptionValues(OptionValues);
                    DhcpRpcFreeMemory(OptionValues);
                    OptionValues = NULL;
                }
            }
            else
            {
                Error = ShowOptionValues4(g_ServerIpAddressUnicodeString,
                                          &ScopeInfo,
                                          &dwOption);
                if( Error isnot NO_ERROR )
                    goto ErrorReturn;
            }
            break;
        }
    default:
        {
            while( TRUE )
            {
                if( g_dwMajorVersion >= CLASS_ID_VERSION )
                {
                    Error = DhcpEnumOptionValuesV5(
                                g_ServerIpAddressUnicodeString,
                                0,
                                pwcUser,
                                pwcVendor,
                                &ScopeInfo,
                                &Resume,
                                ~0,
                                &OptionArray,
                                &dwRead,
                                &dwTotal);
                }
                else
                {
                    Error = DhcpEnumOptionValues(
                                g_ServerIpAddressUnicodeString,
                                &ScopeInfo,
                                &Resume,
                                ~0,
                                &OptionArray,
                                &dwRead,
                                &dwTotal);
                }
                if( Error is ERROR_NO_MORE_ITEMS )
                {
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_OPTIONVAL_COUNT,
                                   dwCount);
                    Error = NO_ERROR;
                    dwOption += dwCount;
                    break;
                }

                if( Error isnot NO_ERROR and
                    Error isnot ERROR_MORE_DATA )
                {
                    goto ErrorReturn;
                }
            
                dwCount += dwRead;

                if( OptionArray )
                {
                    DisplayMessage(g_hModule, 
                                   MSG_SCOPE_RESERVEDOPTION_ALL, 
                                   g_ScopeIpAddressUnicodeString, 
                                   ppwcArguments[dwCurrentIndex]);

                    PrintOptionValuesArray(OptionArray);
                    DhcpRpcFreeMemory(OptionArray);
                    OptionArray = NULL;
                }
                
                if( Error is NO_ERROR )
                {
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_OPTIONVAL_COUNT,
                                   dwCount);
                    dwOption += dwCount;
                    break;
                                    
                }
                else
                {
                    continue;
                }

            }
            break;
        }
    }    



CommonReturn:
    if( Error is NO_ERROR )
    {
        if( dwOption is 0 ) 
        {
            DisplayMessage(g_hModule,
                           MSG_DHCP_NO_OPTIONVALUE_SET);
        }

        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    }

    if( pwcUser  && pwcUser != g_UserClass )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    if( pwcVendor && pwcVendor != g_VendorClass )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SCOPE_SHOW_RESERVEDOPTIONVALUE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleScopeShowState(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD              Error = NO_ERROR;
    LPDHCP_SUBNET_INFO SubnetInfo = NULL;
    BOOL               fActive = TRUE;
    DWORD              MsgId;
    
    Error = DhcpGetSubnetInfo(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                &SubnetInfo );

    if( Error isnot NO_ERROR ) 
    {
        goto ErrorReturn;
    }

    switch( SubnetInfo->SubnetState ) {
    case DhcpSubnetDisabled :
        MsgId = MSG_SCOPE_STATE_NOTACTIVE; break;
    case DhcpSubnetEnabled :
        MsgId = MSG_SCOPE_STATE_ACTIVE; break;
    case DhcpSubnetDisabledSwitched :
        MsgId = MSG_SCOPE_STATE_NOTACTIVE_SWITCHED; break;
    case DhcpSubnetEnabledSwitched :
        MsgId = MSG_SCOPE_STATE_ACTIVE_SWITCHED; break;
    default:
        Error = ERROR_INTERNAL_ERROR;
        goto ErrorReturn;
    }
    
    DisplayMessage(g_hModule, MsgId, g_ScopeIpAddressUnicodeString);

CommonReturn:
    if(Error is NO_ERROR)
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SHOW_STATE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleScopeShowMibinfo(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return NO_ERROR;
}

DWORD
HandleScopeShowScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DisplayMessage(g_hModule, 
                   MSG_SCOPE_SERVER, 
                   g_ScopeIpAddressUnicodeString, 
                   g_ServerIpAddressUnicodeString);
    return NO_ERROR;
}


DWORD
ProcessBootpParameters(
    DWORD                    cArgs,
    LPTSTR                   *ppszArgs,
    DHCP_IP_RESERVATION_V4   *pReservation
)
{
    DWORD dwResult = ERROR_SUCCESS;


    if ( cArgs > 2 )
    {
        // user specified the allowed client type

        if ( !STRICMP( ppszArgs[ 2 ], TEXT("BOOTP") ) )
        {
            pReservation->bAllowedClientTypes = CLIENT_TYPE_BOOTP;
        }
        else if ( !STRICMP ( ppszArgs[ 2 ], TEXT("DHCP") ) )
        {
            pReservation->bAllowedClientTypes = CLIENT_TYPE_DHCP;
        }
        else if ( !STRICMP ( ppszArgs[ 2 ], TEXT("BOTH") ) )
        {
            pReservation->bAllowedClientTypes = CLIENT_TYPE_BOTH;
        }
        else if ( wcslen(ppszArgs[2]) is 0 )
        {
            pReservation->bAllowedClientTypes = CLIENT_TYPE_BOTH;
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_RESERVATION_TYPE);
            return ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        // allow dhcp clients by default.
        pReservation->bAllowedClientTypes = CLIENT_TYPE_DHCP;
        return ERROR_SUCCESS;
    }

    return dwResult;
}

DWORD
RemoveOptionValue(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
)
{
    DWORD                          MajorVersion;
    DWORD                          Error;

    if( g_dwMajorVersion >= CLASS_ID_VERSION ) 
    {
        return DhcpRemoveOptionValueV5(
                            ServerAddress,
                            Flags,
                            OptionID,
                            ClassName,
                            VendorName,
                            ScopeInfo
                            );
    }

    // incorrect version, just do like before..

    return DhcpRemoveOptionValue(
                            ServerAddress,
                            OptionID,
                            ScopeInfo
                            );
}

VOID
PrintRange(
    DHCP_SUBNET_ELEMENT_TYPE Type,
    DHCP_IP_ADDRESS Start,
    DHCP_IP_ADDRESS End,
    ULONG BootpAllocated,
    ULONG MaxBootpAllowed,
    BOOL  fExclude
)
{
    WCHAR IpStart[20] = {L'\0'};
    WCHAR IpEnd[20] = {L'\0'};
    DWORD dw = 0;

    wsprintf(IpStart, L"   %s", IpAddressToString(Start));
    for( dw=wcslen(IpStart); dw<20; dw++)
    {
        IpStart[dw] = L' ';
    }
    IpStart[19] = L'\0';

    wsprintf(IpEnd, L"   %s", IpAddressToString(End));
    for( dw=wcslen(IpEnd); dw<20; dw++)
    {
        IpEnd[dw] = L' ';
    }
    IpEnd[19] = L'\0';

    if( FALSE is fExclude )
    {
        switch(Type ) 
        {
        case DhcpIpRanges : 
            DisplayMessage(g_hModule,
                           MSG_SCOPE_IPRANGE_INFO_DHCP,
                           IpStart,
                           IpEnd);
            break;
        case DhcpIpRangesDhcpOnly : 
            DisplayMessage(g_hModule,
                           MSG_SCOPE_IPRANGE_INFO_DHCPONLY,
                           IpStart,
                           IpEnd);
            break;
        case DhcpIpRangesDhcpBootp: 
            DisplayMessage(g_hModule,
                           MSG_SCOPE_IPRANGE_INFO_DHCPBOOTP,
                           IpStart,
                           IpEnd);
            break;
        case DhcpIpRangesBootpOnly:
            DisplayMessage(g_hModule,
                           MSG_SCOPE_IPRANGE_INFO_BOOTP,
                           IpStart,
                           IpEnd);
            break;
        case DhcpExcludedIpRanges:
            break;
        default: 
            DisplayMessage(g_hModule,
                           MSG_SCOPE_IPRANGE_INFO_UNKNOWN,
                           IpStart,
                           IpEnd);
            break;
        }
    }
    else
    {
        DisplayMessage(g_hModule, 
                       MSG_SCOPE_EXCLUDERANGE_INFO,
                       IpStart,
                       IpEnd);

    }
}


VOID
PrintClientInfo(
    LPDHCP_CLIENT_INFO_V4 ClientInfo,
    DWORD Level
)
{
    DWORD           i = 0, 
                    dwError = NO_ERROR;
    DWORD           DataLength = 0;
    LPBYTE          Data = NULL;
    FILETIME        ftTime = {0};
    WCHAR           *pwszClientType = NULL;
    WCHAR           IpAddress[17] = {L'\0'};
    WCHAR           SubnetMask[17] = {L'\0'};
    WCHAR           HardwareAdd[256*4] = {L'\0'};
    LPWSTR          pwszLease = NULL;
    WCHAR           ClientType[13] = {L'\0'};
    LPWSTR          pwcTemp = NULL;
    DWORD           dwTemp = 0, MsgId;

    enum {Time=0, Never, Inactive}Type = Time;

    DWORD dw = 0;

    pwcTemp = IpAddressToString(ClientInfo->ClientIpAddress);
    if( pwcTemp is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_DISPLAY_CLIENTS);
        return;
    }

    dwTemp = wcslen(pwcTemp);

    wcsncat(IpAddress, 
            pwcTemp,
            ( 16 < dwTemp ) ? 16 : dwTemp );


    for(dw=wcslen(IpAddress); dw<17; dw++)
    {
        IpAddress[dw] = L' ';
    }
    
    IpAddress[16] = L'\0';

    DhcpFreeMemory(pwcTemp);
    pwcTemp = NULL;

    pwcTemp = IpAddressToString(ClientInfo->SubnetMask);

    if( pwcTemp is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_DISPLAY_CLIENTS);
        return;
    }

    dwTemp = wcslen(pwcTemp);


    wcscpy(SubnetMask, L" ");
   
    wcsncat(SubnetMask,
            pwcTemp,
            ( dwTemp > 16 ) ? 16 : dwTemp);
   
    for(dw=wcslen(SubnetMask); dw<17; dw++)
    {
        SubnetMask[dw] = L' ';
    }

    SubnetMask[16] = L'\0';

    DhcpFreeMemory(pwcTemp);
    pwcTemp = NULL;

    DataLength = ClientInfo->ClientHardwareAddress.DataLength;
    
    Data = ClientInfo->ClientHardwareAddress.Data;
    
    if( Data is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_DISPLAY_CLIENTS);
        return;
    }

    i = 0;
    while ( i < DataLength )
    {
        wsprintf(HardwareAdd + wcslen(HardwareAdd), L"%.2x-", (DWORD)Data[i]);
        i++;
    }

    for( dw=wcslen(HardwareAdd)-1;dw<3*10; dw++)
    {
        HardwareAdd[dw] = L' ';
    }

    HardwareAdd[3*10-10] = L'\0';

    switch( ClientInfo->bClientType )
    {
        case CLIENT_TYPE_NONE:
            pwszClientType= L"N";
            break;

        case CLIENT_TYPE_DHCP:
            pwszClientType = L"D";
            break;

        case CLIENT_TYPE_BOOTP:
            pwszClientType = L"B";
            break;

        case CLIENT_TYPE_UNSPECIFIED:
        default:
            pwszClientType = L"U";
            break;
        
        case CLIENT_TYPE_RESERVATION_FLAG:
            pwszClientType = L"R";
            break;
    }

    for( dw=0; dw<13; dw++ )
        ClientType[dw] = L' ';

    ClientType[12] = L'\0';

    if( IsBadStringPtr(pwszClientType, MAX_STRING_LEN) is FALSE )
    {
        dwTemp = wcslen(pwszClientType);
        dwTemp = (dwTemp>12) ? 12 : dwTemp;

        wcsncpy(ClientType,
                pwszClientType,
                dwTemp);

        for( dw=wcslen(ClientType); dw<13; dw++ )
            ClientType[dw] = L' ';

        ClientType[12] = L'\0';                
    }
    
    if( Data is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_DISPLAY_CLIENTS);
        return;
    }
    
    ftTime = *(FILETIME *)(&ClientInfo->ClientLeaseExpires);

 
    if ( ClientInfo->ClientLeaseExpires.dwLowDateTime ==
            DHCP_DATE_TIME_INFINIT_LOW &&
         ClientInfo->ClientLeaseExpires.dwHighDateTime ==
            DHCP_DATE_TIME_INFINIT_HIGH )
    {
        Type = Never;
    }
    else if (ClientInfo->ClientLeaseExpires.dwLowDateTime ==
             DHCP_DATE_TIME_ZERO_LOW &&
             ClientInfo->ClientLeaseExpires.dwHighDateTime ==
             DHCP_DATE_TIME_ZERO_HIGH )
    {
        Type = Inactive;
    }
    else
    {
        pwszLease = GetDateTimeString(ftTime,
                                      TRUE,
                                      (int*)&Type);
    }


    if( Level == 0 ) {
        switch(Type)
        {
        case Never:
            MsgId = MSG_SCOPE_CLIENT_INFO_NEVER;
            break;
        case Inactive :
            MsgId = MSG_SCOPE_CLIENT_INFO_INACTIVE;
            break;
        case Time :
        default :
            MsgId = MSG_SCOPE_CLIENT_INFO;
            break;
        }
    } else {
        switch(Type)
        {
        case Never:
            MsgId = MSG_SCOPE_CLIENT_INFO2_NEVER;
            break;
        case Inactive :
            MsgId = MSG_SCOPE_CLIENT_INFO2_INACTIVE;
            break;
        case Time :
        default :
            MsgId = MSG_SCOPE_CLIENT_INFO2;
            break;
        }
    }
    
    DisplayMessage(g_hModule,
                   MsgId,
                   IpAddress,
                   SubnetMask,
                   HardwareAdd,
                   pwszClientType,
                   pwszLease ? pwszLease : L" ",
                   ClientInfo->ClientName ?
                   ClientInfo->ClientName : L""
        );

    if( pwszLease )
    {
        DhcpFreeMemory(pwszLease);
        pwszLease = NULL;
    }
}

VOID
PrintClientInfoV5(
    LPDHCP_CLIENT_INFO_V5 ClientInfo
    )
{
    DWORD       i = 0;
    DWORD       DataLength = 0;
    LPBYTE      Data = NULL;
    FILETIME    ftTime = {0};
    WCHAR       *pwszClientType = NULL;
    WCHAR       IpAddress[17] = {L'\0'};
    WCHAR       SubnetMask[17] = {L'\0'};
    WCHAR       HardwareAdd[256*4] = {L'\0'};
    LPWSTR      pwszLease = NULL;
    WCHAR       ClientType[13] = {L'\0'};
    DWORD       dwTemp = 0;
    LPWSTR      pwcTemp = NULL;
    enum {Time=0, Never, Inactive}Type = Time;

    DWORD       dw = 0;

    pwcTemp = IpAddressToString(ClientInfo->ClientIpAddress);
    if( pwcTemp is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_DISPLAY_CLIENTS);
        return;
    }

    dwTemp = wcslen(pwcTemp);

    wcsncat(IpAddress, 
            pwcTemp,
            ( dwTemp > 16 ) ? 16 : dwTemp );

    
    for(dw=wcslen(IpAddress); dw<17; dw++)
    {
        IpAddress[dw] = L' ';
    }
    IpAddress[16] = L'\0';

    DhcpFreeMemory(pwcTemp);
    pwcTemp = NULL;
    dwTemp = 0;

    pwcTemp = IpAddressToString(ClientInfo->SubnetMask);

    if( pwcTemp is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_DISPLAY_CLIENTS);
        return;
    }

    dwTemp = wcslen(pwcTemp);

    wcscpy(SubnetMask, L" ");

    wcsncat(SubnetMask,
            pwcTemp,
            ( dwTemp > 16 ) ? 16 : dwTemp );

    
    for(dw=wcslen(SubnetMask); dw<17; dw++)
    {
        SubnetMask[dw] = L' ';
    }
    SubnetMask[16] = L'\0';

    DhcpFreeMemory(pwcTemp);
    pwcTemp = NULL;
    dwTemp = 0;

    DataLength = ClientInfo->ClientHardwareAddress.DataLength;
    Data = ClientInfo->ClientHardwareAddress.Data;
    
    if( Data is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_DISPLAY_CLIENTS);
    }

    i = 0;
    dwTemp = DataLength; 

    while ( i < dwTemp )
    {
        wsprintf(HardwareAdd + wcslen(HardwareAdd), L"%.2x-", (DWORD)Data[i]);
        i++;
    }

    for( dw=wcslen(HardwareAdd)-1;dw<3*10; dw++)
    {
        HardwareAdd[dw] = L' ';
    }
    HardwareAdd[3*10-10] = L'\0';

    switch( ClientInfo->bClientType )
    {
        case CLIENT_TYPE_NONE:
            pwszClientType= L"N";
            break;

        case CLIENT_TYPE_DHCP:
            pwszClientType = L"D";
            break;

        case CLIENT_TYPE_BOOTP:
            pwszClientType = L"B";
            break;

        case CLIENT_TYPE_UNSPECIFIED:
        default:
            pwszClientType = L"U";
            break;
        
        case CLIENT_TYPE_RESERVATION_FLAG:
            pwszClientType = L"R";
            break;
    }

    if( IsBadStringPtr(pwszClientType, MAX_STRING_LEN) is FALSE )
    {
        dwTemp = wcslen(pwszClientType);

        wcsncpy(ClientType,
                pwszClientType,
                ( dwTemp > 12 ) ? 12 : dwTemp );
        for( dw=wcslen(ClientType); dw<13; dw++ )
            ClientType[dw] = L' ';

        ClientType[12] = L'\0';                
    }
    
    if( Data is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_DISPLAY_CLIENTS);
        return;
    }

    ftTime = *(FILETIME *)(&ClientInfo->ClientLeaseExpires);
 
    if ( ClientInfo->ClientLeaseExpires.dwLowDateTime ==
            DHCP_DATE_TIME_INFINIT_LOW &&
         ClientInfo->ClientLeaseExpires.dwHighDateTime ==
            DHCP_DATE_TIME_INFINIT_HIGH )
    {
        Type = Never;
    }
    else if (ClientInfo->ClientLeaseExpires.dwLowDateTime ==
             DHCP_DATE_TIME_ZERO_LOW &&
             ClientInfo->ClientLeaseExpires.dwHighDateTime ==
             DHCP_DATE_TIME_ZERO_HIGH )
    {
        Type = Inactive;
    }
    else
    {
        Type = 0;
        pwszLease = GetDateTimeString(ftTime,
                                      TRUE,
                                      (int*)&Type);

    }


    switch(Type)
    {
    case Never:
        {
            DisplayMessage(g_hModule,
                           MSG_SCOPE_CLIENT_INFO_NEVER,
                           IpAddress,
                           SubnetMask,
                           HardwareAdd,
                           pwszClientType);
            break;
        }
    case Inactive:
        {
            DisplayMessage(g_hModule,
                           MSG_SCOPE_CLIENT_INFO_INACTIVE,
                           IpAddress,
                           SubnetMask,
                           HardwareAdd,
                           pwszClientType);
            break;
        }
    case Time:
    default:
        {
            DisplayMessage(g_hModule, 
                           MSG_SCOPE_CLIENT_INFO,
                           IpAddress,
                           SubnetMask,
                           HardwareAdd,
                           pwszLease ? pwszLease : L" ",
                           pwszClientType);
        }
        break;
    }
    if( pwszLease )
    {
        DhcpFreeMemory(pwszLease);
        pwszLease = NULL;
    }
}

VOID
PrintClientInfoShort(
    LPDHCP_CLIENT_INFO_V4 ClientInfo
    )
{
    FILETIME ftTime = {0};
    LPWSTR   pwszTime = NULL;

    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT,
                GlobalClientCount++,
                IpAddressToString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );

    ftTime = *(FILETIME *)(&ClientInfo->ClientLeaseExpires);
    
    if ( ClientInfo->ClientLeaseExpires.dwLowDateTime ==
        DHCP_DATE_TIME_INFINIT_LOW &&
     ClientInfo->ClientLeaseExpires.dwHighDateTime ==
        DHCP_DATE_TIME_INFINIT_HIGH )
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_DURATION_STR);
    }
    else
    {
        int i = 0;
        pwszTime = GetDateTimeString(ftTime,
                                     FALSE,
                                     &i);

        DisplayMessage(g_hModule,
                       MSG_SCOPE_CLIENT_DURATION_DATE_EXPIRES,
                       pwszTime ? pwszTime : L" ");

        if( pwszTime )
        {
            DhcpFreeMemory(pwszTime);
            pwszTime = NULL;
        }
                          
    }
    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
}

VOID
PrintClientInfoShortV5(
    LPDHCP_CLIENT_INFO_V5 ClientInfo
    )
{
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT,
                GlobalClientCount++,
                IpAddressToString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );
    if ( ClientInfo->ClientLeaseExpires.dwLowDateTime ==
        DHCP_DATE_TIME_INFINIT_LOW &&
     ClientInfo->ClientLeaseExpires.dwHighDateTime ==
        DHCP_DATE_TIME_INFINIT_HIGH )
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_DURATION_STR);
    }
    else if( FileTimeToLocalFileTime(
            (FILETIME *)(&ClientInfo->ClientLeaseExpires),
            &LocalTime) ) 
    {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) 
        {

            DisplayMessage(g_hModule, 
                           MSG_SCOPE_CLIENT_DURATION_DATE_EXPIRES,
                           SystemTime.wMonth,
                           SystemTime.wDay,
                           SystemTime.wYear,
                           SystemTime.wHour,
                           SystemTime.wMinute,
                           SystemTime.wSecond );
        }
        else 
        {
            DisplayMessage(g_hModule, EMSG_SCOPE_INTERNAL_ERROR);
        }
    }
    else 
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INTERNAL_ERROR);
    }
    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_STATE, ClientInfo->AddressState);
    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
}

VOID
PrintClientInfoShort1(
    LPDHCP_CLIENT_INFO_V4 ClientInfo
    )
{
    DWORD i;
    DWORD DataLength;
    LPBYTE Data;

    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT,
                GlobalClientCount++,
                IpAddressToString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );

    DataLength = ClientInfo->ClientHardwareAddress.DataLength;
    Data = ClientInfo->ClientHardwareAddress.Data;
    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_HWADDRESS);
    for( i = 0; i < DataLength; i++ ) 
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_HWADDRESS_FORMAT, (DWORD)Data[i]);
        if((i+1)<DataLength)
            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_DASH);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
}


VOID
PrintClientInfoShort1V5(
    LPDHCP_CLIENT_INFO_V5 ClientInfo
    )
{
    DWORD i;
    DWORD DataLength;
    LPBYTE Data;

    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT,
                GlobalClientCount++,
                IpAddressToString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );

    DataLength = ClientInfo->ClientHardwareAddress.DataLength;
    Data = ClientInfo->ClientHardwareAddress.Data;

    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_HWADDRESS);

    for( i = 0; i < DataLength; i++ ) 
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_HWADDRESS_FORMAT, (DWORD)Data[i]);
        if((i+1)<DataLength)
            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_DASH);
    }

    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_STATE, ClientInfo->AddressState);
    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
}

LPWSTR
GetDynBootpClassName()
{
    DWORD                          Error = NO_ERROR;
    DWORD                          nRead, nTotal, nCount;
    DHCP_RESUME_HANDLE             ResumeHandle;
    LPDHCP_CLASS_INFO_ARRAY        ClassInfoArray = NULL;
    LPWSTR                         pwszClass = NULL;


    while(TRUE)
    {
        Error = DhcpEnumClasses(
                    g_ServerIpAddressUnicodeString,
                    0,
                    &ResumeHandle,
                    ~0,
                    &ClassInfoArray,
                    &nRead,
                    &nTotal
                );

        if( Error isnot NO_ERROR )
        {
            return NULL;
        }
       
        for( nCount = 0; nCount < ClassInfoArray->NumElements; nCount ++ )
        {
            if( ClassInfoArray->Classes[nCount].ClassData )
            {              
                if( strlen(DHCP_BOOTP_CLASS_TXT) is ClassInfoArray->Classes[nCount].ClassDataLength )
                {                    
                    if( memcmp(DHCP_BOOTP_CLASS_TXT, 
                               ClassInfoArray->Classes[nCount].ClassData, 
                               strlen(DHCP_BOOTP_CLASS_TXT))is 0 )
                    {
                        pwszClass = DhcpAllocateMemory( ( wcslen(ClassInfoArray->Classes[nCount].ClassName) + 1 )*sizeof(WCHAR));
                        if( pwszClass is NULL )
                        {
                            DhcpRpcFreeMemory(ClassInfoArray);
                            ClassInfoArray = NULL;
                            return NULL;
                        }

                        wcscpy(pwszClass, ClassInfoArray->Classes[nCount].ClassName);
                        DhcpRpcFreeMemory(ClassInfoArray);
                        ClassInfoArray = NULL;
                        return pwszClass;
                    }
                }
            }
        }

    }
}

typedef enum {
    LEASE_IPADDR,
    LEASE_HOSTNAME,
    LEASE_ALL_BAD_ADDRESSES,
    LEASE_ALL_RASSERVER_ADDRESSES,

    LEASE_INVALID
} LEASETYPE;

LEASETYPE
IsValidDeleteClientArgument(
    LPCWSTR pArg
)

{
    // Expected arguments
    // Delete client <leaseip | \\\\hostname | all_bad_addresses | all_rasserver_addresses>

    LEASETYPE retval;

    if (( 0 == wcsncmp( pArg, L"\\\\", 2 )) &&
        ( wcslen( pArg ) > 2 )) {
        retval = LEASE_HOSTNAME;
    }
    else if ( 0 == _wcsicmp( pArg, L"allbadaddresses" )) {
        retval = LEASE_ALL_BAD_ADDRESSES;
    }
    else if ( 0 == _wcsicmp( pArg, L"allrasserveraddresses" )) {
        retval = LEASE_ALL_RASSERVER_ADDRESSES;
    }
    else if ( IsIpAddress( pArg )) {
        retval = LEASE_IPADDR;
    }
    else {
        retval = LEASE_INVALID;
    }

    return retval;
} // IsValidDeleteClientArgument()


DWORD
HandleScopeDeleteClient(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    // Expected arguments
    // Delete client <leaseip | \\\\hostname | all_bad_addresses | all_rasserver_addresses>

    LEASETYPE          type;
    DHCP_SEARCH_INFO   SearchInfo;
    LPDHCP_CLIENT_INFO pClientInfo = NULL;
    LPWSTR             pArg;
    DWORD              Error;

    // Validate arguments

    if ( 1 != dwArgCount ) {
        DisplayMessage( g_hModule,
                        HLP_SCOPE_DELETE_CLIENT_EX,
                        ERROR_INVALID_PARAMETER );
        return ERROR_INVALID_PARAMETER;
    }

    pArg = ppwcArguments[ dwCurrentIndex ];
    type = IsValidDeleteClientArgument( pArg );
    if ( LEASE_INVALID == type ) {
        DisplayMessage( g_hModule, 
                        EMSG_DHCP_INVALID_PARAMETER, 
                        ERROR_INVALID_PARAMETER );
        return ERROR_INVALID_PARAMETER;
    }

    // Process the request

    switch ( type ) {
    case LEASE_IPADDR: {
        DHCP_IP_ADDRESS IpAddr;

        IpAddr = DhcpDottedStringToIpAddressW( pArg );

        SearchInfo.SearchType = DhcpClientIpAddress;
        SearchInfo.SearchInfo.ClientIpAddress = IpAddr;

        Error = DhcpGetClientInfo( g_ServerIpAddressUnicodeString,
                                   &SearchInfo,
                                   &pClientInfo );
        if (( NO_ERROR != Error ) ||
            ( NULL == pClientInfo )) {
            DisplayMessage( g_hModule, 
                            EMSG_SCOPE_DELETE_CLIENT_FAILED,
                            pArg,
                            ERROR_INVALID_PARAMETER );
            return Error;
        }

        Error = DhcpDeleteClientInfo( g_ServerIpAddressUnicodeString,
                                      &SearchInfo );
        DhcpRpcFreeMemory( pClientInfo );
        if ( NO_ERROR != Error ) {
            DisplayMessage( g_hModule, 
                            EMSG_SCOPE_DELETE_CLIENT_FAILED,
                            pArg,
                            ERROR_INVALID_PARAMETER );
            return Error;
        }

        break;
    }  // LEASE_IPADDR;

    case LEASE_HOSTNAME: {
        SearchInfo.SearchType = DhcpClientName;
        SearchInfo.SearchInfo.ClientName = &pArg[ 2 ];

        Error = DhcpGetClientInfo( g_ServerIpAddressUnicodeString,
                                   &SearchInfo,
                                   &pClientInfo );
        if (( NO_ERROR != Error ) ||
            ( NULL == pClientInfo )) {
            DisplayMessage( g_hModule,
                            EMSG_SCOPE_DELETE_CLIENT_FAILED,
                            pArg,
                            ERROR_INVALID_PARAMETER );
            return Error;
        }

        Error = DhcpDeleteClientInfo( g_ServerIpAddressUnicodeString,
                                      &SearchInfo );
        DhcpRpcFreeMemory( pClientInfo );

        if ( NO_ERROR != Error ) {
            DisplayMessage( g_hModule,
                            EMSG_SCOPE_DELETE_CLIENT_FAILED,
                            ERROR_INVALID_PARAMETER );
            return Error;
        }

        break;
    } // LEASE_HOSTNAME

    case LEASE_ALL_BAD_ADDRESSES: 
    case LEASE_ALL_RASSERVER_ADDRESSES: {
        LPDHCP_CLIENT_INFO_ARRAY pClientInfoArr = NULL;
        DHCP_RESUME_HANDLE       ResumeHandle = 0;
        DWORD                    Read, Total, i;
        BOOL                     bDelete = FALSE;

        Error = DhcpEnumSubnetClients( g_ServerIpAddressUnicodeString,
                                       g_ScopeIpAddress,
                                       &ResumeHandle, ( DWORD ) -1,
                                       &pClientInfoArr, &Read, &Total );
        if (( NO_ERROR !=  Error ) || 
            ( NULL == pClientInfoArr )) {
            DisplayMessage( g_hModule,
                            EMSG_SCOPE_DELETE_CLIENT_FAILED,
                            NULL, ERROR_INVALID_PARAMETER );
            break;
        } // if 

        i = 0; 
        Error = NO_ERROR;
        while ( i < pClientInfoArr->NumElements ) {
            if ( LEASE_ALL_BAD_ADDRESSES == type ) {
                bDelete = ( 0 == wcscmp( pClientInfoArr->Clients[ i ]->ClientName,
                                         L"BAD_ADDRESS" ));
            } // if bad address
            else {
                DHCP_BINARY_DATA *pClientUid;

                pClientUid = &pClientInfoArr->Clients[ i ]->ClientHardwareAddress;
                bDelete = (( pClientUid->DataLength >= 3 ) &&
                           ( pClientUid->Data[ 0 ] == 'R' ) &&
                           ( pClientUid->Data[ 1 ] == 'A' ) &&
                           ( pClientUid->Data[ 2 ] == 'S' ));
            } // else RAS

            if ( bDelete ) {
                SearchInfo.SearchType = DhcpClientIpAddress;
                SearchInfo.SearchInfo.ClientIpAddress = pClientInfoArr->Clients[ i ]->ClientIpAddress;
                Error = DhcpDeleteClientInfo( g_ServerIpAddressUnicodeString,
                                              &SearchInfo );

                if ( NO_ERROR != Error ) {
                    LPWSTR pBuf = DhcpIpAddressToDottedStringW( pClientInfoArr->Clients[ i ]->ClientIpAddress );

                    DisplayMessage( g_hModule,
                                    EMSG_SCOPE_DELETE_CLIENT_FAILED,
                                    pBuf, ERROR_INVALID_PARAMETER );
                    DhcpFreeMemory( pBuf );
                } // if 
            } // if bDelete

            i++;
        } // while;

        DhcpRpcFreeMemory( pClientInfoArr );

        if ( NO_ERROR == Error ) {
                DisplayMessage( g_hModule, EMSG_DHCP_ERROR_SUCCESS );
                return Error;
        } // if

        break;
    } // LEASE_ALL_BAD_ADDRESSES, LEASE_ALL_RASSERVER_ADDRESSES

    default:
        DhcpAssert( FALSE );
    } // switch

    return ERROR_SUCCESS;
} // HandleScopeDeleteClient()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\dhcp\precomp.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/

#define MAX_DLL_NAME    48

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>

#include <winsock2.h>

#include <tchar.h>
#include <wchar.h>

#include <netsh.h>
#include <netshp.h>

#include <jet.h>

#include <dhcpapi.h>
#include <ipexport.h>
#include <icmpif.h>
#include <icmpapi.h>

#ifdef NT5
#include <mdhcsapi.h>
#endif NT5

#include "common.h"
#include "dhcpmgr.h"
#include "dhcpdefs.h"
#include "strdefs.h"
#include "dhcphandle.h"
#include "dhcpmon.h"
#include "srvrmon.h"
#include "srvrhndl.h"
#include "scopemon.h"
#include "scopehndl.h"
#include "mscopemon.h"
#include "mscopehndl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\dhcp\mscopemon.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\dhcp\dhcpmon.c

Abstract:

    SRVR Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 11/14/98

--*/
#include "precomp.h"

//
// The DHCP manager's commands are broken into 2 sets
//      - The commands are split into "command groups"
//        i.e, commands grouped by the VERB where the VERB is ADD, DELETE,
//        SHOW or SET.  This is not for any technical reason - only for
//        staying with the semantics used in netsh with which it will be 
//		  integrated
//      - The commands which are supported by the subcontext commands of 
//        the server. The subcontext supported by DHCP is Server.
//
// A command is described using a CMD_ENTRY structure. It requires the
// command token, the handler, a short help message token and an extended 
// help message token.  To make it easier to create we use the 
// CREATE_CMD_ENTRY macro. This, however puts restrictions on how the tokens
// are named.
//
// The command groups are simply arrays of the CMD_ENTRY structure.  The 
// top level commands are also grouped in a similar array.
//
// The info about a complete command group is put in a CMD_GROUP_ENTRY
// structure, all of which are put in an array.
//
 

//
// NOTE: Since we have only one entry per group, currently, we really didnt
// need command groups. This is done for later extensibility.
// To add a command entry to a group, simply add the command to the appropriate
// array
// To add a command group - create and array and add its info to the
// command group array
//


extern HANDLE   g_hModule;
extern HANDLE   g_hParentModule;
extern HANDLE   g_hDhcpsapiModule;
extern BOOL     g_bCommit;
extern BOOL     g_hConnect;

extern BOOL     g_fMScope;
extern DWORD    g_dwNumTableEntries;
extern PWCHAR   g_pwszRouter;
extern PWCHAR   g_pwszServer;
extern WCHAR    g_ServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1];
extern CHAR     g_ScopeIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern WCHAR    g_ScopeIpAddressUnicodeString[MAX_IP_STRING_LEN+1];

BOOL     g_fMScope;

extern LPWSTR   g_pwszServer;
extern DHCP_IP_ADDRESS g_ServerIpAddress;



LPSTR           g_MScopeNameAnsiString = NULL;
LPWSTR          g_MScopeNameUnicodeString = NULL;
DWORD           g_MScopeID = 0;

CMD_ENTRY  g_MScopeAddCmdTable[] = {
    CREATE_CMD_ENTRY(MSCOPE_ADD_EXCLUDERANGE, HandleMScopeAddExcluderange),
    CREATE_CMD_ENTRY(MSCOPE_ADD_IPRANGE, HandleMScopeAddIprange),
};

CMD_ENTRY  g_MScopeCheckCmdTable[] = {
    CREATE_CMD_ENTRY(MSCOPE_CHECK_DATABASE, HandleMScopeCheckDatabase),
};

CMD_ENTRY  g_MScopeDeleteCmdTable[] = {
    CREATE_CMD_ENTRY(MSCOPE_DELETE_EXCLUDERANGE, HandleMScopeDeleteExcluderange),
    CREATE_CMD_ENTRY(MSCOPE_DELETE_IPRANGE, HandleMScopeDeleteIprange),
 //   CREATE_CMD_ENTRY(MSCOPE_DELETE_OPTIONVALUE, HandleMScopeDeleteOptionvalue),
};


CMD_ENTRY g_MScopeSetCmdTable[] = {
    CREATE_CMD_ENTRY(MSCOPE_SET_COMMENT, HandleMScopeSetComment),
    CREATE_CMD_ENTRY(MSCOPE_SET_EXPIRY, HandleMScopeSetExpiry),
    CREATE_CMD_ENTRY(MSCOPE_SET_LEASE, HandleMScopeSetLease),
    CREATE_CMD_ENTRY(MSCOPE_SET_MSCOPE, HandleMScopeSetMScope),
    CREATE_CMD_ENTRY(MSCOPE_SET_NAME, HandleMScopeSetName),
//     CREATE_CMD_ENTRY(MSCOPE_SET_OPTIONVALUE, HandleMScopeSetOptionvalue),        
    CREATE_CMD_ENTRY(MSCOPE_SET_STATE, HandleMScopeSetState),
    CREATE_CMD_ENTRY(MSCOPE_SET_TTL, HandleMScopeSetTTL),
};

CMD_ENTRY g_MScopeShowCmdTable[] = {
    CREATE_CMD_ENTRY(MSCOPE_SHOW_CLIENTS, HandleMScopeShowClients),
    CREATE_CMD_ENTRY(MSCOPE_SHOW_EXCLUDERANGE, HandleMScopeShowExcluderange),
    CREATE_CMD_ENTRY(MSCOPE_SHOW_EXPIRY, HandleMScopeShowExpiry),
    CREATE_CMD_ENTRY(MSCOPE_SHOW_IPRANGE, HandleMScopeShowIprange),
    CREATE_CMD_ENTRY(MSCOPE_SHOW_LEASE, HandleMScopeShowLease),
    CREATE_CMD_ENTRY(MSCOPE_SHOW_MIBINFO, HandleMScopeShowMibinfo),
    CREATE_CMD_ENTRY(MSCOPE_SHOW_MSCOPE, HandleMScopeShowMScope),
//    CREATE_CMD_ENTRY(MSCOPE_SHOW_OPTIONVALUE, HandleMScopeShowOptionvalue),
    CREATE_CMD_ENTRY(MSCOPE_SHOW_STATE, HandleMScopeShowState),
    CREATE_CMD_ENTRY(MSCOPE_SHOW_TTL, HandleMScopeShowTTL),
};


CMD_GROUP_ENTRY g_MScopeCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD, g_MScopeAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_MScopeDeleteCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_CHECK, g_MScopeCheckCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET, g_MScopeSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_MScopeShowCmdTable),
};


CMD_ENTRY g_MScopeCmds[] = 
{
    CREATE_CMD_ENTRY(DHCP_LIST, HandleMScopeList),
    CREATE_CMD_ENTRY(MSCOPE_DUMP, HandleMScopeDump),
    CREATE_CMD_ENTRY(DHCP_HELP1, HandleMScopeHelp),
    CREATE_CMD_ENTRY(DHCP_HELP2, HandleMScopeHelp),
    CREATE_CMD_ENTRY(DHCP_HELP3, HandleMScopeHelp),
    CREATE_CMD_ENTRY(DHCP_HELP4, HandleMScopeHelp),
};



ULONG g_ulMScopeNumTopCmds = sizeof(g_MScopeCmds)/sizeof(CMD_ENTRY);
ULONG g_ulMScopeNumGroups = sizeof(g_MScopeCmdGroups)/sizeof(CMD_GROUP_ENTRY);

DWORD
WINAPI
MScopeCommit(
    IN  DWORD   dwAction
)
{
    BOOL    bCommit, bFlush = FALSE;

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. Srvr current state is commit, then
            // nothing to be done.
            //

            if(g_bCommit)
            {
                return NO_ERROR;
            }

            bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    return NO_ERROR;
}

DWORD
WINAPI
MScopeMonitor(
    IN      LPCWSTR     pwszMachine,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      DWORD       dwFlags,
    IN      LPCVOID     pvData,
    OUT     LPWSTR      pwcNewContext
    )
{
    DWORD           dwError = NO_ERROR;
    DWORD           dwIndex, i, j, k;
    DWORD           MscopeIndex = 0;
    BOOL            bFound = FALSE;
    PFN_HANDLE_CMD  pfnHandler = NULL;
    DWORD           dwNumMatched;
    DWORD           dwCmdHelpToken = 0;
    DWORD           dwIsMScope = 0;
    PWCHAR          pwcContext = NULL;
    LPWSTR          pwszMScopeTemp = NULL;
    BOOL            fTemp = FALSE;

    if( dwArgCount < 2 )
    {
        DisplayMessage(g_hModule, EMSG_MSCOPE_NO_MSCOPENAME);
        return ERROR_INVALID_PARAMETER;
    }

    dwIndex = 1;

    if( IsValidMScope( g_ServerIpAddressUnicodeString, ppwcArguments[dwIndex] ) )
    {
        if( g_fMScope is TRUE and
            dwArgCount> 2)
        {
            pwszMScopeTemp = DhcpAllocateMemory((wcslen(g_MScopeNameUnicodeString)+1)*sizeof(WCHAR));
            if( pwszMScopeTemp is NULL )
                return ERROR_INVALID_PARAMETER;
            memset(pwszMScopeTemp, 0x00, (wcslen(g_MScopeNameUnicodeString)+1)*sizeof(WCHAR));
            wcscpy(pwszMScopeTemp, g_MScopeNameUnicodeString);
            fTemp = TRUE;
        }
        if( SetMScopeInfo(ppwcArguments[dwIndex]) is FALSE )
        {
            if( g_MScopeNameUnicodeString is NULL )
            {
                DisplayMessage(g_hModule, EMSG_MSCOPE_INVALID_MSCOPE_NAME);
                return ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            g_fMScope = TRUE;
            pwcNewContext[wcslen(pwcNewContext) - wcslen(ppwcArguments[dwIndex]) - 1] = L'\0';
            dwIndex++;
            dwIsMScope++;
	    MscopeIndex = 1;
            //dwArgCount--;
            if( fTemp is FALSE )
            {
                DisplayMessage(g_hModule,
                               MSG_MSCOPE_CHANGE_CONTEXT,
                               g_MScopeNameUnicodeString);
            }
        }
    }
    
    if( g_MScopeNameUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_MSCOPE_NO_MSCOPENAME);
        dwError = ERROR_INVALID_PARAMETER;
        goto CleanUp;
    }

    //No more arguments. Context switch.
    if( dwIndex >= dwArgCount )
    {
        dwError = ERROR_CONTEXT_SWITCH;
        //wcscpy( pwcNewContext, L"dhcp server mscope");
        goto CleanUp;
    }

    //Is it a top level(non Group command)?

    for(i=0; i<g_ulMScopeNumTopCmds; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_MScopeCmds[i].pwszCmdToken))
        {
            bFound = TRUE;

            pfnHandler = g_MScopeCmds[i].pfnCmdHandler;

            dwCmdHelpToken = g_MScopeCmds[i].dwCmdHlpToken;
            dwIndex++;
            break;
        }
    }


    if(bFound)
    {
        if ((( dwArgCount - MscopeIndex )  > 2 ) &&
	    ( IsHelpToken(ppwcArguments[ dwIndex ])))
        {
            DisplayMessage(g_hModule, dwCmdHelpToken);

            return NO_ERROR;
        }
        
        dwIndex++;

        dwError = (*pfnHandler)(pwszMachine, ppwcArguments, dwIndex, dwArgCount, 
                                dwFlags, pvData, &bFound);
        
        return dwError;
    }

    if( g_fMScope is FALSE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_NO_SCOPENAME);
        dwError = ERROR_INVALID_PARAMETER;
        goto CleanUp;
    }

    bFound = FALSE;


    //It is not a non Group Command. Then is it a config command for the manager?
    for(i = 0; (i < g_ulMScopeNumGroups) and !bFound; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_MScopeCmdGroups[i].pwszCmdGroupToken))
        {

            //
            // Command matched entry i, so look at the table of sub commands 
            // for this command
            //
            
            if( dwArgCount > dwIndex+1 )
            {
                for (j = 0; j < g_MScopeCmdGroups[i].ulCmdGroupSize; j++)
                {
                    if (MatchCmdLine(ppwcArguments+dwIndex,
                                      dwArgCount - 1,
                                      g_MScopeCmdGroups[i].pCmdGroup[j].pwszCmdToken,
                                      &dwNumMatched))
                    {
                        bFound = TRUE;
                
                        pfnHandler = g_MScopeCmdGroups[i].pCmdGroup[j].pfnCmdHandler;
                
                        dwCmdHelpToken = g_MScopeCmdGroups[i].pCmdGroup[j].dwCmdHlpToken;

                        dwIndex++;
                        //
                        // break out of the for(j) loop
                        //
                        break;
                    }
                }
            }

            if(!bFound)
            {
                //
                // We matched the command group token but none of the
                // sub commands
                //

                DisplayMessage(g_hModule, 
                               EMSG_SCOPE_INCOMPLETE_COMMAND);

                for (j = 0; j < g_MScopeCmdGroups[i].ulCmdGroupSize; j++)
                {
                    DisplayMessage(g_hModule, 
                             g_MScopeCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);
                    
                    DisplayMessage(g_hModule,
                                   MSG_DHCP_FORMAT_LINE);
                }

                dwError = ERROR_INVALID_PARAMETER;
                goto CleanUp;
            }
            else
            {
                //
                // quit the for(i)
                //

                break;
            }
        }
    }

    if (!bFound)
    {
        //
        // Command not found. 
        //
        if( _wcsicmp(ppwcArguments[dwIndex], L"..") is 0 )
        {
            if( g_MScopeNameUnicodeString )
            {
                memset(g_MScopeNameUnicodeString, 0x00, (wcslen(g_MScopeNameUnicodeString)+1)*sizeof(WCHAR));
                DhcpFreeMemory(g_MScopeNameUnicodeString);
                g_MScopeNameUnicodeString = NULL;
            }
            if( g_MScopeNameAnsiString )
            {
                memset(g_MScopeNameAnsiString, 0x00, (strlen(g_MScopeNameAnsiString)+1)*sizeof(CHAR));
                DhcpFreeMemory(g_MScopeNameAnsiString);
                g_MScopeNameAnsiString = NULL;
            }

            g_MScopeID = 0;     
            g_fMScope = FALSE;
        }

        dwError = ERROR_CMD_NOT_FOUND;
        goto CleanUp;
    }

    //
    // See if it is a request for help.
    //

    dwNumMatched += dwIsMScope;
    if (dwNumMatched < (dwArgCount - 1) &&
        IsHelpToken(ppwcArguments[dwNumMatched + 1]))
    {
        DisplayMessage(g_hModule, dwCmdHelpToken);

        dwError = NO_ERROR;
        goto CleanUp;
    }
    
    //
    // Call the parsing routine for the command
    //

    dwError = (*pfnHandler)(pwszMachine, ppwcArguments+1, 
                            /*dwNumMatched + 1*/dwIndex, 
                            dwArgCount-1 - dwIndex, dwFlags, pvData, &bFound);
CleanUp:
    if( fTemp is TRUE )
    {
        if( pwszMScopeTemp )
        {
            fTemp = SetMScopeInfo(pwszMScopeTemp);
            memset(pwszMScopeTemp, 0x00, (wcslen(pwszMScopeTemp)+1)*sizeof(WCHAR));
            DhcpFreeMemory(pwszMScopeTemp);
            pwszMScopeTemp = NULL;
        }
        
    }
    return dwError;
}



DWORD
WINAPI
MScopeUnInit(
    IN  DWORD   dwReserved
    )
{
    if(InterlockedDecrement(&g_ulInitCount) isnot 0)
    {
        return NO_ERROR;
    }

    return NO_ERROR;
}


BOOL
SetMScopeInfo(
    IN  LPWSTR  pwszMScope
)
{
    DWORD   Error = NO_ERROR;
    LPDHCP_MSCOPE_INFO  MScopeInfo = NULL;
    LPSTR Tmp;
    
    if( pwszMScope is NULL )
        return FALSE;
    Error = DhcpGetMScopeInfo( g_ServerIpAddressUnicodeString,
                               pwszMScope,
                               &MScopeInfo);
    
    if( Error isnot NO_ERROR )
        return FALSE;
    
    g_MScopeID = MScopeInfo->MScopeId;
    
    g_MScopeNameUnicodeString = DhcpAllocateMemory((wcslen(pwszMScope)+1)*sizeof(WCHAR));
    if( g_MScopeNameUnicodeString is NULL )
        return FALSE;
    memset(g_MScopeNameUnicodeString, 0x00, (wcslen(pwszMScope)+1)*sizeof(WCHAR));
    wcscpy(g_MScopeNameUnicodeString, pwszMScope);
    
    g_MScopeNameAnsiString = DhcpAllocateMemory((wcslen(pwszMScope)+1)*sizeof(CHAR));
    if( NULL == g_MScopeNameAnsiString ) {
        DhcpFreeMemory( g_MScopeNameUnicodeString );
        g_MScopeNameUnicodeString = NULL;
        DhcpRpcFreeMemory( MScopeInfo );
        return FALSE ;
    }
    
    memset(g_MScopeNameAnsiString, 0x00, (wcslen(pwszMScope)+1)*sizeof(CHAR));
    Tmp = DhcpUnicodeToOem(pwszMScope, NULL);
    if( NULL == Tmp ) {
        DhcpFreeMemory( g_MScopeNameUnicodeString );
        DhcpFreeMemory( g_MScopeNameAnsiString );
        g_MScopeNameUnicodeString = NULL;
        g_MScopeNameAnsiString = NULL;
        DhcpRpcFreeMemory( MScopeInfo );
        return FALSE;
    }
    
    strcpy(g_MScopeNameAnsiString, Tmp);

    DhcpRpcFreeMemory(MScopeInfo);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\dhcp\dhcpmon.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\dhcp\dhcpmon.c

Abstract:

    DHCP Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 11/14/98

--*/
#include "precomp.h"

//
// The DHCP manager's commands are broken into 2 sets
//      - The commands are split into "command groups"
//        i.e, commands grouped by the VERB where the VERB is ADD, DELETE,
//        SHOW or SET.  This is not for any technical reason - only for
//        staying with the semantics used in netsh with which it will be 
//                integrated
//      - The commands which are supported by the subcontext commands of 
//        the server. The subcontext supported by DHCP is Server.
//
// A command is described using a CMD_ENTRY structure. It requires the
// command token, the handler, a short help message token and an extended 
// help message token.  To make it easier to create we use the 
// CREATE_CMD_ENTRY macro. This, however puts restrictions on how the tokens
// are named.
//
// The command groups are simply arrays of the CMD_ENTRY structure.  The 
// top level commands are also grouped in a similar array.
//
// The info about a complete command group is put in a CMD_GROUP_ENTRY
// structure, all of which are put in an array.
//
 

//
// NOTE: Since we have only one entry per group, currently, we really didnt
// need command groups. This is done for later extensibility.
// To add a command entry to a group, simply add the command to the appropriate
// array
// To add a command group - create and array and add its info to the
// command group array
//


HANDLE   g_hModule = NULL;
HANDLE   g_hDhcpsapiModule = NULL;
BOOL     g_bCommit = TRUE;
BOOL     g_hConnect = FALSE;
BOOL     g_bDSInit = FALSE;
BOOL     g_bDSTried = FALSE;
DWORD    g_dwNumTableEntries = 0;
PWCHAR   g_pwszRouter = NULL;

//{0f7412f0-80fc-11d2-be57-00c04fc3357a}
static const GUID g_MyGuid = 
{ 0x0f7412f0, 0x80fc, 0x11d2, { 0xbe, 0x57, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

static const GUID g_NetshGuid = NETSH_ROOT_GUID;

#define DHCP_HELPER_VERSION 1

//


ULONG   g_ulInitCount = 0;

DHCPMON_SUBCONTEXT_TABLE_ENTRY  g_DhcpSubContextTable[] =
{
    {L"Server", HLP_DHCP_CONTEXT_SERVER, HLP_DHCP_CONTEXT_SERVER_EX, SrvrMonitor},
};


CMD_ENTRY  g_DhcpAddCmdTable[] = {
    CREATE_CMD_ENTRY(DHCP_ADD_SERVER, HandleDhcpAddServer),
//    CREATE_CMD_ENTRY(DHCP_ADD_HELPER, HandleDhcpAddHelper)
};

CMD_ENTRY  g_DhcpDeleteCmdTable[] = {
    CREATE_CMD_ENTRY(DHCP_DELETE_SERVER, HandleDhcpDeleteServer),
//    CREATE_CMD_ENTRY(DHCP_DELETE_HELPER, HandleDhcpDeleteHelper)
};

CMD_ENTRY g_DhcpShowCmdTable[] = {
    CREATE_CMD_ENTRY(DHCP_SHOW_SERVER, HandleDhcpShowServer),
//    CREATE_CMD_ENTRY(DHCP_SHOW_HELPER, HandleDhcpShowHelper)
};


CMD_GROUP_ENTRY g_DhcpCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD, g_DhcpAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_DhcpDeleteCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_DhcpShowCmdTable),
};


CMD_ENTRY g_DhcpCmds[] = 
{
    CREATE_CMD_ENTRY(DHCP_LIST, HandleDhcpList),
    CREATE_CMD_ENTRY(DHCP_HELP1, HandleDhcpHelp),
    CREATE_CMD_ENTRY(DHCP_HELP2, HandleDhcpHelp),
    CREATE_CMD_ENTRY(DHCP_HELP3, HandleDhcpHelp),
    CREATE_CMD_ENTRY(DHCP_HELP4, HandleDhcpHelp),
};



ULONG g_ulNumTopCmds = sizeof(g_DhcpCmds)/sizeof(CMD_ENTRY);
ULONG g_ulNumGroups = sizeof(g_DhcpCmdGroups)/sizeof(CMD_GROUP_ENTRY);
ULONG g_ulNumSubContext = sizeof(g_DhcpSubContextTable)/sizeof(DHCPMON_SUBCONTEXT_TABLE_ENTRY);

DWORD
WINAPI
DhcpCommit(
    IN  DWORD   dwAction
)
{
    BOOL    bCommit, bFlush = FALSE;

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. Dhcp current state is commit, then
            // nothing to be done.
            //

            if(g_bCommit)
            {
                return NO_ERROR;
            }

            bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    return NO_ERROR;
}

BOOL 
WINAPI
DllMain(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
    )
{
    WORD wVersion = MAKEWORD(1,1); //Winsock version 1.1 will do?
    WSADATA wsaData;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            if(WSAStartup(wVersion,&wsaData) isnot NO_ERROR)
            {
                return FALSE;
            }


            break;
        }
        case DLL_PROCESS_DETACH:
        {
            
            if( g_ServerIpAddressUnicodeString )
            {
                memset(g_ServerIpAddressUnicodeString, 0x00, 
                      (wcslen(g_ServerIpAddressUnicodeString)+1)*sizeof(WCHAR));
            }

            
            if( g_pwszServer )
            {
                memset(g_pwszServer, 0x00, (wcslen(g_pwszServer)+1)*sizeof(WCHAR));
                DhcpFreeMemory(g_pwszServer);
                g_pwszServer = NULL;
            }

            if( g_ScopeIpAddressUnicodeString )
            {
                memset(g_ScopeIpAddressUnicodeString, 0x00, 
                      (wcslen(g_ScopeIpAddressUnicodeString)+1)*sizeof(WCHAR));
            }

            if( g_ScopeIpAddressAnsiString )
            {
                memset(g_ScopeIpAddressAnsiString, 0x00, 
                      (strlen(g_ScopeIpAddressAnsiString)+1)*sizeof(CHAR));
            }

            if( g_MScopeNameUnicodeString )
            {
                memset(g_MScopeNameUnicodeString, 0x00, 
                       (wcslen(g_MScopeNameUnicodeString)+1)*sizeof(WCHAR));
                DhcpFreeMemory(g_MScopeNameUnicodeString);
                g_MScopeNameUnicodeString = NULL;
            }

            if( g_MScopeNameUnicodeString )
            {
                memset(g_MScopeNameAnsiString, 0x00, 
                       (strlen(g_MScopeNameAnsiString)+1)*sizeof(CHAR));
                DhcpFreeMemory(g_MScopeNameAnsiString);
                g_MScopeNameAnsiString = NULL;
            }
            if(g_hDhcpsapiModule)
            {
                FreeLibrary(g_hDhcpsapiModule);
            }
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}


DWORD
WINAPI
DhcpStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;
    PNS_PRIV_CONTEXT_ATTRIBUTES  pNsPrivContextAttributes;

    pNsPrivContextAttributes = HeapAlloc(GetProcessHeap(), 0, sizeof(PNS_PRIV_CONTEXT_ATTRIBUTES));
    if (!pNsPrivContextAttributes)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    ZeroMemory(pNsPrivContextAttributes, sizeof(PNS_PRIV_CONTEXT_ATTRIBUTES));

    attMyAttributes.pwszContext = L"dhcp";
    attMyAttributes.guidHelper  = g_MyGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.pfnCommitFn = DhcpCommit;
    attMyAttributes.pfnDumpFn   = DhcpDump;

    pNsPrivContextAttributes->pfnEntryFn    = DhcpMonitor;
    attMyAttributes.pReserved     = pNsPrivContextAttributes;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD WINAPI
InitHelperDll(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    )
{
    DWORD   dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;

    //
    // See if this is the first time we are being called
    //

    if(InterlockedIncrement(&g_ulInitCount) != 1)
    {
        return NO_ERROR;
    }


    g_bCommit = TRUE;

    // Register helpers
    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );

    attMyAttributes.guidHelper         = g_MyGuid;
    attMyAttributes.dwVersion          = DHCP_HELPER_VERSION;
    attMyAttributes.pfnStart           = DhcpStartHelper;
    attMyAttributes.pfnStop            = NULL;

    // dhcpsapi.dll is loaded only resources
    if( NULL is (g_hDhcpsapiModule = LoadLibraryEx(TEXT("Dhcpsapi.dll"), NULL,
                                                   LOAD_LIBRARY_AS_DATAFILE )))
    {
        return GetLastError();
    }

    RegisterHelper( &g_NetshGuid, &attMyAttributes );

    return NO_ERROR;
}

LPCWSTR g_DhcpGlobalServerName = NULL;

DWORD
WINAPI
DhcpMonitor(
    IN      LPCWSTR     pwszMachine,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      DWORD       dwFlags,
    IN      LPCVOID     pvData,
    OUT     LPWSTR      pwcNewContext
    )
{
    DWORD  dwError = NO_ERROR;
    DWORD  dwIndex, i, j;
    BOOL   bFound = FALSE;
    PFN_HANDLE_CMD    pfnHandler = NULL;
    DWORD  dwNumMatched;
    DWORD  dwCmdHelpToken = 0;
    DWORD  ThreadOptions = 0;    
    PNS_CONTEXT_ENTRY_FN     pfnHelperEntryPt;
    PNS_CONTEXT_DUMP_FN      pfnHelperDumpPt;

    g_DhcpGlobalServerName = pwszMachine;
    
    //if dwArgCount is 1 then it must be a context switch fn. or looking for help
    if (( FALSE is g_bDSInit ) &&
        ( FALSE == g_bDSTried )) {
        dwError = DhcpDsInit();
        if ( ERROR_SUCCESS != dwError ) {
            g_bDSInit = FALSE;
        }
        else {
            g_bDSInit = TRUE;
        }
        g_bDSTried = TRUE;
    } // if 

    if(dwArgCount is 1)
    {
        return ERROR_CONTEXT_SWITCH;
    }

    dwIndex = 1;

    //Is it a top level(non Group command)?
    for(i=0; i<g_ulNumTopCmds; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_DhcpCmds[i].pwszCmdToken))
        {
            bFound = TRUE;
            dwIndex++;
            //dwArgCount--;
            pfnHandler = g_DhcpCmds[i].pfnCmdHandler;

            dwCmdHelpToken = g_DhcpCmds[i].dwCmdHlpToken;

            break;
        }
    }


    if(bFound)
    {
        if(dwArgCount > dwIndex && IsHelpToken(ppwcArguments[dwIndex]))
        {
            DisplayMessage(g_hModule, dwCmdHelpToken);

            return NO_ERROR;
        }

        dwError = (*pfnHandler)(pwszMachine, ppwcArguments, dwIndex, dwArgCount, dwFlags, pvData, &bFound);

        return dwError;
    }

    bFound = FALSE;


    //Is it meant for subcontext?
    for(i = 0; i<g_ulNumSubContext; i++)
    {
        //if( _wcsicmp(ppwcArguments[dwIndex], g_DhcpSubContextTable[i].pwszContext) is 0 )
        if( MatchToken(ppwcArguments[dwIndex], g_DhcpSubContextTable[i].pwszContext) )
        {
            bFound = TRUE;
            dwIndex++;
            dwArgCount--;           
            pfnHelperEntryPt = g_DhcpSubContextTable[i].pfnEntryFn;
            DEBUG("Meant for subcontext under it");
            break;
        }
    }

    if( bFound )    //Subcontext
    {
        dwError = (pfnHelperEntryPt)(pwszMachine,
                                     ppwcArguments+1,
                                     dwArgCount,
                                     dwFlags,
                                     pvData,
                                     pwcNewContext);
        return dwError;
    }

    bFound = FALSE;

    //It is not a non Group Command. Not for any helper or subcontext.
    //Then is it a config command for the manager?
    for(i = 0; (i < g_ulNumGroups) and !bFound; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_DhcpCmdGroups[i].pwszCmdGroupToken))
        {
            // See if it's a request for help

            if (dwArgCount > 2 && IsHelpToken(ppwcArguments[2]))
            {
                for (j = 0; j < g_DhcpCmdGroups[i].ulCmdGroupSize; j++)
                {
                    DisplayMessage(g_hModule, 
                           g_DhcpCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);
                                        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);                                        
                }
                                
                return NO_ERROR;
            }

            //
            // Command matched entry i, so look at the table of sub commands 
            // for this command
            //

            for (j = 0; j < g_DhcpCmdGroups[i].ulCmdGroupSize; j++)
            {
                if (MatchCmdLine(ppwcArguments + 1,
                                  dwArgCount - 1,
                                  g_DhcpCmdGroups[i].pCmdGroup[j].pwszCmdToken,
                                  &dwNumMatched))
                {
                    bFound = TRUE;
                
                    pfnHandler = g_DhcpCmdGroups[i].pCmdGroup[j].pfnCmdHandler;
                
                    dwCmdHelpToken = g_DhcpCmdGroups[i].pCmdGroup[j].dwCmdHlpToken;

                    //
                    // break out of the for(j) loop
                    //

                    break;
                }
            }

            if(!bFound)
            {
                //
                // We matched the command group token but none of the
                // sub commands
                //

                DisplayMessage(g_hModule, 
                               EMSG_DHCP_INCOMPLETE_COMMAND);

                for (j = 0; j < g_DhcpCmdGroups[i].ulCmdGroupSize; j++)
                {
                    DisplayMessage(g_hModule, 
                             g_DhcpCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);
                    
                    DisplayMessage(g_hModule,
                                   MSG_DHCP_FORMAT_LINE);
                }

                return ERROR_INVALID_PARAMETER;
            }
            else
            {
                //
                // quit the for(i)
                //

                break;
            }
        }
    }

    if (!bFound)
    {
        //
        // Command not found. 
        //
        if( g_bDSInit )
        {
            DhcpDsCleanup();
            g_bDSInit = FALSE;
        }
        return ERROR_CMD_NOT_FOUND;
    }

    //
    // See if it is a request for help.
    //

    if (dwNumMatched < (dwArgCount - 1) &&
        IsHelpToken(ppwcArguments[dwNumMatched + 1]))
    {
        DisplayMessage(g_hModule, dwCmdHelpToken);

        return NO_ERROR;
    }
    
    //
    // Call the parsing routine for the command
    //

    dwError = (*pfnHandler)(pwszMachine, ppwcArguments, dwNumMatched+1, dwArgCount, dwFlags, pvData, &bFound);
    
    return dwError;
}



DWORD
WINAPI
DhcpUnInit(
    IN  DWORD   dwReserved
    )
{
    if(InterlockedDecrement(&g_ulInitCount) isnot 0)
    {
        return NO_ERROR;
    }

    return NO_ERROR;
}

BOOL
IsHelpToken(
    PWCHAR  pwszToken
    )
{
    if(MatchToken(pwszToken, CMD_DHCP_HELP1))
        return TRUE;
    
    if(MatchToken(pwszToken, CMD_DHCP_HELP2))
        return TRUE;

    if(MatchToken(pwszToken, CMD_DHCP_HELP3))
        return TRUE;

    if(MatchToken(pwszToken, CMD_DHCP_HELP4))
        return TRUE;

    return FALSE;
}

DWORD
DisplayErrorMessage(
    HANDLE  hModule,
    DWORD   dwMsgID,
    DWORD   dwErrID,
    ...
)
{
    LPWSTR  pwszErrorMsg = NULL;
    WCHAR   ErrStringU[MAX_MSG_LENGTH + 1] = {L'\0'};
    DWORD   dwMsgLen = 0;
    DWORD   dwMsg = 0;

    va_list arglist;
    
    va_start(arglist, dwErrID);

    switch(dwErrID)
    {
    case ERROR_INVALID_PARAMETER:
        {
            DisplayMessage(hModule, dwMsgID, arglist);
            DisplayMessage(hModule, EMSG_DHCP_INVALID_PARAMETER);
            return dwErrID;
        }
    case ERROR_NOT_ENOUGH_MEMORY:
    case ERROR_OUT_OF_MEMORY:
        {
            DisplayMessage(hModule, dwMsgID, arglist);
            DisplayMessage(hModule, EMSG_DHCP_OUT_OF_MEMORY);
            return dwErrID;

        }
    case ERROR_NO_MORE_ITEMS:
        {
            DisplayMessage(hModule, dwMsgID, arglist);
            DisplayMessage(hModule, EMSG_DHCP_NO_MORE_ITEMS);
            return dwErrID;
        }
    case ERROR_MORE_DATA:
        {
            DisplayMessage(hModule, dwMsgID, arglist);
            DisplayMessage(hModule, EMSG_DHCP_MORE_DATA);
            return dwErrID;
        }
    case ERROR_INVALID_COMPUTER_NAME:
        {
            DisplayMessage(hModule, dwMsgID, arglist);
            DisplayMessage(hModule, EMSG_SRVR_INVALID_COMPUTER_NAME);
            return dwErrID;
        }
    default:
        break;
    }

    // Format the message from the module and print
    dwMsgLen = DisplayMessageM( g_hDhcpsapiModule, dwErrID );
    if ( 0 == dwMsgLen ) {
        // This is a system message
        PrintError( NULL, dwErrID );
    }

    return dwErrID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\dhcp\srvrhndl.c ===
//
// Copyright (C) 1999 Microsoft Corporation
//

#include "precomp.h"
#include <dhcpexim.h>

extern ULONG g_ulSrvrNumTopCmds;
extern ULONG g_ulSrvrNumGroups;
extern ULONG g_ulSrvrNumSubContext;

extern CMD_GROUP_ENTRY                  g_SrvrCmdGroups[];
extern CMD_ENTRY                        g_SrvrCmds[];
extern DHCPMON_SUBCONTEXT_TABLE_ENTRY   g_SrvrSubContextTable[];

extern LPWSTR  g_pwszServer;

WCHAR  g_ServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1] = {L'\0'};

DWORD  g_dwIPCount = 0;
LPWSTR *g_ppServerIPList = NULL;

LPWSTR  g_UserClass = NULL;
BOOL    g_fUserClass = FALSE;
LPWSTR  g_VendorClass = NULL;
BOOL    g_fIsVendor = FALSE;


COMMAND_OPTION_TYPE TagOptionType[] = 
{
    { TAG_OPTION_BYTE,          DhcpByteOption,             L"BYTE" },
    { TAG_OPTION_WORD,          DhcpWordOption,             L"WORD" },
    { TAG_OPTION_DWORD,         DhcpDWordOption,            L"DWORD" },
    { TAG_OPTION_DWORDDWORD,    DhcpDWordDWordOption,       L"DWORDDWORD" },
    { TAG_OPTION_IPADDRESS,     DhcpIpAddressOption,        L"IPADDRESS" },
    { TAG_OPTION_STRING,        DhcpStringDataOption,       L"STRING" },
    { TAG_OPTION_BINARY,        DhcpBinaryDataOption,       L"BINARY" },
    { TAG_OPTION_ENCAPSULATED,  DhcpEncapsulatedDataOption, L"ENCAPSULATED" }
};

DWORD
HandleSrvrList(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    i, j;

    for(i = 0; i < g_ulSrvrNumTopCmds-2; i++)
    {
        DisplayMessage(g_hModule, g_SrvrCmds[i].dwShortCmdHelpToken);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    for(i = 0; i < g_ulSrvrNumGroups; i++)
    {
        for(j = 0; j < g_SrvrCmdGroups[i].ulCmdGroupSize; j++)
        {
            DisplayMessage(g_hModule, g_SrvrCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);

            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
        }
        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    }

    for(i=0; i < g_ulSrvrNumSubContext; i++)
    {
        DisplayMessage(g_hModule, g_SrvrSubContextTable[i].dwShortCmdHlpToken);
        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    return NO_ERROR;
}


DWORD
HandleSrvrHelp(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
       DWORD    i, j;

    for(i = 0; i < g_ulSrvrNumTopCmds-2; i++)
    {
        if(g_SrvrCmds[i].dwCmdHlpToken != MSG_DHCP_NULL)
        {
            DisplayMessage(g_hModule, g_SrvrCmds[i].dwShortCmdHelpToken);
        }
    }

    for(i = 0; i < g_ulSrvrNumGroups; i++)
    {
        DisplayMessage(g_hModule, g_SrvrCmdGroups[i].dwShortCmdHelpToken);
    }

    for (i = 0; i < g_ulSrvrNumSubContext; i++)
    {
        DisplayMessage(g_hModule,  g_SrvrSubContextTable[i].dwShortCmdHlpToken);
        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    return NO_ERROR;
}

DWORD
HandleSrvrContexts(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return NO_ERROR;
}

DWORD
HandleSrvrDump(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD       Error = NO_ERROR;

    // 
    // Expected args :
    //    0 : server
    //    1 : <server ip>
    //    2 : dump
    //  
    
    if ( dwArgCount > 3 ) {
        DisplayErrorMessage( g_hModule, MSG_DHCP_NULL,
                             ERROR_INVALID_PARAMETER );
        Error = ERROR_INVALID_PARAMETER;
    }
    else {
        Error = DhcpDumpServer( g_ServerIpAddressUnicodeString,
                                g_dwMajorVersion,
                                g_dwMinorVersion );
    }
    return Error;
                            
}

DWORD
HandleSrvrAddClass(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD               Error = NO_ERROR;
    DHCP_CLASS_INFO     ClassInfo;
    DWORD               dwIndex = dwArgCount - dwCurrentIndex;
    BOOL                fBinary = FALSE;
    LPBYTE              pbData = NULL;
    DWORD               dwLen = 0;

    if( dwArgCount < 3 ) 
    {                      // wrong usage
        DisplayMessage(g_hModule, HLP_SRVR_ADD_CLASS_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    ClassInfo.ClassName = ppwcArguments[dwCurrentIndex];
    ClassInfo.ClassComment = ppwcArguments[dwCurrentIndex+1];
   
    ClassInfo.IsVendor = FALSE;

    if( dwArgCount > 3 )
    {
        WCHAR   wcType = ppwcArguments[dwCurrentIndex+3][0];

        if( wcType is L'0' )
            ClassInfo.IsVendor = FALSE;
        else if( wcType is L'1' )
            ClassInfo.IsVendor = TRUE;
        else if( ppwcArguments[dwCurrentIndex+3][0] is L'B' or
                 ppwcArguments[dwCurrentIndex+3][0] is L'b' )
        {
            fBinary = TRUE;
        }
        else
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
        
        if( dwArgCount > 4 )
        {
            if( ppwcArguments[dwCurrentIndex+4][0] is L'B' or
                ppwcArguments[dwCurrentIndex+4][0] is L'b' )
            {
                fBinary = TRUE;
            }
            else
            {
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }

    }
    else
    {
        ClassInfo.IsVendor = FALSE;
        fBinary = FALSE;
    }

    if( fBinary is FALSE )
    {
        LPSTR   pszTemp = NULL;
        DWORD   i = 0;
       

        pszTemp = DhcpUnicodeToOem(ppwcArguments[dwCurrentIndex+2], NULL);

        if( pszTemp is NULL )
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        dwLen = strlen(pszTemp);

        pbData = DhcpAllocateMemory(dwLen);
        
        
        if( pbData is NULL )
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            DhcpFreeMemory(pszTemp);
            pszTemp = NULL;
            goto ErrorReturn;
        }

        for( i=0; i<dwLen; i++ )
        {
            pbData[i] = pszTemp[i];
        }
    
        DhcpFreeMemory(pszTemp);
        pszTemp = NULL;
        
    }
    else
    {
        LPSTR   pszTemp = NULL,
                pszBin = NULL;
        DWORD   i = 0;
        
        pszTemp = DhcpUnicodeToOem(ppwcArguments[dwCurrentIndex+2], NULL);

        if( pszTemp is NULL )
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        pszBin = StringToHexString(pszTemp);

        if( strlen(pszTemp)%2 )
            dwLen = strlen(pszTemp)/2 + 1;
        else
            dwLen = strlen(pszTemp)/2;

        DhcpFreeMemory(pszTemp);
        pszTemp = NULL;

        if( pszBin is NULL )
        {
            pbData = NULL;
        }
        else
        {
            pbData = DhcpAllocateMemory(dwLen);
        
            if( pbData is NULL )
            {
                Error = ERROR_NOT_ENOUGH_MEMORY;
                DhcpFreeMemory(pszBin);
                pszBin = NULL;
                goto ErrorReturn;
            }
            for( i=0; i<dwLen; i++ )
            {
                pbData[i] = pszBin[i];
            }
        }    
        
        DhcpFreeMemory(pszBin);
        pszBin = NULL;
        
    }
    
    ClassInfo.ClassDataLength = dwLen;
    ClassInfo.ClassData = pbData;
   
    ClassInfo.Flags = 0;

    Error = DhcpCreateClass(
        g_ServerIpAddressUnicodeString,
        0,
        &ClassInfo
    );

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    
    if( pbData )
    {
        DhcpFreeMemory(pbData);
        pbData = NULL;
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SRVR_ADD_CLASS, 
                        Error);
    goto CommonReturn;
}


DWORD
HandleSrvrAddMscope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD            Error = NO_ERROR;
    DHCP_MSCOPE_INFO MScopeInfo;
    LPWSTR           UnicodeMScopeName = NULL;
    LPWSTR           UnicodeMScopeDesc = NULL;
    DWORD            MScopeId;
    LPWSTR           UnicodeLangTag = NULL;
    PBYTE            LangTag;
    DWORD            dwTTL    = 32;


    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    memset(&MScopeInfo, 0x00, sizeof(DHCP_MSCOPE_INFO));

    //
    // Expected Parameters are : <MScopeName [MScopeDescription] [TTL]>
    //

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_ADD_MSCOPE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    MScopeId = 0xFFFFFFFF;
    
    UnicodeMScopeName = ppwcArguments[dwCurrentIndex];

    if ( dwArgCount > 1 )
    {

        UnicodeMScopeDesc = ppwcArguments[dwCurrentIndex+1];
    }

    if( dwArgCount > 2 )
    {
        if( IsPureNumeric( ppwcArguments[dwCurrentIndex+2] ) is FALSE )
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        dwTTL = STRTOUL(ppwcArguments[dwCurrentIndex+2], NULL, 10);
        if( dwTTL <= 0 )
            dwTTL = 0;
        if( dwTTL > 255 )
            dwTTL = 255;
    }

    LangTag = GetLangTagA();
    UnicodeLangTag = DhcpOemToUnicode(LangTag, NULL);

    MScopeInfo.MScopeName = UnicodeMScopeName;
    MScopeInfo.MScopeId = MScopeId;
    MScopeInfo.MScopeComment = UnicodeMScopeDesc;
    MScopeInfo.PrimaryHost.IpAddress =
        StringToIpAddress(g_ServerIpAddressUnicodeString);

    MScopeInfo.PrimaryHost.NetBiosName = NULL;
    MScopeInfo.PrimaryHost.HostName = NULL;
    MScopeInfo.MScopeState = DhcpSubnetEnabled;
    MScopeInfo.MScopeFlags = 0;
    MScopeInfo.MScopeAddressPolicy = 0;
    MScopeInfo.TTL = (BYTE)dwTTL;
    MScopeInfo.LangTag = UnicodeLangTag;
    MScopeInfo.ExpiryTime = DhcpCalculateTime(INFINIT_LEASE);

    Error = DhcpSetMScopeInfo(
                g_ServerIpAddressUnicodeString,
                UnicodeMScopeName,
                &MScopeInfo,
                TRUE); // new scope

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule,
                   MSG_SRVR_MSCOPE_ADD);
                   

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SRVR_ADD_MSCOPE,
                        Error);

    goto CommonReturn;
}

DWORD
HandleSrvrAddOptiondef(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                     Error = NO_ERROR;
    DHCP_OPTION               OptionInfo;
    DHCP_OPTION_ID            OptionID;
    DHCP_OPTION_DATA_TYPE     OptionType;
    LPWSTR                    UnicodeOptionName = NULL;
    LPWSTR                    UnicodeOptionValueString = NULL;
    LPWSTR                    OptionTypeString = NULL;
    DHCP_OPTION_DATA_ELEMENT  OptionData;
    DWORD                     dwIndex = 0;

    LPWSTR                    pwcTag = NULL;
    LPWSTR                    pwcUser = NULL;
    LPWSTR                    pwcVendor = NULL;
    LPWSTR                    pwcComment = NULL;
    LPWSTR                    pwcTemp = NULL;
    
    BOOL                      fUser = FALSE;
    BOOL                      fVendor = FALSE;
    BOOL                      fComment = FALSE;
    BOOL                      fDefValue = FALSE;
    BOOL                      fIsArray = FALSE;
    BOOL                      fValidType = FALSE;

    DWORD                     i = 0;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    memset(&OptionInfo, 0x00, sizeof(DHCP_OPTION));
    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    memset(&OptionData, 0x00, sizeof(DHCP_OPTION_DATA_ELEMENT));

    //
    // Expected Parameters are :
    //  <OptionID OptionName DefValueType DefValue>
    //

    if( dwArgCount < 3 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_ADD_OPTIONDEF_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
   
    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    OptionID = STRTOUL( ppwcArguments[dwCurrentIndex], NULL, 10 );
    
    dwIndex++;

    OptionInfo.OptionID = OptionID;

    OptionInfo.OptionName = ppwcArguments[dwCurrentIndex+dwIndex];

    dwIndex++;
    
    OptionTypeString = ppwcArguments[dwCurrentIndex+dwIndex];

    dwIndex++;

    OptionInfo.OptionType = DhcpUnaryElementTypeOption;

    if( dwArgCount > dwIndex  )
    {
        if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex+dwIndex]) )
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        if( 0 is wcstol(ppwcArguments[dwCurrentIndex+dwIndex], NULL, 10) )
        {
            OptionInfo.OptionType = DhcpUnaryElementTypeOption;
        }
        else
        {
            OptionInfo.OptionType = DhcpArrayTypeOption;
            fIsArray = TRUE;
        }
        dwIndex++;
    }
    

    //
    //Check to see if VendorClass is specified or not
    //
    while( TRUE )
    {
        LPWSTR      pwcStr = NULL;
        if( dwArgCount <= dwIndex )
            break;

        if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER)  )
            break;

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else if ( MatchToken(pwcTag, TOKEN_OPTION_COMMENT) )
        {
            if( fComment is TRUE ) //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcComment = NULL;
                else
                {
                    pwcComment = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcComment is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcComment, pwcStr);
                }
                fComment = TRUE;
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
            return ERROR_INVALID_PARAMETER;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }
        
        dwIndex++;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }
    
    if( fComment is TRUE )
    {
        OptionInfo.OptionComment = pwcComment;
    }
    else
    {
        OptionInfo.OptionComment = NULL;
    }

    //Check if OptionType supplied is valid

    //Find out the OptionType
    for(i=0; i < sizeof(TagOptionType)/sizeof(COMMAND_OPTION_TYPE); i++)
    {
        if( MatchToken(OptionTypeString, TagOptionType[i].pwszTagID) )
        {
            OptionType = TagOptionType[i].DataType;
            fValidType = TRUE;
            break;
        }
    }
    
    if( fValidType is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( fIsArray && OptionType >= DhcpBinaryDataOption ) {
        DisplayMessage( g_hModule, EMSG_SRVR_INVALID_OPTIONTYPE );
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    if( dwArgCount > dwIndex ) 
    {
        if( fIsArray )
        {
            Error = SetOptionDataTypeArray(
                OptionType,
                ppwcArguments + dwCurrentIndex,
                dwIndex, dwArgCount,
                &OptionInfo.DefaultValue
                );
        }
        else
        {

            Error = SetOptionDataType(
                OptionType,
                ppwcArguments[dwCurrentIndex+dwIndex],
                &OptionData,
                &UnicodeOptionValueString
            );

            OptionInfo.DefaultValue.NumElements = 1;
            OptionInfo.DefaultValue.Elements = &OptionData;

        }

        dwIndex++;
        fDefValue = TRUE;
    }
    else
    {
       Error = SetOptionDataType(
            OptionType,
            NULL,
            &OptionData,
            &UnicodeOptionValueString
        ); 

        OptionInfo.DefaultValue.NumElements = 1;
        OptionInfo.DefaultValue.Elements = &OptionData;

    }

    if( Error isnot NO_ERROR )
    {

        goto ErrorReturn;
    }

    if( g_dwMajorVersion < CLASS_ID_VERSION )
    {
        Error = DhcpCreateOption(
                                g_ServerIpAddressUnicodeString,
                                OptionID,
                                &OptionInfo);
        if( Error isnot NO_ERROR )
            goto ErrorReturn;

    }
    else
    {
        Error = DhcpCreateOptionV5(
                                g_ServerIpAddressUnicodeString,
                                fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR  : 0,
                                OptionID,
                                pwcUser,
                                pwcVendor,
                                &OptionInfo);

        if( Error isnot NO_ERROR )
            goto ErrorReturn;
    }
CommonReturn:
    
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);

    if( pwcTemp )
    {
        DhcpFreeMemory(pwcTemp);
        pwcTemp = NULL;
    }

    return( Error );
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_ADD_OPTIONDEF,
                        Error);
                   
    goto CommonReturn;
}

DWORD
HandleSrvrAddScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD            Error = NO_ERROR;
    DHCP_SUBNET_INFO SubnetInfo;
    LPWSTR           UnicodeSubnetName = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    memset(&SubnetInfo, 0x00, sizeof(DHCP_SUBNET_INFO));
    
    if( dwArgCount < 3 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_ADD_SCOPE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    SubnetInfo.SubnetAddress =
        StringToIpAddress(ppwcArguments[dwCurrentIndex]);
    SubnetInfo.SubnetMask =
        StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);

    if( SubnetInfo.SubnetAddress is INADDR_NONE or
        SubnetInfo.SubnetMask is INADDR_NONE )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    UnicodeSubnetName = ppwcArguments[dwCurrentIndex+2];

    SubnetInfo.SubnetName = UnicodeSubnetName;
    if( dwArgCount > 3 ) 
    {
#ifdef UNICODE
        SubnetInfo.SubnetComment = ppwcArguments[dwCurrentIndex+3];
#else
        SubnetInfo.SubnetComment = DhcpOemToUnicode( ppwcArguments[dwCurrentIndex+3], NULL);
#endif //UNICODE
    }
    else
    {
        SubnetInfo.SubnetComment = NULL;
    }
    SubnetInfo.PrimaryHost.IpAddress =
        StringToIpAddress(g_ServerIpAddressUnicodeString);

    SubnetInfo.PrimaryHost.NetBiosName = NULL;
    SubnetInfo.PrimaryHost.HostName = NULL;
    SubnetInfo.SubnetState = DhcpSubnetEnabled;

    Error = DhcpCreateSubnet(
                g_ServerIpAddressUnicodeString,
                SubnetInfo.SubnetAddress,
                &SubnetInfo );

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:

#ifndef UNICODE
    if( UnicodeSubnetName != NULL ) 
    {
        DhcpFreeMemory( UnicodeSubnetName );
        UnicodeSubnetName = NULL;
    }

    if( SubnetInfo.SubnetComment isnot NULL )
    {
        DhcpFreeMemory( SubnetInfo.SubnetComment );
        SubnetInfo.SubnetComment = NULL;
    }

#endif //UNICODE

    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SRVR_ADD_SCOPE,
                        Error);

    goto CommonReturn;
}

DWORD
HandleSrvrDeleteClass(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD          Error = ERROR_SUCCESS;
    LPWSTR         ClassName = NULL;

    if( dwArgCount < 1 )
    {        
        DisplayMessage(g_hModule, HLP_SRVR_DELETE_CLASS_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;

    }
    
    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }
 

    ClassName = ppwcArguments[dwCurrentIndex];

    Error = DhcpDeleteClass(
        g_ServerIpAddressUnicodeString,
        0,
        ClassName
    );
    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SRVR_DELETE_CLASS,
                        Error);
    goto CommonReturn;
}


DWORD
HandleSrvrDeleteMscope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD            Error = NO_ERROR;
    DHCP_MSCOPE_INFO MScopeInfo;
    LPWSTR           UnicodeMScopeName = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }


    //
    // Expected Parameters are : <MScopeName>
    //

    memset(&MScopeInfo, 0x00, sizeof(DHCP_MSCOPE_INFO));

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_DELETE_MSCOPE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    

    UnicodeMScopeName = ppwcArguments[dwCurrentIndex];

    Error = DhcpDeleteMScope(
                g_ServerIpAddressUnicodeString,
                UnicodeMScopeName,
                TRUE); 

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SRVR_DELETE_MSCOPE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrDeleteOptiondef(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD          Error = ERROR_SUCCESS;
    DHCP_OPTION_ID OptionID;

    LPWSTR         pwcTag = NULL;
    LPWSTR         pwcUser = NULL;   
    LPWSTR         pwcVendor = NULL;
    LPWSTR         pwcTemp = NULL;

    BOOL           fUser = FALSE;
    BOOL           fVendor = FALSE;

    DWORD          dwIndex = 0;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    //
    // Expected Parameters are :
    //  <OptionID>
    //
    
    if( dwArgCount < 1 ) 
    {
        DisplayMessage(g_hModule, HLP_SRVR_DELETE_OPTIONDEF_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;

    }

    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    OptionID = STRTOUL( ppwcArguments[dwCurrentIndex], NULL, 10 );


    //
    //Check to see if VendorClass or UserClass is specified or not
    //
    dwIndex = 1;
    while( TRUE )
    {
        LPWSTR      pwcStr = NULL;
        if( dwArgCount <= dwIndex )
            break;

        if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER)  )
            break;

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }
        
        dwIndex++;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }
    

    if( g_dwMajorVersion < CLASS_ID_VERSION )
    {
        Error = DhcpRemoveOption(
                                g_ServerIpAddressUnicodeString,
                                OptionID);
        if( Error isnot NO_ERROR )
            goto ErrorReturn;
    }

    else
    {
        Error = DhcpRemoveOptionV5( 
                                g_ServerIpAddressUnicodeString,
                                fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                OptionID,
                                pwcUser,
                                pwcVendor
                                );
        if( Error isnot NO_ERROR )
            goto ErrorReturn;
    }

CommonReturn:

    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);

    if( pwcVendor && pwcVendor != g_VendorClass )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    if( pwcUser && pwcUser != g_UserClass  )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    return Error;

ErrorReturn:

    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_DELETE_OPTIONDEF,
                        Error);

    goto CommonReturn;
}

DWORD
HandleSrvrDeleteOptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                   Error = ERROR_SUCCESS;
    DHCP_OPTION_ID          OptionID;
    DHCP_OPTION_SCOPE_INFO  ScopeInfo;

    LPWSTR         pwcTag = NULL;
    LPWSTR         pwcUser = NULL;   
    LPWSTR         pwcVendor = NULL;
    LPWSTR         pwcTemp = NULL;

    BOOL           fUser = FALSE;
    BOOL           fVendor = FALSE;

    DWORD          dwIndex = 0;


    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    //
    // Expected Parameters are :
    //  <OptionID>
    //
    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_DELETE_OPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    OptionID = STRTOUL( ppwcArguments[dwCurrentIndex], NULL, 10 );

    ScopeInfo.ScopeType = DhcpGlobalOptions;
    ScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;

    //
    //Check to see if VendorClass or UserClass is specified or not
    //
    
    dwIndex = 1;
    while( TRUE )
    {
        LPWSTR      pwcStr = NULL;
        if( dwArgCount <= dwIndex )
            break;

        if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER)  )
            break;

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
        {
            if( fUser is TRUE ) //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcUser = NULL;
                else
                {
                    pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcUser is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcUser, pwcStr);
                }
                fUser = TRUE;
            }
        }
        else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
            return ERROR_INVALID_PARAMETER;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }
        
        dwIndex++;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }
    

    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {

        Error = DhcpRemoveOptionValueV5(
                                   g_ServerIpAddressUnicodeString,
                                   fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                   OptionID,
                                   pwcUser,
                                   pwcVendor,
                                   &ScopeInfo
                                   );
    }
    else
    {
        Error = DhcpRemoveOptionValue(
                                   g_ServerIpAddressUnicodeString,
                                   OptionID,
                                   &ScopeInfo);
    }


    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);

    if( pwcVendor && pwcVendor != g_VendorClass )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }
    
    if( pwcUser  && pwcUser != g_UserClass )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_DELETE_OPTIONVALUE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrDeleteScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                      Error = ERROR_SUCCESS;
    DHCP_IP_ADDRESS            SubnetAddress;
    DHCP_FORCE_FLAG            ForceFlag;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }


    memset(&SubnetAddress, 0x00, sizeof(DHCP_IP_ADDRESS));
    memset(&ForceFlag, 0x00, sizeof(DHCP_FORCE_FLAG));

    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_SRVR_DELETE_SCOPE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    SubnetAddress = StringToIpAddress( ppwcArguments[dwCurrentIndex] );

    if( SubnetAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( 0 == STRICMP(ppwcArguments[dwCurrentIndex+1], TEXT("DhcpFullForce") ) ) 
    {
        ForceFlag = DhcpFullForce;
    } 
    else if( 0 == STRICMP(ppwcArguments[dwCurrentIndex+1], TEXT("DhcpNoForce") ) ) 
    {
        ForceFlag = DhcpNoForce;
    } 
    else 
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_UNKNOWN_FORCEFLAG,
                       ppwcArguments[dwCurrentIndex+1]);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    Error = DhcpDeleteSubnet(
        g_ServerIpAddressUnicodeString,
        SubnetAddress,
        ForceFlag
    );
    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:

    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_DELETE_SCOPE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrDeleteSuperscope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    
    WCHAR  *pwszSuperScope = NULL;
    DWORD  Error = NO_ERROR;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }
    
    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_DELETE_SUPERSCOPE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }


    pwszSuperScope = ppwcArguments[dwCurrentIndex];
    
    Error = DhcpDeleteSuperScopeV4( g_ServerIpAddressUnicodeString,
                                    pwszSuperScope );
        
    if( Error isnot NO_ERROR )
        goto ErrorReturn;
    
CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_DELETE_SUPERSCOPE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrRedoAuth(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD           Error = NO_ERROR;
    PDHCP_ATTRIB    pStatusAttrib = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }


    Error = DhcpServerRedoAuthorization(
                  g_ServerIpAddressUnicodeString,
                  0
                  );
        if( Error is NO_ERROR )
            goto CommonReturn;
        else
            goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_REDO_AUTH,
                        Error);

    goto CommonReturn;

}

DWORD
HandleSrvrExport(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD           Error = NO_ERROR;
    PDHCP_ATTRIB    pStatusAttrib = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_EXPORT_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( !IsLocalServer(g_pwszServer) )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_EXIM_LOCAL);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    Error = CmdLineDoExport(
        &ppwcArguments[dwCurrentIndex], dwArgCount );

    if( ERROR_BAD_ARGUMENTS == Error )
    {
        DisplayMessage(g_hModule, HLP_SRVR_EXPORT_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( Error is NO_ERROR )
        goto CommonReturn;
    else
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_EXPORT,
                        Error);

    goto CommonReturn;

}

DWORD
HandleSrvrImport(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD           Error = NO_ERROR;
    PDHCP_ATTRIB    pStatusAttrib = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_IMPORT_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( !IsLocalServer(g_pwszServer) )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_EXIM_LOCAL);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    Error = CmdLineDoImport(
        &ppwcArguments[dwCurrentIndex], dwArgCount );

    if( ERROR_BAD_ARGUMENTS == Error )
    {
        DisplayMessage(g_hModule, HLP_SRVR_IMPORT_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( Error is NO_ERROR )
        goto CommonReturn;
    else
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_IMPORT,
                        Error);

    goto CommonReturn;

}

DWORD
HandleSrvrInitiateReconcile(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD               Error = NO_ERROR;
    LPDHCP_IP_ARRAY     SubnetIps = NULL;
    DHCP_RESUME_HANDLE  Resume = 0;
    DWORD               dwRead = 0,
                        dwTotal = 0,
                        dwCount = 0;
    BOOL                fFix = FALSE;

    if( dwArgCount > 0 ) 
    {
        //
        // parse fix parameter.
        //

        if( STRICMP(ppwcArguments[dwCurrentIndex], TEXT("fix") ) ) 
        {
            fFix = TRUE;
        }
    }


    while(TRUE)
    {
        DWORD   dw = 0;

        Error = DhcpEnumSubnets(g_ServerIpAddressUnicodeString,
                                &Resume,
                                ~0,
                                &SubnetIps,
                                &dwRead,
                                &dwTotal);

        if( Error is ERROR_NO_MORE_ITEMS )
        {
            Error = NO_ERROR;
            break;
        }

        if( Error isnot NO_ERROR and
            Error isnot ERROR_MORE_DATA )
        {
            goto ErrorReturn;
        }

        for( dw=0; dw<dwRead && dw<SubnetIps->NumElements; dw++ )
        {
            DWORD dwError = NO_ERROR;
            LPDHCP_SCAN_LIST ScanList = NULL;

            dwError = DhcpScanDatabase(
                                        g_ServerIpAddressUnicodeString,
                                        SubnetIps->Elements[dw],
                                        fFix,
                                        &ScanList
                                      );

            if( dwError isnot NO_ERROR ) 
            {
                DisplayErrorMessage(g_hModule,
                                    EMSG_SRVR_RECONCILE_SCOPE,
                                    dwError,
                                    IpAddressToString(SubnetIps->Elements[dw]));
                continue;
            }
            else
            {
                DWORD dwMsgId;
                
                if( fFix ) {
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_RECONCILE_SCOPE,
                                   IpAddressToString(SubnetIps->Elements[dw]));
                }
            }
            
            //
            // display bad entries.
            //

            if( (ScanList isnot NULL) and
                (ScanList->NumScanItems isnot 0) and
                (ScanList->ScanItems isnot NULL) ) 
            {

                LPDHCP_SCAN_ITEM ScanItem;
                LPDHCP_SCAN_ITEM ScanItemEnd;
                DWORD i = 1;

                if( !fFix ) {
                    DisplayMessage(
                        g_hModule,
                        MSG_SRVR_RECONCILE_SCOPE_NEEDFIX,
                        IpAddressToString(SubnetIps->Elements[dw])
                        );
                }
                
                ScanItemEnd =
                    ScanList->ScanItems +
                    ScanList->NumScanItems;

                for( ScanItem = ScanList->ScanItems;
                        ScanItem < ScanItemEnd; ScanItem++ ) 
                {

                    DisplayMessage(g_hModule, MSG_SCOPE_IPADDRESS,
                        i++,
                        IpAddressToString(ScanItem->IpAddress) );

                    if( ScanItem->ScanFlag == DhcpRegistryFix ) 
                    {
                        DisplayMessage(g_hModule, MSG_SCOPE_FIX_REGISTRY);
                    }
                    else if( ScanItem->ScanFlag == DhcpDatabaseFix ) 
                    {
                        DisplayMessage(g_hModule, MSG_SCOPE_FIX_DATABASE);
                    }
                    else 
                    {
                        DisplayMessage(g_hModule, MSG_SCOPE_FIX_UNKNOWN);
                    }
                }
            }
            else
            {
                if( !fFix ) {
                    DisplayMessage(
                        g_hModule,
                        MSG_SRVR_RECONCILE_SCOPE_NOFIX,
                        IpAddressToString(SubnetIps->Elements[dw])
                        );
                }
            }                

            
            if( ScanList )
            {
                DhcpRpcFreeMemory(ScanList);
                ScanList = NULL;
            }

        }


        if( Error is ERROR_MORE_DATA )
        {
            continue;
        }
        else
        {
            break;
        }
    }

    DisplayMessage(g_hModule,
                   EMSG_DHCP_ERROR_SUCCESS);
CommonReturn:
    if( SubnetIps )
    {
        DhcpRpcFreeMemory(SubnetIps);
        SubnetIps = NULL;
    }
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_INITIATE_RECONCILE,
                        Error);
    goto CommonReturn;

}


DWORD
HandleSrvrSetBackupinterval(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                        Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }


    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_BACKUPINTERVAL_EX);
        Error = ERROR_INVALID_PARAMETER;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_BACKUPINTERVAL,
                            Error);
        return Error;
    }

     
    ConfigInfo = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

    if( ConfigInfo == NULL ) 
    {
        DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
        Error = ERROR_NOT_ENOUGH_MEMORY;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_BACKUPINTERVAL,
                            Error);
        return Error;
    }

    memset(ConfigInfo, 0x00, sizeof(DHCP_SERVER_CONFIG_INFO_V4));


    ConfigInfo->BackupInterval = ATOI(ppwcArguments[dwCurrentIndex]);

    Error = DhcpServerSetConfigV4(
                g_ServerIpAddressUnicodeString,
                Set_BackupInterval,
                ConfigInfo );

    if( Error is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    }
    else
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_BACKUPINTERVAL,
                            Error);
    }

    if(ConfigInfo)
    {
        DhcpFreeMemory(ConfigInfo);
        ConfigInfo = NULL;
    }

    return Error;
}

DWORD
HandleSrvrSetBackuppath(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                        Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }


    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_BACKUPPATH_EX);
        Error = ERROR_INVALID_PARAMETER;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_BACKUPPATH,
                            Error);
        return Error;
    }

     
    ConfigInfo = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

    if( ConfigInfo == NULL ) 
    {
        DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
        Error = ERROR_NOT_ENOUGH_MEMORY;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_BACKUPPATH,
                            Error);
        return Error;
    }

    memset(ConfigInfo, 0x00, sizeof(DHCP_SERVER_CONFIG_INFO_V4));


    ConfigInfo->BackupPath = ppwcArguments[dwCurrentIndex];

    Error = DhcpServerSetConfigV4(
                g_ServerIpAddressUnicodeString,
                Set_BackupPath,
                ConfigInfo );

    if( Error is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    }
    else
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_BACKUPPATH,
                            Error);
    }

    if(ConfigInfo)
    {
        DhcpFreeMemory(ConfigInfo);
        ConfigInfo = NULL;
    }
    return Error;
}

DWORD
HandleSrvrSetDatabasecleanupinterval(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                        Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_DATABASECLEANUPINTERVAL_EX);
        Error = ERROR_INVALID_PARAMETER;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASECLEANUPINTERVAL,
                            Error);
        return Error;

    }

     
    ConfigInfo = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

    if( ConfigInfo == NULL ) 
    {
        DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
        Error = ERROR_NOT_ENOUGH_MEMORY;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASECLEANUPINTERVAL,
                            Error);
        return Error;
    }

    memset(ConfigInfo, 0x00, sizeof(DHCP_SERVER_CONFIG_INFO_V4));


    ConfigInfo->DatabaseCleanupInterval = ATOI(ppwcArguments[dwCurrentIndex]);

    Error = DhcpServerSetConfigV4(
                g_ServerIpAddressUnicodeString,
                Set_DatabaseCleanupInterval,
                ConfigInfo );

    if( Error is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    }
    else
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASECLEANUPINTERVAL,
                            Error);
                       
    }

    if(ConfigInfo)
    {
        DhcpFreeMemory(ConfigInfo);
        ConfigInfo = NULL;
    }
    return Error;
}

DWORD
HandleSrvrSetDatabaseloggingflag(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                        Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo = NULL;
    DWORD                        dwFlag = 0;


    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }


    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_DATABASELOGGINGFLAG_EX);
        Error = ERROR_INVALID_PARAMETER;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASELOGGINGFLAG,
                            Error);
        return Error;
    }

     
    ConfigInfo = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

    if( ConfigInfo == NULL ) 
    {
        DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
        Error = ERROR_NOT_ENOUGH_MEMORY;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASELOGGINGFLAG,
                            Error);
        return Error;
    }

    memset(ConfigInfo, 0x00, sizeof(DHCP_SERVER_CONFIG_INFO_V4));

    dwFlag = ATOI(ppwcArguments[dwCurrentIndex]);

    if( dwFlag isnot 0 and
        dwFlag isnot 1 )
    {
        Error = ERROR_INVALID_PARAMETER;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASELOGGINGFLAG,
                            Error);
        return Error;
    }


    ConfigInfo->DatabaseLoggingFlag = dwFlag;

    Error = DhcpServerSetConfigV4(
                g_ServerIpAddressUnicodeString,
                Set_DatabaseLoggingFlag,
                ConfigInfo );

    if( Error is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    }
    else
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASELOGGINGFLAG,
                            Error);
    }

    if(ConfigInfo)
    {
        DhcpFreeMemory(ConfigInfo);
        ConfigInfo = NULL;
    }
    
    return Error;
   
}

DWORD
HandleSrvrSetDatabasename(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                        Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }


    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_DATABASENAME_EX);
        Error = ERROR_INVALID_PARAMETER;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASENAME,
                            Error);
        return Error;
    }

     
    ConfigInfo = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

    if( ConfigInfo == NULL ) 
    {
        DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
        Error = ERROR_NOT_ENOUGH_MEMORY;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASENAME,
                            Error);
        return Error;
    }

    memset(ConfigInfo, 0x00, sizeof(DHCP_SERVER_CONFIG_INFO_V4));


    ConfigInfo->DatabaseName = ppwcArguments[dwCurrentIndex];

    Error = DhcpServerSetConfigV4(
                g_ServerIpAddressUnicodeString,
                Set_DatabaseName,
                ConfigInfo );

    if( Error is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    }
    else
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASENAME,
                            Error);
    }

    if(ConfigInfo)
    {
        DhcpFreeMemory(ConfigInfo);
        ConfigInfo = NULL;
    }
    return Error;

}

DWORD
HandleSrvrSetDatabasepath(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                        Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo = NULL;
    LPDHCP_SERVER_CONFIG_INFO    ConfigInfo5 = NULL;
    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }


    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_DATABASEPATH_EX);
        Error = ERROR_INVALID_PARAMETER;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASEPATH,
                            Error);
        return Error;
    }

    if( g_dwMajorVersion < CLASS_ID_VERSION )
    {
        ConfigInfo = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

        if( ConfigInfo == NULL ) 
        {
            DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
            Error = ERROR_NOT_ENOUGH_MEMORY;
            DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASEPATH,
                            Error);
            return Error;
        }

        memset(ConfigInfo, 0x00, sizeof(DHCP_SERVER_CONFIG_INFO_V4));


        ConfigInfo->DatabasePath = ppwcArguments[dwCurrentIndex];


        Error = DhcpServerSetConfigV4(
                    g_ServerIpAddressUnicodeString,
                    Set_DatabasePath,
                    ConfigInfo );

        if( Error is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_NEED_RESTART);

            DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
        }
        else
        {
            DisplayErrorMessage(g_hModule,
                                EMSG_SRVR_SET_DATABASEPATH,
                                Error);
        }

        if(ConfigInfo)
        {
            DhcpFreeMemory(ConfigInfo);
            ConfigInfo = NULL;
        }
        
        return Error;
    }
    else
    {
        ConfigInfo5 = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO) );

        if( ConfigInfo5 == NULL ) 
        {
            DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
            Error = ERROR_NOT_ENOUGH_MEMORY;
            DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASEPATH,
                            Error);
            return Error;
        }

        memset(ConfigInfo5, 0x00, sizeof(DHCP_SERVER_CONFIG_INFO));


        ConfigInfo5->DatabasePath = ppwcArguments[dwCurrentIndex];


        Error = DhcpServerSetConfig(
                    g_ServerIpAddressUnicodeString,
                    Set_DatabasePath,
                    ConfigInfo5 );

        if( Error is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_NEED_RESTART);

            DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
        }
        else
        {
            DisplayErrorMessage(g_hModule,
                                EMSG_SRVR_SET_DATABASEPATH,
                                Error);
        }

        if(ConfigInfo)
        {
            DhcpFreeMemory(ConfigInfo);
            ConfigInfo = NULL;
        }
        
        return Error;
    }

}

DWORD
HandleSrvrSetDatabaserestoreflag(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                        Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo = NULL;
    DWORD                        dwFlag = 0;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_DATABASERESTOREFLAG_EX);
        Error = ERROR_INVALID_PARAMETER;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASERESTOREFLAG,
                            Error);
        return Error;
    }
     
    ConfigInfo = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

    if( ConfigInfo == NULL ) 
    {
        DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
        Error = ERROR_NOT_ENOUGH_MEMORY;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASERESTOREFLAG,
                            Error);
        return Error;
    }

    memset(ConfigInfo, 0x00, sizeof(DHCP_SERVER_CONFIG_INFO_V4));

        

    dwFlag = ATOI(ppwcArguments[dwCurrentIndex]);

    if( dwFlag isnot 0 and
        dwFlag isnot 1 )
    {
        Error = ERROR_INVALID_PARAMETER;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASERESTOREFLAG,
                            Error);
        return Error;
    }

    ConfigInfo->RestoreFlag = dwFlag;

    Error = DhcpServerSetConfigV4(
                g_ServerIpAddressUnicodeString,
                Set_RestoreFlag,
                ConfigInfo );

    if( Error is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    }
    else
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASERESTOREFLAG,
                            Error);
    }

    if(ConfigInfo)
    {
        DhcpFreeMemory(ConfigInfo);
        ConfigInfo = NULL;
    }

    return Error;

}

DWORD
HandleSrvrSetOptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{

    DWORD                     Error = NO_ERROR;
    DHCP_OPTION_ID            OptionID;
    DHCP_OPTION_SCOPE_INFO    ScopeInfo;
    DHCP_OPTION_DATA          OptionValue;
    DHCP_OPTION_DATA_ELEMENT  OptionData;
    DHCP_OPTION_DATA_TYPE     OptionType;
    LPWSTR                    UnicodeOptionValueString = NULL;
    LPWSTR                    OptionTypeString = NULL;
    LPDHCP_OPTION             OptionInfo = NULL;
    DWORD                     dwIndex = 0;
    
    LPWSTR                    pwcTag = NULL;
    LPWSTR                    pwcUser = NULL;
    LPWSTR                    pwcVendor = NULL;
    LPWSTR                    pwcTemp = NULL;
    DWORD                     dwClass = 0;
    DWORD                     i = 0;
    BOOL                      fUser = FALSE;
    BOOL                      fVendor = FALSE;
    BOOL                      fValidType = FALSE;

    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));
    memset(&OptionValue, 0x00, sizeof(DHCP_OPTION_DATA));
    memset(&OptionData, 0x00, sizeof(DHCP_OPTION_DATA_ELEMENT));
    

 
    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    if( dwArgCount < 3 ) 
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_OPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    OptionID = wcstoul(ppwcArguments[dwCurrentIndex], NULL, 10 );

    dwIndex++;

    OptionTypeString = ppwcArguments[dwCurrentIndex+dwIndex];

    dwIndex++;

    //
    //Check to see if VendorClass or UserClass is specified or not
    //

    while (( dwIndex < dwArgCount ) &&
            ( NULL != wcsstr( ppwcArguments[ dwCurrentIndex + dwIndex ],
                              DHCP_ARG_DELIMITER )))
    {
        LPWSTR  pwcStr = NULL;

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);

        if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
        {
            if( fUser is TRUE ) //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcUser = NULL;
                else
                {
                    pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcUser is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcUser, pwcStr);
                }
                fUser = TRUE;
            }
        }
        else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else
        {
            // Free allocated memory
            if ( NULL != pwcTemp ) {
                DhcpFreeMemory( pwcTemp );
                pwcTemp = NULL;
            }
            break;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }

        dwIndex++;
    } // while

    // Check if we still have any option value
    if( dwIndex >= dwArgCount ) {
        DisplayMessage(g_hModule, HLP_SRVR_SET_OPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }

    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {
        Error = DhcpGetOptionInfoV5(g_ServerIpAddressUnicodeString,
                                    fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                    OptionID,
                                    NULL,
                                    pwcVendor,
                                    &OptionInfo);
    
        if( Error isnot NO_ERROR or OptionInfo is NULL )
            goto ErrorReturn;
    }
    else
    {
        Error = DhcpGetOptionInfo(g_ServerIpAddressUnicodeString,
                                  OptionID,
                                  &OptionInfo);

        if( Error isnot NO_ERROR or OptionInfo is NULL )
            goto ErrorReturn;
    }

    //Check if OptionType supplied is the same as defined.

    //Find out the OptionType
    for(i=0; i < sizeof(TagOptionType)/sizeof(COMMAND_OPTION_TYPE); i++)
    {
        if( MatchToken(OptionTypeString, TagOptionType[i].pwszTagID) )
        {
            OptionType = TagOptionType[i].DataType;
            fValidType = TRUE;
            break;
        }
    }
    
    if( fValidType is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( OptionInfo->DefaultValue.NumElements and
        OptionType isnot OptionInfo->DefaultValue.Elements[0].OptionType )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_INVALID_OPTIONTYPE);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }


    switch(OptionInfo->OptionType)
    {

    case DhcpArrayTypeOption:
        {
            Error = SetOptionDataTypeArray(
                    OptionType,
                    ppwcArguments+dwCurrentIndex,
                    dwIndex,
                    dwArgCount,
                    &OptionValue);
            
            if( Error isnot NO_ERROR )
            {
                goto ErrorReturn;
            }
            break;
                
        }
    case DhcpUnaryElementTypeOption:
    default:
        {
            Error = SetOptionDataType(
                        OptionType,
                        ppwcArguments[dwCurrentIndex+dwIndex],
                        &OptionData,
                        &UnicodeOptionValueString);

            // Option 28 (Broadcast IP) can have 255.255.255.255
            // Others should not.
            
            if ( 28 != OptionID ) {
                if ( INADDR_NONE == OptionData.Element.IpAddressOption ) {
                    Error = ERROR_INVALID_PARAMETER;
                }
            } // if 

            if( Error isnot NO_ERROR ) 
            {
                goto ErrorReturn;
            }
            OptionValue.NumElements = 1;
            OptionValue.Elements = &OptionData;
            break;
        }
    }

    ScopeInfo.ScopeType = DhcpGlobalOptions;
    ScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;

    Error = SetOptionValue(
        g_ServerIpAddressUnicodeString,
        fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
        (DHCP_OPTION_ID)OptionID,
        pwcUser,
        pwcVendor,
        &ScopeInfo,
        &OptionValue
    );
    if( Error isnot ERROR_SUCCESS )
        goto ErrorReturn;

CommonReturn:


    if( OptionValue.Elements &&
        NULL != OptionInfo &&
        OptionInfo->OptionType is DhcpArrayTypeOption )
    {
       DhcpFreeMemory(OptionValue.Elements);
       OptionValue.Elements = NULL;
    }

    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    return Error;

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SET_OPTIONVALUE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrSetServer(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD   Error = NO_ERROR;
    if( dwArgCount < 1 )
    {
        if( FALSE is SetServerInfo(NULL) )
        {
            Error = GetLastError();
            DisplayErrorMessage(g_hModule,
                                EMSG_SRVR_SET_SERVER,
                                Error);
            return Error;
        }
        else
        {
            g_fServer = TRUE;
            DisplayMessage(g_hModule,
                           EMSG_DHCP_ERROR_SUCCESS);
            return NO_ERROR;
        }
    }
    else
    {
        if( FALSE is SetServerInfo(ppwcArguments[dwCurrentIndex]) )
        {
            Error = GetLastError();
            DisplayErrorMessage(g_hModule,
                                EMSG_SRVR_SET_SERVER,
                                Error);
            return Error;
        }
        else
        {
            g_fServer = TRUE;
            DisplayMessage(g_hModule,
                           EMSG_DHCP_ERROR_SUCCESS);
            return NO_ERROR;
        }

    }
  
}

DWORD
HandleSrvrSetUserclass(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    if( g_UserClass )
    {
        memset(g_UserClass, 0x00, (wcslen(g_UserClass)+1)*sizeof(WCHAR));
        DhcpFreeMemory(g_UserClass);
        g_UserClass = NULL;
    }

    g_fUserClass = FALSE;

    if( dwArgCount > 0 )
    {
        g_UserClass = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex])+1)*sizeof(WCHAR));
        if( g_UserClass is NULL )
        {
            DisplayErrorMessage(g_hModule,
                                EMSG_SRVR_SET_USERCLASS,
                                ERROR_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        wcscpy(g_UserClass, ppwcArguments[dwCurrentIndex]);
        g_fUserClass = TRUE;
    }

    DisplayMessage(g_hModule,
                   EMSG_DHCP_ERROR_SUCCESS);

    return NO_ERROR;
}

DWORD
HandleSrvrSetVendorclass(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    if( g_VendorClass )
    {
        memset(g_VendorClass, 0x00, (wcslen(g_VendorClass)+1)*sizeof(WCHAR));
        DhcpFreeMemory(g_VendorClass);
        g_VendorClass = NULL;
    }

    g_fIsVendor = FALSE;

    if( dwArgCount > 0 )
    {
        g_VendorClass = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex])+1)*sizeof(WCHAR));
        if( g_VendorClass is NULL )
        {
            DisplayErrorMessage(g_hModule,
                                EMSG_SRVR_SET_VENDORCLASS,
                                ERROR_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        wcscpy(g_VendorClass, ppwcArguments[dwCurrentIndex]);
        g_fIsVendor = TRUE;
    }

    DisplayMessage(g_hModule,
                   EMSG_DHCP_ERROR_SUCCESS);

    return NO_ERROR;
}

DWORD
GetPassword(
    IN OUT LPWSTR buf,
    IN ULONG buflen
    )
{
    WCHAR ch, *bufPtr = buf;
    DWORD len, c;
    int err, mode;

    buflen -= 1;    /* make space for null terminator */
    len = 0;               /* GP fault probe (a la API's) */

    if(!GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &mode)) {
        return GetLastError();
    }

    DisplayMessage(g_hModule, HLP_SRVR_PROMPT_PASSWORD);
    
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {
        err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);
        if (!err || c != 1)
            ch = 0xffff;

        if ((ch == L'\r' ) || (ch == 0xffff))       /* end of the line */
            break;

        if ( ch == 0x8 ) {  /* back up one or two */
            /*
             * IF bufPtr == buf then the next two lines are
             * a no op.
             */
            if (bufPtr != buf) {
                bufPtr--;
                (len)--;
            }
        }
        else {

            *bufPtr = ch;

            if (len < buflen)
                bufPtr++ ;                   /* don't overflow buf */
            (len)++;                        /* always increment len */
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);
    *bufPtr = L'\0';         /* null terminate the string */
    putchar(L'\n');

    return((len <= buflen) ? 0 : ERROR_BUFFER_OVERFLOW);    

}

VOID
Scramble(
    IN OUT LPWSTR Pwd
    )
{
    UNICODE_STRING Str;
    UCHAR Seed = DHCP_ENCODE_SEED;
    
    Str.Length = (USHORT)(wcslen(Pwd)*sizeof(WCHAR));
    Str.MaximumLength = Str.Length;
    Str.Buffer = (PVOID)Pwd;

    RtlRunEncodeUnicodeString(&Seed, &Str);
}

DWORD
HandleSrvrSetDnsCredentials(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD Error = NO_ERROR;
    WCHAR Password[500];
    DWORD Size = sizeof(Password)/sizeof(Password[0]);

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    if( dwArgCount != 3 ) {
        DisplayMessage( g_hModule, HLP_SRVR_SET_DNSCREDENTIALS_EX );
        Error = ERROR_INVALID_PARAMETER;
    } else {
        if( 0 == STRICMP(ppwcArguments[dwCurrentIndex+2], TEXT("*"))) {
            Error = GetPassword(Password, Size);
        } else {
            if( wcslen(ppwcArguments[dwCurrentIndex+2]) >= Size ) {
                Error = ERROR_BUFFER_OVERFLOW;
            } else {
                wcscpy(Password, ppwcArguments[dwCurrentIndex+2]);
            }
        }

        if( NO_ERROR == Error ) {
            Scramble(Password);

            Error = DhcpServerSetDnsRegCredentials(
                g_ServerIpAddressUnicodeString,
                ppwcArguments[dwCurrentIndex],
                ppwcArguments[dwCurrentIndex+1],
                Password );
        }
    }
    
    if( RPC_S_PROCNUM_OUT_OF_RANGE == Error ) {
        DisplayMessage(
            g_hModule, EMSG_SRVR_NEED_DNS_CREDENTIALS_SUPPORT );
        return ERROR_CAN_NOT_COMPLETE;
    }    
    
    if( NO_ERROR == Error ) {
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    } else {
        DisplayErrorMessage(
            g_hModule, EMSG_SRVR_SET_DNSCREDENTIALS, Error );
    }

    return Error;
}

DWORD
HandleSrvrDeleteDnsCredentials(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD Error = NO_ERROR;
    
    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    if( dwArgCount != 1 || 0 !=
        STRICMP(ppwcArguments[dwCurrentIndex], TEXT("DhcpFullForce")) ) {
        DisplayMessage( g_hModule,
                        HLP_SRVR_DELETE_DNSCREDENTIALS_EX );
        Error = ERROR_INVALID_PARAMETER;
    } else {
        Error = DhcpServerSetDnsRegCredentials(
            g_ServerIpAddressUnicodeString, L"", L"", L"" );
    }

    if( RPC_S_PROCNUM_OUT_OF_RANGE == Error ) {
        DisplayMessage(
            g_hModule, EMSG_SRVR_NEED_DNS_CREDENTIALS_SUPPORT );
        return ERROR_CAN_NOT_COMPLETE;
    }    
    
    if( NO_ERROR == Error ) {
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    } else {
        DisplayErrorMessage(
            g_hModule, EMSG_SRVR_SET_DNSCREDENTIALS, Error );
    }

    return Error;
}

DWORD
HandleSrvrSetAuditlog(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD   Error = NO_ERROR;
    DWORD   DiskCheckInterval = 0, 
            MaxLogFileSize = 0,
            MinSpaceOnDisk = 0;
    LPWSTR  pwszLogDir = NULL;
    LPWSTR  pwszNewDir = NULL;

    HANDLE  hFile = NULL;

    if( dwArgCount < 1 ) 
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_SET_AUDITLOG_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    pwszNewDir = ppwcArguments[dwCurrentIndex];
    
    if( IsLocalServer(g_pwszServer) )
    {
        if( INVALID_HANDLE_VALUE is ( hFile = CreateFile(pwszNewDir,
                                                         GENERIC_READ,
                                                         0,
                                                         NULL,
                                                         OPEN_EXISTING,
                                                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
                                                         NULL) ) )
        {
            Error = GetLastError();
            if( ERROR_SHARING_VIOLATION == Error )
            {
                //
                // This indicates that the file does exist..
                //

                hFile = NULL;
                Error = NO_ERROR ;
            }
            else
            {
                DisplayMessage(g_hModule,
                               EMSG_SRVR_INVALID_DIRECTORY,
                               pwszNewDir);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
        else
        {
            CloseHandle(hFile);
            hFile = NULL;
        }
    }

    Error = DhcpAuditLogGetParams( g_ServerIpAddressUnicodeString,
                                   0,
                                   &pwszLogDir,
                                   &DiskCheckInterval,
                                   &MaxLogFileSize,
                                   &MinSpaceOnDisk);


    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    Error = DhcpAuditLogSetParams( g_ServerIpAddressUnicodeString,
                                   0,
                                   pwszNewDir,
                                   DiskCheckInterval,
                                   MaxLogFileSize,
                                   MinSpaceOnDisk);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    if( pwszLogDir is NULL )
        pwszLogDir = L"None";

    DisplayMessage(g_hModule,
                   MSG_SRVR_CHANGE_AUDIT_SETTINGS,
                   pwszLogDir,
                   pwszNewDir);

    DisplayMessage(g_hModule,
                   MSG_SRVR_NEED_RESTART);

    DisplayMessage(g_hModule,
                   EMSG_DHCP_ERROR_SUCCESS);
CommonReturn:

    if( pwszLogDir )
    {
        DhcpRpcFreeMemory(pwszLogDir);
        pwszLogDir = NULL;
    }

    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SET_AUDITLOG,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrSetDnsconfig(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                  Error = NO_ERROR;
    DHCP_OPTION_SCOPE_INFO ScopeInfo = {0};
    LPDHCP_OPTION_VALUE    OptionValue = NULL;
    DHCP_OPTION_VALUE      DummyValue;
    DHCP_OPTION_DATA_ELEMENT OptionElement;
    DHCP_OPTION_DATA       OptionData = { 1, &OptionElement };
    DWORD   dwValue = 0;
    
    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_SET_DNSCONFIG_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    ScopeInfo.ScopeType = DhcpGlobalOptions ;
    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {
        Error = DhcpGetOptionValueV5(g_ServerIpAddressUnicodeString,
                                     0,
                                     81,    //DYNDNS option
                                     NULL,
                                     NULL,
                                     &ScopeInfo,
                                     &OptionValue);

        if( ERROR_FILE_NOT_FOUND == Error )
        {
            dwValue = DNS_FLAG_ENABLED | DNS_FLAG_CLEANUP_EXPIRED;
            Error = NO_ERROR;
            OptionValue = NULL;
        }
    }
    else
    {
        Error = DhcpGetOptionValue(g_ServerIpAddressUnicodeString,
                                   81,
                                   &ScopeInfo,
                                   &OptionValue);
    }

    if( Error is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_NO_SETDNSCONFIG);
        return Error;
    }

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    if( NULL != OptionValue )
    {
        dwValue = OptionValue->Value.Elements->Element.DWordOption;
    }
    
    if( wcslen(ppwcArguments[dwCurrentIndex]) isnot 1 )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( ppwcArguments[dwCurrentIndex][0] is L'1' )
    {
        dwValue |= DNS_FLAG_ENABLED;
    }

    else if ( ppwcArguments[dwCurrentIndex][0] is L'0' )
    {
        dwValue &= ~DNS_FLAG_ENABLED;
    }

    else
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( dwArgCount > 1 )
    {
        if( wcslen(ppwcArguments[dwCurrentIndex+1]) isnot 1 )
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
        if( ppwcArguments[dwCurrentIndex+1][0] is L'1' )
        {
            dwValue |= DNS_FLAG_UPDATE_BOTH_ALWAYS;
        }
        
        else if( ppwcArguments[dwCurrentIndex+1][0] is L'0' )
        {
            dwValue &= ~DNS_FLAG_UPDATE_BOTH_ALWAYS;
        }
        
        else
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    if( dwArgCount > 2 )
    {
        if( wcslen(ppwcArguments[dwCurrentIndex+2]) isnot 1 )
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
        if( ppwcArguments[dwCurrentIndex+2][0] is L'1' )
        {
            dwValue |= DNS_FLAG_CLEANUP_EXPIRED;
        }
        
        else if( ppwcArguments[dwCurrentIndex+2][0] is L'0' )
        {
            dwValue &= ~DNS_FLAG_CLEANUP_EXPIRED;
        }

        else
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    if( dwArgCount > 3 )
    {
        if( wcslen(ppwcArguments[dwCurrentIndex+3]) isnot 1 )
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
        if( ppwcArguments[dwCurrentIndex+3][0] is L'1' )
        {
            dwValue |= DNS_FLAG_UPDATE_DOWNLEVEL;
        }
        else if( ppwcArguments[dwCurrentIndex+3][0] is L'0' )
        {
            dwValue &= ~DNS_FLAG_UPDATE_DOWNLEVEL;
        }
        else
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    if( NULL == OptionValue ) {
        OptionValue = & DummyValue;
        OptionValue->OptionID = 81; //DYNDNS option
        OptionValue->Value = OptionData;
        OptionValue->Value.Elements->OptionType = DhcpDWordOption;
    }
    
    OptionValue->Value.Elements->Element.DWordOption = dwValue;
    
    ScopeInfo.ScopeType = DhcpGlobalOptions ;

    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {
        Error = DhcpSetOptionValueV5(g_ServerIpAddressUnicodeString,
                                     0,
                                     81,    //DYNDNS option
                                     NULL,
                                     NULL,
                                     &ScopeInfo,
                                     &OptionValue->Value);
    }
    else
    {
        Error = DhcpSetOptionValue(g_ServerIpAddressUnicodeString,
                                   81,
                                   &ScopeInfo,
                                   &OptionValue->Value);
    }

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule,
                   EMSG_DHCP_ERROR_SUCCESS);

CommonReturn:

    if(( OptionValue != NULL ) &&
       ( OptionValue != &DummyValue ))
    {
        DhcpRpcFreeMemory(OptionValue);
        OptionValue = NULL;
    }
    return Error;

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SHOW_DNSCONFIG,
                        Error);
    goto CommonReturn;

}

DWORD
HandleSrvrSetDetectconflictretry(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                         Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4  ConfigInfo = NULL;
    
    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_SET_DETECTCONFLICTRETRY_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    ConfigInfo = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

    if( ConfigInfo == NULL ) 
    {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASERESTOREFLAG,
                            Error);
        return Error;
    }

    memset(ConfigInfo, 0x00, sizeof(DHCP_SERVER_CONFIG_INFO_V4));

    if( IsPureNumeric(ppwcArguments[dwCurrentIndex]) )
    {
        ConfigInfo->dwPingRetries = STRTOUL(ppwcArguments[dwCurrentIndex], NULL, 10);
        
        if( ConfigInfo->dwPingRetries > 5 )
        {
            ConfigInfo->dwPingRetries = 5;
        }
    }
    else
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    Error = DhcpServerSetConfigV4(g_ServerIpAddressUnicodeString,
                                  Set_PingRetries,
                                  ConfigInfo);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule,
                   EMSG_DHCP_ERROR_SUCCESS);


CommonReturn:

    if( ConfigInfo )
    {
        DhcpFreeMemory(ConfigInfo);
        ConfigInfo = NULL;
    }
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SET_DETECTCONFLICTRETRY,
                        Error);
    goto CommonReturn;                                
    
}


DWORD
HandleSrvrShowAll(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD Error = NO_ERROR;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    Error = HandleSrvrShowMibinfo(pwszMachine, ppwcArguments, dwCurrentIndex, dwArgCount, dwFlags, pvData, pbDone);
    Error = HandleSrvrShowServerconfig(pwszMachine, ppwcArguments, dwCurrentIndex, dwArgCount, dwFlags, pvData, pbDone);
    Error = HandleSrvrShowServerstatus(pwszMachine, ppwcArguments, dwCurrentIndex, dwArgCount, dwFlags, pvData, pbDone);

    return Error;
}

VOID
DisplayBindingInfo(DHCP_BIND_ELEMENT Element)
{
    WCHAR           wc[1024] = {L'\0'};
    
    if( Element.fBoundToDHCPServer )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_BOUNDTOSERVER_TRUE);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_BOUNDTOSERVER_FALSE);
    }

    DisplayMessage(g_hModule,
                   MSG_SRVR_PRIMARY_ADDRESS,
                   IpAddressToString(ntohl(Element.AdapterPrimaryAddress)));

    DisplayMessage(g_hModule,
                   MSG_SRVR_SUBNET_ADDRESS,
                   IpAddressToString(ntohl(Element.AdapterSubnetAddress)));

    DisplayMessage(g_hModule,
                   MSG_SRVR_IF_DESCRIPTION,
                   Element.IfDescription);

    DhcpHexToString(wc, Element.IfId, Element.IfIdSize);

    DisplayMessage(g_hModule,
                   MSG_SRVR_IFID,
                   wc);
    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);
                   

                   
}

DWORD
HandleSrvrShowBindings(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                          Error = NO_ERROR;
    LPDHCP_BIND_ELEMENT_ARRAY      Elements = NULL;
    LPDHCP_ATTRIB                  Attrib = NULL;
    DWORD                          i=0;

    Error = DhcpServerQueryAttribute(g_ServerIpAddressUnicodeString,
                                     0,
                                     DHCP_ATTRIB_BOOL_IS_BINDING_AWARE,
                                     &Attrib);

    if( Error isnot NO_ERROR )
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SHOW_BINDINGS,
                            Error);
        return Error;
    }                      
    
    if( Attrib->DhcpAttribBool is FALSE )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_BINDINGS_SUPPORT);
        return Error;
    }

    DhcpRpcFreeMemory(Attrib);
    Attrib = NULL;

    Error = DhcpGetServerBindingInfo(g_ServerIpAddressUnicodeString,
                                     0,
                                     &Elements);

    if( Error isnot NO_ERROR )
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SHOW_BINDINGS,
                            Error);
        return Error;
    }

    if( Elements->NumElements is 0 )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_NO_BINDINGS);
        if( Elements )
        {
            DhcpRpcFreeMemory(Elements);
            Elements = NULL;
        }
        return Error;
    }

    for( i=0; i<Elements->NumElements; i++ )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_BINDINGS,
                       i);
        DisplayBindingInfo(Elements->Elements[i]);
    }
    
    DisplayMessage(g_hModule,
                   EMSG_SRVR_ERROR_SUCCESS);
    return Error;
}


DWORD
HandleSrvrShowClass(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                          Error = NO_ERROR;
    DWORD                          nRead, nTotal, nCount;
    DHCP_RESUME_HANDLE             ResumeHandle;
    LPDHCP_CLASS_INFO_ARRAY        ClassInfoArray = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    ClassInfoArray = NULL;
    ResumeHandle = 0;
    nRead = nTotal = nCount = 0;
    
    while(TRUE)
    {
        Error = DhcpEnumClasses(
                    g_ServerIpAddressUnicodeString,
                    0,
                    &ResumeHandle,
                    ~0,
                    &ClassInfoArray,
                    &nRead,
                    &nTotal
                );

        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_CLASS_COUNT,
                           nCount);

            Error = NO_ERROR;

            break;
        }

        if( ERROR_MORE_DATA isnot Error and 
            NO_ERROR isnot Error ) 
        {
            goto ErrorReturn;
        }
        
        nCount += nRead;

        if( ClassInfoArray isnot NULL )
        {
            PrintClassInfoArray(ClassInfoArray);
            DhcpRpcFreeMemory(ClassInfoArray);
            ClassInfoArray = NULL;
        }
        if( Error is NO_ERROR )
        {
            break;
        }
        else
        {
            continue;    
        }

    }

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SRVR_SHOW_CLASS, 
                        Error);
    goto CommonReturn;
}


DWORD
HandleSrvrShowMibinfo(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD               Error = NO_ERROR;
    LPDHCP_MIB_INFO     MibInfo = NULL;
    DWORD               i = 0;
    LPSCOPE_MIB_INFO    ScopeInfo = NULL;
    FILETIME            ftTime={0};
    LPWSTR              pwszTime = NULL;


    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    DisplayMessage(g_hModule, MSG_SRVR_MIB);
    
    Error = DhcpGetMibInfo(
                g_ServerIpAddressUnicodeString,
                &MibInfo );

    if( Error isnot NO_ERROR )
    {
        goto ErrorReturn;
    }


    DhcpAssert( MibInfo != NULL );

    DisplayMessage(g_hModule, 
                   MSG_SRVR_MIB_DISCOVERS, 
                   MibInfo->Discovers);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_MIB_OFFERS, 
                   MibInfo->Offers);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_MIB_REQUESTS, 
                   MibInfo->Requests);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_MIB_ACKS, 
                   MibInfo->Acks);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_MIB_NAKS, 
                   MibInfo->Naks);

    DisplayMessage(g_hModule,
                   MSG_SRVR_MIB_DECLINES,
                   MibInfo->Declines);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_MIB_RELEASES, 
                   MibInfo->Releases);

    ftTime = *(FILETIME *)(&MibInfo->ServerStartTime);
    
    i = 0;
    
    pwszTime = GetDateTimeString(ftTime,
                                 FALSE,
                                 &i);

    DisplayMessage(g_hModule,
                   MSG_SRVR_MIB_SERVERSTARTTIME,
                   pwszTime ? pwszTime : L" ");

    if( pwszTime )
    {
        DhcpFreeMemory(pwszTime);
        pwszTime = NULL;
    }

    DisplayMessage(g_hModule, MSG_SRVR_MIB_SCOPES, MibInfo->Scopes);

    ScopeInfo = MibInfo->ScopeInfo;

    for ( i = 0; i < MibInfo->Scopes; i++ ) 
    {
        DisplayMessage(g_hModule, 
                       MSG_SRVR_MIB_SCOPES_SUBNET,
                       IpAddressToString(ScopeInfo[i].Subnet));

        DisplayMessage(g_hModule,
                       MSG_SRVR_MIB_SCOPES_SUBNET_NUMADDRESSESINUSE,
                       ScopeInfo[i].NumAddressesInuse );

        DisplayMessage(g_hModule,
                       MSG_SRVR_MIB_SCOPES_SUBNET_NUMADDRESSESFREE,
                       ScopeInfo[i].NumAddressesFree );

        DisplayMessage(g_hModule,
                       MSG_SRVR_MIB_SCOPES_SUBNET_NUMPENDINGOFFERS,
                       ScopeInfo[i].NumPendingOffers );
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
CommonReturn:
    if( MibInfo )
    {
        DhcpRpcFreeMemory( MibInfo );
        MibInfo = NULL;
    }
    return Error;

ErrorReturn:
    DisplayMessage(g_hModule,
                   EMSG_SRVR_SHOW_MIBINFO,
                   Error);
    goto CommonReturn;
}

DWORD
HandleSrvrShowMscope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD               Error = NO_ERROR;
    DHCP_RESUME_HANDLE  ResumeHandle = 0;
    LPDHCP_MSCOPE_TABLE MScopeTable = NULL;
    DWORD               ClientsRead = 0;
    DWORD               ClientsTotal = 0;
    DWORD               i, nCount = 0;
    LPWSTR              UnicodeMScopeName = NULL;
    BOOL                fTable = FALSE;
    
    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    while(TRUE)
    {

        MScopeTable = NULL;
        Error = DhcpEnumMScopes(
                    g_ServerIpAddressUnicodeString,
                    &ResumeHandle,
                    (DWORD)(-1),
                    &MScopeTable,
                    &ClientsRead,
                    &ClientsTotal );

        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_MULTICAST_CLIENT_COUNT,
                           nCount);
            Error = NO_ERROR;
            break;
        }

        if( Error isnot NO_ERROR and 
            Error isnot ERROR_MORE_DATA )
        {
            goto ErrorReturn;
        }

        DhcpAssert( MScopeTable != NULL );
        DhcpAssert( MScopeTable->NumElements == ClientsRead );

        if( fTable is FALSE )
        {           
            DisplayMessage(g_hModule, MSG_SRVR_MSCOPE_TABLE);
            fTable = TRUE;
        }

        nCount += ClientsRead;

        for( i = 0; i < ClientsRead; i++ ) 
        {
            LPDHCP_MSCOPE_INFO MScopeInfo = NULL;
            WCHAR Name[35] = {L'\0'};
            WCHAR Id[17] = {L'\0'};
            WCHAR Comment[21]={L'\0'};
            DWORD dw = 0, dwError = NO_ERROR;

            dwError = DhcpGetMScopeInfo(
                                      g_ServerIpAddressUnicodeString,
                                      MScopeTable->pMScopeNames[i],
                                      &MScopeInfo);


            if( dwError isnot NO_ERROR )
            {
                Error = dwError;
                goto ErrorReturn;
            }
            
            if( IsBadStringPtr(MScopeInfo->MScopeName, MAX_MSG_LENGTH) is FALSE )
            {
                for(dw=0; ( ( dw<34 ) && ( dw<wcslen(MScopeInfo->MScopeName) ) ); dw++)
                {
                    Name[dw] = MScopeInfo->MScopeName[dw];
                }
            }
            
            Name[34] = L'\0';

            for( dw = wcslen(Name); dw < 35; dw++ )
                Name[dw] = L' ';

            Name[34] = L'\0';

            if( IsBadStringPtr(MScopeInfo->MScopeComment, MAX_MSG_LENGTH) is FALSE )
            {
                for( dw=0; dw < 20 && dw < wcslen(MScopeInfo->MScopeComment); dw++ )
                    Comment[dw] = MScopeInfo->MScopeComment[dw];
            }

            Comment[20] = L'\0';

            for( dw=wcslen(Comment); dw < 20 ; dw++)
                Comment[dw] = L' ';
            
            Comment[19] = L'\0';
            
            wsprintf(Id, L" %u", MScopeInfo->MScopeId);

            Id[16] = L'\0';

            for( dw=wcslen(Id); dw < 16; dw++)
                Id[dw] = L' ';

            Id[16] = L'\0';
            
            if( MScopeInfo->MScopeState is DhcpSubnetEnabled )
            {
                DisplayMessage(g_hModule, 
                               MSG_SRVR_MSCOPE_INFO_ACTIVE,
                               Name,
                               Id,
                               Comment);

            }
            else
            {
                DisplayMessage(g_hModule, 
                               MSG_SRVR_MSCOPE_INFO_NOTACTIVE,
                               Name,
                               Id,
                               Comment);
            }

            DhcpRpcFreeMemory(MScopeInfo);
            MScopeInfo = NULL;

        }
        
        DhcpRpcFreeMemory( MScopeTable );
        MScopeTable = NULL;

        if( Error is ERROR_MORE_DATA ) 
        {
            continue;
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_MULTICAST_CLIENT_COUNT,
                           nCount);
            break;
        }
    }

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
CommonReturn:

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SHOW_MSCOPE,
                        Error);
    goto CommonReturn;
}


DWORD
HandleSrvrShowOptiondef(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD               Error = NO_ERROR;
    LPDHCP_OPTION_ARRAY OptionsArray = NULL;
    LPDHCP_ALL_OPTIONS  OptionsAll = NULL;
    DHCP_RESUME_HANDLE  ResumeHandle = 0;
    DWORD               OptionsRead  = 0;
    DWORD               OptionsTotal = 0;
    DWORD               nCount = 0;
    LPWSTR              pwcTag = NULL;
    LPWSTR              pwcUser = NULL;
    LPWSTR              pwcVendor = NULL;
    LPWSTR              pwcTemp = NULL;
    
    BOOL                fUser = FALSE;
    BOOL                fVendor = FALSE;
    BOOL                fTable = FALSE;

    DWORD               dwIndex=0;
    enum                {all=0, user, vendor, both}eDisplay;

    
    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    if( dwArgCount > 0 )
    {
        if( _wcsicmp(ppwcArguments[dwCurrentIndex], L"all") is 0 )
        {
            eDisplay = all;
        }
        else
        {
            while( TRUE )
            {
                LPWSTR  pwcStr = NULL;
        
                if( dwArgCount <= dwIndex )
                    break;
                if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER) )
                    break;
    
                pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
                if( pwcTemp is NULL )
                {
                    Error = ERROR_OUT_OF_MEMORY;
                    goto ErrorReturn;
                }
                wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

                pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
                if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
                {
                    if( fUser is TRUE ) //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcUser = NULL;
                        else
                        {
                            pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcUser is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcUser, pwcStr);
                            eDisplay = user;
                        }
                        fUser = TRUE;
                    }
                }
                else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
                {
                    if( fVendor is TRUE )   //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcVendor = NULL;
                        else
                        {
                            pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcVendor is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcVendor, pwcStr);
                            eDisplay = vendor;
                        }
                        fVendor = TRUE;
                    }
                }
                else
                {
                    DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
                    return ERROR_INVALID_PARAMETER;
                }

                if( pwcTemp )
                {
                    DhcpFreeMemory(pwcTemp);
                    pwcTemp = NULL;
                }
        
                dwIndex++;
            }
        }
    }

    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }


    if( fUser && fVendor )
    {
        eDisplay = both;
    }

    switch(eDisplay)
    {
    case all:
        {
            while(TRUE)
            {
                Error = DhcpGetAllOptions(
                            g_ServerIpAddressUnicodeString,
                            0,
                            &OptionsAll);

                if( Error is NO_ERROR or
                    Error is ERROR_MORE_DATA )
                {
                    PrintAllOptions(OptionsAll);
                    if( Error is NO_ERROR )
                        break;
                    else
                    {
                        DhcpRpcFreeMemory(OptionsAll);
                        OptionsAll = NULL;
                        continue;
                    }
                }
                else
                    goto ErrorReturn;
            }
            break;
        }
    default:
        {
            nCount = 0;

            while(TRUE)
            {
                if( g_dwMajorVersion >= CLASS_ID_VERSION )
                {
                    Error = DhcpEnumOptionsV5(
                                            g_ServerIpAddressUnicodeString,
                                            fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                            pwcUser,
                                            pwcVendor,
                                            &ResumeHandle,
                                            ~0,
                                            &OptionsArray,
                                            &OptionsRead,
                                            &OptionsTotal
                                            );


                }
                else
                {
                    Error = DhcpEnumOptions(
                                            g_ServerIpAddressUnicodeString,
                                            &ResumeHandle,
                                            ~0,
                                            &OptionsArray,
                                            &OptionsRead,
                                            &OptionsTotal);
                
                }

                if( Error is ERROR_NO_MORE_ITEMS )
                {
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_OPTION_TOTAL,
                                   nCount);
                    Error = NO_ERROR;

                    break;
                }


                if( Error isnot NO_ERROR and
                    Error isnot ERROR_MORE_DATA 
                  )
                {
                    goto ErrorReturn;
                } 

                nCount += OptionsRead;

                {

                    DWORD           i = 0;
                    LPDHCP_OPTION   Options;
                    DWORD           NumOptions = 0;

                

                    if( g_dwMajorVersion >= CLASS_ID_VERSION )
                    {
                        if( pwcUser isnot NULL )
                        {
                            DisplayMessage(g_hModule, 
                                           MSG_SRVR_USER_CLASS,
                                           pwcUser);
                        }

                        if( pwcVendor )
                        {
                            DisplayMessage(g_hModule,
                                           MSG_SRVR_VENDOR_CLASS,
                                           pwcVendor);
                        }
                    }

                    DisplayMessage(g_hModule,
                                   MSG_DHCP_FORMAT_LINE);


                    Options = OptionsArray->Options;
                    NumOptions = OptionsArray->NumElements;

                    if( fTable is FALSE )
                    {
                        if( pwcUser is NULL &&
                            pwcVendor is NULL )
                            DisplayMessage(g_hModule, MSG_SRVR_OPTION_NONVENDOR);
                        DisplayMessage(g_hModule, MSG_SRVR_OPTIONDEF_TABLE);
                        fTable = TRUE;
                    }
                    for( i = 0; i < NumOptions; i++, Options++ ) 
                    {
                        PrintOptionInfo( Options );
                    }
                    DhcpRpcFreeMemory( OptionsArray );
                    OptionsArray = NULL;
                }
                
                if( Error is ERROR_MORE_DATA )
                {
                    continue;
                }
                else
                {
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_OPTION_TOTAL,
                                   nCount);
                    break;
                                   
                }
                    
            }
            break;
        }
    }
CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);

    if( pwcUser  && pwcUser != g_UserClass ) 
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }
    if( pwcVendor  && pwcVendor != g_VendorClass ) 
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SHOW_OPTIONDEF,
                        Error);
    goto CommonReturn;
}


DWORD
HandleSrvrShowOptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                       Error = NO_ERROR;
    DWORD                       Major;
    LPDHCP_ALL_OPTION_VALUES    OptionValues = NULL;
    DHCP_OPTION_SCOPE_INFO      ScopeInfo;
    LPDHCP_OPTION_VALUE_ARRAY   OptionArray = NULL;
    DHCP_RESUME_HANDLE          Resume = 0;
    LPWSTR                      pwcTag = NULL;
    LPWSTR                      pwcUser = NULL;
    LPWSTR                      pwcVendor = NULL;
    LPWSTR                      pwcTemp = NULL;

    BOOL                        fUser = FALSE;
    BOOL                        fVendor = FALSE;

    DWORD                       dwRead = 0;
    DWORD                       dwTotal = 0;
    DWORD                       dwCount = 0;

    DWORD                       dwIndex=0;

    enum                        { all=0, user, vendor, both}eDisplay;


    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));
    
    eDisplay = all;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    ScopeInfo.ScopeType = DhcpGlobalOptions;
    
    if( dwArgCount > 0 )
    {
        if( _wcsicmp(ppwcArguments[dwCurrentIndex], L"all") is 0 )
        {
            eDisplay = all;
        }
        else
        {
            while( TRUE )
            {
                LPWSTR  pwcStr = NULL;
        
                if( dwArgCount <= dwIndex )
                    break;
                if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER) )
                    break;
    
                pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
                if( pwcTemp is NULL )
                {
                    Error = ERROR_OUT_OF_MEMORY;
                    goto ErrorReturn;
                }
                wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

                pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
                if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
                {
                    if( fUser is TRUE ) //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcUser = NULL;
                        else
                        {
                            pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcUser is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcUser, pwcStr);
                        }
                        eDisplay = user;
                        fUser = TRUE;
                    }
                }
                else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
                {
                    if( fVendor is TRUE )   //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcVendor = NULL;
                        else
                        {
                            pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcVendor is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcVendor, pwcStr);
                        }
                        eDisplay = vendor;
                        fVendor = TRUE;
                    }
                }
                else
                {
                    DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
                    return ERROR_INVALID_PARAMETER;
                }

                if( pwcTemp )
                {
                    DhcpFreeMemory(pwcTemp);
                    pwcTemp = NULL;
                }
        
                dwIndex++;
            }

        }
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }    

    if( fUser && fVendor )
    {
        eDisplay = both;
    }

    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {
        switch( eDisplay )
        {
        case all:
        default:
            {
                Error = DhcpGetAllOptionValues(
                            g_ServerIpAddressUnicodeString,
                            DHCP_OPT_ENUM_IGNORE_VENDOR,
                            &ScopeInfo,
                            &OptionValues
                            );


                if( Error isnot NO_ERROR )
                    goto ErrorReturn;
            
                if( OptionValues )
                {
                    dwCount += PrintAllOptionValues(OptionValues);
                    DhcpRpcFreeMemory(OptionValues);
                    OptionValues = NULL;
                }

                break;
            }
        case user:
            {
                Error = DhcpGetAllOptionValues(
                                g_ServerIpAddressUnicodeString,
                                DHCP_OPT_ENUM_IGNORE_VENDOR,
                                &ScopeInfo,
                                &OptionValues);

                if( Error isnot NO_ERROR )
                    goto ErrorReturn;

                if( OptionValues )
                {
                    dwCount += PrintUserOptionValues(OptionValues, pwcUser, NULL);
                    DhcpRpcFreeMemory(OptionValues);
                    OptionValues = NULL;
                }
                break;
            }
        case vendor:
            {
                Error = DhcpGetAllOptionValues(
                                g_ServerIpAddressUnicodeString,
                                DHCP_OPT_ENUM_IGNORE_VENDOR,
                                &ScopeInfo,
                                &OptionValues);

                if( Error isnot NO_ERROR )
                    goto ErrorReturn;

                if( OptionValues )
                {
                    dwCount += PrintUserOptionValues(OptionValues, pwcUser, pwcVendor);
                    DhcpRpcFreeMemory(OptionValues);
                    OptionValues = NULL;
                }
                break;
            }
        case both:
            {
                Error = DhcpGetAllOptionValues(
                                g_ServerIpAddressUnicodeString,
                                DHCP_OPT_ENUM_IGNORE_VENDOR,
                                &ScopeInfo,
                                &OptionValues);

                if( Error isnot NO_ERROR )
                    goto ErrorReturn;

                if( OptionValues )
                {
                    dwCount += PrintUserOptionValues(OptionValues, pwcUser, pwcVendor);
                    DhcpRpcFreeMemory(OptionValues);
                    OptionValues = NULL;
                }
                break;
            }
        }
    }
    else
    {
        Error = ShowOptionValues4(g_ServerIpAddressUnicodeString,
                                  &ScopeInfo,
                                  &dwCount);

        if( Error isnot NO_ERROR )
            goto ErrorReturn;
    }
CommonReturn:
    if( Error is ERROR_SUCCESS )
    {
        if( dwCount is 0 )
        {
            DisplayMessage(g_hModule,
                           MSG_DHCP_NO_OPTIONVALUE_SET);
        }

        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    }
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SHOW_OPTIONVALUE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrShowScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                               Error = NO_ERROR;
    ULONG                               nRead, nTotal, i, nCount;
    ULONG                               Resume = 0;
    LPDHCP_IP_ARRAY                     IpArray = NULL;
    LPDHCP_SUBNET_INFO                  ScopeInfo = NULL;
    DHCP_HOST_INFO                      HostInfo;
    BOOL                                fHost = FALSE,
                                        fTable = FALSE;


    memset( &HostInfo, 0x00, sizeof(DHCP_HOST_INFO));

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }



    nRead = nTotal = i = nCount = 0;

       
    while(TRUE)
    {

        Error = DhcpEnumSubnets(
                    g_ServerIpAddressUnicodeString,
                    &Resume,
                    ~0,
                    &IpArray,
                    &nRead,
                    &nTotal
                    );
        
        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule, 
                           MSG_SRVR_SCOPE_COUNT, 
                           nCount);

            Error = NO_ERROR;

            break;
        }
        if( Error isnot NO_ERROR and
            Error isnot ERROR_MORE_DATA )
            goto ErrorReturn;
        

        DhcpAssert( IpArray isnot NULL );
        
        nCount += nRead;

        if( fTable is FALSE )
        {
            DisplayMessage(g_hModule, MSG_SRVR_SCOPE_TABLE);
            fTable = TRUE;
        }
        for( i = 0; ( i < nRead ) and ( i < IpArray->NumElements ) ; i++ )
        {
            DWORD dwError = NO_ERROR;

            dwError = DhcpGetSubnetInfo(
                          g_ServerIpAddressUnicodeString,
                          IpArray->Elements[i],
                          &ScopeInfo);

            if( dwError isnot NO_ERROR )
            {
                Error = dwError;
                goto ErrorReturn;
            }


            DhcpAssert( ScopeInfo isnot NULL );

            
            if( fHost is FALSE )
            {
                HostInfo = ScopeInfo->PrimaryHost;
                fHost = TRUE;
            }
            {
                WCHAR   Ip[17] = {L'\0'};
                WCHAR   Mask[17] = {L'\0'};
                WCHAR   Name[22] = {L'\0'};
                WCHAR   Comment[15] = {L'\0'};
                DWORD   dw = 0;

                wsprintf( Ip, L" %s", IpAddressToString(ScopeInfo->SubnetAddress));
                for( dw=wcslen(Ip); dw<17; dw++)
                    Ip[dw] = L' ';
                Ip[16] = L'\0';


                wsprintf( Mask, L" %s", IpAddressToString(ScopeInfo->SubnetMask));
                for( dw=wcslen(Mask); dw<17; dw++)
                    Mask[dw] = L' ';
                Mask[16] = L'\0';

                if( IsBadStringPtr(ScopeInfo->SubnetName, MAX_MSG_LENGTH) is FALSE )
                {
                    for( dw=0; (dw < 21) && (dw<wcslen(ScopeInfo->SubnetName)) ; dw++)
                    {
                        Name[dw] = ScopeInfo->SubnetName[dw];
                    }
                }
                
                Name[21] = L'\0';

                for( dw = wcslen(Name); dw<22 ; dw++)
                    Name[dw] = L' ';

                Name[21] = L'\0';

                if( IsBadStringPtr(ScopeInfo->SubnetComment, MAX_MSG_LENGTH) is FALSE )
                {
                    for( dw=0; (dw < 14) && (dw<wcslen(ScopeInfo->SubnetComment)) ; dw++)
                    {
                        Comment[dw] = ScopeInfo->SubnetComment[dw];
                    }
                }
                
                Comment[14] = L'\0';

                for( dw = wcslen(Comment); dw<15 ; dw++)
                    Comment[dw] = L' ';

                Comment[14] = L'\0';

                switch( ScopeInfo->SubnetState ) {
                case DhcpSubnetEnabled:
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_SCOPE_INFO_ACTIVE,
                                   Ip,
                                   Mask,
                                   Name,
                                   Comment);
                    break;
                case DhcpSubnetDisabled :
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_SCOPE_INFO_NOTACTIVE,
                                   Ip,
                                   Mask,
                                   Name,
                                   Comment);
                    break;
                case DhcpSubnetEnabledSwitched :
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_SCOPE_INFO_ACTIVE_SWITCHED,
                                   Ip,
                                   Mask,
                                   Name,
                                   Comment);
                    break;
                case DhcpSubnetDisabledSwitched :
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_SCOPE_INFO_NOTACTIVE_SWITCHED,
                                   Ip,
                                   Mask,
                                   Name,
                                   Comment);
                    break;                    
                }
            }    
            DhcpRpcFreeMemory(ScopeInfo);
            ScopeInfo = NULL;
        }
        
        DhcpRpcFreeMemory(IpArray);
        IpArray = NULL;
        
        if( Error is ERROR_MORE_DATA )
            continue;
        else
        {
            DisplayMessage(g_hModule,
                           MSG_DHCP_FORMAT_LINE);
            DisplayMessage(g_hModule, 
                           MSG_SRVR_SCOPE_COUNT, 
                           nCount);
            break;
        }
    }

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SHOW_SCOPE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrShowSuperScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    LPDHCP_SUPER_SCOPE_TABLE  pSScopeTable = NULL;
    LPDHCP_SUBNET_INFO        pScope = NULL;
    BOOL                      bDone;
    DWORD                     Error, i, j, tmp;

    // Syntax: show superscope

    Error = DhcpGetSuperScopeInfoV4( g_ServerIpAddressUnicodeString, &pSScopeTable );
    if (( NO_ERROR != Error ) ||
        ( NULL == pSScopeTable )) {
        return Error;
    }

    i = 0;
    do {
        bDone = TRUE;

        if (( pSScopeTable->cEntries > 0 ) &&
            ( pSScopeTable->pEntries[ i ].NextInSuperScope < ( pSScopeTable->cEntries + 1 ))) {
            DisplayMessage( g_hModule, MSG_SRVR_SSCOPE_NAME,
                            pSScopeTable->pEntries[ i ].SuperScopeName );
            j = i;
            bDone = FALSE;
            while (( j < pSScopeTable->cEntries ) &&
                   (( pSScopeTable->cEntries + 1 ) > j )) {

                Error = DhcpGetSubnetInfo( g_ServerIpAddressUnicodeString,
                                          pSScopeTable->pEntries[ j ].SubnetAddress,
                                          &pScope );
                if (( NO_ERROR != Error ) ||
                    ( NULL == pScope )) {
                    break;
                }
                DisplayMessage( g_hModule, MSG_SRVR_SSCOPE_SCOPE_ADDR_NAME,
                                IpAddressToString( pScope->SubnetAddress ),
                                pScope->SubnetName );

                // mark it is processed. 
                tmp = j;
                j = pSScopeTable->pEntries[ j ].NextInSuperScope;
                pSScopeTable->pEntries[ tmp ].NextInSuperScope = pSScopeTable->cEntries + 1;

                // The last entry in the list points to the previous 
                // one in the list.
                if ( pSScopeTable->pEntries[ j ].NextInSuperScope ==
                     ( pSScopeTable->cEntries + 1 )) {
                    j = pSScopeTable->cEntries + 1;
                }

                DhcpRpcFreeMemory( pScope );
                pScope = NULL;
            } // while

            if ( NO_ERROR != Error ) {
                break;
            }
        } // if new superscope

        i++;
    } while ( !bDone );

    DhcpRpcFreeMemory( pSScopeTable );

    DisplayMessage( g_hModule, EMSG_DHCP_ERROR_SUCCESS );

    return Error;
} // HandleSrvrShowSuperScope()

DWORD
HandleSrvrShowServer(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    if( ( g_ServerIpAddressUnicodeString is NULL ) and ( g_pwszServer is NULL ) )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
    }
    else
    {
        DisplayMessage(g_hModule, MSG_SRVR_COMPUTER_NAME, g_pwszServer, g_ServerIpAddressUnicodeString);
    }

    return NO_ERROR;
}

DWORD
HandleSrvrShowServerconfig(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                        Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_SRVR_SERVERCONFIG);

    Error = DhcpServerGetConfigV4(
                g_ServerIpAddressUnicodeString,
                &ConfigInfo );

    if( Error is ERROR_NO_MORE_ITEMS )
    {
        DisplayMessage(g_hModule, EMSG_DHCP_NO_MORE_ITEMS);
        return Error;
    }

    if( Error isnot NO_ERROR ) 
    {
        DisplayErrorMessage(g_hModule, 
                            EMSG_SRVR_SHOW_SERVERCONFIG,
                            Error);
        return Error;
    }


    DhcpAssert( ConfigInfo != NULL );

    DisplayMessage(g_hModule,
                   MSG_SRVR_DBPROPERTIES);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_SERVERCONFIG_DATABASENAME_VALUE, 
                   ConfigInfo->DatabaseName);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_SERVERCONFIG_DATABASEPATH_VALUE, 
                   ConfigInfo->DatabasePath);
    
    DisplayMessage(g_hModule, 
                   MSG_SRVR_SERVERCONFIG_BACKUPPATH_VALUE, 
                   ConfigInfo->BackupPath);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_SERVERCONFIG_BACKUPINTERVAL_VALUE, 
                   ConfigInfo->BackupInterval);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_SERVERCONFIG_DATABASELOGGINGFLAG_VALUE, 
                   ConfigInfo->DatabaseLoggingFlag);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_SERVERCONFIG_RESTOREFLAG_VALUE, 
                   ConfigInfo->RestoreFlag);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_SERVERCONFIG_DATABASECLEANUPINTERVAL_VALUE, 
                   ConfigInfo->DatabaseCleanupInterval);


    DhcpRpcFreeMemory( ConfigInfo );
    ConfigInfo = NULL;

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    return Error;

}


DWORD
HandleSrvrShowServerstatus(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD           Error = NO_ERROR;
    PDHCP_ATTRIB    pStatusAttrib = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_SRVR_SERVER_STATUS);

    Error = DhcpServerQueryAttribute(
        g_ServerIpAddressUnicodeString,
        0,
        DHCP_ATTRIB_BOOL_IS_ROGUE,
        &pStatusAttrib
    );

    if( Error is ERROR_NO_MORE_ITEMS )
    {
        DisplayMessage(g_hModule, EMSG_DHCP_NO_MORE_ITEMS);
        return Error;
    }

    if( NO_ERROR isnot Error ) 
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SHOW_SERVERSTATUS,
                            Error);
        return Error;
    }

    PrintDhcpAttrib(pStatusAttrib);

    if( pStatusAttrib ) 
    {
        DhcpRpcFreeMemory(pStatusAttrib);
    }

    pStatusAttrib = NULL;

    Error = DhcpServerQueryAttribute(
                g_ServerIpAddressUnicodeString,
                0,
                DHCP_ATTRIB_BOOL_IS_DYNBOOTP,
                &pStatusAttrib
            );

    if( Error is ERROR_NO_MORE_ITEMS )
    {
        DisplayMessage(g_hModule, EMSG_DHCP_NO_MORE_ITEMS);
        return Error;
    }

    if( NO_ERROR isnot Error ) 
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_SHOW_SERVERSTATUS,
                       g_pwszServer,
                       Error);
        return Error;        
    }

    PrintDhcpAttrib(pStatusAttrib);

    if( pStatusAttrib ) 
    {
        DhcpRpcFreeMemory(pStatusAttrib);
    }

    pStatusAttrib = NULL;

    Error = DhcpServerQueryAttribute(
                g_ServerIpAddressUnicodeString,
                0,
                DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC,
                &pStatusAttrib
            );

    if( Error is ERROR_NO_MORE_ITEMS )
    {
        DisplayMessage(g_hModule, EMSG_DHCP_NO_MORE_ITEMS);
        return Error;
    }

    if( NO_ERROR isnot Error ) 
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_SHOW_SERVERSTATUS,
                       g_pwszServer,
                       Error);
        return Error;        
    }

    PrintDhcpAttrib(pStatusAttrib);
    if( pStatusAttrib ) 
        DhcpRpcFreeMemory(pStatusAttrib);

    pStatusAttrib = NULL;
    
    Error = DhcpServerQueryAttribute(
                g_ServerIpAddressUnicodeString,
                0,
                DHCP_ATTRIB_BOOL_IS_BINDING_AWARE,
                &pStatusAttrib
            );

    if( Error is ERROR_NO_MORE_ITEMS )
    {
        DisplayMessage(g_hModule, EMSG_DHCP_NO_MORE_ITEMS);
        return Error;
    }

    if( NO_ERROR isnot Error ) 
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_SHOW_SERVERSTATUS,
                       g_pwszServer,
                       Error);
        return Error;        
    }

    PrintDhcpAttrib(pStatusAttrib);
    
    if( pStatusAttrib ) 
        DhcpRpcFreeMemory(pStatusAttrib);

    pStatusAttrib = NULL;
    
    Error = DhcpServerQueryAttribute(
                g_ServerIpAddressUnicodeString,
                0,
                DHCP_ATTRIB_BOOL_IS_ADMIN,
                &pStatusAttrib
            );

    if( Error is ERROR_NO_MORE_ITEMS )
    {
        DisplayMessage(g_hModule, EMSG_DHCP_NO_MORE_ITEMS);
        return Error;
    }

    if( NO_ERROR isnot Error ) 
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_SHOW_SERVERSTATUS,
                       g_pwszServer,
                       Error);
        return Error;        
    }

    PrintDhcpAttrib(pStatusAttrib);
    
    if( pStatusAttrib ) 
        DhcpRpcFreeMemory(pStatusAttrib);

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    
    pStatusAttrib = NULL;

    return Error;
    
}


DWORD
HandleSrvrShowUserclass(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    if( g_UserClass is NULL )
    {
        DisplayMessage(g_hModule, MSG_SRVR_CLASSNAME_NONE, g_pwszServer);
    }
    else
    {
        DisplayMessage(g_hModule, MSG_SRVR_CLASSNAME, g_UserClass, g_pwszServer);
    }
    return NO_ERROR;
}


DWORD
HandleSrvrShowVendorclass(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    if( g_VendorClass is NULL )
    {
        DisplayMessage(g_hModule, MSG_SRVR_VENDORNAME_NONE, g_pwszServer);
    }
    else
    {
        DisplayMessage(g_hModule, MSG_SRVR_VENDORNAME, g_VendorClass, g_pwszServer);
    }
    return NO_ERROR;
}

DWORD
HandleSrvrShowDnsCredentials(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    WCHAR Name[256], Domain[256];
    DWORD Error = NO_ERROR;


    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    ZeroMemory(Name,sizeof(Name));
    ZeroMemory(Domain,sizeof(Domain));


    // This pragma will prevent warning 209 when prefast 1.2 is released
// #pragma prefast(suppress:209, "It is handled correctly at the server and changing would break backward compatibility")
    Error = DhcpServerQueryDnsRegCredentials(
        g_ServerIpAddressUnicodeString,
        sizeof(Name), (LPWSTR)Name, sizeof(Domain),
        (LPWSTR)Domain );

    if( RPC_S_PROCNUM_OUT_OF_RANGE == Error ) {
        DisplayMessage(
            g_hModule, EMSG_SRVR_NEED_DNS_CREDENTIALS_SUPPORT );
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    if( NO_ERROR != Error ) {
        DisplayErrorMessage(
            g_hModule, EMSG_SRVR_SHOW_DNSCREDENTIALS, Error );
    } else {
        DisplayMessage(
            g_hModule, MSG_SRVR_DNS_CREDENTIALS, Name, Domain );
    }

    return Error;
}

DWORD
HandleSrvrShowVersion(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DisplayMessage(g_hModule,
                   MSG_SRVR_VERSION,
                   g_ServerIpAddressUnicodeString,
                   g_dwMajorVersion,
                   g_dwMinorVersion);
    return NO_ERROR;
}

DWORD
HandleSrvrShowAuditlog(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD   Error = NO_ERROR;
    DWORD   DiskCheckInterval = 0, 
            MaxLogFileSize = 0,
            MinSpaceOnDisk = 0;
    LPWSTR  pwszLogDir = NULL;

    Error = DhcpAuditLogGetParams( g_ServerIpAddressUnicodeString,
                                   0,
                                   &pwszLogDir,
                                   &DiskCheckInterval,
                                   &MaxLogFileSize,
                                   &MinSpaceOnDisk);


    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule,
                   MSG_SRVR_AUDIT_SETTINGS,
                   pwszLogDir,
                   DiskCheckInterval,
                   MaxLogFileSize,
                   MinSpaceOnDisk);

    DisplayMessage(g_hModule,
                   EMSG_DHCP_ERROR_SUCCESS);
CommonReturn:

    if( pwszLogDir )
    {
        DhcpRpcFreeMemory(pwszLogDir);
        pwszLogDir = NULL;
    }

    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SHOW_AUDITLOG,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrShowDnsconfig(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                  Error = NO_ERROR;
    DHCP_OPTION_SCOPE_INFO ScopeInfo = {0};
    DHCP_OPTION_ID         OptionId = 81;
    LPDHCP_OPTION_VALUE    OptionValue = NULL;

    DWORD   dwValue = 0;
    
    ScopeInfo.ScopeType = DhcpGlobalOptions;

    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {
        Error = DhcpGetOptionValueV5(g_ServerIpAddressUnicodeString,
                                     0,
                                     OptionId,    //DYNDNS option
                                     NULL,
                                     NULL,
                                     &ScopeInfo,
                                     &OptionValue);

        if( ERROR_FILE_NOT_FOUND == Error ) {
            dwValue = DNS_FLAG_ENABLED | DNS_FLAG_CLEANUP_EXPIRED;
            Error = NO_ERROR;
            OptionValue = NULL;
        }
    }
    else
    {
        Error = DhcpGetOptionValue(g_ServerIpAddressUnicodeString,
                                   OptionId,//81,
                                   &ScopeInfo,
                                   &OptionValue);
    }
    
    if( Error is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_NO_SHOWDNSCONFIG);
        return Error;
    }
    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    if( OptionValue ) {
        dwValue = OptionValue->Value.Elements->Element.DWordOption;
    }
    
    if( dwValue & DNS_FLAG_ENABLED )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_DNS_ENABLED);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_DNS_DISABLED);

        DisplayMessage(g_hModule,
                       EMSG_DHCP_ERROR_SUCCESS);
        goto CommonReturn;
    }

    DisplayMessage(g_hModule,
                   MSG_SRVR_UPDATE_LOOKUP);

    if( dwValue & DNS_FLAG_UPDATE_BOTH_ALWAYS )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_UPDATE_DOWNLEVEL_ENABLED);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_UPDATE_DOWNLEVEL_DISABLED);
    }

    DisplayMessage(g_hModule,
                   MSG_SRVR_DNS_OPTIONS);

    if( dwValue & DNS_FLAG_CLEANUP_EXPIRED )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_CLEANUP_EXPIRED_ENABLED);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_CLEANUP_EXPIRED_DISABLED);
    }

    if( dwValue & DNS_FLAG_UPDATE_DOWNLEVEL )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_UPDATE_BOTH_ENABLED);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_UPDATE_BOTH_DISABLED);
    }
    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);
    
    DisplayMessage(g_hModule,
                   EMSG_DHCP_ERROR_SUCCESS);

CommonReturn:

    if( OptionValue )
    {
        DhcpRpcFreeMemory(OptionValue);
        OptionValue = NULL;
    }

    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SHOW_DNSCONFIG,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrShowDetectconflictretry(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                           Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4    ConfigInfo = NULL;
    
    Error = DhcpServerGetConfigV4(g_ServerIpAddressUnicodeString,
                                  &ConfigInfo);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule,
                   MSG_SRVR_PING_RETRY,
                   ConfigInfo->dwPingRetries);

    DisplayMessage(g_hModule,
                   EMSG_DHCP_ERROR_SUCCESS);

CommonReturn:
    if( ConfigInfo )
    {
        DhcpRpcFreeMemory(ConfigInfo);
        ConfigInfo = NULL;
    }
    return Error;

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SHOW_DETECTCONFLICTRETRY,
                        Error);
    goto CommonReturn;
}

VOID
PrintClassInfo(                                   // print info on a single class
    LPDHCP_CLASS_INFO      Class
)
{
    DWORD   i;

    if( Class->IsVendor )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_CLASS_INFO_VENDOR,
                       Class->ClassName, 
                       Class->ClassComment, 
                       Class->Flags);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_CLASS_INFO,
                       Class->ClassName, 
                       Class->ClassComment, 
                       Class->Flags);
    }

    DisplayMessage(g_hModule, MSG_SRVR_CLASS_DATA);
    for( i = 0; i < Class->ClassDataLength; i ++ )
        DisplayMessage(g_hModule, 
                       MSG_SRVR_CLASS_DATA_FORMAT, 
                       Class->ClassData[i]);
    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
}

VOID
PrintClassInfoArray(                              // print array of classes
    LPDHCP_CLASS_INFO_ARRAY Classes
)
{
    DWORD   i;

    DisplayMessage(g_hModule,
                   MSG_SRVR_CLASS_INFO_ARRAY, 
                   Classes->NumElements);

    for( i = 0; i < Classes->NumElements; i ++ )
        PrintClassInfo(&Classes->Classes[i]);
}


DWORD
_CreateOption(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      DHCP_OPTION           *OptionInfo
)
{
    DWORD                          MajorVersion, MinorVersion;
    DWORD                          Error;

#ifdef NT5
    if( g_dwMajorVersion >= CLASS_ID_VERSION ) 
    {

        return DhcpCreateOptionV5(
            ServerAddress,
            0,
            OptionId,
            ClassName,
            VendorName,
            OptionInfo
        );
    }

    // incorrect version, just do like before..
#endif

    return DhcpCreateOption(
        ServerAddress,
        OptionId,
        OptionInfo
    );

}


DWORD
SetOptionDataType(
    DHCP_OPTION_DATA_TYPE  OptionType,
    LPTSTR OptionValueString,
    LPDHCP_OPTION_DATA_ELEMENT OptionData,
    LPWSTR *UnicodeOptionValueString
)
{
    DWORD                 OptionValue;

    OptionData->OptionType = OptionType;
    
    if( OptionValueString is NULL )
    {
        return NO_ERROR;
    }

    if( DhcpStringDataOption != OptionType && 0 == wcslen(OptionValueString) ) {
        return NO_ERROR;
    }

    switch( OptionType ) 
    {
    case DhcpByteOption:
        {

            if( IsPureHex( OptionValueString ) is FALSE )
            {
                return ERROR_INVALID_PARAMETER;
            }

            OptionValue = (BYTE)STRTOUL( OptionValueString, NULL, 16 );

            if( OptionValue > 0xFF ) 
            {
                DisplayMessage(g_hModule,
                               EMSG_SRVR_VALUE_OUT_OF_RANGE);

                return( ERROR_INVALID_PARAMETER );
            }

            OptionData->Element.ByteOption = (BYTE)OptionValue;
            break;
        }
    case DhcpWordOption:
        if( FALSE is IsPureNumeric( OptionValueString ) )
        {
            return ERROR_INVALID_PARAMETER;
        }
        OptionValue = (WORD)STRTOUL( OptionValueString, NULL, 10 );

        if( OptionValue > 0xFFFF ) 
        {
            DisplayMessage(g_hModule,
                           EMSG_SRVR_VALUE_OUT_OF_RANGE);

            return( ERROR_INVALID_PARAMETER );
        }

        OptionData->Element.WordOption = (WORD)OptionValue;
        break;

    case DhcpDWordOption:

        if( FALSE is IsPureNumeric(OptionValueString) )
        {
            return ERROR_INVALID_PARAMETER;
        }

        OptionValue = STRTOUL( OptionValueString, NULL, 10 );
        OptionData->Element.DWordOption = (DWORD)OptionValue;
        break;

    case DhcpDWordDWordOption: {
        ULONG  Length;
        ULARGE_INTEGER value;

        Length = wcslen( OptionValueString );

        // Length cannot be greater than 16 hex digits 
        if ( Length > 16 ) {
            return ERROR_INVALID_PARAMETER;
        }

        if ( !IsPureHex( OptionValueString )) {
            return ERROR_INVALID_PARAMETER;
        }

        value.QuadPart = 0;
        if ( EOF == swscanf( OptionValueString, L"%I64x", &value.QuadPart )) {
            value.QuadPart = 0;
        }
        OptionData->Element.DWordDWordOption.DWord1 = value.HighPart;
        OptionData->Element.DWordDWordOption.DWord2 = value.LowPart;

        break;
    } // DhcpDWordDWordOption

    case DhcpIpAddressOption:
        OptionData->Element.IpAddressOption =
            StringToIpAddress(OptionValueString);
        break;

    case DhcpStringDataOption:
        {
#ifdef UNICODE
            *UnicodeOptionValueString = OptionValueString;
#else
            *UnicodeOptionValueString =
                DhcpOemToUnicode( OptionValueString, NULL );
#endif //UNICODE
            if( UnicodeOptionValueString == NULL ) 
            {
                return( ERROR_NOT_ENOUGH_MEMORY );
            }
        OptionData->Element.StringDataOption = *UnicodeOptionValueString;
        break;
        }


    case DhcpBinaryDataOption:
    case DhcpEncapsulatedDataOption:
        {
            PUCHAR Bytes;
            ULONG Length, i;        

            Length = (wcslen(OptionValueString))/2;
            if( Length * 2 != wcslen(OptionValueString) ) {
                return ERROR_INVALID_PARAMETER;
            }

            for( i = 0; i < Length * 2 ; i ++ ) {
                 if( !iswxdigit(OptionValueString[i]) ) {
                      return ERROR_INVALID_PARAMETER;
                 }
            }

            Bytes = DhcpAllocateMemory(Length);
            if( NULL == Bytes ) {
                  return ERROR_NOT_ENOUGH_MEMORY;
            }
            (*UnicodeOptionValueString) = (LPWSTR)(Bytes);
            OptionData->Element.BinaryDataOption.DataLength = Length;
            OptionData->Element.BinaryDataOption.Data = Bytes;

            while( Length -- ) {
                WCHAR OneByte[3] = {0, 0, 0 };

                OneByte[0] = OptionValueString[0];
                OneByte[1] = OptionValueString[1];
                OptionValueString += 2;

                *Bytes++ = (BYTE)(STRTOUL(OneByte, NULL, 16));
            }
            break;
        }
    default:
        {
            DhcpAssert(FALSE);
            
            DisplayMessage(g_hModule,
                           EMSG_SRVR_UNKNOWN_OPTION_TYPE);

            DisplayMessage(g_hModule,
                           HLP_SRVR_ADD_OPTIONDEF);

            return( ERROR_INVALID_PARAMETER );
        }
    }

    return( ERROR_SUCCESS );
}

DWORD
_EnumOptions(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_ARRAY   *Options,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
)
{

#ifdef NT5
 

    if( g_dwMajorVersion >= CLASS_ID_VERSION ) 
    {

        return DhcpEnumOptionsV5(
            ServerAddress,
            0,
            ClassName,
            VendorName,
            ResumeHandle,
            PreferredMaximum,
            Options,
            OptionsRead,
            OptionsTotal
        );
    }

    // incorrect version, just do like before..
#endif

    return DhcpEnumOptions(
        ServerAddress,
        ResumeHandle,
        PreferredMaximum,
        Options,
        OptionsRead,
        OptionsTotal
    );

}


VOID
PrintOptionInfo(
    IN LPDHCP_OPTION OptionInfo
)
{
    #define OPTION_ID_LEN         14
    #define OPTION_ARRAY_TYPE_LEN 14
    #define OPTION_TYPE_LEN       20
    #define BUFFER_LEN            20
    #define OPTION_NAME_LEN       50

    WCHAR  wcOptionID[ OPTION_ID_LEN ];
    LPWSTR pArrayType = NULL;
    WCHAR  wcOptionType[ OPTION_TYPE_LEN ];
    WCHAR  Buffer[ BUFFER_LEN ];
    WCHAR  wcOptionName[  OPTION_NAME_LEN ];

    DWORD  dwLen = 0, dw = 0;
    
    if( OptionInfo is NULL )
        return;

    wsprintf( wcOptionID, L"   %s   ", _itow((int)OptionInfo->OptionID, Buffer, 10) );
    
    dwLen = wcslen(wcOptionID);
    
    for(dw = dwLen; dw < OPTION_ID_LEN ; dw++ )
    {
        wcOptionID[dw] = L' ';
    }
    wcOptionID[ OPTION_ID_LEN - 1 ] = L'\0';

    wcscpy(wcOptionName, L" ");

    wcsncat(wcOptionName, 
            OptionInfo->OptionName, 
            (( OPTION_NAME_LEN - 1 ) < wcslen(OptionInfo->OptionName) ) ?
            ( OPTION_NAME_LEN - 1 ) : wcslen(OptionInfo->OptionName));
    
    dwLen = wcslen(wcOptionName);
    
    if ( dwLen < OPTION_NAME_LEN ) {
        for(dw = dwLen; dw < OPTION_NAME_LEN ; dw++ ) {
                wcOptionName[dw] = L' ';
        }
    }
    wcOptionName[ OPTION_NAME_LEN - 1 ] = L'\0';

    if( OptionInfo->OptionType is DhcpUnaryElementTypeOption )
    {
        pArrayType = L"    UNARY    ";
    }
    else if( OptionInfo->OptionType is DhcpArrayTypeOption )
    {
        pArrayType = L"    ARRAY    ";
    }
    else
    {
        pArrayType = L"    UNKNOWN  ";
    }

    wcOptionType[ OPTION_TYPE_LEN - 1 ] = L'\0';

    if( OptionInfo->DefaultValue.NumElements ) {
        dw = OptionInfo->DefaultValue.Elements[ 0 ].OptionType;
        wsprintf( wcOptionType, L"  %s", TagOptionType[ dw ].pwcTag );
    }

    DisplayMessage(g_hModule, 
                   MSG_SRVR_OPTIONDEF_INFO,
                   wcOptionID,
                   wcOptionName,
                   pArrayType,
                   wcOptionType);

} // PrintOptionInfo()

VOID
PrintOptionValue(
    IN LPDHCP_OPTION_DATA OptionValue
)
{
    DWORD NumElements;
    DHCP_OPTION_DATA_TYPE OptionType;
    DWORD i;

    if( OptionValue is NULL )
        return;

    DisplayMessage(g_hModule, MSG_SRVR_OPTION);
    NumElements = OptionValue->NumElements;

    DisplayMessage(g_hModule, 
                   MSG_SRVR_OPTION_COUNT, 
                   NumElements );

    if( NumElements == 0 ) {
        return;
    }

    OptionType = OptionValue->Elements[0].OptionType;

    DisplayMessage( g_hModule, MSG_SRVR_OPTION_TYPE,
                    TagOptionType[ OptionType ].pwcTag );

    if( OptionType is DhcpBinaryDataOption )
    {
        DisplayMessage(g_hModule, MSG_SRVR_OPTION_TYPE, L"BINARY");
    }

    for( i = 0; i < OptionValue->NumElements; i++ ) 
    {
        DhcpAssert( OptionType == OptionValue->Elements[i].OptionType );

        DisplayMessage(g_hModule, 
                       MSG_SRVR_OPTION_VALUE);

        switch( OptionType ) {
        case DhcpByteOption:
            DisplayMessage(g_hModule, 
                           MSG_SRVR_OPTION_VALUE_NUM, 
                           (DWORD)OptionValue->Elements[i].Element.ByteOption );
            break;

        case DhcpWordOption:
            DisplayMessage(g_hModule, 
                           MSG_SRVR_OPTION_VALUE_NUM, 
                           (DWORD)OptionValue->Elements[i].Element.WordOption );
            break;

        case DhcpDWordOption:
            DisplayMessage(g_hModule, 
                           MSG_SRVR_OPTION_VALUE_NUM,
                           OptionValue->Elements[i].Element.DWordOption );
            break;

        case DhcpDWordDWordOption:
            DisplayMessage(g_hModule, 
                           MSG_SRVR_OPTION_VALUE_LONGNUM,
                           OptionValue->Elements[i].Element.DWordDWordOption.DWord1,
                           OptionValue->Elements[i].Element.DWordDWordOption.DWord2 );

            break;

        case DhcpIpAddressOption:
            DisplayMessage(g_hModule, 
                           MSG_SRVR_OPTION_VALUE_STRING,
                           IpAddressToString((DWORD)OptionValue->Elements[i].Element.IpAddressOption));
            break;

        case DhcpStringDataOption:
            if( *OptionValue->Elements[i].Element.StringDataOption ) {
                DisplayMessage(g_hModule, 
                               MSG_SRVR_OPTION_VALUE_STRING,
                               OptionValue->Elements[i].Element.StringDataOption );
            }
            
            break;

        case DhcpBinaryDataOption:
        case DhcpEncapsulatedDataOption: 
            {
                DWORD j;
                DWORD Length;

                Length = OptionValue->Elements[i].Element.BinaryDataOption.DataLength;
                for( j = 0; j < Length; j++ ) {
                    DisplayMessage(g_hModule, 
                                   MSG_SRVR_OPTION_VALUE_BINARY,
                                   OptionValue->Elements[i].Element.BinaryDataOption.Data[j] );
                }
                DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
                break;
            }
        default:
            DisplayMessage(g_hModule, MSG_SRVR_OPTION_TYPE_UNKNOWN);
            break;
        }
    }
}

DWORD
PrintAllOptionValues(
    IN LPDHCP_ALL_OPTION_VALUES OptValues
)
{
    DWORD    i, dwCount = 0;
    BOOL     fUser = FALSE,
             fVendor = FALSE;
    for( i = 0; i < OptValues->NumElements ; i ++ ) 
    {

        if( OptValues->Options[i].OptionsArray is NULL )
        {
            continue;
        }
        if( OptValues->Options[i].IsVendor ) 
        {
            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
            DisplayMessage(g_hModule, MSG_SRVR_CLASS_VENDOR, CHKNULL(OptValues->Options[i].VendorName));
            fVendor = TRUE;
        }
        if( OptValues->Options[i].ClassName ) 
        {
            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
            DisplayMessage(g_hModule, MSG_SRVR_CLASS_USER, OptValues->Options[i].ClassName);
            fUser = TRUE;
        }
        else if ( fVendor is FALSE )
        {
            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
            DisplayMessage(g_hModule, MSG_SRVR_STANDARD_OPTION);
        }

        if( fUser is FALSE and
            fVendor is FALSE )
        {
            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
            DisplayMessage(g_hModule, MSG_SRVR_CLASS_NONE);
        }
        PrintOptionValuesArray(OptValues->Options[i].OptionsArray);
        dwCount++;
    }
    return dwCount;
}


DWORD
PrintUserOptionValues(
    IN LPDHCP_ALL_OPTION_VALUES OptValues,
    IN LPWSTR                   pwcUser,
    IN LPWSTR                   pwcVendor
)
{
    DWORD    i,
             dwCount = 0;
    BOOL     fUser = FALSE,
             fVendor = FALSE;

    for( i = 0; i < OptValues->NumElements; i++ ) 
    {
        if( OptValues->Options[i].OptionsArray is NULL )
        {
            continue;
        }
        if( pwcVendor is NULL )
        {
            if( OptValues->Options[i].ClassName isnot NULL and
                ( _wcsicmp(OptValues->Options[i].ClassName, pwcUser) is 0 ) and
                OptValues->Options[i].IsVendor is FALSE )
            {
           
                DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
                if( fUser is FALSE )
                {
                    DisplayMessage(g_hModule, MSG_SRVR_STANDARD_OPTION);
                    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
                    DisplayMessage(g_hModule, MSG_SRVR_CLASS_USER, OptValues->Options[i].ClassName);
                    fUser = TRUE;
                }
                PrintOptionValuesArray(OptValues->Options[i].OptionsArray);
                dwCount+=OptValues->Options[i].OptionsArray->NumElements;
            }
        }
        else
        {
            if( pwcUser )
            {
                if( OptValues->Options[i].ClassName and
                    ( _wcsicmp(OptValues->Options[i].ClassName, pwcUser) is 0 ) and
                    OptValues->Options[i].VendorName isnot NULL and
                    ( _wcsicmp(OptValues->Options[i].VendorName, pwcVendor) is 0 )and
                    OptValues->Options[i].IsVendor is TRUE )
                {

                    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
                    if( fUser is FALSE )
                    {
                        DisplayMessage(g_hModule, MSG_SRVR_CLASS_VENDOR, CHKNULL(OptValues->Options[i].VendorName));
                        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
                        DisplayMessage(g_hModule, MSG_SRVR_CLASS_USER, OptValues->Options[i].ClassName);
                        fUser = TRUE;
                    }
                    PrintOptionValuesArray(OptValues->Options[i].OptionsArray);
                    dwCount+=OptValues->Options[i].OptionsArray->NumElements;
                }
            }
            else
            {
                if( OptValues->Options[i].VendorName isnot NULL and
                    ( _wcsicmp(OptValues->Options[i].VendorName, pwcVendor) is 0 ) and
                    OptValues->Options[i].IsVendor is TRUE )
                {
                    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
                    if( fUser is FALSE )
                    {
                        DisplayMessage(g_hModule, MSG_SRVR_CLASS_VENDOR, CHKNULL(OptValues->Options[i].VendorName));
                        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
                        fUser = TRUE;
                    }
                    if( OptValues->Options[i].ClassName )
                    {
                        DisplayMessage(g_hModule, MSG_SRVR_CLASS_USER, OptValues->Options[i].ClassName);
                    }
                    PrintOptionValuesArray(OptValues->Options[i].OptionsArray);
                    dwCount+=OptValues->Options[i].OptionsArray->NumElements;
                }
            }
        }
    }

    return dwCount;
                   
}

VOID
PrintOptionArray(
    IN LPDHCP_OPTION_ARRAY    OptArray
)
{
    DWORD    i;

    if( OptArray is NULL )
        return;

    for( i = 0; i < OptArray->NumElements ; i ++ ) {
        PrintOptionInfo( &OptArray->Options[i] );
    }
}

VOID
PrintAllOptions(
    IN      LPDHCP_ALL_OPTIONS     Options
)
{
    DWORD                          i =0;

    if( Options is NULL )
        return;

    DisplayMessage(g_hModule, MSG_SRVR_OPTION_NONVENDOR);
    DisplayMessage(g_hModule, MSG_SRVR_OPTIONDEF_TABLE);



    PrintOptionArray(Options->NonVendorOptions);

    for( i = 0; i < Options->NumVendorOptions; i ++ ) 
    {
        if( i>0 )
        {
            if( wcscmp(CHKNULL(Options->VendorOptions[i-1].VendorName), CHKNULL(Options->VendorOptions[i].VendorName)) )
            {
                DisplayMessage(g_hModule, MSG_SRVR_OPTION_VENDOR, CHKNULL(Options->VendorOptions[i].VendorName));
                DisplayMessage(g_hModule, MSG_SRVR_OPTIONDEF_TABLE);
            }
        }
        else
        {
            DisplayMessage(g_hModule, MSG_SRVR_OPTION_VENDOR, CHKNULL(Options->VendorOptions[i].VendorName));
            DisplayMessage(g_hModule, MSG_SRVR_OPTIONDEF_TABLE);
        }
        PrintOptionInfo(&(Options->VendorOptions[i].Option));
    }

}



VOID
PrintOptionValue1(
    IN LPDHCP_OPTION_VALUE    OptVal
)
{
    if( OptVal is NULL )
        return;
    DisplayMessage(g_hModule, MSG_SRVR_OPTION_ID, OptVal->OptionID);

    PrintOptionValue(&OptVal->Value);
}

VOID
PrintOptionValuesArray(
    IN LPDHCP_OPTION_VALUE_ARRAY OptValArray
)
{
    DWORD    i;

    if( NULL == OptValArray ) 
        return;
    for( i = 0; i < OptValArray->NumElements ; i ++ ) {
        PrintOptionValue1( &OptValArray->Values[i] );
    }
}

DWORD
SetOptionValue(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
)
{
       
#ifdef NT5

    if( g_dwMajorVersion >= CLASS_ID_VERSION ) 
    {

        return DhcpSetOptionValueV5(
            ServerAddress,
            Flags,
            OptionId,
            ClassName,
            VendorName,
            ScopeInfo,
            OptionValue
        );
    }

#endif

    return DhcpSetOptionValue(
        ServerAddress,
        OptionId,
        ScopeInfo,
        OptionValue
    );
    
}

VOID
PrintDhcpAttrib(                                  // print a server attrib
    LPDHCP_ATTRIB ServerAttrib
)
{
    LPWSTR      pwszAttrib = NULL;
    BOOL        AttribBool = ServerAttrib->DhcpAttribBool;

    if( NULL == ServerAttrib ) 
        return;

    switch(ServerAttrib->DhcpAttribId )
    {
    case DHCP_ATTRIB_BOOL_IS_ROGUE:
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_SERVER_ATTRIB_ISROUGE);
            AttribBool = !AttribBool;
            break;
        }
    case DHCP_ATTRIB_BOOL_IS_DYNBOOTP:
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_SERVER_ATTRIB_ISDYNBOOTP);
            break;
        }
    case DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC:
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_SERVER_ATTRIB_ISPARTDSDC);
            break;
        }
    case DHCP_ATTRIB_BOOL_IS_BINDING_AWARE:
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_SERVER_ATTRIB_ISBINDING);
            break;
        }
    case DHCP_ATTRIB_BOOL_IS_ADMIN:
    default:
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_SERVER_ATTRIB_ISADMIN);
            break;
        }
    }

    switch( ServerAttrib->DhcpAttribType ) 
    {
    case DHCP_ATTRIB_TYPE_BOOL :
        if( AttribBool )
        {
            DisplayMessage(g_hModule, MSG_SRVR_TRUE);
        }
        else
        {
            DisplayMessage(g_hModule, 
                           MSG_SRVR_FALSE);
        }
        break;
    case DHCP_ATTRIB_TYPE_ULONG:
        DisplayMessage(g_hModule, MSG_SRVR_SERVER_ATTRIB_TYPE_ULONG, ServerAttrib->DhcpAttribUlong);
        break;
    default:
        DisplayMessage(g_hModule, EMSG_SRVR_UNKNOWN_SERVER_ATTRIB);
        break;
    }
}


DWORD
SetOptionDataTypeArray(
    DHCP_OPTION_DATA_TYPE OptionType,
    LPTSTR                *OptionValues,
    DWORD                 dwStartCount, //first optionvalue = dwStartCount 
    DWORD                 dwEndCount, //last optionvalue = dwEndCount - 1
    LPDHCP_OPTION_DATA  pOptionData
)
{
    LPDHCP_OPTION_DATA_ELEMENT  lpElemArray = NULL;
    DWORD                       i = 0, dwCount=0;
    
    if( pOptionData is NULL )
        return ERROR_INVALID_PARAMETER;

    while(( dwStartCount + i < dwEndCount ) and
          ( FALSE is IsBadStringPtr(OptionValues[dwStartCount+i], MAX_STRING_LEN))) 
    {
        if( wcslen(OptionValues[dwStartCount+i]) is 0 )
            break;
        i++;
    }

    pOptionData->NumElements = i;

    pOptionData->Elements = DhcpAllocateMemory(pOptionData->NumElements*sizeof(DHCP_OPTION_DATA_ELEMENT));

    if( pOptionData->Elements is NULL )
        return ERROR_OUT_OF_MEMORY;

      
    switch(OptionType)
    {
    case DhcpByteOption:
        {
            for( i = 0; i < pOptionData->NumElements; i++ )
            {
                if( IsPureHex(OptionValues[dwStartCount+i]) is FALSE )
                {
                    return ERROR_INVALID_PARAMETER;
                }
                pOptionData->Elements[i].OptionType = OptionType;
                pOptionData->Elements[i].Element.ByteOption = (BYTE)STRTOUL(OptionValues[dwStartCount+i], NULL, 16);
            }
            break;
        }
    case DhcpWordOption:
        {
            for( i = 0; i < pOptionData->NumElements; i++ )
            {
                pOptionData->Elements[i].OptionType = OptionType;
                if( FALSE is IsPureNumeric(OptionValues[dwStartCount+i]) )
                {
                    return ERROR_INVALID_PARAMETER;
                }
                pOptionData->Elements[i].Element.WordOption = (WORD)STRTOUL(OptionValues[dwStartCount+i], NULL, 10);
            }
            break;
        }
    case DhcpDWordOption:
        {
            for( i = 0; i < pOptionData->NumElements; i++ )
            {
                pOptionData->Elements[i].OptionType = OptionType;

                if( FALSE is IsPureNumeric(OptionValues[dwStartCount+i]) )
                {
                    return ERROR_INVALID_PARAMETER;
                }

                pOptionData->Elements[i].Element.DWordOption = (DWORD)STRTOUL(OptionValues[dwStartCount+i], NULL, 10);
            }
            break;
        }

    case DhcpDWordDWordOption: {
        ULARGE_INTEGER value;
        ULONG          Length;

        for ( i = 0; i < pOptionData->NumElements; i++ ) {
            Length = wcslen( OptionValues[ dwStartCount + i ]);

            // Length cannot be greater than 16 hex digits 
            if ( Length > 16 ) {
                return ERROR_INVALID_PARAMETER;
            }

            if ( !IsPureHex( OptionValues[ dwStartCount + i ])) {
                return ERROR_INVALID_PARAMETER;
            }


            value.QuadPart = 0;
            if ( EOF == swscanf( OptionValues[ dwStartCount + i ], L"%I64x", 
                                 &value.QuadPart )) {
                value.QuadPart = 0;
            }
            pOptionData->Elements[ i ].OptionType = OptionType;
            pOptionData->Elements[ i ].Element.DWordDWordOption.DWord1 = value.HighPart;
            pOptionData->Elements[ i ].Element.DWordDWordOption.DWord2 = value.LowPart;
        } // for
        break;
    }
    case DhcpStringDataOption:
        {
            for( i = 0; i < pOptionData->NumElements; i++ )
            {
                pOptionData->Elements[i].OptionType = OptionType;
                pOptionData->Elements[i].Element.StringDataOption = OptionValues[dwStartCount+i];
            }
            break;
        }
    case DhcpIpAddressOption:
        {
            DWORD   dwIp = 0;
            for( i = 0; i < pOptionData->NumElements; i++ )
            {
                pOptionData->Elements[i].OptionType = OptionType;
                dwIp = StringToIpAddress(OptionValues[dwStartCount+i]);
                if( dwIp is INADDR_NONE )
                {
                    return ERROR_INVALID_PARAMETER;
                }

                pOptionData->Elements[i].Element.IpAddressOption = StringToIpAddress(OptionValues[dwStartCount+i]);
            }
            break;
        }
    default:
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    return NO_ERROR;

}



DWORD
ShowOptionValues4(
    IN      LPWSTR                      pwszIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO    ScopeInfo,
    IN      LPDWORD                     pdwCount
)
{
    DWORD                       Error = NO_ERROR;
    LPDHCP_OPTION_ARRAY         OptionsArray = NULL;
    LPDHCP_ALL_OPTION_VALUES    OptionValues = NULL;
    LPDHCP_OPTION_VALUE         OptionValue = NULL;
    DHCP_RESUME_HANDLE          ResumeHandle = 0;
    DWORD                       nRead = 0,
                                dwCount = 0,
                                nTotal = 0,
                                dw = 0;

    *pdwCount = 0;

    while(TRUE)
    {
         Error = DhcpEnumOptions(
                        pwszIpAddress,
                        &ResumeHandle,
                        ~0,
                        &OptionsArray,
                        &nRead,
                        &nTotal);
    
        if( Error is ERROR_NO_MORE_ITEMS )
        {
            Error = NO_ERROR;
            break;
        }

        if( Error isnot NO_ERROR  &&
            Error isnot ERROR_MORE_DATA )
            goto Return;

        for( dw = 0; dw < nRead; dw++ )
        {
            DHCP_OPTION_ID OptionId = OptionsArray->Options[dw].OptionID;
            DWORD          dwError = NO_ERROR;
            dwError = DhcpGetOptionValue(
                                         pwszIpAddress,
                                         OptionId,
                                         ScopeInfo,
                                         &OptionValue);
                           
            if( dwError isnot NO_ERROR )
            {
                continue;
            }
    
            if( OptionValue )
            {
                PrintOptionValue1(OptionValue);
                dwCount++;
                DhcpRpcFreeMemory(OptionValue);
                OptionValue = NULL;
            }
        }

        if( OptionsArray )
        {
            DhcpRpcFreeMemory(OptionsArray);
            OptionsArray = NULL;
        }

        if( Error is NO_ERROR )
            break;
        else
            continue;
    }
Return:
    *pdwCount = dwCount;
    return Error;
}


//
// Need to support these routines for displaying error messages ..
//

VOID
DhcpEximErrorClassConflicts(
    IN LPWSTR SvcClass,
    IN LPWSTR ConfigClass
    )
{
    DisplayMessage(
        g_hModule,
        MSG_SRVR_IMPORT_CLASS_CONFLICT,
        SvcClass, ConfigClass );
}        

VOID
DhcpEximErrorOptdefConflicts(
    IN LPWSTR SvcOptdef,
    IN LPWSTR ConfigOptdef
    )
{
    DisplayMessage(
        g_hModule,
        MSG_SRVR_IMPORT_OPTDEF_CONFLICT,
        SvcOptdef, ConfigOptdef );
}        

VOID
DhcpEximErrorOptionConflits(
    IN LPWSTR SubnetName OPTIONAL,
    IN LPWSTR ResAddress OPTIONAL,
    IN LPWSTR OptId,
    IN LPWSTR UserClass OPTIONAL,
    IN LPWSTR VendorClass OPTIONAL
    )
{
    DWORD MsgId;
    
    if( NULL == SubnetName ) {
        MsgId = MSG_SRVR_IMPORT_OPTION_CONFLICT;
    } else if( NULL == ResAddress ) {
        MsgId = MSG_SRVR_IMPORT_SUBNET_OPTION_CONFLICT;
    } else {
        MsgId = MSG_SRVR_IMPORT_RES_OPTION_CONFLICT;
    }

    if( NULL == UserClass ) UserClass = L"";
    if( NULL == VendorClass ) VendorClass = L"";
    
    DisplayMessage(
        g_hModule,
        MsgId, OptId, UserClass, VendorClass, SubnetName,
        ResAddress );
}        

VOID
DhcpEximErrorSubnetNotFound(
    IN LPWSTR SubnetAddress
    )
{
    DisplayMessage(
        g_hModule,
        MSG_SRVR_EXPORT_SUBNET_NOT_FOUND, SubnetAddress );
}        

VOID
DhcpEximErrorSubnetAlreadyPresent(
    IN LPWSTR SubnetAddress,
    IN LPWSTR SubnetName OPTIONAL
    )
{
    if( NULL == SubnetName ) SubnetName = L"";
    DisplayMessage(
        g_hModule,
        MSG_SRVR_IMPORT_SUBNET_CONFLICT,
        SubnetAddress, SubnetName );
}        

VOID
DhcpEximErrorDatabaseEntryFailed(
    IN LPWSTR ClientAddress,
    IN LPWSTR ClientHwAddress,
    IN DWORD Error,
    OUT BOOL *fAbort
    )
{
    WCHAR ErrStr[30];

    wsprintf(ErrStr, L"%ld", Error );

    (*fAbort) = FALSE; // continue on errors
    DisplayMessage(
        g_hModule,
        MSG_SRVR_IMPORT_DBENTRY_CONFLICT,
        ClientAddress, ClientHwAddress, ErrStr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\dhcp\scopemon.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\dhcp\dhcpmon.c

Abstract:

    SRVR Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 11/14/98

--*/
#include "precomp.h"

//
// The DHCP manager's commands are broken into 2 sets
//      - The commands are split into "command groups"
//        i.e, commands grouped by the VERB where the VERB is ADD, DELETE,
//        SHOW or SET.  This is not for any technical reason - only for
//        staying with the semantics used in netsh with which it will be 
//		  integrated
//      - The commands which are supported by the subcontext commands of 
//        the server. The subcontext supported by DHCP is Server.
//
// A command is described using a CMD_ENTRY structure. It requires the
// command token, the handler, a short help message token and an extended 
// help message token.  To make it easier to create we use the 
// CREATE_CMD_ENTRY macro. This, however puts restrictions on how the tokens
// are named.
//
// The command groups are simply arrays of the CMD_ENTRY structure.  The 
// top level commands are also grouped in a similar array.
//
// The info about a complete command group is put in a CMD_GROUP_ENTRY
// structure, all of which are put in an array.
//
 

//
// NOTE: Since we have only one entry per group, currently, we really didnt
// need command groups. This is done for later extensibility.
// To add a command entry to a group, simply add the command to the appropriate
// array
// To add a command group - create and array and add its info to the
// command group array
//


extern HANDLE   g_hModule;
extern HANDLE   g_hParentModule;
extern HANDLE   g_hDhcpsapiModule;
extern BOOL     g_bCommit;
extern BOOL     g_hConnect;

extern BOOL     g_fMScope;
extern DWORD    g_dwNumTableEntries;
extern PWCHAR   g_pwszRouter;
extern PWCHAR   g_pwszServer;
extern WCHAR    g_ServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1];
extern CHAR     g_ServerIpAddressAnsiString[MAX_IP_STRING_LEN+1];
CHAR     g_ScopeIpAddressAnsiString[MAX_IP_STRING_LEN+1];
WCHAR    g_ScopeIpAddressUnicodeString[MAX_IP_STRING_LEN+1];
DHCP_IP_ADDRESS g_ScopeIpAddress = 0;
BOOL     g_fScope;

extern LPWSTR   g_pwszServer;
extern DHCP_IP_ADDRESS g_ServerIpAddress;


ULONG   g_ulScopeInitCount = 0;

CMD_ENTRY  g_ScopeAddCmdTable[] = {
    CREATE_CMD_ENTRY(SCOPE_ADD_EXCLUDERANGE, HandleScopeAddExcluderange),
    CREATE_CMD_ENTRY(SCOPE_ADD_IPRANGE, HandleScopeAddIprange),
    CREATE_CMD_ENTRY(SCOPE_ADD_RESERVEDIP, HandleScopeAddReservedip),
};

CMD_ENTRY  g_ScopeCheckCmdTable[] = {
    CREATE_CMD_ENTRY(SCOPE_CHECK_DATABASE, HandleScopeCheckDatabase),
};

CMD_ENTRY  g_ScopeDeleteCmdTable[] = {
    CREATE_CMD_ENTRY(SCOPE_DELETE_EXCLUDERANGE, HandleScopeDeleteExcluderange),
    CREATE_CMD_ENTRY(SCOPE_DELETE_IPRANGE, HandleScopeDeleteIprange),
    CREATE_CMD_ENTRY(SCOPE_DELETE_OPTIONVALUE, HandleScopeDeleteOptionvalue),
    CREATE_CMD_ENTRY(SCOPE_DELETE_RESERVEDIP, HandleScopeDeleteReservedip),
    CREATE_CMD_ENTRY(SCOPE_DELETE_RESERVEDOPTIONVALUE, HandleScopeDeleteReservedoptionvalue),
    CREATE_CMD_ENTRY(SCOPE_DELETE_CLIENT, HandleScopeDeleteClient),
};


CMD_ENTRY g_ScopeSetCmdTable[] = {
    CREATE_CMD_ENTRY(SCOPE_SET_COMMENT, HandleScopeSetComment),
    CREATE_CMD_ENTRY(SCOPE_SET_NAME, HandleScopeSetName),
    CREATE_CMD_ENTRY(SCOPE_SET_OPTIONVALUE, HandleScopeSetOptionvalue),
    CREATE_CMD_ENTRY(SCOPE_SET_RESERVEDOPTIONVALUE, HandleScopeSetReservedoptionvalue),
    CREATE_CMD_ENTRY(SCOPE_SET_SCOPE, HandleScopeSetScope),
    CREATE_CMD_ENTRY(SCOPE_SET_STATE, HandleScopeSetState),
    CREATE_CMD_ENTRY(SCOPE_SET_SUPERSCOPE, HandleScopeSetSuperscope),
};

CMD_ENTRY g_ScopeShowCmdTable[] = {
    CREATE_CMD_ENTRY(SCOPE_SHOW_CLIENTS, HandleScopeShowClients),
    CREATE_CMD_ENTRY(SCOPE_SHOW_CLIENTSV5, HandleScopeShowClientsv5),
    CREATE_CMD_ENTRY(SCOPE_SHOW_EXCLUDERANGE, HandleScopeShowExcluderange),
    CREATE_CMD_ENTRY(SCOPE_SHOW_IPRANGE, HandleScopeShowIprange),
//    CREATE_CMD_ENTRY(SCOPE_SHOW_MIBINFO, HandleScopeShowMibinfo),
    CREATE_CMD_ENTRY(SCOPE_SHOW_OPTIONVALUE, HandleScopeShowOptionvalue),
    CREATE_CMD_ENTRY(SCOPE_SHOW_RESERVEDIP, HandleScopeShowReservedip),
    CREATE_CMD_ENTRY(SCOPE_SHOW_RESERVEDOPTIONVALUE, HandleScopeShowReservedoptionvalue),
    CREATE_CMD_ENTRY(SCOPE_SHOW_SCOPE, HandleScopeShowScope),
    CREATE_CMD_ENTRY(SCOPE_SHOW_STATE, HandleScopeShowState),
};


CMD_GROUP_ENTRY g_ScopeCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD, g_ScopeAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_ScopeDeleteCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_CHECK, g_ScopeCheckCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET, g_ScopeSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_ScopeShowCmdTable),
};


CMD_ENTRY g_ScopeCmds[] = 
{
    CREATE_CMD_ENTRY(DHCP_LIST, HandleScopeList),
    CREATE_CMD_ENTRY(SCOPE_DUMP, HandleScopeDump),
    CREATE_CMD_ENTRY(DHCP_HELP1, HandleScopeHelp),
    CREATE_CMD_ENTRY(DHCP_HELP2, HandleScopeHelp),
    CREATE_CMD_ENTRY(DHCP_HELP3, HandleScopeHelp),
    CREATE_CMD_ENTRY(DHCP_HELP4, HandleScopeHelp),
};



ULONG g_ulScopeNumTopCmds = sizeof(g_ScopeCmds)/sizeof(CMD_ENTRY);
ULONG g_ulScopeNumGroups = sizeof(g_ScopeCmdGroups)/sizeof(CMD_GROUP_ENTRY);

DWORD
WINAPI
ScopeCommit(
    IN  DWORD   dwAction
)
{
    BOOL    bCommit, bFlush = FALSE;

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. Srvr current state is commit, then
            // nothing to be done.
            //

            if(g_bCommit)
            {
                return NO_ERROR;
            }

            bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    return NO_ERROR;
}


DWORD
WINAPI
ScopeMonitor(
    IN      LPCWSTR     pwszMachine,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      DWORD       dwFlags,
    IN      LPCVOID     pvData,
    OUT     LPWSTR      pwcNewContext
    )
{
    DWORD           dwError = NO_ERROR;
    DWORD           dwIndex, i, j, k;
    DWORD           ScopeIndex = 0;
    BOOL            bFound = FALSE;
    PFN_HANDLE_CMD  pfnHandler = NULL;
    DWORD           dwNumMatched;
    DWORD           dwCmdHelpToken = 0;
    DWORD           dwIsScope = 0;
    PWCHAR          pwcContext = NULL;
    WCHAR           pwszScopeIP[MAX_IP_STRING_LEN+1] = {L'\0'};
    BOOL            fTemp = FALSE;
    if( dwArgCount < 2 )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_NO_SCOPENAME);
        return ERROR_INVALID_PARAMETER;
    }

    dwIndex = 1;

  
    //Is it Scope IpAddress?
    if( IsValidScope(g_ServerIpAddressUnicodeString, ppwcArguments[dwIndex]) )
    {
        if( g_fScope is TRUE and
            dwArgCount > 2 )
        {
            wcscpy(pwszScopeIP, g_ScopeIpAddressUnicodeString);
            fTemp = TRUE;
        }
        if( SetScopeInfo(ppwcArguments[dwIndex]) is FALSE )
        {
            DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_SCOPE_NAME);
            dwError = ERROR_INVALID_PARAMETER;
            goto CleanUp;
        }

        g_fScope = TRUE;
        pwcNewContext[wcslen(pwcNewContext) - wcslen(ppwcArguments[dwIndex]) - 1] = L'\0';
        dwIndex++;
        dwIsScope++;
	ScopeIndex = 1;

        if( fTemp is FALSE )
        {
            DisplayMessage(g_hModule,
                           MSG_SCOPE_CHANGE_CONTEXT,
                           g_ScopeIpAddressUnicodeString);
        }
    }

    if( wcslen(g_ScopeIpAddressUnicodeString) is 0 )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_NO_SCOPENAME);

        dwError = ERROR_INVALID_PARAMETER;
        goto CleanUp;
    }

    //No more arguments. Context switch.
    if( dwIndex >= dwArgCount )
    {
        dwError = ERROR_CONTEXT_SWITCH;
        //wcscpy( pwcNewContext, L"dhcp server scope");
        goto CleanUp;
    }

    //Is it a top level(non Group command)?

    for(i=0; i<g_ulScopeNumTopCmds; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_ScopeCmds[i].pwszCmdToken))
        {
            bFound = TRUE;

            pfnHandler = g_ScopeCmds[i].pfnCmdHandler;

            dwCmdHelpToken = g_ScopeCmds[i].dwCmdHlpToken;
            dwIndex++;
            break;
        }
    }


    if(bFound)
    {
        if ((( dwArgCount - ScopeIndex ) > 2 ) && 
	    ( IsHelpToken(ppwcArguments[ dwIndex ])))
        {
            DisplayMessage(g_hModule, dwCmdHelpToken);
            
            dwError = NO_ERROR;

            goto CleanUp;
        }
        
        dwIndex++;

        dwError = (*pfnHandler)(pwszMachine, ppwcArguments, dwIndex, dwArgCount,
                                dwFlags, pvData, &bFound);
        
        goto CleanUp;
    }

    if( g_fScope is FALSE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_NO_SCOPENAME);
        dwError = ERROR_INVALID_PARAMETER;
        goto CleanUp;
    }

    bFound = FALSE;


    //It is not a non Group Command. Then is it a config command for the manager?
    for(i = 0; (i < g_ulScopeNumGroups) and !bFound; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_ScopeCmdGroups[i].pwszCmdGroupToken))
        {

            //
            // Command matched entry i, so look at the table of sub commands 
            // for this command
            //
            
            if( dwArgCount > dwIndex+1 )
            {
                for (j = 0; j < g_ScopeCmdGroups[i].ulCmdGroupSize; j++)
                {
                    if (MatchCmdLine(ppwcArguments+dwIndex,
                                      dwArgCount - 1,
                                      g_ScopeCmdGroups[i].pCmdGroup[j].pwszCmdToken,
                                      &dwNumMatched))
                    {
                        bFound = TRUE;
                
                        pfnHandler = g_ScopeCmdGroups[i].pCmdGroup[j].pfnCmdHandler;
                
                        dwCmdHelpToken = g_ScopeCmdGroups[i].pCmdGroup[j].dwCmdHlpToken;

                        dwIndex++;
                        //
                        // break out of the for(j) loop
                        //
                        break;
                    }
                }

            }
            if(!bFound)
            {
                //
                // We matched the command group token but none of the
                // sub commands
                //

                DisplayMessage(g_hModule, 
                               EMSG_SCOPE_INCOMPLETE_COMMAND);

                for (j = 0; j < g_ScopeCmdGroups[i].ulCmdGroupSize; j++)
                {
                    DisplayMessage(g_hModule, 
                             g_ScopeCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);
                    
                    DisplayMessage(g_hModule,
                                   MSG_DHCP_FORMAT_LINE);
                }

                dwError = ERROR_INVALID_PARAMETER;
                goto CleanUp;
            }
            else
            {
                //
                // quit the for(i)
                //

                break;
            }
        }
    }

    if (!bFound)
    {
        //
        // Command not found. 
        //
        if( _wcsicmp(ppwcArguments[dwIndex], L"..") is 0 )
        {
            memset(g_ScopeIpAddressUnicodeString, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(WCHAR));
            memset(g_ScopeIpAddressAnsiString, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(CHAR));
            g_ScopeIpAddress = 0;
            g_fScope = FALSE;
        }

        dwError = ERROR_CMD_NOT_FOUND;
        goto CleanUp;
    }

    //
    // See if it is a request for help.
    //

    dwNumMatched += dwIsScope;

    if (dwNumMatched < (dwArgCount - 1) &&
        IsHelpToken(ppwcArguments[dwNumMatched + 1]))
    {
        DisplayMessage(g_hModule, dwCmdHelpToken);

        dwError = NO_ERROR;
        goto CleanUp;
    }
    
    //
    // Call the parsing routine for the command
    //

    dwError = (*pfnHandler)(pwszMachine, ppwcArguments+1, 
                            dwIndex, 
                            dwArgCount-1 - dwIndex, 
                            dwFlags, pvData, &bFound);

CleanUp:
    if( fTemp )
    {
        fTemp = SetScopeInfo(pwszScopeIP);
    }
    return dwError;
}



DWORD
WINAPI
ScopeUnInit(
    IN  DWORD   dwReserved
    )
{
    if(InterlockedDecrement(&g_ulInitCount) isnot 0)
    {
        return NO_ERROR;
    }

    return NO_ERROR;
}


BOOL
SetScopeInfo(
    IN  LPWSTR  pwszScope
)
{
    DWORD   dwError = NO_ERROR;
    DHCP_IP_ADDRESS IpAddress = StringToIpAddress(pwszScope);
    LPDHCP_SUBNET_INFO  SubnetInfo = NULL;
    LPSTR Tmp;
    
    dwError = DhcpGetSubnetInfo(
                            g_ServerIpAddressUnicodeString,
                            IpAddress,
                            &SubnetInfo);

    if( dwError isnot NO_ERROR )
    {
        return FALSE;
    }

    DhcpRpcFreeMemory(SubnetInfo);
    SubnetInfo = NULL;
    memset(g_ScopeIpAddressUnicodeString, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(WCHAR));
    wcscpy(g_ScopeIpAddressUnicodeString, pwszScope);
    memset(g_ScopeIpAddressAnsiString, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(CHAR));
    Tmp = DhcpUnicodeToOem(g_ScopeIpAddressUnicodeString, NULL);
    if( NULL == Tmp ) {
        return FALSE;
    }
    
    strcpy(g_ScopeIpAddressAnsiString, Tmp );
    
    g_ScopeIpAddress = IpAddress;
    
    return TRUE;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\dhcp\srvrmon.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\dhcp\dhcpmon.c

Abstract:

    SRVR Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 11/14/98

--*/
#include "precomp.h"

#define MAX_FQDN_SIZE 256

//
// The DHCP manager's commands are broken into 2 sets
//      - The commands are split into "command groups"
//        i.e, commands grouped by the VERB where the VERB is ADD, DELETE,
//        SHOW or SET.  This is not for any technical reason - only for
//        staying with the semantics used in netsh with which it will be 
//                integrated
//      - The commands which are supported by the subcontext commands of 
//        the server. The subcontext supported by DHCP is Server.
//
// A command is described using a CMD_ENTRY structure. It requires the
// command token, the handler, a short help message token and an extended 
// help message token.  To make it easier to create we use the 
// CREATE_CMD_ENTRY macro. This, however puts restrictions on how the tokens
// are named.
//
// The command groups are simply arrays of the CMD_ENTRY structure.  The 
// top level commands are also grouped in a similar array.
//
// The info about a complete command group is put in a CMD_GROUP_ENTRY
// structure, all of which are put in an array.
//
 

//
// NOTE: Since we have only one entry per group, currently, we really didnt
// need command groups. This is done for later extensibility.
// To add a command entry to a group, simply add the command to the appropriate
// array
// To add a command group - create and array and add its info to the
// command group array
//

#define CONTEXT_DHCP            L"Dhcp"
#define CONTEXT_SERVER          L"Dhcp Server"
#define CONTEXT_SCOPE           L"Scope"
#define CONTEXT_MSCOPE          L"MScope"

extern HANDLE   g_hModule;
extern HANDLE   g_hParentModule;
extern HANDLE   g_hDhcpsapiModule;
extern BOOL     g_bCommit;
extern BOOL     g_hConnect;
extern BOOL     g_fServer = FALSE;
PWCHAR   g_pwszServer = NULL;


LPWSTR  g_CurrentSubContext = NULL;

ULONG   g_ulSrvrInitCount = 0;
DWORD   g_dwMajorVersion = 0;
DWORD   g_dwMinorVersion = 0;

BOOL   g_IsSubcontext = FALSE;

DHCPMON_SUBCONTEXT_TABLE_ENTRY  g_SrvrSubContextTable[] =
{
    {L"Scope", HLP_SRVR_CONTEXT_SCOPE, HLP_SRVR_CONTEXT_SCOPE_EX, ScopeMonitor},
    {L"MScope", HLP_SRVR_CONTEXT_MSCOPE, HLP_SRVR_CONTEXT_MSCOPE_EX, MScopeMonitor},
};



CMD_ENTRY  g_SrvrAddCmdTable[] = {
    CREATE_CMD_ENTRY(SRVR_ADD_CLASS, HandleSrvrAddClass),
    CREATE_CMD_ENTRY(SRVR_ADD_MSCOPE, HandleSrvrAddMscope),
    CREATE_CMD_ENTRY(SRVR_ADD_OPTIONDEF, HandleSrvrAddOptiondef),
    CREATE_CMD_ENTRY(SRVR_ADD_SCOPE, HandleSrvrAddScope),
};

CMD_ENTRY  g_SrvrDeleteCmdTable[] = {
    CREATE_CMD_ENTRY(SRVR_DELETE_CLASS, HandleSrvrDeleteClass),
    CREATE_CMD_ENTRY(SRVR_DELETE_DNSCREDENTIALS, HandleSrvrDeleteDnsCredentials),
    CREATE_CMD_ENTRY(SRVR_DELETE_MSCOPE, HandleSrvrDeleteMscope),
    CREATE_CMD_ENTRY(SRVR_DELETE_OPTIONDEF, HandleSrvrDeleteOptiondef),
    CREATE_CMD_ENTRY(SRVR_DELETE_OPTIONVALUE, HandleSrvrDeleteOptionvalue),
    CREATE_CMD_ENTRY(SRVR_DELETE_SCOPE, HandleSrvrDeleteScope),
    CREATE_CMD_ENTRY(SRVR_DELETE_SUPERSCOPE, HandleSrvrDeleteSuperscope),
};

CMD_ENTRY g_SrvrRedoCmdTable[] = {
    CREATE_CMD_ENTRY(SRVR_REDO_AUTH, HandleSrvrRedoAuth),
    CREATE_CMD_ENTRY(SRVR_INITIATE_RECONCILE, HandleSrvrInitiateReconcile),
};

CMD_ENTRY g_SrvrExportCmdTable[] = {
    CREATE_CMD_ENTRY(SRVR_EXPORT, HandleSrvrExport),
};

CMD_ENTRY g_SrvrImportCmdTable[] = {
    CREATE_CMD_ENTRY(SRVR_IMPORT, HandleSrvrImport),
};

CMD_ENTRY g_SrvrSetCmdTable[] = {
    CREATE_CMD_ENTRY(SRVR_SET_AUDITLOG, HandleSrvrSetAuditlog),
    CREATE_CMD_ENTRY(SRVR_SET_BACKUPINTERVAL, HandleSrvrSetBackupinterval),
    CREATE_CMD_ENTRY(SRVR_SET_BACKUPPATH, HandleSrvrSetBackuppath),
    CREATE_CMD_ENTRY(SRVR_SET_DATABASECLEANUPINTERVAL, HandleSrvrSetDatabasecleanupinterval),
    CREATE_CMD_ENTRY(SRVR_SET_DATABASELOGGINGFLAG, HandleSrvrSetDatabaseloggingflag),
    CREATE_CMD_ENTRY(SRVR_SET_DATABASENAME, HandleSrvrSetDatabasename),
    CREATE_CMD_ENTRY(SRVR_SET_DATABASEPATH, HandleSrvrSetDatabasepath),
    CREATE_CMD_ENTRY(SRVR_SET_DATABASERESTOREFLAG, HandleSrvrSetDatabaserestoreflag),
    CREATE_CMD_ENTRY(SRVR_SET_DETECTCONFLICTRETRY, HandleSrvrSetDetectconflictretry),
    CREATE_CMD_ENTRY(SRVR_SET_DNSCREDENTIALS, HandleSrvrSetDnsCredentials),
    CREATE_CMD_ENTRY(SRVR_SET_DNSCONFIG, HandleSrvrSetDnsconfig),
    CREATE_CMD_ENTRY(SRVR_SET_OPTIONVALUE, HandleSrvrSetOptionvalue),
    CREATE_CMD_ENTRY(SRVR_SET_SERVER, HandleSrvrSetServer),
    CREATE_CMD_ENTRY(SRVR_SET_USERCLASS, HandleSrvrSetUserclass),
    CREATE_CMD_ENTRY(SRVR_SET_VENDORCLASS, HandleSrvrSetVendorclass),
};

CMD_ENTRY g_SrvrShowCmdTable[] = {
    CREATE_CMD_ENTRY(SRVR_SHOW_ALL, HandleSrvrShowAll),
    CREATE_CMD_ENTRY(SRVR_SHOW_AUDITLOG, HandleSrvrShowAuditlog),
    CREATE_CMD_ENTRY(SRVR_SHOW_BINDINGS, HandleSrvrShowBindings),
    CREATE_CMD_ENTRY(SRVR_SHOW_CLASS, HandleSrvrShowClass),
    CREATE_CMD_ENTRY(SRVR_SHOW_DETECTCONFLICTRETRY, HandleSrvrShowDetectconflictretry),
    CREATE_CMD_ENTRY(SRVR_SHOW_DNSCONFIG, HandleSrvrShowDnsconfig),
    CREATE_CMD_ENTRY(SRVR_SHOW_DNSCREDENTIALS, HandleSrvrShowDnsCredentials),
    CREATE_CMD_ENTRY(SRVR_SHOW_MIBINFO, HandleSrvrShowMibinfo),
    CREATE_CMD_ENTRY(SRVR_SHOW_MSCOPE, HandleSrvrShowMscope),
    CREATE_CMD_ENTRY(SRVR_SHOW_OPTIONDEF, HandleSrvrShowOptiondef),
    CREATE_CMD_ENTRY(SRVR_SHOW_OPTIONVALUE, HandleSrvrShowOptionvalue),
    CREATE_CMD_ENTRY(SRVR_SHOW_SCOPE, HandleSrvrShowScope),
    CREATE_CMD_ENTRY(SRVR_SHOW_SUPERSCOPE, HandleSrvrShowSuperScope),
    CREATE_CMD_ENTRY(SRVR_SHOW_SERVER, HandleSrvrShowServer),
    CREATE_CMD_ENTRY(SRVR_SHOW_SERVERCONFIG, HandleSrvrShowServerconfig),
    CREATE_CMD_ENTRY(SRVR_SHOW_SERVERSTATUS, HandleSrvrShowServerstatus),
    CREATE_CMD_ENTRY(SRVR_SHOW_USERCLASS, HandleSrvrShowUserclass),
    CREATE_CMD_ENTRY(SRVR_SHOW_VENDORCLASS, HandleSrvrShowVendorclass),
    CREATE_CMD_ENTRY(SRVR_SHOW_VERSION, HandleSrvrShowVersion),
};


CMD_GROUP_ENTRY g_SrvrCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD, g_SrvrAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_SrvrDeleteCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_EXPORT, g_SrvrExportCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_IMPORT, g_SrvrImportCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_REDO, g_SrvrRedoCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET, g_SrvrSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_SrvrShowCmdTable),
};


CMD_ENTRY g_SrvrCmds[] = 
{
    CREATE_CMD_ENTRY(SRVR_LIST, HandleSrvrList),
    CREATE_CMD_ENTRY(SRVR_DUMP, HandleSrvrDump),
    CREATE_CMD_ENTRY(SRVR_HELP1, HandleSrvrHelp),
    CREATE_CMD_ENTRY(SRVR_HELP2, HandleSrvrHelp),
    CREATE_CMD_ENTRY(SRVR_HELP3, HandleSrvrHelp),
    CREATE_CMD_ENTRY(SRVR_HELP4, HandleSrvrHelp),
};


ULONG g_ulSrvrNumSubContext = sizeof(g_SrvrSubContextTable)/sizeof(DHCPMON_SUBCONTEXT_TABLE_ENTRY);
ULONG g_ulSrvrNumTopCmds = sizeof(g_SrvrCmds)/sizeof(CMD_ENTRY);
ULONG g_ulSrvrNumGroups = sizeof(g_SrvrCmdGroups)/sizeof(CMD_GROUP_ENTRY);

DWORD
WINAPI
SrvrCommit(
    IN  DWORD   dwAction
)
{
    BOOL    bCommit, bFlush = FALSE;

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. Srvr current state is commit, then
            // nothing to be done.
            //

            if(g_bCommit)
            {
                return NO_ERROR;
            }

            bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    return NO_ERROR;
}


DWORD
WINAPI
SrvrMonitor(
    IN      LPCWSTR     pwszMachine,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      DWORD       dwFlags,
    IN      LPCVOID     pvData,
    OUT     LPWSTR      pwcNewContext
    )
{
    DWORD                   dwError = NO_ERROR;
    DWORD                   dwIndex, i, j, k;
    DWORD                   dwIsServer = 0;
    DWORD                   SrvIndex = 0;
    BOOL                    bFound = FALSE;
    PFN_HANDLE_CMD          pfnHandler = NULL;
    PNS_CONTEXT_ENTRY_FN    pfnHelperEntryPt;
    PNS_CONTEXT_DUMP_FN     pfnHelperDumpPt;
    WCHAR                   wcSvrTemp[MAX_IP_STRING_LEN+1] = {L'\0'};
    BOOL                    fTemp = FALSE;                            
    DWORD                   dwNumMatched;
    DWORD                   dwCmdHelpToken = 0;
    DWORD                   dw = 0;

    if(dwArgCount is 1)
    {
        //Hmm! Hasn't passed any Server Info. Set the server to the
        // value pwsRouter
        WCHAR ServerInfo[1000] = L"\\\\";

        if( pwszMachine and
            wcslen(pwszMachine) > 2 and
            wcsncmp(pwszMachine, L"\\\\", 2) and
            IsIpAddress(pwszMachine) is FALSE )
        {
            wcscpy(&ServerInfo[2], pwszMachine );
            pwszMachine = ServerInfo;
        }

        if( FALSE is SetServerInfo(pwszMachine) )
        {
            return GetLastError();
        }
        else
        {
            g_fServer = TRUE;
            //wcscpy(pwcNewContext, L"dhcp server");
            return ERROR_CONTEXT_SWITCH;
        }
    }

    dwIndex = 1;

    //If it is a help for server command
    if( IsHelpToken(ppwcArguments[dwIndex]) is TRUE and
        g_fServer is FALSE )
    {
        DisplayMessage(g_hModule, HLP_DHCP_CONTEXT_SERVER_EX);
        dwError = NO_ERROR;
        goto CleanUp;
    }

    //Is it a servername or address?
    if( IsValidServer(ppwcArguments[dwIndex]) )
    {
        if( g_fServer is TRUE and
            dwArgCount > 2 )
        {
            wcscpy(wcSvrTemp, g_ServerIpAddressUnicodeString);
            fTemp = TRUE;
        }
        if( FALSE is SetServerInfo(ppwcArguments[dwIndex]) )
        {
            dwError = GetLastError();
            goto CleanUp;
        }

        pwcNewContext[wcslen(pwcNewContext)- wcslen(ppwcArguments[dwIndex]) -1 ] = L'\0';
        
        dw++;
        dwIndex++;
        SrvIndex = 1;
        dwIsServer++;
        g_fServer = TRUE;

    }
    else if( g_fServer is FALSE )
    {
        WCHAR ServerInfo[1000] = L"\\\\";

        if( pwszMachine and 
            wcslen(pwszMachine) > 2 and
            wcsncmp(pwszMachine, L"\\\\", 2) and
            IsIpAddress(pwszMachine) is FALSE )
        {
            wcscpy(&ServerInfo[2], pwszMachine );
            pwszMachine = ServerInfo;
        }
        
        if( FALSE is SetServerInfo(pwszMachine) )
        {
            dwError = GetLastError();
            goto CleanUp;
        }
        g_fServer = TRUE;
    }

    
    if( dwIndex >= dwArgCount )
    {            
        dwError = ERROR_CONTEXT_SWITCH;
        //wcscpy(pwcNewContext, L"dhcp server");
        goto CleanUp;
    }

    //Is it a top level(non Group command)?
    for(i=0; i<g_ulSrvrNumTopCmds; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_SrvrCmds[i].pwszCmdToken))
        {
            bFound = TRUE;

            pfnHandler = g_SrvrCmds[i].pfnCmdHandler;

            dwCmdHelpToken = g_SrvrCmds[i].dwCmdHlpToken;
            
            dwIndex++;

            break;
        }
    }


    if(bFound)
    {
        if ((( dwArgCount - SrvIndex ) > 2 ) &&
            ( IsHelpToken(ppwcArguments[ dwIndex ])))
        {
            DisplayMessage(g_hModule, dwCmdHelpToken);

            dwError = NO_ERROR;
            goto CleanUp;
        }
        
        dwIndex++;

        dwError = (*pfnHandler)(pwszMachine, ppwcArguments+dw, dwIndex, dwArgCount-dw, dwFlags, pvData, &bFound);

        goto CleanUp;
    }
    //Is it meant for any of the subcontext?
    for(i = 0; i<g_ulSrvrNumSubContext; i++)
    {
        if( MatchToken(ppwcArguments[dwIndex], g_SrvrSubContextTable[i].pwszContext) )
        {
            bFound = TRUE;
            dwIndex++;
            pfnHelperEntryPt = g_SrvrSubContextTable[i].pfnEntryFn;
            DEBUG("Meant for subcontext under it");
            break;
        }
    }

    if( bFound )    //Subcontext
    {
        dwError = (pfnHelperEntryPt)(pwszMachine,
                                     ppwcArguments+1+dw,
                                     dwArgCount-1 -dw,
                                     dwFlags,
                                     pvData,
                                     pwcNewContext);
        if( dwError is ERROR_CONTEXT_SWITCH )
        {
            if( g_CurrentSubContext isnot NULL )
            {
                memset(g_CurrentSubContext, 0x00, (wcslen(g_CurrentSubContext)+1)*sizeof(WCHAR));
                DhcpFreeMemory(g_CurrentSubContext);
                g_CurrentSubContext = NULL;
            }

            g_CurrentSubContext = DhcpAllocateMemory((wcslen(g_SrvrSubContextTable[i].pwszContext)+1)*sizeof(WCHAR));
            if( g_CurrentSubContext is NULL )
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto CleanUp;
            }
            g_CurrentSubContext[0] = L'\0';
            wcscpy(g_CurrentSubContext, g_SrvrSubContextTable[i].pwszContext);
            g_IsSubcontext = TRUE;
        }

        goto CleanUp;
    }

    bFound = FALSE;

    //It is not a non Group Command. Then is it a config command for the manager?
    for(i = 0; (i < g_ulSrvrNumGroups) and !bFound; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_SrvrCmdGroups[i].pwszCmdGroupToken))
        {
            //
            // Command matched entry i, so look at the table of sub commands 
            // for this command
            //
            if( dwArgCount > dwIndex+1 )
            {
                for (j = 0; j < g_SrvrCmdGroups[i].ulCmdGroupSize; j++)
                {
                    if (MatchCmdLine(ppwcArguments+dwIndex,
                                      dwArgCount - 1,
                                      g_SrvrCmdGroups[i].pCmdGroup[j].pwszCmdToken,
                                      &dwNumMatched))
                    {
                        bFound = TRUE;
                
                        pfnHandler = g_SrvrCmdGroups[i].pCmdGroup[j].pfnCmdHandler;
                
                        dwCmdHelpToken = g_SrvrCmdGroups[i].pCmdGroup[j].dwCmdHlpToken;

                        //
                        // break out of the for(j) loop
                        //
                        dwIndex+=dwNumMatched;
                        break;
                    }
                }
            }

            if(!bFound)
            {
                //
                // We matched the command group token but none of the
                // sub commands
                //

                DisplayMessage(g_hModule, 
                               EMSG_SRVR_INCOMPLETE_COMMAND);

                for (j = 0; j < g_SrvrCmdGroups[i].ulCmdGroupSize; j++)
                {
                    DisplayMessage(g_hModule, 
                             g_SrvrCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);
                    
                                        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
                }

                dwError = ERROR_INVALID_PARAMETER;
                goto CleanUp;
            }
            else
            {
                //
                // quit the for(i)
                //

                break;
            }
        }
    }




    if (!bFound)
    {
        //
        // Command not found. 
        //
        if( _wcsicmp(ppwcArguments[dwIndex], L"..") is 0 )
        {
            if( g_IsSubcontext is FALSE )
            {
                if(g_pwszServer)
                {
                    DhcpFreeMemory(g_pwszServer);
                    g_pwszServer = NULL;
                }
                memset(g_ServerIpAddressUnicodeString, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(WCHAR));
                g_fServer = FALSE;
            }
            else
            {
                g_IsSubcontext = FALSE;
            }
        }

        dwError = ERROR_CMD_NOT_FOUND;
        goto CleanUp;
    }

    //
    // See if it is a request for help.
    //

    dwNumMatched += dwIsServer;

    if (dwNumMatched < (dwArgCount - 1) &&
        IsHelpToken(ppwcArguments[dwNumMatched + 1]))
    {
        DisplayMessage(g_hModule, dwCmdHelpToken);

        dwError = NO_ERROR;
        goto CleanUp;
    }
    
    //
    // Call the parsing routine for the command
    //

    dwError = (*pfnHandler)(pwszMachine, ppwcArguments, dwIndex, dwArgCount - dwIndex, dwFlags, pvData, &bFound);

    if( dwError is ERROR_CONTEXT_SWITCH )
    {
        if( ( _wcsicmp(g_CurrentSubContext, CONTEXT_SCOPE) is 0 ) or
            ( _wcsicmp(g_CurrentSubContext, CONTEXT_MSCOPE) is 0 ) )
        {
            //pwcNewContext[0] = L'\0';
            //wcscpy(pwcNewContext, CONTEXT_SERVER);
            dwError = ERROR_CONTEXT_SWITCH;

        }
        else
        {
            dwError = NO_ERROR;
        }
        goto CleanUp;
    }
CleanUp:
    if( fTemp )
    {
        fTemp = SetServerInfo(wcSvrTemp);
    }
    return dwError;
}



DWORD
WINAPI
SrvrUnInit(
    IN  DWORD   dwReserved
    )
{
    if(InterlockedDecrement(&g_ulSrvrInitCount) isnot 0)
    {
        return NO_ERROR;
    }

    return NO_ERROR;
}

BOOL
SetServerInfo(
    IN  LPCWSTR  pwszServerInfo
)
{

    PHOSTENT pHost;
    INT      retval;
    SOCKADDR_IN addr;
    DWORD    Len, Error;

    // Get the FQDN into g_pwszServer
    if ( NULL != g_pwszServer ) {
        DhcpFreeMemory( g_pwszServer );
        g_pwszServer = NULL;
    }


    // skip the leading backslashes if any
    if (( NULL != pwszServerInfo ) && 
        ( pwszServerInfo[ 0 ] == L'\\') &&
        ( pwszServerInfo[ 1 ] == L'\\')) {
        pwszServerInfo = &pwszServerInfo[ 2 ];
    }
    pHost = UnicodeGetHostByName( pwszServerInfo, &g_pwszServer );
    if ( NULL == pHost ) {
        return FALSE;
    }

    // copy the server info into the global variables

    addr.sin_family = AF_INET;
    addr.sin_addr.S_un.S_addr = *(( u_long * )(pHost->h_addr_list) [ 0 ]);
    addr.sin_port = 0;

    LocalFree( pHost );

    Len = sizeof( g_ServerIpAddressUnicodeString );
    retval = WSAAddressToString(( LPSOCKADDR ) &addr, sizeof( addr ), NULL,
                                g_ServerIpAddressUnicodeString, &Len );

    if ( 0 != retval ) {
        return FALSE;
    }

    // If the server does not have an FQDN, use the provided name
    if ( NULL == g_pwszServer ) {
	Len = wcslen( pwszServerInfo ) + 1;
	Len *= sizeof( WCHAR );
	g_pwszServer = DhcpAllocateMemory( Len );
	
	if ( NULL == g_pwszServer ) {
	    return FALSE;
	}
	wcscpy( g_pwszServer, pwszServerInfo );
    } // if 
    

    // Get the server version
    Error = DhcpGetVersion( g_ServerIpAddressUnicodeString, &g_dwMajorVersion, &g_dwMinorVersion );
    if ( ERROR_SUCCESS != Error ) {
	SetLastError( Error );
	DisplayMessage( g_hModule, EMSG_SRVR_UNKNOWN_VERSION,
			g_ServerIpAddressUnicodeString );
	return FALSE;
    }
    return TRUE;
} // SetServerInfo()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\dhcp\stubs.c ===
#include "precomp.h"

//
// Delete Record is used in server\server\dbconfig.c to delete entries from the
// database. This is referenced in netsh via the import/export library defined
// dhcpexim.lib. Dhcpexim.lib is a replica of dbconfig.c and uses in-memory data
// structures defined in server\mm and server\mmreg extensively. 
// Since DeleteRecord() is only valid in dhcpssvc.dll, it is stubbed out here.
// 

DWORD DeleteRecord
( 
   ULONG UniqId
)
{
    return ERROR_SUCCESS;

} // DeleteRecord()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\inc\dhcpdefs.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\ip\defs.h

Abstract:

    global definitions

Revision History:

    Anand Mahalingam         7/10/98  Created

--*/

#ifndef _DEBUG
#define DEBUG(s)
#define DEBUG1(s1,s2)
#define DEBUG2(s1,s2)
#else
#define DEBUG(s) wprintf(L"%s\n", L##s)
#define DEBUG1(s1,s2) wprintf(L##s1, L##s2)
#define DEBUG2(s1,s2) wprintf(L##s1, L##s2)
#endif

#define is ==
#define isnot !=
#define or ||
#define and &&

#define REG_VALUE_ENTRY_PT        L"EntryPoint"
#define REG_VALUE_DUMP_FN         L"DumpFunction"
#define REG_KEY_DHCPMGR_HELPER    L"SOFTWARE\\Microsoft\\Netsh\\Dhcp"

#define MaxIfDisplayLength 1024
#define ADDR_LENGTH          24
#define ADDR_LEN              4

#define DISPLAYLEN_PHYSADDR 3*MAXLEN_PHYSADDR + 8

#define PRINT(s) wprintf(L"%s\n",L##s)
#define PRINT1(s,s1) wprintf(L##s , L##s1)

#ifdef UNICODE
#define MakeUnicodeIpAddr(ptszUnicode,pszAddr)             \
    MultiByteToWideChar(CP_ACP,                            \
                        0,                                 \
                        (pszAddr),                         \
                        -1,                                \
                        (ptszUnicode),                     \
                        ADDR_LENGTH)
#else
#define MakeUnicodeIpAddr(ptszUnicode,pszAddr)             \
    strcpy((ptszUnicode),(pszAddr))
#endif //UNICODE

#ifdef UNICODE
#define MakeUnicodePhysAddr(ptszUnicode,pszAddr,dwLen)      \
{                                                           \
    CHAR __szTemp[DISPLAYLEN_PHYSADDR + 1];                 \
    DWORD __i,__dwTempLen;                                  \
    __dwTempLen = (((dwLen) <= MAXLEN_PHYSADDR) ? (dwLen) : MAXLEN_PHYSADDR); \
    for(__i = 0; __i < __dwTempLen; __i++)                  \
    {                                                       \
        sprintf(&(__szTemp[3*__i]),"%02X-",pszAddr[__i]);   \
    }                                                       \
    MultiByteToWideChar(CP_ACP,                             \
                        0,                                  \
                        (__szTemp),                         \
                        -1,                                 \
                        (ptszUnicode),                      \
                        3*__i);                             \
    ptszUnicode[(3*__i) - 1] = TEXT('\0');                  \
}
#else
#define MakeUnicodePhysAddr(ptszUnicode,pszAddr,dwLen)      \
{                                                           \
    CHAR __szTemp[DISPLAYLEN_PHYSADDR + 1];                 \
    DWORD __i,__dwTempLen;                                  \
    __dwTempLen = (((dwLen) <= MAXLEN_PHYSADDR) ? (dwLen) : MAXLEN_PHYSADDR); \
    for(__i = 0; __i < __dwTempLen; __i++)                  \
    {                                                       \
        sprintf(&(__szTemp[3*__i]),"%02X-",pszAddr[__i]);   \
    }                                                       \
    strncpy((ptszUnicode),__szTemp,3*__i);                  \
    ptszUnicode[(3*__i) - 1] = TEXT('\0');                  \
}
#endif //UNICODE

#define     GetDispString(gModule, val, str, count, table)                           \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for( ; __dwInd < (count); __dwInd += 2 )                                \
    {                                                                       \
        if ( (val) != (table)[ __dwInd ] ) { continue; }                    \
        (str) = MakeString( (gModule), (table)[ __dwInd + 1 ] );                       \
        break;                                                              \
    }                                                                       \
    if ( __dwInd >= (count) ) { (str) = MakeString( (gModule), STRING_UNKNOWN ); }     \
}

#define FREE_STRING_NOT_NULL(ptszString) if (ptszString) FreeString(ptszString)

#define ERROR_CONFIG                    1
#define ERROR_ADMIN                     2
#define ERROR_UNIDENTIFIED_MIB 2312
#define ERROR_TOO_FEW_ARGS     (ERROR_UNIDENTIFIED_MIB+1)

#define MAX_NUM_INDICES 6

#define PRINT_IPADDR(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

#define IP_TO_WSTR(str,addr) swprintf((str),L"%d.%d.%d.%d", \
				    (addr)[0],    \
				    (addr)[1],    \
				    (addr)[2],    \
				    (addr)[3])




#define GET_TOKEN_PRESENT(tokenMask) (dwBitVector & tokenMask)
#define SET_TOKEN_PRESENT(tokenMask) (dwBitVector |= tokenMask)

#define SetErrorType(pdw)   *(pdw) = IsRouterRunning()?ERROR_ADMIN:ERROR_CONFIG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\inc\dhcphandle.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/
FN_HANDLE_CMD   HandleDhcpList;
FN_HANDLE_CMD   HandleDhcpHelp;

FN_HANDLE_CMD   HandleDhcpContexts;

FN_HANDLE_CMD   HandleDhcpDump;

FN_HANDLE_CMD   HandleDhcpAddServer;

//FN_HANDLE_CMD   HandleDhcpAddHelper;


FN_HANDLE_CMD   HandleDhcpDeleteServer;

//FN_HANDLE_CMD   HandleDhcpDeleteHelper;


FN_HANDLE_CMD   HandleDhcpShowServer;

//FN_HANDLE_CMD   HandleDhcpShowHelper;

DWORD
CreateDumpFile(
    IN  PWCHAR  pwszName,
    OUT PHANDLE phFile
);

VOID
CloseDumpFile(
    HANDLE  hFile
);


// print server information
VOID
PrintServerInfo(
    LPDHCP_SERVER_INFO  Server
);



VOID
PrintServerInfoArray(
    LPDHCP_SERVER_INFO_ARRAY Servers
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\inc\common.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/
#ifndef _COMMON_H_
#define _COMMON_H_

#define MAX_IP_STRING_LEN   15

#ifdef UNICODE
#define STRICMP(x, y)    _wcsicmp(x, y)
#else
#define STRICMP(x, y)    _stricmp(x, y)
#endif  //UNICODE

#ifdef UNICODE
#define STRTOUL(x, y, z)    wcstoul(x, y, z)
#else
#define STRTOUL(x, y, z)    strtoul(x, y, z)
#endif  //UNICODE

#ifdef UNICODE
#define STRCHR(x, y)        wcschr(x, y)
#else
#define STRCHR(x, y)        strchr(x, y)
#endif  //UNICODE

#ifdef UNICODE
#define STRCAT(x, y)        wcscat(x, y)
#else
#define STRCAT(x, y)        strcat(x, y)
#endif  //UNICODE

#ifdef UNICODE
#define STRLEN(x)        wcslen(x)
#else
#define STRCAT(x)        strlen(x)
#endif  //UNICODE

#ifdef UNICODE
#define ATOI(x)        _wtoi(x)
#else
#define ATOI(x)        atoi(x)
#endif  //UNICODE

#ifdef NT5
#define CHKNULL(Str) ((Str)?(Str):TEXT("<None>"))
#endif  //NT5

#ifdef UNICODE
#define IpAddressToString   DhcpIpAddressToDottedStringW
#else
#define IpAddressToString   DhcpIpAddressToDottedString
#endif //UNICODE

#ifdef UNICODE
#define StringToIpAddress   DhcpDottedStringToIpAddressW
#else
#define StringToIpAddress   DhcpDottedStringToIpAddress
#endif //UNICODE

#undef DhcpAllocateMemory
#undef DhcpFreeMemory

#ifndef _DEBUG
#define DEBUG(s)
#define DEBUG1(s1,s2)
#define DEBUG2(s1,s2)
#else
#define DEBUG(s) wprintf(L"%s\n", L##s)
#define DEBUG1(s1,s2) wprintf(L##s1, L##s2)
#define DEBUG2(s1,s2) wprintf(L##s1, L##s2)
#endif

#define SRVRMON_VERSION_50      5
#define DHCPMON_VERSION_50      5
#define SCOPEMON_VERSION_50     5

#define is                      ==
#define isnot                   !=
#define or                      ||
#define and                     &&

#define CLASS_ID_VERSION        0x5
#define MAX_STRING_LEN          256

#define REG_VALUE_ENTRY_PT        L"EntryPoint"
#define REG_VALUE_DUMP_FN         L"DumpFunction"
#define REG_KEY_DHCPSCOPE_HELPER  L"SOFTWARE\\Microsoft\\Netsh\\Dhcp\\Server\\Scope"
#define REG_KEY_DHCPSRVR_HELPER   L"SOFTWARE\\Microsoft\\Netsh\\Dhcp\\Server"
#define REG_KEY_DHCPMGR_HELPER    L"SOFTWARE\\Microsoft\\Netsh\\Dhcp"

#define MaxIfDisplayLength 1024
#define ADDR_LENGTH          24
#define ADDR_LEN              4

#define DEFAULT_DHCP_LEASE         8*24*60*60
#define DEFAULT_BOOTP_LEASE        30*24*60*60
#define DEFAULT_MULTICAST_TTL      0x20
#define INFINIT_TIME               0x7FFFFFFF  // time_t is int
#define INFINIT_LEASE              0xFFFFFFFF  // in secs. (unsigned int.)


typedef struct _COMMAND_OPTION_TYPE
{
    LPWSTR                  pwszTagID;
    DHCP_OPTION_DATA_TYPE   DataType;
    LPWSTR                  pwcTag;
} COMMAND_OPTION_TYPE, *PCOMMAND_OPTION_TYPE;

extern COMMAND_OPTION_TYPE TagOptionType[ 8 ];/* = 
    { TAG_OPTION_BYTE,          DhcpByteOption,             L"BYTE" },
    { TAG_OPTION_WORD,          DhcpWordOption,             L"WORD" },
    { TAG_OPTION_DWORD,         DhcpDWordOption,            L"DWORD" },
    { TAG_OPTION_DWORDDWORD,    DhcpDWordDWordOption,       L"DWORDDWORD" },
    { TAG_OPTION_IPADDRESS,     DhcpIpAddressOption,        L"IPADDRESS" },
    { TAG_OPTION_STRING,        DhcpStringDataOption,       L"STRING" },
    { TAG_OPTION_BINARY,        DhcpBinaryDataOption,       L"BINARY" },
    { TAG_OPTION_ENCAPSULATED,  DhcpEncapsulatedDataOption, L"ENCAPSULATED" }
*/
#define DISPLAYLEN_PHYSADDR 3*MAXLEN_PHYSADDR + 8

#define PRINT(s) wprintf(L"%s\n",L##s)
#define PRINT1(s,s1) wprintf(L##s , L##s1)

#ifdef UNICODE
#define MakeUnicodeIpAddr(ptszUnicode,pszAddr)             \
    MultiByteToWideChar(CP_ACP,                            \
                        0,                                 \
                        (pszAddr),                         \
                        -1,                                \
                        (ptszUnicode),                     \
                        ADDR_LENGTH)
#else
#define MakeUnicodeIpAddr(ptszUnicode,pszAddr)             \
    strcpy((ptszUnicode),(pszAddr))
#endif //UNICODE

#ifdef UNICODE
#define MakeUnicodePhysAddr(ptszUnicode,pszAddr,dwLen)      \
{                                                           \
    CHAR __szTemp[DISPLAYLEN_PHYSADDR + 1];                 \
    DWORD __i,__dwTempLen;                                  \
    __dwTempLen = (((dwLen) <= MAXLEN_PHYSADDR) ? (dwLen) : MAXLEN_PHYSADDR); \
    for(__i = 0; __i < __dwTempLen; __i++)                  \
    {                                                       \
        sprintf(&(__szTemp[3*__i]),"%02X-",pszAddr[__i]);   \
    }                                                       \
    MultiByteToWideChar(CP_ACP,                             \
                        0,                                  \
                        (__szTemp),                         \
                        -1,                                 \
                        (ptszUnicode),                      \
                        3*__i);                             \
    ptszUnicode[(3*__i) - 1] = TEXT('\0');                  \
}
#else
#define MakeUnicodePhysAddr(ptszUnicode,pszAddr,dwLen)      \
{                                                           \
    CHAR __szTemp[DISPLAYLEN_PHYSADDR + 1];                 \
    DWORD __i,__dwTempLen;                                  \
    __dwTempLen = (((dwLen) <= MAXLEN_PHYSADDR) ? (dwLen) : MAXLEN_PHYSADDR); \
    for(__i = 0; __i < __dwTempLen; __i++)                  \
    {                                                       \
        sprintf(&(__szTemp[3*__i]),"%02X-",pszAddr[__i]);   \
    }                                                       \
    strncpy((ptszUnicode),__szTemp,3*__i);                  \
    ptszUnicode[(3*__i) - 1] = TEXT('\0');                  \
}
#endif //UNICODE

#define     GetDispString(gModule, val, str, count, table)                           \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for( ; __dwInd < (count); __dwInd += 2 )                                \
    {                                                                       \
        if ( (val) != (table)[ __dwInd ] ) { continue; }                    \
        (str) = MakeString( (gModule), (table)[ __dwInd + 1 ] );                       \
        break;                                                              \
    }                                                                       \
    if ( __dwInd >= (count) ) { (str) = MakeString( (gModule), STRING_UNKNOWN ); }     \
}

#define FREE_STRING_NOT_NULL(ptszString) if (ptszString) FreeString(ptszString)

#define ERROR_CONFIG                    1
#define ERROR_ADMIN                     2
#define ERROR_UNIDENTIFIED_MIB 2312
#define ERROR_TOO_FEW_ARGS     (ERROR_UNIDENTIFIED_MIB+1)

#define MAX_NUM_INDICES 6

#define PRINT_IPADDR(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

#define IP_TO_WSTR(str,addr) swprintf((str),L"%d.%d.%d.%d", \
				    (addr)[0],    \
				    (addr)[1],    \
				    (addr)[2],    \
				    (addr)[3])




#define GET_TOKEN_PRESENT(tokenMask) (dwBitVector & tokenMask)
#define SET_TOKEN_PRESENT(tokenMask) (dwBitVector |= tokenMask)

#define SetErrorType(pdw)   *(pdw) = IsRouterRunning()?ERROR_ADMIN:ERROR_CONFIG
#define INFINITE_EXPIRATION 0x7FFFFFFF


#define MSCOPE_START_RANGE      StringToIpAddress(L"224.0.0.0")
#define MSCOPE_END_RANGE        StringToIpAddress(L"239.255.255.255")

WCHAR  StringToHex(LPCWSTR pwcString);
LPSTR  StringToHexString(LPCSTR pszStr);

DHCP_IP_ADDRESS
DhcpDefaultSubnetMask(
    DHCP_IP_ADDRESS IpAddress
    );

DWORD
FormatDateTimeString( FILETIME ftTime,
                      BOOL    fShort,
                      LPWSTR  pwszBuffer,
                      DWORD  *pdwBuffLen);

LPWSTR
GetDateTimeString(FILETIME  TimeStamp,
                  BOOL      fShort,
                  int      *piType
                  );

PVOID
DhcpAllocateMemory(
    IN  DWORD Size
    );

VOID
DhcpFreeMemory(
    IN  PVOID Memory
    );


DATE_TIME
DhcpCalculateTime(
    IN  DWORD RelativeTime
    );

LPWSTR
DhcpOemToUnicodeN(
    IN      LPCSTR  Ansi,
    IN OUT  LPWSTR  Unicode,
    IN      USHORT  cChars
    );

LPWSTR
DhcpOemToUnicode(
    IN      LPCSTR Ansi,
    IN OUT  LPWSTR Unicode
    );

LPSTR
DhcpUnicodeToOem(
    IN  LPCWSTR Unicode,
    OUT LPSTR   Ansi
    );

VOID
DhcpHexToString(
    OUT LPWSTR  Buffer,
    IN  const BYTE * HexNumber,
    IN  DWORD Length
    );

VOID
DhcpHexToAscii(
    IN  LPSTR Buffer,
    IN  LPBYTE HexNumber,
    IN  DWORD Length
    );

VOID
DhcpDecimalToString(
    IN  LPWSTR Buffer,
    IN  BYTE Number
    );

DWORD
DhcpDottedStringToIpAddress(
    IN  LPSTR String
    );

LPSTR
DhcpIpAddressToDottedString(
    IN  DWORD IpAddress
    );

DWORD
DhcpStringToHwAddress(
    OUT LPSTR  AddressBuffer,
    IN  LPCSTR AddressString
    );

DWORD
DhcpDottedStringToIpAddressW(
    IN  LPCWSTR pwszString
);

LPWSTR
DhcpIpAddressToDottedStringW(
    IN  DWORD   IpAddress
);

LPWSTR
DhcpRegIpAddressToKey(
    IN  DHCP_IP_ADDRESS IpAddress,
    IN  LPCWSTR KeyBuffer
    );

DWORD
DhcpRegKeyToIpAddress(
    IN  LPCWSTR Key
    );

LPWSTR
DhcpRegOptionIdToKey(
    IN  DHCP_OPTION_ID OptionId,
    IN  LPCWSTR KeyBuffer
    );

DHCP_OPTION_ID
DhcpRegKeyToOptionId(
    IN  LPCWSTR Key
    );

#if DBG



VOID
DhcpPrintRoutine(
    IN DWORD  DebugFlag,
    IN LPCSTR Format,
    ...
);

VOID
DhcpAssertFailed(
    IN LPCSTR FailedAssertion,
    IN LPCSTR FileName,
    IN DWORD LineNumber,
    IN LPSTR Message
    );

#define DhcpPrint(_x_)   DhcpPrintRoutine _x_


#define DhcpAssert(Predicate) \
    { \
        if (!(Predicate)) \
            DhcpAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#define DhcpVerify(Predicate) \
    { \
        if (!(Predicate)) \
            DhcpAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#else

#define DhcpAssert(_x_)
#define DhcpDumpMessage(_x_, _y_)
#define DhcpVerify(_x_) (_x_)

#endif // not DBG

DWORD
CreateDumpFile(
    IN  PWCHAR  pwszName,
    OUT PHANDLE phFile
    );


VOID
CloseDumpFile(
    IN HANDLE  hFile
    );


BOOL
IsIpAddress(
    IN LPCWSTR pwszAddress
);

BOOL
IsValidServer(
    IN LPCWSTR  pwszServer
);

BOOL
IsLocalServer( 
    IN LPCWSTR  pwszServer
);

BOOL
IsValidScope(
    IN LPCWSTR  pwszServer,
    IN LPCWSTR  pwszAddress
);

BOOL
IsValidMScope(
    IN LPCWSTR  pwszServer,  
    IN LPCWSTR  pwszMScope
);

BOOL
IsPureHex(
    IN LPCWSTR  pwszString
);

DWORD
DhcpDumpServer(
               IN LPCWSTR  pwszIpAddress,
               IN DWORD    dwMajor,
               IN DWORD    dwMinor
               );

PBYTE
GetLangTagA();

VOID
DhcpDumpScriptHeader();

VOID
DhcpDumpServerScriptHeader(IN LPCWSTR pwszServer);

VOID
DhcpDumpServerClass(
                    IN LPCWSTR          pwszServer,
                    IN DHCP_CLASS_INFO ClassInfo);

DWORD
DhcpDumpServerOptiondefV5(IN LPCWSTR             pwszServer,
                          IN LPDHCP_ALL_OPTIONS OptionsAll
                         );

DWORD
DhcpDumpServerOptiondef(IN LPCWSTR               pwszServer,
                        LPDHCP_OPTION_ARRAY  OptionArray
                       );

DWORD
DhcpDumpServerOptionValuesV5(IN LPCWSTR          pwszServer,
                             IN LPCWSTR          pwszScope,
                             IN LPCWSTR          pwszReserved,
                             IN LPDHCP_ALL_OPTION_VALUES OptionValues
                            );

DWORD
DhcpDumpServerOptionValue(IN LPCWSTR             pwszServer,
                          IN LPCWSTR             pwszScope,
                          IN LPCWSTR             pwszReserved,
                          IN LPCWSTR             pwcUser,
                          IN LPCWSTR             pwcVendor,
                          IN BOOL               fIsV5,
                          IN DHCP_OPTION_VALUE  OptionValue);

DWORD
DhcpDumpReservedOptionValues(
                             IN LPCWSTR     pwszServer,
                             IN DWORD      dwMajor,
                             IN DWORD      dwMinor,
                             IN LPCWSTR     pwszScope,
                             IN LPCWSTR     pwszReservedIp
                             );

DWORD
DhcpDumpScope(IN LPCWSTR  pwszServerIp,
              IN DWORD   dwMajor,
              IN DWORD   dwMinor,
              IN DWORD   ScopeIp);

VOID
DhcpDumpSuperScopes( IN LPCWSTR pwszServer, 
		     IN DWORD dwMajor, 
		     IN DWORD dwMinor );


DWORD
DhcpDumpServerMScope(IN LPCWSTR pwszServer,
                     IN DWORD  dwMajor,
                     IN DWORD  dwMinor,
                     IN LPCWSTR pwszMScope
                     );

VOID
DhcpDumpServerClassHeader();

VOID
DhcpDumpServerClassFooter();

VOID
DhcpDumpServerOptiondefHeader();

VOID
DhcpDumpServerOptiondefFooter();

VOID
DhcpDumpServerOptionvalueHeader();

VOID
DhcpDumpServerOptionvalueFooter();

VOID
DhcpDumpServerScopeHeader();

VOID
DhcpDumpServerScopeFooter();

VOID
DhcpDumpServerMScopeHeader();

VOID
DhcpDumpServerMScopeFooter();

VOID
DhcpDumpServerConfig(IN LPCWSTR pwszServer);



VOID
DhcpDumpScriptFooter();

VOID
DhcpDumpServerScriptFooter();

NS_CONTEXT_DUMP_FN DhcpDump;

BOOL
IsPureNumeric(IN LPCWSTR pwszStr);

LPWSTR
MakeDayTimeString(
               IN DWORD dwTime
);

PHOSTENT
UnicodeGetHostByName(
    IN PCWSTR name,
    IN OUT LPWSTR *FqdnName
    );

#endif //_COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\dhcp\strdefs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:


Abstract:

    

Author:

    Shubho Bhattacharya(a-sbhatt)  11/14/98

Revision History:

        
--*/

#ifndef __STRDEFS_H__
#define __STRDEFS_H__

#define MSG_DHCP_NULL                           1001
#define MSG_DHCP_FORMAT_LINE                    1002
#define MSG_DHCP_FORMAT_TAB                     1003
#define MSG_DHCP_FORMAT_DASH                    1004
#define MSG_DHCP_FORMAT_STRING                  1005

#define DHCP_ARG_DELIMITER                      L"="


#define TAG_OPTION_BYTE                         L"byte"
#define TAG_OPTION_WORD                         L"word"
#define TAG_OPTION_DWORD                        L"dword"
#define TAG_OPTION_IPADDRESS                    L"ipaddress"
#define TAG_OPTION_STRING                       L"string"
#define TAG_OPTION_DWORDDWORD                   L"dworddword"
#define TAG_OPTION_BINARY                       L"binary"
#define TAG_OPTION_ENCAPSULATED                 L"encapsulated"

#define TOKEN_VENDOR_CLASS                      L"vendor"
#define TOKEN_USER_CLASS                        L"user"
#define TOKEN_OPTION_COMMENT                    L"comment"


#define CMD_GROUP_ADD                           L"add"
#define CMD_GROUP_CHECK                         L"initiate"
#define CMD_GROUP_DELETE                        L"delete"
#define CMD_GROUP_REDO                          L"initiate"
#define CMD_GROUP_SET                           L"set"
#define CMD_GROUP_SHOW                          L"show"
#define CMD_GROUP_EXPORT                        L"export"
#define CMD_GROUP_IMPORT                        L"import"

#define CMD_DHCP_LIST                           L"list"
#define CMD_DHCP_HELP1                          L"help"
#define CMD_DHCP_HELP2                          L"?"
#define CMD_DHCP_HELP3                          L"/?"
#define CMD_DHCP_HELP4                          L"-?"
#define CMD_DHCP_DUMP                           L"dump"

#define CMD_DHCP_ADD_SERVER 	                L"add server"
#define CMD_DHCP_ADD_HELPER                     L"add helper"
#define CMD_DHCP_DELETE_SERVER                  L"delete server"
#define CMD_DHCP_DELETE_HELPER                  L"delete helper"
#define CMD_DHCP_SHOW_SERVER                    L"show server"
#define CMD_DHCP_SHOW_HELPER                    L"show helper"



#define HLP_DHCP_HELP1                          2601
#define HLP_DHCP_HELP1_EX                       2602
#define HLP_DHCP_HELP2                          2604
#define HLP_DHCP_HELP2_EX                       2605
#define HLP_DHCP_HELP3                          2606
#define HLP_DHCP_HELP3_EX                       2607
#define HLP_DHCP_HELP4                          2608
#define HLP_DHCP_HELP4_EX                       2609
#define HLP_DHCP_LIST                           2610
#define HLP_DHCP_LIST_EX                        2611
#define HLP_DHCP_DUMP                           2612
#define HLP_DHCP_DUMP_EX                        2613

#define HLP_DHCP_CONTEXT_SERVER                 2701
#define HLP_DHCP_CONTEXT_SERVER_EX              2702
#define HLP_SRVR_CONTEXT_SCOPE                  2703
#define HLP_SRVR_CONTEXT_SCOPE_EX               2704
#define HLP_SRVR_CONTEXT_MSCOPE                 2705
#define HLP_SRVR_CONTEXT_MSCOPE_EX              2706

#define HLP_DHCP_ADD_SERVER                     3101
#define HLP_DHCP_ADD_SERVER_EX                  3102
#define HLP_DHCP_ADD_HELPER                     3103
#define HLP_DHCP_ADD_HELPER_EX                  3104


#define HLP_DHCP_DELETE_SERVER                  3201
#define HLP_DHCP_DELETE_SERVER_EX               3202
#define HLP_DHCP_DELETE_HELPER                  3203
#define HLP_DHCP_DELETE_HELPER_EX               3204


#define HLP_DHCP_SHOW_SERVER                    3401
#define HLP_DHCP_SHOW_SERVER_EX                 3402
#define HLP_DHCP_SHOW_HELPER                    3403
#define HLP_DHCP_SHOW_HELPER_EX                 3404


#define HLP_GROUP_ADD                           3501
#define HLP_GROUP_CHECK                         3502
#define HLP_GROUP_DELETE                        3503
#define HLP_GROUP_REDO                          3504
#define HLP_GROUP_SET                           3505
#define HLP_GROUP_SHOW                          3506
#define HLP_GROUP_EXPORT                        3507
#define HLP_GROUP_IMPORT                        3508

#define DMP_DHCP_ADD_SERVER                     4101
#define MSG_DHCP_SERVER_ADDING                  4102
#define DMP_DHCP_DELETE_SERVER                  4103
#define MSG_DHCP_SERVER_DELETING                4104
#define DMP_DHCP_SHOW_SERVER                    4105
#define MSG_DHCP_SERVER_SHOW_INFO_ARRAY         4106
#define MSG_DHCP_SERVER_SHOW_INFO               4107
#define DMP_DHCP_ADD_HELPER                     4108
#define DMP_DHCP_DELETE_HELPER                  4109
#define DMP_DHCP_SHOW_HELPER                    4110
#define DMP_DHCP_SCRIPTHEADER                   4111
#define DMP_DHCP_SCRIPTFOOTER                   4112
#define MSG_DHCP_SERVER_SHOW_INFO_NODS          4113

#define EMSG_DHCP_ERROR_SUCCESS                 6100
#define EMSG_DHCP_ADD_SERVER                    6101
#define EMSG_DHCP_DELETE_SERVER                 6102
#define EMSG_DHCP_SHOW_SERVER                   6103

#define EMSG_DHCP_INCOMPLETE_COMMAND            6104
#define EMSG_DHCP_UNABLE_TO_CREATE_FILE         6105
#define EMSG_INSTALL_KEY_FAILED                 6106
#define	EMSG_UNINSTALL_KEY_FAILED               6107
#define	EMSG_UNINSTALL_SUBKEYS                  6108
#define EMSG_RSVD_KEYWORD                       6109
#define EMSG_DHCP_FAILED_TO_LOAD_HELPER         6110
#define EMSG_DHCP_DSINIT_FAILED                 6111
#define EMSG_DHCP_INVALID_PARAMETER             6112
#define EMSG_DHCP_OUT_OF_MEMORY                 6113
#define EMSG_DHCP_NO_MORE_ITEMS                 6114
#define EMSG_DHCP_MORE_DATA                     6115
#define EMSG_DHCP_INVALID_TAG                   6116
#define EMSG_DHCP_DUPLICATE_TAG                 6117
#define EMSG_DHCP_DUMP                          6118

#define CMD_SRVR_HELP1                          L"help"
#define CMD_SRVR_HELP2                          L"/?"
#define CMD_SRVR_HELP3                          L"-?"
#define CMD_SRVR_HELP4                          L"?"
#define CMD_SRVR_LIST                           L"list"
#define CMD_SRVR_DUMP                           L"dump"


#define CMD_SRVR_ADD_CLASS                      L"add      class"
#define CMD_SRVR_ADD_HELPER                     L"add      helper"
#define CMD_SRVR_ADD_MSCOPE                     L"add      mscope"
#define CMD_SRVR_ADD_OPTIONDEF                  L"add      optiondef"
#define CMD_SRVR_ADD_SCOPE                      L"add      scope"

#define CMD_SRVR_DELETE_CLASS                   L"delete   class"
#define CMD_SRVR_DELETE_HELPER                  L"delete   helper"
#define CMD_SRVR_DELETE_MSCOPE                  L"delete   mscope"
#define CMD_SRVR_DELETE_OPTIONDEF               L"delete   optiondef"
#define CMD_SRVR_DELETE_OPTIONVALUE             L"delete   optionvalue"
#define CMD_SRVR_DELETE_SCOPE                   L"delete   scope"
#define CMD_SRVR_DELETE_SUPERSCOPE              L"delete   superscope"
#define CMD_SRVR_DELETE_DNSCREDENTIALS          L"delete   dnscredentials"

#define CMD_SRVR_REDO_AUTH                      L"initiate auth"
#define CMD_SRVR_INITIATE_RECONCILE             L"initiate reconcile"

#define CMD_SRVR_EXPORT                         L"export"
#define CMD_SRVR_IMPORT                         L"import"

#define CMD_SRVR_SET_BACKUPINTERVAL             L"set      databasebackupinterval"
#define CMD_SRVR_SET_BACKUPPATH                 L"set      databasebackuppath"
#define CMD_SRVR_SET_DATABASECLEANUPINTERVAL    L"set      databasecleanupinterval"
#define CMD_SRVR_SET_DATABASELOGGINGFLAG        L"set      databaseloggingflag"
#define CMD_SRVR_SET_DATABASENAME               L"set      databasename"
#define CMD_SRVR_SET_DATABASEPATH               L"set      databasepath"
#define CMD_SRVR_SET_DATABASERESTOREFLAG        L"set      databaserestoreflag"
#define CMD_SRVR_SET_OPTIONVALUE                L"set      optionvalue"
#define CMD_SRVR_SET_SERVER                     L"set      server"
#define CMD_SRVR_SET_USERCLASS                  L"set      userclass"
#define CMD_SRVR_SET_VENDORCLASS                L"set      vendorclass"
#define CMD_SRVR_SET_DNSCREDENTIALS             L"set      dnscredentials"
#define CMD_SRVR_SET_DETECTCONFLICTRETRY        L"set      detectconflictretry"
#define CMD_SRVR_SET_DNSCONFIG                  L"set      dnsconfig"
#define CMD_SRVR_SET_AUDITLOG                   L"set      auditlog"

#define CMD_SRVR_SHOW_ALL                       L"show     all"
#define CMD_SRVR_SHOW_BINDINGS                  L"show     bindings"
#define CMD_SRVR_SHOW_CLASS                     L"show     class"
#define CMD_SRVR_SHOW_SERVERCONFIG              L"show     dbproperties"
#define CMD_SRVR_SHOW_HELPER                    L"show     helper"
#define CMD_SRVR_SHOW_MIBINFO                   L"show     mibinfo"
#define CMD_SRVR_SHOW_MSCOPE                    L"show     mscope"
#define CMD_SRVR_SHOW_OPTIONDEF                 L"show     optiondef"
#define CMD_SRVR_SHOW_OPTIONVALUE               L"show     optionvalue"
#define CMD_SRVR_SHOW_SCOPE                     L"show     scope"
#define CMD_SRVR_SHOW_SUPERSCOPE                L"show     superscope"
#define CMD_SRVR_SHOW_SERVER                    L"show     server"
#define CMD_SRVR_SHOW_SERVERSTATUS              L"show     serverstatus"
#define CMD_SRVR_SHOW_USERCLASS                 L"show     userclass"
#define CMD_SRVR_SHOW_VENDORCLASS               L"show     vendorclass"
#define CMD_SRVR_SHOW_DNSCREDENTIALS            L"show     dnscredentials"
#define CMD_SRVR_SHOW_VERSION                   L"show     version"
#define CMD_SRVR_SHOW_DETECTCONFLICTRETRY       L"show     detectconflictretry"
#define CMD_SRVR_SHOW_DNSCONFIG                 L"show     dnsconfig"
#define CMD_SRVR_SHOW_AUDITLOG                  L"show     auditlog"



#define HLP_SRVR_HELP1                          26001
#define HLP_SRVR_HELP1_EX                       26002
#define HLP_SRVR_HELP2                          26004
#define HLP_SRVR_HELP2_EX                       26005
#define HLP_SRVR_HELP3                          26006
#define HLP_SRVR_HELP3_EX                       26007
#define HLP_SRVR_HELP4                          26008
#define HLP_SRVR_HELP4_EX                       26009
#define HLP_SRVR_LIST                           26010
#define HLP_SRVR_LIST_EX                        26011
#define HLP_SRVR_DUMP                           26012
#define HLP_SRVR_DUMP_EX                        26013


#define HLP_SRVR_ADD_CLASS                      31001
#define HLP_SRVR_ADD_CLASS_EX                   31002
#define HLP_SRVR_ADD_HELPER                     31003
#define HLP_SRVR_ADD_HELPER_EX                  31004
#define HLP_SRVR_ADD_MSCOPE                     31005
#define HLP_SRVR_ADD_MSCOPE_EX                  31006
#define HLP_SRVR_ADD_OPTIONDEF                  31007
#define HLP_SRVR_ADD_OPTIONDEF_EX               31008
#define HLP_SRVR_ADD_SCOPE                      31009
#define HLP_SRVR_ADD_SCOPE_EX                   31010

#define HLP_SRVR_DELETE_CLASS                   32001
#define HLP_SRVR_DELETE_CLASS_EX                32002
#define HLP_SRVR_DELETE_HELPER                  32003
#define HLP_SRVR_DELETE_HELPER_EX               32004
#define HLP_SRVR_DELETE_MSCOPE                  32005
#define HLP_SRVR_DELETE_MSCOPE_EX               32006
#define HLP_SRVR_DELETE_OPTIONDEF               32007
#define HLP_SRVR_DELETE_OPTIONDEF_EX            32008
#define HLP_SRVR_DELETE_OPTIONVALUE             32009
#define HLP_SRVR_DELETE_OPTIONVALUE_EX          32010
#define HLP_SRVR_DELETE_SCOPE                   32011
#define HLP_SRVR_DELETE_SCOPE_EX                32012
#define HLP_SRVR_DELETE_SUPERSCOPE              32013
#define HLP_SRVR_DELETE_SUPERSCOPE_EX           32014
#define HLP_SRVR_DELETE_DNSCREDENTIALS          32015
#define HLP_SRVR_DELETE_DNSCREDENTIALS_EX       32016

#define HLP_SRVR_REDO_AUTH                      33001
#define HLP_SRVR_REDO_AUTH_EX                   33002
#define HLP_SRVR_INITIATE_RECONCILE             33003
#define HLP_SRVR_INITIATE_RECONCILE_EX          33004
#define HLP_SRVR_EXPORT                         33005
#define HLP_SRVR_EXPORT_EX                      33006
#define HLP_SRVR_IMPORT                         33007
#define HLP_SRVR_IMPORT_EX                      33008

#define HLP_SRVR_SET_BACKUPINTERVAL             34001
#define HLP_SRVR_SET_BACKUPINTERVAL_EX          34002
#define HLP_SRVR_SET_BACKUPPATH                 34003
#define HLP_SRVR_SET_BACKUPPATH_EX              34004
#define HLP_SRVR_SET_DATABASECLEANUPINTERVAL    34005
#define HLP_SRVR_SET_DATABASECLEANUPINTERVAL_EX 34006
#define HLP_SRVR_SET_DATABASELOGGINGFLAG        34007
#define HLP_SRVR_SET_DATABASELOGGINGFLAG_EX     34008
#define HLP_SRVR_SET_DATABASENAME               34009
#define HLP_SRVR_SET_DATABASENAME_EX            34010
#define HLP_SRVR_SET_DATABASEPATH               34011
#define HLP_SRVR_SET_DATABASEPATH_EX            34012
#define HLP_SRVR_SET_DATABASERESTOREFLAG        34013
#define HLP_SRVR_SET_DATABASERESTOREFLAG_EX     34014
#define HLP_SRVR_SET_OPTIONVALUE                34015
#define HLP_SRVR_SET_OPTIONVALUE_EX             34016
#define HLP_SRVR_SET_SERVER                     34017
#define HLP_SRVR_SET_SERVER_EX                  34018
#define HLP_SRVR_SET_USERCLASS                  34019
#define HLP_SRVR_SET_USERCLASS_EX               34020
#define HLP_SRVR_SET_VENDORCLASS                34021
#define HLP_SRVR_SET_VENDORCLASS_EX             34022
#define HLP_SRVR_SET_DETECTCONFLICTRETRY        34023
#define HLP_SRVR_SET_DETECTCONFLICTRETRY_EX     34024
#define HLP_SRVR_SET_DNSCONFIG                  34025
#define HLP_SRVR_SET_DNSCONFIG_EX               34026
#define HLP_SRVR_SET_AUDITLOG                   34027
#define HLP_SRVR_SET_AUDITLOG_EX                34028
#define HLP_SRVR_SET_DNSCREDENTIALS             34029
#define HLP_SRVR_SET_DNSCREDENTIALS_EX          34030

#define HLP_SRVR_SHOW_ALL                       35001
#define HLP_SRVR_SHOW_ALL_EX                    35002
#define HLP_SRVR_SHOW_CLASS                     35003
#define HLP_SRVR_SHOW_CLASS_EX                  35004
#define HLP_SRVR_SHOW_HELPER                    35005
#define HLP_SRVR_SHOW_HELPER_EX                 35006
#define HLP_SRVR_SHOW_MIBINFO                   35007
#define HLP_SRVR_SHOW_MIBINFO_EX                35008
#define HLP_SRVR_SHOW_MSCOPE                    35009
#define HLP_SRVR_SHOW_MSCOPE_EX                 35010
#define HLP_SRVR_SHOW_OPTIONDEF                 35011
#define HLP_SRVR_SHOW_OPTIONDEF_EX              35012
#define HLP_SRVR_SHOW_OPTIONVALUE               35013
#define HLP_SRVR_SHOW_OPTIONVALUE_EX            35014
#define HLP_SRVR_SHOW_SCOPE                     35015
#define HLP_SRVR_SHOW_SCOPE_EX                  35016
#define HLP_SRVR_SHOW_SERVER                    35017
#define HLP_SRVR_SHOW_SERVER_EX                 35018
#define HLP_SRVR_SHOW_SERVERCONFIG              35019
#define HLP_SRVR_SHOW_SERVERCONFIG_EX           35020
#define HLP_SRVR_SHOW_SERVERSTATUS              35021
#define HLP_SRVR_SHOW_SERVERSTATUS_EX           35022
#define HLP_SRVR_SHOW_USERCLASS                 35023
#define HLP_SRVR_SHOW_USERCLASS_EX              35024
#define HLP_SRVR_SHOW_VENDORCLASS               35025
#define HLP_SRVR_SHOW_VENDORCLASS_EX            35026
#define HLP_SRVR_SHOW_VERSION                   35027
#define HLP_SRVR_SHOW_VERSION_EX                35028
#define HLP_SRVR_SHOW_BINDINGS                  35029
#define HLP_SRVR_SHOW_BINDINGS_EX               35030
#define HLP_SRVR_SHOW_DETECTCONFLICTRETRY       35031
#define HLP_SRVR_SHOW_DETECTCONFLICTRETRY_EX    35032
#define HLP_SRVR_SHOW_DNSCONFIG                 35033
#define HLP_SRVR_SHOW_DNSCONFIG_EX              35034
#define HLP_SRVR_SHOW_AUDITLOG                  35035
#define HLP_SRVR_SHOW_AUDITLOG_EX               35036
#define HLP_SRVR_SHOW_DNSCREDENTIALS            35037
#define HLP_SRVR_SHOW_DNSCREDENTIALS_EX         35038
#define HLP_SRVR_SHOW_SUPERSCOPE                35039
#define HLP_SRVR_SHOW_SUPERSCOPE_EX             35040

#define DMP_SRVR_ADD_CLASS                      41101
#define DMP_SRVR_ADD_HELPER                     41102
#define DMP_SRVR_ADD_MSCOPE                     41103
#define DMP_SRVR_ADD_OPTIONDEF                  41104
#define DMP_SRVR_ADD_SCOPE                      41105
#define DMP_SRVR_ADD_SUPER_SCOPE                41106

#define DMP_SRVR_DELETE_CLASS                   41201
#define DMP_SRVR_DELETE_HELPER                  41202
#define DMP_SRVR_DELETE_MSCOPE                  41203
#define DMP_SRVR_DELETE_OPTIONDEF               41204
#define DMP_SRVR_DELETE_OPTIONVALUE             41005
#define DMP_SRVR_DELETE_SCOPE                   41206
#define DMP_SRVR_DELETE_SUPERSCOPE              41207

#define DMP_SRVR_REDO_AUTH                      41301

#define DMP_SRVR_SET_BACKUPINTERVAL             41401
#define DMP_SRVR_SET_BACKUPPATH                 41402
#define DMP_SRVR_SET_DATABASECLEANUPINTERVAL    41403
#define DMP_SRVR_SET_DATABASELOGGINGFLAG        41404
#define DMP_SRVR_SET_DATABASENAME               41405
#define DMP_SRVR_SET_DATABASEPATH               41406
#define DMP_SRVR_SET_DATABASERESTOREFLAG        41407
#define DMP_SRVR_SET_OPTIONVALUE                41408
#define DMP_SRVR_SET_SERVER                     41409
#define DMP_SRVR_SET_CLASSNAME                  41410
#define DMP_SRVR_SET_VENDORNAME                 41411
#define DMP_SRVR_SET_OPTIONVALUE_CLASS          41412
#define DMP_SRVR_SET_DETECTCONFLICTRETRY        41413
#define DMP_SRVR_SET_DNSCONFIG                  41414
#define DMP_SRVR_SET_AUDITLOG                   41415
#define DMP_SRVR_SET_OPTIONVALUE_USER           41416
#define DMP_SRVR_SET_OPTIONVALUE_VENDOR         41417


#define DMP_SRVR_SHOW_ALL                       41501
#define DMP_SRVR_SHOW_CLASS                     41502
#define DMP_SRVR_SHOW_HELPER                    41503
#define DMP_SRVR_SHOW_MIBINFO                   41504
#define DMP_SRVR_SHOW_MSCOPE                    41505
#define DMP_SRVR_SHOW_OPTIONDEF                 41506
#define DMP_SRVR_SHOW_OPTIONVALUE               41507
#define DMP_SRVR_SHOW_SCOPE                     41508
#define DMP_SRVR_SHOW_SERVER                    41509
#define DMP_SRVR_SHOW_SERVERCONFIG              41510
#define DMP_SRVR_SHOW_SERVERSTATUS              41511
#define DMP_SRVR_SHOW_CLASSNAME                 41512
#define DMP_SRVR_SHOW_VENDORNAME                41513

#define DMP_SRVR_OPTION_NONVENDOR               42001
#define DMP_SRVR_ADD_OPTIONDEF_VENDOR           42002
#define DMP_SRVR_ADD_OPTIONDEF_NONE             42003
#define DMP_SRVR_ADD_OPTIONDEF_VENDOR_NONE      42004



#define DMP_SRVR_CLASS_HEADER                   42101
#define DMP_SRVR_CLASS_FOOTER                   42102
#define DMP_SRVR_OPTIONDEF_HEADER               42103
#define DMP_SRVR_OPTIONDEF_FOOTER               42104
#define DMP_SRVR_OPTIONVALUE_HEADER             42105
#define DMP_SRVR_OPTIONVALUE_FOOTER             42106
#define DMP_SRVR_SCOPE_HEADER                   42107
#define DMP_SRVR_SCOPE_FOOTER                   42108
#define DMP_SRVR_SERVER_HEADER                  42109
#define DMP_SRVR_SERVER_FOOTER                  42010
#define DMP_SRVR_MSCOPE_HEADER                  42011
#define DMP_SRVR_MSCOPE_FOOTER                  42012
#define DMP_SCOPE_ADD_IPRANGES_HEADER           42013
#define DMP_SCOPE_ADD_IPRANGES_FOOTER           42014
#define DMP_SCOPE_ADD_EXCLUDERANGES_HEADER      42015
#define DMP_SCOPE_ADD_EXCLUDERANGES_FOOTER      42016
#define DMP_SCOPE_SET_OPTIONVALUE_HEADER        42017
#define DMP_SCOPE_SET_OPTIONVALUE_FOOTER        42018
#define DMP_SCOPE_SET_RESERVEDIP_HEADER         42019
#define DMP_SCOPE_SET_RESERVEDIP_FOOTER         42020
#define DMP_MSCOPE_ADD_IPRANGES_HEADER          42021
#define DMP_MSCOPE_ADD_IPRANGES_FOOTER          42022
#define DMP_MSCOPE_ADD_EXCLUDERANGES_HEADER     42023
#define DMP_MSCOPE_ADD_EXCLUDERANGES_FOOTER     42024
#define DMP_SRVR_MSCOPE_SET_EXPIRY              42025
#define DMP_SRVR_SUPER_SCOPE_HEADER             42026
#define DMP_SRVR_SUPER_SCOPE_FOOTER             42027

#define MSG_NO_ENTRY_PT                         51001
#define MSG_DLL_LOAD_FAILED                     51002
#define MSG_DLL_START_FAILED                    51003
#define MSG_NO_HELPER                           51004
#define	MSG_DHCP_NOT_ENOUGH_MEMORY              51005
#define MSG_HELPER_HELP                         51006
#define MSG_SRVR_COMPUTER_NAME                  51007
#define MSG_SRVR_CLASS_INFO                     51008
#define MSG_SRVR_CLASS_DATA                     51009
#define MSG_SRVR_CLASS_DATA_FORMAT              51010
#define MSG_SRVR_CLASS_INFO_ARRAY               51011

#define MSG_SRVR_OPTION_INFO                    51012
#define MSG_SRVR_OPTION_ID                      51013
#define MSG_SRVR_OPTION_NAME                    51014
#define MSG_SRVR_OPTION_COMMENT                 51015
#define MSG_SRVR_OPTION_TYPE1                   51016
#define MSG_SRVR_OPTION                         51017
#define MSG_SRVR_OPTION_COUNT                   51018
#define MSG_SRVR_OPTION_TYPE                    51019
#define MSG_SRVR_OPTION_TYPE_BYTE               51020
#define MSG_SRVR_OPTION_TYPE_WORD               51021
#define MSG_SRVR_OPTION_TYPE_DWORD              51022
#define MSG_SRVR_OPTION_TYPE_DWORDDWORD         51023
#define MSG_SRVR_OPTION_TYPE_IPADDRESS          51024
#define MSG_SRVR_OPTION_TYPE_STRINGDATA         51025
#define MSG_SRVR_OPTION_TYPE_BINARYDATA         51026
#define MSG_SRVR_OPTION_TYPE_ENCAPSULATEDDATA   51027
#define MSG_SRVR_OPTION_TYPE_UNKNOWN            51028
#define MSG_SRVR_OPTION_VALUE                   51029
#define MSG_SRVR_OPTION_VALUE_NUM               51030
#define MSG_SRVR_OPTION_VALUE_LONGNUM           51031
#define MSG_SRVR_OPTION_VALUE_STRING            51032
#define MSG_SRVR_OPTION_VALUE_BINARY            51033
#define MSG_SRVR_OPTION_READ                    51034
#define MSG_SRVR_OPTION_TOTAL                   51035
#define MSG_SRVR_OPTION_PROPS                   51036
#define MSG_SRVR_OPTIONS                        51037
#define MSG_SRVR_CLASS_VENDOR                   51038
#define MSG_SRVR_CLASS_USER                     51039
#define MSG_SRVR_UNKNOWN_FORCEFLAG              51040
#define MSG_SRVR_MIB                            51041
#define MSG_SRVR_MIB_DISCOVERS                  51042
#define MSG_SRVR_MIB_OFFERS                     51043
#define MSG_SRVR_MIB_REQUESTS                   51044
#define MSG_SRVR_MIB_RENEWS                     51045
#define MSG_SRVR_MIB_ACKS                       51055
#define MSG_SRVR_MIB_NAKS                       51056
#define MSG_SRVR_MIB_DECLINES                   51057
#define MSG_SRVR_MIB_RELEASES                   51058
#define MSG_SRVR_MIB_SERVERSTARTTIME            51059
#define MSG_SRVR_MIB_SCOPES                     51060
#define MSG_SRVR_MIB_SCOPES_SUBNET              51061
#define MSG_SRVR_MIB_SCOPES_SUBNET_NUMADDRESSESINUSE  51062
#define MSG_SRVR_MIB_SCOPES_SUBNET_NUMADDRESSESFREE   51063
#define MSG_SRVR_MIB_SCOPES_SUBNET_NUMPENDINGOFFERS   51064

#define MSG_SRVR_SERVER_STATUS                  51065
#define MSG_SRVR_SERVER_ATTRIB                  51067
#define MSG_SRVR_SERVER_ATTRIB_TYPE_BOOL        51068
#define MSG_SRVR_SERVER_ATTRIB_TYPE_ULONG       51069

#define MSG_SRVR_SERVERCONFIG_DATABASENAME             51070
#define MSG_SRVR_SERVERCONFIG_DATABASEPATH             51071
#define MSG_SRVR_SERVERCONFIG_BACKUPPATH               51072
#define MSG_SRVR_SERVERCONFIG_BACKUPINTERVAL           51073
#define MSG_SRVR_SERVERCONFIG_DATABASELOGGINGFLAG      51074
#define MSG_SRVR_SERVERCONFIG_RESTOREFLAG              51075
#define MSG_SRVR_DBPROPERTIES                          51076
#define MSG_SRVR_SERVERCONFIG_DATABASECLEANUPINTERVAL  51078

#define MSG_SRVR_SERVERCONFIG                                     51079
#define MSG_SRVR_VERSION                                          51081           
#define MSG_SRVR_SERVERCONFIG_DATABASENAME_VALUE                  51082
#define MSG_SRVR_SERVERCONFIG_DATABASEPATH_VALUE                  51083
#define MSG_SRVR_SERVERCONFIG_BACKUPPATH_VALUE                    51084
#define MSG_SRVR_SERVERCONFIG_BACKUPINTERVAL_VALUE                51085
#define MSG_SRVR_SERVERCONFIG_DATABASELOGGINGFLAG_VALUE           51086
#define MSG_SRVR_SERVERCONFIG_RESTOREFLAG_VALUE                   51087
#define MSG_SRVR_SERVERCONFIG_DATABASECLEANUPINTERVAL_VALUE       51088
#define MSG_SRVR_SERVERCONFIG_DEBUGFLAG_VALUE                     51089

#define MSG_SRVR_SCOPE                          51090
#define MSG_SRVR_SCOPE_IPADDRESS                51091
#define MSG_SRVR_SCOPE_SUBNETMASK               51092
#define MSG_SRVR_SCOPE_NAME                     51093
#define MSG_SRVR_SCOPE_COMMENT                  51094
#define MSG_SRVR_SCOPE_STATE                    51095
#define MSG_SRVR_SCOPE_COUNT                    51096
#define MSG_SRVR_CLIENT_DURATION_DATE           51097

#define MSG_SRVR_OWNER_NAME                     51098
#define MSG_SRVR_OWNER_NETBIOSNAME              51099
#define MSG_SRVR_OWNER_IPADDRESS                51100

#define MSG_SRVR_MULTICAST_CLIENT_COUNT         51101
#define MSG_SRVR_MULTICAST_SCOPES               51102
#define MSG_SRVR_MULTICAST_SCOPEID              51103
#define MSG_SRVR_OPTIONDEF_TABLE                51104
#define MSG_SRVR_OPTIONDEF_INFO                 51105
#define MSG_SRVR_CLASSNAME                      51106
#define MSG_SRVR_VENDORNAME                     51107
#define MSG_SRVR_OPTION_NONVENDOR               51108
#define MSG_SRVR_OPTION_VENDOR                  51109
#define MSG_SRVR_CLASS_NONE                     51110
#define MSG_SRVR_SCOPE_TABLE                    51111
#define MSG_SRVR_SCOPE_INFO_ACTIVE              51112
#define MSG_SRVR_MSCOPE_TABLE                   51113
#define MSG_SRVR_MSCOPE_INFO_ACTIVE             51114
#define MSG_SRVR_USER_CLASS                     51115
#define MSG_SRVR_VENDOR_CLASS                   51116
#define MSG_SRVR_OPTIONVAL_COUNT                51117
#define MSG_SRVR_CLASS_COUNT                    51118
#define MSG_SRVR_BINDINGS                       51119
#define MSG_SRVR_NO_BINDINGS                    51120
#define MSG_SRVR_BOUNDTOSERVER_TRUE             51121
#define MSG_SRVR_PRIMARY_ADDRESS                51122
#define MSG_SRVR_SUBNET_ADDRESS                 51123
#define MSG_SRVR_IF_DESCRIPTION                 51124
#define MSG_SRVR_IFID                           51125
#define MSG_SRVR_STANDARD_OPTION                51126
#define MSG_SRVR_RECONCILE_SCOPE                51127
#define MSG_SRVR_BOUNDTOSERVER_FALSE            51128
#define MSG_SRVR_SCOPE_INFO_NOTACTIVE           51129
#define MSG_SRVR_MSCOPE_INFO_NOTACTIVE          51130
#define MSG_SRVR_CLASSNAME_NONE                 51131
#define MSG_SRVR_VENDORNAME_NONE                51132
#define MSG_SRVR_CLASS_INFO_VENDOR              51133
#define MSG_SRVR_SERVER_ATTRIB_ISROUGE          51134
#define MSG_SRVR_SERVER_ATTRIB_ISDYNBOOTP       51135
#define MSG_SRVR_SERVER_ATTRIB_ISPARTDSDC       51136
#define MSG_SRVR_SERVER_ATTRIB_ISBINDING        51138
#define MSG_SRVR_SERVER_ATTRIB_ISADMIN          51139
#define MSG_SRVR_TRUE                           51140
#define MSG_SRVR_FALSE                          51141
#define MSG_SRVR_AUDIT_SETTINGS                 51142
#define MSG_SRVR_NEED_RESTART                   51143
#define MSG_SRVR_CHANGE_AUDIT_SETTINGS          51144
#define MSG_SRVR_PING_RETRY                     51145
#define MSG_SRVR_DNS_ENABLED                    51146
#define MSG_SRVR_DNS_DISABLED                   51147
#define MSG_SRVR_UPDATE_DOWNLEVEL_ENABLED       51148
#define MSG_SRVR_UPDATE_DOWNLEVEL_DISABLED      51149
#define MSG_SRVR_CLEANUP_EXPIRED_ENABLED        51150
#define MSG_SRVR_CLEANUP_EXPIRED_DISABLED       51151
#define MSG_SRVR_UPDATE_BOTH_ENABLED            51152
#define MSG_SRVR_UPDATE_BOTH_DISABLED           51153
#define MSG_SRVR_UPDATE_LOOKUP                  51154
#define MSG_SRVR_DNS_OPTIONS                    51155
#define MSG_SRVR_MSCOPE_ADD                     51156
#define MSG_DHCP_NO_OPTIONVALUE_SET             51157
#define MSG_SRVR_DNS_CREDENTIALS                51158
#define MSG_SRVR_SCOPE_INFO_ACTIVE_SWITCHED     51159
#define MSG_SRVR_SCOPE_INFO_NOTACTIVE_SWITCHED  51160
#define MSG_SRVR_RECONCILE_SCOPE_NEEDFIX        51161
#define MSG_SRVR_RECONCILE_SCOPE_NOFIX          51162

#define MSG_SRVR_IMPORT_CLASS_CONFLICT          51200
#define MSG_SRVR_IMPORT_OPTDEF_CONFLICT         51201
#define MSG_SRVR_IMPORT_OPTION_CONFLICT         51202
#define MSG_SRVR_IMPORT_SUBNET_OPTION_CONFLICT  51203
#define MSG_SRVR_IMPORT_RES_OPTION_CONFLICT     51204
#define MSG_SRVR_EXPORT_SUBNET_NOT_FOUND        51205
#define MSG_SRVR_IMPORT_SUBNET_CONFLICT         51206
#define MSG_SRVR_IMPORT_DBENTRY_CONFLICT        51207
#define MSG_SRVR_SSCOPE_NAME                    51208
#define MSG_SRVR_SSCOPE_SCOPE_ADDR_NAME         31209


#define EMSG_SRVR_ERROR_SUCCESS                 52000
#define EMSG_SRVR_INCOMPLETE_COMMAND            52001
#define EMSG_SRVR_UNABLE_TO_CREATE_FILE         52002
#define EMSG_SRVR_NO_COMPUTER_NAME              52007
#define EMSG_SRVR_INVALID_COMPUTER_NAME         52008
#define EMSG_SRVR_UNKNOWN_OPTION_TYPE           52009
#define EMSG_SRVR_VALUE_OUT_OF_RANGE            52010
#define EMSG_SRVR_UNKNOWN_SERVER_ATTRIB         52011
#define EMSG_SRVR_UNKNOWN_SERVER                52012
#define EMSG_SRVR_UNKNOWN_VERSION               52013
#define EMSG_SRVR_FAILED_TO_LOAD_HELPER         52014
#define EMSG_DHCP_ERROR_TEXT                    52015
#define EMSG_SRVR_STRING_ARRAY_OPTIONS          52016

#define EMSG_SRVR_ADD_CLASS                     53001
#define EMSG_SRVR_ADD_HELPER                    53002
#define EMSG_SRVR_ADD_MSCOPE                    53003
#define EMSG_SRVR_ADD_SCOPE                     53004
#define EMSG_SRVR_ADD_OPTIONDEF                 53005

#define EMSG_SRVR_DELETE_CLASS                  53101
#define EMSG_SRVR_DELETE_HELPER                 53102
#define EMSG_SRVR_DELETE_MSCOPE                 53103
#define EMSG_SRVR_DELETE_OPTIONDEF              53104
#define EMSG_SRVR_DELETE_OPTIONVALUE            53105
#define EMSG_SRVR_DELETE_SCOPE                  53106
#define EMSG_SRVR_DELETE_SUPERSCOPE             53107
#define EMSG_SRVR_DELETE_DNSCREDENTIALS         53108

#define EMSG_SRVR_REDO_AUTH                     53201
#define EMSG_SRVR_INITIATE_RECONCILE            53202
#define EMSG_SRVR_EXPORT                        53203
#define EMSG_SRVR_IMPORT                        53204
#define EMSG_SRVR_EXIM_LOCAL                    53205

#define EMSG_SRVR_SET_BACKUPINTERVAL            53301
#define EMSG_SRVR_SET_BACKUPPATH                53302
#define EMSG_SRVR_SET_DATABASECLEANUPINTERVAL   53303
#define EMSG_SRVR_SET_DATABASELOGGINGFLAG       53304
#define EMSG_SRVR_SET_DATABASENAME              53305
#define EMSG_SRVR_SET_DATABASEPATH              53306
#define EMSG_SRVR_SET_DATABASERESTOREFLAG       53307
#define EMSG_SRVR_SET_OPTIONVALUE               53308
#define EMSG_SRVR_SET_SERVER                    53309
#define EMSG_SRVR_SET_USERCLASS                 53310
#define EMSG_SRVR_SET_VENDORCLASS               53311
#define EMSG_SRVR_SET_DETECTCONFLICTRETRY       53312
#define EMSG_SRVR_SET_DNSCONFIG                 53313
#define EMSG_SRVR_SET_AUDITLOG                  53314
#define EMSG_SRVR_SET_DNSCREDENTIALS            53315

#define EMSG_SRVR_SHOW_ALL                      53401
#define EMSG_SRVR_SHOW_CLASS                    53402
#define EMSG_SRVR_SHOW_HELPER                   53403
#define EMSG_SRVR_SHOW_MIBINFO                  53404
#define EMSG_SRVR_SHOW_MSCOPE                   53405
#define EMSG_SRVR_SHOW_OPTIONDEF                53406
#define EMSG_SRVR_SHOW_OPTIONVALUE              53407
#define EMSG_SRVR_SHOW_SCOPE                    53408
#define EMSG_SRVR_SHOW_SERVER                   53409
#define EMSG_SRVR_SHOW_SERVERCONFIG             53410
#define EMSG_SRVR_SHOW_SERVERSTATUS             53411
#define EMSG_SRVR_SHOW_USERCLASS                53412
#define EMSG_SRVR_SHOW_VENDORCLASS              53413
#define EMSG_SRVR_INVALID_VERSION               53414
#define EMSG_SRVR_SHOW_BINDINGS                 53415
#define EMSG_SRVR_BINDINGS_SUPPORT              53416
#define EMSG_SRVR_RECONCILE_SCOPE               53417
#define EMSG_SRVR_SHOW_DETECTCONFLICTRETRY      53418
#define EMSG_SRVR_SHOW_DNSCONFIG                53419
#define EMSG_SRVR_SHOW_AUDITLOG                 53420
#define EMSG_SRVR_NO_SHOWDNSCONFIG              53421
#define EMSG_SRVR_NO_SETDNSCONFIG               53422
#define EMSG_SRVR_INVALID_OPTIONTYPE            53423
#define EMSG_SRVR_INVALID_DIRECTORY             53424
#define EMSG_SRVR_SHOW_DNSCREDENTIALS           53425
#define EMSG_SRVR_NEED_DNS_CREDENTIALS_SUPPORT  53426

#define CMD_SCOPE_HELP1                          L"help"
#define CMD_SCOPE_HELP2                          L"/?"
#define CMD_SCOPE_HELP3                          L"-?"
#define CMD_SCOPE_HELP4                          L"?"
#define CMD_SCOPE_LIST                           L"list"
#define CMD_SCOPE_DUMP                           L"dump"

#define CMD_SCOPE_ADD_IPRANGE                    L"add      iprange"
#define CMD_SCOPE_ADD_EXCLUDERANGE               L"add      excluderange"
#define CMD_SCOPE_ADD_RESERVEDIP                 L"add      reservedip"

#define CMD_SCOPE_CHECK_DATABASE                 L"initiate reconcile"

#define CMD_SCOPE_DELETE_IPRANGE                 L"delete   iprange"
#define CMD_SCOPE_DELETE_EXCLUDERANGE            L"delete   excluderange"
#define CMD_SCOPE_DELETE_RESERVEDIP              L"delete   reservedip"
#define CMD_SCOPE_DELETE_OPTIONVALUE             L"delete   optionvalue"
#define CMD_SCOPE_DELETE_RESERVEDOPTIONVALUE     L"delete   reservedoptionvalue"
#define CMD_SCOPE_DELETE_CLIENT                  L"delete   lease"

#define CMD_SCOPE_SET_COMMENT                    L"set      comment"
#define CMD_SCOPE_SET_NAME                       L"set      name"
#define CMD_SCOPE_SET_OPTIONVALUE                L"set      optionvalue"
#define CMD_SCOPE_SET_RESERVEDOPTIONVALUE        L"set      reservedoptionvalue"
#define CMD_SCOPE_SET_STATE                      L"set      state"
#define CMD_SCOPE_SET_SUPERSCOPE                 L"set      superscope"
#define CMD_SCOPE_SET_SCOPE                      L"set      scope"

#define CMD_SCOPE_SHOW_CLIENTS                   L"show     clients"
#define CMD_SCOPE_SHOW_CLIENTSV5                 L"show     clientsv5"
#define CMD_SCOPE_SHOW_IPRANGE                   L"show     iprange"
#define CMD_SCOPE_SHOW_EXCLUDERANGE              L"show     excluderange"
#define CMD_SCOPE_SHOW_RESERVEDIP                L"show     reservedip"
#define CMD_SCOPE_SHOW_OPTIONVALUE               L"show     optionvalue"
#define CMD_SCOPE_SHOW_RESERVEDOPTIONVALUE       L"show     reservedoptionvalue"
#define CMD_SCOPE_SHOW_SCOPE                     L"show     scope"
#define CMD_SCOPE_SHOW_STATE                     L"show     state"
#define CMD_SCOPE_SHOW_MIBINFO                   L"show     mibinfo"

#define HLP_SCOPE_HELP1                          76001
#define HLP_SCOPE_HELP1_EX                       26002
#define HLP_SCOPE_HELP2                          76004
#define HLP_SCOPE_HELP2_EX                       76005
#define HLP_SCOPE_HELP3                          76006
#define HLP_SCOPE_HELP3_EX                       76007
#define HLP_SCOPE_HELP4                          76008
#define HLP_SCOPE_HELP4_EX                       76009
#define HLP_SCOPE_LIST                           76010
#define HLP_SCOPE_LIST_EX                        76011
#define HLP_SCOPE_DUMP                           76012
#define HLP_SCOPE_DUMP_EX                        76013


#define HLP_SCOPE_ADD_IPRANGE                    81001
#define HLP_SCOPE_ADD_IPRANGE_EX                 81002
#define HLP_SCOPE_ADD_EXCLUDERANGE               81003
#define HLP_SCOPE_ADD_EXCLUDERANGE_EX            81004
#define HLP_SCOPE_ADD_RESERVEDIP                 81005
#define HLP_SCOPE_ADD_RESERVEDIP_EX              81006

#define HLP_SCOPE_DELETE_IPRANGE                 82001
#define HLP_SCOPE_DELETE_IPRANGE_EX              82002
#define HLP_SCOPE_DELETE_EXCLUDERANGE            82003
#define HLP_SCOPE_DELETE_EXCLUDERANGE_EX         82004
#define HLP_SCOPE_DELETE_RESERVEDIP              82005
#define HLP_SCOPE_DELETE_RESERVEDIP_EX           82006
#define HLP_SCOPE_DELETE_OPTIONVALUE             82007
#define HLP_SCOPE_DELETE_OPTIONVALUE_EX          82008
#define HLP_SCOPE_DELETE_RESERVEDOPTIONVALUE     82009
#define HLP_SCOPE_DELETE_RESERVEDOPTIONVALUE_EX  82010
#define HLP_SCOPE_DELETE_CLIENT                  82011
#define HLP_SCOPE_DELETE_CLIENT_EX               82012

#define HLP_SCOPE_CHECK_DATABASE                 83001
#define HLP_SCOPE_CHECK_DATABASE_EX              83002

#define HLP_SCOPE_SET_COMMENT                    84001
#define HLP_SCOPE_SET_COMMENT_EX                 84002
#define HLP_SCOPE_SET_NAME                       84003
#define HLP_SCOPE_SET_NAME_EX                    84004
#define HLP_SCOPE_SET_STATE                      84005
#define HLP_SCOPE_SET_STATE_EX                   84006
#define HLP_SCOPE_SET_OPTIONVALUE                84007
#define HLP_SCOPE_SET_OPTIONVALUE_EX             84008
#define HLP_SCOPE_SET_RESERVEDOPTIONVALUE        84009
#define HLP_SCOPE_SET_RESERVEDOPTIONVALUE_EX     84010
#define HLP_SCOPE_SET_SCOPE                      84011
#define HLP_SCOPE_SET_SCOPE_EX                   84012
#define HLP_SCOPE_SET_SUPERSCOPE                 84013
#define HLP_SCOPE_SET_SUPERSCOPE_EX              84014


#define HLP_SCOPE_SHOW_CLIENTS                   85001
#define HLP_SCOPE_SHOW_CLIENTS_EX                85002
#define HLP_SCOPE_SHOW_CLIENTSV5                 85003
#define HLP_SCOPE_SHOW_CLIENTSV5_EX              85004
#define HLP_SCOPE_SHOW_RESERVEDIP                85005
#define HLP_SCOPE_SHOW_RESERVEDIP_EX             85006
#define HLP_SCOPE_SHOW_MIBINFO                   85007
#define HLP_SCOPE_SHOW_MIBINFO_EX                85008
#define HLP_SCOPE_SHOW_IPRANGE                   85009
#define HLP_SCOPE_SHOW_IPRANGE_EX                85010
#define HLP_SCOPE_SHOW_EXCLUDERANGE              85011
#define HLP_SCOPE_SHOW_EXCLUDERANGE_EX           85012
#define HLP_SCOPE_SHOW_OPTIONVALUE               85013
#define HLP_SCOPE_SHOW_OPTIONVALUE_EX            85014
#define HLP_SCOPE_SHOW_SCOPE                     85015
#define HLP_SCOPE_SHOW_SCOPE_EX                  85016
#define HLP_SCOPE_SHOW_RESERVEDOPTIONVALUE       85017
#define HLP_SCOPE_SHOW_RESERVEDOPTIONVALUE_EX    85018
#define HLP_SCOPE_SHOW_STATE                     85019
#define HLP_SCOPE_SHOW_STATE_EX                  85020


#define DMP_SCOPE_ADD_IPRANGE                    91101
#define DMP_SCOPE_ADD_EXCLUDERANGE               91102
#define DMP_SCOPE_ADD_RESERVEDIP                 91103

#define DMP_SCOPE_DELETE_IPRANGE                 91201
#define DMP_SCOPE_DELETE_EXCLUDERANGE            91202
#define DMP_SCOPE_DELETE_RESERVEDIP              91203
#define DMP_SCOPE_DELETE_OPTIONVALUE             91204
#define DMP_SCOPE_DELETE_RESERVEDOPTIONVALUE     91005

#define DMP_SCOPE_CHECK_DATABASE                 91301

#define DMP_SCOPE_SET_COMMENT                    91401
#define DMP_SCOPE_SET_SUPERSCOPE                 91402
#define DMP_SCOPE_SET_STATE                      91403
#define DMP_SCOPE_SET_SCOPE                      91404
#define DMP_SCOPE_SET_NAME                       91405
#define DMP_SCOPE_SET_OPTIONVALUE                91406
#define DMP_SCOPE_SET_RESERVEDOPTIONVALUE        91407
#define DMP_SCOPE_SET_OPTIONVALUE_CLASS          91408
#define DMP_SCOPE_SET_RESERVEDOPTIONVALUE_CLASS  91409
#define DMP_SCOPE_SET_OPTIONVALUE_USER           91410
#define DMP_SCOPE_SET_OPTIONVALUE_VENDOR         91411
#define DMP_SCOPE_SET_RESERVEDOPTIONVALUE_USER   91412
#define DMP_SCOPE_SET_RESERVEDOPTIONVALUE_VENDOR 91413


#define DMP_SCOPE_SHOW_CLIENTS                   91501
#define DMP_SCOPE_SHOW_CLIENTSV5                 91502
#define DMP_SCOPE_SHOW_EXCLUDERANGE              91503
#define DMP_SCOPE_SHOW_MIBINFO                   91504
#define DMP_SCOPE_SHOW_IPRANGE                   91505
#define DMP_SCOPE_SHOW_RESERVEDIP                91506
#define DMP_SCOPE_SHOW_OPTIONVALUE               91507
#define DMP_SCOPE_SHOW_SCOPE                     91508
#define DMP_SCOPE_SHOW_RESERVEDOPTIONVALUE       91509
#define DMP_SCOPE_SHOW_STATE                     91510


#define EMSG_SCOPE_ERROR_SUCCESS                 92000
#define EMSG_SCOPE_INCOMPLETE_COMMAND            92001
#define EMSG_SCOPE_UNABLE_TO_CREATE_FILE         92002
#define EMSG_SCOPE_INVALID_SCOPE_NAME            92008
#define EMSG_SCOPE_UNKNOWN_OPTION_TYPE           92009
#define EMSG_SCOPE_VALUE_OUT_OF_RANGE            92010
#define EMSG_SCOPE_NO_SCOPENAME                  92013
#define ERROR_OUT_OF_MEMORY                      92014
#define EMSG_SCOPE_INVALID_IPADDRESS             92015
#define EMSG_DHCP_UNKNOWN_SERVER_ATTRIB         92017
#define EMSG_DHCP_UNKNOWN_OPTION_DATATYPE       92018
#define EMSG_DHCP_LARGE_OPTION_VALUE            92019
#define EMSG_DHCP_VERSION_NOT_SUPPORTED         92020
#define EMSG_DHCP_NO_OPTION_VALUE               92021
#define EMSG_DHCP_FAILED_ENUM_OPTION            92022
#define EMSG_DHCP_FAILED_GETVERSION             92923
#define EMSG_DHCP_UNKNOWN_FORCEFLAG             92023
#define EMSG_DHCP_UNKNOWN_RANGETYPE             92024
#define EMSG_SCOPE_INVALID_HARDWAREADDRESS      92025
#define EMSG_DHCP_CLIENT_NAME_TOOLONG           92026
#define EMSG_DHCP_CLIENT_COMMENT_TOOLONG        92027
#define EMSG_DHCP_INVALID_RESERVATION_TYPE      92028
#define EMSG_DHCP_FAILED_SCAN                   92029
#define EMSG_DHCP_INVALID_DEFAULTSCOPE_PARAM    92030
#define EMSG_DHCP_INVALID_GLOBAL_OPTION         92031
#define EMSG_DHCP_COMMAND_FAILED                92032
#define EMSG_DHCP_COMMAND_FAILED_STRING         92033
#define EMSG_DHCP_COMMAND_PART_FAILED           92034
#define EMSG_SCOPE_INTERNAL_ERROR               92035
#define EMSG_SCOPE_DISPLAY_CLIENTS              92036
#define ERROR_INVALID_COMPUTER_NAME             92037
#define EMSG_SCOPE_INVALID_IPRANGE              92038
#define EMSG_SCOPE_INVALID_STARTADDRESS         92039
#define EMSG_SCOPE_INVALID_ENDADDRESS           92040
#define EMSG_SCOPE_DELETE_CLIENT_FAILED         92041

#define EMSG_SCOPE_ADD_IPRANGE                   93001
#define EMSG_SCOPE_ADD_EXCLUDERANGE              93002
#define EMSG_SCOPE_ADD_RESERVEDIP                93003

#define EMSG_SCOPE_DELETE_IPRANGE                93101
#define EMSG_SCOPE_DELETE_EXCLUDERANGE           93102
#define EMSG_SCOPE_DELETE_RESERVEDIP             93103
#define EMSG_SCOPE_DELETE_OPTIONVALUE            93104
#define EMSG_SCOPE_DELETE_RESERVEDOPTIONVALUE    93105

#define EMSG_SCOPE_CHECK_DATABASE                93201

#define EMSG_SCOPE_SET_COMMENT                   93301
#define EMSG_SCOPE_SET_NAME                      93302
#define EMSG_SCOPE_SET_SCOPE                     93303
#define EMSG_SCOPE_SET_OPTIONVALUE               93304
#define EMSG_SCOPE_SET_RESERVEDOPTIONVALUE       93305
#define EMSG_SCOPE_SET_STATE                     93306
#define EMSG_SCOPE_SET_SUPERSCOPE                93307

#define EMSG_SCOPE_SHOW_CLIENTS                  93401
#define EMSG_SCOPE_SHOW_CLIENTSV5                93402
#define EMSG_SCOPE_SHOW_IPRANGE                  93403
#define EMSG_SCOPE_SHOW_MIBINFO                  93404
#define EMSG_SCOPE_SHOW_EXCLUDERANGE             93405
#define EMSG_SCOPE_SHOW_RESERVEDIP               93406
#define EMSG_SCOPE_SHOW_OPTIONVALUE              93407
#define EMSG_SCOPE_SHOW_SCOPE                    93408
#define EMSG_SCOPE_SHOW_RESERVEDOPTIONVALUE      93409
#define EMSG_SCOPE_SHOW_STATE                    93410
#define EMSG_SCOPE_DEFAULT_LEASE_TIME            93411
#define EMSG_SCOPE_INVALID_EXCLUDERANGE          93412
#define EMSG_DHCP_RECONCILE_SUCCESS              93413

#define MSG_SCOPE_OPTION_INFO                    320150
#define MSG_SCOPE_OPTION_ID                      320151
#define MSG_SCOPE_OPTION_NAME                    320152
#define MSG_SCOPE_OPTION_COMMENT                 320153
#define MSG_SCOPE_OPTION_TYPE1                   320154
#define MSG_SCOPE_OPTION_COUNT                   320155
#define MSG_SCOPE_OPTION_READ                    320156
#define MSG_SCOPE_OPTION_TOTAL                   320157
#define MSG_SCOPE_OPTION_PROPS                   320158
#define MSG_SCOPE_OPTIONS                        320159
#define MSG_SCOPE_CLASS_VENDOR                   320160
#define MSG_SCOPE_CLASS_USER                     320161
#define MSG_SCOPE_RANGE_START                    320162
#define MSG_SCOPE_RANGE_END                      320163
#define MSG_SCOPE_IPRANGE                        320164
#define MSG_SCOPE_EXCLUDERANGE                   320165
#define MSG_SCOPE_RESERVEDIP                     320166
#define MSG_DHCP                                 320167
#define MSG_SCOPE_DHCPBOOTP                      320168
#define MSG_SCOPE_BOOTP                          320169
#define MSG_SCOPE_IPADDRESS                      320170
#define MSG_SCOPE_FIX_REGISTRY                   320171
#define MSG_SCOPE_FIX_DATABASE                   320172
#define MSG_SCOPE_FIX_UNKNOWN                    320173
#define MSG_SCOPE_CLIENT_INFO                    320174
#define MSG_SCOPE_CLIENT_NAME                    320175
#define MSG_SCOPE_CLIENT_HWADDRESS               320176
#define MSG_SCOPE_CLIENT_COMMENT                 320177
#define MSG_SCOPE_CLIENT_TYPE                    320178
#define MSG_SCOPE_CLIENT_HWADDRESS_FORMAT        320179
#define MSG_SCOPE_CLIENT_IPADDRESS               320180
#define MSG_SCOPE_CLIENT_SUBNET_MASK             320181
#define MSG_SCOPE_CLIENT_DURATION                320182
#define MSG_SCOPE_CLIENT_DURATION_STR            320183
#define MSG_SCOPE_CLIENT_DURATION_DATE_STARTS    320184
#define MSG_SCOPE_OWNER_NAME                     320185
#define MSG_SCOPE_OWNER_NETBIOSNAME              320186
#define MSG_SCOPE_OWNER_IPADDRESS                320187
#define MSG_SCOPE_CLIENT_STATE                   320188
#define MSG_SCOPE_CLIENT                         320189
#define MSG_SCOPE_SUPERSCOPE_NAME                320190
#define MSG_SCOPE_SUPERSCOPE_SUBNET              320191
#define MSG_SCOPE_SUPERSCOPE_GROUP               320192
#define MSG_SCOPE_MULTICAST_CLIENT_COUNT         320193
#define MSG_SCOPE_MULTICAST_SCOPES               320194
#define MSG_SCOPE_MULTICAST_SCOPEID              320195
#define MSG_SCOPE_SERVER_INFO                    320196
#define MSG_SCOPE_SERVER_INFO_ARRAY              320197
#define MSG_SCOPE_CLASS_INFO                     320198
#define MSG_SCOPE_CLASS_INFO_ARRAY               320199
#define MSG_SCOPE_CLASS_DATA                     320200
#define MSG_SCOPE_CLASS_DATA_FORMAT              320201
#define MSG_SCOPE_CLIENT_READ                    320202
#define MSG_SCOPE_CLIENT_COUNT                   320203
#define MSG_SCOPE_SERVERS_DELETING               320204
#define MSG_SCOPE_SERVERS_ADDING                 320205
#define MSG_SCOPE_RESERVEDIP_HWADDRESS			 320206
#define MSG_SCOPE_DHCP                           320207
#define MSG_SCOPE_STATE_ACTIVE                   320208
#define MSG_SCOPE_SERVER                         320209
#define MSG_SCOPE_CLIENTS_COUNT                  320210
#define MSG_SCOPE_CLIENTSV5_COUNT                320211
#define MSG_SCOPE_IPRANGE_COUNT                  320212
#define MSG_SCOPE_EXCLUDERANGE_COUNT             320213
#define MSG_SCOPE_RESERVEDIP_COUNT               320214
#define MSG_SCOPE_OPTION_ALL                     320215
#define MSG_SCOPE_OPTION_CLASS                   320216
#define MSG_SCOPE_RESERVEDOPTION_ALL             320217
#define MSG_SCOPE_RESERVEDOPTION_CLASS           320218
#define MSG_SCOPE_IPRANGE_TABLE                  320219
#define MSG_SCOPE_IPRANGE_INFO_DHCP              320220
#define MSG_SCOPE_EXCLUDERANGE_TABLE             320221
#define MSG_SCOPE_EXCLUDERANGE_INFO              320222
#define MSG_SCOPE_RESERVEDIP_TABLE               320223
#define MSG_SCOPE_RESERVEDIP_INFO                320224
#define MSG_SCOPE_CLIENT_TABLE                   320225
#define MSG_SCOPE_CHANGE_CONTEXT                 320226
#define MSG_SCOPE_CLIENT_DURATION_DATE_EXPIRES   320227
#define MSG_SCOPE_STATE_NOTACTIVE                320228
#define MSG_SCOPE_CLIENT_INFO_NEVER              320229
#define MSG_SCOPE_CLIENT_INFO_INACTIVE           320230
#define MSG_MSCOPE_CLIENT_INFO                   320231
#define MSG_SCOPE_IPRANGE_INFO_DHCPONLY          320232
#define MSG_SCOPE_IPRANGE_INFO_DHCPBOOTP         320233
#define MSG_SCOPE_IPRANGE_INFO_BOOTP             320234
#define MSG_SCOPE_IPRANGE_INFO_UNKNOWN           320235
#define MSG_SCOPE_STATE_ACTIVE_SWITCHED          320236
#define MSG_SCOPE_STATE_NOTACTIVE_SWITCHED       320237
#define MSG_SCOPE_CLIENT_TABLE2                  320238
#define MSG_SCOPE_CLIENT_INFO2_NEVER             320239
#define MSG_SCOPE_CLIENT_INFO2_INACTIVE          320240
#define MSG_SCOPE_CLIENT_INFO2                  320241

#define MSG_MSCOPE_MIB                             351041
#define MSG_MSCOPE_MIB_DISCOVERS                   351042
#define MSG_MSCOPE_MIB_OFFERS                      351043
#define MSG_MSCOPE_MIB_REQUESTS                    351044
#define MSG_MSCOPE_MIB_RENEWS                      351045
#define MSG_MSCOPE_MIB_ACKS                        351055
#define MSG_MSCOPE_MIB_NAKS                        351056
#define MSG_MSCOPE_MIB_DECLINES                    351057
#define MSG_MSCOPE_MIB_RELEASES                    351058
#define MSG_MSCOPE_MIB_SERVERSTARTTIME             351059
#define MSG_MSCOPE_MIB_SCOPES                      351060
#define MSG_MSCOPE_MIB_SCOPES_SUBNET               351061
#define MSG_MSCOPE_MIB_SCOPES_SUBNET_NUMADDRESSESINUSE  351062
#define MSG_MSCOPE_MIB_SCOPES_SUBNET_NUMADDRESSESFREE   351063
#define MSG_MSCOPE_MIB_SCOPES_SUBNET_NUMPENDINGOFFERS   351064
#define MSG_MSCOPE_MIB_INFORMS                     351065
#define MSG_MSCOPE_MIB_RECONFIGURES                351066
#define MSG_MSCOPE_OPTION_ALL                      351067
#define MSG_MSCOPE_CHANGE_CONTEXT                  351068


#define CMD_MSCOPE_LIST                           L"list"
#define CMD_MSCOPE_HELP1                          L"help"
#define CMD_MSCOPE_HELP2                          L"/?"
#define CMD_MSCOPE_HELP3                          L"-?"
#define CMD_MSCOPE_HELP4                          L"?"
#define CMD_MSCOPE_DUMP                           L"dump"

#define CMD_MSCOPE_ADD_IPRANGE                    L"add      iprange"
#define CMD_MSCOPE_ADD_EXCLUDERANGE               L"add      excluderange"
    
#define CMD_MSCOPE_CHECK_DATABASE                 L"initiate reconcile"

#define CMD_MSCOPE_DELETE_IPRANGE                 L"delete   iprange"
#define CMD_MSCOPE_DELETE_EXCLUDERANGE            L"delete   excluderange"
#define CMD_MSCOPE_DELETE_OPTIONVALUE             L"delete   optionvalue"
    
#define CMD_MSCOPE_SET_COMMENT                    L"set      comment"
#define CMD_MSCOPE_SET_NAME                       L"set      name"
#define CMD_MSCOPE_SET_STATE                      L"set      state"
#define CMD_MSCOPE_SET_MSCOPE                     L"set      mscope"
#define CMD_MSCOPE_SET_OPTIONVALUE                L"set      optionvalue"
#define CMD_MSCOPE_SET_TTL                        L"set      ttl"
#define CMD_MSCOPE_SET_LEASE                      L"set      lease"
#define CMD_MSCOPE_SET_EXPIRY                     L"set      scopelife"


#define CMD_MSCOPE_SHOW_CLIENTS                   L"show     clients"
#define CMD_MSCOPE_SHOW_IPRANGE                   L"show     iprange"
#define CMD_MSCOPE_SHOW_EXCLUDERANGE              L"show     excluderange"
#define CMD_MSCOPE_SHOW_MSCOPE                    L"show     mscope"
#define CMD_MSCOPE_SHOW_STATE                     L"show     state"
#define CMD_MSCOPE_SHOW_MIBINFO                   L"show     mibinfo"
#define CMD_MSCOPE_SHOW_OPTIONVALUE               L"show     optionvalue"
#define CMD_MSCOPE_SHOW_TTL                       L"show     ttl"
#define CMD_MSCOPE_SHOW_LEASE                     L"show     lease"
#define CMD_MSCOPE_SHOW_EXPIRY                    L"show     scopelife"


#define HLP_MSCOPE_HELP1                          326002
#define HLP_MSCOPE_HELP2                          326004
#define HLP_MSCOPE_HELP2_EX                       326005
#define HLP_MSCOPE_HELP3                          326006
#define HLP_MSCOPE_HELP3_EX                       326007
#define HLP_MSCOPE_HELP4                          326008
#define HLP_MSCOPE_HELP4_EX                       326009
#define HLP_MSCOPE_LIST                           326010
#define HLP_MSCOPE_LIST_EX                        326011
#define HLP_MSCOPE_DUMP                           326012
#define HLP_MSCOPE_DUMP_EX                        326013


#define HLP_MSCOPE_ADD_IPRANGE                    331001
#define HLP_MSCOPE_ADD_IPRANGE_EX                 331002
#define HLP_MSCOPE_ADD_EXCLUDERANGE               331003
#define HLP_MSCOPE_ADD_EXCLUDERANGE_EX            331004

#define HLP_MSCOPE_DELETE_IPRANGE                 332001
#define HLP_MSCOPE_DELETE_IPRANGE_EX              332002
#define HLP_MSCOPE_DELETE_EXCLUDERANGE            332003
#define HLP_MSCOPE_DELETE_EXCLUDERANGE_EX         332004
#define HLP_MSCOPE_DELETE_OPTIONVALUE             332005
#define HLP_MSCOPE_DELETE_OPTIONVALUE_EX          332006

#define HLP_MSCOPE_CHECK_DATABASE                 333001
#define HLP_MSCOPE_CHECK_DATABASE_EX              333002

#define HLP_MSCOPE_SET_MSCOPE                     334001
#define HLP_MSCOPE_SET_MSCOPE_EX                  334002
#define HLP_MSCOPE_SET_STATE                      334003
#define HLP_MSCOPE_SET_STATE_EX                   334004
#define HLP_MSCOPE_SET_NAME                       334005
#define HLP_MSCOPE_SET_NAME_EX                    334006
#define HLP_MSCOPE_SET_COMMENT                    334007
#define HLP_MSCOPE_SET_COMMENT_EX                 334008
#define HLP_MSCOPE_SET_OPTIONVALUE                334009
#define HLP_MSCOPE_SET_OPTIONVALUE_EX             334010
#define HLP_MSCOPE_SET_TTL                        334011
#define HLP_MSCOPE_SET_TTL_EX                     334012
#define HLP_MSCOPE_SET_LEASE                      334013
#define HLP_MSCOPE_SET_LEASE_EX                   334014
#define HLP_MSCOPE_SET_EXPIRY                     334015
#define HLP_MSCOPE_SET_EXPIRY_EX                  334016



#define HLP_MSCOPE_SHOW_MSCOPE                    335001
#define HLP_MSCOPE_SHOW_MSCOPE_EX                 335002
#define HLP_MSCOPE_SHOW_IPRANGE                   335003
#define HLP_MSCOPE_SHOW_IPRANGE_EX                335004
#define HLP_MSCOPE_SHOW_EXCLUDERANGE              335005
#define HLP_MSCOPE_SHOW_EXCLUDERANGE_EX           335006
#define HLP_MSCOPE_SHOW_MIBINFO                   335007
#define HLP_MSCOPE_SHOW_MIBINFO_EX                335008
#define HLP_MSCOPE_SHOW_CLIENTS                   335009
#define HLP_MSCOPE_SHOW_CLIENTS_EX                335010
#define HLP_MSCOPE_SHOW_STATE                     335011
#define HLP_MSCOPE_SHOW_STATE_EX                  335012
#define HLP_MSCOPE_SHOW_OPTIONVALUE               335013
#define HLP_MSCOPE_SHOW_OPTIONVALUE_EX            335014
#define HLP_MSCOPE_SHOW_TTL                       335015
#define HLP_MSCOPE_SHOW_TTL_EX                    335016
#define HLP_MSCOPE_SHOW_LEASE                     335017
#define HLP_MSCOPE_SHOW_LEASE_EX                  335018
#define HLP_MSCOPE_SHOW_EXPIRY                    335019
#define HLP_MSCOPE_SHOW_EXPIRY_EX                 335020



#define DMP_MSCOPE_ADD_IPRANGE                    341101
#define DMP_MSCOPE_ADD_EXCLUDERANGE               341102

#define DMP_MSCOPE_DELETE_IPRANGE                 341201
#define DMP_MSCOPE_DELETE_EXCLUDERANGE            341202

#define DMP_MSCOPE_CHECK_DATABASE                 341301

#define DMP_MSCOPE_SET_MSCOPE                     341401
#define DMP_MSCOPE_SET_NAME                       341402
#define DMP_MSCOPE_SET_COMMENT                    341403
#define DMP_MSCOPE_SET_STATE                      341404

#define DMP_MSCOPE_SHOW_STATE                     341501
#define DMP_MSCOPE_SHOW_IPRANGE                   341502
#define DMP_MSCOPE_SHOW_EXCLUDERANGE              341503
#define DMP_MSCOPE_SHOW_MIBINFO                   341504
#define DMP_MSCOPE_SHOW_MSCOPE                    341505
#define DMP_MSCOPE_SHOW_CLIENTS                   341506

#define EMSG_MSCOPE_ADD_IPRANGE                   393001
#define EMSG_MSCOPE_ADD_EXCLUDERANGE              393002

#define EMSG_MSCOPE_DELETE_IPRANGE                393101
#define EMSG_MSCOPE_DELETE_EXCLUDERANGE           393102
#define EMSG_MSCOPE_DELETE_OPTIONVALUE            393103

#define EMSG_MSCOPE_CHECK_DATABASE                393201

#define EMSG_MSCOPE_SET_COMMENT                   393301
#define EMSG_MSCOPE_SET_NAME                      393302
#define EMSG_MSCOPE_SET_MSCOPE                    393303
#define EMSG_MSCOPE_SET_STATE                     393304
#define EMSG_MSCOPE_SET_OPTIONVALUE               393305
#define EMSG_MSCOPE_SET_TTL                       393396
#define EMSG_MSCOPE_SET_LEASE                     393397
#define EMSG_MSCOPE_SET_EXPIRY                    393398


#define EMSG_MSCOPE_SHOW_CLIENTS                  393401
#define EMSG_MSCOPE_SHOW_IPRANGE                  393402
#define EMSG_MSCOPE_SHOW_MIBINFO                  393403
#define EMSG_MSCOPE_SHOW_EXCLUDERANGE             393404
#define EMSG_MSCOPE_SHOW_MSCOPE                   393405
#define EMSG_MSCOPE_SHOW_STATE                    393406
#define EMSG_MSCOPE_SHOW_OPTIONVALUE              393407
#define EMSG_MSCOPE_SHOW_TTL                      393408
#define EMSG_MSCOPE_SHOW_LEASE                    393409
#define EMSG_MSCOPE_SHOW_EXPIRY                   393410

#define EMSG_MSCOPE_NO_MSCOPENAME                 393411
#define EMSG_MSCOPE_INVALID_MSCOPE_NAME           393412
#define EMSG_MSCOPE_LEASE_NOTSET                  393413
#define EMSG_MSCOPE_IPRANGE_VERIFY                390414

#define MSG_MSCOPE_MSCOPE                         380209
#define MSG_MSCOPE_CLIENTS_COUNT                  380210
#define MSG_MSCOPE_IPRANGE_COUNT                  380212
#define MSG_MSCOPE_EXCLUDERANGE_COUNT             380213
#define MSG_MSCOPE_STATE_ACTIVE                   380214
#define MSG_MSCOPE_STATE_NOTACTIVE                380215
#define MSG_MSCOPE_MIB_MSCOPENAME                 380216
#define MSG_MSCOPE_MIB_MSCOPEID                   380217
#define MSG_MSCOPE_TTL                            380218
#define MSG_MSCOPE_LEASE                          380219
#define MSG_MSCOPE_EXPIRY                         380220
#define MSG_MSCOPE_INFINITE_EXPIRATION            380221
#define MSG_MSCOPE_INFINITE_LEASE                 380222

#define HLP_SRVR_PROMPT_PASSWORD                  400000

#endif //__STDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\inc\mscopehndl.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/
#ifndef _SCOPEHNDL_H_
#define _SCOPEHNDL_H_


FN_HANDLE_CMD HandleMScopeList;
FN_HANDLE_CMD HandleMScopeHelp;
FN_HANDLE_CMD HandleMScopeContexts;
FN_HANDLE_CMD HandleMScopeDump;

FN_HANDLE_CMD HandleMScopeAddIprange;
FN_HANDLE_CMD HandleMScopeAddExcluderange;

FN_HANDLE_CMD HandleMScopeCheckDatabase;

FN_HANDLE_CMD HandleMScopeDeleteIprange;
FN_HANDLE_CMD HandleMScopeDeleteExcluderange;
FN_HANDLE_CMD HandleMScopeDeleteOptionvalue;

FN_HANDLE_CMD HandleMScopeSetName;
FN_HANDLE_CMD HandleMScopeSetComment;
FN_HANDLE_CMD HandleMScopeSetMScope;
FN_HANDLE_CMD HandleMScopeSetState;
FN_HANDLE_CMD HandleMScopeSetOptionvalue;
FN_HANDLE_CMD HandleMScopeSetTTL;
FN_HANDLE_CMD HandleMScopeSetLease;
FN_HANDLE_CMD HandleMScopeSetExpiry;


FN_HANDLE_CMD HandleMScopeShowClients;
FN_HANDLE_CMD HandleMScopeShowIprange;
FN_HANDLE_CMD HandleMScopeShowExcluderange;
FN_HANDLE_CMD HandleMScopeShowMibinfo;
FN_HANDLE_CMD HandleMScopeShowMScope;
FN_HANDLE_CMD HandleMScopeShowOptionvalue;
FN_HANDLE_CMD HandleMScopeShowState;
FN_HANDLE_CMD HandleMScopeShowLease;
FN_HANDLE_CMD HandleMScopeShowTTL;
FN_HANDLE_CMD HandleMScopeShowExpiry;



VOID
PrintMClientInfoShort(
    LPDHCP_MCLIENT_INFO ClientInfo
);

VOID
PrintMClientInfo(
    LPDHCP_MCLIENT_INFO ClientInfo
);

#endif //_SCOPEHNDL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\inc\dhcpmon.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\dhcp\dhcpmon.h

Abstract:

    DHCP Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 11/14/98

--*/



extern HANDLE   g_hModule;
extern HANDLE   g_hDhcpsapiModule;
extern BOOL     g_bCommit;
extern BOOL     g_hConnect;
extern DWORD    g_dwNumTableEntries;
extern PWCHAR   g_pwszRouter;

extern ULONG    g_ulInitCount;
extern ULONG    g_ulNumTopCmds;
extern ULONG    g_ulNumGroups;

extern LPWSTR  g_pwszServer;
extern LPSTR   g_ServerNameAnsi;
extern WCHAR   g_ServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1];
extern CHAR    g_ServerIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern WCHAR   g_ScopeIpAddressUnicodeString[MAX_IP_STRING_LEN+1];
extern CHAR    g_ScopeIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern LPWSTR  g_MScopeNameUnicodeString;
extern LPSTR   g_MScopeNameAnsiString;

extern LPWSTR  g_UserClass;
extern BOOL    g_fUserClass;
extern LPWSTR  g_VendorClass;
extern BOOL    g_fIsVendor;

DWORD
WINAPI
DhcpCommit(
    IN  DWORD   dwAction
);

BOOL 
WINAPI
DhcpDllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
);

NS_CONTEXT_ENTRY_FN DhcpMonitor;

DWORD
WINAPI
DhcpUnInit(
    IN  DWORD   dwReserved
);

BOOL
SetServerInfo(
    IN  LPCWSTR  pwszServerInfo
);

BOOL
IsHelpToken(
    PWCHAR  pwszToken
);

BOOL
IsReservedKeyWord(
    PWCHAR  pwszToken
);

DWORD
DisplayErrorMessage(
    HANDLE  hModule,
    DWORD   dwMsgID,
    DWORD   dwErrID,
    ...
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\inc\dhcpmgr.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/
#ifndef _DHCPMGR_H_
#define _DHCPMGR_H_


#define MAX_MSG_LENGTH  5120

#define MAX_HELPER_NAME MAX_DLL_NAME
#define MAX_NAME_LEN    MAX_DLL_NAME
#define MAX_ENTRY_PT_NAME MAX_DLL_NAME

#if 0

typedef struct _DHCPMON_ATTRIBUTES
{
    //Major version of the server
    DWORD                   dwMajorVersion; 
    //Minor version of the server
    DWORD                   dwMinorVersion; 
    //NetShell attributes
    NETSH_ATTRIBUTES        NetshAttrib;    
    //Server IPAddress Unicode String
    WCHAR                   wszServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1];   
    //Server IPAddress ANSI String
    CHAR                    szServerIpAddressAnsiString[MAX_IP_STRING_LEN+1];
    //ServerNameString in UNICODE
    LPWSTR                  pwszServerUnicodeName;
    //Server IP Address
    DHCP_IP_ADDRESS         ServerIpAddress;
    //This module's handle
    HANDLE                  hParentModule;
    //Handle of DHCPSAPI.DLL if loaded.
    HANDLE                  hDhcpsapiModule;
}DHCPMON_ATTRIBUTES, *PDHCPMON_ATTRIBUTES;

typedef
DWORD
(WINAPI *PDHCPMON_HELPER_INIT_FN)(
    IN  PWCHAR                      pwszRouter,
    IN  PDHCPMON_ATTRIBUTES         pUtilityTable,
    OUT PNS_HELPER_ATTRIBUTES       pHelperTable
);

typedef struct _DHCPMON_HELPER_TABLE_ENTRY
{
    //
    // Name of the helper - this is also the name of the context
    // and the name of the key in the registry
    //

    WCHAR                   pwszHelper[MAX_NAME_LEN];  // Helper Name

    //
    // Name of the DLL servicing the context
    //

    WCHAR                   pwszDLLName[MAX_NAME_LEN]; // Corresponding DLL

    //
    // TRUE if loaded
    //

    BOOL                    bLoaded;                   // In memory or not

    //
    // Handle to DLL instance if loaded
    //

    HANDLE                  hDll;                      // DLL handle if loaded

    //
    // Name of the entry point for the helper
    //

    WCHAR                   pwszInitFnName[MAX_NAME_LEN];  // Entry Fn name

    //
    // Pointers to functions
    //

    PNS_HELPER_UNINIT_FN    pfnUnInitFn;   
    PNS_HELPER_DUMP_FN      pfnDumpFn;     

}DHCPMON_HELPER_TABLE_ENTRY,*PDHCPMON_HELPER_TABLE_ENTRY;

#endif //0


typedef struct _DHCPMON_SUBCONTEXT_TABLE_ENTRY
{
    //
    // Name of the context
    //

    LPWSTR                  pwszContext;
    //
    //Short command help
    DWORD                   dwShortCmdHlpToken;
    
    //Detail command help
    DWORD                   dwCmdHlpToken;

    PNS_CONTEXT_ENTRY_FN    pfnEntryFn;    

}DHCPMON_SUBCONTEXT_TABLE_ENTRY,*PDHCPMON_SUBCONTEXT_TABLE_ENTRY;



#endif //_DHCPMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\inc\mscopemon.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\dhcp\dhcpmon.h

Abstract:

    DHCP Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 11/14/98

--*/


#define MAX_IP_STRING_LEN   15

extern HANDLE   g_hModule;
extern HANDLE   g_hParentModule;
extern HANDLE   g_hDhcpsapiModule;
extern BOOL     g_bCommit;
extern BOOL     g_hConnect;
extern BOOL     g_fScope;
extern PWCHAR   g_pwszServer;
extern DWORD    g_dwMajorVersion;
extern DWORD    g_dwMinorVersion;
extern DHCP_IP_ADDRESS g_ServerIpAddress;
extern ULONG    g_ulInitCount;
extern ULONG    g_ulNumTopCmds;
extern ULONG    g_ulNumGroups;

/*
extern CHAR   g_ServerIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern WCHAR  g_ServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1];
extern CHAR   g_ScopeIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern WCHAR  g_ScopeIpAddressUnicodeString[MAX_IP_STRING_LEN+1];
extern LPSTR  g_MScopeNameAnsiString;
extern LPWSTR g_MScopeNameUnicodeString;
*/

DWORD       g_dwMScopeID;

DWORD
WINAPI
MScopeCommit(
    IN  DWORD   dwAction
);

NS_CONTEXT_ENTRY_FN MScopeMonitor;

DWORD
WINAPI
MScopeUnInit(
    IN  DWORD   dwReserved
);

BOOL
SetMScopeInfo(
    IN  LPWSTR  pwszMScope
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\inc\scopemon.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\dhcp\dhcpmon.h

Abstract:

    DHCP Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 11/14/98

--*/


#define MAX_IP_STRING_LEN   15

extern HANDLE   g_hModule;
extern HANDLE   g_hParentModule;
extern HANDLE   g_hDhcpsapiModule;
extern BOOL     g_bCommit;
extern BOOL     g_hConnect;
extern BOOL     g_fScope;
extern PWCHAR   g_pwszServer;
extern DWORD    g_dwMajorVersion;
extern DWORD    g_dwMinorVersion;
extern DHCP_IP_ADDRESS g_ServerIpAddress;
extern ULONG    g_ulInitCount;
extern ULONG    g_ulNumTopCmds;
extern ULONG    g_ulNumGroups;

extern CHAR   g_ServerIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern WCHAR  g_ServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1];
extern CHAR   g_ScopeIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern WCHAR  g_ScopeIpAddressUnicodeString[MAX_IP_STRING_LEN+1];

DHCP_IP_ADDRESS g_ScopeIpAddress;


DWORD
WINAPI
ScopeCommit(
    IN  DWORD   dwAction
);

NS_CONTEXT_ENTRY_FN ScopeMonitor;


DWORD
WINAPI
ScopeUnInit(
    IN  DWORD   dwReserved
);

BOOL
SetScopeInfo(
    IN  LPWSTR  pwszScope
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\inc\srvrmon.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\dhcp\dhcpmon.h

Abstract:

    DHCP Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 11/14/98

--*/

#define MAX_OPTION_NAME_LEN         35
#define MAX_OPTION_ID_LEN           14
#define MAX_OPTION_ARRAY_TYPE_LEN   13

extern HANDLE   g_hModule;
extern HANDLE   g_hParentModule;
extern HANDLE   g_hDhcpsapiModule;
extern BOOL     g_bCommit;
extern BOOL     g_hConnect;
extern BOOL     g_fServer;
extern DWORD    g_dwNumTableEntries;
extern PWCHAR   g_pwszRouter;
extern PWCHAR   g_pwszServer;

extern ULONG    g_ulInitCount;
extern ULONG    g_ulNumTopCmds;
extern ULONG    g_ulNumGroups;

extern DWORD    g_dwMajorVersion;
extern DWORD    g_dwMinorVersion;
 
extern CHAR   g_ServerIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern WCHAR  g_ServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1];

extern DWORD  g_dwIPCount;
extern LPWSTR *g_ppServerIPList;

DWORD
WINAPI
SrvrCommit(
    IN  DWORD   dwAction
);

NS_CONTEXT_ENTRY_FN SrvrMonitor;

DWORD
WINAPI
SrvrUnInit(
    IN  DWORD   dwReserved
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\inc\scopehndl.h ===
#ifndef _MSCOPEHNDL_H_
#define _MSCOPEHNDL_H_

FN_HANDLE_CMD HandleScopeList;
FN_HANDLE_CMD HandleScopeHelp;
FN_HANDLE_CMD HandleScopeContexts;
FN_HANDLE_CMD HandleScopeDump;

FN_HANDLE_CMD HandleScopeAddIprange;
FN_HANDLE_CMD HandleScopeAddExcluderange;
FN_HANDLE_CMD HandleScopeAddReservedip;

FN_HANDLE_CMD HandleScopeCheckDatabase;

FN_HANDLE_CMD HandleScopeDeleteIprange;
FN_HANDLE_CMD HandleScopeDeleteExcluderange;
FN_HANDLE_CMD HandleScopeDeleteReservedip;
FN_HANDLE_CMD HandleScopeDeleteOptionvalue;
FN_HANDLE_CMD HandleScopeDeleteReservedoptionvalue;
FN_HANDLE_CMD HandleScopeDeleteClient;

FN_HANDLE_CMD HandleScopeSetState;
FN_HANDLE_CMD HandleScopeSetScope;
FN_HANDLE_CMD HandleScopeSetOptionvalue;
FN_HANDLE_CMD HandleScopeSetReservedoptionvalue;
FN_HANDLE_CMD HandleScopeSetName;
FN_HANDLE_CMD HandleScopeSetComment;
FN_HANDLE_CMD HandleScopeSetSuperscope;

FN_HANDLE_CMD HandleScopeShowClients;
FN_HANDLE_CMD HandleScopeShowClientsv5;
FN_HANDLE_CMD HandleScopeShowIprange;
FN_HANDLE_CMD HandleScopeShowExcluderange;
FN_HANDLE_CMD HandleScopeShowReservedip;
FN_HANDLE_CMD HandleScopeShowOptionvalue;
FN_HANDLE_CMD HandleScopeShowReservedoptionvalue;
FN_HANDLE_CMD HandleScopeShowState;
FN_HANDLE_CMD HandleScopeShowMibinfo;
FN_HANDLE_CMD HandleScopeShowScope;

DWORD
ProcessBootpParameters(
    DWORD                    cArgs,
    LPTSTR                   *ppszArgs,
    DHCP_IP_RESERVATION_V4   *pReservation
);

DWORD
RemoveOptionValue(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
);

VOID
PrintRange(
    DHCP_SUBNET_ELEMENT_TYPE Type,
    DHCP_IP_ADDRESS Start,
    DHCP_IP_ADDRESS End,
    ULONG BootpAllocated,
    ULONG MaxBootpAllowed,
    BOOL  fExclude
);


VOID
PrintClientInfo(
    LPDHCP_CLIENT_INFO_V4 ClientInfo,
    DWORD Level
);

#ifdef NT5
VOID
PrintClientInfoV5(
    LPDHCP_CLIENT_INFO_V5 ClientInfo
);

VOID
PrintClientInfoShortV5(
    LPDHCP_CLIENT_INFO_V5 ClientInfo
);

VOID
PrintClientInfoShort1V5(
    LPDHCP_CLIENT_INFO_V5 ClientInfo
);
#endif //NT5


VOID
PrintClientInfoShort(
    LPDHCP_CLIENT_INFO_V4 ClientInfo
);


VOID
PrintClientInfoShort1(
    LPDHCP_CLIENT_INFO_V4 ClientInfo
);
#endif //_SCOPEHNDL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\binl.h ===
/*++

Copyright (c) 1994-7  Microsoft Corporation

Module Name:

    binl.h

Abstract:

    This file is the central include file for the BINL service.

Author:

    Colin Watson (colinw)  14-Apr-1997

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

//
//  NT public header files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <winsock2.h>
#include <iphlpapi.h>
#include <align.h>
#include <dsgetdc.h>
#include <winldap.h>
#include <dsrole.h>
#include <rpc.h>
#include <ntdsapi.h>

#include <lm.h>
#include <security.h>   // General definition of a Security Support Provider
#include <spseal.h>
#include <userenv.h>
#include <setupapi.h>

//
// C Runtime library includes.
//

#include <stdlib.h>
#include <stdio.h>
#include <shlwapi.h>    // shell team special string manipulators

//
// tcp services control hander file
//

#include <tcpsvcs.h>

//
//  Local header files
//

#include <dhcp.h>
#include <dhcplib.h>
#include <dhcpbinl.h>
#include <dhcprog.h>
#include <oscpkt.h>
#include <dnsapi.h>
#include <remboot.h>

#include "binldef.h"
#include "osc.h"
#include "netinf.h"
#include "global.h"
#include "debug.h"
#include "binlmsg.h"
#include "proto.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\netsh\inc\srvrhndl.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/
FN_HANDLE_CMD  HandleSrvrList;
FN_HANDLE_CMD  HandleSrvrHelp;
FN_HANDLE_CMD  HandleSrvrContexts;
FN_HANDLE_CMD  HandleSrvrDump;

FN_HANDLE_CMD  HandleSrvrAddClass;
FN_HANDLE_CMD  HandleSrvrAddMscope;
FN_HANDLE_CMD  HandleSrvrAddOptiondef;
FN_HANDLE_CMD  HandleSrvrAddScope;

FN_HANDLE_CMD  HandleSrvrDeleteClass;
FN_HANDLE_CMD  HandleSrvrDeleteMscope;
FN_HANDLE_CMD  HandleSrvrDeleteOptiondef;
FN_HANDLE_CMD  HandleSrvrDeleteOptionvalue;
FN_HANDLE_CMD  HandleSrvrDeleteScope;
FN_HANDLE_CMD  HandleSrvrDeleteSuperscope;
FN_HANDLE_CMD  HandleSrvrDeleteDnsCredentials;

FN_HANDLE_CMD  HandleSrvrRedoAuth;
FN_HANDLE_CMD  HandleSrvrInitiateReconcile;
FN_HANDLE_CMD  HandleSrvrExport;
FN_HANDLE_CMD  HandleSrvrImport;

FN_HANDLE_CMD  HandleSrvrSetBackupinterval;
FN_HANDLE_CMD  HandleSrvrSetBackuppath;
FN_HANDLE_CMD  HandleSrvrSetDatabasecleanupinterval;
FN_HANDLE_CMD  HandleSrvrSetDatabaseloggingflag;
FN_HANDLE_CMD  HandleSrvrSetDatabasename;
FN_HANDLE_CMD  HandleSrvrSetDatabasepath;
FN_HANDLE_CMD  HandleSrvrSetDatabaserestoreflag;
FN_HANDLE_CMD  HandleSrvrSetOptionvalue;
FN_HANDLE_CMD  HandleSrvrSetServer;
FN_HANDLE_CMD  HandleSrvrSetUserclass;
FN_HANDLE_CMD  HandleSrvrSetVendorclass;
FN_HANDLE_CMD  HandleSrvrSetDnsCredentials;
FN_HANDLE_CMD  HandleSrvrSetAuditlog;
FN_HANDLE_CMD  HandleSrvrSetDnsconfig;
FN_HANDLE_CMD  HandleSrvrSetDetectconflictretry;

FN_HANDLE_CMD  HandleSrvrShowAll;
FN_HANDLE_CMD  HandleSrvrShowBindings;
FN_HANDLE_CMD  HandleSrvrShowClass;
FN_HANDLE_CMD  HandleSrvrShowHelper;
FN_HANDLE_CMD  HandleSrvrShowMibinfo;
FN_HANDLE_CMD  HandleSrvrShowMscope;
FN_HANDLE_CMD  HandleSrvrShowOptiondef;
FN_HANDLE_CMD  HandleSrvrShowOptionvalue;
FN_HANDLE_CMD  HandleSrvrShowScope;
FN_HANDLE_CMD  HandleSrvrShowSuperScope;
FN_HANDLE_CMD  HandleSrvrShowServer;
FN_HANDLE_CMD  HandleSrvrShowServerconfig;
FN_HANDLE_CMD  HandleSrvrShowServerstatus;
FN_HANDLE_CMD  HandleSrvrShowUserclass;
FN_HANDLE_CMD  HandleSrvrShowVendorclass;
FN_HANDLE_CMD  HandleSrvrShowDnsCredentials;
FN_HANDLE_CMD  HandleSrvrShowVersion;
FN_HANDLE_CMD  HandleSrvrShowAuditlog;
FN_HANDLE_CMD  HandleSrvrShowDnsconfig;
FN_HANDLE_CMD  HandleSrvrShowDetectconflictretry;

DWORD
CreateDumpFile(
    IN  PWCHAR  pwszName,
    OUT PHANDLE phFile
);

VOID
CloseDumpFile(
    HANDLE  hFile
);

DWORD
SrvrDottedStringToIpAddressW(
    LPWSTR pwszString
);

LPWSTR
SrvrIpAddressToDottedStringW(
    DWORD   IpAddress
);


VOID
PrintClassInfo(                                   // print info on a single class
    LPDHCP_CLASS_INFO   Class
);

VOID
PrintClassInfoArray(                              // print array of classes
    LPDHCP_CLASS_INFO_ARRAY Classes
);

DWORD
SetOptionDataType(
    DHCP_OPTION_DATA_TYPE       OptionType,
    LPTSTR                      OptionValueString,
    LPDHCP_OPTION_DATA_ELEMENT  OptionData,
    LPWSTR                      *UnicodeOptionValueString
);

DWORD
SetOptionDataTypeArray(
    DHCP_OPTION_DATA_TYPE OptionType,
    LPTSTR              *OptionValues,
    DWORD               dwStartCount, //first optionvalue = dwStartCount 
    DWORD               dwEndCount, //last optionvalue = dwEndCount - 1
    LPDHCP_OPTION_DATA  pOptionData
);

DWORD
_EnumOptions(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_ARRAY   *Options,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
);

VOID
PrintOptionInfo(
    IN LPDHCP_OPTION OptionInfo
);

VOID
PrintOptionValue(
    IN LPDHCP_OPTION_DATA OptionValue
);

DWORD
PrintAllOptionValues(
    IN LPDHCP_ALL_OPTION_VALUES OptValues
);

DWORD
PrintUserOptionValues(
    IN LPDHCP_ALL_OPTION_VALUES OptValues,
    IN LPWSTR                   pwcUser,
    IN LPWSTR                   pwcVendor
);

VOID
PrintOptionValuesArray(
    IN LPDHCP_OPTION_VALUE_ARRAY OptValArray
);

VOID
PrintOptionArray(
    IN LPDHCP_OPTION_ARRAY    OptArray
);

VOID
PrintOptionValue1(
    IN LPDHCP_OPTION_VALUE    OptVal
);

VOID
PrintAllOptions(
    IN      LPDHCP_ALL_OPTIONS     Options
);

DWORD
SetOptionValue(
    IN      LPWSTR                      ServerAddress,
    IN      DWORD                       Flags,
    IN      DHCP_OPTION_ID              OptionId,
    IN      LPWSTR                      ClassName,
    IN      LPWSTR                      VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO    ScopeInfo,
    IN      LPDHCP_OPTION_DATA          OptionValue
);

DWORD
ShowOptionValues4(
    IN      LPWSTR                      pwszServer,
    IN      LPDHCP_OPTION_SCOPE_INFO    ScopeInfo,
    IN      LPDWORD                     pdwCount
);

VOID
PrintDhcpAttrib(                                  // print a server attrib
    LPDHCP_ATTRIB ServerAttrib
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\cache.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cache.c

Abstract:

    This module contains the code to cache BINL client information across
    requests for the BINL server.

Author:

    Andy Herron (andyhe)  5-Mar-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include "binl.h"
#pragma hdrstop

ULONG BinlCacheCount = 0;
ULONG BinlCacheEntriesInUse = 0;

VOID
BinlFreeCacheEntry (
    PMACHINE_INFO CacheEntry
    );

DWORD
BinlCreateOrFindCacheEntry (
    PCHAR Guid,
    BOOLEAN CreateIfNotExist,
    PMACHINE_INFO *CacheEntry
    )
//
//  This searches the list of cached entries for the matching GUID.  If it is
//  found and is in use, we return an error as another thread is working on
//  the same request.  If it is found and not in use, we mark it in use and
//  return it.  If it is not found, we add it and return it.
//
{
    PLIST_ENTRY listEntry;
    PMACHINE_INFO currentEntry = NULL;
    DWORD expireTickCount;

    EnterCriticalSection( &BinlCacheListLock );

    //
    //  For now, we don't bother with a scavenger thread.  Just free them up
    //  as we come across them.
    //

    if (BinlCacheExpireMilliseconds > 0) {

        expireTickCount = GetTickCount() - BinlCacheExpireMilliseconds;

    } else {

        expireTickCount = 0;
    }

    if (BinlCurrentState == BINL_STOPPED) {

        //
        //  if we're in the midst of shutting down, ignore the request.  We
        //  do the check while holding the lock to synchronize with any thread
        //  calling BinlCloseCache.
        //

        LeaveCriticalSection( &BinlCacheListLock );
        *CacheEntry = NULL;

        //
        //  We return the EVENT_SERVER_SHUTDOWN to tell the calling thread
        //  not to bother with this request.
        //

        return EVENT_SERVER_SHUTDOWN;
    }

    listEntry = BinlCacheList.Flink;

    while ( listEntry != &BinlCacheList ) {

        LONG isEqual;

        currentEntry = (PMACHINE_INFO) CONTAINING_RECORD(
                                            listEntry,
                                            MACHINE_INFO,
                                            CacheListEntry );

        //
        //  lazy free.. check to see if we should free this entry because
        //  it's time to live has expired.
        //

        if ((currentEntry->InProgress == FALSE) &&
            (expireTickCount > 0) &&
            (currentEntry->TimeCreated < expireTickCount)) {

            listEntry = listEntry->Flink;
            BinlFreeCacheEntry( currentEntry );

            BinlPrintDbg((DEBUG_BINL_CACHE, "removed cache entry %x", currentEntry ));
            continue;
        }

        //
        // search for the given guid.  The list is sorted by GUID so when
        // we hit a guid that is greater than current, we stop searching.
        //

        isEqual = memcmp( Guid, currentEntry->Guid, BINL_GUID_LENGTH );

        if (isEqual < 0) {

            listEntry = listEntry->Flink;
            continue;
        }

        if (isEqual == 0) {

            DWORD rc = ERROR_SUCCESS;

            //
            //  If another thread is using this entry, then we should ignore
            //  the request we're currently working on as the other thread will
            //  respond.

            if (currentEntry->InProgress == TRUE) {

                LeaveCriticalSection( &BinlCacheListLock );
                *CacheEntry = NULL;
                return ERROR_BINL_CLIENT_EXISTS;
            }

            //
            //  Also, if the entry is not ours to handle, then we return the
            //  error here.  We don't return ERROR_BINL_INVALID_BINL_CLIENT
            //  because that will tell GetBootParameters to process it as a
            //  new client.  Instead, we return ERROR_BINL_CLIENT_EXISTS so
            //  that the caller will simply return the error.  A bit ugly,
            //  but necessary.
            //

            if (currentEntry->MyClient == FALSE) {

                if (currentEntry->EntryExists)  {
                    LeaveCriticalSection( &BinlCacheListLock );
                    *CacheEntry = NULL;
                    return ERROR_BINL_CLIENT_EXISTS;
                }
                
                //
                //  we return the empty entry since we might now be
                //  creating the account.
                //
                rc = ERROR_BINL_INVALID_BINL_CLIENT;
            }

            //
            //  since we're now using an entry, reset the event saying all
            //  threads are done.
            //

            BinlCacheEntriesInUse++;

            currentEntry->InProgress = TRUE;
            *CacheEntry = currentEntry;

            LeaveCriticalSection( &BinlCacheListLock );

            return rc;
        }

        //
        //  we're at the first entry that is greater than the guid in question.
        //

        break;
    }

    if (! CreateIfNotExist) {

        LeaveCriticalSection( &BinlCacheListLock );
        *CacheEntry = NULL;
        return ERROR_BINL_INVALID_BINL_CLIENT;
    }

    //  currentEntry is not valid, but listEntry is.
    //
    //  Add a new entry at the end of listEntry.  Either listEntry points to
    //  the first entry that is larger than our guid or it points to the root
    //  of the list (in which case we add it at the end).
    //

    currentEntry = BinlAllocateMemory( sizeof( MACHINE_INFO ) );

    if (currentEntry == NULL) {

        *CacheEntry = NULL;
        LeaveCriticalSection( &BinlCacheListLock );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    currentEntry->TimeCreated = GetTickCount();
    currentEntry->InProgress = TRUE;

    // leave MyClient and EntryExists as FALSE

    memcpy( currentEntry->Guid, Guid, BINL_GUID_LENGTH );
    InsertTailList( listEntry, &currentEntry->CacheListEntry );
    InitializeListHead( &currentEntry->DNsWithSameGuid );

    BinlCacheEntriesInUse++;
    BinlCacheCount++;
    *CacheEntry = currentEntry;

    //
    //  If we're at the max, then go through the entire list to free the
    //  oldest.  We do this here because the loop below doesn't go through
    //  the whole list.
    //

    if (BinlCacheCount > BinlGlobalCacheCountLimit) {

        PMACHINE_INFO entryToDelete = NULL;
        DWORD earliestTime;

        listEntry = BinlCacheList.Flink;

        while ( listEntry != &BinlCacheList ) {

            currentEntry = (PMACHINE_INFO) CONTAINING_RECORD(
                                                listEntry,
                                                MACHINE_INFO,
                                                CacheListEntry );

            listEntry = listEntry->Flink;

            if (currentEntry->InProgress == FALSE) {

                //
                //  if this one is expired, stop here as we have one to free
                //

                if ((expireTickCount > 0) &&
                    (currentEntry->TimeCreated < expireTickCount)) {

                    entryToDelete = currentEntry;
                    break;
                }

                //
                //  if this one is earlier than the one we previously found,
                //  remember it.
                //

                if ((( entryToDelete == NULL) ||
                     ( currentEntry->TimeCreated < earliestTime)) ) {

                    entryToDelete = currentEntry;
                    earliestTime = currentEntry->TimeCreated;
                }
            }
        }
        if (entryToDelete) {
            BinlFreeCacheEntry( entryToDelete );
            BinlPrintDbg((DEBUG_BINL_CACHE, "removed cache entry %x", entryToDelete ));
        }
    }

    LeaveCriticalSection( &BinlCacheListLock );

    return ERROR_SUCCESS;
}

VOID
BinlDoneWithCacheEntry (
    PMACHINE_INFO CacheEntry,
    BOOLEAN FreeIt
    )
{
    EnterCriticalSection( &BinlCacheListLock );

    //
    //  This one is no longer actively used.  See if it's time to set the
    //  event to tell the terminating thread that everyone is done.
    //

    CacheEntry->InProgress = FALSE;

    BinlCacheEntriesInUse--;

    if ((BinlCacheEntriesInUse == 0) && BinlCloseCacheEvent) {

        SetEvent( BinlCloseCacheEvent );
    }

    if (FreeIt) {

        BinlFreeCacheEntry( CacheEntry );
    }

    LeaveCriticalSection( &BinlCacheListLock );

    BinlPrintDbg((DEBUG_BINL_CACHE, "binl done with cache entry 0x%x, FreeIt == %s\n", 
                  CacheEntry,
                  (FreeIt == TRUE) ? "TRUE" : "FALSE" ));
    return;
}

VOID
BinlFreeCacheEntry (
    PMACHINE_INFO CacheEntry
    )
//
//  The lock must be held while coming in here.  It will be not be freed.
//
{
    PLIST_ENTRY p;
    PDUP_GUID_DN dupDN;

    //
    //  We're done with this entry.  Simply remove it from the list, free it,
    //  and update the global count.  The lock is held, so party on.
    //

    BinlPrintDbg((DEBUG_BINL_CACHE, "binl freeing cache entry at 0x%x\n", CacheEntry ));    

    RemoveEntryList( &CacheEntry->CacheListEntry );

    if ( CacheEntry->dwFlags & MI_NAME_ALLOC ) {
        BinlFreeMemory( CacheEntry->Name );
    }
    if ( CacheEntry->dwFlags & MI_SETUPPATH_ALLOC ) {
        BinlFreeMemory( CacheEntry->SetupPath );
    }
    if ( CacheEntry->dwFlags & MI_HOSTNAME_ALLOC ) {
        BinlFreeMemory( CacheEntry->HostName );
    }
    if ( CacheEntry->dwFlags & MI_BOOTFILENAME_ALLOC ) {
        BinlFreeMemory( CacheEntry->BootFileName );
    }
    if ( CacheEntry->dwFlags & MI_SAMNAME_ALLOC ) {
        BinlFreeMemory( CacheEntry->SamName );
    }
    if ( CacheEntry->dwFlags & MI_DOMAIN_ALLOC ) {
        BinlFreeMemory( CacheEntry->Domain );
    }
    if ( CacheEntry->dwFlags & MI_SIFFILENAME_ALLOC ) {
        BinlFreeMemory( CacheEntry->ForcedSifFileName );
    }
    if ( CacheEntry->dwFlags & MI_MACHINEDN_ALLOC ) {
        BinlFreeMemory( CacheEntry->MachineDN );
    }

    while (!IsListEmpty(&CacheEntry->DNsWithSameGuid)) {

        p = RemoveHeadList(&CacheEntry->DNsWithSameGuid);

        dupDN = CONTAINING_RECORD(p, DUP_GUID_DN, ListEntry);
        BinlFreeMemory( dupDN );
    }

    BinlFreeMemory( CacheEntry );
    BinlCacheCount--;

    return;
}

VOID
BinlCloseCache (
    VOID
    )
//
//  This routine closes down all entries in the DS cache.  It waits until all
//  threads are done with entries before it returns.  It waits for the
//  BinlCloseCacheEvent to be set if threads are waiting.
//
{
    PLIST_ENTRY listEntry;

    EnterCriticalSection( &BinlCacheListLock );

    listEntry = BinlCacheList.Flink;

    while ( listEntry != &BinlCacheList ) {

        DWORD Error;

        PMACHINE_INFO cacheEntry;

        //
        //  For each entry in the list, if it's not in use we free it.  If it
        //  is in use, we wait for the thread to finish with it.
        //

        cacheEntry = (PMACHINE_INFO) CONTAINING_RECORD(
                                            listEntry,
                                            MACHINE_INFO,
                                            CacheListEntry );

        if (cacheEntry->InProgress != TRUE) {

            listEntry = listEntry->Flink;
            BinlFreeCacheEntry( cacheEntry );
            continue;
        }

        if (BinlCloseCacheEvent) {

            ResetEvent( BinlCloseCacheEvent );
        }

        LeaveCriticalSection( &BinlCacheListLock );

        //
        //  Wait for the event signalling that all threads are done with
        //  the cache
        //

        if (BinlCloseCacheEvent) {

            Error = WaitForSingleObject( BinlCloseCacheEvent, THREAD_TERMINATION_TIMEOUT );

        } else {

            //
            //  well, the event that we would wait on isn't there and there's
            //  still a worker thread using a cache entry, so we just wait
            //  and then recheck.  Yup, this is ugly.
            //

            Sleep( 10*1000 );
        }

        EnterCriticalSection( &BinlCacheListLock );
        listEntry = BinlCacheList.Flink;
    }

    LeaveCriticalSection( &BinlCacheListLock );
}

// cache.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\binldef.h ===
/*++

Copyright (c) 1994-7  Microsoft Corporation

Module Name:

    binldef.h

Abstract:

    This file contains manifest constants and internal data structures
    for the BINL service.

Author:

    Colin Watson (colinw)  14-Apr-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _BINL_
#define _BINL_

#if DBG
#define STATIC
#else
#define STATIC static
#endif // DBG

//
// Globals
//
extern DWORD BinlRepeatSleep;


//  Connection information to a DC in our domain
extern PLDAP DCLdapHandle;
extern PWCHAR * DCBase;

//  Connection information to the Global Catalog for our enterprise
extern PLDAP GCLdapHandle;
extern PWCHAR * GCBase;



//
// useful macros
//

#define WSTRSIZE( wsz ) (( wcslen( wsz ) + 1 ) * sizeof( WCHAR ))
#define STRSIZE( sz ) (( strlen( sz ) + 1 ) * sizeof( char ))
#define SWAP( p1, p2 )  \
{                       \
    VOID *pvTemp = p1;  \
    p1 = p2;            \
    p2 = pvTemp;        \
}

//
// calculates the size of a field
//

#define GET_SIZEOF_FIELD( struct, field ) ( sizeof(((struct*)0)->field))


//
// Constants
//

#define BINL_SERVER       L"BINLSVC"

//
// Timeouts, this is the length of time we wait for our threads to terminate.
//

#define THREAD_TERMINATION_TIMEOUT      INFINITE        // wait a long time,
                                                        // but don't AV

#define BINL_HYPERMODE_TIMEOUT           60*1000        // in msecs. 1 min
#define BINL_HYPERMODE_RETRY_COUNT       30             // do it for 30 mins

//
// message queue length.
//

#define BINL_RECV_QUEUE_LENGTH              50
#define BINL_MAX_PROCESSING_THREADS         20
#define BINL_MESSAGE_SIZE                 1500
//
// macros
//

#define LOCK_INPROGRESS_LIST()   EnterCriticalSection(&BinlGlobalInProgressCritSect)
#define UNLOCK_INPROGRESS_LIST() LeaveCriticalSection(&BinlGlobalInProgressCritSect)

#define LOCK_RECV_LIST()   EnterCriticalSection(&BinlGlobalRecvListCritSect)
#define UNLOCK_RECV_LIST() LeaveCriticalSection(&BinlGlobalRecvListCritSect)

//
// An endpoint represents a socket and the addresses associated with
// the socket.
//

typedef struct _ENDPOINT {
    SOCKET  Socket;
    DWORD   Port;
    DHCP_IP_ADDRESS IpAddress;
    DHCP_IP_ADDRESS SubnetMask;
    DHCP_IP_ADDRESS SubnetAddress;
} ENDPOINT, *LPENDPOINT, *PENDPOINT;


//
// A request context, one per processing thread.
//

typedef struct _BINL_REQUEST_CONTEXT {

    //
    // list pointer.
    //

    LIST_ENTRY ListEntry;


    //
    // pointer to a received buffer.
    //

    LPBYTE ReceiveBuffer;

    //
    // A buffer to send response.
    //

    LPBYTE SendBuffer;

    //
    // The actual amount of data received in the buffer.
    //

    DWORD ReceiveMessageSize;

    //
    // The actual amount of data send in the buffer.
    //

    DWORD SendMessageSize;

    //
    // The source of the current message
    //

    PENDPOINT ActiveEndpoint;
    struct sockaddr SourceName;
    DWORD SourceNameLength;
    DWORD TimeArrived;

    BYTE MessageType;

} BINL_REQUEST_CONTEXT, *LPBINL_REQUEST_CONTEXT, *PBINL_REQUEST_CONTEXT;


#define BOOT_FILE_SIZE          128
#define BOOT_SERVER_SIZE        64
#define BOOT_FILE_SIZE_W        ( BOOT_FILE_SIZE * sizeof( WCHAR ))
#define BOOT_SERVER_SIZE_W      ( BOOT_SERVER_SIZE * sizeof( WCHAR ))

//
// Registry data
//

#define BINL_PARAMETERS_KEY       L"System\\CurrentControlSet\\Services\\Binlsvc\\Parameters"
#define BINL_PORT_NAME            L"Port"
#define BINL_DEFAULT_PORT         4011
#define BINL_DEBUG_KEY            L"Debug"
#if DBG
#define BINL_REPEAT_RESPONSE      L"RepeatResponse"
#endif // DBG
#define BINL_LDAP_OPT_REFERRALS   L"LdapOptReferrals"
#define BINL_MIN_RESPONSE_TIME    L"ResponseDelay"
#define BINL_LDAP_SEARCH_TIMEOUT  L"LdapTimeout"
#define BINL_CACHE_EXPIRE         L"CacheExpire"
#define BINL_CACHE_MAX_COUNT      L"CacheMaxCount"
#define BINL_ALLOW_NEW_CLIENTS    L"AllowNewClients"
#define BINL_DEFAULT_CONTAINER    L"DefaultContainer"
#define BINL_DEFAULT_DOMAIN       L"DefaultDomain"
#define BINL_DEFAULT_DS           L"DefaultServer"
#define BINL_DEFAULT_GC           L"DefaultGCServer"
#define BINL_CLIENT_TIMEOUT       L"ClientTimeout"
#define BINL_SCAVENGER_SLEEP      L"ScavengerSleep"
#define BINL_SCAVENGER_SIFFILE    L"SifFileSleep"
#define BINL_DEFAULT_LANGUAGE     L"DefaultLanguage"
#define BINL_UPDATE_PARAMETER_POLL L"UpdateParameterPoll"
#define BINL_DS_ERROR_COUNT_PARAMETER L"MaxDSErrorsToLog"
#define BINL_DS_ERROR_SLEEP       L"DSErrorInterval"
#define BINL_ASSIGN_NEW_CLIENTS_TO_SERVER L"AssignNewClientsToServer"
#define BINL_NTLMV2_AUTHENTICATE  L"UseNTLMV2Authentication"

#define BINL_SCP_CREATED          L"ScpCreated"
#define BINL_SCP_NEWCLIENTS       L"netbootAllowNewClients"
#define BINL_SCP_LIMITCLIENTS     L"netbootLimitClients"
#define BINL_SCP_CURRENTCLIENTCOUNT L"netbootCurrentClientCount"
#define BINL_SCP_MAXCLIENTS       L"netbootMaxClients"
#define BINL_SCP_ANSWER_REQUESTS  L"netbootAnswerRequests"
#define BINL_SCP_ANSWER_VALID     L"netbootAnswerOnlyValidClients"
#define BINL_SCP_NEWMACHINENAMEPOLICY L"netbootNewMachineNamingPolicy"
#define BINL_SCP_NEWMACHINEOU     L"netbootNewMachineOU"
#define BINL_SCP_NETBOOTSERVER    L"netbootServer"










typedef struct _DHCP_BINARY_DATA {
    DWORD DataLength;

#if defined(MIDL_PASS)
    [size_is(DataLength)]
#endif // MIDL_PASS
        BYTE *Data;

} DHCP_BINARY_DATA, *LPDHCP_BINARY_DATA;

//
// Structure that defines the state of a client.
//
// The reason we use a separate Positive and Negative RefCount is so that
// we don't have to re-acquire the global ClientsCriticalSection when
// we are done with a CLIENT_STATE, just to decrement the ref count.
// Instead we guard the NegativeRefCount with just the CLIENT_STATE's
// CriticalSection. Then we compare Positive and Negative and if they
// are equal we delete the CLIENT_STATE. Even if PositiveRefCount is
// being added to just as we do this comparison, it won't ever be equal
// to Negative RefCount unless we really are the last thread to use the
// CLIENT_STATE.
//
// Padding is in the structure so that the first two elements, which are
// guarded by ClientsCriticalSection, aren't in the same quadword as
// anything else.
//

// search and replace structure
typedef struct {
    LPSTR  pszToken;
    struct {
        LPSTR  pszStringA;
        LPWSTR pszStringW;
    };
} SAR, * LPSAR;

#define MAX_VARIABLES 64

typedef struct _CLIENT_STATE {
    LIST_ENTRY Linkage;     // in ClientsQueue
    ULONG PositiveRefCount; // guarded by global ClientsCriticalSection
    ULONG Padding;
    CRITICAL_SECTION CriticalSection;  // prevents two messages processed at once
    ULONG NegativeRefCount; // guarded by our CriticalSection; delete when equal to PositiveRC
    ULONG RemoteIp;         // IP address of the client
    CtxtHandle ServerContextHandle;
    PLDAP AuthenticatedDCLdapHandle;  // returned by ldap_bind (with credentials)
    HANDLE UserToken;                 // returned by LogonUser with same credentials
    ULONG ContextAttributes;
    UCHAR Seed;                       // seed used for run encoding-decoding
    BOOL NegotiateProcessed;
    BOOL CustomInstall;         // true if custom, false if auto
    BOOL AuthenticateProcessed; // if TRUE, then AuthenticateStatus is valid
    BOOL CriticalSectionHeld;   // just a quick check, not 100% accurate.
    BOOL InitializeOnFirstRequest; // call OscInitializeClientVariables on initial request?
    SECURITY_STATUS AuthenticateStatus;
    ULONG LastSequenceNumber;
    PUCHAR LastResponse;          // buffer holding the last packet sent
    ULONG LastResponseAllocated;  // size LastResponse is allocated at
    ULONG LastResponseLength;     // size of current data in LastResponse
    DWORD LastUpdate;             // Last time this client state was entered

    ULONG  nVariables;            // current number of defined varaibles
    SAR    Variables[ MAX_VARIABLES ]; // "variables" that are replaced in OSCs and SIFs
    INT    nCreateAccountCounter; // Counts up each time a different computer name was tired
    BOOL   fCreateNewAccount;     // FALSE if a pre-staged account exists
    BOOL   fAutomaticMachineName; // TRUE is BINL generated the machine name
    BOOL   fHaveSetupMachineDN;   // TRUE if we've already called OscCheckMachineDN
    WCHAR  MachineAccountPassword[LM20_PWLEN+1];
    DWORD  MachineAccountPasswordLength;
} CLIENT_STATE, *PCLIENT_STATE;

//
//  The structure that tracks info based on GUID.
//
//  Because checking the DS is a expensive, we track the results we received
//  from the DS per GUID in this structure.  This also allows us to ignore
//  duplicate requests from clients when we're already working on them.
//
//  These cache entries are very short lived, on the order of a minute or so.
//  We'd hold them longer except we have no idea when they get stale in the DS.
//
//  The list of cache entries is protected by BinlCacheListLock.  An entry
//  is in use when the InProgress flag is set.  If this flag is set, it means
//  that a thread is actively using it and the entry shouldn't be touched.
//
//  If the hostname is not filled in and the NotMyClient flag is set to FALSE,
//  then the entry, though allocated, hasn't been fully filled in.
//
//  The XXX_ALLOC bits indicate that the corresponding field was allocated
//  and needs to be freed when the cache entry is freed.
//

#define BINL_GUID_LENGTH 16

#define MI_NAME               0x00000001
#define MI_SETUPPATH          0x00000002
#define MI_HOSTNAME           0x00000004
#define MI_BOOTFILENAME       0x00000008

#define MI_SAMNAME            0x00000010
#define MI_PASSWORD           0x00000020
#define MI_DOMAIN             0x00000040
#define MI_HOSTIP             0x00000080

#define MI_MACHINEDN          0x00000100

#define MI_NAME_ALLOC         0x00010000
#define MI_SETUPPATH_ALLOC    0x00020000
#define MI_HOSTNAME_ALLOC     0x00040000
#define MI_BOOTFILENAME_ALLOC 0x00080000

#define MI_SAMNAME_ALLOC      0x00100000
#define MI_DOMAIN_ALLOC       0x00400000
#define MI_SIFFILENAME_ALLOC  0x00800000

#define MI_MACHINEDN_ALLOC    0x01000000

#define MI_ALL_ALLOC          0x03ff0000

#define MI_GUID               0x80000000  // UpdateCreate forces a new guid to be written

typedef struct _MACHINE_INFO {

    LIST_ENTRY  CacheListEntry;     // global is BinlCacheList
    DWORD       TimeCreated;        // from GetTickCount

    BOOLEAN     InProgress;         // is a thread currently working on this?
    BOOLEAN     MyClient;           // do we not respond to this client?
    BOOLEAN     EntryExists;        // does the entry exist in the DS?

    DWORD       dwFlags;            // "MI_" bits saying what information is currently valid
    UCHAR       Guid[BINL_GUID_LENGTH]; // client's GUID
    PWCHAR      Name;               // client's name
    PWCHAR      MachineDN;          // client's FQ Distinguished Name
    PWCHAR      SetupPath;          // client's orginal installation path
    PWCHAR      HostName;           // client's host server name
    DHCP_IP_ADDRESS HostAddress;    // address of host - this is filled when HostName is filled
    PWCHAR      BootFileName;       // client's boot filename
    PWCHAR      SamName;            // client's SAM name
    PWCHAR      Password;           // client's password (for setting only)
    ULONG       PasswordLength;     // client's password length (for setting only)
    PWCHAR      Domain;             // client's domain
    LIST_ENTRY  DNsWithSameGuid;    // list of DNs with same GUID, except for MachineDN above.
    PWCHAR      ForcedSifFileName;  // client's sif file it must use.

} MACHINE_INFO, *PMACHINE_INFO;

//
//  Structure that tracks duplicate DNs for this machine account. The structure
//  is allocated with room for the two strings at the end.
//

typedef struct _DUP_GUID_DN {

    LIST_ENTRY ListEntry;
    ULONG      DuplicateDNOffset;  // offset from the start of DuplicateName to DuplicateDN
    WCHAR      DuplicateName[ANYSIZE_ARRAY];   // name of the duplicate account (without final '$')
    // WCHAR   DuplicateDN[];      // this follows at DuplicateDNOffset

} DUP_GUID_DN, *PDUP_GUID_DN;


//
// The largest size of any client architecture name
// (current choices: i386 alpha mips ia64 ppc arci386) --
// assume it won't exceed 8 chars for now.
//

#define MAX_ARCHITECTURE_LENGTH      8


#define DHCP_OPTION_CLIENT_ARCHITECTURE_X86       0
#define DHCP_OPTION_CLIENT_ARCHITECTURE_NEC98     1 
#define DHCP_OPTION_CLIENT_ARCHITECTURE_IA64      2
#define DHCP_OPTION_CLIENT_ARCHITECTURE_ALPHA     3
#define DHCP_OPTION_CLIENT_ARCHITECTURE_ARCX86    4
#define DHCP_OPTION_CLIENT_ARCHITECTURE_INTELLEAN 5

//
// Structure that tracks the queued DS Names that we want to register
// with the DS, but havent yet.  Keeping a running list of queued DS names
// prevents multi-threaded collisions on the same name.
//
typedef struct _QUEUED_DS_NAME_NODE {

    LIST_ENTRY  ListEntry;
    WCHAR       Name[ANYSIZE_ARRAY];

} QUEUED_DS_NAME_NODE, *PQUEUED_DS_NAME_NODE;

#endif _BINL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\debug.h ===
/*++

Copyright (c) 1994-7  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains debugging macros for the binl server.

Author:

    Colin Watson (colinw)  14-Apr-1997

Environment:

    User Mode - Win32

Revision History:


--*/

#define DEBUG_DIR           L"\\debug"
#define DEBUG_FILE          L"\\binlsvc.log"
#define DEBUG_BAK_FILE      L"\\binlsvc.bak"

//
// LOW WORD bit mask (0x0000FFFF) for low frequency debug output.
//

#define DEBUG_ADDRESS           0x00000001  // subnet address
#define DEBUG_OPTIONS           0x00000008  // binl option

#define DEBUG_ERRORS            0x00000010  // hard error
#define DEBUG_STOC              0x00000020  // protocol error
#define DEBUG_INIT              0x00000040  // init error
#define DEBUG_SCAVENGER         0x00000080  // sacvenger error

#define DEBUG_TIMESTAMP         0x00000100  // debug message timing
#define DEBUG_REGISTRY          0x00000400  // Registry operation
#define DEBUG_NETINF            0x00000800  // NETINF error

#define DEBUG_MISC              0x00008000  // misc info.

//
// HIGH WORD bit mask (0x0000FFFF) for high frequency debug output.
// ie more verbose.
//

#define DEBUG_MESSAGE           0x00010000  // binl message output.
#define DEBUG_OSC               0x00040000  // OSChooser message output.
#define DEBUG_OSC_ERROR         0x00080000  // OSChooser error output.

#define DEBUG_BINL_CACHE        0x00100000  // Binl client cache output.
#define DEBUG_ROGUE             0x00200000  // rogue processing.
#define DEBUG_POLICY            0x00400000  // group policy filtering.

#define DEBUG_THREAD            0x04000000  // debug message contains threadid
#define DEBUG_MEMORY            0x08000000  // Memory Allocation Tracking Spew

#define DEBUG_FUNC              0x10000000  // function entry

#define DEBUG_STARTUP_BRK       0x40000000  // breakin debugger during startup.
#define DEBUG_LOG_IN_FILE       0x80000000  // log debug output in a file.

VOID
DebugInitialize(
    VOID
    );

VOID
DebugUninitialize(
    VOID
    );

VOID
BinlOpenDebugFile(
    IN BOOL ReopenFlag
    );

VOID
BinlServerEventLog(
    DWORD EventID,
    DWORD EventType,
    DWORD ErrorCode
    );

extern const char g_szTrue[];
extern const char g_szFalse[];

#define BOOLTOSTRING( _f ) ( _f ? g_szTrue : g_szFalse )

VOID
BinlPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    );

#define BinlPrint(_x_) BinlPrintRoutine _x_;

#if DBG

VOID
BinlDumpMessage(
    DWORD BinlDebugFlag,
    LPDHCP_MESSAGE BinlMessage
    );

VOID
BinlAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    );

#define BinlAssert(Predicate) \
    { \
    if (!(Predicate)) {\
            BinlAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
        } \
    }

#define BinlAssertMsg(Predicate, Message) \
    { \
    if (!(Predicate)) {\
            BinlAssertFailed( #Predicate, __FILE__, __LINE__, #Message ); \
        } \
    }

#define BinlPrintDbg(_x_) BinlPrintRoutine _x_;

#define TraceFunc( _func )  BinlPrintDbg(( DEBUG_FUNC, "%s", _func ));

//
// Leak detection
//
#define INITIALIZE_TRACE_MEMORY     InitializeCriticalSection( &g_TraceMemoryCS );
#define UNINITIALIZE_TRACE_MEMORY   DebugMemoryCheck( ); DeleteCriticalSection( &g_TraceMemoryCS );

CRITICAL_SECTION g_TraceMemoryCS;

HGLOBAL
DebugAlloc(
    LPCSTR pszFile,
    UINT    uLine,
    LPCSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCSTR pszComment );

void
DebugMemoryDelete(
    HGLOBAL hglobal );

HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCSTR pszFile,
    UINT    uLine,
    LPCSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCSTR pszComment );

HGLOBAL
DebugFree(
    HGLOBAL hglobal );

void
DebugMemoryCheck( );

#else   // not DBG

#define INITIALIZE_TRACE_MEMORY
#define UNINITIALIZE_TRACE_MEMORY

#define BinlPrintDbg(_x_)
#define TraceFunc( _func )
#define BinlAssert(_x_)
#define BinlAssertMsg(_x_, _y_)
#define BinlDumpMessage(_x_, _y_)
#define DebugMemoryAdd( x1, x2, x3, x4, x5, x6, x7 )

#endif // not DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\debug.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This file contains debugging macros for the BINL server.

Author:

    Madan Appiah  (madana)  10-Sep-1993

Environment:

    User Mode - Win32

Revision History:


--*/

#include "binl.h"
#pragma hdrstop

const char g_szTrue[] = "True";
const char g_szFalse[] = "False";

DWORD DebugRefCount = 0;

VOID
DebugInitialize (
    VOID
    )
{
    DWORD dwErr;
    HKEY KeyHandle;

    //
    // only initialize debugging once.
    //
    InterlockedIncrement(&DebugRefCount);
    if (DebugRefCount > 1) {
        return;
    }

    InitializeCriticalSection(&BinlGlobalDebugFileCritSect);
    BinlGlobalDebugFileHandle = NULL;

    BinlGlobalDebugFileMaxSize = DEFAULT_MAXIMUM_DEBUGFILE_SIZE;
    BinlGlobalDebugSharePath = NULL;

    // Read DebugFlags value
    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                BINL_PARAMETERS_KEY,
                0,
                KEY_QUERY_VALUE,
                &KeyHandle );
    if ( dwErr == ERROR_SUCCESS ) {
        BinlGlobalDebugFlag = ReadDWord( KeyHandle, BINL_DEBUG_KEY, 0 );
        BinlPrintDbg(( DEBUG_OPTIONS, "Debug Flags = 0x%08x.\n", BinlGlobalDebugFlag ));
        RegCloseKey( KeyHandle );
    }

#if DBG
    // break in the debugger if we are asked to do so.
    if(BinlGlobalDebugFlag & DEBUG_STARTUP_BRK) {
        BinlPrintDbg(( 0, "Stopping at DebugInitialize()'s DebugBreak( ).\n" ));
        DebugBreak();
    }
#endif

    //
    // Open debug log file.
    //

    if ( BinlGlobalDebugFlag & DEBUG_LOG_IN_FILE ) {
        BinlOpenDebugFile( FALSE );  // not a reopen.
    }

} // DebugInitialize

VOID
DebugUninitialize (
    VOID
    )
{
    
    //
    // Make sure debugging has been initialized before we go
    // uninitializing it.
    //
    if( DebugRefCount == 0 ) {
        // do nothing.
        return;
    }


    //
    // Don't uninitialize if there are other's depending on
    // our debugging engine.
    //
    InterlockedDecrement(&DebugRefCount);
    if (DebugRefCount > 0) {
        return;
    }
    
    EnterCriticalSection( &BinlGlobalDebugFileCritSect );
    if ( BinlGlobalDebugFileHandle != NULL ) {
        CloseHandle( BinlGlobalDebugFileHandle );
        BinlGlobalDebugFileHandle = NULL;
    }

    if( BinlGlobalDebugSharePath != NULL ) {
        BinlFreeMemory( BinlGlobalDebugSharePath );
        BinlGlobalDebugSharePath = NULL;
    }

    LeaveCriticalSection( &BinlGlobalDebugFileCritSect );

    DeleteCriticalSection( &BinlGlobalDebugFileCritSect );

} // DebugUninitialize

VOID
BinlOpenDebugFile(
    IN BOOL ReopenFlag
    )
/*++

Routine Description:

    Opens or re-opens the debug file

Arguments:

    ReopenFlag - TRUE to indicate the debug file is to be closed, renamed,
        and recreated.

Return Value:

    None

--*/

{
    WCHAR LogFileName[500];
    WCHAR BakFileName[500];
    DWORD FileAttributes;
    DWORD PathLength;
    DWORD WinError;

    //
    // Close the handle to the debug file, if it is currently open
    //

    EnterCriticalSection( &BinlGlobalDebugFileCritSect );
    if ( BinlGlobalDebugFileHandle != NULL ) {
        CloseHandle( BinlGlobalDebugFileHandle );
        BinlGlobalDebugFileHandle = NULL;
    }
    LeaveCriticalSection( &BinlGlobalDebugFileCritSect );

    //
    // make debug directory path first, if it is not made before.
    //
    if( BinlGlobalDebugSharePath == NULL ) {

        if ( !GetWindowsDirectoryW(
                LogFileName,
                sizeof(LogFileName)/sizeof(WCHAR) ) ) {
            BinlPrintDbg((DEBUG_ERRORS, "Window Directory Path can't be "
                        "retrieved, %lu.\n", GetLastError() ));
            return;
        }

        //
        // check debug path length.
        //

        PathLength = wcslen(LogFileName) * sizeof(WCHAR) +
                        sizeof(DEBUG_DIR) + sizeof(WCHAR);

        if( (PathLength + sizeof(DEBUG_FILE) > sizeof(LogFileName) )  ||
            (PathLength + sizeof(DEBUG_BAK_FILE) > sizeof(BakFileName) ) ) {

            BinlPrintDbg((DEBUG_ERRORS, "Debug directory path (%ws) length is too long.\n",
                        LogFileName));
            goto ErrorReturn;
        }

        wcscat(LogFileName, DEBUG_DIR);

        //
        // copy debug directory name to global var.
        //

        BinlGlobalDebugSharePath =
            BinlAllocateMemory( (wcslen(LogFileName) + 1) * sizeof(WCHAR) );

        if( BinlGlobalDebugSharePath == NULL ) {
            BinlPrintDbg((DEBUG_ERRORS, "Can't allocate memory for debug share "
                                    "(%ws).\n", LogFileName));
            goto ErrorReturn;
        }

        wcscpy(BinlGlobalDebugSharePath, LogFileName);
    }
    else {
        wcscpy(LogFileName, BinlGlobalDebugSharePath);
    }

    //
    // Check this path exists.
    //

    FileAttributes = GetFileAttributesW( LogFileName );

    if( FileAttributes == 0xFFFFFFFF ) {

        WinError = GetLastError();
        if( WinError == ERROR_FILE_NOT_FOUND ) {

            //
            // Create debug directory.
            //

            if( !CreateDirectoryW( LogFileName, NULL) ) {
                BinlPrintDbg((DEBUG_ERRORS, "Can't create Debug directory (%ws), "
                            "%lu.\n", LogFileName, GetLastError() ));
                goto ErrorReturn;
            }

        }
        else {
            BinlPrintDbg((DEBUG_ERRORS, "Can't Get File attributes(%ws), "
                        "%lu.\n", LogFileName, WinError ));
            goto ErrorReturn;
        }
    }
    else {

        //
        // if this is not a directory.
        //

        if(!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

            BinlPrintDbg((DEBUG_ERRORS, "Debug directory path (%ws) exists "
                         "as file.\n", LogFileName));
            goto ErrorReturn;
        }
    }

    //
    // Create the name of the old and new log file names
    //

    (VOID) wcscpy( BakFileName, LogFileName );
    (VOID) wcscat( LogFileName, DEBUG_FILE );
    (VOID) wcscat( BakFileName, DEBUG_BAK_FILE );


    //
    // If this is a re-open,
    //  delete the backup file,
    //  rename the current file to the backup file.
    //

    if ( ReopenFlag ) {

        if ( !DeleteFile( BakFileName ) ) {
            WinError = GetLastError();
            if ( WinError != ERROR_FILE_NOT_FOUND ) {
                BinlPrintDbg((DEBUG_ERRORS,
                    "Cannot delete %ws (%ld)\n",
                    BakFileName,
                    WinError ));
                BinlPrintDbg((DEBUG_ERRORS, "   Try to re-open the file.\n"));
                ReopenFlag = FALSE;     // Don't truncate the file
            }
        }
    }

    if ( ReopenFlag ) {
        if ( !MoveFile( LogFileName, BakFileName ) ) {
            BinlPrintDbg((DEBUG_ERRORS,
                    "Cannot rename %ws to %ws (%ld)\n",
                    LogFileName,
                    BakFileName,
                    GetLastError() ));
            BinlPrintDbg((DEBUG_ERRORS,
                "   Try to re-open the file.\n"));
            ReopenFlag = FALSE;     // Don't truncate the file
        }
    }

    //
    // Open the file.
    //

    EnterCriticalSection( &BinlGlobalDebugFileCritSect );
    BinlGlobalDebugFileHandle = CreateFileW( LogFileName,
                                  GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  ReopenFlag ? CREATE_ALWAYS : OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL );


    if ( BinlGlobalDebugFileHandle == INVALID_HANDLE_VALUE ) {
        BinlPrintDbg((DEBUG_ERRORS,  "cannot open %ws ,\n",
                    LogFileName ));
        LeaveCriticalSection( &BinlGlobalDebugFileCritSect );
        goto ErrorReturn;
    } else {
        // Position the log file at the end
        (VOID) SetFilePointer( BinlGlobalDebugFileHandle,
                               0,
                               NULL,
                               FILE_END );
    }

    LeaveCriticalSection( &BinlGlobalDebugFileCritSect );
    return;

ErrorReturn:
    BinlPrintDbg((DEBUG_ERRORS,
            "   Debug output will be written to debug terminal.\n"));
    return;
}

#define MAX_PRINTF_LEN 1024        // Arbitrary.
char OutputBuffer[MAX_PRINTF_LEN]; // protected by BinlGlobalDebugFileCritSect


VOID
BinlPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{
    va_list arglist;
    
    ULONG length;
    DWORD BytesWritten;
    static BeginningOfLine = TRUE;
    static LineCount = 0;
    static TruncateLogFileInProgress = FALSE;
    LPSTR Text;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( DebugFlag != 0 && (BinlGlobalDebugFlag & DebugFlag) == 0 ) {
        return;
    }

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    EnterCriticalSection( &BinlGlobalDebugFileCritSect );
    length = 0;

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        //
        // If the log file is getting huge,
        //  truncate it.
        //

        if ( BinlGlobalDebugFileHandle != NULL &&
             !TruncateLogFileInProgress ) {

            //
            // Only check every 50 lines,
            //

            LineCount++;
            if ( LineCount >= 50 ) {
                DWORD FileSize;
                LineCount = 0;

                //
                // Is the log file too big?
                //

                FileSize = GetFileSize( BinlGlobalDebugFileHandle, NULL );
                if ( FileSize == 0xFFFFFFFF ) {
                    (void) DbgPrint( "[BinlServer] Cannot GetFileSize %ld\n",
                                     GetLastError() );
                } else if ( FileSize > BinlGlobalDebugFileMaxSize ) {
                    TruncateLogFileInProgress = TRUE;
                    LeaveCriticalSection( &BinlGlobalDebugFileCritSect );
                    BinlOpenDebugFile( TRUE );
                    BinlPrint(( DEBUG_MISC,
                              "Logfile truncated because it was larger than %ld bytes\n",
                              BinlGlobalDebugFileMaxSize ));
                    EnterCriticalSection( &BinlGlobalDebugFileCritSect );
                    TruncateLogFileInProgress = FALSE;
                }

            }
        }

        //  Indicate this is a BINL server's message.

        length += (ULONG) sprintf( &OutputBuffer[length], "[BinlServer] " );

        //
        // Put the thread id at the begining of the line.
        //
        if (BinlGlobalDebugFlag & DEBUG_THREAD) {
            DWORD threadId = GetCurrentThreadId();
            length += (ULONG) sprintf( &OutputBuffer[length],
                                  "%08x ", threadId );
        }

        //
        // Put the timestamp at the begining of the line.
        //
        if (BinlGlobalDebugFlag & DEBUG_TIMESTAMP) {
            SYSTEMTIME SystemTime;
            GetLocalTime( &SystemTime );
            length += (ULONG) sprintf( &OutputBuffer[length],
                                  "%02u/%02u %02u:%02u:%02u ",
                                  SystemTime.wMonth,
                                  SystemTime.wDay,
                                  SystemTime.wHour,
                                  SystemTime.wMinute,
                                  SystemTime.wSecond );
        }

        //
        // Indicate the type of message on the line
        //
        switch (DebugFlag) {
            case DEBUG_OPTIONS:
                Text = "OPTIONS";
                break;

            case DEBUG_ERRORS:
                Text = "ERRORS";
                break;

            case DEBUG_STOC:
                Text = "STOC";
                break;

            case DEBUG_INIT:
                Text = "INIT";
                break;

            case DEBUG_SCAVENGER:
                Text = "SCAVENGER";
                break;

            case DEBUG_REGISTRY:
                Text = "REGISTRY";
                break;

            case DEBUG_NETINF:
                Text = "NETINF";
                break;

            case DEBUG_MISC:
                Text = "MISC";
                break;

            case DEBUG_MESSAGE:
                Text = "MESSAGE";
                break;

            case DEBUG_LOG_IN_FILE:
                Text = "LOG_IN_FILE";
                break;

            default:
                Text = NULL;
                break;
        }

        if ( Text != NULL ) {
            length += (ULONG) sprintf( &OutputBuffer[length], "[%s] ", Text );
        }
    }

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);

    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    BeginningOfLine = (length > 0 && OutputBuffer[length-1] == '\n' );

    va_end(arglist);

    // Add in the fix for notepad users and fixing the assert
    BinlAssert(length < MAX_PRINTF_LEN - 1);
    if(BeginningOfLine){
        OutputBuffer[length-1] = '\r';
        OutputBuffer[length] = '\n';
        length++;
        OutputBuffer[length] = '\0';
    }



    //
    // Output to the debug terminal,
    //  if the log file isn't open or we are asked to do so.
    //

    if ( (BinlGlobalDebugFileHandle == NULL) ||
         !(BinlGlobalDebugFlag & DEBUG_LOG_IN_FILE) ) {

        //
        // Don't use DbgPrint(OutputBuffer) here because the buffer
        // might contain strings that printf will try to interpret
        // (e.g., NewMachineNamingPolicy = %1Fist%Last%#).
        //

        (void) DbgPrint( "%s", (PCH)OutputBuffer);

    //
    // Write the debug info to the log file.
    //

    } else {
        if ( !WriteFile( BinlGlobalDebugFileHandle,
                         OutputBuffer,
                         strlen( OutputBuffer ),
                         &BytesWritten,
                         NULL ) ) {
            (void) DbgPrint( "%s", (PCH) OutputBuffer);
        }

    }

    LeaveCriticalSection( &BinlGlobalDebugFileCritSect );

}

#if DBG

VOID
BinlAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    )
/*++

Routine Description:

    Assertion failed.

Arguments:

    FailedAssertion :

    FileName :

    LineNumber :

    Message :

Return Value:

    none.

--*/
{
    RtlAssert(
            FailedAssertion,
            FileName,
            (ULONG) LineNumber,
            (PCHAR) Message);

    BinlPrintDbg(( 0, "Assert @ %s \n", FailedAssertion ));
    BinlPrintDbg(( 0, "Assert Filename, %s \n", FileName ));
    BinlPrintDbg(( 0, "Line Num. = %ld.\n", LineNumber ));
    BinlPrintDbg(( 0, "Message is %s\n", Message ));
#if DBG
    DebugBreak( );
#endif
}

VOID
BinlDumpMessage(
    DWORD BinlDebugFlag,
    LPDHCP_MESSAGE BinlMessage
    )
/*++

Routine Description:

    This function dumps a DHCP packet in human readable form.

Arguments:

    BinlDebugFlag - debug flag that indicates what we are debugging.

    BinlMessage - A pointer to a DHCP message.

Return Value:

    None.

--*/
{
    LPOPTION option;
    BYTE i;

    BinlPrintDbg(( BinlDebugFlag, "Binl message: \n\n"));

    BinlPrintDbg(( BinlDebugFlag, "Operation              :"));
    if ( BinlMessage->Operation == BOOT_REQUEST ) {
        BinlPrintDbg(( BinlDebugFlag,  "BootRequest\n"));
    } else if ( BinlMessage->Operation == BOOT_REPLY ) {
        BinlPrintDbg(( BinlDebugFlag,  "BootReply\n"));
    } else {
        BinlPrintDbg(( BinlDebugFlag,  "Unknown %x\n", BinlMessage->Operation));
        return;
    }

    BinlPrintDbg(( BinlDebugFlag, "Hardware Address type  : %d\n", BinlMessage->HardwareAddressType));
    BinlPrintDbg(( BinlDebugFlag, "Hardware Address Length: %d\n", BinlMessage->HardwareAddressLength));
    BinlPrintDbg(( BinlDebugFlag, "Hop Count              : %d\n", BinlMessage->HopCount ));
    BinlPrintDbg(( BinlDebugFlag, "Transaction ID         : %lx\n", BinlMessage->TransactionID ));
    BinlPrintDbg(( BinlDebugFlag, "Seconds Since Boot     : %d\n", BinlMessage->SecondsSinceBoot ));
    BinlPrintDbg(( BinlDebugFlag, "Client IP Address      : " ));
    BinlPrintDbg(( BinlDebugFlag, "%s\n",
        inet_ntoa(*(struct in_addr *)&BinlMessage->ClientIpAddress ) ));

    BinlPrintDbg(( BinlDebugFlag, "Your IP Address        : " ));
    BinlPrintDbg(( BinlDebugFlag, "%s\n",
        inet_ntoa(*(struct in_addr *)&BinlMessage->YourIpAddress ) ));

    BinlPrintDbg(( BinlDebugFlag, "Server IP Address      : " ));
    BinlPrintDbg(( BinlDebugFlag, "%s\n",
        inet_ntoa(*(struct in_addr *)&BinlMessage->BootstrapServerAddress ) ));

    BinlPrintDbg(( BinlDebugFlag, "Relay Agent IP Address : " ));
    BinlPrintDbg(( BinlDebugFlag, "%s\n",
        inet_ntoa(*(struct in_addr *)&BinlMessage->RelayAgentIpAddress ) ));

    BinlPrintDbg(( BinlDebugFlag, "Hardware Address       : "));
    for ( i = 0; i < BinlMessage->HardwareAddressLength; i++ ) {
        BinlPrintDbg(( BinlDebugFlag, "%2.2x", BinlMessage->HardwareAddress[i] ));
    }

    option = &BinlMessage->Option;

    BinlPrintDbg(( BinlDebugFlag, "\n\n"));
    BinlPrintDbg(( BinlDebugFlag, "Magic Cookie: "));
    for ( i = 0; i < 4; i++ ) {
        BinlPrintDbg(( BinlDebugFlag, "%d ", *((LPBYTE)option)++ ));
    }
    BinlPrintDbg(( BinlDebugFlag, "\n\n"));

    BinlPrintDbg(( BinlDebugFlag, "Options:\n"));
    while ( option->OptionType != 255 ) {
        BinlPrintDbg(( BinlDebugFlag, "\tType = %d ", option->OptionType ));
        for ( i = 0; i < option->OptionLength; i++ ) {
            BinlPrintDbg(( BinlDebugFlag, "%2.2x", option->OptionValue[i] ));
        }
        BinlPrintDbg(( BinlDebugFlag, "\n"));

        if ( option->OptionType == OPTION_PAD ||
             option->OptionType == OPTION_END ) {

            option = (LPOPTION)( (LPBYTE)(option) + 1);

        } else {

            option = (LPOPTION)( (LPBYTE)(option) + option->OptionLength + 2);

        }

        if ( (LPBYTE)option - (LPBYTE)BinlMessage > DHCP_MESSAGE_SIZE ) {
            BinlPrintDbg(( BinlDebugFlag, "End of message, but no trailer found!\n"));
            break;
        }
    }
}
#endif // DBG


DWORD
BinlReportEventW(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPWSTR *Strings,
    LPVOID Data
    )
/*++

Routine Description:

    This function writes the specified (EventID) log at the end of the
    eventlog.

Arguments:

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event

    NumStrings - Specifies the number of strings that are in the array
                    at 'Strings'. A value of zero indicates no strings
                    are present.

    DataLength - Specifies the number of bytes of event-specific raw
                    (binary) data to write to the log. If cbData is
                    zero, no event-specific data is present.

    Strings - Points to a buffer containing an array of null-terminated
                strings that are merged into the message before
                displaying to the user. This parameter must be a valid
                pointer (or NULL), even if cStrings is zero.

    Data - Buffer containing the raw data. This parameter must be a
            valid pointer (or NULL), even if cbData is zero.


Return Value:

    Returns the WIN32 extended error obtained by GetLastError().

    NOTE : This function works slow since it calls the open and close
            eventlog source everytime.

--*/
{
    HANDLE EventlogHandle;
    DWORD ReturnCode;


    //
    // open eventlog section.
    //

    EventlogHandle = RegisterEventSourceW(NULL, BINL_SERVER);

    if (EventlogHandle == NULL) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }


    //
    // Log the error code specified
    //

    if( !ReportEventW(
            EventlogHandle,
            (WORD)EventType,
            0,            // event category
            EventID,
            NULL,
            (WORD)NumStrings,
            DataLength,
            Strings,
            Data
            ) ) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }

    ReturnCode = NO_ERROR;

Cleanup:

    if( EventlogHandle != NULL ) {

        DeregisterEventSource(EventlogHandle);
    }

    return ReturnCode;
}


DWORD
BinlReportEventA(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    )
/*++

Routine Description:

    This function writes the specified (EventID) log at the end of the
    eventlog.

Arguments:

    Source - Points to a null-terminated string that specifies the name
             of the module referenced. The node must exist in the
             registration database, and the module name has the
             following format:

                \EventLog\System\Lanmanworkstation

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event

    NumStrings - Specifies the number of strings that are in the array
                    at 'Strings'. A value of zero indicates no strings
                    are present.

    DataLength - Specifies the number of bytes of event-specific raw
                    (binary) data to write to the log. If cbData is
                    zero, no event-specific data is present.

    Strings - Points to a buffer containing an array of null-terminated
                strings that are merged into the message before
                displaying to the user. This parameter must be a valid
                pointer (or NULL), even if cStrings is zero.

    Data - Buffer containing the raw data. This parameter must be a
            valid pointer (or NULL), even if cbData is zero.


Return Value:

    Returns the WIN32 extended error obtained by GetLastError().

    NOTE : This function works slow since it calls the open and close
            eventlog source everytime.

--*/
{
    HANDLE EventlogHandle;
    DWORD ReturnCode;


    //
    // open eventlog section.
    //

    EventlogHandle = RegisterEventSourceW(
                    NULL,
                    BINL_SERVER
                    );

    if (EventlogHandle == NULL) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }


    //
    // Log the error code specified
    //

    if( !ReportEventA(
            EventlogHandle,
            (WORD)EventType,
            0,            // event category
            EventID,
            NULL,
            (WORD)NumStrings,
            DataLength,
            Strings,
            Data
            ) ) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }

    ReturnCode = NO_ERROR;

Cleanup:

    if( EventlogHandle != NULL ) {

        DeregisterEventSource(EventlogHandle);
    }

    return ReturnCode;
}

VOID
BinlServerEventLog(
    DWORD EventID,
    DWORD EventType,
    DWORD ErrorCode
    )
/*++

Routine Description:

    Logs an event in EventLog.

Arguments:

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event


    ErrorCode - Error Code to be Logged.

Return Value:

    None.

--*/

{
    DWORD Error;
    LPSTR Strings[1];
    CHAR ErrorCodeOemString[32 + 1];

    wsprintfA( ErrorCodeOemString, "%lu", ErrorCode );

    Strings[0] = ErrorCodeOemString;

    Error = BinlReportEventA(
                EventID,
                EventType,
                1,
                sizeof(ErrorCode),
                Strings,
                &ErrorCode );

    if( Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_ERRORS,
            "BinlReportEventW failed, %ld.\n", Error ));
    }

    return;
}


#if DBG==1

//
// Memory allocation and tracking
//

LPVOID g_TraceMemoryTable = NULL;
CRITICAL_SECTION g_TraceMemoryCS;


#define DEBUG_OUTPUT_BUFFER_SIZE 1024

typedef struct _MEMORYBLOCK {
    HGLOBAL hglobal;
    struct _MEMORYBLOCK *pNext;
    LPCSTR pszModule;
    LPCSTR pszComment;
    LPCSTR pszFile;
    DWORD   dwBytes;
    UINT    uFlags;
    UINT    uLine;    
} MEMORYBLOCK, *LPMEMORYBLOCK;

//
// Takes the filename and line number and put them into a string buffer.
//
// NOTE: the buffer is assumed to be of size DEBUG_OUTPUT_BUFFER_SIZE.
//
LPSTR
dbgmakefilelinestring(
    LPSTR  pszBuf,
    LPCSTR pszFile,
    UINT    uLine )
{
    LPVOID args[2];

    args[0] = (LPVOID) pszFile;
    args[1] = (LPVOID) UintToPtr( uLine );

    FormatMessageA(
        FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
        "%1(%2!u!):",
        0,                          // error code
        0,                          // default language
        (LPSTR) pszBuf,             // output buffer
        DEBUG_OUTPUT_BUFFER_SIZE,   // size of buffer
        (va_list*) args );         // arguments

    return pszBuf;
}

//
// Adds a MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCSTR pszFile,
    UINT    uLine,
    LPCSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCSTR pszComment )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmb     = (LPMEMORYBLOCK) GlobalAlloc(
                                                    GMEM_FIXED,
                                                    sizeof(MEMORYBLOCK) );

        if ( !pmb )
        {
            GlobalFree( hglobal );
            return NULL;
        }

        pmb->hglobal    = hglobal;
        pmb->dwBytes    = dwBytes;
        pmb->uFlags     = uFlags;
        pmb->pszFile    = pszFile;
        pmb->uLine      = uLine;
        pmb->pszModule  = pszModule;
        pmb->pszComment = pszComment;

        EnterCriticalSection( &g_TraceMemoryCS );

        pmb->pNext         = g_TraceMemoryTable;
        g_TraceMemoryTable = pmb;

        BinlPrintDbg((DEBUG_MEMORY, "DebugAlloc: 0x%08x alloced (%s)\n", hglobal, pmb->pszComment ));

        LeaveCriticalSection( &g_TraceMemoryCS );
    }

    return hglobal;
}

//
// Removes a MEMORYBLOCK to the memory tracking list.
//
void
DebugMemoryDelete(
    HGLOBAL hglobal )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead;
        LPMEMORYBLOCK pmbLast = NULL;

        EnterCriticalSection( &g_TraceMemoryCS );
        pmbHead = g_TraceMemoryTable;

        while ( pmbHead && pmbHead->hglobal != hglobal )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        }

        if ( pmbHead )
        {
            HGLOBAL *p;
            if ( pmbLast )
            {
                pmbLast->pNext = pmbHead->pNext;
            }
            else
            {
                g_TraceMemoryTable = pmbHead->pNext;
            }

            BinlPrintDbg((DEBUG_MEMORY, "DebugFree: 0x%08x freed (%s)\n", hglobal,
                pmbHead->pszComment ));

            p = (HGLOBAL)((LPBYTE)hglobal + pmbHead->dwBytes - sizeof(HGLOBAL));
            if ( *p != hglobal )
            {
                BinlPrintDbg(((DEBUG_ERRORS|DEBUG_MEMORY), "DebugFree: Heap check FAILED for %0x08x %u bytes (%s).\n",
                    hglobal, pmbHead->dwBytes, pmbHead->pszComment));
                BinlPrintDbg(((DEBUG_ERRORS|DEBUG_MEMORY), "DebugFree: %s, Line: %u\n",
                    pmbHead->pszFile, pmbHead->uLine ));
                BinlAssert( *p == hglobal );
            }

            memset( hglobal, 0xFE, pmbHead->dwBytes );
            memset( pmbHead, 0xFD, sizeof(sizeof(MEMORYBLOCK)) );

            LocalFree( pmbHead );
        }
        else
        {
            HGLOBAL *p;

            BinlPrintDbg(((DEBUG_ERRORS|DEBUG_MEMORY), "DebugFree: 0x%08x not found in memory table\n", hglobal ));
            memset( hglobal, 0xFE, (int)LocalSize( hglobal ));
        }

        LeaveCriticalSection( &g_TraceMemoryCS );

    }
}

//
// Allocates memory and adds the MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugAlloc(
    LPCSTR pszFile,
    UINT    uLine,
    LPCSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCSTR pszComment )
{
    HGLOBAL hglobal;
    DWORD dwBytesToAlloc = ROUND_UP_COUNT( dwBytes + sizeof(HGLOBAL), ALIGN_WORST);

    HGLOBAL *p;
    hglobal = GlobalAlloc( uFlags, dwBytesToAlloc );
    if (hglobal == NULL) {
        return NULL;
    }
    p = (HGLOBAL)((LPBYTE)hglobal + dwBytesToAlloc - sizeof(HGLOBAL));
    *p = hglobal;

    return DebugMemoryAdd( hglobal, pszFile, uLine, pszModule, uFlags, dwBytesToAlloc, pszComment );
}

//
// Remove the MEMORYBLOCK to the memory tracking list, memsets the
// memory to 0xFE and then frees the memory.
//
HGLOBAL
DebugFree(
    HGLOBAL hglobal )
{
    DebugMemoryDelete( hglobal );

    return GlobalFree( hglobal );
}

//
// Checks the memory tracking list. If it is not empty, it will dump the
// list and break.
//
void
DebugMemoryCheck( )
{
    BOOL          fFoundLeak = FALSE;
    LPMEMORYBLOCK pmb;

    EnterCriticalSection( &g_TraceMemoryCS );

    pmb = g_TraceMemoryTable;
    while ( pmb )
    {
        LPMEMORYBLOCK pTemp;
        LPVOID args[ 5 ];
        CHAR  szOutput[ DEBUG_OUTPUT_BUFFER_SIZE ];
        CHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( fFoundLeak == FALSE )
        {
            BinlPrintRoutine( 0, "\n***************************** Memory leak detected *****************************\n\n");
          //BinlPrintRoutine( 0, "1234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1...");
            BinlPrintRoutine( 0, "Filename(Line Number):                    Module     Addr/HGLOBAL  Size   String\n");
            fFoundLeak = TRUE;
        }

        args[0] = (LPVOID) pmb->hglobal;
        args[1] = (LPVOID) szFileLine;
        args[2] = (LPVOID) pmb->pszComment;
        args[3] = (LPVOID) ULongToPtr( pmb->dwBytes );
        args[4] = (LPVOID) pmb->pszModule;

        dbgmakefilelinestring( szFileLine, pmb->pszFile, pmb->uLine );

        if ( !!(pmb->uFlags & GMEM_MOVEABLE) )
        {
            FormatMessageA(
                FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                "%2!-40s!  %5!-10s! H 0x%1!08x!  %4!-5u!  \"%3\"\n",
                0,                          // error code
                0,                          // default language
                szOutput,                   // output buffer
                DEBUG_OUTPUT_BUFFER_SIZE,   // size of buffer
                (va_list*) args );           // arguments
        }
        else
        {
            FormatMessageA(
                FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                "%2!-40s!  %5!-10s! A 0x%1!08x!  %4!-5u!  \"%3\"\n",
                0,                          // error code
                0,                          // default language
                szOutput,                   // output buffer
                DEBUG_OUTPUT_BUFFER_SIZE,   // size of buffer
                (va_list*) args );           // arguments
        }

        BinlPrintRoutine( 0,  szOutput );

        pTemp = pmb;
        pmb = pmb->pNext;
        memset( pTemp, 0xFD, sizeof(MEMORYBLOCK) );
        LocalFree( pTemp );
    }

    if ( fFoundLeak == TRUE )
    {
        BinlPrintRoutine( 0, "\n***************************** Memory leak detected *****************************\n\n");
    }

    LeaveCriticalSection( &g_TraceMemoryCS );

    //BinlAssert( !fFoundLeak );
}

VOID
DumpBuffer(
    PVOID Buffer,
    ULONG BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    ULONG i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    PUCHAR BufferPtr = Buffer;


    DbgPrint("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            DbgPrint("%02x ", (UCHAR)BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            DbgPrint("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            DbgPrint("  %s\n", TextBuffer);
        }

    }

    DbgPrint("------------------------------------\n");
}


#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\client.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    client.c

Abstract:

    This module contains the code to process OS Chooser message
    for the BINL server.

Author:

    Adam Barr (adamba)  9-Jul-1997
    Geoff Pease (gpease) 10-Nov-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include "binl.h"
#pragma hdrstop
#include "mbstring.h"

//
// List of maximums for certain variables. OscAddVariableX will fail if
// the limits are exceeded; it is up to the caller of the function to know
// if the variable being added might hit a limit and check for failure.
//

typedef struct OSC_VARIABLE_MAXIMUM {
    LPSTR VariableName;
    ULONG MaximumLength;
} OSC_VARIABLE_MAXIMUM, *POSC_VARIABLE_MAXIMUM;

OSC_VARIABLE_MAXIMUM OscMaximums[] = {
    //
    // This set of variables come from locations we don't completely control,
    // so we need to check the return code from OscAddVariable each time.
    //
    { "BOOTFILE",  127 },   // with NULL, must fit in 128-byte field of CREATE_DATA.
                            // Normally this will be empty or come from a .sif;
                            // an admin may customize the .sif or modify the
                            // DS attribute directly.
    { "MACHINENAME", 63 },  // used in path with SERVERNAME; comes from a screen
                            // input with a max length of 63, or else is generated
                            // by the GenerateMachineName() function. 63 is equal
                            // to DNS_MAX_LABEL_LENGTH.
    { "SIFFILE", 127 },     // with NULL, must fit in 128-byte field of CREATE_DATA.
                            // Normally this will be \RemoteInstall\tmp\[GUID].sif,
                            // but the path may be longer.
    { "INSTALLPATH", 127 }, // used in paths with MACHINETYPE and SERVERNAME. This
                            // will depend on where the build is installed
                            // with RISETUP.
    //
    // The ones after this will be correct when we add them, but a rogue
    // client might send in bogus values. So the general checking code in
    // OscProcessScreenArguments will catch invalid ones.
    //
    { "MACHINETYPE", MAX_ARCHITECTURE_LENGTH },
                            // current max value. This is sent up by oschooser
                            // and should correspond to where RISETUP puts
                            // the platform-specific files.
    { "SERVERNAME", 63 },   // used in paths with MACHINENAME and INSTALLPATH,
                            // set by calling GetComputerNameEX(ComputerNameNetBIOS)
    { "NETBIOSNAME", 31 },  // with NULL, must fit in 32-byte field of CREATE_DATA.
                            // This is gotten by calling DnsHostnameToComputerNameW(),
                            // if that fails the name is truncated to 15 chars
    { "LANGUAGE", 32 },     // reasonable max value; this is obtained by calling
                            // GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SENGLANGUAGE),
                            // but can be over-ridden in the registry. It is used in
                            // paths with IntelliMirrorPathW and some other constants,
                            // but no other variables. Eventually this becomes
                            // a part of INSTALLPATH and sometimes BOOTFILE.
    { "GUID", 32 },         // 16 bytes in hex format
    { "MAC", 12 },          // 6 bytes in hex format
    //
    // NOTE: If we get an error condition, we add the variable SUBERROR
    // to the client state. So don't put a limit on SUBERROR size, since
    // that might cause an infinite loop.
    //
};

#define OSC_VARIABLE_MAXIMUM_COUNT (sizeof(OscMaximums) / sizeof(OSC_VARIABLE_MAXIMUM))

//
//  We need to eliminate the chance of denial of service attacks so we'll limit
//  the number of concurrent clients we support.
//

#define BINL_MAX_CLIENT_RECORDS 1000
LONG BinlGlobalClientLimit = BINL_MAX_CLIENT_RECORDS;

DWORD
OscUpdatePassword(
    IN PCLIENT_STATE ClientState,
    IN PWCHAR SamAccountName,
    IN PWCHAR Password,
    IN LDAP * LdapHandle,
    IN PLDAPMessage LdapMessage
    )
/*++

Routine Description:

    Sets the password for the client. NOTE: WE MUST BE BETWEEN CALLS TO
    OSCIMPERSONATE/OSCREVERT.

Arguments:

    ClientState - The client state. AuthenticatedDCLdapHandle must be valid
        and we must be impersonating the client.

    SamAccountName - The name of the machine account. This is the
        "samAccountName" value from the DS, which includes the final $.

    Password - The NULL-terminated Unicode password.

    LdapHandle - The handle to the DS.

    LdapMessage - The result of an ldap search for this client.

Return Value:

    Status of the operation.

--*/

{
    BOOL bResult;
    LDAP * serverLdap;
    PWCHAR serverHostName;
    USER_INFO_1003 userInfo1003;
    PWCHAR backslashServerName;
    PWCHAR p;
    ULONG serverHostNameLength;
    DWORD paramError;
    NET_API_STATUS netStatus;

    //
    // Change the password in the DS.
    //

    serverLdap = ldap_conn_from_msg (LdapHandle, LdapMessage);
    if (serverLdap == NULL) {
        BinlPrintDbg(( DEBUG_ERRORS,
            "OscUpdatePassword ldap_conn_from_msg is NULL\n" ));
        return E_HANDLE;
    }

    serverHostName = NULL;
    if (LDAP_SUCCESS != ldap_get_option(serverLdap, LDAP_OPT_HOST_NAME, &serverHostName)) {
        BinlPrintDbg(( DEBUG_ERRORS,
                       "OscUpdatePassword ldap_get_option failed\n" ));
        return E_HANDLE;
    }
    

    userInfo1003.usri1003_password = Password;

    serverHostNameLength = wcslen(serverHostName) + 1;

    //
    // Allocate room for the name with two extra characters
    // for the leading \\.
    //

    backslashServerName = BinlAllocateMemory((serverHostNameLength+2) * sizeof(WCHAR));
    if (backslashServerName == NULL) {
        BinlPrintDbg(( DEBUG_ERRORS,
            "OscUpdatePassword could not allocate serverHostNameW\n" ));
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;
    }

    wcscpy(backslashServerName, L"\\\\");
    wcscpy(backslashServerName+2, serverHostName);

    //
    // TEMP: Serialize all calls to the NetUserSetInfo/
    // NetUserModalsGet. See discussion in bug 319962.
    // This code was put back in when the fix for a
    // problem described as "RPC is ignoring the security
    // context of the caller when choosing which named
    // pipe to send an RPC call over" turned out to cause
    // a BVT break.
    //
    EnterCriticalSection(&HackWorkaroundCriticalSection);

    netStatus = NetUserSetInfo(
                    backslashServerName,
                    SamAccountName,
                    1003,
                    (LPBYTE)&userInfo1003,
                    &paramError);

    LeaveCriticalSection(&HackWorkaroundCriticalSection);

    BinlFreeMemory(backslashServerName);

    if (netStatus != NERR_Success) {

        HANDLE TempToken;

        BinlPrint(( DEBUG_ERRORS,
            "OscUpdatePassword NetUserSetInfo returned %lx\n", netStatus ));

        //
        // If NetUserSetInfo failed, try a LogonUser to see if the
        // password is already set to the value we want -- if so,
        // we can still succeed.
        //

        bResult = LogonUser(
                      SamAccountName,
                      OscFindVariableW( ClientState, "MACHINEDOMAIN" ),
                      Password,
                      LOGON32_LOGON_NETWORK,
                      LOGON32_PROVIDER_WINNT40,
                      &TempToken);

        if (bResult) {
            CloseHandle(TempToken);
        } else {
            DWORD TempError = GetLastError();
            if (TempError != ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT) {
                return netStatus;  // return the original error
            }
        }

        //
        // Fall through and return ERROR_SUCCESS.
        //
    }

    return ERROR_SUCCESS;

}

//
// Free client state information
//
VOID
FreeClient(
    PCLIENT_STATE client
    )
{
    ULONG   i;

    TraceFunc("FreeClient( )\n");

    //
    // if this client had its name generated,
    // then attempt to remove the name from the queued DS list
    // this behavior is necessary for when a client times out
    //
    if (client->fAutomaticMachineName) {
        
        PWCHAR  pMachineName;              // Pointer to Machine Name variable value
        DWORD   Error;
        
        pMachineName = OscFindVariableW( client, "MACHINENAME" );
    
        Error = RemoveQueuedDSName(pMachineName);

        if (Error != ERROR_SUCCESS) {
            
            BinlPrintDbg(( DEBUG_ERRORS, "RemoveQueuedDSName returned with status: 0x%x\n", Error));
            
            if (Error == ERROR_NOT_FOUND) {
                
                BinlPrintDbg(( DEBUG_ERRORS, "QueuedDSName already removed\n", Error));
                
                Error = ERROR_SUCCESS;
            
            }
        
        }

    }

    BinlPrintDbg(( DEBUG_OSC, "Freeing client state for %s\n", inet_ntoa(*(struct in_addr *)&(client->RemoteIp)) ));

    DeleteCriticalSection(&client->CriticalSection);

    if (client->LastResponse)
        BinlFreeMemory(client->LastResponse);

    OscFreeClientVariables(client);

    InterlockedIncrement( &BinlGlobalClientLimit );

    if (client->NegotiateProcessed) {
        DeleteSecurityContext( &client->ServerContextHandle );
    }

    if (client->AuthenticatedDCLdapHandle) {
        ldap_unbind(client->AuthenticatedDCLdapHandle);
    }

    if (client->UserToken) {
        CloseHandle(client->UserToken);
    }

    BinlFreeMemory(client);
}

VOID
OscFreeClientVariables(
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function frees all variables in a client state.

Arguments:

    clientState - the client state pointer.

Return Value:

    None.

--*/
{
    ULONG i;

    for( i = 0; i < clientState->nVariables; i++ )
    {
        BinlFreeMemory(clientState->Variables[i].pszToken);
        if (clientState->Variables[i].pszStringA) {
            BinlFreeMemory(clientState->Variables[i].pszStringA);
            clientState->Variables[i].pszStringA = NULL;
        }
        if (clientState->Variables[i].pszStringW) {
            BinlFreeMemory(clientState->Variables[i].pszStringW);
            clientState->Variables[i].pszStringW = NULL;
        }
    }

    clientState->nVariables = 0;
    clientState->fHaveSetupMachineDN = FALSE;
    clientState->fCreateNewAccount = FALSE;
    clientState->fAutomaticMachineName = FALSE;
}

BOOLEAN
OscInitializeClientVariables(
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function cleans out any variables in the client state,
    then initializes some default values, which may later be
    overwritten by variables from client screens.

    This function is called when a client state is created, and
    when it is re-used from cache.

Arguments:

    clientState - the client state pointer.

Return Value:

    None.

--*/
{
    BOOLEAN retVal = TRUE;
    SYSTEMTIME SystemTime;
    FILETIME FileTime;
    WCHAR pTime[64];
    //
    // First clean out any variables in the client state.
    //
    OscFreeClientVariables(clientState);

    //
    // Now add the variables.
    //

    EnterCriticalSection( &gcsParameters );

    if (BinlGlobalDefaultLanguage) {
        OscAddVariableW( clientState, "LANGUAGE",     BinlGlobalDefaultLanguage );
    } else {
        OscAddVariableW( clientState, "LANGUAGE",     DEFAULT_LANGUAGE );
    }
    if (BinlGlobalDefaultOrgname) {
        OscAddVariableW( clientState, "ORGNAME",      BinlGlobalDefaultOrgname );
    } else {
        OscAddVariableW( clientState, "ORGNAME",      DEFAULT_ORGNAME );
    }
    if (BinlGlobalDefaultTimezone) {
        OscAddVariableW( clientState, "TIMEZONE",     BinlGlobalDefaultTimezone );
    } else {
        OscAddVariableW( clientState, "TIMEZONE",     DEFAULT_TIMEZONE );
    }

    if (BinlGlobalOurDomainName == NULL || BinlGlobalOurServerName == NULL) {

        LeaveCriticalSection( &gcsParameters );
        BinlPrintDbg((DEBUG_OSC_ERROR, "!! Error we don't have a FQDN for ourselves.\n" ));
        retVal = FALSE;
        goto Cleanup;

    }
    OscAddVariableW( clientState, "SERVERDOMAIN", BinlGlobalOurDomainName );

    // Add the Server's name variable

    OscAddVariableW( clientState, "SERVERNAME", BinlGlobalOurServerName );

    GetSystemTime(&SystemTime);
    if (SystemTimeToFileTime(&SystemTime,&FileTime)) {
    
        swprintf(pTime,L"%d;%d",FileTime.dwHighDateTime,FileTime.dwLowDateTime);
    
        OscAddVariableW( clientState, "ServerUTCFileTime", pTime );
    }

    OscAddVariableW( 
            clientState, 
            "NTLMV2Enabled", 
            BinlGlobalUseNTLMV2 
             ? L"1"
             : L"0" );

    LeaveCriticalSection( &gcsParameters );

    OscAddVariableA( clientState, "SUBERROR", " " );

    clientState->fHaveSetupMachineDN = FALSE;
    clientState->fCreateNewAccount = FALSE;
    clientState->fAutomaticMachineName = FALSE;

    clientState->InitializeOnFirstRequest = FALSE;

Cleanup:

    //
    // If this fails, clean up anything we set here.
    //

    if (!retVal) {
        OscFreeClientVariables(clientState);
    }

    return retVal;

}

DWORD
OscFindClient(
    ULONG RemoteIp,
    BOOL Remove,
    PCLIENT_STATE * pClientState
    )
/*++

Routine Description:

    This function looks up a client in our client database, using
    their IP address. If Remove is TRUE, it removes the entry if
    found. Otherwise, if not found, it creates a new entry.

Arguments:

    RemoteIp - the remote IP address.

    Remove - TRUE if the client should be removed if found.

    pClientState - Returns the CLIENT_STATE.

Return Value:

    ERROR_SUCCESS if it finds the client and it is not in use.
    ERROR_NOT_ENOUGH_SERVER_MEMORY if a client state could not be allocated.
    ERROR_BUSY if the client state is already being used by another thread.

--*/
{
    LONG oldCount;
    PLIST_ENTRY p;
    DWORD Error = ERROR_SUCCESS;
    PCLIENT_STATE TempClient = NULL;

    TraceFunc("OscFindClient( )\n");

    EnterCriticalSection(&ClientsCriticalSection);

    for (p = ClientsQueue.Flink;
         p != &ClientsQueue;
         p = p->Flink) {

        TempClient = CONTAINING_RECORD(p, CLIENT_STATE, Linkage);

        if (TempClient->RemoteIp == RemoteIp) {

            //
            // Found it!
            //
            if (Remove) {
                RemoveEntryList(&TempClient->Linkage);
                TraceFunc("Client removed.\n");
            }

            break;
        }
    }

    if (p == &ClientsQueue) {
        TempClient = NULL;
    }

    if (!TempClient && (!Remove)) {

        //
        // Not found, allocate a new one.
        //

        oldCount = InterlockedDecrement( &BinlGlobalClientLimit );

        if (oldCount <= 0) {

            InterlockedIncrement( &BinlGlobalClientLimit );
            BinlPrintDbg(( DEBUG_OSC_ERROR, "Way too many clients, 0x%x clients\n", BINL_MAX_CLIENT_RECORDS));
            Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
            TempClient = NULL;

        } else {

            TraceFunc("Creating new client...\n");

            TempClient = BinlAllocateMemory(sizeof(CLIENT_STATE));

            if (TempClient == NULL) {

                InterlockedIncrement( &BinlGlobalClientLimit );
                BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not get client state for %s\n", inet_ntoa(*(struct in_addr *)&RemoteIp) ));
                Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;

            } else {
                TempClient->NegotiateProcessed = FALSE;
                TempClient->AuthenticateProcessed = FALSE;
                TempClient->LastSequenceNumber = 0;
                TempClient->LastResponse = NULL;
                TempClient->LastResponseAllocated = 0;
                TempClient->PositiveRefCount = 1;
                TempClient->NegativeRefCount = 0;
                TempClient->AuthenticatedDCLdapHandle = NULL;

                TempClient->UserToken = NULL;
                TempClient->LastUpdate = GetTickCount();
                TempClient->nCreateAccountCounter = 0;

                TempClient->nVariables = 0;

                //
                // Fill in some standard variables.
                //

                if (!OscInitializeClientVariables(TempClient)) {

                    InterlockedIncrement( &BinlGlobalClientLimit );
                    BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not initialize client state for %s\n", inet_ntoa(*(struct in_addr *)&RemoteIp) ));
                    BinlFreeMemory(TempClient);
                    TempClient = NULL;
                    Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;

                } else {

                    InitializeCriticalSection(&TempClient->CriticalSection);
                    TempClient->CriticalSectionHeld = FALSE;
                    TempClient->RemoteIp = RemoteIp;

                    OscGenerateSeed(&TempClient->Seed);

                    InsertHeadList(&ClientsQueue, &TempClient->Linkage);

                    BinlPrintDbg(( DEBUG_OSC, "Allocating new client state for %s\n", inet_ntoa(*(struct in_addr *)&RemoteIp) ));
                }
            }
        }
    }

    if (TempClient) {
        //
        // Do a quick check to see if another client is using this. This
        // check is not synchronized with the setting of this variable to
        // FALSE, and it's possible two clients could slip through, but
        // that is OK since this is not fatal (each thread still needs
        // to actually get the critical section to do anything).
        //
        if (TempClient->CriticalSectionHeld && (!Remove)) {
            Error = ERROR_BUSY;
            TempClient = NULL;
        } else {
            ++TempClient->PositiveRefCount;   // need to do this inside ClientsCriticalSection
        }
    }

    LeaveCriticalSection(&ClientsCriticalSection);

    *pClientState = TempClient;
    return Error;

}


VOID
OscFreeClients(
    VOID
    )
/*++

Routine Description:

    This function frees the clients list for OS chooser. It is
    intended to be called only when the service is shutting down,
    so the critical section does not matter.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PLIST_ENTRY p;
    PCLIENT_STATE TempClient;

    TraceFunc("OscFreeClients( )\n");

    while (!IsListEmpty(&ClientsQueue)) {

        p = RemoveHeadList(&ClientsQueue);

        TempClient = CONTAINING_RECORD(p, CLIENT_STATE, Linkage);

        FreeClient(TempClient);

    }

}

VOID
SearchAndReplace(
    LPSAR psarList,
    LPSTR *pszString,
    DWORD ArraySize,
    DWORD dwSize,
    DWORD dwExtraSize )
/*++

Routine Description:


    Searches and replaces text in a ASCII (8-bit) string.

Arguments:

    psarList - SearchAndReplace structure with the list of tokens and
        and the strings that are going replace the tokens.

    pszString - the text to search and replace.

    dwSize - length of the text in pszString.

    dwExtraSize - if the buffer is reallocated, how much extra room to allocate

Return Value:

    None.

--*/
{
    LPSTR psz = *pszString;

    TraceFunc("SearchAndReplace( )\n");

    if ( !psarList || !*pszString )
        return;

    while ( *psz )
    {
        if ( *psz == '%' )
        {
            LPSAR psar = psarList;
            ULONG count = 0;
            LPSTR pszEnd;
            UCHAR ch;

            psz++;  // move forward

            //
            // Find the end of the %MACRO%
            //
            pszEnd = psz;
            while ( *pszEnd && *pszEnd !='%' )
                pszEnd++;

            //
            // Terminate but remember the character (NULL or '%')
            //
            ch = *pszEnd;
            *pszEnd = 0;

            //
            // Loop trying to match the %MACRO% when a Token
            //
            while( count++ < ArraySize ) {

                if ( _stricmp( psz, psar->pszToken ) == 0 )
                {   // match, so replace
                    DWORD dwString;
                    DWORD dwToken;

                    if ( psar->pszStringA == NULL )
                    {
                        // need to translate the string from UNICODE to ANSI
                        DWORD dwLen;
                        ANSI_STRING aString;
                        UNICODE_STRING uString;

                        uString.Buffer = psar->pszStringW;
                        uString.Length = (USHORT)( wcslen( psar->pszStringW ) * sizeof(WCHAR) );

                        dwLen = RtlUnicodeStringToAnsiSize(&uString);  // includes NULL termination

                        psar->pszStringA = BinlAllocateMemory( dwLen );

                        if (psar->pszStringA == NULL) {
                            BinlAssert( !"Out of memory!" );
                            psar++;
                            continue; // abort this replace
                        }

                        aString.Buffer = psar->pszStringA;
                        aString.MaximumLength = (USHORT)dwLen;

                        RtlUnicodeStringToAnsiString(
                            &aString,
                            &uString,
                            FALSE);

                    }

                    dwString = strlen( psar->pszStringA );
                    dwToken  = strlen( psar->pszToken );

                    psz--;  // move back

                    if ( 2 + dwToken < dwString )
                    {
                        // "%MACRO%" is smaller than "ReplaceString"
                        // Check to see if we need to grow the buffer...
                        LPSTR pszEndBuff = &psz[2 + dwToken];
                        DWORD dwLenEnd = strlen( pszEndBuff ) + 1;
                        DWORD dwLenBegin = (DWORD)( psz - *pszString );
                        DWORD dwNewSize = dwLenBegin + dwString + dwLenEnd;

                        //
                        // Does the new string fit in the old space?
                        //
                        if ( dwSize < dwNewSize )
                        {
                            //
                            // No. Make some space
                            //
                            LPSTR pszNewString;

                            dwNewSize += 1024; // with some extra to grow

                            pszNewString =  BinlAllocateMemory( dwNewSize + dwExtraSize );
                            if ( !pszNewString )
                            {
                                BinlAssert( !"Out of memory!" );
                                return; // abort the rest
                            }

                            MoveMemory( pszNewString, *pszString, dwSize );

                            dwSize = dwNewSize;
                            psz = pszNewString + ( psz - *pszString );
                            BinlFreeMemory( *pszString );
                            *pszString = pszNewString;
                        }

                        MoveMemory( &psz[dwString], &psz[ 2 + dwToken ], dwLenEnd );
                    }

                    CopyMemory( psz, psar->pszStringA, dwString );

                    if ( 2 + dwToken > dwString )
                    {
                        strcpy( &psz[ dwString ], &psz[ 2 + dwToken ] );
                    }

                    pszEnd = NULL;  // match, NULL so we don't put the temp char back
                    psz++;          // move forward
                    break;
                }

                psar++;
            }

            //
            // If no match, put the character back
            //
            if ( pszEnd != NULL )
            {
                *pszEnd = ch;
            }
        }
        else
        {
            psz++;
        }
    }
}

LPSTR
FindSection(
    LPSTR sectionName,
    LPSTR sifFile
    )

/*++

Routine Description:


    This routine is for use by ProcessUniqueUdb. It scans in memory
    starting at sifFile, looking for a SIF section named "sectionName".
    Specifically it searches for a line whose first non-blank characters
    are "[sectionName]".

Arguments:

    sectionName - The section name to look for, an ANSI string.

    sifFile - The SIF file in memory, which is NULL-terminated ANSI string.

Return Value:

    A pointer to the start of the section -- the first character of the
        line after the one with [sectionName] in it.

--*/

{
    LPSTR curSifFile;
    DWORD lenSectionName;
    LPSTR foundSection = NULL;

    lenSectionName = strlen(sectionName);

    curSifFile = sifFile;

    while (*curSifFile != '\0') {

        //
        // At this point in the while, curSifFile points to the beginning
        // of a line.
        //

        //
        // First find the first non-blank character.
        //

        while ((*curSifFile != '\0') && (*curSifFile == ' ')) {
            ++curSifFile;
        }
        if (*curSifFile == '\0') {
            break;
        }

        if (*curSifFile == '[') {
            if ((memcmp(sectionName, curSifFile+1, lenSectionName) == 0) &&
                (curSifFile[lenSectionName+1] == ']')) {

                //
                // Found it, scan to start of next line.
                //
                while ((*curSifFile != '\0') && (*curSifFile != '\n')) {
                    ++curSifFile;
                }
                if (*curSifFile == '\0') {
                    break;
                }
                foundSection = curSifFile + 1;  // +1 to skip past the '\n'
                break;
            }
        }

        //
        // Now scan to the start of the next line, defined as the
        // character after a \n.
        //
        while ((*curSifFile != L'\0') && (*curSifFile != L'\n')) {
            ++curSifFile;
        }
        if (*curSifFile == L'\0') {
            break;
        }
        ++curSifFile;   // skip past the '\n'
    }

    return foundSection;
}

BOOLEAN
FindLineInSection(
    PCHAR SectionStart,
    PWCHAR lineToMatch,
    PCHAR *existingLine,
    DWORD *existingLineLen
    )

/*++

Routine Description:


    This routine is for use by ProcessUniqueUdb. It scans in memory
    starting at SectionStart, which is assumed to be the first line of
    a section of a .sif file. It looks for a line that is for the same
    value as lineToMatch, which will be of the form "value=name".
    If it is found, it returns the line that it was found on.

Arguments:

    SectionStart - The section of the .sif, in ANSI.

    lineToMatch - The value=name pair to match, in UNICODE.

    existingLine - Returns the existing line (in SectionStart), in ANSI.

    existingLineLen - Returns the length of the existing line, including
        final \r\n. Length is in characters, not bytes.

Return Value:

    TRUE of the line is found, FALSE otherwise.

--*/
{
    LPWSTR endOfValue;
    LPSTR curSection;
    LPSTR curLine;
    LPSTR endOfLine;
    DWORD valueLength, ansiValueLength;
    BOOLEAN foundLine = FALSE;
    LPSTR valueToMatch = NULL;
    ANSI_STRING aString;
    UNICODE_STRING uString;


    //
    // First look at lineToMatch to see what we are looking
    // for. This is the text up to the first =, or all of it if there
    // is no =. Once found, we convert it to ANSI for comparisons.
    //

    endOfValue = wcschr(lineToMatch, L'=');
    if (endOfValue == NULL) {
        endOfValue = lineToMatch + wcslen(lineToMatch);
    }

    valueLength = (DWORD)(endOfValue - lineToMatch);


    //
    // Copy the sectionName to ANSI for comparisons.
    //

    uString.Buffer = lineToMatch;
    uString.Length = (USHORT)(valueLength*sizeof(WCHAR));

    ansiValueLength = RtlUnicodeStringToAnsiSize(&uString);  // includes final '\0'
    valueToMatch = BinlAllocateMemory(ansiValueLength);
    if (valueToMatch == NULL) {
        return FALSE;
    }

    aString.Buffer = valueToMatch;
    aString.MaximumLength = (USHORT)ansiValueLength;
    RtlUnicodeStringToAnsiString(
        &aString,
        &uString,
        FALSE);

    --ansiValueLength;  // remove final '\0' from the count

    //
    // now scan each line of SectionStart, until we find the beginning
    // of another section, a \0, or the matching line.
    //

    curSection = SectionStart;

    while (*curSection != '\0') {

        //
        // At this point in the while, curSection points to the beginning
        // of a line. Save the start of the current line.
        //

        curLine = curSection;

        //
        // First find the first non-blank character.
        //

        while ((*curSection != '\0') && (*curSection == ' ')) {
            ++curSection;
        }

        //
        // If we hit \0, we didn't find it.
        //
        if (*curSection == '\0') {
            break;
        }

        //
        // If we hit a line starting with [, we didn't find it.
        //
        if (*curSection == '[') {
            break;
        }

        //
        // If we hit a line starting with what we expect, followed
        // by an =, \0, or a blank, we found it.
        //

        if (strncmp(curSection, valueToMatch, ansiValueLength) == 0) {
            if ((curSection[ansiValueLength] == '=') ||
                (curSection[ansiValueLength] == '\0') ||
                (curSection[ansiValueLength] == ' ')) {

                *existingLine = curLine;
                endOfLine = strchr(curLine, '\n');
                if (endOfLine == NULL) {
                    *existingLineLen = strlen(curLine);
                } else {
                    *existingLineLen = (DWORD)(endOfLine + 1 - curLine);
                }
                foundLine = TRUE;
                break;
            }
        }

        //
        // Now scan to the start of the next line, defined as the
        // character after a \n.
        //
        while ((*curSection != L'\0') && (*curSection != L'\n')) {
            ++curSection;
        }
        if (*curSection == L'\0') {
            break;
        }
        ++curSection;   // skip past the '\n'
    }

    if (valueToMatch != NULL) {
        BinlFreeMemory(valueToMatch);
    }

    return foundLine;
}

VOID
ProcessUniqueUdb(
    LPSTR *sifFilePtr,
    DWORD sifFileLen,
    LPWSTR UniqueUdbPath,
    LPWSTR UniqueUdbId
    )

/*++

Routine Description:


    Overlays data from a unique.udb file based on the tag specified. The
    file to overlay on is in memory at *pszString. *pszString is reallocated
    if necessary.

Arguments:

    sifFile - The file to overlay data on.

    sifFileLen - The current size of the data at *pszString (including final NULL).

    UniqueUdbPath - The path to the unique.udb file.

    UniqueUdbId - The ID in unique.udb to use.

Return Value:

    None.

--*/
{
    PWCHAR TmpBuffer = NULL;
    DWORD len, sifFileAlloc, lineLen;
    LONG sizeToAdd;
    LPSTR sifFile = *sifFilePtr;
    PWCHAR sectionList = NULL;
    PWCHAR sectionLoc, sectionCur;
    PWCHAR sectionName = NULL;
    PCHAR ansiRealSectionName = NULL;
    PCHAR sectionStart;
    PWCHAR profileSectionCur;
    PWCHAR realSectionName;
    PCHAR existingLine;
    DWORD existingLineLen;
    DWORD lenRealSectionName;
    PCHAR insertionPoint;
    ANSI_STRING aString;
    UNICODE_STRING uString;

#define TMP_BUFFER_SIZE 2048


    TraceFunc("ProcessUniqueUdb( )\n");

    TmpBuffer = BinlAllocateMemory(TMP_BUFFER_SIZE * sizeof(WCHAR));
    if (TmpBuffer == NULL) {
        return;
    }

    //
    // See if the ID appears in the [UniqueIds] section of the unique.udb file.
    //

    TmpBuffer[0] = L'\0';
    GetPrivateProfileString( L"UniqueIds",  // section name
                             UniqueUdbId,   // line name
                             L"",   // default
                             TmpBuffer,
                             TMP_BUFFER_SIZE,
                             UniqueUdbPath );

    if (TmpBuffer[0] == L'\0') {
        return;
    }

    //
    // sifFileAlloc is the size allocated for sifFile, whereas
    // sifFileLen is the amount actually used. They should only
    // be different while we are actively shuffling things
    // around.
    //

    sifFileAlloc = sifFileLen;

    //
    // Save the tmpbuffer result.
    //

    len = wcslen(TmpBuffer) + 1;
    sectionList = BinlAllocateMemory(len * sizeof(WCHAR));
    if (sectionList == NULL) {
        return;
    }

    wcscpy(sectionList, TmpBuffer);

    //
    // Now for each section identified in sectionList, scan for
    // the section to overlay.
    //

    sectionLoc = sectionList;
    while (TRUE) {

        //
        // First skip leading blanks
        //

        while (*sectionLoc && !iswalnum(*sectionLoc)) {
            //
            // Make sure we are not at a comment.
            //
            if (*sectionLoc == L';') {
                goto Cleanup;
            }
            ++sectionLoc;
        }
        if (!*sectionLoc) {
            goto Cleanup;
        }


        //
        // Now save sectionCur as the current section name
        // and skip to the end of it. Section names can be
        // any alphanumeric character, '.', or '_'.
        //
        sectionCur = sectionLoc;
        while((iswalnum(*sectionLoc)) ||
              (*sectionLoc == '.') ||
              (*sectionLoc == '_')) {
            ++sectionLoc;
        }

        //
        // Construct the new section name to look for. This will
        // be [UNIQUEUDBID:RealSectionName].
        //

        len = wcslen(UniqueUdbId) + (sectionLoc - sectionCur) + 2;  // one for :, one for NULL
        sectionName = BinlAllocateMemory(len * sizeof(WCHAR));
        if (sectionName == NULL) {
            goto Cleanup;
        }

        wcscpy(sectionName, UniqueUdbId);
        wcscat(sectionName, L":");
        len = wcslen(sectionName);
        realSectionName = sectionName + len;
        memcpy(realSectionName, sectionCur, (sectionLoc - sectionCur) * sizeof(WCHAR));
        realSectionName[sectionLoc - sectionCur] = L'\0';


        //
        // Copy the sectionName to ANSI for comparisons.
        //

        uString.Buffer = realSectionName;
        uString.Length = (USHORT)(wcslen(realSectionName)*sizeof(WCHAR));

        lenRealSectionName = RtlUnicodeStringToAnsiSize(&uString);  // includes final '\0'
        ansiRealSectionName = BinlAllocateMemory(lenRealSectionName);
        if (ansiRealSectionName == NULL) {
            goto Cleanup;
        }

        aString.Buffer = ansiRealSectionName;
        aString.MaximumLength = (USHORT)lenRealSectionName;
        RtlUnicodeStringToAnsiString(
            &aString,
            &uString,
            FALSE);
        --lenRealSectionName;  // remove final '\0' from count

        //
        // See if there is a section with that name.
        //

        TmpBuffer[0] = L'\0';
        GetPrivateProfileSection( sectionName,
                                  TmpBuffer,
                                  TMP_BUFFER_SIZE,
                                  UniqueUdbPath );

        if (TmpBuffer[0] == L'\0') {
            continue;
        }

        //
        // Got the contents of the section, now process it.
        //

        sectionStart = FindSection(ansiRealSectionName, sifFile);

        sizeToAdd = 0;  // amount we need to extend the buffer by.

        if (sectionStart == NULL) {

            //
            // No section, so need to add room for it.
            //
            // We put a CR-LF combo, then the section name in [], then
            // another CR-LF.
            //
            // lenRealSectionName already contains the '\0'
            //

            sizeToAdd = lenRealSectionName + 6;

        }

        //
        // Now scan through the entries in the profile section.
        //

        profileSectionCur = TmpBuffer;

        while (*profileSectionCur != L'\0') {

            uString.Buffer = profileSectionCur;
            uString.Length = (USHORT)(wcslen(profileSectionCur) * sizeof(WCHAR));

            //
            // Figure out how long profileSectionCur will be as an
            // ANSI string (may have DBCS data in it).
            //

            lineLen = RtlUnicodeStringToAnsiSize(&uString); // includes \0 termination
            --lineLen;  // remove the \0 from the count

            //
            // If there is no existing section we have to add it;
            // if not, see if there is a line for this already.
            //

            if (sectionStart == NULL) {
                sizeToAdd += lineLen + 2;  // +2 is for CR-LF
            } else {
                if (FindLineInSection(sectionStart,
                                      profileSectionCur,
                                      &existingLine,
                                      &existingLineLen)) {
                    //
                    // Need to remove current line.
                    //
                    memmove(existingLine, existingLine + existingLineLen,
                                sifFileLen - ((existingLine - sifFile) + existingLineLen));

                    sizeToAdd += lineLen + 2 - existingLineLen;
                    sifFileLen -= existingLineLen;

                } else {

                    sizeToAdd += lineLen + 2;
                }
            }

            profileSectionCur += wcslen(profileSectionCur) + 1;
        }

        //
        // Now we need to reallocate the buffer if needed.
        //

        if (sizeToAdd > 0) {

            //
            // No. Make some space
            //
            LPSTR pszNewString;

            pszNewString =  BinlAllocateMemory( sifFileAlloc + sizeToAdd );
            if ( !pszNewString )
            {
                return; // abort the rest
            }

            MoveMemory( pszNewString, sifFile, sifFileLen);

            BinlFreeMemory( sifFile );
            //
            // Adjust sectionStart to be within the new buffer.
            //
            if (sectionStart != NULL) {
                sectionStart = pszNewString + (sectionStart - sifFile);
            }
            sifFile = pszNewString;
            *sifFilePtr = pszNewString;
            sifFileAlloc += sizeToAdd;
        }

        //
        // Add the section header if necessary.
        //

        if (sectionStart == NULL) {
            strcpy(sifFile + sifFileLen - 1, "\r\n[");
            sifFileLen += 3;
            strcpy(sifFile + sifFileLen - 1, ansiRealSectionName);
            sifFileLen += lenRealSectionName;
            strcpy(sifFile + sifFileLen - 1, "]\r\n");
            sifFileLen += 3;
            sectionStart = sifFile + sifFileLen - 1;
        }

        //
        // Now add the items from the profile section. We know that
        // they do not exist in the file and that we have reallocated
        // the file buffer to be large enough.
        //

        profileSectionCur = TmpBuffer;
        insertionPoint = sectionStart;

        while (*profileSectionCur != L'\0') {

            uString.Buffer = profileSectionCur;
            uString.Length = (USHORT)(wcslen(profileSectionCur)*sizeof(WCHAR));

            lineLen = RtlUnicodeStringToAnsiSize(&uString);  // includes final '\0'
            --lineLen;  // remove final '\0' from count

            //
            // move anything we need to down and insert the new line.
            //

            memmove(insertionPoint + lineLen + 2, insertionPoint, sifFileLen - (insertionPoint - sifFile));

            aString.Buffer = insertionPoint;
            aString.MaximumLength = (USHORT)(lineLen+1);
            RtlUnicodeStringToAnsiString(
                &aString,
                &uString,
                FALSE);
            memcpy(insertionPoint + lineLen, "\r\n", 2);
            sifFileLen += lineLen + 2;
            insertionPoint += lineLen + 2;

            profileSectionCur += wcslen(profileSectionCur) + 1;
        }

    }

Cleanup:

    if (sectionList != NULL) {
        BinlFreeMemory(sectionList);
    }
    if (sectionName != NULL) {
        BinlFreeMemory(sectionName);
    }
    if (ansiRealSectionName != NULL) {
        BinlFreeMemory(ansiRealSectionName);
    }
    if (TmpBuffer != NULL) {
        BinlFreeMemory(TmpBuffer);
    }

    ASSERT (sifFileLen <= sifFileAlloc);
}
//
// OscFindVariableA( )
//
LPSTR
OscFindVariableA(
    PCLIENT_STATE clientState,
    LPSTR variableName )        // variable name are always ASCII until OSChooser
                                // can handle Unicode.
{
    ULONG i;
    static CHAR szNullStringA[1] = { '\0' };
    LPSTR overrideValue;

    //
    // First check to see if this a query we are supposed to override.
    //
    if (strcmp(variableName, "SIF") == 0) {

        overrideValue = OscFindVariableA(clientState, "FORCESIFFILE");

        if ((overrideValue != NULL) && (strlen(overrideValue) != 0)) {
            return overrideValue;
        }

    }

    for( i = 0; i < clientState->nVariables; i++ )
    {
        if ( strcmp( clientState->Variables[i].pszToken, variableName ) == 0 )
        {
            if ( clientState->Variables[i].pszStringA == NULL )
            {
                DWORD dwLen;
                ANSI_STRING aString;
                UNICODE_STRING uString;

                uString.Buffer = clientState->Variables[i].pszStringW;
                uString.Length = (USHORT)( wcslen( clientState->Variables[i].pszStringW ) * sizeof(WCHAR) );

                dwLen = RtlUnicodeStringToAnsiSize( &uString );  // includes NULL termination

                clientState->Variables[i].pszStringA = BinlAllocateMemory( dwLen );
                if ( !(clientState->Variables[i].pszStringA) )
                    break;  // out of memory

                aString.Buffer = clientState->Variables[i].pszStringA;
                aString.MaximumLength = (USHORT)dwLen;

                RtlUnicodeStringToAnsiString(
                    &aString,
                    &uString,
                    FALSE);
            }

            return clientState->Variables[i].pszStringA;
        }
    }

    return szNullStringA;
}

//
// OscFindVariableW( )
//
LPWSTR
OscFindVariableW(
    PCLIENT_STATE clientState,
    LPSTR variableName  )       // variable name are always ASCII until OSChooser
                                // can handle Unicode.
{
    ULONG i;
    static WCHAR szNullStringW[1] = { L'\0' };
    LPWSTR overrideValue;

    //
    // First check to see if this a query we are supposed to override.
    //
    if (strcmp(variableName, "SIF") == 0) {

        overrideValue = OscFindVariableW(clientState, "FORCESIFFILE");

        if ((overrideValue != NULL) && (wcslen(overrideValue) != 0)) {
            return overrideValue;
        }

    }

    for( i = 0; i < clientState->nVariables; i++ )
    {
        if ( strcmp( clientState->Variables[i].pszToken, variableName ) == 0 )
        {
            if ( clientState->Variables[i].pszStringW == NULL )
            {
                DWORD dwLen = _mbslen( clientState->Variables[i].pszStringA ) + 1;
                ANSI_STRING aString;
                UNICODE_STRING uString;

                clientState->Variables[i].pszStringW = BinlAllocateMemory( dwLen * sizeof(WCHAR) );
                if ( !(clientState->Variables[i].pszStringW) )
                    break;  // out of memory

                uString.Buffer = clientState->Variables[i].pszStringW;
                uString.MaximumLength = (USHORT)(dwLen * sizeof(WCHAR));

                aString.Buffer = clientState->Variables[i].pszStringA;
                aString.Length = (USHORT)strlen( clientState->Variables[i].pszStringA );

                RtlAnsiStringToUnicodeString(
                    &uString,
                    &aString,
                    FALSE);
            }

            return clientState->Variables[i].pszStringW;
        }
    }

    return szNullStringW;
}

//
// OscCheckVariableLength( )
//
BOOLEAN
OscCheckVariableLength(
    PCLIENT_STATE clientState,
    LPSTR        variableName,
    ULONG        variableLength )
{
    ULONG i;

    for (i = 0; i < OSC_VARIABLE_MAXIMUM_COUNT; i++) {
        if (strcmp(OscMaximums[i].VariableName, variableName) == 0) {
            if (variableLength > OscMaximums[i].MaximumLength) {
                BinlPrintDbg((DEBUG_OSC_ERROR, "Variable %s was %d bytes, only %d allowed\n",
                           variableName,
                           variableLength,
                           OscMaximums[i].MaximumLength));
                OscAddVariableA( clientState, "SUBERROR", variableName );
                return FALSE;
            } else {
                return TRUE;
            }
        }
    }

    //
    // If we don't find it in our list of maximums, it is OK.
    //

    return TRUE;
}

//
// OscAddVariableA( )
//
DWORD
OscAddVariableA(
    PCLIENT_STATE clientState,
    LPSTR        variableName,  // variable name are always ASCII until OSChooser
                                // can handle Unicode.
    LPSTR        variableValue )
{
    ULONG i;

    if ( variableValue == NULL )
        return E_POINTER;  // no value to add... abort

    if (!OscCheckVariableLength(clientState, variableName, strlen(variableValue))) {
        return E_INVALIDARG;
    }

    for( i = 0; i < clientState->nVariables; i++ )
    {

        if ( strcmp( clientState->Variables[i].pszToken, variableName ) == 0 )
        {
            ULONG l = strlen( variableValue );

            if ( clientState->Variables[i].pszStringW != NULL )
            {
                BinlFreeMemory( clientState->Variables[i].pszStringW );
                clientState->Variables[i].pszStringW = NULL;
            }

            if ( clientState->Variables[i].pszStringA != NULL )
            { // found a previous one

                // Don't replace values with ""
                if ( variableValue[0] == '\0' ) {
                    break;
                } else {
                    // replace it with the new one
                    if ( l <= strlen( clientState->Variables[i].pszStringA ) )
                    {
                        strcpy( clientState->Variables[i].pszStringA, variableValue );
                    }
                    else
                    {
                        // need more space, delete the old
                        BinlFreeMemory( clientState->Variables[i].pszStringA );
                        clientState->Variables[i].pszStringA = NULL;
                    }
                }
            }

            break;
        }
    }

    //
    // Limit the number of variables we can have. Everything else is ignored.
    //
    if ( i == MAX_VARIABLES ) {
        return E_OUTOFMEMORY;
    }

    //
    // Adding a new one
    //
    if ( clientState->nVariables == i )
    {
        clientState->Variables[i].pszToken = BinlStrDupA( variableName );

        if (clientState->Variables[i].pszToken == NULL) {
            return E_OUTOFMEMORY;
        }

        clientState->nVariables++;
    }

    //
    // If this is a new one or a new Value for an existing variable
    // that does not fit in the old values space, create a dup of the
    // value.
    //
    if ( clientState->Variables[i].pszStringA == NULL )
    {
        BinlAssert( variableValue != NULL );
        clientState->Variables[i].pszStringA = BinlStrDupA( variableValue );

        if (clientState->Variables[i].pszStringA == NULL) {

            if ((i + 1) == clientState->nVariables) {
                clientState->nVariables--;
                BinlFreeMemory(clientState->Variables[i].pszToken);
            }

            return E_OUTOFMEMORY;
        }

        //
        // The "OPTIONS" variable can have a lot of stuff in it and will
        // blow up the BinlPrint(). Just avoid the whole mess by not
        // printing it
        //

        if ( strcmp( clientState->Variables[i].pszToken, "OPTIONS" ) != 0 ) {
            BinlPrintDbg((DEBUG_OSC, "Add Var:'%s' = '%s'\n",
                       clientState->Variables[i].pszToken,
                       clientState->Variables[i].pszStringA ));
        }
    }

    //
    // it will be converted to UNICODE when OscFindVariableW( ) is called
    //

    return ERROR_SUCCESS;
}

//
// OscAddVariableW( )
//
DWORD
OscAddVariableW(
    PCLIENT_STATE clientState,
    LPSTR        variableName,  // variable name are always ASCII until OSChooser
                                // can handle Unicode.
    LPWSTR       variableValue )
{
    ULONG i;

    if ( variableValue == NULL )
        return E_POINTER;  // no value to add... abort

    if (!OscCheckVariableLength(clientState, variableName, wcslen(variableValue))) {
        return E_INVALIDARG;
    }

    for( i = 0; i < clientState->nVariables; i++ )
    {
        if ( strcmp( clientState->Variables[i].pszToken, variableName ) == 0 )
        {
            if ( clientState->Variables[i].pszStringA != NULL )
            {
                BinlFreeMemory( clientState->Variables[i].pszStringA );
                clientState->Variables[i].pszStringA = NULL;
            }

            if ( clientState->Variables[i].pszStringW != NULL )
            { // found a previous one

                // Don't replace values with ""
                if ( variableValue[0] == L'\0' ) {
                    break;
                } else {
                    // replace it with the new one
                    ULONG Length = wcslen( variableValue );
                    if ( Length < wcslen( clientState->Variables[i].pszStringW ) )
                    {
                        wcscpy( clientState->Variables[i].pszStringW, variableValue );
                    }
                    else
                    {
                        // need more space, delete the old
                        BinlFreeMemory( clientState->Variables[i].pszStringW );
                        clientState->Variables[i].pszStringW = NULL;
                    }
                }
            }

            break;
        }
    }

    //
    // Limit the number of variables we can have. Everything else is ignored.
    //
    if ( i == MAX_VARIABLES ) {
        return E_OUTOFMEMORY;   // out of space
    }

    //
    // Adding a new one
    //
    if ( clientState->nVariables == i )
    {
        clientState->Variables[i].pszToken = BinlStrDupA( variableName );

        if (clientState->Variables[i].pszToken == NULL) {
            return E_OUTOFMEMORY;
        }

        clientState->nVariables++;
    }

    //
    // If this is a new one or a new Value for an existing variable
    // that does not fit in the old values space, create a dup of the
    // value.
    //
    if ( clientState->Variables[i].pszStringW == NULL )
    {
        BinlAssert( variableValue != NULL );
        clientState->Variables[i].pszStringW = BinlStrDupW( variableValue);

        if (clientState->Variables[i].pszStringW == NULL) {

            if ((i + 1) == clientState->nVariables) {
                clientState->nVariables--;
                BinlFreeMemory(clientState->Variables[i].pszToken);
            }

            return E_OUTOFMEMORY;
        }


        BinlPrintDbg((DEBUG_OSC, "Add Var:'%s' = '%ws'\n",
                   clientState->Variables[i].pszToken,
                   clientState->Variables[i].pszStringW ));
    }

    //
    // it will be converted to ASCII when OscFindVariableA( ) is called
    //

    return ERROR_SUCCESS;
}

//
// OscResetVariable( )
//
VOID
OscResetVariable(
    PCLIENT_STATE clientState,
    LPSTR        variableName
    )
{
    ULONG i;
    BOOLEAN found = FALSE;

    for( i = 0; i < clientState->nVariables; i++ ) {
        if ( strcmp( clientState->Variables[i].pszToken, variableName ) == 0 ) {

            if ( clientState->Variables[i].pszStringA != NULL ) {

                BinlFreeMemory( clientState->Variables[i].pszStringA );
                clientState->Variables[i].pszStringA = NULL;
            }

            if ( clientState->Variables[i].pszStringW != NULL ) { // found a previous one

                BinlFreeMemory( clientState->Variables[i].pszStringW );
                clientState->Variables[i].pszStringW = NULL;
            }
            BinlPrintDbg((DEBUG_OSC, "Deleted Var:'%s'\n",
                       clientState->Variables[i].pszToken ));
            BinlFreeMemory( clientState->Variables[i].pszToken );
            found = TRUE;
            break;
        }
    }

    if (found) {

        //
        // move all existing ones up.
        //

        while (i < clientState->nVariables) {

            clientState->Variables[i].pszToken = clientState->Variables[i+1].pszToken;
            clientState->Variables[i].pszStringA = clientState->Variables[i+1].pszStringA;
            clientState->Variables[i].pszStringW = clientState->Variables[i+1].pszStringW;
            i++;
        }
        clientState->nVariables--;
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\ds.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    ds.c

Abstract:

    This module contains the code to process OS Chooser message
    for the BINL server.

Author:

    Adam Barr (adamba)  9-Jul-1997
    Geoff Pease (gpease) 10-Nov-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include "binl.h"
#pragma hdrstop

#include <math.h>  // pow() function

#include <riname.h>

#include <riname.c>

DWORD
OscGetUserDetails (
    PCLIENT_STATE clientState
    )
//
//  This function fills in USERDOMAIN, USERFIRSTNAME, USERLASTNAME, USEROU in
//  the client state.  Also fills in ROOTDOMAIN for root of enterprise.
//
{
    DWORD  Error = ERROR_SUCCESS;
    DWORD  Count;

    LPWSTR pszUserName = OscFindVariableW( clientState, "USERNAME" );
    LPWSTR pUserDomain = OscFindVariableW( clientState, "USERDOMAIN" );
    LPWSTR pUserOU = OscFindVariableW( clientState, "USEROU" );
    LPWSTR pUserFullName = OscFindVariableW( clientState, "USERFULLNAME" );

    PLDAP LdapHandle;
    PLDAPMessage LdapMessage = NULL;
    PWSTR Filter = NULL;
    PWCHAR ldapAttributes[5];
    BOOLEAN impersonating = FALSE;
    PLDAPMessage ldapEntry;
    PWCHAR *ldapConfigContainer = NULL;
    PWCHAR *ldapDomain = NULL;
    PWCHAR *ldapFirstName = NULL;
    PWCHAR *ldapLastName = NULL;
    PWCHAR *ldapDisplayName = NULL;
    PWCHAR *ldapAccountName = NULL;
    BOOLEAN allocatedContainer = FALSE;
    PWCHAR configContainer = NULL;
    BOOLEAN firstNameValid = FALSE;
    BOOLEAN lastNameValid = FALSE;

    BOOLEAN userFullNameSet = FALSE;

    PLDAPControlW controlArray[2];
    LDAPControlW controlNoReferrals;
    ULONG noReferralsPlease;

    PWCHAR ldapUserDN = NULL;
    PWCHAR *explodedDN = NULL;
    PWCHAR dnUsersOU = NULL;

    TraceFunc( "OscGetUserDetails( )\n" );
    if ( pszUserName[0] == L'\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "USERNAME" );
        return ERROR_BINL_MISSING_VARIABLE;
    }

    //
    // If the USERFULLNAME variable already exists, we won't change it below.
    // But if it came back as an empty string, that might actually mean
    // that the variable doesn't exist. In such a case, when SearchAndReplace
    // processes the .SIF file for the client, it will leave occurrences of
    // "%USERFULLNAME%" alone -- it won't replace them with "". We don't want
    // "%USERFULLNAME% to hang around, so we explicitly set it to an empty
    // string if it doesn't already exist or is an empty string. We do the
    // same thing with USERFIRSTNAME, USERLASTNAME, and USERDISPLAYNAME.
    //

    if (pUserFullName[0] != L'\0') {
        userFullNameSet = TRUE;
    } else {
        OscAddVariableW( clientState, "USERFULLNAME", L"" );
    }

    {
        LPWSTR name;
        name = OscFindVariableW( clientState, "USERFIRSTNAME" );
        if (name[0] == L'\0') {
            OscAddVariableW( clientState, "USERFIRSTNAME", L"" );
        }
        name = OscFindVariableW( clientState, "USERLASTNAME" );
        if (name[0] == L'\0') {
            OscAddVariableW( clientState, "USERLASTNAME", L"" );
        }
        name = OscFindVariableW( clientState, "USERDISPLAYNAME" );
        if (name[0] == L'\0') {
            OscAddVariableW( clientState, "USERDISPLAYNAME", L"" );
        }
    }

    if ( pUserOU[0] != L'\0' ) {

        //
        // if we've already found this user's info, bail here with success.
        //
        return ERROR_SUCCESS;
    }

    //
    // if the users domain and the servers domain don't match,
    // then try connecting to the DC for the new domain.  If we
    // don't do this, then we won't necessarily be able to get 
    // the correct information about the user.  By connecting to
    // the new DC, we get the clientState to cache some information
    // about the new domain.
    //
    if (pUserDomain[0] != L'\0' ) {
        PWSTR CrossDC = OscFindVariableW( clientState, "DCNAME" );
        if ( (CrossDC[0] == L'\0') && 
             (_wcsicmp(pUserDomain, BinlGlobalOurDomainName) != 0)) {
            HANDLE hDC;
            PSTR pUserDomainA = OscFindVariableA( clientState, "USERDOMAIN" );
            Error = MyGetDcHandle(clientState, pUserDomainA,&hDC);
            if (Error == ERROR_SUCCESS) {
                DsUnBindA(&hDC);
            }
        }
    }

    Error = OscImpersonate(clientState);
    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg((DEBUG_ERRORS,
                   "OscGetUserDetails: OscImpersonate failed %lx\n", Error));
        return Error;
    }
    impersonating = TRUE;

    BinlAssert( clientState->AuthenticatedDCLdapHandle != NULL );

    LdapHandle = clientState->AuthenticatedDCLdapHandle;

    //
    //  we first look up the configuration and default container, we'll need
    //  one or the other, based on whether we have a domain name or not.
    //

    ldapAttributes[0] = L"configurationNamingContext";
    ldapAttributes[1] = L"rootDomainNamingContext";
    ldapAttributes[2] = NULL;

    Error = ldap_search_ext_sW(LdapHandle,
                               NULL,
                               LDAP_SCOPE_BASE,
                               L"(objectClass=*)",
                               ldapAttributes,
                               FALSE,
                               NULL,
                               NULL,
                               0,
                               0,
                               &LdapMessage);

    if (Error == LDAP_SUCCESS) {
        
        Count = ldap_count_entries( LdapHandle, LdapMessage );
    
        if (Count > 0) {
    
            ldapEntry = ldap_first_entry( LdapHandle, LdapMessage );
    
            if (ldapEntry != NULL) {
    
                ldapConfigContainer = ldap_get_valuesW( LdapHandle,
                                                        ldapEntry,
                                                        L"configurationNamingContext" );
    
                ldapDomain = ldap_get_valuesW( LdapHandle,
                                               ldapEntry,
                                               L"rootDomainNamingContext" );
    
                if (ldapDomain != NULL &&
                    *ldapDomain != NULL &&
                    **ldapDomain != L'\0') {
    
                    OscAddVariableW( clientState, "ROOTDOMAIN", *ldapDomain );
                }
            }
        } else {
            LogLdapError(   EVENT_WARNING_LDAP_SEARCH_ERROR,
                            LdapGetLastError(),
                            LdapHandle
                            );
        }
    } else {
        LogLdapError(   EVENT_WARNING_LDAP_SEARCH_ERROR,
                        LdapGetLastError(),
                        LdapHandle
                        );
    }
    if (LdapMessage) {
        ldap_msgfree( LdapMessage );
        LdapMessage = NULL;
    }

    //
    //  we either have the config container or the default domain DN.  If
    //  we only have the config container, go get the correct domain DN.
    //

    if ( pUserDomain[0] != L'\0' ) {

        //
        // Since the user specified a domain, remove the defaulting to the same domain
        // as the RIS server.
        //
        ldapDomain = NULL;

        //
        //  if a domain was specified, then we look it up to find the baseDN
        //
        //  we fail if we didn't get the config container
        //

        if (ldapConfigContainer == NULL ||
            *ldapConfigContainer == NULL ||
            **ldapConfigContainer == L'\0') {

            if (Error == LDAP_SUCCESS) {
                Error = LDAP_NO_SUCH_ATTRIBUTE;
            }
            BinlPrintDbg((DEBUG_ERRORS,
                       "OscGetUserDetails: get config container failed %lx\n", Error));
            Error = LdapMapErrorToWin32( Error );
            goto exitGetUserDetails;
        }

        //
        //  we then tack on "CN=Partitions," to search the partitions container
        //
        //  sizeof contains the \0 in it.
        //
        Count = wcslen( *ldapConfigContainer ) + (sizeof( L"CN=Partitions,")/sizeof(WCHAR));

        configContainer = BinlAllocateMemory( Count * sizeof(WCHAR) );

        if (configContainer == NULL) {

            Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
            goto exitGetUserDetails;
        }

        if (_snwprintf(configContainer,
                       Count,
                       L"CN=Partitions,%ws",
                       *ldapConfigContainer) < 0) {
            Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
            goto exitGetUserDetails; // this frees configContainer
        }        
        configContainer[Count-1] = L'\0'; 

        //
        //  then we find the correct partition, we ignore the enterprise and
        //  enterprise schema entries by specifying a non-empty netbios name.
        //

        ldapAttributes[0] = L"NCName";
        ldapAttributes[1] = NULL;

        Filter = BinlAllocateMemory( 
                    ((wcslen(pUserDomain) * 2) + 
                    (sizeof(L"(&(objectClass=CrossRef)(netbiosName=*)(|(dnsRoot=)(cn=)))")/sizeof(WCHAR)))
                    * sizeof(WCHAR) );
        if (!Filter) {
            Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
            goto exitGetUserDetails; 
        }

        wsprintf(Filter,
                 L"(&(objectClass=CrossRef)(netbiosName=*)(|(dnsRoot=%s)(cn=%s)))",
                 pUserDomain,
                 pUserDomain);


        Error = ldap_search_ext_sW(LdapHandle,
                                  configContainer,
                                  LDAP_SCOPE_ONELEVEL,
                                  Filter,
                                  ldapAttributes,
                                  FALSE,
                                  NULL,
                                  NULL,
                                  0,
                                  0,
                                  &LdapMessage);

        if (Error == LDAP_SUCCESS) {
        
            Count = ldap_count_entries( LdapHandle, LdapMessage );
    
            if (Count > 0) {
    
                PWCHAR *ldapDomainFromPartition = NULL;
    
                ldapEntry = ldap_first_entry( LdapHandle,
                                              LdapMessage );
    
                if (ldapEntry != NULL) {
    
                    ldapDomainFromPartition = ldap_get_valuesW( LdapHandle,
                                                                ldapEntry,
                                                                L"NCName" );
                    if (ldapDomainFromPartition != NULL) {
    
                        //
                        //  if we read a valid DN from the partitions container,
                        //  we free the default one and switch over to the
                        //  one we just found.
                        //
    
                        if (*ldapDomainFromPartition != NULL &&
                            **ldapDomainFromPartition != L'\0') {
    
                            ldap_value_free( ldapDomain );
                            ldapDomain = ldapDomainFromPartition;
    
                        } else {
    
                            ldap_value_free( ldapDomainFromPartition );
                        }
    
                    }
    
                }
    
            } else {
    
                LogLdapError( EVENT_WARNING_LDAP_SEARCH_ERROR, LdapGetLastError(), LdapHandle);
    
            }
        } else {
            LogLdapError( EVENT_WARNING_LDAP_SEARCH_ERROR, LdapGetLastError(), LdapHandle);
        }

        if (LdapMessage) {
            ldap_msgfree( LdapMessage );
            LdapMessage = NULL;
        }

    } else if ((ldapDomain != NULL) && (*ldapDomain != NULL) && (**ldapDomain != L'\0')) {
        
        //
        //  Add the user's domain as a variable to the client state.
        //
        OscAddVariableW( clientState, "USERDOMAIN", *ldapDomain );
        pUserDomain = OscFindVariableW( clientState, "USERDOMAIN" );
    }

    if (ldapDomain == NULL ||
        *ldapDomain == NULL ||
        **ldapDomain == L'\0') {

        if (Error == LDAP_SUCCESS) {
            Error = LDAP_NO_SUCH_ATTRIBUTE;
        }
        BinlPrintDbg((DEBUG_ERRORS,
                   "OscGetUserDetails: get default domain failed %lx\n", Error));
        Error = LdapMapErrorToWin32( Error );
        goto exitGetUserDetails;
    }


    //
    //  go find the user's first name, last name, display name,
    //  and account name from the DS.
    //

    ldapAttributes[0] = &L"givenName";
    ldapAttributes[1] = &L"sn";
    ldapAttributes[2] = &L"displayName";
    ldapAttributes[3] = &L"cn";
    ldapAttributes[4] = NULL;

    BinlFreeMemory( Filter );
    Filter = BinlAllocateMemory( 
                    (wcslen( pszUserName ) + (sizeof(L"(&(objectClass=user)(samAccountName=))")/sizeof(WCHAR)))
                    * sizeof(WCHAR));
    
    if (!Filter) {
        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto exitGetUserDetails;
    }
    
    wsprintf( Filter, L"(&(objectClass=user)(samAccountName=%s))", pszUserName );

    //
    //  we really don't want it to go chasing referrals over the entire
    //  enterprise since we know what the domain is but we do want to chase
    //  externals.
    //

    noReferralsPlease = (ULONG)((ULONG_PTR)LDAP_CHASE_EXTERNAL_REFERRALS);
    controlNoReferrals.ldctl_oid = LDAP_CONTROL_REFERRALS_W;
    controlNoReferrals.ldctl_value.bv_len =  sizeof(ULONG);
    controlNoReferrals.ldctl_value.bv_val =  (PCHAR) &noReferralsPlease;
    controlNoReferrals.ldctl_iscritical = FALSE;

    controlArray[0] = &controlNoReferrals;
    controlArray[1] = NULL;

    Error = ldap_search_ext_sW(LdapHandle,
                              *ldapDomain,
                              LDAP_SCOPE_SUBTREE,
                              Filter,
                              ldapAttributes,
                              FALSE,
                              NULL,
                              &controlArray[0],
                              0,
                              1,
                              &LdapMessage);

    if (Error == LDAP_SUCCESS) {
    
        Count = ldap_count_entries( LdapHandle, LdapMessage );
    
        if (Count > 0) {
    
            ldapEntry = ldap_first_entry( LdapHandle, LdapMessage );
    
            if (ldapEntry != NULL) {
    
                ldapFirstName = ldap_get_valuesW( LdapHandle,
                                                  ldapEntry,
                                                 L"givenName" );
    
                if (ldapFirstName != NULL &&
                    *ldapFirstName != NULL &&
                    **ldapFirstName != L'\0') {
    
                    OscAddVariableW( clientState, "USERFIRSTNAME", *ldapFirstName );
                    firstNameValid = TRUE;
                }
    
                ldapLastName  = ldap_get_valuesW( LdapHandle,
                                                  ldapEntry,
                                                  L"sn" );
                if (ldapLastName != NULL &&
                    *ldapLastName != NULL &&
                    **ldapLastName != L'\0') {
    
                    OscAddVariableW( clientState, "USERLASTNAME", *ldapLastName );
                    lastNameValid = TRUE;
                }
    
                //
                // Now that we have first and last name, set the USERFULLNAME
                // if either is not empty.
                //
    
                if ((firstNameValid || lastNameValid) && (userFullNameSet == FALSE)) {
    
                    ULONG userFullNameLength = 0;
                    PWCHAR userFullName;
    
                    if (firstNameValid) {
                        userFullNameLength = (wcslen(*ldapFirstName) + 1) * sizeof(WCHAR);
                    }
                    if (lastNameValid) {
                        if (firstNameValid) {
                            userFullNameLength += sizeof(WCHAR);  // for the space
                        }
                        userFullNameLength += (wcslen(*ldapLastName) + 1) * sizeof(WCHAR);
                    }
    
                    userFullName = BinlAllocateMemory(userFullNameLength);
                    if (userFullName != NULL) {
                        userFullName[0] = L'\0';
                        if (firstNameValid) {
                            wcscat(userFullName, *ldapFirstName);
                        }
                        if (lastNameValid) {
                            if (firstNameValid) {
                                wcscat(userFullName, L" ");
                            }
                            wcscat(userFullName, *ldapLastName);
                        }
                        OscAddVariableW( clientState, "USERFULLNAME", userFullName);
                        BinlFreeMemory(userFullName);
                        userFullNameSet = TRUE;
                    }
                }
    
                ldapDisplayName  = ldap_get_valuesW( LdapHandle,
                                                     ldapEntry,
                                                     L"displayName" );
                if (ldapDisplayName != NULL &&
                    *ldapDisplayName != NULL &&
                    **ldapDisplayName != L'\0') {
    
                    OscAddVariableW( clientState, "USERDISPLAYNAME", *ldapDisplayName );
                    if (!userFullNameSet) {
                        OscAddVariableW( clientState, "USERFULLNAME", *ldapDisplayName );
                        userFullNameSet = TRUE;
                    }
                }
    
                ldapAccountName  = ldap_get_valuesW( LdapHandle,
                                                     ldapEntry,
                                                     L"cn" );
                if (ldapAccountName != NULL &&
                    *ldapAccountName != NULL &&
                    **ldapAccountName != L'\0') {
    
                    OscAddVariableW( clientState, "USERACCOUNTNAME", *ldapAccountName );
                    if (!userFullNameSet) {
                        OscAddVariableW( clientState, "USERFULLNAME", *ldapAccountName );
                        userFullNameSet = TRUE;
                    }
                }
    
                ldapUserDN = ldap_get_dnW( LdapHandle, ldapEntry );
    
                if (ldapUserDN != NULL) {
    
                    explodedDN = ldap_explode_dnW( ldapUserDN, 0);
    
                    if (explodedDN != NULL &&
                        *explodedDN != NULL &&
                        *(explodedDN+1) != NULL ) {
    
                        //
                        //  if there's less than two components, we can't do
                        //  anything with this DN.
                        //
    
                        PWCHAR component;
                        ULONG requiredSize = 1; // 1 for null terminator
    
                        //
                        //  we now have an array of strings, each of which
                        //  is a component of the DN.  This is the safe and
                        //  correct way to chop off the first element.
                        //
    
                        Count = 1;
                        while ((component = explodedDN[Count++]) != NULL) {
    
                            requiredSize += wcslen( component ) + 1; // 1 for the comma
                        }
    
                        dnUsersOU = BinlAllocateMemory( requiredSize * sizeof(WCHAR) );
    
                        if (dnUsersOU != NULL) {
    
                            wcscpy( dnUsersOU, explodedDN[1] );
                            Count = 2;
                            while ((component = explodedDN[Count++]) != NULL) {
    
                                wcscat( dnUsersOU, L"," );
                                wcscat( dnUsersOU, component );
                            }
    
                            OscAddVariableW( clientState, "USEROU", dnUsersOU );
    
                        } else {
    
                            BinlPrintDbg((DEBUG_ERRORS,
                               "OscGetUserDetails: unable to allocate %lx for user OU\n",
                                requiredSize * sizeof(WCHAR)));
                        }
                    }
                }
            }
        } else {
            LogLdapError(   EVENT_WARNING_LDAP_SEARCH_ERROR,
                            LdapGetLastError(),
                            LdapHandle
                            );
        }
    } else {
        LogLdapError(   EVENT_WARNING_LDAP_SEARCH_ERROR,
                        LdapGetLastError(),
                        LdapHandle
                        );
    }
    
    if (LdapMessage) {
        ldap_msgfree( LdapMessage );
        LdapMessage = NULL;
    }

    Error = ERROR_SUCCESS;

exitGetUserDetails:

    if (dnUsersOU != NULL) {
        BinlFreeMemory( dnUsersOU );
    }
    if (explodedDN != NULL) {
        ldap_value_free( explodedDN );
    }
    if (ldapUserDN != NULL) {
        ldap_memfree( ldapUserDN );
    }
    if (ldapConfigContainer != NULL) {
        ldap_value_free( ldapConfigContainer );
    }
    if (ldapDomain != NULL) {
        ldap_value_free( ldapDomain );
    }
    if (ldapFirstName != NULL) {
        ldap_value_free( ldapFirstName );
    }
    if (ldapLastName != NULL) {
        ldap_value_free( ldapLastName );
    }
    if (ldapDisplayName != NULL) {
        ldap_value_free( ldapDisplayName );
    }
    if (ldapAccountName != NULL) {
        ldap_value_free( ldapAccountName );
    }
    if (impersonating) {
        OscRevert( clientState );
    }

    if (Filter != NULL) {
        BinlFreeMemory( Filter );
    }

    if (configContainer != NULL) {
        BinlFreeMemory( configContainer );
    }
    return Error;
}

DWORD
OscCreateAccount(
    PCLIENT_STATE clientState,
    PCREATE_DATA CreateData
    )
/*++

Routine Description:

    This function creates an account for the client specified by
    RequestContext and writes the response in CreateData, which
    will be sent down to the client.

    It also creates the client's base image directory.

Arguments:

    clientState - client state information

    CreateData - The block of data that will be sent down to the
        client if the account is successfully created.

Return Value:

    None.

--*/
{
    DWORD  Error;
    PWSTR pMachineName;
    PWSTR pMachineDN = NULL;
    PWSTR pMachineOU;
    PWSTR pServerName;
    PWSTR pInstallPath;

    WCHAR  SetupPath[MAX_PATH];
    PWSTR pNameDollarSign;
    ULONG  HostNameSize;
    UINT   uSize;
    LPSTR  pGuid;
    PWCHAR pStrings[3];
    
    MACHINE_INFO MachineInfo = { 0 };

    TraceFunc("OscCreateAccount( )\n");

    pMachineName = OscFindVariableW( clientState, "MACHINENAME" );
    pNameDollarSign = OscFindVariableW( clientState, "NETBIOSNAME" );

    //
    // Convert the GUID
    //
    pGuid = OscFindVariableA( clientState, "GUID" );
    Error = OscGuidToBytes( pGuid, MachineInfo.Guid );
    if ( Error != ERROR_SUCCESS )
        goto e0;

    if (clientState->fCreateNewAccount) {

        //
        // Create client's FQDN(DS)
        //
        pMachineOU = OscFindVariableW( clientState, "MACHINEOU" );
        BinlAssert( pMachineOU[0] != L'\0' );
        uSize = wcslen( pMachineName ) * sizeof(WCHAR)
              + wcslen( pMachineOU ) * sizeof(WCHAR)
              + sizeof(L"CN=,"); // includes terminating NULL char
        pMachineDN = (PWCHAR) BinlAllocateMemory( uSize );
        if ( !pMachineDN ) {
            Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
            goto e0;
        }
        wsprintf( pMachineDN, L"CN=%ws,%ws", pMachineName, pMachineOU );
        OscAddVariableW( clientState, "MACHINEDN", pMachineDN );

    } else {

        pMachineDN = OscFindVariableW( clientState, "MACHINEDN" );
    }

    //
    // Create the full setup path
    //
    pServerName = OscFindVariableW( clientState, "SERVERNAME");
    pInstallPath = OscFindVariableW( clientState, "INSTALLPATH");

    if (!pServerName || !pInstallPath ||
        (_snwprintf(SetupPath,
                   MAX_PATH,
                   L"\\\\%ws\\REMINST\\%ws",
                   pServerName ,
                   pInstallPath) < 0 )) {
        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto e0;
    }    
    SetupPath[MAX_PATH-1] = L'\0';

    EnterCriticalSection( &gcsParameters );
    MachineInfo.HostName = BinlStrDupW(BinlGlobalOurDnsName );
    LeaveCriticalSection( &gcsParameters );

    if ( !MachineInfo.HostName ) {
        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto e0;
    }

    //
    // Fill in the rest of the MachineInfo structure
    //
    MachineInfo.Name           = pMachineName;
    MachineInfo.MachineDN      = pMachineDN;
#if 1
    //
    // Don't store BOOTFILE in the cache/DS, since BOOTFILE points to setupldr
    // and we want the cache entry to point to oschooser. If we store an
    // empty string in the cache/DS, then GetBootParametersExt() will replace
    // that with the path to oschooser.
    //
    MachineInfo.BootFileName   = L"";
#else
    MachineInfo.BootFileName   = OscFindVariableW( clientState, "BOOTFILE" );
#endif
    MachineInfo.SetupPath      = SetupPath;
    MachineInfo.SamName        = pNameDollarSign;
    MachineInfo.Password       = clientState->MachineAccountPassword;
    MachineInfo.PasswordLength = clientState->MachineAccountPasswordLength;
    MachineInfo.dwFlags        = MI_NAME
                               | MI_HOSTNAME
                               | MI_BOOTFILENAME
                               | MI_SETUPPATH
                               | MI_SAMNAME
                               | MI_PASSWORD
                               | MI_MACHINEDN
                               | MI_GUID;

    //
    // Create the MAO in the DS
    //
    Error = UpdateAccount( clientState,
                           &MachineInfo,
                           clientState->fCreateNewAccount );  // create it
    if ( Error ) {
        goto e0;
    }

    //
    // Create the response to the client
    //
    Error = OscConstructSecret( 
                    clientState, 
                    clientState->MachineAccountPassword, 
                    clientState->MachineAccountPasswordLength, 
                    CreateData );
    if ( Error != ERROR_SUCCESS ) {
        OscCreateWin32SubError( clientState, Error );
        Error = ERROR_BINL_FAILED_TO_INITIALIZE_CLIENT;
        goto e0;
    }

    BinlPrint(( DEBUG_OSC, "Successfully created account for <%ws>\n", pMachineName ));
    pStrings[0] = pMachineName;
    pStrings[1] = OscFindVariableW( clientState, "USERNAME" );
    BinlReportEventW( EVENT_COMPUTER_ACCOUNT_CREATED_SUCCESSFULLY,
                      EVENTLOG_INFORMATION_TYPE,
                      2,
                      0,
                      pStrings,
                      0 );

e0:
    // No need to call FreeMachineInfo() since all the information
    // in it is either allocated on the stack or is referenced
    // by the clientState, but we do need to free the HostName
    // since it is allocated above.
    if ( MachineInfo.HostName ) {
        BinlFreeMemory( MachineInfo.HostName );
    }

    if ( pMachineDN && clientState->fCreateNewAccount ) {
        BinlFreeMemory( pMachineDN );
    }
    return Error;
}


//
// CheckForDuplicateMachineName( )
//
DWORD
CheckForDuplicateMachineName(
    PCLIENT_STATE clientState,
    LPWSTR pszMachineName )
{
    DWORD Error = ERROR_SUCCESS;
    PLDAPMessage LdapMessage = NULL;
    WCHAR  Filter[128];
    DWORD  count;
    PWCHAR ComputerAttrs[2];
    LPWSTR pDomain = OscFindVariableW( clientState, "MACHINEOU" );
    PWCHAR BaseDN;
    PLDAP LdapHandle;
    ULONG ldapRetryLimit = 0;
    PWCHAR *gcBase;

    PLDAPControlW controlArray[2];
    LDAPControlW controlNoReferrals;
    ULONG noReferralsPlease;

    //
    // see if binl is already in the process of registering the name with the DS
    //
    if (IsQueuedDSName(pszMachineName)) {
        Error = -1; // signal multiple accounts
        goto exitCheck;
    }

    ComputerAttrs[0] = &L"cn";
    ComputerAttrs[1] = NULL;

    TraceFunc( "CheckForDuplicateMachineName( )\n" );

    if (pDomain[0] == L'\0') {

        pDomain = OscFindVariableW( clientState, "USERDOMAIN" );
        BinlPrintDbg((DEBUG_ERRORS, "CheckforDupMachine: couldn't find root domain, using user's domain %ws\n.", pDomain));
    }

    BaseDN = StrStrIW( pDomain, L"DC=" );

    if (BaseDN == NULL) {
        BaseDN = pDomain;
    }

    LdapHandle = clientState->AuthenticatedDCLdapHandle;

    BinlAssert( LdapHandle != NULL );

    //
    //  According to the DS guys, it's not necessarily the case that CN is
    //  equal to SamAccountName and the latter is the important one.  It has
    //  a dollar sign at the end, so we'll tack that on.
    //

    if (_snwprintf( Filter,
                    sizeof(Filter)/sizeof(Filter[0]),
                    L"(&(objectClass=Computer)(samAccountName=%ws$))",
                    pszMachineName) < 0) {
        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto exitCheck;
    }
    Filter[(sizeof(Filter)/sizeof(Filter[0]))-1] = L'\0';

    //
    //  we really don't want it to go chasing subordinate referrals over
    //  the entire enterprise since we know what the domain is, therefore
    //  limit it to only external referrals (for child domains).
    //

    noReferralsPlease = (ULONG)((ULONG_PTR) LDAP_CHASE_EXTERNAL_REFERRALS);
    controlNoReferrals.ldctl_oid = LDAP_CONTROL_REFERRALS_W;
    controlNoReferrals.ldctl_value.bv_len =  sizeof(ULONG);
    controlNoReferrals.ldctl_value.bv_val =  (PCHAR) &noReferralsPlease;
    controlNoReferrals.ldctl_iscritical = FALSE;

    controlArray[0] = &controlNoReferrals;
    controlArray[1] = NULL;

Retry:
    Error = ldap_search_ext_s(LdapHandle,
                              BaseDN,
                              LDAP_SCOPE_SUBTREE,
                              Filter,
                              ComputerAttrs,
                              FALSE,
                              NULL,
                              &controlArray[0],
                              0,
                              1,
                              &LdapMessage);
    switch ( Error )
    {
    case LDAP_SUCCESS:
        break;

    case LDAP_BUSY:
        if (++ldapRetryLimit < LDAP_BUSY_LIMIT) {
            Sleep( LDAP_BUSY_DELAY );
            goto Retry;
        }

        // lack of break is on purpose.

    default:
        OscCreateLDAPSubError( clientState, Error );
        LogLdapError(   EVENT_WARNING_LDAP_SEARCH_ERROR,
                        Error,
                        LdapHandle
                        );
        BinlPrintDbg(( DEBUG_OSC_ERROR, "!!LdapError 0x%08x - Failed search to create machine name.\n", Error ));
        goto exitCheck;
    }

    count = ldap_count_entries( LdapHandle, LdapMessage );
    if ( count != 0 ) {
        Error = -1; // signal multiple accounts
        goto exitCheck;
    }

    ldap_msgfree( LdapMessage );
    LdapMessage = NULL;

    //
    //  now we go check the GC.
    //

    gcBase = NULL;

    Error = InitializeConnection( TRUE, &LdapHandle, &gcBase );
    if ( Error != ERROR_SUCCESS ) {

        //
        //  if no GC is present or available, we'll let this call succeed.
        //  Reasoning here is GCs can be flaky creatures.
        //
        Error = ERROR_SUCCESS;
        goto exitCheck;
    }

    ldapRetryLimit = 0;

RetryGC:
    Error = ldap_search_ext_s(LdapHandle,
                              *gcBase,
                              LDAP_SCOPE_SUBTREE,
                              Filter,
                              ComputerAttrs,
                              FALSE,
                              NULL,
                              NULL,
                              0,
                              1,
                              &LdapMessage);
    switch ( Error )
    {
    case LDAP_SUCCESS:
        break;

    case LDAP_BUSY:
        if (++ldapRetryLimit < LDAP_BUSY_LIMIT) {
            Sleep( LDAP_BUSY_DELAY );
            goto RetryGC;
        }

        // lack of break is on purpose.

    default:
        
        OscCreateLDAPSubError( clientState, Error );

        HandleLdapFailure( Error,
                         EVENT_WARNING_LDAP_SEARCH_ERROR,
                         TRUE,
                         &LdapHandle,
                         FALSE ); // don't have the lock
                         
        BinlPrintDbg(( DEBUG_OSC_ERROR, "!!LdapError 0x%08x - Failed search to create machine name.\n", Error ));
        goto exitCheck;
    }

    count = ldap_count_entries( LdapHandle, LdapMessage );

    if ( count != 0 ) {

        Error = -1; // signal multiple accounts

    } else {

        Error = ERROR_SUCCESS;
    }

exitCheck:

    if (LdapMessage) {
        ldap_msgfree( LdapMessage );
    }
    return Error;
}

//
// GenerateMachineName( )
//

DWORD
GenerateMachineName(
    PCLIENT_STATE clientState
    )
{
    DWORD  Error = ERROR_SUCCESS;
    GENNAME_VARIABLES variables;
    WCHAR  szMachineName[ DNS_MAX_LABEL_BUFFER_LENGTH ];
    DWORD  Count = 1;
    LPWSTR missingVariable;
    BOOL usedCounter;

    LPWSTR pszUserName;
    LPWSTR pszFirstName;
    LPWSTR pszLastName;
    LPWSTR pUserOU;
    LPWSTR pszMAC;

    TraceFunc( "GenerateMachineName( )\n" );

    pszUserName = OscFindVariableW( clientState, "USERNAME" );

    if ( pszUserName[0] == L'\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "USERNAME" );
        return ERROR_BINL_MISSING_VARIABLE;
    }

    Error = OscGetUserDetails( clientState );

    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg((DEBUG_OSC_ERROR,
                   "GenerateMachineName: OscGetUserDetails failed %lx\n", Error));
        return Error;
    }

    pszFirstName = OscFindVariableW( clientState, "USERFIRSTNAME" );
    pszLastName = OscFindVariableW( clientState, "USERLASTNAME" );
    pUserOU = OscFindVariableW( clientState, "USEROU" );
    pszMAC = OscFindVariableW( clientState, "MAC" );

    variables.UserName = pszUserName;
    variables.FirstName = pszFirstName;
    variables.LastName = pszLastName;
    variables.MacAddress = pszMAC;
    variables.AllowCounterTruncation = FALSE;

TryAgain:

    variables.Counter = ++clientState->nCreateAccountCounter;

    EnterCriticalSection( &gcsParameters );

    Error = GenerateNameFromTemplate(
                NewMachineNamingPolicy,
                &variables,
                szMachineName,
                DNS_MAX_LABEL_BUFFER_LENGTH,
                &missingVariable,
                &usedCounter,
                NULL
                );

    LeaveCriticalSection( &gcsParameters );

    if ( (Error != GENNAME_NO_ERROR) && (Error != GENNAME_NAME_TOO_LONG) ) {
        if ( Error == GENNAME_VARIABLE_MISSING ) {
            OscAddVariableW( clientState, "SUBERROR", missingVariable );
            clientState->nCreateAccountCounter = 0;
            return ERROR_BINL_MISSING_VARIABLE;
        }
        BinlAssert( (Error == GENNAME_COUNTER_TOO_HIGH) || (Error == GENNAME_TEMPLATE_INVALID) );
        clientState->nCreateAccountCounter = 0;
        return ERROR_BINL_UNABLE_TO_GENERATE_MACHINE_NAME;
    }

    BinlPrint(( DEBUG_OSC, "Generated MachineName = %ws\n", szMachineName ));

    //
    // grab the global lock so that we can synchronously find a unique name.
    // once we find a unique name, we then add it to the queued DS name list
    // to prevent another thread from attempting to register the same name
    //
    EnterCriticalSection( &gcsParameters );
    
    Error = CheckForDuplicateMachineName( clientState, szMachineName );
    
    if ( Error == -1 ) {
        if ( usedCounter ) {
            LeaveCriticalSection( &gcsParameters );
            goto TryAgain;
        }
        Error = ERROR_BINL_DUPLICATE_MACHINE_NAME_FOUND;
        LeaveCriticalSection( &gcsParameters );
    } else if ( Error == LDAP_SIZELIMIT_EXCEEDED ) {
        BinlPrint(( DEBUG_OSC, "MachineName '%s' has mutliple accounts already.\n", szMachineName ));
        if ( usedCounter ) {
            LeaveCriticalSection( &gcsParameters );
            goto TryAgain;
        }
        LeaveCriticalSection( &gcsParameters );
    } else if ( Error != LDAP_SUCCESS ) {
        Error = ERROR_BINL_UNABLE_TO_GENERATE_MACHINE_NAME;
        LeaveCriticalSection( &gcsParameters );
    } else {
        
        //
        // insert name into queued name list so another thread
        // fails the CheckForDuplicateMachineName if they try
        // to use the same name
        //
        Error = AddQueuedDSName(szMachineName);        

        LeaveCriticalSection( &gcsParameters );

        if (Error == ERROR_SUCCESS) {

            BinlPrintDbg(( DEBUG_OSC, "MachineName: '%ws'\n", szMachineName ));
            
            Error = OscAddVariableW( clientState, "MACHINENAME", szMachineName );
            
            if ( Error == ERROR_SUCCESS ) {

                WCHAR  NameDollarSign[17];  // MACHINENAME(15)+'$'+'\0'
                UINT   uSize;

                clientState->fAutomaticMachineName = TRUE;

                uSize = sizeof(NameDollarSign);
                // DnsHostnameToComputerNameW takes BYTEs in and returns the # of WCHARs out.
                if ( !DnsHostnameToComputerNameW( szMachineName, NameDollarSign, &uSize ) ) {
                    // if this fails(?), default to truncating machine name and
                    // add '$' to the end
                    BinlPrintDbg((DEBUG_OSC_ERROR, "!! Error 0x%08x - DnsHostnameToComputerNameW failed.\n", GetLastError() ));
                    BinlPrintDbg((DEBUG_OSC, "WARNING: Truncating machine name to 15 characters to generated NETBIOS name.\n" ));
                    memset( NameDollarSign, 0, sizeof(NameDollarSign) );
                    wcsncpy( NameDollarSign, szMachineName, 15 );
                }
                wcscat( NameDollarSign, L"$");
                Error = OscAddVariableW( clientState, "NETBIOSNAME", NameDollarSign );
            }
        }
    }

    clientState->nCreateAccountCounter = 0;

    return Error;

    
}

DWORD
OscCheckMachineDN(
    PCLIENT_STATE clientState
    )
//
//  Ensure that the client name, OU, and domain are setup correctly.  If there
//  are duplicate records in the DS with this same guid, we'll return
//  ERROR_BINL_DUPLICATE_MACHINE_NAME_FOUND and set %SUBERROR% string to
//  those DNs and return an error.
//
{
    DWORD    dwErr = ERROR_SUCCESS;
    PWCHAR   pwc;                       // parsing pointer
    WCHAR    wch;                       // temp wide char
    PWCHAR   pMachineName;              // Pointer to Machine Name variable value
    PWCHAR   pMachineOU;                // Pointer to where the MAO will be created
    PWCHAR   pDomain;                   // Pointer to Domain variable name
    PCHAR    pGuid;                     // Pointer to Guid variable name
    WCHAR    NameDollarSign[17];  // MACHINENAME(15)+'$'+'\0'
    WCHAR    Path[MAX_PATH];            // general purpose path buffer
    ULONG    i;                         // general counter
    BOOL     b;                         // general purpose BOOLean.
    UINT     uSize;
    UCHAR Guid[ BINL_GUID_LENGTH ];
    PMACHINE_INFO pMachineInfo = NULL;
    USHORT   SystemArchitecture;
    DWORD    DupRecordCount;

    TraceFunc("OscCheckMachineDN( )\n");

    if ( clientState->fHaveSetupMachineDN ) {

        // we've been through this logic before, just exit here with success.
        dwErr = ERROR_SUCCESS;
        goto e0;
    }

    dwErr = OscGetUserDetails( clientState );
    
    if (dwErr != ERROR_SUCCESS) {
        BinlPrintDbg((DEBUG_OSC_ERROR,
                   "OscCheckMachineDN: OscGetUserDetails failed %lx\n", dwErr));
        goto e0;
    }

    pGuid = OscFindVariableA( clientState, "GUID" );
    if ( pGuid[0] == '\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "GUID" );
        dwErr = ERROR_BINL_MISSING_VARIABLE;
        goto e0;
    }

    dwErr = OscGuidToBytes( pGuid, Guid );
    if ( dwErr != ERROR_SUCCESS ) {
        goto e0;
    }

    // Do we have a machine name yet?
    clientState->fCreateNewAccount = TRUE;
    pMachineName  = OscFindVariableW( clientState, "MACHINENAME" );
    if ( pMachineName[0] == L'\0' ) {

        clientState->CustomInstall = FALSE;

    } else {

        clientState->CustomInstall = TRUE;
    }

    clientState->fHaveSetupMachineDN = TRUE;


    SystemArchitecture = OscPlatformToArchitecture(clientState);
    

    //
    // See if the client already has an account with a matching GUID
    //
    dwErr = GetBootParameters( Guid,
                               &pMachineInfo,
                               MI_NAME | MI_DOMAIN | MI_MACHINEDN,
                               SystemArchitecture,
                               FALSE );    

    if (( dwErr == ERROR_SUCCESS ) &&
        ( !clientState->CustomInstall )) {

        PWCHAR pszOU;

        //
        // Since we asked for these, they should be set.
        //
        ASSERT ( pMachineInfo->dwFlags & MI_NAME );
        ASSERT ( pMachineInfo->dwFlags & MI_MACHINEDN );

        //
        //  if this is an automatic install, then we simply set the
        //  account info to the account we found.
        //

        // skip the comma
        pszOU = wcschr( pMachineInfo->MachineDN, L',' );
        if (pszOU) {
            pszOU++;
            OscAddVariableW( clientState, "MACHINEOU", pszOU );
        }

        OscAddVariableW( clientState, "MACHINEDN", pMachineInfo->MachineDN );

        dwErr = OscAddVariableW( clientState, "MACHINENAME", pMachineInfo->Name );
        if ( dwErr != ERROR_SUCCESS ) {
            BinlPrintDbg((DEBUG_OSC_ERROR,
                       "!!Error 0x%08x - OscCheckMachineDN: Unable to add MACHINENAME variable\n", dwErr ));
            goto e0;
        }
        clientState->fCreateNewAccount = FALSE;

        if ( pMachineInfo->dwFlags & MI_DOMAIN ) {
            OscAddVariableW( clientState, "MACHINEDOMAIN", pMachineInfo->Domain );
        }
    }

    //
    //  Do we have an OU yet?
    //
    pMachineOU = OscFindVariableW( clientState, "MACHINEOU" );
    if ( pMachineOU[0] == L'\0' ) {

        //
        //  Here's how we determine the OU...
        //
        //  if this is an auto, then MACHINEOU shouldn't already have
        //  been set by now.  If it's custom, then MACHINEOU may be empty
        //  or it may be set to what the user wants it set to.
        //
        //  if it's not already set, then we look at BinlGlobalDefaultContainer.
        //
        //  if this value is equal to the server's DN, then we set it to the
        //  default for this domain.
        //
        //  if BinlGlobalDefaultContainer is empty, then we set it to the
        //  user's OU.
        //

        if ( BinlGlobalServerDN == NULL ) {

            dwErr = ERROR_BINL_NO_DN_AVAILABLE_FOR_SERVER;
            BinlPrintDbg((DEBUG_OSC_ERROR,
                       "!!Error - OscCheckMachineDN: BinlGlobalServerDN is null\n", dwErr ));
            goto e0;
        }

        EnterCriticalSection( &gcsParameters );

        if ( BinlGlobalServerDN &&
             _wcsicmp( BinlGlobalDefaultContainer, BinlGlobalServerDN ) == 0) {

            //
            //  If the machine's OU is the same as this server's OU, then we set
            //  it to the default for this server's domain.
            //

            PWCHAR pDomainDefault = StrStrIW( BinlGlobalServerDN, L"DC=" );
            ULONG dwErrGetDefault;
            if ( pDomainDefault ) {

                dwErrGetDefault = OscGetDefaultContainerForDomain( clientState, pDomainDefault );

                //
                // spit out an error but keep going, we'll try the user's OU in a bit.
                //
                if (dwErrGetDefault != ERROR_SUCCESS) {

                    BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not get default MACHINEOU, 0x%x\n",dwErrGetDefault));
                }
            }
        } else {

            dwErr = OscAddVariableW( clientState, "MACHINEOU", BinlGlobalDefaultContainer );
            if ( dwErr != ERROR_SUCCESS ) {
                LeaveCriticalSection( &gcsParameters );
                BinlPrintDbg(( DEBUG_OSC_ERROR, "!!Error 0x%08x - Could not add MACHINEOU\n", dwErr ));
                goto e0;
            }
        }

        LeaveCriticalSection( &gcsParameters );

        pMachineOU = OscFindVariableW( clientState, "MACHINEOU" );
        if ( pMachineOU[0] == L'\0' ) {

            LPWSTR pUserOU = OscFindVariableW( clientState, "USEROU" );
            //
            //  the machine OU isn't already specified, that means we set it to
            //  the same as the user's OU.
            //

            if ( pUserOU[0] == L'\0' ) {
                BinlPrintDbg(( DEBUG_OSC_ERROR, "Missing UserOU variable\n" ));
                OscAddVariableA( clientState, "SUBERROR", "USEROU" );
                dwErr = ERROR_BINL_MISSING_VARIABLE;
                goto e0;
            }

            dwErr = OscAddVariableW( clientState, "MACHINEOU", pUserOU );
            if ( dwErr != ERROR_SUCCESS ) {
                BinlPrintDbg(( DEBUG_OSC_ERROR, "!!Error 0x%08x - Could not add MACHINEOU\n", dwErr ));
                goto e0;
            }

            pMachineOU = OscFindVariableW( clientState, "MACHINEOU" );
        }
    }

    //
    //  We need to generate the MACHINENAME after MACHINEOU because we need
    //  to know MACHINEOU to know which domain to check for duplicate
    //  machine names.
    //

    pMachineName = OscFindVariableW( clientState, "MACHINENAME" );

    if ( pMachineName[0] == L'\0' ) {

        dwErr = GenerateMachineName( clientState );
        if ( dwErr != ERROR_SUCCESS ) {
            BinlPrintDbg(( DEBUG_OSC_ERROR, "!!Error 0x%08x - Failed to generate machine name\n" ));
            goto e0;
        }
        // now we should have one
        pMachineName = OscFindVariableW( clientState, "MACHINENAME" );
    }
    BinlAssertMsg( pMachineName[0] != L'\0', "Missing MACHINENAME" );

    uSize = sizeof(NameDollarSign);
    // DnsHostnameToComputerNameW takes BYTEs in and returns the # of WCHARs out.
    if ( !DnsHostnameToComputerNameW( pMachineName, NameDollarSign, &uSize ) )
    {
        // if this fails(?), default to truncating machine name and
        // add '$' to the end
        BinlPrintDbg((DEBUG_OSC_ERROR, "!! Error 0x%08x - DnsHostnameToComputerNameW failed.\n", GetLastError( ) ));
        BinlPrintDbg((DEBUG_OSC, "WARNING: Truncating machine name to 15 characters to generated NETBIOS name.\n" ));
        memset( NameDollarSign, 0, sizeof(NameDollarSign) );
        wcsncpy( NameDollarSign, pMachineName, 15 );
        // don't return the error...
    }
    wcscat( NameDollarSign, L"$");
    OscAddVariableW( clientState, "NETBIOSNAME", NameDollarSign );

    // Do we have a domain yet?
    pDomain = OscFindVariableW( clientState, "MACHINEDOMAIN" );
    if ( pDomain[0] == L'\0' ) {

        // skip to the first "DC="
        pDomain = StrStrIW( pMachineOU, L"DC=" );
        if ( pDomain ) {

            PDS_NAME_RESULTW pResults;

            dwErr = DsCrackNames( INVALID_HANDLE_VALUE,
                                  DS_NAME_FLAG_SYNTACTICAL_ONLY,
                                  DS_FQDN_1779_NAME,
                                  DS_CANONICAL_NAME,
                                  1,
                                  &pDomain,
                                  &pResults );
            BinlAssertMsg( dwErr == ERROR_SUCCESS, "Error in DsCrackNames" );

            if ( dwErr == ERROR_SUCCESS ) {
                if ( pResults->cItems == 1
                  && pResults->rItems[0].status == DS_NAME_NO_ERROR
                  && pResults->rItems[0].pName ) {    // paranoid
                    pResults->rItems[0].pName[wcslen(pResults->rItems[0].pName)-1] = L'\0';
                    OscAddVariableW( clientState, "MACHINEDOMAIN", pResults->rItems[0].pName );
                }

                DsFreeNameResult( pResults );

                pDomain = OscFindVariableW( clientState, "MACHINEDOMAIN" );
            } else {
                pDomain = NULL;
            }
        }
    }

    // All else fails default to the servers
    if ( !pDomain || pDomain[0] == '\0' )
    {
        OscAddVariableW( clientState,
                         "MACHINEDOMAIN",
                         OscFindVariableW( clientState, "SERVERDOMAIN" ) );
    }

    //
    //  check for duplicate accounts in the ds.  fail if we find any, though
    //  we only fail after we have everything setup in case the user on
    //  custom install wants to ignore the error.  For automatic, it's
    //  currently a fatal error but this could be changed in the osc screens.
    //

    if (( pMachineInfo != NULL ) &&
        ( pMachineInfo->dwFlags & MI_MACHINEDN )) {

        PDUP_GUID_DN dupDN;
        PLIST_ENTRY listEntry;

        if (( pMachineInfo->dwFlags & MI_NAME ) &&
            ( clientState->CustomInstall )) {

            //
            //  if this is a custom install, then we compare the account
            //  the user entered with all the existing accounts we found.
            //  We want to match both machine namd and OU (this is really
            //  just the DN but we have not necessarily constructed that
            //  yet).
            //
            //  First we try the main entry in the cache, then all of
            //  the rest in the DNsWithSameGuid list.
            //

            // skip the comma
            ULONG err;
            PWCHAR MachineDNToUse;
            PWCHAR pszOU = wcschr( pMachineInfo->MachineDN, L',' );
            if (pszOU) {
                pszOU++;
            }

            //
            //  See if the main machine name and OU in the cache
            //  entry match.
            //

            if ((CompareStringW(
                     LOCALE_SYSTEM_DEFAULT,
                     NORM_IGNORECASE,
                     pMachineName,
                     -1,
                     pMachineInfo->Name,
                     -1
                     ) != 2)
                ||
                ((pszOU == NULL) && (pMachineOU[0] != L'\0'))
                ||
                ((pszOU != NULL) &&
                 (CompareStringW(
                      LOCALE_SYSTEM_DEFAULT,
                      NORM_IGNORECASE,
                      pMachineOU,
                      -1,
                      pszOU,
                      -1
                      ) != 2))) {

                //
                // We did not match the main entry in the cache, so
                // keep looking.
                //

                for (listEntry = pMachineInfo->DNsWithSameGuid.Flink;
                     listEntry != &pMachineInfo->DNsWithSameGuid;
                     listEntry = listEntry->Flink) {

                    dupDN = CONTAINING_RECORD(listEntry, DUP_GUID_DN, ListEntry);

                    pszOU = wcschr( &dupDN->DuplicateName[dupDN->DuplicateDNOffset], L',' );
                    if (pszOU) {
                        pszOU++;
                    }

                    if ((CompareStringW(
                             LOCALE_SYSTEM_DEFAULT,
                             NORM_IGNORECASE,
                             pMachineName,
                             -1,
                             dupDN->DuplicateName,
                             -1
                             ) != 2)
                        ||
                        ((pszOU == NULL) && (pMachineOU[0] != L'\0'))
                        ||
                        ((pszOU != NULL) &&
                         (CompareStringW(
                              LOCALE_SYSTEM_DEFAULT,
                              NORM_IGNORECASE,
                              pMachineOU,
                              -1,
                              pszOU,
                              -1
                              ) != 2))) {

                        //
                        // No match on this one.
                        //

                        continue;

                    } else {

                        //
                        // We found a match. Note which DN to use for
                        // this account.
                        //

                        MachineDNToUse = &dupDN->DuplicateName[dupDN->DuplicateDNOffset];
                        break;
                    }
                }

                //
                // If we got to the end of our list with no match, jump to
                // the error case.
                //

                if (listEntry == &pMachineInfo->DNsWithSameGuid) {
                    goto exitWithDupError;
                }

            } else {

                //
                // The main cache entry matched.
                //

                MachineDNToUse = pMachineInfo->MachineDN;
            }

            //
            //  We didn't jump to exitWithDupError above, so we found a match.
            //  we know that the client is using an existing account, let's
            //  mark the client state as such.  this is the custom case.
            //
            clientState->fCreateNewAccount = FALSE;

            OscAddVariableW( clientState, "MACHINEDN", MachineDNToUse );

            if ( pMachineInfo->dwFlags & MI_DOMAIN ) {
                OscAddVariableW( clientState, "MACHINEDOMAIN", pMachineInfo->Domain );
            }
        }

        if (!IsListEmpty(&pMachineInfo->DNsWithSameGuid)) {

            //
            //  if there's more than one account, we fill in SUBERROR
            //  with a list of the duplicates and return an error.
            //

            PWCHAR dnList;
            ULONG requiredSize = 1; // 1 for null terminator
            BOOL FreeDnList;

exitWithDupError:
            //
            // since we tack a <BR> to the end of each string, we'll account
            // for it when we allocate the string as +4 from what we need.
            //
#define     MAX_DUPLICATE_RECORDS_TO_DISPLAY         4

            requiredSize += wcslen( pMachineInfo->Name ) + (sizeof(L"<BR>")/sizeof(WCHAR));
            listEntry = pMachineInfo->DNsWithSameGuid.Flink;

            DupRecordCount = 0;
            while (listEntry != &pMachineInfo->DNsWithSameGuid) {                

                dupDN = CONTAINING_RECORD(listEntry, DUP_GUID_DN, ListEntry);
                listEntry = listEntry->Flink;
                DupRecordCount += 1;

                if (DupRecordCount <= MAX_DUPLICATE_RECORDS_TO_DISPLAY) {
                    requiredSize += wcslen( &dupDN->DuplicateName[0] ) + sizeof("<BR>");
                } else if (DupRecordCount == MAX_DUPLICATE_RECORDS_TO_DISPLAY+1) {
                    requiredSize += sizeof( "..." ) + sizeof("<BR>");
                }
            }

            dnList = BinlAllocateMemory( requiredSize * sizeof(WCHAR) );

            DupRecordCount = 0;
            if (dnList != NULL) {

                ULONG  nameLength;

                nameLength = wcslen(pMachineInfo->Name);
                FreeDnList = TRUE;

                //
                // The Name field should not end in a '$'.
                //

                ASSERT (!((nameLength > 1) && (pMachineInfo->Name[nameLength-1] == L'$')));

                wcscpy( dnList, pMachineInfo->Name );
                wcscat( dnList, L"<BR>" );

                listEntry = pMachineInfo->DNsWithSameGuid.Flink;

                while (listEntry != &pMachineInfo->DNsWithSameGuid) {

                    dupDN = CONTAINING_RECORD(listEntry, DUP_GUID_DN, ListEntry);
                    listEntry = listEntry->Flink;

                    DupRecordCount += 1;

                    if (DupRecordCount <= MAX_DUPLICATE_RECORDS_TO_DISPLAY) {
                    
                        nameLength = wcslen(dupDN->DuplicateName);
    
                        //
                        // The DuplicateName field should not have the '$' either
                        //
    
                        ASSERT (!((nameLength > 1) && (dupDN->DuplicateName[nameLength-1] == L'$')));
    
                        wcscat( dnList, dupDN->DuplicateName );
                        wcscat( dnList, L"<BR>" );

                    } else if (DupRecordCount == MAX_DUPLICATE_RECORDS_TO_DISPLAY + 1) {
                        wcscat( dnList, L"..." );
                        wcscat( dnList, L"<BR>" );
                    }
                }
            } else {
                FreeDnList = FALSE;
                dnList = pMachineInfo->MachineDN;
            }

            OscAddVariableW( clientState, "SUBERROR", dnList );
            if (FreeDnList) {
                BinlFreeMemory( dnList );
            }
            dwErr = ERROR_BINL_DUPLICATE_MACHINE_NAME_FOUND;
        }
    } else {
        //
        // We must not exist in the DS yet so there cannot be a duplicate.
        // set the error to successand return.
        //
        dwErr = ERROR_SUCCESS;
    }

e0:
    if ( pMachineInfo ) {
        BinlDoneWithCacheEntry( pMachineInfo, FALSE );
    }
    return dwErr;
}

DWORD
OscGetDefaultContainerForDomain (
    PCLIENT_STATE clientState,
    PWCHAR DomainDN
    )
{
    PLDAP LdapHandle;
    PLDAPMessage LdapMessage = NULL;
    PWCHAR ldapAttributes[2];
    BOOLEAN impersonating = FALSE;
    PLDAPMessage ldapEntry;
    PWCHAR *ldapWellKnownObjectValues = NULL;
    PWCHAR objectValue;
    PWCHAR guidEnd;
    WCHAR savedChar;
    ULONG Error = LDAP_NO_SUCH_ATTRIBUTE;
    ULONG Count;

    if (clientState->AuthenticatedDCLdapHandle == NULL) {

        Error = OscImpersonate(clientState);
        if (Error != ERROR_SUCCESS) {
            BinlPrintDbg((DEBUG_ERRORS,
                       "OscGetDefaultContainer: OscImpersonate failed %lx\n", Error));
            return Error;
        }
        impersonating = TRUE;
        BinlAssert( clientState->AuthenticatedDCLdapHandle != NULL );
    }

    LdapHandle = clientState->AuthenticatedDCLdapHandle;

    //
    //  we look up the wellKnownObjects in the root of the domain
    //

    ldapAttributes[0] = L"wellKnownObjects";
    ldapAttributes[1] = NULL;

    Error = ldap_search_ext_sW(LdapHandle,
                               DomainDN,
                               LDAP_SCOPE_BASE,
                               L"objectclass=*",
                               ldapAttributes,
                               FALSE,
                               NULL,
                               NULL,
                               0,
                               0,
                               &LdapMessage);

    if (Error == LDAP_SUCCESS) {
        Count = ldap_count_entries( LdapHandle, LdapMessage );
    } else {
        Count = 0;
    }

    Error = LDAP_NO_SUCH_ATTRIBUTE;

    if (Count == 0) {

        BinlPrintDbg((DEBUG_ERRORS,
                   "OscGetDefaultContainer: get default domain failed with no records found\n"));
        LogLdapError(   EVENT_WARNING_LDAP_SEARCH_ERROR,
                        Error,
                        LdapHandle
                        );       
        goto exitGetDefaultContainer;
    }

    ldapEntry = ldap_first_entry( LdapHandle, LdapMessage );

    if (ldapEntry == NULL) {

        BinlPrintDbg((DEBUG_ERRORS,
                   "OscGetDefaultContainer: get first entry failed\n"));
        goto exitGetDefaultContainer;
    }

    ldapWellKnownObjectValues = ldap_get_valuesW( LdapHandle,
                                                  ldapEntry,
                                                  L"wellKnownObjects" );
    if (ldapWellKnownObjectValues == NULL) {

        BinlPrintDbg((DEBUG_ERRORS,"OscGetDefaultContainer: get value failed\n"));
        goto exitGetDefaultContainer;
    }

    Count = 0;
    objectValue = NULL;
    while (1) {

        objectValue = ldapWellKnownObjectValues[Count++];

        if (objectValue == NULL) {
            break;
        }

        //
        //  the structure of this particular field is :
        //  L"B:32:GUID:DN" where GUID is AA312825768811D1ADED00C04FD8D5CD
        //

        if (wcslen( objectValue ) <
            (sizeof( COMPUTER_DEFAULT_CONTAINER_IN_B32_FORM )/sizeof(WCHAR)) -1 ) {

            continue;
        }

        //
        //   see if it matches "B:32:specialGuid:" then DN follows
        //

        guidEnd = objectValue + (sizeof( COMPUTER_DEFAULT_CONTAINER_IN_B32_FORM )/sizeof(WCHAR))-1;
        savedChar = *guidEnd;
        *guidEnd = L'\0';

        if (_wcsicmp( objectValue, COMPUTER_DEFAULT_CONTAINER_IN_B32_FORM) != 0) {

            *guidEnd = savedChar;
            continue;
        }

        *guidEnd = savedChar;   // this is the first character of the DN

        //
        //  we have our value, now copy it off.
        //

        OscAddVariableW( clientState, "MACHINEOU", guidEnd );

        Error = ERROR_SUCCESS;
        break;
    }

exitGetDefaultContainer:

    if (ldapWellKnownObjectValues) {
        ldap_value_free( ldapWellKnownObjectValues );
    }
    if (LdapMessage) {
        ldap_msgfree( LdapMessage );
    }
    if (impersonating) {
        OscRevert( clientState );
    }
    return Error;
}

VOID
LogLdapError (
    ULONG LdapEvent,
    ULONG LdapError,
    PLDAP LdapHandle OPTIONAL
    )
{
    PWCHAR Server = NULL;

    if (LdapError != LDAP_SUCCESS) {

        if (LdapHandle != NULL) {

            ldap_get_option( LdapHandle, LDAP_OPT_HOST_NAME, &Server );
        }

        if (++BinlGlobalLdapErrorCount <= BinlGlobalMaxLdapErrorsLogged) {

            PWCHAR strings[2];

            if (Server) {
                strings[0] = Server;
            } else {
                strings[0] = L"?";
            }
            strings[1] = NULL;

            BinlReportEventW( LdapEvent,
                              EVENTLOG_WARNING_TYPE,
                              (Server != NULL) ? 1 : 0,
                              sizeof(LdapError),
                              (Server != NULL) ? strings : NULL,
                              &LdapError
                              );
        }
    }
    return;
}


DWORD 
MyGetDcHandle(
    PCLIENT_STATE clientState,
    PCSTR DomainName,
    PHANDLE Handle
    )
{
    DWORD Error;
    HANDLE hDC;
    PDOMAIN_CONTROLLER_INFOA DCI = NULL;
    DWORD impersonateError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
    
    BinlPrintDbg((
        DEBUG_OSC, 
        "Attempting discovery of DC in %s domain.\n",
        DomainName ));
    
    Error = DsGetDcNameA( 
        NULL, 
        DomainName,
        NULL,
        NULL,
        DS_IS_DNS_NAME | DS_RETURN_DNS_NAME,
        &DCI);
    
    if (Error == ERROR_SUCCESS) {
    
        BinlPrintDbg((
            DEBUG_OSC, 
            "DC is %s, attempting bind.\n",
            DCI->DomainControllerName ));
    
        impersonateError = OscImpersonate(clientState);
    
        Error = DsBindA(DCI->DomainControllerName, NULL, &hDC);
        if (Error != ERROR_SUCCESS) {
            BinlPrintDbg((
                DEBUG_OSC_ERROR, 
                "DsBind failed, ec = %d.\n",
                Error ));
        } else {
            PSTR p = DCI->DomainControllerName;

            *Handle = hDC;

            //
            // if it's got '\\' in the front, then strip those
            // off because ldap_init hates them
            //
            while (*p == '\\') {
                p = p + 1;
            }

            OscAddVariableA( clientState, "DCNAME", p );
        }
    
        NetApiBufferFree(DCI);
    
    } else {
        BinlPrintDbg((
        DEBUG_OSC_ERROR, 
        "DsGetDcNameA failed, ec = %d.\n",
        Error ));
    }

    if (impersonateError == ERROR_SUCCESS) {
        OscRevert(clientState);
    }

    return(Error);

}

DWORD
AddQueuedDSName(
    PWCHAR  Name
    )
/*++

description:

    this routine ADDS a name to the queued ds name list.

args:

    Name    - queued DS Name to add

return:

    status

--*/
{
    DWORD                   Error = ERROR_SUCCESS;
    PQUEUED_DS_NAME_NODE    queuedDSName;
    PLIST_ENTRY             ListEntry;
    ULONG                   ListEntrySize;

    do {

        //
        //
        //
        ListEntrySize = sizeof(QUEUED_DS_NAME_NODE);
        ListEntrySize += (wcslen(Name) + 1) * sizeof(WCHAR);

        ListEntry = BinlAllocateMemory( ListEntrySize );

        if (ListEntry == NULL) {

            Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;

            break;

        }

        queuedDSName = CONTAINING_RECORD(ListEntry, QUEUED_DS_NAME_NODE, ListEntry);
        
        wcscpy(queuedDSName->Name, Name);

        //
        //
        //
        EnterCriticalSection( &QueuedDSNamesCriticalSection );
        
        InsertTailList(&QueuedDSNamesList, ListEntry);
        
        LeaveCriticalSection( &QueuedDSNamesCriticalSection );
    
    } while ( FALSE );

    if (Error != ERROR_SUCCESS) {
        if (ListEntry) {
            BinlFreeMemory(ListEntry);
        }
    }

    return Error;
}

PLIST_ENTRY
FindQueuedDSName(
    PWCHAR  Name
    )
/*++

description:

    this routine attempts to find a name in the queued ds name list.

    note: this routine assumes that the global list lock is held
          by the caller

args:

    Name    - queued DS Name to find

return:

    if found, pointer to listEntry is returned.
    else NULL

--*/
{
    PQUEUED_DS_NAME_NODE    queuedDSName;
    PLIST_ENTRY             listEntry;
    int                     compare;
    BOOL                    found;

    found = FALSE;

    for (listEntry = QueuedDSNamesList.Flink;
         listEntry != &QueuedDSNamesList;
         listEntry = listEntry->Flink) {

        queuedDSName = CONTAINING_RECORD(listEntry, QUEUED_DS_NAME_NODE, ListEntry);

        compare = CompareStringW(
                 LOCALE_SYSTEM_DEFAULT,
                 NORM_IGNORECASE,
                 Name,
                 -1,
                 queuedDSName->Name,
                 -1
                 );

        if (compare == CSTR_EQUAL) {
            found = TRUE;
            break;
        }
    
    }

    if (!found) {
        listEntry = NULL;
    }

    return listEntry;
}

DWORD
RemoveQueuedDSName(
    PWCHAR  Name
    )
/*++

description:

    this routine REMOVES a name to the queued ds name list.

args:

    Name    - queued DS Name to remove

return:

    status

--*/
{
    DWORD       Error = ERROR_SUCCESS;
    PLIST_ENTRY ListEntry;    

    do {

        //
        //
        //
        EnterCriticalSection( &QueuedDSNamesCriticalSection );
        
        ListEntry = FindQueuedDSName(Name);
        
        if (ListEntry == NULL) {
            Error = ERROR_NOT_FOUND;
            break;
        }

        //
        //
        //
        RemoveEntryList(ListEntry);

    } while ( FALSE );

    LeaveCriticalSection( &QueuedDSNamesCriticalSection );

    //
    //
    //
    if (Error == ERROR_SUCCESS) {
        
        BinlAssert( ListEntry != NULL );

        BinlFreeMemory(ListEntry);

    }
    
    return Error;
}

BOOL
IsQueuedDSName(
    PWCHAR  Name
    )
/*++

description:

    this routine determines if a name exits in the queued ds name list.

args:

    Name    - queued DS Name to find

return:

    status

--*/
{
    BOOL        bFound;
    PLIST_ENTRY ListEntry;    

    bFound = FALSE;

    //
    //
    //
    EnterCriticalSection( &QueuedDSNamesCriticalSection );
    
    ListEntry = FindQueuedDSName(Name);
    
    if (ListEntry != NULL) {
        bFound = TRUE;
    }

    LeaveCriticalSection( &QueuedDSNamesCriticalSection );

    return bFound;
}


VOID
FreeQueuedDSNameList(
    VOID
    )
/*++

description:

    this routine any entries in the Queued DS Name list

args:

    None 
    
return:

    None
    
--*/
{
    PLIST_ENTRY             listEntry;

    EnterCriticalSection( &QueuedDSNamesCriticalSection );
    
    while(! IsListEmpty(&QueuedDSNamesList)) {

        listEntry = RemoveHeadList(&QueuedDSNamesList);

        BinlFreeMemory(listEntry);

    }

    BinlAssert(IsListEmpty(&QueuedDSNamesList));
    
    LeaveCriticalSection( &QueuedDSNamesCriticalSection );
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\main.c ===
/*++

Copyright (c) 1994-7  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This is the main routine for the BINL server service.

    Where possible, debugged code has been obtained from the
    DHCP server since BINL processes similarly formatted
    requests.

Author:

    Colin Watson (colinw)  14-Apr-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include <binl.h>
#pragma hdrstop

#define GLOBAL_DATA_ALLOCATE    // allocate global data defined in global.h
#include <global.h>

#define BINL_PNP_DELAY_SECONDS 10

#define BINL_LSA_SERVER_NAME_POLICY PolicyNotifyDnsDomainInformation

//
// module variables
//

PSECURITY_DESCRIPTOR s_SecurityDescriptor = NULL;

struct l_timeval BinlLdapSearchTimeout;
ULARGE_INTEGER  BinlSifFileScavengerTime;


#if defined(REGISTRY_ROGUE)
BOOL RogueDetection = FALSE;
#endif

VOID
FreeClient(
    PCLIENT_STATE client
    );


DWORD
UpdateStatus(
    VOID
    )
/*++

Routine Description:

    This function updates the binl service status with the Service
    Controller.

Arguments:

    None.

Return Value:

    Return code from SetServiceStatus.

--*/
{
    DWORD Error = ERROR_SUCCESS;


#if DBG
    if (BinlGlobalRunningAsProcess) {
        return(Error);
    }
#endif

    if ( BinlGlobalServiceStatusHandle != 0 ) {

        if (!SetServiceStatus(
                    BinlGlobalServiceStatusHandle,
                    &BinlGlobalServiceStatus)) {
            Error = GetLastError();
            BinlPrintDbg((DEBUG_ERRORS, "SetServiceStatus failed, %ld.\n", Error ));
        }
    }

    return(Error);
}

//
// BinlReadParameters( )
//
DWORD
BinlReadParameters( )
{
    DWORD dwDSErr;
    DWORD dwErr;
    HKEY KeyHandle;
    UINT uResult;
    PWCHAR LanguageString;
    PWCHAR OrgnameString;
    PWCHAR TimezoneString;
    TIME_ZONE_INFORMATION TimeZoneInformation;
    HKEY KeyHandle2 = NULL;
    DWORD Index;

    //
    // Get any registry overrides
    //
    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                BINL_PARAMETERS_KEY,
                0,
                KEY_QUERY_VALUE,
                &KeyHandle );
    if ( dwErr != ERROR_SUCCESS ) {
        KeyHandle = NULL;
    }

    BinlRegGetValue( KeyHandle, BINL_DEFAULT_CONTAINER ,   REG_SZ, (LPBYTE *)&BinlGlobalDefaultContainer );
    BinlRegGetValue( KeyHandle, BINL_DEFAULT_DOMAIN,       REG_SZ, (LPBYTE *)&DefaultDomain );

    BinlRegGetValue( KeyHandle, BINL_DEFAULT_DS, REG_SZ, (LPBYTE *)&BinlGlobalDefaultDS );
    BinlRegGetValue( KeyHandle, BINL_DEFAULT_GC, REG_SZ, (LPBYTE *)&BinlGlobalDefaultGC );

    AllowNewClients   = ReadDWord( KeyHandle, BINL_ALLOW_NEW_CLIENTS, AllowNewClients );

#if defined(REGISTRY_ROGUE)
    RogueDetection  = ReadDWord( KeyHandle, L"RogueDetection", RogueDetection );
#endif

    BinlClientTimeout = ReadDWord( KeyHandle, BINL_CLIENT_TIMEOUT,    900 );
    BinlPrint((DEBUG_OPTIONS, "Client Timeout = %u seconds\n", BinlClientTimeout ));

    g_Port            = ReadDWord( KeyHandle, BINL_PORT_NAME,         BINL_DEFAULT_PORT );
    BinlPrint((DEBUG_OPTIONS, "Port Number = %u\n", g_Port ));

    //
    // BinlGlobalScavengerSleep and BinlUpdateFromDSTimeout are specified in
    // the registry in seconds, but are maintained internally in milliseconds.
    //

    BinlGlobalScavengerSleep = ReadDWord( KeyHandle, BINL_SCAVENGER_SLEEP, 60 ); // seconds
    BinlGlobalScavengerSleep *= 1000; // convert to milliseconds
    BinlPrint((DEBUG_OPTIONS, "Scavenger Timeout = %u milliseconds\n", BinlGlobalScavengerSleep ));


    Index = ReadDWord( KeyHandle, BINL_SCAVENGER_SIFFILE, 24 ); // hours
    if (Index == 0 ) {
        Index = 24;
    }

    //
    // BinlSifFileScavengerTime is read from the registry in seconds, but is
    // maintained internally as a filetime, which has a resolution of 100 ns 
    // intervals (100 ns == 10^7)
    //    
    BinlSifFileScavengerTime.QuadPart = (ULONGLONG)(Index * 60) * 60 * 1000 * 10000;
    BinlPrint((DEBUG_OPTIONS, "SIF File Scavenger Timeout = %d hours\n", Index ));


    BinlUpdateFromDSTimeout = ReadDWord( KeyHandle, BINL_UPDATE_PARAMETER_POLL, 4 * 60 * 60 ); // seconds
    BinlUpdateFromDSTimeout *= 1000; // convert to milliseconds
    BinlPrint((DEBUG_OPTIONS, "Update from DS Timeout = %u milliseconds\n", BinlUpdateFromDSTimeout ));

    //
    //  Setup the variables which control how many ldap errors we log at most
    //  during a given time period and what the time period is.
    //

    BinlGlobalMaxLdapErrorsLogged = ReadDWord( KeyHandle, BINL_DS_ERROR_COUNT_PARAMETER, 10 );
    BinlGlobalLdapErrorScavenger = ReadDWord( KeyHandle, BINL_DS_ERROR_SLEEP, 10 * 60 );  // seconds, default to 10 minutes
    BinlGlobalLdapErrorScavenger *= 1000; // convert to milliseconds
    BinlPrint((DEBUG_OPTIONS, "DS Error log timeout = %u milliseconds\n", BinlGlobalLdapErrorScavenger ));

    //
    //  get the min time to wait before we respond to a new client
    //
    //  It defaults to 7 because it will then ignore the  first two packets
    //  and respond starting at the third.  After testing, we may change
    //  this to 3.
    //

    BinlMinDelayResponseForNewClients = (DWORD) ReadDWord(  KeyHandle,
                                                            BINL_MIN_RESPONSE_TIME,
                                                            0 );
    BinlPrint((DEBUG_OPTIONS, "New Client Timeout Minimum = %u seconds\n", BinlMinDelayResponseForNewClients ));

    //
    //  Get the max time we'll wait for an ldap request
    //

    BinlLdapSearchTimeout.tv_usec = 0;
    BinlLdapSearchTimeout.tv_sec = (DWORD) ReadDWord( KeyHandle,
                                            BINL_LDAP_SEARCH_TIMEOUT,
                                            BINL_LDAP_SEARCH_TIMEOUT_SECONDS );
    BinlPrint((DEBUG_OPTIONS, "LDAP Search Timeout = %u seconds\n", BinlLdapSearchTimeout.tv_sec ));

    //
    //  We need to give the DS some time to find the entries.  If the user
    //  specified 0 timeout, default to some decent minimum.
    //
    if (BinlLdapSearchTimeout.tv_sec == 0) {

        BinlLdapSearchTimeout.tv_usec = BINL_LDAP_SEARCH_MIN_TIMEOUT_MSECS;
    }

    BinlCacheExpireMilliseconds = (ULONG) ReadDWord( KeyHandle, BINL_CACHE_EXPIRE, BINL_CACHE_EXPIRE_DEFAULT);
    BinlPrint(( DEBUG_OPTIONS, "Cache Entry Expire Time = %u milliseconds\n", BinlCacheExpireMilliseconds ));

    BinlGlobalCacheCountLimit = (ULONG) ReadDWord( KeyHandle, BINL_CACHE_MAX_COUNT, BINL_CACHE_COUNT_LIMIT_DEFAULT);
    BinlPrint(( DEBUG_OPTIONS, "Maximum Cache Count = %u entries\n", BinlGlobalCacheCountLimit ));

#if DBG
    //
    // Test for repeat ACKs - 0 = disabled
    //
    BinlRepeatSleep = (DWORD) ReadDWord( KeyHandle, BINL_REPEAT_RESPONSE, 0 );
#endif

    //
    // Turn on/off LDAP_OPT_REFERRALS
    //
    BinlLdapOptReferrals = (DWORD) ReadDWord( KeyHandle, BINL_LDAP_OPT_REFERRALS, (ULONG) ((ULONG_PTR)LDAP_OPT_OFF) );

    //
    // Determine whether to assign new client accounts to the creating server.
    //
    AssignNewClientsToServer = (DWORD) ReadDWord( KeyHandle, BINL_ASSIGN_NEW_CLIENTS_TO_SERVER, AssignNewClientsToServer );
    BinlPrint(( DEBUG_OPTIONS, "Assign new clients to this server = %u\n", AssignNewClientsToServer ));

    BinlGlobalUseNTLMV2 = (DWORD) ReadDWord( KeyHandle, BINL_NTLMV2_AUTHENTICATE, BINL_NTLMV2_AUTHENTICATE_DEFAULT );
    BinlRegGetValue( KeyHandle, BINL_NTLMV2_AUTHENTICATE, REG_SZ, (LPBYTE *)&BinlGlobalDefaultGC );


    if (KeyHandle) {
        RegCloseKey(KeyHandle);
    }

    //
    // Determine the default language.
    //

    LanguageString = NULL;

    uResult = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SENGLANGUAGE, NULL, 0);
    if (uResult != 0) {
        LanguageString = BinlAllocateMemory(uResult * sizeof(WCHAR) );
        if (LanguageString != NULL) {
            uResult = GetLocaleInfo(
                        LOCALE_SYSTEM_DEFAULT,
                        LOCALE_SENGLANGUAGE,
                        LanguageString,
                        uResult );
            if (uResult == 0) {
                BinlFreeMemory( LanguageString );
                LanguageString = NULL;
            }
        }
    }

    //
    // Determine the default organization to put in .sif files.
    //

    OrgnameString = NULL;

    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                L"Software\\Microsoft\\Windows NT\\CurrentVersion",
                0,
                KEY_QUERY_VALUE,
                &KeyHandle );
    if ( dwErr == ERROR_SUCCESS ) {
        dwErr = BinlRegGetValue(
                    KeyHandle,
                    L"RegisteredOrganization",
                    REG_SZ,
                    (LPBYTE *)&OrgnameString );
        if ( dwErr != ERROR_SUCCESS ) {
            ASSERT( OrgnameString == NULL );
        }
        RegCloseKey(KeyHandle);
    }

    //
    // Determine the default timezone to put in .sif files.
    //

    TimezoneString = NULL;

    if (GetTimeZoneInformation(&TimeZoneInformation) != TIME_ZONE_ID_INVALID) {

        //
        // We need to find the value of
        // "Software\\Microsoft\\Windows NT\\CurrentVersion\Time Zones\
        // {TimeZoneInformation.StandardName}\Index.
        //

        dwErr = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones",
                    0,
                    KEY_READ,
                    &KeyHandle );
        if (dwErr == ERROR_SUCCESS) {

            dwErr = RegOpenKeyEx(
                        KeyHandle,
                        TimeZoneInformation.StandardName,
                        0,
                        KEY_QUERY_VALUE,
                        &KeyHandle2);

            //
            // In Far East NT, the TimeZoneInformation.StandardName gets a
            // localized string of the English time zone name, but the subkey
            // name remains in English. For example, if the time zone is
            // "Pacific Standard Time", TimeZoneInformation.StandardName will
            // be the localized string for this English string, but the subkey
            // name will still be "Pacific Standard Time".
            //
            // So if we pass this Localized string to RegOpenKeyEx(), we may
            // get error value (0x00000002).
            //
            // The above code works fine in US Build, but for FE build, we
            // have to add a code block to get the correct Key.
            //

            if ( dwErr != ERROR_SUCCESS ) {

                //
                // This is for FE builds. Normally, in US Build, code will
                // not go to here.
                //

                WCHAR   pszSubKeyName[MAX_PATH];
                WCHAR   pszAlternateName[MAX_PATH];
                DWORD   cbName;
                LONG    lRetValue;
                DWORD   dwIndex;

                dwIndex = 0;

                //
                // The alternate name is the name returned by
                // GetTimeZoneInformation with "Standard Time"
                // added at the end -- NT4 upgraded machines
                // may return the old names.
                //

                wcscpy(pszAlternateName, TimeZoneInformation.StandardName);
                wcscat(pszAlternateName, L" Standard Time");

                cbName = MAX_PATH;

                lRetValue = RegEnumKeyEx(
                                         KeyHandle,
                                         dwIndex,
                                         pszSubKeyName,
                                         &cbName,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL );

                KeyHandle2 = NULL;

                while ( lRetValue != ERROR_NO_MORE_ITEMS ) {


                    if ( KeyHandle2 != NULL ) {
                       RegCloseKey( KeyHandle2 );
                       KeyHandle2 = NULL;
                    }

                    dwErr = RegOpenKeyEx(
                                        KeyHandle,
                                        pszSubKeyName,
                                        0,
                                        KEY_QUERY_VALUE,
                                        &KeyHandle2);
                    if ( dwErr == ERROR_SUCCESS ) {

                        WCHAR   StdName[MAX_PATH];
                        DWORD   cb;

                        cb = MAX_PATH;
                        StdName[0] = L'\0';
                        dwErr = RegQueryValueEx(KeyHandle2,
                                                TEXT("Std"),
                                                NULL,
                                                NULL,
                                                (PBYTE)StdName,
                                                &cb);

                        if (dwErr == ERROR_SUCCESS && 
                            (!wcscmp(StdName,TimeZoneInformation.StandardName) ||
                             !wcscmp(StdName,pszAlternateName)) ){

                             // got the right key.

                             break;
                        }
                    }

                    dwIndex ++;

                    cbName = MAX_PATH;

                    lRetValue = RegEnumKeyEx(
                                         KeyHandle,
                                         dwIndex,
                                         pszSubKeyName,
                                         &cbName,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL);

                } // while

                if ( lRetValue == ERROR_NO_MORE_ITEMS ) {
                   dwErr = ERROR_NO_MORE_ITEMS;
                }
            }

            if (dwErr == ERROR_SUCCESS) {

                BinlRegGetValue( KeyHandle2,
                                 L"Index",
                                 REG_DWORD,
                                 (LPBYTE *)&Index );
                TimezoneString = BinlAllocateMemory(24);  // enough for a big number
                if (TimezoneString != NULL) {
                    wsprintf(TimezoneString, L"%d", Index);
                }
            }

            if ( KeyHandle2 != NULL ) {
               RegCloseKey( KeyHandle2 );
               KeyHandle2 = NULL;
            }

            RegCloseKey(KeyHandle);
        }
    }

    EnterCriticalSection(&gcsParameters);
    if ( LanguageString != NULL ) {
        if ( BinlGlobalDefaultLanguage != NULL ) {
            BinlFreeMemory( BinlGlobalDefaultLanguage );
        }
        BinlGlobalDefaultLanguage = LanguageString;
    }
    if ( OrgnameString != NULL ) {
        if ( BinlGlobalDefaultOrgname != NULL ) {
            BinlFreeMemory( BinlGlobalDefaultOrgname );
        }
        BinlGlobalDefaultOrgname = OrgnameString;
    }
    if ( TimezoneString != NULL ) {
        if (BinlGlobalDefaultTimezone != NULL) {
            BinlFreeMemory( BinlGlobalDefaultTimezone );
        }
        BinlGlobalDefaultTimezone = TimezoneString;
    }
    LeaveCriticalSection(&gcsParameters);

    //
    // dwDSErr is the status code that we will return. We don't care whether
    // the registry reads work -- we assume that they always will. We do care
    // whether we were able to contact the DS.
    //
    //
    //  We do the DS query after we've read the parameters so that we setup
    //  the ldap timeouts, chase referrals, etc parameters correctly before
    //  we try to do the search.
    //

    dwDSErr = GetBinlServerParameters( FALSE );
    if ( dwDSErr != ERROR_SUCCESS ) {
        BinlPrint(( DEBUG_ERRORS, "!!Error 0x%08x - there was an error getting the settings from the DS.\n", dwDSErr ));
    }

    //
    // Return the status of the DS access.
    //

    return(dwDSErr);
}



DWORD
GetSCPName(
    PWSTR *ScpName
    )
{

    DWORD dwError;
    PWSTR psz;
    WCHAR MachineDN[ MAX_PATH ];
    
    WCHAR IntellimirrorSCP[ 64 ] = L"-Remote-Installation-Services";

    DWORD dwPathLength;

    //
    // Figure out the machine DN
    //
    wcscpy( MachineDN, BinlGlobalOurFQDNName );
    psz = MachineDN;
    while ( *psz && *psz != L',' )
        psz++;

    if ( *psz == L',' ) {
        *psz = TEXT('\0');  // terminate
        
    } else {
        wcscpy( MachineDN, L"UNKNOWN" );
    }

    //
    // Make space
    //
    dwPathLength = (wcslen( MachineDN ) +            // CN=SERVER
                    wcslen( IntellimirrorSCP ) +     // CN=SERVER-IntelliMirror-Service
                    1 +                                 // CN=SERVER-IntelliMirror-Service,
                    wcslen( BinlGlobalOurFQDNName ) +   // CN=SERVER-IntelliMirror-Service,CN=SERVE
                    1 )                                 // CN=SERVER-IntelliMirror-Service,CN=SERVE
                    * sizeof(WCHAR);

    *ScpName = (LPWSTR) BinlAllocateMemory( dwPathLength );
    if ( !*ScpName ) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // Create string
    //
    wsprintf( *ScpName, L"%s%s,%s", MachineDN, IntellimirrorSCP, BinlGlobalOurFQDNName );
    dwError = ERROR_SUCCESS;

exit:
    return(dwError);
}

    
DWORD
CreateSCPIfNeeded(
    PBOOL CreatedTheSCP
    )
/*++

Routine Description:

    Creates the SCP for BINL if necessary.
    
    It does this by checking the local registry for a flag (ScpCreated) which
    indicates whether the SCP needs to be created.  This flag may created by
    RISETUP or by BINL.  If the SCP needs to be created, then the registry is
    queried for the SCP data.  If the data isn't present, then we assume that
    RISETUP hasn't been run yet, and we do not try to create the SCP.  If SCP
    creation is successful, the "ScpCreated" registry flag is set.
    
    KB.  This is all done because the system context that BINL runs in should
    have permission to create the SCP underneath the MAO.  The user running
    RISETUP may not have sufficient permissions to be able to create the SCP.

Arguments:

    CreatedTheSCP - set to TRUE if we actually create the SCP.

Return Value:

    ERROR_SUCCESS indicates success.  A WIN32 error code if SCP creation fails.

--*/
{
    DWORD dwErr;
    HKEY KeyHandle;
    DWORD Created = 0;
    DWORD i;
    PWSTR ScpName;
    PWSTR ScpDataKeys[] = {
            BINL_SCP_NEWCLIENTS,
            BINL_SCP_LIMITCLIENTS,
            BINL_SCP_CURRENTCLIENTCOUNT,
            BINL_SCP_MAXCLIENTS,       
            BINL_SCP_ANSWER_REQUESTS,
            BINL_SCP_ANSWER_VALID,   
            BINL_SCP_NEWMACHINENAMEPOLICY,
            BINL_SCP_NEWMACHINEOU,        
            BINL_SCP_NETBOOTSERVER };

#define SCPDATACOUNT (sizeof(ScpDataKeys) / sizeof(PWSTR))
#define MACHINEOU_INDEX     7
#define NETBOOTSERVER_INDEX 8

    PWSTR ScpDataValues[SCPDATACOUNT];

    PLDAP LdapHandle = NULL;
    PLDAPMessage LdapMessage;
    PLDAPMessage CurrentEntry;
    LDAPMod mods[1+SCPDATACOUNT];
    PLDAPMod pmods[2+SCPDATACOUNT];
    LPWSTR attr_values[SCPDATACOUNT+1][2];    

    *CreatedTheSCP = FALSE;

    //
    // Try to get the ScpCreated flag
    //
    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                BINL_PARAMETERS_KEY,
                0,
                KEY_QUERY_VALUE | KEY_SET_VALUE,
                &KeyHandle );
    if ( dwErr != ERROR_SUCCESS ) {
        dwErr = ERROR_SUCCESS;
        BinlPrintDbg(( DEBUG_INIT, "SCP Created key not in registry, won't try to create SCP.\n" ));
        goto e0;
    }

    dwErr = BinlRegGetValue( 
                KeyHandle, 
                BINL_SCP_CREATED , 
                REG_DWORD, 
                (LPBYTE *)&Created );
    if (dwErr == ERROR_SUCCESS && Created != 0) {
        //
        // we think the SCP has already been created...we're done.
        //
        BinlPrintDbg(( DEBUG_INIT, "SCP Created flag set to 1, we won't try to create SCP.\n" ));
        dwErr = ERROR_SUCCESS;
        goto e1;
    }

    //
    // The SCP hasn't been created.  See if all of the required parameters for 
    // creating the SCP are in the registry.
    //
    RtlZeroMemory( ScpDataValues, sizeof(ScpDataValues) );
    for (i = 0; i < SCPDATACOUNT ; i++) {
        dwErr = BinlRegGetValue( 
                    KeyHandle, 
                    ScpDataKeys[i], 
                    REG_SZ, 
                    (LPBYTE *)&ScpDataValues[i] );

        if (dwErr != ERROR_SUCCESS) {
            //
            // one of the required parameters isn't present.  this means that
            // RISETUP wasn't run yet.
            //
            BinlPrintDbg(( 
                DEBUG_INIT, "Can't retrieve SCP value %s [ec = 0x%08x, we won't try to create SCP.\n",
                ScpDataKeys[i],
                dwErr ));
            dwErr = ERROR_SUCCESS;
            goto e2;
        }
    }

    //
    // great, we have all of the data.  Now do some touchup on the pieces that
    // may have changed
    //
    if (wcscmp(ScpDataValues[MACHINEOU_INDEX],BinlGlobalOurFQDNName)) {
        BinlFreeMemory( ScpDataValues[MACHINEOU_INDEX] );
        ScpDataValues[MACHINEOU_INDEX] = BinlAllocateMemory((wcslen(BinlGlobalOurFQDNName)+1)*sizeof(WCHAR));
        if (!ScpDataValues[MACHINEOU_INDEX]) {
            BinlPrintDbg(( DEBUG_INIT, "Can't allocate memory for SCP, we can't create SCP.\n" ));
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto e2;
        }
        wcscpy(ScpDataValues[MACHINEOU_INDEX],BinlGlobalOurFQDNName);
    }

    if (wcscmp(ScpDataValues[NETBOOTSERVER_INDEX],BinlGlobalOurFQDNName)) {
        BinlFreeMemory( ScpDataValues[NETBOOTSERVER_INDEX] );
        ScpDataValues[NETBOOTSERVER_INDEX] = BinlAllocateMemory((wcslen(BinlGlobalOurFQDNName)+1)*sizeof(WCHAR));
        if (!ScpDataValues[NETBOOTSERVER_INDEX]) {
            BinlPrintDbg(( DEBUG_INIT, "Can't allocate memory for SCP, we can't create SCP.\n" ));
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto e2;
        }
        wcscpy(ScpDataValues[NETBOOTSERVER_INDEX],BinlGlobalOurFQDNName);
    }

    //
    // generate the SCP name
    //
    dwErr = GetSCPName(&ScpName);
    if (dwErr != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_INIT, "Can't get the SCP name, ec=0x08x, we can't create SCP.\n",dwErr ));
        goto e2;
    }    

    //
    // create the SCP -- set the timeout to something reasonable since the timeout isn't initialized
    // from the registry yet at this point
    //
    BinlLdapSearchTimeout.tv_sec = BINL_LDAP_SEARCH_TIMEOUT_SECONDS;
    BinlLdapSearchTimeout.tv_usec = 0;
    dwErr = InitializeConnection( FALSE, &LdapHandle, NULL );
    if ( dwErr != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_INIT, "Can't InitializeConnection, ec=0x08x, we can't create SCP.\n",dwErr ));
        goto e2;
    }
    
    
    //
    // setup all of the attributes for the object.
    //
    mods[0].mod_op = LDAP_MOD_ADD;
    mods[0].mod_type = L"objectClass";
    mods[0].mod_values = attr_values[0];
    attr_values[0][0] = L"IntellimirrorSCP";
    attr_values[0][1] = NULL;
    pmods[0] = &mods[0];
    pmods[SCPDATACOUNT+1] = NULL;

    for( i = 0; i < SCPDATACOUNT ; i++ ) {
        mods[i+1].mod_op = LDAP_MOD_ADD;
        mods[i+1].mod_type = ScpDataKeys[i];
        mods[i+1].mod_values = attr_values[i+1];
        attr_values[i+1][0] = ScpDataValues[i];
        attr_values[i+1][1] = NULL;

        pmods[i+1] = &mods[i+1];
                
    }
    
    dwErr = ldap_add_s( LdapHandle, ScpName, pmods );
    if ( dwErr != LDAP_SUCCESS ) {
        
        if (dwErr == LDAP_ALREADY_EXISTS ) {
            //
            // if the SCP already exists, don't overwrite any data.  Set our flag in
            // the registry so we don't try to do this next time we start.
            //
            dwErr = ERROR_SUCCESS;
            goto SetSCPCreatedFlag;
           
        } else {
            BinlPrintDbg(( DEBUG_INIT, "ldap_add_s failed, ec=0x08x, we can't create SCP.\n",dwErr ));
            goto e3;
        }
    }

    *CreatedTheSCP = TRUE;


SetSCPCreatedFlag:
    //
    // we're done.  set the flag so we don't try to do this in the future.
    //
    Created = 1;
    RegSetValueEx( KeyHandle, BINL_SCP_CREATED, 0, REG_DWORD, (LPBYTE)&Created, sizeof(DWORD) );
    
e3:
    if ( dwErr != LDAP_SUCCESS ) {   
        //
        // just delete the object if this failed
        //
        ldap_delete( LdapHandle, ScpName );
    }
    
    ldap_unbind( LdapHandle );
    
e2:
    for (i = 0; i < SCPDATACOUNT ; i++) {
        if (ScpDataValues[i]) {
            BinlFreeMemory( ScpDataValues[i]);
        }
    }
e1:
    RegCloseKey(KeyHandle);
e0:
    return(dwErr);
}

DWORD
InitializeData(
    VOID
    )
{
    DWORD Length;
    DWORD dwErr;
    int i;
    DWORD ValueSize;

    //
    //  We can operate on all NICs with all IP addresses with a single socket.
    //  If we want control to limit BINL to particular NICs or IP addresses then
    //  we will need multiple sockets and use the bindings in the registry.
    //
    BinlGlobalNumberOfNets = 2;
    BinlGlobalEndpointList =
        BinlAllocateMemory( sizeof(ENDPOINT) * BinlGlobalNumberOfNets );

    if( BinlGlobalEndpointList == NULL ) {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }
    BinlGlobalEndpointList[0].Socket = 0;
    BinlGlobalEndpointList[1].Socket = 0;
    BinlGlobalIgnoreBroadcastFlag = FALSE;
    BinlGlobalLdapErrorCount = 0;

    InitializeCriticalSection(&g_ProcessMessageCritSect);

    InitializeListHead(&BinlGlobalActiveRecvList);
    InitializeListHead(&BinlGlobalFreeRecvList);
    InitializeCriticalSection(&BinlGlobalRecvListCritSect);
    g_cMaxProcessingThreads = BINL_MAX_PROCESSING_THREADS;
    g_cProcessMessageThreads = 0;

    InitializeListHead(&BinlCacheList);
    InitializeCriticalSection( &BinlCacheListLock );

    //
    // initialize (free) receive message queue.
    //

    for( i = 0; i < BINL_RECV_QUEUE_LENGTH; i++ )
    {
        PBINL_REQUEST_CONTEXT pRequestContext =
            BinlAllocateMemory( sizeof(BINL_REQUEST_CONTEXT) );

        if( !pRequestContext )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

        //
        // allocate memory for the receive buffer, plus one byte
        // so we can ensure there is a NULL after the message.
        //

        pRequestContext->ReceiveBuffer =
            BinlAllocateMemory( DHCP_RECV_MESSAGE_SIZE + 1 );

        if( !pRequestContext->ReceiveBuffer )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

        //
        // add this entry to free list.
        //

        LOCK_RECV_LIST();
        InsertTailList( &BinlGlobalFreeRecvList,
                        &pRequestContext->ListEntry );
        UNLOCK_RECV_LIST();
    }


    //
    // create an event to notifiy the message processing thread about the
    // arrival of a new message.
    //

    BinlGlobalRecvEvent = CreateEvent(
                                NULL,       // no security descriptor
                                FALSE,      // AUTOMATIC reset
                                FALSE,      // initial state: not signalled
                                NULL);      // no name

    if ( !BinlGlobalRecvEvent) {
        dwErr = GetLastError();
        goto Error;
    }

    BinlCloseCacheEvent = CreateEvent(
                                NULL,       // no security descriptor
                                TRUE,       // MANUAL reset
                                FALSE,      // initial state: not signalled
                                NULL);      // no name
    if ( !BinlCloseCacheEvent) {
        dwErr = GetLastError();
        goto Error;
    }

    //
    //  initialize our notify event handle to LSA for server name change operations
    //

    BinlGlobalLsaDnsNameNotifyEvent =
        CreateEvent(
            NULL,      // no security descriptor
            FALSE,     // auto reset
            FALSE,     // initial state: not signalled
            NULL);     // no name

    if ( BinlGlobalLsaDnsNameNotifyEvent == NULL ) {
        dwErr = GetLastError();
        BinlPrintDbg((DEBUG_INIT, "Can't create LSA notify event, "
                    "%ld.\n", dwErr));
        goto Error;
    }

    dwErr = LsaRegisterPolicyChangeNotification(    BINL_LSA_SERVER_NAME_POLICY,
                                                    BinlGlobalLsaDnsNameNotifyEvent
                                                    );
    if (dwErr == ERROR_SUCCESS) {

        BinlGlobalHaveOutstandingLsaNotify = TRUE;

    } else {

        //
        //  we won't fail for now as in 99.99% of the cases the machine name
        //  won't be changing therefore this is not critical.
        //

        BinlPrintDbg((DEBUG_INIT, "Can't start LSA notify, 0x%08x.\n", dwErr));
    }

    dwErr = GetOurServerInfo();
    if (dwErr != ERROR_SUCCESS) {
        goto Error;
    }

    dwErr = GetIpAddressInfo( 0 );

    if (dwErr != ERROR_SUCCESS) {
        goto Error;
    }

Cleanup:
    return(dwErr);

Error:
    BinlPrintDbg(( DEBUG_ERRORS, "!!Error 0x%08x - Could not initialize BINL service.\n", dwErr ));
    BinlServerEventLog(
        EVENT_SERVER_INIT_DATA_FAILED,
        EVENTLOG_ERROR_TYPE,
        dwErr );
    goto Cleanup;
}

DWORD
ReadDWord(
    HKEY KeyHandle,
    LPTSTR lpValueName,
    DWORD DefaultValue
    )
/*++

Routine Description:

    Read a DWORD value from the registry. If there is a problem then
    return the default value.

--*/
{
    DWORD Value;
    DWORD ValueSize = sizeof(Value);
    DWORD ValueType;

    if ((KeyHandle) &&
        (RegQueryValueEx(
                KeyHandle,
                lpValueName,
                0,
                &ValueType,
                (PUCHAR)&Value,
                &ValueSize ) == ERROR_SUCCESS )) {

        return Value;
    } else {
        return DefaultValue;
    }
}


DWORD
BinlRegGetValue(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    LPBYTE * BufferPtr
    )
/*++

Routine Description:

    This function retrieves the value of the specified value field. This
    function allocates memory for variable length field such as REG_SZ.
    For REG_DWORD data type, it copies the field value directly into
    BufferPtr. Currently it can handle only the following fields :

    REG_DWORD,
    REG_SZ,
    REG_BINARY

Arguments:

    KeyHandle : handle of the key whose value field is retrieved.

    ValueName : name of the value field.

    ValueType : Expected type of the value field.

    BufferPtr : Pointer to DWORD location where a DWORD datatype value
                is returned or a buffer pointer for REG_SZ or REG_BINARY
                datatype value is returned.

                If "ValueName" is not found, then "BufferPtr" will not be
                touched.

Return Value:

    Registry Errors.

--*/
{
    DWORD dwErr;
    DWORD LocalValueType;
    DWORD ValueSize;
    LPBYTE DataBuffer;
    LPBYTE AllotedBuffer = NULL;
    LPDHCP_BINARY_DATA BinaryData = NULL;

    //
    // Query DataType and BufferSize.
    //

    if ( !KeyHandle ) {
        dwErr = ERROR_INVALID_HANDLE;
        goto Error;
    }

    dwErr = RegQueryValueEx(
                KeyHandle,
                ValueName,
                0,
                &LocalValueType,
                NULL,
                &ValueSize );

    if ( dwErr != ERROR_SUCCESS ) {
        goto Error;
    }

    if ( LocalValueType != ValueType ) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Error;
    }

    switch( ValueType ) {
    case REG_DWORD:
        BinlAssert( ValueSize == sizeof(DWORD) );

        DataBuffer = (LPBYTE)BufferPtr;
        break;

    case REG_SZ:
    case REG_MULTI_SZ:
    case REG_EXPAND_SZ:
    case REG_BINARY:
        if( ValueSize == 0 ) {
            goto Cleanup; // no key
        }

        AllotedBuffer = DataBuffer = BinlAllocateMemory( ValueSize );

        if( DataBuffer == NULL ) {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

        break;

    default:
        BinlPrint(( DEBUG_REGISTRY, "Unexpected ValueType in"
                        "BinlRegGetValue function, %ld\n", ValueType ));
        dwErr= ERROR_INVALID_PARAMETER;
        goto Error;
    }

    //
    // retrieve data.
    //

    dwErr = RegQueryValueEx(
                KeyHandle,
                ValueName,
                0,
                &LocalValueType,
                DataBuffer,
                &ValueSize );

    if( dwErr != ERROR_SUCCESS ) {
        goto Error;
    }

    switch( ValueType ) {
    case REG_SZ:
    case REG_MULTI_SZ:
    case REG_EXPAND_SZ:
        BinlAssert( ValueSize != 0 );
        *BufferPtr = DataBuffer;
        break;

    case REG_BINARY:
        BinaryData = BinlAllocateMemory(sizeof(DHCP_BINARY_DATA));

        if( BinaryData == NULL ) {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

        BinaryData->DataLength = ValueSize;
        BinaryData->Data = DataBuffer;
        *BufferPtr = (LPBYTE)BinaryData;

    default:
        break;
    }

Cleanup:
    return(dwErr);

Error:
    if ( BinaryData )
        BinlFreeMemory( BinaryData );

    if ( AllotedBuffer )
        BinlFreeMemory( AllotedBuffer );

    goto Cleanup;
}


VOID
ServiceControlHandler(
    IN DWORD Opcode
    )
/*++

Routine Description:

    This is the service control handler of the binl service.

Arguments:

    Opcode - Supplies a value which specifies the action for the
        service to perform.

Return Value:

    None.

--*/
{
    DWORD Error;

    //
    //  Use critical section to stop DHCP telling us it is starting or stopping
    //  while we change state ourselves.
    //

    EnterCriticalSection(&gcsDHCPBINL);
    switch (Opcode) {

    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:

        BinlCurrentState = BINL_STOPPED;

        if (BinlGlobalServiceStatus.dwCurrentState != SERVICE_STOP_PENDING) {

            if( Opcode == SERVICE_CONTROL_SHUTDOWN ) {

                //
                // set this flag, so that service shut down will be
                // faster.
                //

                BinlGlobalSystemShuttingDown = TRUE;
            }

            BinlPrintDbg(( DEBUG_MISC, "Service is stop pending.\n"));

            BinlGlobalServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
            BinlGlobalServiceStatus.dwCheckPoint = 1;

            //
            // Send the status response.
            //

            UpdateStatus();

            if (! SetEvent(BinlGlobalProcessTerminationEvent)) {

                //
                // Problem with setting event to terminate binl
                // service.
                //

                BinlPrintDbg(( DEBUG_ERRORS, "BINL Server: Error "
                                "setting DoneEvent %lu\n",
                                    GetLastError()));

                BinlAssert(FALSE);
            }

            LeaveCriticalSection(&gcsDHCPBINL);

            return;
        }
        break;

    case SERVICE_CONTROL_PAUSE:

        BinlGlobalServiceStatus.dwCurrentState = SERVICE_PAUSED;
        BinlPrint(( DEBUG_MISC, "Service is paused.\n"));
        break;

    case SERVICE_CONTROL_CONTINUE:

        BinlCurrentState = BINL_STARTED;
        BinlGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;
        BinlPrint(( DEBUG_MISC, "Service is Continued.\n"));
        break;

    case SERVICE_CONTROL_INTERROGATE:
        BinlPrint(( DEBUG_MISC, "Service is interrogated.\n"));
        break;

    case BINL_SERVICE_REREAD_SETTINGS:   // custom message
        BinlPrint(( DEBUG_MISC, "Service received paramchange message.\n"));
        Error = BinlReadParameters( );
        //
        // Cause the service to poll frequently for a while and then return to
        // normal polling. If we managed to read the DS above, then we don't
        // need to succeed again, but if we failed above, then we want to keep
        // trying until we succeed at least once.
        //
        BinlHyperUpdateCount = BINL_HYPERMODE_RETRY_COUNT;
        BinlHyperUpdateSatisfied = (BOOL)(Error == ERROR_SUCCESS);
        break;

    default:
        BinlPrintDbg(( DEBUG_MISC, "Service received unknown control.\n"));
        break;
    }

    //
    // Send the status response.
    //

    UpdateStatus();

    LeaveCriticalSection(&gcsDHCPBINL);
}

DWORD
BinlInitializeEndpoint(
    PENDPOINT pEndpoint,
    PDHCP_IP_ADDRESS pIpAddress,
    DWORD Port
    )
/*++

Routine Description:

    This function initializes an endpoint by creating and binding a
    socket to the local address.

Arguments:

    pEndpoint - Receives a pointer to the newly created socket

    pIpAddress - The IP address to initialize to INADDR_ANY if NULL.

    Port - The port to bind to.

Return Value:

    The status of the operation.

--*/
{
    DWORD Error;
    SOCKET Sock;
    DWORD OptValue;

#define SOCKET_RECEIVE_BUFFER_SIZE      1024 * 64   // 64K max.

    struct sockaddr_in SocketName;

    pEndpoint->Port = Port;

    //
    // Create a socket
    //

    Sock = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );

    if ( Sock == INVALID_SOCKET ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    //
    // Make the socket share-able
    //

    OptValue = TRUE;
    Error = setsockopt(
                Sock,
                SOL_SOCKET,
                SO_REUSEADDR,
                (LPBYTE)&OptValue,
                sizeof(OptValue) );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    OptValue = TRUE;
    Error = setsockopt(
                Sock,
                SOL_SOCKET,
                SO_BROADCAST,
                (LPBYTE)&OptValue,
                sizeof(OptValue) );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    OptValue = SOCKET_RECEIVE_BUFFER_SIZE;
    Error = setsockopt(
                Sock,
                SOL_SOCKET,
                SO_RCVBUF,
                (LPBYTE)&OptValue,
                sizeof(OptValue) );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    SocketName.sin_family = PF_INET;
    SocketName.sin_port = htons( (unsigned short)Port );
    if (pIpAddress) {
        SocketName.sin_addr.s_addr = *pIpAddress;
    } else {
        SocketName.sin_addr.s_addr = INADDR_ANY;
    }
    RtlZeroMemory( SocketName.sin_zero, 8);

    //
    // Bind this socket to the server port
    //

    Error = bind(
               Sock,
               (struct sockaddr FAR *)&SocketName,
               sizeof( SocketName )
               );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    pEndpoint->Socket = Sock;

    //
    //  if this is 4011, then we setup for the pnp notification.
    //

    if ((Port == g_Port) &&
        (BinlGlobalPnpEvent != NULL) &&
        (BinlPnpSocket == INVALID_SOCKET)) {

        BinlPnpSocket = Sock;

        Error = BinlSetupPnpWait( );

        if (Error != 0) {
            BinlPrintDbg(( DEBUG_ERRORS, "BinlInitializeEndpoint could not set pnp event, %ld.\n", Error ));
        }
    }

    if (!pIpAddress) {

        PHOSTENT Host = gethostbyname(NULL);        // winsock2 allows us to do this.

        if (Host) {

            pEndpoint->IpAddress = *(PDHCP_IP_ADDRESS)Host->h_addr;

        } else {

            Error = WSAGetLastError();
            BinlPrintDbg(( DEBUG_ERRORS, "BinlInitializeEndpoint could not get ip addr, %ld.\n", Error ));

            pEndpoint->IpAddress = 0;
        }

    } else {

        pEndpoint->IpAddress = *pIpAddress;
    }

    Error = ERROR_SUCCESS;

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // if we aren't successful, close the socket if it is opened.
        //

        if( Sock != INVALID_SOCKET ) {
            closesocket( Sock );
        }

        BinlPrintDbg(( DEBUG_ERRORS,
            "BinlInitializeEndpoint failed, %ld.\n", Error ));
    }

    return( Error );
}

DWORD
WaitForDsStartup(
    VOID
    )
{
    const DWORD dwMaxWaitForDS = 5*60*1000;
    HANDLE hDsStartupCompletedEvent = NULL;
    DWORD i;
    DWORD err = ERROR_DS_UNAVAILABLE;
    DWORD waitStatus;
    DWORD waitTime = BinlGlobalServiceStatus.dwWaitHint;
    NT_PRODUCT_TYPE productType;

    //
    // Find out if we're on a DC. If we're not, there's no need to wait for
    // the DS.
    //
    // RtlGetNtProductType shouldn't fail. If it does, just assume we're
    // not on a DC.
    //

    if (!RtlGetNtProductType(&productType) || (productType != NtProductLanManNt)) {
        return NO_ERROR;
    }

    //
    // Wait up to five minutes for DS to finish startup, if it hasn't done so
    // already.
    //

    for (i = 0; i < dwMaxWaitForDS; i += waitTime) {

        if (hDsStartupCompletedEvent == NULL) {
            hDsStartupCompletedEvent = OpenEvent(SYNCHRONIZE,
                                                 FALSE,
                                                 DS_SYNCED_EVENT_NAME_W);
        }

        if (hDsStartupCompletedEvent == NULL) {

            //
            // DS hasn't even gotten around to creating this event.  This
            // probably means the DS isn't *going* to be started, but let's
            // not jump to conclusions.
            //

            BinlPrint((DEBUG_INIT, "DS startup has not begun; sleeping...\n"));
            Sleep(waitTime);

        } else {

            //
            // DS startup has begun.
            //

            waitStatus = WaitForSingleObject(hDsStartupCompletedEvent, waitTime);

            if (waitStatus == WAIT_OBJECT_0) {

                //
                // DS startup completed (or failed).
                //

                BinlPrint((DEBUG_INIT, "DS startup completed.\n"));
                err = NO_ERROR;
                break;

            } else if (WAIT_TIMEOUT == waitStatus) {

                //
                // DS startup still in progress.
                //

                BinlPrint((DEBUG_INIT, "DS is starting...\n"));

            } else {

                //
                // Wait failure. Ignore the error.
                //

                BinlPrint((DEBUG_INIT, "Failed to wait on DS event handle;"
                            " waitStatus = %d, GLE = %d.\n", waitStatus, GetLastError()));
            }
        }

        UpdateStatus();
    }

    if (hDsStartupCompletedEvent != NULL) {
        CloseHandle(hDsStartupCompletedEvent);
    }

    return err;
}

DWORD
Initialize(
    VOID
    )
/*++

Routine Description:

    This function initialize the binl service global data structures and
    starts up the service.

Arguments:

    None.

Return Value:

    The initialization status.

    0 - Success.
    Positive - A windows error occurred.
    Negative - A service specific error occured.

--*/
{
    DWORD threadId;
    DWORD Error;
    WSADATA wsaData;

    //
    // Initialize all the status fields so that subsequent calls to
    // SetServiceStatus need to only update fields that changed.
    //

    BinlGlobalServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    BinlGlobalServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    BinlGlobalServiceStatus.dwControlsAccepted = 0;
    BinlGlobalServiceStatus.dwCheckPoint = 1;
    BinlGlobalServiceStatus.dwWaitHint = 60000; // 60 secs.
    BinlGlobalServiceStatus.dwWin32ExitCode = ERROR_SUCCESS;
    BinlGlobalServiceStatus.dwServiceSpecificExitCode = 0;

    //
    // Initialize binl to receive service requests by registering the
    // control handler.
    //
#if DBG
    if (!BinlGlobalRunningAsProcess) {
#endif
    BinlGlobalServiceStatusHandle = RegisterServiceCtrlHandler(
                                      BINL_SERVER,
                                      ServiceControlHandler );

    if ( BinlGlobalServiceStatusHandle == 0 ) {
        Error = GetLastError();
        BinlPrintDbg((DEBUG_INIT, "RegisterServiceCtrlHandlerW failed, "
                    "%ld.\n", Error));

        BinlServerEventLog(
            EVENT_SERVER_FAILED_REGISTER_SC,
            EVENTLOG_ERROR_TYPE,
            Error );

        return(Error);
    }
#if DBG
    } // if (!BinlGlobalRunningAsProcess)
#endif

    //
    // Tell Service Controller that we are start pending.
    //

    UpdateStatus();

    //
    // Create the process termination event.
    //

    BinlGlobalProcessTerminationEvent =
        CreateEvent(
            NULL,      // no security descriptor
            TRUE,      // MANUAL reset
            FALSE,     // initial state: not signalled
            NULL);     // no name

    if ( BinlGlobalProcessTerminationEvent == NULL ) {
        Error = GetLastError();
        BinlPrintDbg((DEBUG_INIT, "Can't create ProcessTerminationEvent, "
                    "%ld.\n", Error));
        return(Error);
    }

    BinlGlobalPnpEvent =
        CreateEvent(
            NULL,      // no security descriptor
            FALSE,     // auto reset
            FALSE,     // initial state: not signalled
            NULL);     // no name

    if ( BinlGlobalPnpEvent == NULL ) {
        Error = GetLastError();
        BinlPrintDbg((DEBUG_INIT, "Can't create PNP event, "
                    "%ld.\n", Error));
        return(Error);
    }

    //
    // create the ProcessMessage termination event
    //

    g_hevtProcessMessageComplete = CreateEvent(
                                        NULL,
                                        FALSE,
                                        FALSE,
                                        NULL
                                        );

    if ( !g_hevtProcessMessageComplete )
    {
        Error = GetLastError();

        BinlPrintDbg( (DEBUG_INIT,
                    "Initialize(...) CreateEvent returned error %x\n",
                    Error )
                );

        return Error;
    }

    BinlPrint(( DEBUG_INIT, "Initializing .. \n", 0 ));

    //
    // Wait for the DS to start up.
    //

    Error = WaitForDsStartup();
    if ( Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_INIT, "Wait for DS failed, %ld.\n", Error ));

        BinlServerEventLog(
            EVENT_SERVER_DS_WAIT_FAILED,
            EVENTLOG_ERROR_TYPE,
            Error );

        return(Error);
    }

    Error = WSAStartup( WS_VERSION_REQUIRED, &wsaData);
    if ( Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_INIT, "WSAStartup failed, %ld.\n", Error ));

        BinlServerEventLog(
            EVENT_SERVER_INIT_WINSOCK_FAILED,
            EVENTLOG_ERROR_TYPE,
            Error );

        return(Error);
    }

    Error = InitializeData();
    if ( Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_INIT, "Data initialization failed, %ld.\n",
                        Error ));

        BinlServerEventLog(
            EVENT_SERVER_INIT_DATA_FAILED,
            EVENTLOG_ERROR_TYPE,
            Error );

        return(Error);
    }

    //
    // if the SCP hasn't been created yet, then try to create it now.  
    // We do this before trying the read the SCP from the DS
    // -- failure to read the SCP will mean that BINL won't startup properly
    //
    Error = CreateSCPIfNeeded(&BinlParametersRead);
    if (Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_INIT, "Create SCP failed, %ld.\n", Error ));

        BinlServerEventLog(
            ERROR_BINL_SCP_CREATION_FAILED,
            EVENTLOG_ERROR_TYPE,
            Error );

    }

    if (BinlParametersRead) {
        //
        // this means that we created the SCP.  When we try to read the SCP 
        // from the DS, it will probably fail the first time.
        //
        BinlPrint(( DEBUG_INIT, "BINLSVC created the SCP.\n" ));
    }

    BinlParametersRead = FALSE;

    Error = BinlReadParameters( );
    if ( Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_INIT, "Read parameters failed, %ld.\n",
                        Error ));

        //
        // Tell the scavenger to be hyper about reading parameters. Also, log
        // an event indicating that we're in hyper mode and not truly
        // initialized yet.
        //
        // In spite of this failure, we DO NOT fail to initialize BINLSVC.
        // We assume that we'll eventually be able to read our parameters.
        //

        BinlHyperUpdateCount = 1;
        BinlHyperUpdateSatisfied = FALSE;

        BinlServerEventLog(
            EVENT_SERVER_INIT_PARAMETERS_FAILED,
            EVENTLOG_WARNING_TYPE,
            Error );
    } else {
        BinlParametersRead = TRUE;
    }

    BinlPrintDbg(( DEBUG_INIT, "Data initialization succeeded.\n", 0 ));

    // Get the DHCP UDP socket
    Error = MaybeInitializeEndpoint( &BinlGlobalEndpointList[0],
                                NULL,
                                DHCP_SERVR_PORT);
    if ( Error != ERROR_SUCCESS ) {
        return WSAGetLastError();
    };

    if (g_Port) {
        // Get the BINL UDP socket
        Error = BinlInitializeEndpoint( &BinlGlobalEndpointList[1],
                                    NULL,
                                    g_Port);
        if ( Error != ERROR_SUCCESS ) {
            return WSAGetLastError();
        };
    }

    //
    // Initialize the OSChooser server.
    //

    Error = OscInitialize();
    if ( Error != ERROR_SUCCESS ) {
        BinlPrint(( DEBUG_INIT, "OSChooser initialization failed, %ld.\n",
                        Error ));
        return Error;
    };


    //
    // send heart beat to the service controller.
    //
    //

    BinlGlobalServiceStatus.dwCheckPoint++;
    UpdateStatus();

    //
    // Start a thread to queue the incoming BINL messages
    //

    BinlGlobalMessageHandle = CreateThread(
                          NULL,
                          0,
                          (LPTHREAD_START_ROUTINE)BinlMessageLoop,
                          NULL,
                          0,
                          &threadId );

    if ( BinlGlobalMessageHandle == NULL ) {
        Error =  GetLastError();
        BinlPrint((DEBUG_INIT, "Can't create Message Thread, %ld.\n", Error));
        return(Error);
    }

    //
    // Start a thread to process BINL messages
    //

    BinlGlobalProcessorHandle = CreateThread(
                          NULL,
                          0,
                          (LPTHREAD_START_ROUTINE)BinlProcessingLoop,
                          NULL,
                          0,
                          &threadId );

    if ( BinlGlobalProcessorHandle == NULL ) {
        Error =  GetLastError();
        BinlPrint((DEBUG_INIT, "Can't create ProcessThread, %ld.\n", Error));
        return(Error);
    }

    Error = NetInfStartHandler();

    if ( Error != ERROR_SUCCESS ) {

        BinlPrint((DEBUG_INIT, "Can't start INF Handler thread, %ld.\n", Error));
        return(Error);
    }

    BinlGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;
    BinlGlobalServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                                 SERVICE_ACCEPT_SHUTDOWN |
                                                 SERVICE_ACCEPT_PAUSE_CONTINUE;

    UpdateStatus();

    BinlCurrentState = BINL_STARTED;
#if defined(REGISTRY_ROGUE)
    //
    //  for now, temporarily set the rogue logic disabled.  it can be
    //  enabled in the registry
    //

    if (RogueDetection) {
#endif
        //
        //  initialize the rogue thread if DHCP server isn't running.
        //

        BinlRogueLoggedState = FALSE;

        Error = MaybeStartRogueThread();
        if ( Error != ERROR_SUCCESS ) {
            BinlPrint((DEBUG_INIT, "Can't start rogue logic, %ld.\n", Error));
            return(Error);
        }

#if defined(REGISTRY_ROGUE)
    } else {

        // pull this out when we pull out the registry setting

        BinlGlobalAuthorized = TRUE;
    }
#endif
    //
    // finally set the server startup time.
    //

    //GetSystemTime(&BinlGlobalServerStartTime);

    return ERROR_SUCCESS;
}

VOID
Shutdown(
    IN DWORD ErrorCode
    )
/*++

Routine Description:

    This function shuts down the binl service.

Arguments:

    ErrorCode - Supplies the error code of the failure

Return Value:

    None.

--*/
{
    DWORD   Error;

    BinlPrint((DEBUG_MISC, "Shutdown started ..\n" ));

    //
    // LOG an event if this is not a normal shutdown.
    //

    if( ErrorCode != ERROR_SUCCESS ) {

        BinlServerEventLog(
            EVENT_SERVER_SHUTDOWN,
            EVENTLOG_ERROR_TYPE,
            ErrorCode );
    }

    //
    // Service is shuting down, may be due to some service problem or
    // the administrator is stopping the service. Inform the service
    // controller.
    //

    BinlGlobalServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
    BinlGlobalServiceStatus.dwCheckPoint = 1;

    //
    // Send the status response.
    //

    UpdateStatus();

    if( BinlGlobalProcessTerminationEvent != NULL ) {

        //
        // set Termination Event so that other threads know about the
        // shut down.
        //

        SetEvent( BinlGlobalProcessTerminationEvent );

        //
        // Close all sockets, so that the BinlProcessingLoop
        // thread will come out of blocking Select() call.
        //
        // Close EndPoint sockets.
        //

        if( BinlGlobalEndpointList != NULL ) {
            DWORD i;

            for ( i = 0; i < BinlGlobalNumberOfNets ; i++ ) {
                MaybeCloseEndpoint(&BinlGlobalEndpointList[i]);
            }

            BinlFreeMemory( BinlGlobalEndpointList );
        }

        BinlPnpSocket = INVALID_SOCKET;

        //
        // Wait for the threads to terminate, don't wait forever.
        //

        if( BinlGlobalProcessorHandle != NULL ) {
            WaitForSingleObject(
                BinlGlobalProcessorHandle,
                THREAD_TERMINATION_TIMEOUT );
            CloseHandle( BinlGlobalProcessorHandle );
            BinlGlobalProcessorHandle = NULL;
        }

        //
        // wait for the receive thread to complete.
        //

        if( BinlGlobalMessageHandle != NULL ) {
            WaitForSingleObject(
                BinlGlobalMessageHandle,
                THREAD_TERMINATION_TIMEOUT );
            CloseHandle( BinlGlobalMessageHandle );
            BinlGlobalMessageHandle = NULL;
        }

        while ( !IsListEmpty( &BinlGlobalFreeRecvList ) )
        {
            BINL_REQUEST_CONTEXT *pRequestContext;
            pRequestContext =
                (BINL_REQUEST_CONTEXT *)
                    RemoveHeadList( &BinlGlobalFreeRecvList );

            BinlFreeMemory( pRequestContext->ReceiveBuffer );
            BinlFreeMemory( pRequestContext );
        }

        while ( !IsListEmpty( &BinlGlobalActiveRecvList ) )
        {
            BINL_REQUEST_CONTEXT *pRequestContext;
            pRequestContext =
                (BINL_REQUEST_CONTEXT *)
                    RemoveHeadList( &BinlGlobalActiveRecvList );

            BinlFreeMemory( pRequestContext->ReceiveBuffer );
            BinlFreeMemory( pRequestContext );
        }

        if ( BinlIsProcessMessageExecuting() )
        {
            //
            // wait for the thread pool to shutdown
            //

            Error = WaitForSingleObject(
                g_hevtProcessMessageComplete,
                THREAD_TERMINATION_TIMEOUT
                );

            BinlAssert( WAIT_OBJECT_0 == Error );
        }

        //
        //  We free the ldap connections after all the threads are done because
        //  the connection BaseDN strings may be in use by the threads and
        //  we're about to free them in FreeConnections.
        //

        FreeConnections();

        CloseHandle( g_hevtProcessMessageComplete );
        g_hevtProcessMessageComplete = NULL;

    }

    BinlPrintDbg((DEBUG_MISC, "Client requests cleaned up.\n" ));

    //
    // send heart beat to the service controller.
    //
    //

    BinlGlobalServiceStatus.dwCheckPoint++;
    UpdateStatus();

    //
    // send heart beat to the service controller and
    // reset wait time.
    //

    BinlGlobalServiceStatus.dwWaitHint = 60 * 1000; // 1 mins.
    BinlGlobalServiceStatus.dwCheckPoint++;
    UpdateStatus();

    FreeIpAddressInfo();

    //
    // cleanup other data.
    //

    StopRogueThread( );

    OscUninitialize();

    WSACleanup();

    DeleteCriticalSection( &BinlCacheListLock );

    NetInfCloseHandler();

    if ( BinlGlobalSCPPath ) {
        BinlFreeMemory( BinlGlobalSCPPath );
        BinlGlobalSCPPath = NULL;
    }

    if ( BinlGlobalServerDN ) {
        BinlFreeMemory( BinlGlobalServerDN );
        BinlGlobalServerDN = NULL;
    }

    if ( BinlGlobalGroupDN ) {
        BinlFreeMemory( BinlGlobalGroupDN );
        BinlGlobalGroupDN = NULL;
    }

    if ( BinlGlobalDefaultLanguage ) {
        BinlFreeMemory( BinlGlobalDefaultLanguage );
        BinlGlobalDefaultLanguage = NULL;
    }

    EnterCriticalSection( &gcsParameters );

    if ( BinlGlobalDefaultContainer ) {
        BinlFreeMemory( BinlGlobalDefaultContainer );
        BinlGlobalDefaultContainer = NULL;
    }

    if ( NewMachineNamingPolicy != NULL ) {
        BinlFreeMemory( NewMachineNamingPolicy );
        NewMachineNamingPolicy = NULL;
    }

    if ( BinlGlobalOurDnsName ) {
        BinlFreeMemory( BinlGlobalOurDnsName );
        BinlGlobalOurDnsName = NULL;
    }

    if ( BinlGlobalOurDomainName ) {
        BinlFreeMemory( BinlGlobalOurDomainName );
        BinlGlobalOurDomainName = NULL;
    }

    if ( BinlGlobalOurServerName ) {
        BinlFreeMemory( BinlGlobalOurServerName );
        BinlGlobalOurServerName = NULL;
    }

    if ( BinlGlobalOurFQDNName ) {
        BinlFreeMemory( BinlGlobalOurFQDNName );
        BinlGlobalOurFQDNName = NULL;
    }

    LeaveCriticalSection( &gcsParameters );

    if (BinlGlobalHaveOutstandingLsaNotify) {
        Error = LsaUnregisterPolicyChangeNotification(
                                BINL_LSA_SERVER_NAME_POLICY,
                                BinlGlobalLsaDnsNameNotifyEvent
                                );

        if (Error != ERROR_SUCCESS) {

            BinlPrintDbg((DEBUG_INIT, "Can't close LSA notify, 0x%08x.\n", Error));
        }
        BinlGlobalHaveOutstandingLsaNotify = FALSE;
    }

    if (BinlGlobalLsaDnsNameNotifyEvent != NULL) {
        CloseHandle( BinlGlobalLsaDnsNameNotifyEvent );
        BinlGlobalLsaDnsNameNotifyEvent = NULL;
    }

    if ( BinlGlobalDefaultOrgname ) {
        BinlFreeMemory( BinlGlobalDefaultOrgname );
        BinlGlobalDefaultOrgname = NULL;
    }

    if ( BinlGlobalDefaultTimezone ) {
        BinlFreeMemory( BinlGlobalDefaultTimezone );
        BinlGlobalDefaultTimezone = NULL;
    }

    if ( BinlGlobalDefaultDS ) {
        BinlFreeMemory( BinlGlobalDefaultDS );
        BinlGlobalDefaultDS = NULL;
    }

    if ( BinlGlobalDefaultGC ) {
        BinlFreeMemory( BinlGlobalDefaultGC );
        BinlGlobalDefaultGC = NULL;
    }

    BinlPrint((DEBUG_MISC, "Shutdown Completed.\n" ));

    //
    // don't DebugUninitialize here -- we dump memory leaks
    // during process detach which requires debug support.
    //
    //DebugUninitialize( );

    //
    // don't use BinlPrint past this point
    //

    BinlGlobalServiceStatus.dwCurrentState = SERVICE_STOPPED;
    BinlGlobalServiceStatus.dwControlsAccepted = 0;
    if ( ErrorCode >= 20000 && ErrorCode <= 20099 ) {
        // Indicate that it is a BINL specific error code
        BinlGlobalServiceStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
        BinlGlobalServiceStatus.dwServiceSpecificExitCode = ErrorCode;
    } else {
        BinlGlobalServiceStatus.dwWin32ExitCode = ErrorCode;
        BinlGlobalServiceStatus.dwServiceSpecificExitCode = 0;
    }

    BinlGlobalServiceStatus.dwCheckPoint = 0;
    BinlGlobalServiceStatus.dwWaitHint = 0;

    UpdateStatus();
}

VOID
ServiceEntry(
    DWORD NumArgs,
    LPWSTR *ArgsArray,
    IN PTCPSVCS_GLOBAL_DATA pGlobalData
    )
/*++

Routine Description:

    This is the main routine of the BINL server service.  After
    the service has been initialized, this thread will wait on
    BinlGlobalProcessTerminationEvent for a signal to terminate the service.

Arguments:

    NumArgs - Supplies the number of strings specified in ArgsArray.

    ArgsArray -  Supplies string arguments that are specified in the
        StartService API call.  This parameter is ignored.

Return Value:

    None.

--*/
{
    DWORD Error;

#if !DBG
    UNREFERENCED_PARAMETER(NumArgs);
    UNREFERENCED_PARAMETER(ArgsArray);
#endif

    DebugInitialize( );

#if DBG
    //
    //  If we are running as a test process instead of as a service then
    //  recored it now so that we avoid calling into the service controller
    //  and failing.
    //

    if ((NumArgs == 2) &&
        (ArgsArray == NULL)) {
        BinlGlobalRunningAsProcess = TRUE;
    } else {
        BinlGlobalRunningAsProcess = FALSE;
    }
#endif

    //
    // copy the process global data pointer to service global variable.
    //

    TcpsvcsGlobalData = pGlobalData;

    Error = Initialize();

    if ( Error == ERROR_SUCCESS) {

        //
        // If we were able to read our parameters from the DS, log an event
        // indicating that we're ready to roll. If not, hold off on logging the
        // event -- the scavenger will do it when it manages to get to the DS.
        //

        if ( BinlParametersRead ) {
            BinlServerEventLog(
                EVENT_SERVER_INIT_AND_READY,
                EVENTLOG_INFORMATION_TYPE,
                Error );
        }

        //
        // perform Scavenge task until we are told to stop.
        //

        Error = Scavenger();
    }

    Shutdown( Error );
    return;
}

VOID
BinlMessageLoop(
    LPVOID Parameter
    )
/*++

Routine Description:

    This function is the message queuing thread.  It loops
    to receive messages that are arriving to all opened sockets and
    queue them in the message queue. The queue length is fixed, so if the
    queue becomes full, it deletes the oldest message from the queue to
    add the new one.

    The message processing thread pops out messages (last one first) and
    process them. New messages are processed first because the
    corresponding clients will least likely time-out, and hence the
    throughput will be better. Also the processing thread throws
    messages that are already timed out, this will stop server starving
    problem.

Arguments:

    Parameter - pointer to the parameter passed.

Return Value:

    None.

--*/
{
    DWORD                 Error,
                          SendResponse,
                          Signal;

    BINL_REQUEST_CONTEXT *pRequestContext;

    while ( 1 ) {

        //
        // dequeue an entry from the free list.
        //

        LOCK_RECV_LIST();
        if( !IsListEmpty( &BinlGlobalFreeRecvList ) ) {

            pRequestContext =
                (BINL_REQUEST_CONTEXT *)
                    RemoveHeadList( &BinlGlobalFreeRecvList );
        }
        else {

            //
            // active message queue should be non-empty.
            //

            BinlAssert( IsListEmpty( &BinlGlobalActiveRecvList ) == FALSE );

            BinlPrintDbg(( DEBUG_MISC, "A Message has been overwritten.\n"));

            //
            // dequeue an old entry from the queue.
            //

            pRequestContext =
                (BINL_REQUEST_CONTEXT *)
                    RemoveHeadList( &BinlGlobalActiveRecvList );
        }
        UNLOCK_RECV_LIST();

        //
        // wait for message to arrive from of the open socket port.
        //

MessageWait:

        Error = BinlWaitForMessage( pRequestContext );

        if( Error != ERROR_SUCCESS ) {

            if( Error == ERROR_SEM_TIMEOUT ) {

                //
                // if we are asked to exit, do so.
                //

                Error = WaitForSingleObject( BinlGlobalProcessTerminationEvent, 0 );

                if ( Error == ERROR_SUCCESS ) {

                    //
                    // The termination event has been signalled
                    //

                    //
                    // delete pRequestContext before exiting
                    //

                    ExitThread( 0 );
                }

                BinlAssert( Error == WAIT_TIMEOUT );
                goto MessageWait;
            }
            else {

                BinlPrintDbg(( DEBUG_ERRORS,
                    "BinlWaitForMessage failed, error = %ld\n", Error ));

                goto MessageWait;
            }
        }

        //
        // time stamp the received message.
        //

        pRequestContext->TimeArrived = GetTickCount();

        //
        // queue the message in active queue.
        //

        LOCK_RECV_LIST();

        //
        // before adding this message, check the active list is empty, if
        // so, signal the processing thread after adding this new message.
        //

        Signal = IsListEmpty( &BinlGlobalActiveRecvList );
        InsertTailList( &BinlGlobalActiveRecvList, &pRequestContext->ListEntry );

        if( Signal == TRUE ) {

            if( !SetEvent( BinlGlobalRecvEvent) ) {

                //
                // Problem with setting the event to indicate the message
                // processing queue the arrival of a new message.
                //

                BinlPrintDbg(( DEBUG_ERRORS,
                    "Error setting BinlGlobalRecvEvent %ld\n",
                                    GetLastError()));

                BinlAssert(FALSE);
            }
        }
        UNLOCK_RECV_LIST();
    }

    //
    // Abnormal thread termination.
    //
    ExitThread( 1 );
}

DWORD
BinlStartWorkerThread(
    BINL_REQUEST_CONTEXT **ppContext
    )
{
    BYTE  *pbSendBuffer    = NULL,
          *pbReceiveBuffer = NULL;

    DWORD  dwResult;

    BINL_REQUEST_CONTEXT *pNewContext,
                         *pTempContext;

    DWORD   dwID;
    HANDLE  hThread;

    pNewContext = BinlAllocateMemory( sizeof( *pNewContext ) );

    if ( !pNewContext )
    {
        goto t_cleanup;
    }

    pbSendBuffer = BinlAllocateMemory( DHCP_SEND_MESSAGE_SIZE );

    if ( !pbSendBuffer )
    {
        goto t_cleanup;
    }

    pbReceiveBuffer = BinlAllocateMemory( DHCP_RECV_MESSAGE_SIZE + 1 );

    if ( !pbReceiveBuffer )
    {
        goto t_cleanup;
    }

    //
    // Pass the input context to the worker thread and return the new
    // context to the caller.  This saves a memory copy.
    //

    SWAP( *ppContext, pNewContext );

    (*ppContext)->ReceiveBuffer = pbReceiveBuffer;
    pNewContext->SendBuffer   = pbSendBuffer;

    EnterCriticalSection( &g_ProcessMessageCritSect );

    ++g_cProcessMessageThreads;

    BinlAssert( g_cProcessMessageThreads <= g_cMaxProcessingThreads );

    hThread = CreateThread(
                     NULL,
                     0,
                     (LPTHREAD_START_ROUTINE) ProcessMessage,
                     pNewContext,
                     0,
                     &dwID
                     );

    if ( hThread )
    {
        //
        // success
        //

        CloseHandle( hThread );
        LeaveCriticalSection( &g_ProcessMessageCritSect );
        return ERROR_SUCCESS;
    }

    --g_cProcessMessageThreads;
    LeaveCriticalSection( &g_ProcessMessageCritSect );

    //
    // CreateThread failed. Swap restores the context pointers.
    //

    SWAP( *ppContext, pNewContext );

    BinlPrintDbg( (DEBUG_ERRORS,
                "BinlStartWorkerThread: CreateThread failed: %d\n" )
             );


t_cleanup:

    if ( pbReceiveBuffer )
    {
        BinlFreeMemory( pbReceiveBuffer );
    }

    if ( pbSendBuffer )
    {
        BinlFreeMemory( pbSendBuffer );
    }

    if ( pNewContext )
    {
        BinlFreeMemory( pNewContext );
    }

    BinlPrintDbg( ( DEBUG_ERRORS,
                "BinlStartWorkerThread failed.\n"
                ) );

    return ERROR_NOT_ENOUGH_MEMORY;
}

#define PROCESS_TERMINATE_EVENT     0
#define PROCESS_MESSAGE_RECVD       1
#define PROCESS_EVENT_COUNT         2

VOID
BinlProcessingLoop(
    VOID
    )
/*++

Routine Description:

    This function is the starting point for the main processing thread.
    It loops to process queued messages, and sends replies.

Arguments:

    RequestContext - A pointer to the request context block for
        for this thread to use.

Return Value:

    None.

--*/
{
    DWORD                 Error,
                          Result;

    HANDLE                WaitHandle[PROCESS_EVENT_COUNT];

    BINL_REQUEST_CONTEXT *pRequestContext;

    WaitHandle[PROCESS_MESSAGE_RECVD]   = BinlGlobalRecvEvent;
    WaitHandle[PROCESS_TERMINATE_EVENT] = BinlGlobalProcessTerminationEvent;

    while ( 1 ) {

        //
        // wait for one of the following event to occur :
        //  1. if we are notified about the incoming message.
        //  2. if we are asked to terminate
        //

        Result = WaitForMultipleObjects(
                    PROCESS_EVENT_COUNT,    // num. of handles.
                    WaitHandle,             // handle array.
                    FALSE,                  // wait for any.
                    INFINITE );              // timeout in msecs.

        if (Result == PROCESS_TERMINATE_EVENT) {

            //
            // The termination event has been signalled
            //

            break;
        }

        if ( Result != PROCESS_MESSAGE_RECVD) {

            BinlPrintDbg(( DEBUG_ERRORS,
                "WaitForMultipleObjects returned invalid result, %ld.\n",
                    Result ));

            //
            // go back to wait.
            //

            continue;
        }

        //
        // process all queued messages.
        //

        while(  TRUE )
        {
            if ( BinlIsProcessMessageBusy() )
            {
                //
                // All worker threads are active, so  break to the outer loop.
                // When a worker thread is finished it will set the
                // PROCESS_MESSAGE_RECVD event.

                BinlPrintDbg( (DEBUG_STOC,
                            "BinlProcessingLoop: All worker threads busy.\n" )
                         );

                break;
            }

            LOCK_RECV_LIST();

            if( IsListEmpty( &BinlGlobalActiveRecvList ) ) {

                //
                // no more message.
                //

                UNLOCK_RECV_LIST();
                break;
            }

            //
            // pop out a message from the active list ( *last one first* ).
            //

            pRequestContext =
                (BINL_REQUEST_CONTEXT *) RemoveHeadList(&BinlGlobalActiveRecvList );
            UNLOCK_RECV_LIST();

            //
            // if the message is too old, or if the maximum number of worker threads
            // are running, discard the message.
            //

            if( GetTickCount() - pRequestContext->TimeArrived <
                    WAIT_FOR_RESPONSE_TIME * 1000 )
            {
                Error = BinlStartWorkerThread( &pRequestContext );

                if ( ERROR_SUCCESS != Error )
                {
                    BinlPrintDbg( (DEBUG_ERRORS,
                                "BinlProcessingLoop: BinlStartWorkerThread failed: %d\n",
                                Error )
                             );
                }

            } // if ( ( GetTickCount() < pRequestContext->TimeArrived...
            else
            {
                BinlPrintDbg(( DEBUG_ERRORS, "A message has been timed out.\n" ));
            }

            //
            // return this context to the free list
            //

            LOCK_RECV_LIST();

            InsertTailList(
                &BinlGlobalFreeRecvList,
                &pRequestContext->ListEntry );

            UNLOCK_RECV_LIST();

         } // while (TRUE)
    } // while( 1 )

    //
    // Abnormal thread termination.
    //
    ExitThread( 1 );
}

BOOL
BinlIsProcessMessageExecuting(
    VOID
    )
{
    BOOL f;

    EnterCriticalSection( &g_ProcessMessageCritSect );
    f = g_cProcessMessageThreads;
    LeaveCriticalSection( &g_ProcessMessageCritSect );

    return f;
}

BOOL
BinlIsProcessMessageBusy(
    VOID
    )
{

    BOOL f;

    EnterCriticalSection( &g_ProcessMessageCritSect );
    f = ( g_cProcessMessageThreads == g_cMaxProcessingThreads );
    LeaveCriticalSection( &g_ProcessMessageCritSect );

    return f;
}

#undef PROCESS_TERMINATE_EVENT
#undef PROCESS_EVENT_COUNT

#define PROCESS_TERMINATE_EVENT     0
#define PROCESS_PNP_EVENT           1
#define PROCESS_LSA_EVENT           2
#define PROCESS_EVENT_COUNT         3

DWORD
Scavenger(
    VOID
    )
/*++

Routine Description:

    This function runs as an independant thread.  It periodically wakes
    up. Currently we have no work for it to do but I'm sure we will in the future.

Arguments:

    None.

Return Value:

    None.

--*/
{
    BOOL fLeftCriticalSection = FALSE;
    DWORD TimeOfLastScavenge = GetTickCount();
    DWORD TimeOfLastDSScavenge = GetTickCount();
    DWORD TimeOfLastParameterCheck = 0;
    DWORD                 Error,
                          Result;
    HANDLE                WaitHandle[PROCESS_EVENT_COUNT];
    DWORD secondsSinceLastScavenge;

    WaitHandle[PROCESS_TERMINATE_EVENT] = BinlGlobalProcessTerminationEvent;
    WaitHandle[PROCESS_PNP_EVENT] = BinlGlobalPnpEvent;
    WaitHandle[PROCESS_LSA_EVENT] = BinlGlobalLsaDnsNameNotifyEvent;

    while ((!BinlGlobalSystemShuttingDown) &&
    (BinlGlobalServiceStatus.dwCurrentState != SERVICE_STOP_PENDING))
    {
        DWORD CurrentTime;
        PLIST_ENTRY p;

        //
        // wait for one of the following event to occur :
        //  1. if we are notified about a pnp change.
        //  2. if we are asked to terminate
        //

        Result = WaitForMultipleObjects(
                    PROCESS_EVENT_COUNT,    // num. of handles.
                    WaitHandle,             // handle array.
                    FALSE,                  // wait for any.
                    BINL_HYPERMODE_TIMEOUT );  // timeout in msecs.

        if (Result == PROCESS_TERMINATE_EVENT) {

            //
            // The termination event has been signalled
            //

            break;

        } else if (Result == PROCESS_PNP_EVENT) {

            //
            // The pnp notify event has been signalled
            //

            GetIpAddressInfo( BINL_PNP_DELAY_SECONDS * 1000 );

            Error = BinlSetupPnpWait( );

            if (Error != 0) {
                BinlPrintDbg(( DEBUG_ERRORS, "BinlScavenger could not set pnp event, %ld.\n", Error ));
            }
        } else if (Result == PROCESS_LSA_EVENT) {

            Error = GetOurServerInfo( );
            if (Error != ERROR_SUCCESS) {
                BinlPrintDbg(( DEBUG_ERRORS, "BinlScavenger could not get server name info, 0x%08x.\n", Error ));
            }
        }

        //
        // Capture the current time (in milliseconds).
        //

        CurrentTime = GetTickCount( );

        secondsSinceLastScavenge = CurrentTime - TimeOfLastScavenge;

        //
        // If we haven't scavenged recently, do so now.
        //

        if ( secondsSinceLastScavenge >= BinlGlobalScavengerSleep ) {
            HANDLE hFind;
            WCHAR SifFilePath[MAX_PATH];
            WIN32_FIND_DATA FindData;
            ULARGE_INTEGER CurrentTimeConv,FileTime;
            FILETIME CurrentFileTime;
            PWSTR ptr;

            TimeOfLastScavenge = CurrentTime;
            BinlPrintDbg((DEBUG_SCAVENGER, "Scavenging Clients...\n"));

            fLeftCriticalSection = FALSE;
            EnterCriticalSection(&ClientsCriticalSection);

            for (p = ClientsQueue.Flink; p != &ClientsQueue; p = p->Flink)
            {
                PCLIENT_STATE TempClient;

                TempClient = CONTAINING_RECORD(p, CLIENT_STATE, Linkage);

                if ( CurrentTime - TempClient->LastUpdate > BinlClientTimeout * 1000 )
                {
                    BOOL FreeClientState;

                    BinlPrintDbg((DEBUG_SCAVENGER, "Savenger deleting client = 0x%08x\n", TempClient ));

                    RemoveEntryList(&TempClient->Linkage);
                    TempClient->PositiveRefCount++; // one for CS

                    LeaveCriticalSection(&ClientsCriticalSection);
                    fLeftCriticalSection = TRUE;

                    EnterCriticalSection(&TempClient->CriticalSection);

                    TempClient->NegativeRefCount += 2;  // one for CS and one of Logoff

                    //
                    // FreeClientState will be TRUE if the two refcounts are equal.
                    // Otherwize another thread is being held by the clientState's CS
                    // and it will take care of deleting the CS when it's done.
                    //
                    FreeClientState = (BOOL)(TempClient->PositiveRefCount == TempClient->NegativeRefCount);

                    LeaveCriticalSection(&TempClient->CriticalSection);

                    if (FreeClientState)
                    {
                        FreeClient(TempClient);
                    }

                    break;
                }
            }

            if ( !fLeftCriticalSection ) {
                LeaveCriticalSection(&ClientsCriticalSection);
            }

            BinlPrintDbg((DEBUG_SCAVENGER, "Scavenging Clients Complete\n"));
        

            //
            // scavenge the SIF files
            //
            BinlPrintDbg((DEBUG_SCAVENGER, "Scavenging SIF Files...\n"));
            GetSystemTimeAsFileTime( &CurrentFileTime );
            CurrentTimeConv.LowPart = CurrentFileTime.dwLowDateTime;
            CurrentTimeConv.HighPart = CurrentFileTime.dwHighDateTime;
            if ( _snwprintf( SifFilePath,
                             sizeof(SifFilePath) / sizeof(SifFilePath[0]),
                             L"%ws\\%ws\\",
                             IntelliMirrorPathW,
                             TEMP_DIRECTORY ) >= 0 ) {
                SifFilePath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe
                ptr = SifFilePath + wcslen(SifFilePath);
                wcscat(SifFilePath,L"*.sif");
                hFind = FindFirstFile(SifFilePath,&FindData);
                if (hFind != INVALID_HANDLE_VALUE) {
                    do {
                        FileTime.LowPart = FindData.ftCreationTime.dwLowDateTime;
                        FileTime.HighPart = FindData.ftCreationTime.dwHighDateTime;

                        FileTime.QuadPart += BinlSifFileScavengerTime.QuadPart;
                        
                        //
                        // if the file has been on the server long enough,
                        // we delete it
                        //
                        if (_wcsicmp(FindData.cFileName,L".") != 0 &&
                            _wcsicmp(FindData.cFileName,L"..") != 0 &&
                            CurrentTimeConv.QuadPart > FileTime.QuadPart) {
                            *ptr = L'\0';
                            wcscat(SifFilePath,FindData.cFileName);

                            BinlPrintDbg((DEBUG_SCAVENGER, 
                                          "Attempting to scavenge SIF File %S...\n", 
                                          SifFilePath));
                            SetFileAttributes(SifFilePath,FILE_ATTRIBUTE_NORMAL);
                            if (!DeleteFile(SifFilePath)) {
                                BinlPrintDbg((DEBUG_SCAVENGER,
                                              "Failed to scavenge SIF File %S, ec = %d\n",
                                              SifFilePath,
                                              GetLastError() ));
                            }
                        }

                    } while ( FindNextFile(hFind,&FindData) );

                    FindClose( hFind );
                }

            }

            BinlPrintDbg((DEBUG_SCAVENGER, "Scavenging SIF Files Complete\n"));
        }

        secondsSinceLastScavenge = CurrentTime - TimeOfLastDSScavenge;

        if ( secondsSinceLastScavenge >= BinlGlobalLdapErrorScavenger) {

            TimeOfLastDSScavenge = CurrentTime;

            if (BinlGlobalLdapErrorCount >= BinlGlobalMaxLdapErrorsLogged) {

                ULONG seconds = BinlGlobalLdapErrorScavenger / 1000;
                PWCHAR strings[2];
                WCHAR secondsString[10];

                swprintf(secondsString, L"%d", seconds);

                strings[0] = secondsString;
                strings[1] = NULL;

                BinlReportEventW( EVENT_WARNING_LDAP_ERRORS,
                                  EVENTLOG_WARNING_TYPE,
                                  1,
                                  sizeof(BinlGlobalLdapErrorCount),
                                  strings,
                                  &BinlGlobalLdapErrorCount
                                  );
            }
            BinlGlobalLdapErrorCount = 0;
        }

        //
        // If we haven't read our parameters recently, do so now.
        //
        // "Recently" is normally a long time period -- defaulting to four hours.
        // But when we are in "hyper" mode, we read our parameters every minute.
        // There are two reasons to be in "hyper" mode:
        //
        // 1. We were not able to read our parameters during initialization. We
        //    need to get the parameters quickly so that we can truly consider
        //    ourselves initialized. In this case, BinlHyperUpdateCount will
        //    always be 1.
        //
        // 2. We were told by the admin UI that our parameters had changed. We
        //    need to read the parameters a number of times over a period of
        //    time because of DS propagation delays. In this case,
        //    BinlHyperUpdateCount starts at BINL_HYPERMODE_RETRY_COUNT (30),
        //    and is decremented each time we attempt to read our parameters.
        //
        // If we are not in hyper mode, then we try to read our parameters and
        // we don't care if we fail. If we are in hyper mode, then we decrement
        // BinlHyperUpdateCount each time we try to read our parameters, and we
        // stay in hyper mode until BinlHyperUpdateCount is decremented to 0.
        // But we don't let the count go to 0 until we have successfully read
        // our parameters at least once while in hyper mode.

        if ( (CurrentTime - TimeOfLastParameterCheck) >=
             ((BinlHyperUpdateCount != 0) ? BINL_HYPERMODE_TIMEOUT : BinlUpdateFromDSTimeout) ) {

            TimeOfLastParameterCheck = CurrentTime;
            BinlPrintDbg((DEBUG_SCAVENGER, "Reading parameters...\n"));

            Error = BinlReadParameters( );

            //
            // If we're not in hyper mode, we don't care if reading the
            // parameters failed. But if we're in hyper mode, we have
            // to do some extra work.
            //

            if ( BinlHyperUpdateCount != 0 ) {

                //
                // If the read worked, then we set BinlHyperUpdateSatisfied.
                // Also, if this is the first time we've managed to read
                // our parameters, we log an event indicating that we're
                // ready.
                //

                if ( Error == ERROR_SUCCESS ) {
                    BinlHyperUpdateSatisfied = TRUE;
                    if ( !BinlParametersRead ) {
                        BinlParametersRead = TRUE;
                        BinlServerEventLog(
                            EVENT_SERVER_INIT_AND_READY,
                            EVENTLOG_INFORMATION_TYPE,
                            Error );
                    }
                }

                //
                // Decrement the update count. However, if we have not yet
                // managed to read our parameters while in hyper mode, don't
                // let the count go to 0.
                //

                BinlHyperUpdateCount--;
                if ( (BinlHyperUpdateCount == 0) && !BinlHyperUpdateSatisfied ) {
                    BinlHyperUpdateCount = 1;
                }
                BinlPrintDbg((DEBUG_SCAVENGER, "Hypermode count: %u\n", BinlHyperUpdateCount ));
            }

            BinlPrintDbg((DEBUG_SCAVENGER, "Reading parameters complete\n"));
        }
    }
    if (BinlGlobalPnpEvent != NULL) {
        CloseHandle( BinlGlobalPnpEvent );
        BinlGlobalPnpEvent = NULL;
    }
    return( ERROR_SUCCESS );
}

VOID
TellBinlState(
    int NewState
        )
/*++

Routine Description:

    This routine is called by DHCP when it starts (when we need to stop
    listening on the DHCP socket) and when it stops (when we need to start).

Arguments:

    NewState - Supplies DHCP's state.

Return Value:

    None.

--*/
{
    BOOLEAN haveLock = TRUE;

    EnterCriticalSection(&gcsDHCPBINL);

    //
    //  If BinlGlobalEndpointList is NULL then BINL isn't started so just
    //  record the NewState
    //

    if (NewState == DHCP_STARTING) {

        if (DHCPState == DHCP_STOPPED) {

            //  DHCP is going from stopped to running.

            DHCPState = NewState;

            //  BINL needs to close the DHCP socket so that DHCP can receive datagrams

            if (BinlCurrentState != BINL_STOPPED) {

                MaybeCloseEndpoint( &BinlGlobalEndpointList[0]);

                LeaveCriticalSection(&gcsDHCPBINL);
                haveLock = FALSE;
                StopRogueThread( );
            }

        } else {

            BinlAssert( DHCPState == DHCP_STARTING );
        }

    } else if (NewState == DHCP_STOPPED) {

        if (DHCPState == DHCP_STARTING) {

            //  DHCP is going from running to stopped.

            DHCPState = NewState;

            if (BinlCurrentState != BINL_STOPPED) {

                MaybeInitializeEndpoint( &BinlGlobalEndpointList[0],
                                            NULL,
                                            DHCP_SERVR_PORT);

                LeaveCriticalSection(&gcsDHCPBINL);
                haveLock = FALSE;
                MaybeStartRogueThread( );
            }
        } else {

            BinlAssert( DHCPState == DHCP_STOPPED );
        }

    } else if (NewState == DHCP_AUTHORIZED) {

        HandleRogueAuthorized( );

    } else if (NewState == DHCP_NOT_AUTHORIZED) {

        HandleRogueUnauthorized( );

    } else {

        BinlPrintDbg((DEBUG_ERRORS, "TellBinlState called with 0x%x\n", NewState ));
    }

    if (haveLock) {
        LeaveCriticalSection(&gcsDHCPBINL);
    }
    return;
}

BOOL
BinlState (
        VOID
        )
/*++

Routine Description:

    This routine is called by DHCP when it starts (when we need to stop
    listening on the DHCP socket) and when it stops (when we need to start).

Arguments:

    None.

Return Value:

    TRUE if BINL running.

--*/
{
    return (BinlCurrentState == BINL_STARTED)?TRUE:FALSE;
}

BOOLEAN
BinlDllInitialize(
    IN HINSTANCE DllHandle,
    IN ULONG Reason,
    IN LPVOID lpReserved OPTIONAL
    )
{

    //
    // Handle attaching binlsvc.dll to a new process.
    //

    //DebugBreak( );

    if (Reason == DLL_PROCESS_ATTACH) {

        INITIALIZE_TRACE_MEMORY;

        //
        // Initialize critical sections.
        //

        InitializeCriticalSection( &gcsDHCPBINL );
        InitializeCriticalSection( &gcsParameters );

        // don't call in here with thread attach/detach notices please...

        DisableThreadLibraryCalls( DllHandle );

    //
    // When DLL_PROCESS_DETACH and lpReserved is NULL, then a FreeLibrary
    // call is being made.  If lpReserved is Non-NULL, and ExitProcess is
    // in progress.  These cleanup routines will only be called when
    // a FreeLibrary is being called.  ExitProcess will automatically
    // clean up all process resources, handles, and pending io.
    //
    } else if ((Reason == DLL_PROCESS_DETACH) &&
               (lpReserved == NULL)) {

        UNINITIALIZE_TRACE_MEMORY;

        DeleteCriticalSection( &gcsParameters );
        DeleteCriticalSection( &gcsDHCPBINL );

        //
        // uninitialize the debugging engine last, after
        // we're done printing out the memory leak list,
        // etc.
        //
        DebugUninitialize();

    }

    return TRUE;

}

VOID
SendWakeup(
           PENDPOINT pEndpoint
           )
/*++

Routine Description:

    Send a loopback packet to the BINL socket. This will cause the
    select to change so that it includes or excludes the DHCP socket
    as appropriate.

Arguments:

    pEndpoint - Supplies the socket to send the packet on.

Return Value:

    None.

--*/
{
    DHCP_MESSAGE SendBuffer;
    SOCKADDR_IN saUdpServ;

    RtlZeroMemory(&SendBuffer, sizeof(SendBuffer));
    //  We ignore anything that is not BOOT_REQUEST
    SendBuffer.Operation = ~BOOT_REQUEST;

    saUdpServ.sin_family = AF_INET;
        saUdpServ.sin_addr.s_addr = htonl ( INADDR_LOOPBACK );
    saUdpServ.sin_port = htons ( (USHORT)g_Port );

    BinlPrintDbg((DEBUG_MISC, "Sending dummy packet\n"));

    sendto( pEndpoint->Socket,
        (char *)&SendBuffer,
        sizeof(SendBuffer),
        0,
        (const struct sockaddr *)&saUdpServ,
        sizeof ( SOCKADDR_IN )
        );
}

DWORD
MaybeInitializeEndpoint(
    PENDPOINT pEndpoint,
    PDHCP_IP_ADDRESS pIpAddress,
    DWORD Port
    )
/*++

Routine Description:

    This function initializes an endpoint by creating and binding a
    socket to the local address if DHCP is not running.

Arguments:

    pEndpoint - Receives a pointer to the newly created socket

    pIpAddress - The IP address to initialize to INADDR_ANY if NULL.

    Port - The port to bind to.

Return Value:

    The status of the operation.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    EnterCriticalSection(&gcsDHCPBINL);

    if (DHCPState == DHCP_STOPPED) {

        Error = BinlInitializeEndpoint( pEndpoint,
                                    pIpAddress,
                                    Port);

        BinlPrintDbg((DEBUG_MISC, "Opened Socket  %lx\n", pEndpoint->Socket ));

        //
        //  We may have a thread already doing a select and listening to
        //  the BINL socket. Send a dummy packet so that it will do a new
        //  select that includes this socket.
        //

        if ( Error == ERROR_SUCCESS ) {
            SendWakeup(pEndpoint);
        }
    }

    LeaveCriticalSection(&gcsDHCPBINL);
    return Error;
}

VOID
MaybeCloseEndpoint(
    PENDPOINT pEndpoint
    )
/*++

Routine Description:

    This function closes an endpoint if it is open. Usually caused
    when DHCP starts/

Arguments:

    pEndpoint - Pointer to the socket

Return Value:

    None.

--*/
{
    EnterCriticalSection(&gcsDHCPBINL);

    if( pEndpoint->Socket != 0 ) {
        //
        //  Set pEndpoint->Socket to 0 first so that the wait loop gets only
        //  one error when we close the socket. Otherwise there is a race until
        //  we get it set to 0 where the wait loop will loop quickly failing.
        //

        SOCKET  Socket = pEndpoint->Socket;
        BinlPrintDbg((DEBUG_MISC, "Close Socket  %lx\n", Socket ));
        pEndpoint->Socket = 0;
        closesocket( Socket );
    }

    LeaveCriticalSection(&gcsDHCPBINL);
}


//
// Create a copy of a string by allocating heap memory.
//
LPSTR
BinlStrDupA( LPCSTR pStr )
{
    DWORD dwLen;
    LPSTR psz;
    
    if (!pStr) {
        return(NULL);
    }

    dwLen = (strlen( pStr ) + 1) * sizeof(CHAR);
    psz = BinlAllocateMemory( dwLen );
    if (psz) {
        memcpy( psz, pStr, dwLen );
    }
    return psz;
}

LPWSTR
BinlStrDupW( LPCWSTR pStr )
{
    DWORD dwLen;
    LPWSTR psz;

    if (!pStr) {
        return(NULL);
    }
    
    dwLen = (wcslen( pStr ) + 1) * sizeof(WCHAR);
    psz = (LPWSTR) BinlAllocateMemory( dwLen );
    if (psz) {
        memcpy( psz, pStr, dwLen );
    }



    return psz;
}

BOOL
BinlAnsiToUnicode(
    IN PSTR AnsiString,
    OUT PWSTR UnicodeBuffer,
    IN OUT USHORT UnicodeBufferSize
    )
{
    ANSI_STRING aString;
    UNICODE_STRING uString;
    NTSTATUS Status;

    RtlInitAnsiString(&aString, AnsiString);

    uString.Buffer = UnicodeBuffer;
    uString.Length = uString.MaximumLength = UnicodeBufferSize;

    Status = RtlAnsiStringToUnicodeString(&uString,&aString,FALSE);

    return (NT_SUCCESS(Status));

}

BOOL
BinlUnicodeToAnsi(
    IN PWSTR UnicodeString,
    OUT PSTR AnsiBuffer,
    OUT USHORT AnsiBufferSize
    )
{
    ANSI_STRING aString;
    UNICODE_STRING uString;
    NTSTATUS Status;

    RtlInitUnicodeString(&uString, UnicodeString);

    aString.Buffer = AnsiBuffer;
    aString.Length = aString.MaximumLength = AnsiBufferSize;

    Status = RtlUnicodeStringToAnsiString(&aString,&uString,FALSE);

    return (NT_SUCCESS(Status));

}



NTSTATUS
BinlSetupPnpWait (
    VOID
    )
{
    NTSTATUS Error;
    ULONG bytesRequired = 0;

    BinlAssert(BinlPnpSocket != INVALID_SOCKET);

    memset((PCHAR) &BinlPnpOverlapped, '\0', sizeof( WSAOVERLAPPED ));
    BinlPnpOverlapped.hEvent = BinlGlobalPnpEvent;

    Error = WSAIoctl( BinlPnpSocket,
                      SIO_ADDRESS_LIST_CHANGE,
                      NULL,
                      0,
                      NULL,
                      0,
                      &bytesRequired,
                      &BinlPnpOverlapped,
                      NULL
                      );
    if (Error != 0) {
        Error = WSAGetLastError();
        //
        //  a return code of ERROR_IO_PENDING is perfectly valid here.
        //
        if (Error == ERROR_IO_PENDING) {
            Error = 0;
        }
    }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\infdir.c ===
/*
Module Name:

    infdir.c

Abstract:

    This module implements utility routines to manipulate structures used to
    maintain track INF directories.  These directories hold INF files that
    we put parse and put change notifies on to track updates.

Author:

    Andy Herron Apr 08 1998

Revision History:

*/

#include "binl.h"
#pragma hdrstop

#include "netinfp.h"

BOOLEAN StartedNetInfHandler = FALSE;
CRITICAL_SECTION NetInfLock;
LIST_ENTRY NetInfGlobalInfList;

ULONG
NetInfStartHandler (
    VOID
    )
/*++

Routine Description:

    This function just dereferences the block for the 'alive' reference.
    This may cause it to be deleted.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

Return Value:

    Windows Error.

--*/
{
    if (StartedNetInfHandler == FALSE) {

        StartedNetInfHandler = TRUE;
        InitializeCriticalSection( &NetInfLock );
        InitializeListHead(&NetInfGlobalInfList);
    }
    return ERROR_SUCCESS;
}

ULONG
NetInfCloseHandler (
    VOID
    )
/*++

Routine Description:

    This function just dereferences the block for the 'alive' reference.
    This may cause it to be deleted.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

Return Value:

    Windows Error.

--*/
{
    if (StartedNetInfHandler) {

        EnterCriticalSection( &NetInfLock );

        while (IsListEmpty( &NetInfGlobalInfList ) == FALSE) {

            PNETCARD_INF_BLOCK pEntry;
            PLIST_ENTRY listEntry = RemoveHeadList( &NetInfGlobalInfList );

            pEntry = (PNETCARD_INF_BLOCK) CONTAINING_RECORD(
                                                    listEntry,
                                                    NETCARD_INF_BLOCK,
                                                    InfBlockEntry );
            NetInfCloseNetcardInfo( pEntry );
        }

        StartedNetInfHandler = FALSE;

        LeaveCriticalSection( &NetInfLock );

        DeleteCriticalSection( &NetInfLock );
    }
    return ERROR_SUCCESS;
}

ULONG
NetInfFindNetcardInfo (
    PWCHAR InfDirectory,
    ULONG Architecture,
    ULONG CardInfoVersion,
    NET_CARD_INFO UNALIGNED * CardIdentity,
    PWCHAR *FullDriverBuffer OPTIONAL,
    PNETCARD_RESPONSE_DATABASE *pInfEntry
    )
/*++

Routine Description:

    This function searches the drivers we've found and returns a pointer to
    an entry that most closely matches the client's request.

Arguments:

    InfDirectory - directory that is target client's setup directory that
        contains all INF files for the client's NT installation.

    Architecture - PROCESSOR_ARCHITECTURE_XXXXX

    CardInfoVersion - Version of the structure passed by the client.

    CardIdentity - has the values the app is looking for.  we try our best to
        find one that matches.

    FullDriverBuffer - where we put the fully qualified file path specification
        for the driver we find, if they want it.

    pInfEntry - the entry that was found if successful. NULL if in error.

Return Value:

    ERROR_SUCCESS, ERROR_NOT_ENOUGH_MEMORY, or ERROR_NOT_SUPPORTED

--*/
{
    ULONG err = ERROR_NOT_SUPPORTED;        // start off with not found
    LONG result;
    PLIST_ENTRY listEntry;
    UNICODE_STRING infDirString;
    PNETCARD_INF_BLOCK pNetCards = NULL;
    WCHAR SetupPath[MAX_PATH];
    PWSTR ArchitectureString;

    *pInfEntry = NULL;

    if (InfDirectory == NULL) {

        return ERROR_NOT_SUPPORTED;
    }

    //
    //  we find out what the relative path within the IMIRROR directory is
    //  for this client's setup files.
    //

    if ((*InfDirectory != L'\\') ||
        (*(InfDirectory+1) != L'\\') ) {

useWholePath:

        //
        // Make sure there is room for InfDirectory + '\' (1 byte)
        // + architecture (MAX_ARCHITECTURE_LENGTH bytes) + '\0' (1 byte).

        if (wcslen(InfDirectory) + MAX_ARCHITECTURE_LENGTH + 2 >=
                sizeof(SetupPath) / sizeof(SetupPath[0])) {
            return ERROR_BAD_PATHNAME;
        }
        wcscpy( SetupPath, InfDirectory );

    } else {

        PWCHAR beginRelativePath = InfDirectory + 2;    // skip leading slashes

        //
        // skip computer name
        //

        while ((*beginRelativePath != L'\0') &&
               (*beginRelativePath != L'\\')) {

            beginRelativePath++;
        }

        //
        //  we should be at the start of the sharename.
        //

        if (*beginRelativePath != L'\\') {

            goto useWholePath;
        }

        beginRelativePath++;

        //
        // skip share name
        //

        while ((*beginRelativePath != L'\0') &&
               (*beginRelativePath != L'\\')) {

            beginRelativePath++;
        }

        //
        //  we should be at the start of the relative directory
        //

        if (*beginRelativePath != L'\\') {

            goto useWholePath;
        }

        //
        // Make sure there is room for IntelliMirrorPathW +
        // beginRelativePath + '\' (1 byte) + architecture
        // (MAX_ARCHITECTURE_LENGTH bytes) + '\0' (1 byte).
        //

        if (wcslen(IntelliMirrorPathW) + wcslen(beginRelativePath) + MAX_ARCHITECTURE_LENGTH + 2 >=
                sizeof(SetupPath) / sizeof(SetupPath[0])) {
            return ERROR_BAD_PATHNAME;
        }
        wcscpy( SetupPath, IntelliMirrorPathW );
        wcscat( SetupPath, beginRelativePath );
    }

    RtlInitUnicodeString( &infDirString, SetupPath );
    RtlUpcaseUnicodeString( &infDirString, &infDirString, FALSE );

    //  convert the path to uppercase to speed our searches
    switch (Architecture) {

#if 0
    //
    // obsoleted architectures.
    //
    case PROCESSOR_ARCHITECTURE_ALPHA:
        ArchitectureString = L"\\ALPHA";
        break;
    case PROCESSOR_ARCHITECTURE_ALPHA64:
        ArchitectureString = L"\\AXP64";
        break;   
    case PROCESSOR_ARCHITECTURE_MIPS:
        ArchitectureString = L"\\MIPS";
        break;
    case PROCESSOR_ARCHITECTURE_PPC:
        ArchitectureString = L"\\PPC";
        break;
#endif
    case PROCESSOR_ARCHITECTURE_AMD64:
        ArchitectureString = L"\\amd64";
        break;
    case PROCESSOR_ARCHITECTURE_IA64:
        ArchitectureString = L"\\IA64";
        break;
    case PROCESSOR_ARCHITECTURE_INTEL:
    default:
        ArchitectureString = L"\\I386";
        break;
    }

    wcscat( SetupPath, ArchitectureString );
    
    RtlInitUnicodeString( &infDirString, SetupPath );

    EnterCriticalSection( &NetInfLock );

    //
    //  Find the NETCARD_INF_BLOCK block for this inf directory.  If it
    //  doesn't exist, try to create the block.
    //

    listEntry = NetInfGlobalInfList.Flink;

    while ( listEntry != &NetInfGlobalInfList ) {

        pNetCards = (PNETCARD_INF_BLOCK) CONTAINING_RECORD(
                                                listEntry,
                                                NETCARD_INF_BLOCK,
                                                InfBlockEntry );

        err = CompareStringW( LOCALE_INVARIANT,
                              0,
                              SetupPath,
                              infDirString.Length / sizeof(WCHAR),
                              &pNetCards->InfDirectory[0],
                              -1
                              );
        if (err == 2) {

            break;      // a match was found.
        }

        pNetCards = NULL;

        if (err == 3) {

            break;      // it's greater, add it before listEntry
        }

        listEntry = listEntry->Flink;
    }

    if (pNetCards == NULL) {

        // we didn't find one.   let's create it and parse the INFs.

        err = NetInfAllocateNetcardInfo( SetupPath,
                                         Architecture,
                                         &pNetCards );

        if (err != ERROR_SUCCESS) {

            //
            //  log an error here that we couldn't get INF file info.
            //

            PWCHAR strings[2];

            strings[0] = SetupPath;
            strings[1] = NULL;

            BinlReportEventW(   ERROR_BINL_ERR_IN_SETUP_PATH,
                                EVENTLOG_WARNING_TYPE,
                                1,
                                sizeof(ULONG),
                                strings,
                                &err
                                );
            BinlAssert( pNetCards == NULL );
            LeaveCriticalSection( &NetInfLock );
            return err;
        }

        BinlAssert( pNetCards != NULL );

        //
        //  Now we plop it in the list right in front of listEntry
        //
        //  Either listEntry is equal to the head of the list or
        //  it's equal to some entry that is larger (sort wise) than the
        //  inf path passed in.  In either case, we can simply insert
        //  this new entry onto the tail of listEntry.
        //

        InsertTailList( listEntry, &pNetCards->InfBlockEntry );

        EnterCriticalSection( &pNetCards->Lock );
        LeaveCriticalSection( &NetInfLock );

        //
        //  Fill in the list with the list of cards to support
        //

        err = GetNetCardList( pNetCards );
        pNetCards->StatusFromScan = err;

        if (err != ERROR_SUCCESS) {

            PWCHAR strings[2];

            LeaveCriticalSection( &pNetCards->Lock );
            NetInfCloseNetcardInfo( pNetCards );
            DereferenceNetcardInfo( pNetCards );

            strings[0] = SetupPath;
            strings[1] = NULL;

            BinlReportEventW(   ERROR_BINL_ERR_IN_SETUP_PATH,
                                EVENTLOG_WARNING_TYPE,
                                1,
                                sizeof(ULONG),
                                strings,
                                &err
                                );
            return err;
        }

    } else {

        BinlAssert( pNetCards->ReferenceCount > 0 );
        pNetCards->ReferenceCount++;

        LeaveCriticalSection( &NetInfLock );
        EnterCriticalSection( &pNetCards->Lock );

        err = pNetCards->StatusFromScan;
    }

    //
    //  if the thread that is scanning the INFs hits an error, then all threads
    //  that were waiting on that directory to be scanned should get the same
    //  error.  we use StatusFromScan to hold this.
    //

    if (err == ERROR_SUCCESS) {

        err = FindNetcardInfo( pNetCards, CardInfoVersion, CardIdentity, pInfEntry );

    }

    LeaveCriticalSection( &pNetCards->Lock );


    if ((err == ERROR_SUCCESS) &&
        (*pInfEntry != NULL) &&
        (FullDriverBuffer != NULL)) {

        ULONG sizeToAllocate;

        //
        //  the caller wanted a copy of the fully qualified file name.  we
        //  have all that info here.  Allocate what we need plus two, one for
        //  the null, the other for the backslash.
        //

        sizeToAllocate = (wcslen( SetupPath ) + 2) * sizeof(WCHAR);
        sizeToAllocate += wcslen( (*pInfEntry)->DriverName ) * sizeof(WCHAR);

        *FullDriverBuffer = BinlAllocateMemory( sizeToAllocate );

        if (*FullDriverBuffer) {

            if (_snwprintf( *FullDriverBuffer,
                      sizeToAllocate/sizeof(WCHAR),
                      L"%ws\\%ws",
                      SetupPath,
                      (*pInfEntry)->DriverName ) < 0) {
                BinlFreeMemory( *FullDriverBuffer );
                *FullDriverBuffer = NULL;
                err = ERROR_NOT_ENOUGH_SERVER_MEMORY;
            } else {
                *FullDriverBuffer[sizeToAllocate-1] = L'\0';
            }
        }
    }
    DereferenceNetcardInfo( pNetCards );

    return err;
}

ULONG
NetInfEnumFiles (
    PWCHAR FlatDirectory,
    ULONG Architecture,
    LPVOID Context,
    PNETINF_CALLBACK CallBack
    )
/*++

Routine Description:

    This function searches the drivers we've found and returns a pointer to
    an entry that most closely matches the client's request.

Arguments:

    FlatDirectory - directory that is target client's setup directory that
        contains all INF files for the client's NT installation.

    Architecture - PROCESSOR_ARCHITECTURE_XXXXX

    CallBack - function to call with names of files


Return Value:

    ERROR_SUCCESS, ERROR_NOT_ENOUGH_MEMORY, or ERROR_NOT_SUPPORTED

--*/
{
    ULONG err = ERROR_NOT_SUPPORTED;        // start off with not found
    UNICODE_STRING infDirString;
    PNETCARD_INF_BLOCK pNetCards = NULL;
    WCHAR SetupPath[MAX_PATH];

    //
    // this entrypoint can purposely be called from another context than 
    // BINLSVC.  so initialize debugging if that's the case.
    //
    DebugInitialize();

    if (FlatDirectory == NULL) {

        err = ERROR_NOT_SUPPORTED;
        goto Exit;
    }

    if (wcslen(FlatDirectory) > MAX_PATH - 1) {

        err = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    wcscpy( SetupPath, FlatDirectory );

    RtlInitUnicodeString( &infDirString, SetupPath );
    RtlUpcaseUnicodeString( &infDirString, &infDirString, FALSE );

    if (StartedNetInfHandler == FALSE) {

        err = NetInfStartHandler();

        if (err != ERROR_SUCCESS) {
            goto Exit;
        }
    }

    err = NetInfAllocateNetcardInfo( SetupPath,
                                     Architecture,
                                     &pNetCards );

    if (err != ERROR_SUCCESS) {

        goto Exit;
    }

    BinlAssert( pNetCards != NULL );

    pNetCards->FileListCallbackFunction = CallBack;
    pNetCards->FileListCallbackContext = Context;

    //
    //  Fill in the list with the list of cards to support
    //

    err = GetNetCardList( pNetCards );

    DereferenceNetcardInfo( pNetCards );    // one for dereference
    DereferenceNetcardInfo( pNetCards );    // and one to delete it.

    //
    //  note that we won't bother to call NetInfCloseHandler here because
    //  we have no idea if the caller on another thread has setup any
    //  other NETCARD_INF_BLOCKs.  So rather than corrupt the list and AV,
    //  we'll just leak the lock.  Not a big deal in RIPREP since it doesn't
    //  handle more than one.  Not an issue for BINL processing INF files.
    //

Exit:    
    //
    // this entrypoint can purposely be called from another context than 
    // BINLSVC. debugging will be uninitialize in process detach when we're
    // done.
    //    

    return err;
}

// infdir.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\global.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    global.h

Abstract:

    This module contains definitions for global server data.

Author:

    Colin Watson (colinw)  14-Apr-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef  GLOBAL_DATA_ALLOCATED
    #ifdef  GLOBAL_DATA_ALLOCATE
        #undef GLOBAL_DATA
    #endif
#endif

#ifndef GLOBAL_DATA
#define GLOBAL_DATA

//
// main.c will #include this file with GLOBAL_DATA_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef  GLOBAL_DATA_ALLOCATE
#undef EXTERN
#define EXTERN
#define GLOBAL_DATA_ALLOCATED
#undef INIT_GLOBAL
#define INIT_GLOBAL(v) =v
#else
#define EXTERN extern
#define INIT_GLOBAL(v)
#endif

//
// process global data passed to this service from tcpsvcs.exe
//

EXTERN PTCPSVCS_GLOBAL_DATA TcpsvcsGlobalData;

//
// Service variables
//
EXTERN SERVICE_STATUS BinlGlobalServiceStatus;
EXTERN SERVICE_STATUS_HANDLE BinlGlobalServiceStatusHandle;

//
// Process data.
//

#define BINL_STOPPED 0
#define BINL_STARTED 1
EXTERN DWORD BinlCurrentState INIT_GLOBAL(BINL_STOPPED);

EXTERN HANDLE BinlGlobalProcessTerminationEvent INIT_GLOBAL(NULL);
EXTERN HANDLE BinlGlobalProcessorHandle;
EXTERN HANDLE BinlGlobalMessageHandle;

EXTERN LIST_ENTRY BinlGlobalFreeRecvList;
EXTERN LIST_ENTRY BinlGlobalActiveRecvList;
EXTERN CRITICAL_SECTION BinlGlobalRecvListCritSect;
EXTERN HANDLE BinlGlobalRecvEvent INIT_GLOBAL(NULL);

EXTERN int DHCPState INIT_GLOBAL(DHCP_STOPPED);

EXTERN BOOL BinlGlobalSystemShuttingDown;

//  Temporary defaults until GPT lookup available
EXTERN PWCHAR BinlGlobalDefaultContainer INIT_GLOBAL(NULL);
EXTERN PWCHAR DefaultDomain INIT_GLOBAL(NULL);

#define DEFAULT_MAXIMUM_DEBUGFILE_SIZE 20000000

EXTERN DWORD BinlGlobalDebugFlag;
EXTERN CRITICAL_SECTION BinlGlobalDebugFileCritSect;
EXTERN HANDLE BinlGlobalDebugFileHandle;
EXTERN DWORD BinlGlobalDebugFileMaxSize;
EXTERN LPWSTR BinlGlobalDebugSharePath;

EXTERN DWORD BinlLdapOptReferrals INIT_GLOBAL(0);

//
// misc
//

//
//  We don't wait forever for the DS to come back with a reply.
//

#define BINL_LDAP_SEARCH_TIMEOUT_SECONDS        30
#define BINL_LDAP_SEARCH_MIN_TIMEOUT_MSECS      500

EXTERN struct l_timeval  BinlLdapSearchTimeout;

EXTERN DWORD BinlGlobalIgnoreBroadcastFlag;     // whether to ignore the broadcast
                                                // bit in the client requests or not

EXTERN HANDLE g_hevtProcessMessageComplete;
EXTERN DWORD g_cMaxProcessingThreads;
EXTERN DWORD g_cProcessMessageThreads;
EXTERN CRITICAL_SECTION g_ProcessMessageCritSect;

EXTERN CRITICAL_SECTION gcsDHCPBINL;
EXTERN CRITICAL_SECTION gcsParameters;

EXTERN LPENDPOINT BinlGlobalEndpointList INIT_GLOBAL(NULL);
EXTERN DWORD BinlGlobalNumberOfNets;

EXTERN DWORD g_Port;

EXTERN BOOL AllowNewClients INIT_GLOBAL(TRUE);
EXTERN BOOL LimitClients INIT_GLOBAL(FALSE);
EXTERN BOOL AssignNewClientsToServer INIT_GLOBAL(FALSE);

//
//  As part of rogue detection, the default for servers should be to not answer
//  for new clients.  We'll get the ability to answer clients out of
//  the directory.
//

EXTERN BOOL AnswerRequests INIT_GLOBAL(TRUE);
EXTERN BOOL AnswerOnlyValidClients INIT_GLOBAL(TRUE);

EXTERN WCHAR NewMachineNamingPolicyDefault[] INIT_GLOBAL(L"%Username%#");
EXTERN PWCHAR NewMachineNamingPolicy INIT_GLOBAL(NULL);
EXTERN DWORD CurrentClientCount INIT_GLOBAL(0);
EXTERN DWORD BinlMaxClients INIT_GLOBAL(0);
EXTERN DWORD BinlClientTimeout INIT_GLOBAL(0);
EXTERN DWORD BinlUpdateFromDSTimeout INIT_GLOBAL(4*60*60*1000); // milliseconds (4 hours)
EXTERN DWORD BinlHyperUpdateCount INIT_GLOBAL(0);
EXTERN BOOL BinlHyperUpdateSatisfied INIT_GLOBAL(FALSE);

EXTERN BOOL BinlParametersRead INIT_GLOBAL(FALSE);

EXTERN PWCHAR BinlGlobalSCPPath INIT_GLOBAL(NULL);
EXTERN PWCHAR BinlGlobalServerDN INIT_GLOBAL(NULL);
EXTERN PWCHAR BinlGlobalGroupDN INIT_GLOBAL(NULL);

EXTERN CRITICAL_SECTION ClientsCriticalSection;
EXTERN LIST_ENTRY ClientsQueue;
EXTERN CRITICAL_SECTION HackWorkaroundCriticalSection;

//
//  By default, we cache DS responses for 25 seconds.  It's relatively short
//  because we have no way of cheeply getting notified of DS changes.
//

#define BINL_CACHE_EXPIRE_DEFAULT (25*1000)

//
//  We maintain a list of BINL_CACHE_ENTRY structures for short term caching.
//  The root of the list is in BinlCacheList and the lock that protects the
//  list is BinlCacheListLock.  We expire these cache entries after a given
//  time period has expired (BinlCacheExpireMilliseconds holds it).
//

EXTERN LIST_ENTRY BinlCacheList;
EXTERN CRITICAL_SECTION BinlCacheListLock;
EXTERN ULONG BinlCacheExpireMilliseconds;

//
//  When waiting for the threads to be done with the cache, we wait on the
//  BinlCloseCacheEvent event.
//

EXTERN HANDLE BinlCloseCacheEvent INIT_GLOBAL(NULL);

//
//  default for max number to cache is 250.  This seems reasonable number to
//  cache for at most BinlCacheExpireMilliseconds.
//

#define BINL_CACHE_COUNT_LIMIT_DEFAULT 250

EXTERN ULONG BinlGlobalCacheCountLimit;
EXTERN DWORD BinlGlobalScavengerSleep; // in milliseconds

#if DBG
EXTERN BOOL BinlGlobalRunningAsProcess;
#endif

EXTERN ULONG BinlMinDelayResponseForNewClients;

//
// Remote boot path - as in "D:\RemoteInstall" with no trailing slash
//
EXTERN WCHAR IntelliMirrorPathW[ MAX_PATH ];
EXTERN CHAR IntelliMirrorPathA[ MAX_PATH ];

//
// Default language to look for oschooser screens/setups in.
//
EXTERN PWCHAR BinlGlobalDefaultLanguage INIT_GLOBAL(NULL);

EXTERN DHCP_ROGUE_STATE_INFO DhcpRogueInfo;
EXTERN BOOL BinlGlobalHaveCalledRogueInit INIT_GLOBAL(FALSE);
EXTERN BOOL BinlGlobalAuthorized INIT_GLOBAL(FALSE);
EXTERN BOOL BinlRogueLoggedState INIT_GLOBAL(FALSE);

EXTERN HANDLE BinlRogueTerminateEventHandle INIT_GLOBAL(NULL);
EXTERN HANDLE RogueUnauthorizedHandle INIT_GLOBAL(NULL);
EXTERN HANDLE BinlRogueThread INIT_GLOBAL(NULL);

//
//  PNP globals.
//

EXTERN PIP_ADAPTER_INFO BinlIpAddressInfo INIT_GLOBAL(NULL);
EXTERN ULONG BinlIpAddressInfoCount INIT_GLOBAL(0);
EXTERN BOOL BinlIsMultihomed INIT_GLOBAL(FALSE);
EXTERN DHCP_IP_ADDRESS BinlGlobalMyIpAddress INIT_GLOBAL(0);
EXTERN SOCKET BinlPnpSocket INIT_GLOBAL(INVALID_SOCKET);

EXTERN WSAOVERLAPPED BinlPnpOverlapped;
EXTERN HANDLE BinlGlobalPnpEvent INIT_GLOBAL(NULL);

//
// The four strings below are protected by the gcsParameters critical section.
//

EXTERN PWCHAR BinlGlobalOurDnsName INIT_GLOBAL(NULL);   // our dns name
EXTERN PWCHAR BinlGlobalOurDomainName INIT_GLOBAL(NULL);// our netbios domain name
EXTERN PWCHAR BinlGlobalOurServerName INIT_GLOBAL(NULL);// our netbios server name
EXTERN PWCHAR BinlGlobalOurFQDNName INIT_GLOBAL(NULL);  // our distinguished name
EXTERN HANDLE BinlGlobalLsaDnsNameNotifyEvent INIT_GLOBAL(NULL);
EXTERN BOOL BinlGlobalHaveOutstandingLsaNotify INIT_GLOBAL(FALSE);

//
// Default organization to use in .sifs.
//
EXTERN PWCHAR BinlGlobalDefaultOrgname INIT_GLOBAL(NULL);

//
// Default timezone index to use in .sifs
//
EXTERN PWCHAR BinlGlobalDefaultTimezone INIT_GLOBAL(NULL);

//
// Default DS servers
//
EXTERN PWCHAR BinlGlobalDefaultDS INIT_GLOBAL(NULL);
EXTERN PWCHAR BinlGlobalDefaultGC INIT_GLOBAL(NULL);


//
// default for NTLMV2 style authentication
//
#define BINL_NTLMV2_AUTHENTICATE_DEFAULT        1

EXTERN DWORD BinlGlobalUseNTLMV2 INIT_GLOBAL(1);

//
//  The number of times we'll retry before giving up on the DS.
//

#define LDAP_SERVER_DOWN_LIMIT 4  // number of times to retry
#define LDAP_BUSY_LIMIT 15      // number of times to retry
#define LDAP_BUSY_DELAY 250     // milliseconds to wait

EXTERN ULONG BinlGlobalLdapErrorCount INIT_GLOBAL(0);
EXTERN ULONG BinlGlobalMaxLdapErrorsLogged INIT_GLOBAL(0);
EXTERN ULONG BinlGlobalLdapErrorScavenger INIT_GLOBAL(0);

//
// Used to crack names
//
EXTERN HANDLE BinlOscClientDSHandle INIT_GLOBAL(NULL);

#endif // GLOBAL_DATA*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\menu.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    menu.c

Abstract:

    This module contains the code to process OS Chooser message
    for the BINL server.

Author:

    Adam Barr (adamba)  9-Jul-1997
    Geoff Pease (gpease) 10-Nov-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include "binl.h"
#pragma hdrstop

BOOL
IsIncompatibleRiprepSIF(
    PCHAR Path,
    PCLIENT_STATE clientState
    )
{
    CHAR HalName[32];
    CHAR ImageType[32];
    PCHAR DetectedHalName;
    BOOL RetVal;

    ImageType[0] = '\0';
    HalName[0] = '\0';

    //
    // if it's not an RIPREP image, then just bail out.
    //
    GetPrivateProfileStringA(
                OSCHOOSER_SIF_SECTIONA,
                "ImageType",
                "",
                ImageType,
                sizeof(ImageType)/sizeof(ImageType[0]),
                Path );


    if (0 != _stricmp(ImageType,"SYSPREP")) {
        RetVal = FALSE;
        goto exit;
    }
    //
    // retrieve the hal name from the SIF file
    //
    GetPrivateProfileStringA(
                OSCHOOSER_SIF_SECTIONA,
                "HalName",
                "",
                HalName,
                sizeof(HalName)/sizeof(HalName[0]),
                Path );

    //
    // if the hal name isn't present, assume it's an old SIF that
    // doesn't have the hal type in it, and so we just return success
    //
    if (*HalName == '\0') {
        RetVal = FALSE;
        goto exit;
    }

    //
    // retrieve the detected HAL type from earlier
    //
    DetectedHalName = OscFindVariableA( clientState, "HALTYPE" );
    if (_stricmp(HalName,DetectedHalName)==0) {
        RetVal = FALSE;
        goto exit;
    }

    //
    // if we got this far, the SIF file is incompatible
    //
    RetVal = TRUE;

exit:
    return(RetVal);
}

DWORD
OscAppendTemplatesMenus(
    PCHAR *GeneratedScreen,
    PDWORD dwGeneratedSize,
    PCHAR DirToEnum,
    PCLIENT_STATE clientState,
    BOOLEAN RecoveryOptionsOnly
    )
{
    DWORD Error = ERROR_SUCCESS;
    WIN32_FIND_DATA FindData;
    HANDLE hFind;
    int   x = 1;
    CHAR Path[MAX_PATH];
    WCHAR UnicodePath[MAX_PATH];
    DWORD dwGeneratedCurrentLength;
    
    TraceFunc("OscAppendTemplatesMenus( )\n");

    BinlAssert( *GeneratedScreen != NULL );

    //
    // The incoming size is the current length of the buffer
    //
    dwGeneratedCurrentLength = *dwGeneratedSize;

    // Resulting string should be something like:
    //      "D:\RemoteInstall\English\Images\nt50.wks\i386\Templates\*.sif"
    if ( _snprintf( Path,
                    sizeof(Path) / sizeof(Path[0]),
                    "%s\\%s\\Templates\\*.sif",
                    DirToEnum,
                    OscFindVariableA( clientState, "MACHINETYPE" )
                    ) < 0 ) {
        Error = ERROR_BAD_PATHNAME;
        goto Cleanup;
    }

    if (!BinlAnsiToUnicode(Path, UnicodePath, MAX_PATH*sizeof(WCHAR))) {
        Error = ERROR_BAD_PATHNAME;
        goto Cleanup;
    }
    
    BinlPrintDbg(( DEBUG_OSC, "Enumerating: %s\n", Path ));

    hFind = FindFirstFile( UnicodePath, (LPVOID) &FindData );
    if ( hFind != INVALID_HANDLE_VALUE )
    {
        DWORD dwPathLen;

        dwPathLen = strlen( Path );

        do {
            //
            // If it is not a directory, try to open it
            //
            if (!(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                CHAR  Description[DESCRIPTION_SIZE];
                CHAR  HelpLines[HELPLINES_SIZE];
                PCHAR NewScreen;    // temporary points to newly generated screen
                DWORD dwErr;
                DWORD dwFileNameLen;
                CHAR  NewItems[ MAX_PATH * 2 + 512 ];  // arbitrary size
                DWORD dwNewItemsLength;
                BOOLEAN IsCmdConsSif;
                BOOLEAN IsASRSif;
                BOOLEAN IsWinPESif;
                BOOLEAN IsRecoveryOption;

                //
                // Resulting string should be something like:
                //      "D:\RemoteInstall\English\Images\nt50.wks\i386\Templates\Winnt.Sif"
                dwFileNameLen = wcslen(FindData.cFileName);
                if (dwPathLen + dwFileNameLen - 4 > sizeof(Path) / sizeof(Path[0])) {
                    continue;  // path too long, skip it
                }
                
                if (!BinlUnicodeToAnsi(FindData.cFileName, &Path[dwPathLen - 5], (USHORT)(dwFileNameLen+1) )) {
                    continue;
                }
                

                BinlPrintDbg(( DEBUG_OSC, "Found SIF File: %s\n", Path ));

                //
                // Check that the image is the type we are looking for
                //
                IsCmdConsSif = OscSifIsCmdConsA(Path);
                IsASRSif = OscSifIsASR(Path);
                IsWinPESif = OscSifIsWinPE(Path);

                IsRecoveryOption = ( IsCmdConsSif || IsASRSif || IsWinPESif) 
                                    ? TRUE 
                                    : FALSE;
                if ((RecoveryOptionsOnly && !IsRecoveryOption) || 
                    (!RecoveryOptionsOnly && IsRecoveryOption)) {
                    continue; // not readable, skip it
                }

                if (IsIncompatibleRiprepSIF(Path,clientState)) {
                    //
                    // skip it
                    //
                    BinlPrintDbg(( 
                        DEBUG_OSC, 
                        "Skipping %s because it's an incompatible RIPREP SIF\n",
                        Path ));
                    continue;
                }

                //
                // Retrieve the description
                //
                dwErr = GetPrivateProfileStringA(OSCHOOSER_SIF_SECTIONA,
                                                 "Description",
                                                 "",
                                                 Description,
                                                 DESCRIPTION_SIZE,
                                                 Path 
                                                );

                if ( dwErr == 0 || Description[0] == L'\0' )
                    continue; // not readible, skip it
                //
                // Retrieve the help lines
                //
                dwErr = GetPrivateProfileStringA(OSCHOOSER_SIF_SECTIONA,
                                                 "Help",
                                                 "",
                                                 HelpLines,
                                                 HELPLINES_SIZE,
                                                 Path 
                                                );
                //
                // Create the new item that look like this:
                // <OPTION VALUE="sif_filename.ext" TIP="Help_Lines"> Description\r\n
                //
                if ( _snprintf( NewItems,
                                sizeof(NewItems),
                                "<OPTION VALUE=\"%s\" TIP=\"%s\"> %s\r\n",
                                Path,
                                HelpLines,
                                Description
                                ) < 0 ) {
                    continue;   // path too long, skip it
                }
                NewItems[sizeof(NewItems)-1] = '\0';

                dwNewItemsLength = strlen( NewItems );

                //
                // Check to see if we have to grow the buffer...
                //
                if ( dwNewItemsLength + dwGeneratedCurrentLength >= *dwGeneratedSize )
                {
                    //
                    // Grow the buffer (add in some slop too)...
                    //
                    NewScreen = BinlAllocateMemory( dwNewItemsLength + dwGeneratedCurrentLength + GENERATED_SCREEN_GROW_SIZE );
                    if( NewScreen == NULL ) {
                        return ERROR_NOT_ENOUGH_SERVER_MEMORY;
                    }
                    memcpy( NewScreen, *GeneratedScreen, *dwGeneratedSize );
                    BinlFreeMemory(*GeneratedScreen);
                    *GeneratedScreen = NewScreen;
                    *dwGeneratedSize = dwNewItemsLength + dwGeneratedCurrentLength + GENERATED_SCREEN_GROW_SIZE;
                }

                //
                // Add the new items to the screen
                //
                strcat( *GeneratedScreen, NewItems );
                dwGeneratedCurrentLength += dwNewItemsLength;

                x++;    // move to next line
            }

        } while (FindNextFile( hFind, (LPVOID) &FindData ));

        FindClose( hFind );
    }
    else
    {
        OscCreateWin32SubError( clientState, GetLastError( ) );
        Error = ERROR_BINL_FAILED_TO_GENERATE_SCREEN;
    }

    //
    // We do this so that we only transmitted what is needed
    //
//    *dwGeneratedSize = dwGeneratedCurrentLength + 1;    // plus 1 for the NULL character

Cleanup:

    return Error;
}



//
// SearchAndGenerateOSMenu()
//
DWORD
SearchAndGenerateOSMenu(
    PCHAR *GeneratedScreen,
    PDWORD dwGeneratedSize,
    PCHAR DirToEnum,
    PCLIENT_STATE clientState )
{
    DWORD Error = ERROR_SUCCESS;
    DWORD err; // not a return value
    WIN32_FIND_DATA FindData;
    HANDLE hFind;
    int   x = 1;
    CHAR Path[MAX_PATH];
    WCHAR UnicodePath[MAX_PATH];
    BOOLEAN SearchingCmdCons;

    TraceFunc("SearchAndGenerateOSMenu( )\n");

    BinlAssert( *GeneratedScreen != NULL );

    Error = ImpersonateSecurityContext( &clientState->ServerContextHandle );
    if ( Error != STATUS_SUCCESS ) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "ImpersonateSecurityContext: 0x%08x\n", Error ));
        if ( !NT_SUCCESS(Error)) {
            return Error;
        }
    }

    //
    // Resulting string should be something like:
    //      "D:\RemoteInstall\Setup\English\Images\*"
    //
    // We special case the CMDCONS directive to search in the Images directory.
    //
    SearchingCmdCons = (BOOLEAN)(!_stricmp(DirToEnum, "CMDCONS"));
    
    if ( _snprintf( Path,
                    sizeof(Path) / sizeof(Path[0]),
                    "%s\\Setup\\%s\\%s\\*",
                    IntelliMirrorPathA,                 
                    OscFindVariableA( clientState, "LANGUAGE" ),
                    SearchingCmdCons ? REMOTE_INSTALL_IMAGE_DIR_A : 
                    DirToEnum 
                    ) < 0 ) {
        Error = ERROR_BAD_PATHNAME;
        goto Cleanup;
    }

    if (!BinlAnsiToUnicode(Path,UnicodePath,MAX_PATH*sizeof(WCHAR))) {
        Error = ERROR_BAD_PATHNAME;
        goto Cleanup;
    }
    

    hFind = FindFirstFile( UnicodePath, (LPVOID) &FindData );
    if ( hFind != INVALID_HANDLE_VALUE )
    {
        DWORD dwPathLen = strlen( Path );

        //
        // Loop enumerating each subdirectory's MachineType\Templates for
        // SIF files.
        //
        do {
            //
            // Ignore current and parent directories, but search other
            // directories.
            //
            if (wcscmp(FindData.cFileName, L".") &&
                wcscmp(FindData.cFileName, L"..") &&
                (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ))
            {
                DWORD dwFileNameLen;

                //
                // Add the sub-directory to the path
                //
                dwFileNameLen = wcslen( FindData.cFileName );
                if (dwPathLen + dwFileNameLen > sizeof(Path)/sizeof(Path[0])) {
                    continue;  // path too long, skip it
                }

                if (!BinlUnicodeToAnsi(FindData.cFileName, &Path[dwPathLen - 1], (USHORT)(dwFileNameLen+1))) {
                    continue;  // path too long, skip it
                }                

                BinlPrintDbg(( DEBUG_OSC, "Found OS Directory: %s\n", Path ));
                //
                // Then enumerate the templates and add them to the menu screen
                //
                OscAppendTemplatesMenus( GeneratedScreen, 
                                         dwGeneratedSize, 
                                         Path, 
                                         clientState, 
                                         SearchingCmdCons 
                                       );
            }

        } while (FindNextFile( hFind, (LPVOID) &FindData ));

        FindClose( hFind );
    }
    else
    {
        OscCreateWin32SubError( clientState, GetLastError( ) );
        Error = ERROR_BINL_FAILED_TO_GENERATE_SCREEN;
    }

Cleanup:

    err = RevertSecurityContext( &clientState->ServerContextHandle );
    if ( err != STATUS_SUCCESS ) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "RevertSecurityContext: 0x%08x\n", Error ));
        OscCreateWin32SubError( clientState, err );
        Error = ERROR_BINL_FAILED_TO_GENERATE_SCREEN;
    }

    return Error;
}

//
// FilterFormOptions() - for every option in this form, scan the GPO
// list for oscfilter.ini, in each one see if there is an entry in
// section [SectionName] that indicates if each option should be
// filtered out.
//

#define MAX_INI_SECTION_SIZE  512

typedef struct _FORM_OPTION {
    ULONG Result;
    PCHAR ValueName;
    PCHAR TagStart;
    ULONG TagLength;
    struct _FORM_OPTION * Next;
} FORM_OPTION, *PFORM_OPTION;

DWORD
FilterFormOptions(
    PCHAR  OutMessage,
    PCHAR  FilterStart,
    PULONG OutMessageLength,
    PCHAR SectionName,
    PCLIENT_STATE ClientState )
{
    PCHAR OptionStart, OptionEnd, ValueStart, ValueEnd, CurLoc;
    PCHAR ValueName, EqualSign;
    PFORM_OPTION Options = NULL, TmpOption;
    PCHAR IniSection = NULL;
    ULONG ValueLen;
    BOOLEAN Impersonating = FALSE;
    CHAR IniPath[MAX_PATH];
    PGROUP_POLICY_OBJECT pGPOList = NULL, tmpGPO;
    DWORD Error, BytesRead, i;
    DWORD OptionCount = 0;

    //
    // First scan the form and find all the OPTION tags. For each one,
    // we save a point to the value name, the location and length of the
    // tag, and a place to store the current result for that tag (if
    // the result is 1, then the tag stays, otherwise it is deleted).
    //

    CurLoc = FilterStart;

    while (TRUE) {

        //
        // Find the next option/end-of-option/value/end-of-value
        //

        if (!(OptionStart = strstr(CurLoc, "<OPTION ")) ||
            !(OptionEnd = strchr(OptionStart+1, '<' )) ||
            !(ValueStart = StrStrIA(OptionStart, "VALUE=\""))) {
            break;
        }
        ValueStart += sizeof("VALUE=\"") - sizeof("");
        if (!(ValueEnd = strchr(ValueStart, '\"'))) {
            break;
        }
        ValueLen = (ULONG)(ValueEnd - ValueStart);

        //
        // Allocate and fill in a FORM_OPTION for this option.
        //

        TmpOption = BinlAllocateMemory(sizeof(FORM_OPTION));
        if (!TmpOption) {
            break;
        }
        TmpOption->ValueName = BinlAllocateMemory(ValueLen + 1);
        if (!TmpOption->ValueName) {
            BinlFreeMemory(TmpOption);
            break;
        }

        TmpOption->Result = 1;
        strncpy(TmpOption->ValueName, ValueStart, ValueLen);
        TmpOption->ValueName[ValueLen] = '\0';
        TmpOption->TagStart = OptionStart;
        TmpOption->TagLength = (ULONG)(OptionEnd - OptionStart);

        ++OptionCount;

        //
        // Now link it at the head of Options.
        //

        TmpOption->Next = Options;
        Options = TmpOption;

        //
        // Continue looking for options.
        //

        CurLoc = OptionEnd;

    }

    if (!Options) {
        goto Cleanup;      // didn't find any, so don't bother filtering
    }

    //
    // Now scan the GPO list.
    //

    Error = OscImpersonate(ClientState);
    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg((DEBUG_ERRORS,
                   "FilterFormOptions: OscImpersonate failed %lx\n", Error));
        goto Cleanup;
    }

    Impersonating = TRUE;

    if (!GetGPOList(ClientState->UserToken, NULL, NULL, NULL, 0, &pGPOList)) {
        BinlPrintDbg((DEBUG_ERRORS,
                   "FilterFormOptions: GetGPOList failed %lx\n", GetLastError()));
        goto Cleanup;

    }

    IniSection = BinlAllocateMemory(MAX_INI_SECTION_SIZE);
    if (!IniSection) {
        BinlPrintDbg((DEBUG_ERRORS,
                   "FilterFormOptions: Allocate %d failed\n", MAX_INI_SECTION_SIZE));
        goto Cleanup;
    }

    for (tmpGPO = pGPOList; tmpGPO != NULL; tmpGPO = tmpGPO->pNext) {

        //
        // Try to open our .ini file. We read the whole section so
        // that we only go over the network once.
        //

#define OSCFILTER_INI_PATH "\\Microsoft\\RemoteInstall\\oscfilter.ini"

        if (!BinlUnicodeToAnsi(tmpGPO->lpFileSysPath,IniPath,MAX_PATH)) {
            continue;
        }
        
        if (strlen(IniPath) + sizeof(OSCFILTER_INI_PATH) > sizeof(IniPath)/sizeof(IniPath[0])) {
            continue;   // path too long, skip it
        }
        strcat(IniPath, OSCFILTER_INI_PATH);

        memset( IniSection, '\0', MAX_INI_SECTION_SIZE );

        BytesRead = GetPrivateProfileSectionA(
                        SectionName,
                        IniSection,
                        MAX_INI_SECTION_SIZE,
                        IniPath);

        if (BytesRead == 0) {
            BinlPrintDbg((DEBUG_POLICY,
                       "FilterFormOptions: Could not read [%s] section in %s\n", SectionName, IniPath));
            continue;
        }

        BinlPrintDbg((DEBUG_POLICY,
                   "FilterFormOptions: Found [%s] section in %s\n", SectionName, IniPath));

        //
        // GetPrivateProfileSectionA puts a NULL character after every
        // option, but in fact we don't want that since we use StrStrIA
        // below.
        //

        for (i = 0; i < BytesRead; i++) {
            if (IniSection[i] == '\0') {
                IniSection[i] = ' ';
            }
        }

        //
        // We have the section, now walk the list of options seeing if this
        // section has something for that value name.
        //

        for (TmpOption = Options; TmpOption != NULL; TmpOption = TmpOption->Next) {

            if ((ValueName = StrStrIA(IniSection, TmpOption->ValueName)) &&
                (EqualSign = strchr(ValueName, '='))) {
                TmpOption->Result = strtol(EqualSign+1, NULL, 10);
                BinlPrintDbg((DEBUG_POLICY,
                           "FilterFormOptions: Found %s = %d\n", TmpOption->ValueName, TmpOption->Result));
            }
        }
    }

    //
    // Now we have figured out the results for all the options in the
    // form, clean up the file if needed.
    //
    // NOTE: We rely on the fact that the option list is sorted from
    // last option to first, so that when we remove an option and
    // slide the rest of the file up, we don't affect any of the
    // TmpOption->TagStart values that we have not yet processed.
    //

    for (TmpOption = Options; TmpOption != NULL; TmpOption = TmpOption->Next) {

        if (TmpOption->Result == 0) {

            *OutMessageLength -= TmpOption->TagLength;

            memmove(
                TmpOption->TagStart,
                TmpOption->TagStart + TmpOption->TagLength,
                *OutMessageLength - (size_t)(TmpOption->TagStart - OutMessage));

            --OptionCount;

        }
    }

Cleanup:

    if (pGPOList) {
        FreeGPOList(pGPOList);
    }

    if (IniSection) {
        BinlFreeMemory(IniSection);
    }

    //
    // Free the options chain.
    //

    while (Options) {
        TmpOption = Options->Next;
        BinlFreeMemory(Options->ValueName);
        BinlFreeMemory(Options);
        Options = TmpOption;
    }

    if (Impersonating) {
        OscRevert(ClientState);
    }

    return OptionCount;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\infutil.c ===
/*
Module Name:

    infutil.c

Abstract:

    This module implements utility routines to parse net card INF files.

Author:

    Andy Herron Mar 24 1998

Revision History:

*/

#include "binl.h"
#pragma hdrstop

#include "netinfp.h"

const WCHAR NetInfHexToCharTable[17] = L"0123456789ABCDEF";

ULONG
NetInfCloseNetcardInfo (
    PNETCARD_INF_BLOCK pNetCards
    )
/*++

Routine Description:

    This function just dereferences the block for the 'alive' reference.
    This may cause it to be deleted.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

Return Value:

    Windows Error.

--*/
{
    BinlAssert( pNetCards->ReferenceCount > 0 );

    DereferenceNetcardInfo( pNetCards );
    return ERROR_SUCCESS;
}


VOID
DereferenceNetcardInfo (
    PNETCARD_INF_BLOCK pNetCards
    )
/*++

Routine Description:

    This function frees all memory, handles, etc that is stored in the
    NETCARD_INF_BLOCK passed in.  Note that all NETCARD_RESPONSE_DATABASE
    entries are simply dereferenced, not freed here.  This is because we don't
    want to require that all threads are done with these records before we
    close down the pNetCards block.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

Return Value:

    Windows Error.

--*/
{
    ULONG i;

    EnterCriticalSection( &NetInfLock );

    pNetCards->ReferenceCount--;

    if (pNetCards->ReferenceCount > 0) {

        LeaveCriticalSection( &NetInfLock );
        return;
    }

    //  only remove it from the global list if it was put on the list.  It
    //  might not be on the list if it's not called within BINL (i.e. RISETUP
    //  is just enumerating files).

    if (pNetCards->InfBlockEntry.Flink != NULL) {
        RemoveEntryList( &pNetCards->InfBlockEntry );
    }

    LeaveCriticalSection( &NetInfLock );

    EnterCriticalSection( &pNetCards->Lock );

    //
    //  No thread after this should call FindNetcardInfo to search the table,
    //  since the caller just closed it.
    //
    //  Free all entries allocated for this block.  We just dereference in case
    //  any thread is using a specific entry.
    //

    for (i = 0; i < NETCARD_HASH_TABLE_SIZE; i++) {

        PLIST_ENTRY listHead = &pNetCards->NetCardEntries[i];

        while (IsListEmpty( listHead ) == FALSE) {

            PNETCARD_RESPONSE_DATABASE pInfEntry;
            PLIST_ENTRY listEntry = RemoveHeadList( listHead );

            pInfEntry = (PNETCARD_RESPONSE_DATABASE) CONTAINING_RECORD(
                                                    listEntry,
                                                    NETCARD_RESPONSE_DATABASE,
                                                    NetCardEntry );
            NetInfDereferenceNetcardEntry( pInfEntry );
        }
    }

    LeaveCriticalSection( &pNetCards->Lock );

    DeleteCriticalSection( &pNetCards->Lock );
    BinlFreeMemory( pNetCards );

    return;
}

VOID
NetInfDereferenceNetcardEntry (
    PNETCARD_RESPONSE_DATABASE pInfEntry
    )
/*++

Routine Description:

    This function frees all memory, handles, etc that is stored in the
    NETCARD_INF_BLOCK passed in.  Note that all NETCARD_RESPONSE_DATABASE
    entries are simply dereferenced, not freed here.  This is because we don't
    want to require that all threads are done with these records before we
    close down the pNetCards block.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

Return Value:

    Windows Error.

--*/
{
    LONG result;

    result = InterlockedDecrement( &pInfEntry->ReferenceCount );

    if (result > 0) {
        return;
    }

    BinlAssert( result == 0 );

    //
    //  Time to free this one.  It should've already been pulled from the list.
    //

    //
    //  free the list of registry parameters we have stored off for it.
    //

    while (! IsListEmpty( &pInfEntry->Registry )) {

        PNETCARD_REGISTRY_PARAMETERS regParam;
        PLIST_ENTRY listEntry = RemoveHeadList( &pInfEntry->Registry );

        regParam = (PNETCARD_REGISTRY_PARAMETERS) CONTAINING_RECORD(
                                                    listEntry,
                                                    NETCARD_REGISTRY_PARAMETERS,
                                                    RegistryListEntry );
        if (regParam->Parameter.Buffer) {

            BinlFreeMemory( regParam->Parameter.Buffer );
        }
        if (regParam->Value.Buffer) {

            BinlFreeMemory( regParam->Value.Buffer );
        }

        BinlFreeMemory( regParam );
    }

    //
    //  free the list of registry parameters we have stored off for it.
    //

    while (! IsListEmpty( &pInfEntry->FileCopyList )) {

        PNETCARD_FILECOPY_PARAMETERS fileEntry;
        PLIST_ENTRY listEntry = RemoveHeadList( &pInfEntry->FileCopyList );

        fileEntry = (PNETCARD_FILECOPY_PARAMETERS) CONTAINING_RECORD(
                                                    listEntry,
                                                    NETCARD_FILECOPY_PARAMETERS,
                                                    FileCopyListEntry );
        if (fileEntry->SourceFile.Buffer) {

            BinlFreeMemory( fileEntry->SourceFile.Buffer );
        }
        if (fileEntry->DestFile.Buffer) {

            BinlFreeMemory( fileEntry->DestFile.Buffer );
        }

        BinlFreeMemory( fileEntry );
    }

    if (pInfEntry->DriverName != NULL) {

        BinlFreeMemory( pInfEntry->DriverName );
    }

    if (pInfEntry->ServiceName != NULL) {

        BinlFreeMemory( pInfEntry->ServiceName );
    }

    //
    //  if the section name is the same as the extended section name, then
    //  they will be the same pointer.  let's not free it twice.
    //

    if (pInfEntry->SectionNameExt != NULL &&
        pInfEntry->SectionNameExt != pInfEntry->SectionName) {

        BinlFreeMemory( pInfEntry->SectionNameExt );
    }

    if (pInfEntry->SectionName != NULL) {

        BinlFreeMemory( pInfEntry->SectionName );
    }

    if (pInfEntry->HardwareId != NULL) {

        BinlFreeMemory( pInfEntry->HardwareId );
    }

    if (pInfEntry->DriverDescription != NULL) {

        BinlFreeMemory( pInfEntry->DriverDescription );
    }

    BinlFreeMemory( pInfEntry );

    return;
}


ULONG
FindNetcardInfo (
    PNETCARD_INF_BLOCK pNetCards,
    ULONG CardInfoVersion,
    NET_CARD_INFO UNALIGNED * CardIdentity,
    PNETCARD_RESPONSE_DATABASE *pInfEntry
    )
/*++

Routine Description:

    This function searches the drivers we've found and returns a pointer to
    an entry that most closely matches the client's request.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

       The NetCards structure has been referenced by the caller of this
       API and won't be going away from under us!

    CardInfoVersion - Version of the structure passed by the client.

    CardIdentity - has the values the app is looking for.  we try our best to
        find one that matches.

    pInfEntry - the entry that was found if successful. NULL if in error.

Return Value:

    ERROR_SUCCESS, ERROR_NOT_ENOUGH_MEMORY, or ERROR_NOT_SUPPORTED

--*/
{
    ULONG err;
    PWCHAR listOfPossibleCardIdentifiers = NULL;
    PWCHAR searchString;
    PNETCARD_RESPONSE_DATABASE pEntry = NULL;

    *pInfEntry = NULL;

    if (CardInfoVersion != OSCPKT_NETCARD_REQUEST_VERSION) {

        BinlPrint(( DEBUG_NETINF, "Not supporting CardInfoVersion %u\n", CardInfoVersion ));
        return ERROR_NOT_SUPPORTED;
    }

    err = CreateListOfCardIdentifiers( CardIdentity,
                                       &listOfPossibleCardIdentifiers );

    if (err != ERROR_SUCCESS) {

        goto exitFind;
    }
    BinlAssert( listOfPossibleCardIdentifiers != NULL);

    //
    //  The search strings are ordered from most specific to least specific
    //  so we have to search for them ordered top to bottom.
    //

    searchString = listOfPossibleCardIdentifiers;

    while (*searchString != L'\0') {

        PLIST_ENTRY listEntry;
        PLIST_ENTRY listHead;
        ULONG hwLength = wcslen( searchString );
        ULONG hashValue;

        COMPUTE_STRING_HASH( searchString, &hashValue );

        listHead = &pNetCards->NetCardEntries[HASH_TO_INF_INDEX(hashValue)];
        listEntry = listHead->Flink;

        while ( listEntry != listHead ) {

            pEntry = (PNETCARD_RESPONSE_DATABASE) CONTAINING_RECORD(
                                                    listEntry,
                                                    NETCARD_RESPONSE_DATABASE,
                                                    NetCardEntry );

            err = CompareStringW( LOCALE_INVARIANT,
                                  0,
                                  searchString,
                                  hwLength,
                                  pEntry->HardwareId,
                                  -1
                                  );
            if (err == 2) {

                break;      // a match was found.
            }

            pEntry = NULL;

            if (err == 3) {

                break;      // it's greater therefore entry isn't present
            }

            listEntry = listEntry->Flink;
        }

        if (pEntry != NULL) {

            // we found one that matches it.  reference it and return

            InterlockedIncrement( &pEntry->ReferenceCount );
            err = ERROR_SUCCESS;
            *pInfEntry = pEntry;
            break;
        }

        searchString += wcslen( searchString ) + 1;  // point to next after null
    }

exitFind:

    if (pEntry == NULL) {

        err = ERROR_NOT_SUPPORTED;

    } else {

        BinlAssert( err == ERROR_SUCCESS );
    }

    if (listOfPossibleCardIdentifiers) {
        BinlFreeMemory( listOfPossibleCardIdentifiers );
    }

    return err;
}

ULONG
CreateListOfCardIdentifiers (
    NET_CARD_INFO UNALIGNED * CardIdentity,
    PWCHAR *CardIdentifiers
    )
/*++

Routine Description:

    This function creates the list of card identifiers for the given card.
    It generates a buffer that looks like this :

    "PCI\VEN_8086&DEV_1229&SUBSYS_00018086&REV_05"
    "PCI\VEN_8086&DEV_1229&SUBSYS_00018086"
    "PCI\VEN_8086&DEV_1229&REV_05"
    "PCI\VEN_8086&DEV_1229"
    empty string

    Note that if we support more than just PCI, we'll have to change this
    function.

Arguments:

    CardIdentity - Holds the values we're looking for that identify this card.

    CardIdentifiers - where we put the resulant strings.

Return Value:

    Windows Error.

--*/
{
    ULONG err = ERROR_SUCCESS;
    ULONG spaceRequired;
    PWCHAR nextField;

    if (CardIdentity->NicType == NETINF_BUS_TYPE_PCI) {

        UCHAR ch;

        WCHAR vendorBuff[5];
        WCHAR deviceBuff[5];
        WCHAR subsysBuff[9];
        WCHAR revBuff[3];

        // "PCI\VEN_8086&DEV_1229&SUBSYS_00018086&REV_05"
        // "PCI\VEN_8086&DEV_1229&SUBSYS_00018086"
        // "PCI\VEN_8086&DEV_1229&REV_05"
        // "PCI\VEN_8086&DEV_1229"

        spaceRequired = ((( sizeof( L"PCI\\1234&1234&" ) - 1 ) +
                          ( sizeof( NETINF_VENDOR_STRING ) - 1 ) +
                          ( sizeof( NETINF_DEVICE_STRING ) - 1 ) ) * 4 +
                         (( sizeof( L"12&" ) - 1 ) +
                          ( sizeof( NETINF_REVISION_STRING ) - 1 ) ) * 2 +
                         (( sizeof( L"12345678&" ) - 1 ) +
                          ( sizeof( NETINF_IOSUBS_STRING ) - 1 )) * 2 );

        spaceRequired += sizeof(WCHAR); // allocate 1 more for trailing null

        *CardIdentifiers = BinlAllocateMemory( spaceRequired );

        if (*CardIdentifiers == NULL) {

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        nextField = *CardIdentifiers;

        //
        //  Convert the numeric values to their char equivalents
        //

        ConvertHexToBuffer( &vendorBuff[0], CardIdentity->pci.Vendor_ID );
        vendorBuff[4] = '\0';
        ConvertHexToBuffer( &deviceBuff[0], CardIdentity->pci.Dev_ID );
        deviceBuff[4] = '\0';

        revBuff[0] = NetInfHexToCharTable[ ( CardIdentity->pci.Rev & 0xF0 ) >> 4 ];
        revBuff[1] = NetInfHexToCharTable[ ( CardIdentity->pci.Rev & 0x0F ) ];
        revBuff[2] = '\0';

        ConvertHexToBuffer( &subsysBuff[0], HIWORD( CardIdentity->pci.Subsys_ID ) );
        ConvertHexToBuffer( &subsysBuff[4], LOWORD( CardIdentity->pci.Subsys_ID ) );
        subsysBuff[8] = '\0';

        //
        //  Now create the strings in most specific to least specific order
        //

        // "PCI\VEN_8086&DEV_1229&SUBSYS_00018086&REV_05"
        wsprintf( nextField, 
                  L"PCI\\" NETINF_VENDOR_STRING L"%ws&" NETINF_DEVICE_STRING L"%ws&" NETINF_IOSUBS_STRING L"%ws&" NETINF_REVISION_STRING L"%ws",
                  vendorBuff, deviceBuff, subsysBuff, revBuff
                  );
        nextField += wcslen( nextField ) + 1;  // point to next after null

        // "PCI\VEN_8086&DEV_1229&SUBSYS_00018086"
        wsprintf( nextField, 
          L"PCI\\" NETINF_VENDOR_STRING L"%ws&" NETINF_DEVICE_STRING L"%ws&" NETINF_IOSUBS_STRING L"%ws",
          vendorBuff, deviceBuff, subsysBuff
          );

        nextField += wcslen( nextField ) + 1;  // point to next after null

        // "PCI\VEN_8086&DEV_1229&REV_05"
        wsprintf( nextField, 
          L"PCI\\" NETINF_VENDOR_STRING L"%ws&" NETINF_DEVICE_STRING L"%ws&" NETINF_REVISION_STRING L"%ws",
          vendorBuff, deviceBuff, revBuff
          );
        nextField += wcslen( nextField ) + 1;  // point to next after null

        // "PCI\VEN_8086&DEV_1229"
        wsprintf( nextField, 
          L"PCI\\" NETINF_VENDOR_STRING L"%ws&" NETINF_DEVICE_STRING L"%ws",
          vendorBuff, deviceBuff
          );

        nextField += wcslen( nextField ) + 1;  // point to next after null

        //
        //  to mark the end of the multi-sz, stick on another null terminator
        //

        *(nextField++) = L'\0';

    } else {

        *CardIdentifiers = NULL;
        err = ERROR_NOT_SUPPORTED;
    }

    return err;
}

VOID
ConvertHexToBuffer(
    PWCHAR Buff,
    USHORT Value
    )
{
    UCHAR ch;

    ch = HIBYTE( Value );
    *(Buff+0) = NetInfHexToCharTable[ ( ch & 0xF0 ) >> 4 ];
    *(Buff+1) = NetInfHexToCharTable[ ( ch & 0x0F ) ];
    ch = LOBYTE( Value );
    *(Buff+2) = NetInfHexToCharTable[ ( ch & 0xF0 ) >> 4 ];
    *(Buff+3) = NetInfHexToCharTable[ ( ch & 0x0F ) ];

    return;
}



ULONG
GetSetupLineWideText (
    PINFCONTEXT InfContext,
    HINF InfHandle,
    PWCHAR Section,
    PWCHAR Key,
    PWCHAR *String,
    PULONG SizeOfAllocation OPTIONAL
    )
{
    ULONG sizeRequired = 0;

    if (SetupGetLineTextW( InfContext,
                           InfHandle,
                           Section,
                           Key,
                           NULL,
                           0,
                           &sizeRequired) == FALSE) {

        return GetLastError();
    }

    if (*String == NULL ||
        SizeOfAllocation == NULL ||
        *SizeOfAllocation < sizeRequired) {

        if (*String != NULL) {
            BinlFreeMemory( *String );
            *String = NULL;
        }

        *String = (PWCHAR) BinlAllocateMemory( sizeRequired * sizeof(WCHAR));

        if (*String == NULL) {

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (SizeOfAllocation != NULL) {
            *SizeOfAllocation = sizeRequired;
        }
    }

    if (SetupGetLineTextW( InfContext,
                           InfHandle,
                           Section,
                           Key,
                           *String,
                           sizeRequired,
                           NULL) == FALSE) {

        return GetLastError();
    }

    return ERROR_SUCCESS;
}

ULONG
GetSetupWideTextField (
    PINFCONTEXT InfContext,
    DWORD  FieldIndex,
    PWCHAR *String,
    PULONG SizeOfAllocation
    )
{
    ULONG sizeRequired = 0;

    if (SetupGetStringFieldW( InfContext,
                              FieldIndex,
                              NULL,
                              0,
                              &sizeRequired) == FALSE) {

        return GetLastError();
    }

    if (*String == NULL ||
        SizeOfAllocation == NULL ||
        *SizeOfAllocation < sizeRequired) {

        if (*String != NULL) {
            BinlFreeMemory( *String );
            *String = NULL;
        }

        *String = (PWCHAR) BinlAllocateMemory( sizeRequired * sizeof(WCHAR));

        if (*String == NULL) {

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (SizeOfAllocation != NULL) {

            *SizeOfAllocation = sizeRequired;
        }
    }

    if (SetupGetStringFieldW( InfContext,
                              FieldIndex,
                              *String,
                              sizeRequired,
                              NULL) == FALSE) {

        return GetLastError();
    }

    return ERROR_SUCCESS;
}


ULONG
CheckHwDescription (
    PWCHAR HardwareID
    )
/*++

Routine Description:

    This function parses the HardwareID field of the driver's detail record
    and determines a) if we can support it and b) fills in all the values.

    Note that if we support more than just PCI, we'll have to change this
    function.

Arguments:

    HardwareID - uppercased hardware id representing the driver's configuration

    Identifiers - the fields we need to fill in.

Return Value:

    ERROR_NOT_SUPPORTED, ERROR_SUCCESS, or ERROR_INVALID_PARAMETER

--*/
{
    ULONG err = ERROR_SUCCESS;
    PWCHAR hwPointer = HardwareID;
    USHORT busType;
    USHORT Vendor;      // Vendor_ID to check
    USHORT Device;      // Dev_ID to check
    ULONG Subsystem;    // Subsys_ID to check
    USHORT Revision;    // Revision to check
    BOOLEAN RevPresent; // Revision present
    BOOLEAN SubPresent; // Subsystem present

    //
    //  for now, PCI is the only one supported.
    //

    if (IsSubString( L"PCI\\", hwPointer, FALSE )) {

        hwPointer += ((sizeof( L"pci\\" )/sizeof(WCHAR)) - 1); // 1 for the null terminator;
        busType = NETINF_BUS_TYPE_PCI;

    } else {

        return ERROR_NOT_SUPPORTED;
    }

    //
    //  we parse the HardwareID as it's passed to us in the
    //  SP_DRVINFO_DETAIL_DATA structure.  It is of the form :
    //
    //  pci\ven_8086&dev_1229&rev_01&subsys_00018086
    //
    //  where the vendor will always be present and the device, revision,
    //  and subsystem may or may not be present.
    //

    if (busType == NETINF_BUS_TYPE_PCI) {

        while (*hwPointer != L'\0') {

            if (IsSubString( NETINF_VENDOR_STRING, hwPointer, FALSE )) {

                hwPointer += ((sizeof(NETINF_VENDOR_STRING)/sizeof(WCHAR)) - 1);

                err = GetHexValueFromHw( &hwPointer, NULL, &Vendor );

                if (err != ERROR_SUCCESS) {
                    goto cardSyntaxError;
                }
            } else if (IsSubString( NETINF_DEVICE_STRING, hwPointer, FALSE )) {

                hwPointer += ((sizeof(NETINF_DEVICE_STRING)/sizeof(WCHAR)) - 1);

                err = GetHexValueFromHw( &hwPointer, NULL, &Device );

                if (err != ERROR_SUCCESS) {
                    goto cardSyntaxError;
                }
            } else if (IsSubString( NETINF_REVISION_STRING, hwPointer, FALSE )) {

                hwPointer += ((sizeof(NETINF_REVISION_STRING)/sizeof(WCHAR)) - 1);

                err = GetHexValueFromHw( &hwPointer, NULL, &Revision );

                if (err != ERROR_SUCCESS) {
                    goto cardSyntaxError;
                }
                RevPresent = TRUE;

            } else if (IsSubString( NETINF_IOSUBS_STRING, hwPointer, FALSE )) {

                hwPointer += ((sizeof(NETINF_IOSUBS_STRING)/sizeof(WCHAR)) - 1);

                err = GetHexValueFromHw( &hwPointer, &Subsystem, NULL);

                if (err != ERROR_SUCCESS) {
                    goto cardSyntaxError;
                }
                SubPresent = TRUE;

            } else {

                //
                //  we hit something else.  hmmm.. bail on this one.
                //

                goto cardSyntaxError;
            }
        }

    } else {

        // we should never get here unless we start supporting ISAPNP,
        // PCMCIA, etc

cardSyntaxError:

        BinlPrint(( DEBUG_NETINF, "Not supporting INF hw string of %S\n", HardwareID ));
        err = ERROR_NOT_SUPPORTED;
    }

    if ((err == ERROR_SUCCESS) &&
        ((Vendor == 0) ||
         (Device == 0))) {

        // both vendor and device are required for it to be valid.

        err = ERROR_NOT_SUPPORTED;
    }

    return err;
}

ULONG
GetHexValueFromHw (
    PWCHAR *String,      // this is updated.
    PULONG longValue,
    PUSHORT shortValue
    )
/*++

Routine Description:

    This function parses a hex integer out of the HardwareID field of
    the driver's detail record.  The string is of the form :

    pci\ven_8086&dev_1229&rev_01&subsys_00018086

    so this routine needs to convert the hex chars to a value.

Arguments:

    String - the input string that we manipulate by moving it to the end of
       the integer (we also move it past the '&' if there is one present.

    longValue - integer that we fill in if it's present

    shortValue - ushort that we fill in if it's present


Return Value:

    ERROR_INVALID_PARAMETER or ERROR_SUCCESS

--*/
{
    PWCHAR targetString = *String;
    ULONG value = 0;
    UCHAR ch;
    UCHAR hexChar;
    ULONG length = 0;
    ULONG maxLength = ( (shortValue != NULL) ?
                        (sizeof(USHORT) * 2) :
                        (sizeof(ULONG) * 2) );

    ch = LOBYTE( *targetString );

    while ((length++ < maxLength) && (ch != '\0') && (ch != '&')) {

        //
        //  convert from the ascii char to it's hex representation
        //

        if (ch >= '0' && ch <= '9') {

            hexChar = ch - '0';

        } else if (ch >= 'A' && ch <= 'F') {

            hexChar = ch - 'A' + 10;

        } else if (ch >= 'a' && ch <= 'f') {

            hexChar = ch - 'a' + 10;

        } else {

            break;
        }

        value = ( value << 4 ) | hexChar;

        targetString++;        // on to the next character
        ch = LOBYTE( *targetString );
    }

    if ((ch != '\0') && (ch != '&')) {

        return ERROR_INVALID_PARAMETER;
    }

    // skip all trailing ampersands... we allow more than one just to be
    // generous

    while (*targetString == L'&') {

        targetString++;
    }

    *String = targetString;

    if (longValue) {

        *longValue = value;
    }

    if (shortValue) {

        *shortValue = LOWORD( value );
    }

    return ERROR_SUCCESS;
}


BOOLEAN
IsSubString (
    PWCHAR subString,
    PWCHAR target,
    BOOLEAN ignoreCase
    )
//
//  our local version of memicmp so as not to pull in full c runtimes.
//
{
    ULONG subStringLength = wcslen( subString );

    if (wcslen( target ) < subStringLength) {

        return FALSE;
    }
    return (CompareStringW( LOCALE_INVARIANT,
                            ignoreCase ? NORM_IGNORECASE : 0,
                            subString,
                            subStringLength,
                            target,
                            subStringLength         // note use same length
                            ) == 2);
}

// infutil.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\message.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    message.c

Abstract:

    This module contains the code to process a BINL request message
    for the BINL server.

Author:

    Colin Watson (colinw)  2-May-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include "binl.h"
#pragma hdrstop

#if DBG
DWORD BinlRepeatSleep;
#endif

const WCHAR IntelOSChooser[] = L"OSChooser\\i386\\startrom.com";
const WCHAR IA64OSChooser[]  = L"OSChooser\\ia64\\oschoice.efi";
WCHAR DefaultNamingContext[] = L"defaultNamingContext";

//  Connection information to a DC in our domain
PLDAP DCLdapHandle = NULL;
PWCHAR * DCBase = NULL;

//  Connection information to the Global Catalog for our enterprise
PLDAP GCLdapHandle = NULL;
PWCHAR * GCBase = NULL;

DWORD
GetGuidFromPacket(
    LPDHCP_MESSAGE DhcpReceiveMessage,
    LPDHCP_SERVER_OPTIONS DhcpOptions,
    OUT PUCHAR Guid,
    OUT PDWORD GuidLength OPTIONAL,
    OUT PMACHINE_INFO *MachineInfo
    );

LPOPTION
AppendClientRequestedParameters(
    DHCP_IP_ADDRESS IpAddress,
    DHCP_IP_ADDRESS SubnetMask,
    LPBYTE RequestedList,
    DWORD ListLength,
    LPOPTION Option,
    LPBYTE OptionEnd,
    CHAR *ClassIdentifier,
    DWORD ClassIdentifierLength,
    BOOL  fSwitchedSubnet
    );

DWORD
RecognizeClient(
    PUCHAR          pGuid,
    PMACHINE_INFO * pMachineInfo,
    DWORD           dwRequestedInfo,
    ULONG           SecondsSinceBoot,
    USHORT          SystemArchitecture
    );

DWORD
GetBootParametersExt(
    PMACHINE_INFO   pMachineInfo,
    DWORD           dwRequestedInfo,
    USHORT          SystemArchitecture,
    BOOL            fGlobal);


VOID
FreeConnection(
    PLDAP * LdapHandle,
    PWCHAR ** Base
    );


DWORD
ProcessMessage(
    LPBINL_REQUEST_CONTEXT RequestContext
    )
/*++

Routine Description:

    This function dispatches the processing of a received BINL message.
    The handler functions will create the response message if necessary.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

Return Value:

    Windows Error.

--*/
{
    DWORD               Error;
    BOOL                fSendResponse,
                        fSubnetsListEmpty,
                        fReadyToTerminate,
                        fAllThreadsBusy;

    DHCP_SERVER_OPTIONS dhcpOptions;
    LPDHCP_MESSAGE      binlReceiveMessage;

    TraceFunc("ProcessMessage( )\n" );


    //
    // Simply ignore messages when the service is paused.
    //

    if( BinlGlobalServiceStatus.dwCurrentState == SERVICE_PAUSED )
    {
        Error = ERROR_BINL_SERVICE_PAUSED;
        goto t_done;
    }

    binlReceiveMessage = (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer;

    //
    // If it is an OSChooser message, then process that separately
    // since they don't conform to the DHCP layout.  This will send
    // any messages that it needs to.
    //

    if (binlReceiveMessage->Operation == OSC_REQUEST)
    {
        Error = OscProcessMessage(RequestContext);
        goto t_done;
    }

    RtlZeroMemory( &dhcpOptions, sizeof( dhcpOptions ) );

    //BinlDumpMessage(DEBUG_MESSAGE, binlReceiveMessage);

    Error = ExtractOptions(
                binlReceiveMessage,
                &dhcpOptions,
                RequestContext->ReceiveMessageSize );

    if( Error != ERROR_SUCCESS ) {
        goto t_done;
    }

    if (!dhcpOptions.MessageType) {
        goto t_done;    //  BOOTP request
    }

#if 0
    if (dhcpOptions.SystemArchitecture 
            != DHCP_OPTION_CLIENT_ARCHITECTURE_X86) {
        BinlPrintDbg((
            DEBUG_OPTIONS,
            "ProcessMessage: Client ignored - unsupported architecture type %d \n",
            dhcpOptions.SystemArchitecture ) );
        goto t_done;
    }
#endif
    
    if ( ( !AnswerRequests ) &&
         ( RequestContext->ActiveEndpoint->Port == DHCP_SERVR_PORT )) {

        //
        //  this is not the 4011 port, therefore it must be the DHCP port.
        //  We're configured to not answer requests on this port right now
        //  therefore we'll toss this packet.
        //

        BinlPrint((DEBUG_OPTIONS, "Client ignored - Not answering requests (AnswerRequests == FALSE)\n" ));
        goto t_done;
    }

    if (BinlGlobalAuthorized == FALSE) {

        BinlPrint((DEBUG_ROGUE, "BINL has not passed rogue detection. Ignoring packet.\n" ));

        //
        //  We'll possibly log an event here since we don't log an event
        //  at startup saying what our rogue state is.
        //

        LogCurrentRogueState( TRUE );
        goto t_done;
    }

    //
    // Dispatch based on Message Type
    //

    RequestContext->MessageType = *dhcpOptions.MessageType;

    switch( *dhcpOptions.MessageType ) {

    case DHCP_DISCOVER_MESSAGE:
        Error = ProcessBinlDiscover( RequestContext, &dhcpOptions );
        fSendResponse = TRUE;
        break;

    case DHCP_INFORM_MESSAGE:
        Error = ProcessBinlInform( RequestContext, &dhcpOptions );
        fSendResponse = TRUE;
        break;

    case DHCP_REQUEST_MESSAGE:
        Error = ProcessBinlRequest( RequestContext, &dhcpOptions );
        fSendResponse = TRUE;
        break;

    default:
        BinlPrintDbg(( DEBUG_STOC,
            "Received a invalid message type, %ld.\n",
                *dhcpOptions.MessageType ));

        Error = ERROR_BINL_INVALID_BINL_MESSAGE;
        break;
    }

    if ( ERROR_SUCCESS == Error && fSendResponse )
    {
        /*
         BinlDumpMessage(
                DEBUG_MESSAGE,
                (LPDHCP_MESSAGE)RequestContext->SendBuffer
                );
        */

        BinlSendMessage( RequestContext );
    }

t_done:

    //
    // delete the context structure for this thread
    //

    BinlFreeMemory( RequestContext->ReceiveBuffer );
    BinlFreeMemory( RequestContext->SendBuffer );
    BinlFreeMemory( RequestContext );

    EnterCriticalSection( &g_ProcessMessageCritSect );

    //
    // Check to see if all worker threads were busy
    //

    fAllThreadsBusy = ( g_cProcessMessageThreads ==
                            g_cMaxProcessingThreads );

    --g_cProcessMessageThreads;

    //
    // Check to see if this is the last worker thread
    //

    fReadyToTerminate = !g_cProcessMessageThreads;

    LeaveCriticalSection( &g_ProcessMessageCritSect );


    //
    // If all the worker threads were busy, then BinlProcessingLoop
    // is waiting for a thread to complete.  Set BinlGlobalRecvEvent
    // so BinlProcessingLoop can continue.
    //

    if ( fAllThreadsBusy )
    {
        BinlPrintDbg( ( DEBUG_STOC,
                    "ProcessMessage: Alerting BinlProcessingLoop\n" )
                    );

        SetEvent( BinlGlobalRecvEvent );
    }

    if ( fReadyToTerminate &&
         WaitForSingleObject( BinlGlobalProcessTerminationEvent,
                              0 ) == WAIT_OBJECT_0 )
    {
        //
        // there are no other ProcessMessage threads running, and
        // the service is waiting to shutdown.
        //

        BinlPrintDbg( (DEBUG_MISC,
                    "ProcessMessage: shutdown complete.\n" )
                 );

        BinlAssert( g_hevtProcessMessageComplete );
        SetEvent( g_hevtProcessMessageComplete );
    }

    //
    // thread exit
    //

    BinlPrintDbg( ( DEBUG_STOC,
                "ProcessMessage exited\n" )
                );

    return Error;
}

DWORD
GetGuidFromPacket(
    LPDHCP_MESSAGE DhcpReceiveMessage,
    LPDHCP_SERVER_OPTIONS DhcpOptions,
    OUT PUCHAR Guid,
    OUT PDWORD GuidLength OPTIONAL,
    OUT PMACHINE_INFO *MachineInfo
    )
/*++

Routine Description:

    This routine reads the guid from the client's packet (they send 
    us their guid). After obtaining their guid, we attempt to 
    recognize the client by querying the DS with the guid.  If 
    found, MachineInfo will be returned with the information 
    requested, otherwise if we are accepting new clients we 
    may create the entry ourselves.  otherwise, we just fail.

Arguments:

    DhcpReceiveMessage - a pointer to the message received from the client
    
    DhcpOptions - a pointer to the DHCP options gotton from the end of the 
                  message the client sent
                  
    Guid - a pointer to memory for the guid to be copied to
    
    GuidLength - a pointer to a dword to copy the guid length to
    
    MachineInfo - a pointer to memory for us to client machine
                  information to.  if we fail, this could be
                  returned as null.

Return Value:

    Windows Error.

--*/
{
    DWORD gLength = BINL_GUID_LENGTH;
    const LONG AllFs[] = { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };
    const LONG AllZeros[] = { 0x0, 0x0, 0x0, 0x0 };
    DWORD err;
    ULONG SecondsSinceBoot;
    DWORD bytesToCopy = 0;

    TraceFunc("GetGuidFromPacket( )\n" );

    BinlAssert(sizeof(AllZeros) == BINL_GUID_LENGTH );
    BinlAssert(sizeof(AllFs) == BINL_GUID_LENGTH);

    if (DhcpOptions->GuidLength == 0) {
useNicAddress:
        memset(Guid, 0x0, BINL_GUID_LENGTH);
        if (DhcpReceiveMessage->HardwareAddressLength > BINL_GUID_LENGTH) {
            bytesToCopy = BINL_GUID_LENGTH;
        } else {
            bytesToCopy = DhcpReceiveMessage->HardwareAddressLength;
        }
        memcpy(Guid + BINL_GUID_LENGTH - bytesToCopy,
               DhcpReceiveMessage->HardwareAddress,
               bytesToCopy
              );
    } else {
        if (DhcpOptions->GuidLength > BINL_GUID_LENGTH) {
            memcpy(Guid, DhcpOptions->Guid + DhcpOptions->GuidLength - BINL_GUID_LENGTH, BINL_GUID_LENGTH);
        } else {
            gLength = DhcpOptions->GuidLength;
            memcpy(Guid, DhcpOptions->Guid, gLength);
        }
        if (!memcmp(Guid, (PUCHAR)AllFs, BINL_GUID_LENGTH) ||
            !memcmp(Guid, (PUCHAR)AllZeros, BINL_GUID_LENGTH)) {

            //
            //  if they specified all 00s or all FFs, use the NIC address.
            //

            goto useNicAddress;
        }
    }

    if (GuidLength) {
        *GuidLength = (bytesToCopy) ? bytesToCopy : gLength;
    }

    //
    //  we return STATUS_SUCCESS if we can handle this client.
    //
    //  If a cache entry is found here, then it will be marked as InProgress as
    //  a side effect of finding it.  We need to call BinlDoneWithCacheEntry
    //  when we're done with the entry.
    //
    //  SecondsSinceBoot may have been sent on the network in network order.
    //  To correct this we assume the lower of the two bytes is the high byte.
    //  So if the high byte is more than the low one, we flip them.
    //

    SecondsSinceBoot = DhcpReceiveMessage->SecondsSinceBoot;
    if ((SecondsSinceBoot >> 8) > (SecondsSinceBoot % 256)) {
        SecondsSinceBoot = (SecondsSinceBoot >> 8) +
                        ((SecondsSinceBoot % 256) << 8);
    }

    err = RecognizeClient(  Guid,
                            MachineInfo,
                            MI_HOSTNAME | MI_BOOTFILENAME,
                            SecondsSinceBoot,
                            DhcpOptions->SystemArchitecture );

    if ( err == ERROR_BINL_INVALID_GUID ) {
        PWCHAR pwch;
        WCHAR Buffer[6];

        //
        // Log an event with the hardware address of the offending client
        //
        pwch = (PWCHAR)BinlAllocateMemory( (( (sizeof(Buffer)/sizeof(Buffer[0])) - 1 ) * 
                                           DhcpReceiveMessage->HardwareAddressLength + 1 ) * 
                                           sizeof(WCHAR));

        if (pwch != NULL) {
            INT i;

            *pwch = UNICODE_NULL;
            for (i=0 ; i < DhcpReceiveMessage->HardwareAddressLength; i++) {
                swprintf(Buffer, L" 0x%2x", (ULONG)(DhcpReceiveMessage->HardwareAddress[i]));
                wcscat(pwch, Buffer);
            }

            BinlReportEventW(EVENT_SERVER_CLIENT_WITHOUT_GUID,
                             EVENTLOG_INFORMATION_TYPE,
                             1,
                             0,
                             &pwch,
                             NULL
                            );

            BinlFreeMemory( pwch );
        }
    }
    return err;
}

DWORD
ProcessBinlDiscoverInDhcp(
    LPDHCP_MESSAGE DhcpReceiveMessage,
    LPDHCP_SERVER_OPTIONS DhcpOptions
    )
/*++

Routine Description:

    this is a callback routine for a binl discover
    will call GetGuidFromPacket which is start the 
    discovery process for the client.  

Arguments:

    DhcpReceiveMessage - a pointer to the packet received from 
                         the client.

    dhcpOptions - options extracted from the end of the request 

Return Value:

    Windows Error.

--*/
{
    DWORD Error;
    UCHAR Guid[BINL_GUID_LENGTH];
    PMACHINE_INFO machineInfo = NULL;

    TraceFunc("ProcessBinlDiscoverInDhcp( )\n" );

    if ( !AnswerRequests ) {
        BinlPrint((DEBUG_OPTIONS, "Client ignored - Not answering requests (AnswerRequests == FALSE)\n" ));
        return ERROR_BINL_INVALID_BINL_CLIENT;
    }

    if (BinlGlobalAuthorized == FALSE) {

        BinlPrint((DEBUG_ROGUE, "BINL has not passed rogue detection. Ignoring packet.\n" ));

        //
        //  We'll possibly log an event here since we don't log an event
        //  at startup saying what our rogue state is.
        //

        LogCurrentRogueState( TRUE );
        return ERROR_BINL_INVALID_BINL_CLIENT;
    }

    //
    //  If a cacheEntry is found here, then it will be marked as InProgress as
    //  a side effect of finding it.  We need to call BinlDoneWithCacheEntry
    //  when we're done with the entry.
    //

    Error = GetGuidFromPacket(  DhcpReceiveMessage,
                                DhcpOptions,
                                Guid,
                                NULL,
                                &machineInfo
                                );
    if (machineInfo != NULL) {

        BinlDoneWithCacheEntry( machineInfo, FALSE );
    }

    if( Error != ERROR_SUCCESS ) {
        BinlPrint(( DEBUG_STOC, "BinlDiscover failed with Dhcp server, 0x%x\n", Error ));
    }

    return( Error );
}


DWORD
ProcessBinlDiscover(
    LPBINL_REQUEST_CONTEXT RequestContext,
    LPDHCP_SERVER_OPTIONS DhcpOptions
    )
/*++

Routine Description:

    This function will create the response message if necessary.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

    dhcpOptions - Interesting options extracted from the request.

Return Value:

    Windows Error.

--*/
{
    DWORD Error;
    LPDHCP_MESSAGE dhcpReceiveMessage;
    LPDHCP_MESSAGE dhcpSendMessage;

    BYTE messageType;

    LPOPTION Option;
    LPBYTE OptionEnd;

    PMACHINE_INFO pMachineInfo = NULL;
    UCHAR Guid[ BINL_GUID_LENGTH ];
    DHCP_IP_ADDRESS ipaddr;

    TraceFunc("ProcessBinlDiscover( )\n" );

    dhcpReceiveMessage = (LPDHCP_MESSAGE) RequestContext->ReceiveBuffer;

    // 
    // get our ip address. later we will append this to the sender's
    // message, that way all communication after this is unicast.
    //
    
    ipaddr = BinlGetMyNetworkAddress( RequestContext );

    if ( ipaddr == 0 ) {

        Error = ERROR_BINL_INVALID_BINL_CLIENT;
        goto Cleanup;
    }

    //
    // If the client specified a server identifier option, we should
    // drop this packet unless the identified server is this one.
    //
    if ( DhcpOptions->Server != NULL ) {

        if (*DhcpOptions->Server != ipaddr) {

            Error = ERROR_BINL_INVALID_BINL_CLIENT;
            goto Cleanup;
        }
    }

    //
    //  If a cacheEntry is found here, then it will be marked as InProgress as
    //  a side effect of finding it.  We need to call BinlDoneWithCacheEntry
    //  when we're done with the entry.
    //

    Error = GetGuidFromPacket(  dhcpReceiveMessage,
                                DhcpOptions,
                                Guid,
                                NULL,
                                &pMachineInfo
                                );
    if (Error != ERROR_SUCCESS) {
        goto Cleanup;
    }

    //
    // Generate and send a reply.
    //

    dhcpReceiveMessage->BootFileName[ BOOT_FILE_SIZE - 1 ] = '\0';

    dhcpSendMessage = (LPDHCP_MESSAGE) RequestContext->SendBuffer;
    RtlZeroMemory( RequestContext->SendBuffer, DHCP_SEND_MESSAGE_SIZE );

    dhcpSendMessage->Operation = BOOT_REPLY;
    dhcpSendMessage->TransactionID = dhcpReceiveMessage->TransactionID;
    dhcpSendMessage->ClientIpAddress = dhcpReceiveMessage->ClientIpAddress;
    dhcpSendMessage->YourIpAddress = dhcpReceiveMessage->YourIpAddress;

    if (pMachineInfo != NULL && pMachineInfo->HostAddress != 0) {

        dhcpSendMessage->BootstrapServerAddress = pMachineInfo->HostAddress;

    } else {

        dhcpSendMessage->BootstrapServerAddress = ipaddr;
    }

    dhcpSendMessage->RelayAgentIpAddress = dhcpReceiveMessage->RelayAgentIpAddress;
    dhcpSendMessage->Reserved = dhcpReceiveMessage->Reserved;

    dhcpSendMessage->HardwareAddressType = dhcpReceiveMessage->HardwareAddressType;
    dhcpSendMessage->HardwareAddressLength = dhcpReceiveMessage->HardwareAddressLength;
    RtlCopyMemory(dhcpSendMessage->HardwareAddress,
                    dhcpReceiveMessage->HardwareAddress,
                    dhcpReceiveMessage->HardwareAddressLength );

    Option = &dhcpSendMessage->Option;
    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    Option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) Option, OptionEnd );

    //
    // Append OPTIONS.
    //

    messageType = DHCP_OFFER_MESSAGE;
    Option = DhcpAppendOption(
                 Option,
                 OPTION_MESSAGE_TYPE,
                 &messageType,
                 1,
                 OptionEnd
                 );

    Option = DhcpAppendOption(
                 Option,
                 OPTION_SERVER_IDENTIFIER,
                 &ipaddr,
                 sizeof(ipaddr),
                 OptionEnd );

    Option = DhcpAppendOption(
                Option,
                OPTION_CLIENT_CLASS_INFO,
                "PXEClient",
                9,
                OptionEnd
                );

    //
    // Finally, add client requested parameters.
    //

    if ( DhcpOptions->ParameterRequestList != NULL ) {

        Option = AppendClientRequestedParameters(
                    0,
                    0,
                    DhcpOptions->ParameterRequestList,
                    DhcpOptions->ParameterRequestListLength,
                    Option,
                    OptionEnd,
                    DhcpOptions->ClassIdentifier,
                    DhcpOptions->ClassIdentifierLength,
                    FALSE
                    );
    }

    Option = DhcpAppendOption(
                 Option,
                 OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    RequestContext->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);
    BinlAssert( RequestContext->SendMessageSize <= DHCP_SEND_MESSAGE_SIZE );

    Error = ERROR_SUCCESS;

Cleanup:
    if ( pMachineInfo ) {
        BinlDoneWithCacheEntry( pMachineInfo, FALSE );
    }

    if( Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_STOC, "!! Error 0x%08x - DhcpDiscover failed.\n", Error ));
    }

    return( Error );
}

DWORD
ProcessBinlRequestInDhcp(
    LPDHCP_MESSAGE DhcpReceiveMessage,
    LPDHCP_SERVER_OPTIONS DhcpOptions,
    PCHAR HostName,
    PCHAR BootFileName,
    DHCP_IP_ADDRESS *BootstrapServerAddress,
    LPOPTION *Option,
    PBYTE OptionEnd
    )
/*++

Routine Description:

    This function will create the response message if necessary.

Arguments:

    dhcpOptions - Interesting options extracted from the request.

Return Value:

    Windows Error.

--*/
{
    DWORD Error;
    PMACHINE_INFO pMachineInfo = NULL;
    BOOLEAN includePXE = TRUE;
    DHCP_IP_ADDRESS ipaddr;

    UCHAR Guid[BINL_GUID_LENGTH];
    DWORD GuidLength;

    TraceFunc("ProcessBinlRequestInDhcp( )\n" );

    if ( !AnswerRequests ) {
        BinlPrint((DEBUG_OPTIONS, "Client ignored - Not answering requests (AnswerRequests == FALSE)\n" ));
        return ERROR_BINL_INVALID_BINL_CLIENT;
    }

    if (BinlGlobalAuthorized == FALSE) {

        BinlPrint((DEBUG_ROGUE, "BINL has not passed rogue detection. Ignoring packet.\n" ));

        //
        //  We'll possibly log an event here since we don't log an event
        //  at startup saying what our rogue state is.
        //

        LogCurrentRogueState( TRUE );
        return ERROR_BINL_INVALID_BINL_CLIENT;
    }

    //
    //  If a cache entry is found here, then it will be marked as InProgress as
    //  a side effect of finding it.  We need to call BinlDoneWithCacheEntry
    //  when we're done with the entry.
    //

    Error = GetGuidFromPacket(  DhcpReceiveMessage,
                                DhcpOptions,
                                Guid,
                                &GuidLength,
                                &pMachineInfo
                                );

    if (Error != ERROR_SUCCESS) {
        goto Cleanup;
    }

    if (pMachineInfo->HostName == NULL) {
        Error = ERROR_BINL_INVALID_BINL_CLIENT;
        goto Cleanup;
    }

    if (!BinlUnicodeToAnsi(pMachineInfo->HostName,HostName,BOOT_SERVER_SIZE)) {
        Error = ERROR_BINL_INVALID_BINL_CLIENT;
        goto Cleanup;
    }

    if (!BinlUnicodeToAnsi(pMachineInfo->BootFileName,BootFileName,BOOT_FILE_SIZE)) {
        Error = ERROR_BINL_INVALID_BINL_CLIENT;
        goto Cleanup;
    }   

    BinlPrintDbg(( DEBUG_MISC, "HostName: %s\n", HostName ));
    BinlPrintDbg(( DEBUG_MISC, "BootFileName: %s\n", BootFileName ));

    //
    //  if the server is our own, then the machineInfo->HostAddress will be
    //  0 and the DHCP server will fill in the correct one for us so long as
    //  we return success.
    //

    memcpy( BootstrapServerAddress,
            &pMachineInfo->HostAddress,
            sizeof( DHCP_IP_ADDRESS ) );

    if (DhcpOptions->GuidLength != 0) {
        *Option = DhcpAppendOption(
                     *Option,
                     OPTION_CLIENT_GUID,
                     DhcpOptions->Guid,
                     DhcpOptions->GuidLength,
                     OptionEnd );
    } else {
        UCHAR TmpBuffer[17];

        TmpBuffer[0] = '\0';
        memcpy(TmpBuffer + 1, Guid, GuidLength);
        *Option = DhcpAppendOption(
                     *Option,
                     OPTION_CLIENT_GUID,
                     TmpBuffer,
                     17,
                     OptionEnd );

    }

    //
    //  check if OPTION_CLIENT_CLASS_INFO is already specified, if so, then
    //  don't put PXEClient in again
    //

    if (DhcpOptions->ParameterRequestList != NULL) {

        LPBYTE requestList = DhcpOptions->ParameterRequestList;
        ULONG listLength = DhcpOptions->ParameterRequestListLength;

        while (listLength > 0) {

            if (*requestList == OPTION_CLIENT_CLASS_INFO) {

                includePXE = FALSE;
                break;
            }
            listLength--;
            requestList++;
        }
    }

    if (includePXE) {

        *Option = DhcpAppendOption(
                    *Option,
                    OPTION_CLIENT_CLASS_INFO,
                    "PXEClient",
                    9,
                    OptionEnd
                    );
    }
    Error = ERROR_SUCCESS;

Cleanup:

    if (pMachineInfo != NULL) {

        BinlDoneWithCacheEntry( pMachineInfo, FALSE );
    }

    if( Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_STOC, "!! Error 0x%08x - BINL Request failed.\n", Error ));
    }

    return( Error );
}


DWORD
ProcessBinlRequest(
    LPBINL_REQUEST_CONTEXT RequestContext,
    LPDHCP_SERVER_OPTIONS DhcpOptions
    )
/*++

Routine Description:

    This function will create the response message if necessary.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

    dhcpOptions - Interesting options extracted from the request.

Return Value:

    Windows Error.

--*/
{
    DWORD Error;
    LPDHCP_MESSAGE dhcpReceiveMessage;
    LPDHCP_MESSAGE dhcpSendMessage;

    BYTE messageType;

    LPOPTION Option;
    LPBYTE OptionEnd;

    PMACHINE_INFO pMachineInfo = NULL;
    UCHAR Guid[ BINL_GUID_LENGTH ];

    DHCP_IP_ADDRESS ipaddr;
    DHCP_IP_ADDRESS boostrapIpAddr;

    TraceFunc("ProcessBinlRequest( )\n" );

#if DBG
    if ( BinlRepeatSleep )
    {
        BinlPrintDbg((DEBUG_STOC, "Delay response %u milliseconds.\n", BinlRepeatSleep ));
        Sleep( BinlRepeatSleep );
        BinlPrintDbg((DEBUG_STOC, "Awakening from sleep...\n" ));
    }
#endif // DBG

    dhcpReceiveMessage = (LPDHCP_MESSAGE) RequestContext->ReceiveBuffer;

    //
    // If the client specified a server identifier option, we should
    // drop this packet unless the identified server is this one.
    //

    ipaddr = BinlGetMyNetworkAddress( RequestContext );

    if ( ipaddr == 0 ) {

        Error = ERROR_BINL_INVALID_BINL_CLIENT;
        goto Cleanup;
    }

    if ( DhcpOptions->Server != NULL ) {

        if ( *DhcpOptions->Server != ipaddr ) {

            Error = ERROR_BINL_INVALID_BINL_CLIENT;
            goto Cleanup;
        }
    }

    //
    //  If a cacheEntry is found here, then it will be marked as InProgress as
    //  a side effect of finding it.  We need to call BinlDoneWithCacheEntry
    //  when we're done with the entry.
    //

    Error = GetGuidFromPacket(  dhcpReceiveMessage,
                                DhcpOptions,
                                Guid,
                                NULL,
                                &pMachineInfo
                                );
    if (Error != ERROR_SUCCESS) {
        goto Cleanup;
    }

    //
    // Generate and send a reply.
    //

    dhcpReceiveMessage->BootFileName[ BOOT_FILE_SIZE - 1 ] = '\0';

    dhcpSendMessage = (LPDHCP_MESSAGE) RequestContext->SendBuffer;
    RtlZeroMemory( RequestContext->SendBuffer, DHCP_SEND_MESSAGE_SIZE );

    dhcpSendMessage->Operation = BOOT_REPLY;
    dhcpSendMessage->TransactionID = dhcpReceiveMessage->TransactionID;
    dhcpSendMessage->ClientIpAddress = dhcpReceiveMessage->ClientIpAddress;
    dhcpSendMessage->YourIpAddress = dhcpReceiveMessage->YourIpAddress;

    dhcpSendMessage->RelayAgentIpAddress = dhcpReceiveMessage->RelayAgentIpAddress;
    dhcpSendMessage->Reserved = dhcpReceiveMessage->Reserved;

    dhcpSendMessage->HardwareAddressType = dhcpReceiveMessage->HardwareAddressType;
    dhcpSendMessage->HardwareAddressLength = dhcpReceiveMessage->HardwareAddressLength;
    RtlCopyMemory(dhcpSendMessage->HardwareAddress,
                    dhcpReceiveMessage->HardwareAddress,
                    min(dhcpReceiveMessage->HardwareAddressLength, sizeof(dhcpSendMessage->HardwareAddress)) );

    if (pMachineInfo->HostName == NULL) {
        Error = ERROR_BINL_INVALID_BINL_CLIENT;
        goto Cleanup;
    }

    // Comparing BYTE count to CHAR count
    BinlAssert( sizeof( dhcpSendMessage->HostName ) >= wcslen( pMachineInfo->HostName ) );
    BinlAssert( sizeof( dhcpSendMessage->BootFileName ) >= wcslen( pMachineInfo->BootFileName ) );

    if (!BinlUnicodeToAnsi(pMachineInfo->HostName,dhcpSendMessage->HostName,BOOT_SERVER_SIZE)) {
        Error = ERROR_BINL_INVALID_BINL_CLIENT;
        goto Cleanup;
    }

    if (!BinlUnicodeToAnsi(pMachineInfo->BootFileName,dhcpSendMessage->BootFileName,BOOT_FILE_SIZE)) {
        Error = ERROR_BINL_INVALID_BINL_CLIENT;
        goto Cleanup;
    }   
    
    //
    //  if the machineinfo->HostAddress is zero, then that means the hostname
    //  is the same as ours.  we therefore slap in our own ipaddress in.
    //

    boostrapIpAddr = pMachineInfo->HostAddress;

    if (boostrapIpAddr == 0) {

        boostrapIpAddr = ipaddr;
    }

    dhcpSendMessage->BootstrapServerAddress = boostrapIpAddr;

    BinlPrintDbg(( DEBUG_MISC, "HostName: %s\n", dhcpSendMessage->HostName ));
    BinlPrintDbg(( DEBUG_MISC, "HostAddress: %u.%u.%u.%u\n",
        dhcpSendMessage->BootstrapServerAddress & 0xFF,
        (dhcpSendMessage->BootstrapServerAddress >> 8) & 0xFF,
        (dhcpSendMessage->BootstrapServerAddress >> 16) & 0xFF,
        (dhcpSendMessage->BootstrapServerAddress >> 24) & 0xFF ));
    BinlPrintDbg(( DEBUG_MISC, "BootFileName: %s\n", dhcpSendMessage->BootFileName ));

    Option = &dhcpSendMessage->Option;
    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    Option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) Option, OptionEnd );

    //
    // Append OPTIONS.
    //

    messageType = DHCP_ACK_MESSAGE;
    Option = DhcpAppendOption(
                 Option,
                 OPTION_MESSAGE_TYPE,
                 &messageType,
                 1,
                 OptionEnd
                 );

    Option = DhcpAppendOption(
                 Option,
                 OPTION_SERVER_IDENTIFIER,
                 &ipaddr,
                 sizeof(ipaddr),
                 OptionEnd );

    if (DhcpOptions->GuidLength != 0) {
        Option = DhcpAppendOption(
                     Option,
                     OPTION_CLIENT_GUID,
                     DhcpOptions->Guid,
                     (UCHAR)DhcpOptions->GuidLength,
                     OptionEnd );
    } else {
        UCHAR TmpBuffer[BINL_GUID_LENGTH + 1];

        TmpBuffer[0] = '\0';
        memcpy(TmpBuffer + 1, pMachineInfo->Guid, BINL_GUID_LENGTH);
        Option = DhcpAppendOption(
                     Option,
                     OPTION_CLIENT_GUID,
                     TmpBuffer,
                     sizeof(TmpBuffer),
                     OptionEnd );

    }

    Option = DhcpAppendOption(
                Option,
                OPTION_CLIENT_CLASS_INFO,
                "PXEClient",
                9,
                OptionEnd
                );

    //
    // Finally, add client requested parameters.
    //

    if ( DhcpOptions->ParameterRequestList != NULL ) {

        Option = AppendClientRequestedParameters(
                    0,
                    0,
                    DhcpOptions->ParameterRequestList,
                    DhcpOptions->ParameterRequestListLength,
                    Option,
                    OptionEnd,
                    DhcpOptions->ClassIdentifier,
                    DhcpOptions->ClassIdentifierLength,
                    FALSE
                    );
    }

    Option = DhcpAppendOption(
                 Option,
                 OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    RequestContext->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);
    BinlAssert( RequestContext->SendMessageSize <= DHCP_SEND_MESSAGE_SIZE );

    Error = ERROR_SUCCESS;

Cleanup:
    if ( pMachineInfo ) {
        BinlDoneWithCacheEntry( pMachineInfo, FALSE );
    }

    if( Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_STOC, "!! Error 0x%08x - BINL Request failed.\n", Error ));
    }

    return( Error );
}

DWORD
ProcessBinlInform(
    IN      LPBINL_REQUEST_CONTEXT RequestContext,
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions
    )
/*++

Routine Description:

    This function will create the response message to the inform packet iff
    the query is asking for our domain name.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

    dhcpOptions - Interesting options extracted from the request.

Return Value:

    Windows Error.

--*/
{
    DWORD       Error;
    LPDHCP_MESSAGE dhcpReceiveMessage;
    LPDHCP_MESSAGE dhcpSendMessage;
    LPOPTION    Option;
    LPBYTE      OptionEnd;
    PCHAR       domain = NULL;
    DHCP_IP_ADDRESS ipaddr;

    TraceFunc("ProcessBinlInform( )\n" );

    dhcpReceiveMessage  = (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer;
    dhcpSendMessage     = (LPDHCP_MESSAGE)RequestContext->SendBuffer;

    ipaddr = BinlGetMyNetworkAddress( RequestContext );

    if ( ipaddr == 0 ) {

        Error = ERROR_BINL_INVALID_BINL_CLIENT;
        goto exit_inform;
    }

    if ( ! DhcpOptions->DSDomainNameRequested ) {

        BinlPrintDbg((DEBUG_STOC, "Ignoring inform as no domain name option present.\n"));
        Error = ERROR_BINL_INVALID_BINL_CLIENT;
        goto exit_inform;
    }

    domain = GetDhcpDomainName();

    if (domain == NULL) {

        BinlPrintDbg((DEBUG_STOC, "Couldn't get domain name!\n"));
        Error = ERROR_BINL_INVALID_BINL_CLIENT;
        goto exit_inform;
    }

    // if the client IP address is not zero, we may AV in dhcpssvc because
    // it updates a global counter tracking informs.  Always have this as 0.

    Option = FormatDhcpInformAck(                      // Here come the actual formatting of the ack!
        dhcpReceiveMessage,
        dhcpSendMessage,
        0,              // on a ack to an inform query for name, IP address not needed.
        ipaddr
    );
    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    // our enterprise name was requested, append it

    Option = DhcpAppendEnterpriseName(
        Option,
        domain,
        OptionEnd
    );

    // also, make the server send out a broadcast: if someone is using a bad
    // ipaddr, we should make sure we reach him

    dhcpSendMessage->Reserved = dhcpReceiveMessage->Reserved = htons(DHCP_BROADCAST);

    //
    // Finally, add client requested parameters.
    //

    if ( DhcpOptions->ParameterRequestList != NULL ) {

        Option = AppendClientRequestedParameters(
                    0,
                    0,
                    DhcpOptions->ParameterRequestList,
                    DhcpOptions->ParameterRequestListLength,
                    Option,
                    OptionEnd,
                    DhcpOptions->ClassIdentifier,
                    DhcpOptions->ClassIdentifierLength,
                    FALSE
                    );
    }

    Option = DhcpAppendOption(
        Option,
        OPTION_END,
        NULL,
        0,
        OptionEnd
    );

    RequestContext->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);
    BinlAssert( RequestContext->SendMessageSize <= DHCP_SEND_MESSAGE_SIZE );

    Error = ERROR_SUCCESS;

exit_inform:

    if (domain != NULL) {
        LocalFree( domain );
    }
    return Error;
}

LPOPTION
ConsiderAppendingOption(
    DHCP_IP_ADDRESS IpAddress,
    DHCP_IP_ADDRESS SubnetMask,
    LPOPTION Option,
    BYTE OptionType,
    LPBYTE OptionEnd,
    CHAR *ClassIdentifier,
    DWORD ClassIdentifierLength,
    BOOL  fSwitchedSubnet
    )
/*++

Routine Description:

    This function conditionally appends an option value to a response
    message.  The option is appended if the server has a valid value
    to append.

Arguments:

    IpAddress - The IP address of the client.

    SubnetMask - The subnet mask of the client.

    Option - A pointer to the place in the message buffer to append the
        option.

    OptionType - The option number to consider appending.

    OptionEnd - End of Option Buffer

Return Value:

    A pointer to end of the appended data.

--*/
{
    LPBYTE optionValue = NULL;
    DWORD optionSize;
    DWORD status;
    DWORD dwUnused;

    TraceFunc( "ConsiderAppendingOption( )\n" );

    switch ( OptionType ) {

    //
    // Options already handled.
    //

    case OPTION_SUBNET_MASK:
    case OPTION_REQUESTED_ADDRESS:
    case OPTION_LEASE_TIME:
    case OPTION_OK_TO_OVERLAY:
    case OPTION_MESSAGE_TYPE:
    case OPTION_RENEWAL_TIME:
    case OPTION_REBIND_TIME:
    case OPTION_CLIENT_CLASS_INFO:
    case OPTION_VENDOR_SPEC_INFO:

    //
    // Options it is illegal to ask for.
    //

    case OPTION_PAD:
    case OPTION_PARAMETER_REQUEST_LIST:
    case OPTION_END:

    // Options for DHCP server, not for BINL
    case OPTION_ROUTER_ADDRESS:
        BinlPrintDbg(( DEBUG_ERRORS,
            "Unrecognized option %d\n", OptionType));
        break;

    default:

        break;
    }

    return Option;
}

LPOPTION
AppendClientRequestedParameters(
    DHCP_IP_ADDRESS IpAddress,
    DHCP_IP_ADDRESS SubnetMask,
    LPBYTE RequestedList,
    DWORD ListLength,
    LPOPTION Option,
    LPBYTE OptionEnd,
    CHAR *ClassIdentifier,
    DWORD ClassIdentifierLength,
    BOOL  fSwitchedSubnet
    )
/*++

Routine Description:

Arguments:

Return Value:

    A pointer to the end of appended data.

--*/
{
    while ( ListLength > 0) {
        Option = ConsiderAppendingOption(
                     IpAddress,
                     SubnetMask,
                     Option,
                     *RequestedList,
                     OptionEnd,
                     ClassIdentifier,
                     ClassIdentifierLength,
                     fSwitchedSubnet
                     );
        ListLength--;
        RequestedList++;
    }

    return Option;
}


DWORD
RecognizeClient(
    PUCHAR          pGuid,
    PMACHINE_INFO * ppMachineInfo,
    DWORD           dwRequestedInfo,
    ULONG           SecondsSinceBoot,
    USHORT          SystemArchitecture
    )
/*++

Routine Description:

    This function only return ERROR_SUCCESS if we need to process the message
    from this client.  It may optionally return a cache entry if we actually
    go off to the DS to get the entry.

Arguments:

    Guid - Client identifier, sent to us by them.

    SecondsSinceBoot - from the client.  If we don't know this client and
        this value is small then maybe this client is owned by another BINL
        server. Give the other server time to respond before we send
        OSChooser.

        This gets around the problem (mostly) of two BINL servers that are
        talking to two different DCs with a replication delay between them
        where the client gets sent OSCHOOSER multiple times.

        Alas, if DHCP is running on the same box and we're multihomed, we
        can't delay as that will force the client to go to 4011.  If the
        client does that, then we'll probably return the wrong address.

    ppMachineInfo - what we found.  May be null if we didn't actually go off to
        the DS.
        
    SystemArchitecture - architecture for the client

Return Value:


--*/
{
    HKEY KeyHandle;
    DWORD Error;

    BinlAssertMsg(dwRequestedInfo == (MI_HOSTNAME | MI_BOOTFILENAME),
                  "!! You must modify RecognizeClient() to generate new data\n" );
    BinlAssert(ppMachineInfo);

    TraceFunc( "RecognizeClient( )\n" );

    //
    // Attempt to get the boot parameters. This might fail if
    // the server can't handle any more clients.
    //

    if ( AnswerOnlyValidClients ) {

        //
        //  if we're only responding to existing clients, then call off to
        //  the DS to get the info.
        //

        Error = GetBootParameters( pGuid,
                                   ppMachineInfo,
                                   dwRequestedInfo,
                                   SystemArchitecture,
                                   FALSE );

    } else {

        //
        //  if we are answering new clients but only if it's after a
        //  certain timeout, then call off to the DS to get the info.
        //
        //  Allow OSCHOOSER as a valid response, since AnswerOnlyValidClients is FALSE
        //

        Error = GetBootParameters( pGuid,
                                   ppMachineInfo,
                                   dwRequestedInfo,
                                   SystemArchitecture,
                                   (BOOLEAN) (SecondsSinceBoot >= BinlMinDelayResponseForNewClients) );
    }

    if ( Error == ERROR_SUCCESS ) {

        BinlPrint((DEBUG_OPTIONS, "Recognizing client.\n" ));

        BinlAssert( *ppMachineInfo != NULL );

        if ( (*ppMachineInfo)->MyClient == FALSE ) {

            //
            //  the cache entry is telling us not to handle this client.
            //

            BinlPrint((DEBUG_OPTIONS, "Binl cache entry says not to respond.\n" ));

            Error = ERROR_BINL_INVALID_BINL_CLIENT;

            BinlDoneWithCacheEntry( *ppMachineInfo, FALSE );
            *ppMachineInfo = NULL;
        }
    } else {

        if ( AnswerOnlyValidClients ) {
            BinlPrint((DEBUG_OPTIONS, "Client ignored - Not answering for unknown clients (AnswerOnlyValid TRUE)\n" ));
        } else {
            BinlPrint((DEBUG_OPTIONS, "Client ignored - Not answering requests from boot %u < %u\n",
                                        SecondsSinceBoot,
                                        BinlMinDelayResponseForNewClients
                                        ));
        }
    }

    return Error;
}

DWORD
UpdateAccount(
    PCLIENT_STATE ClientState,
    PMACHINE_INFO pMachineInfo,
    BOOL          fCreate
    )
/*++

Routine Description:

    Create a new computer object. BINL must impersonate the client so that the
    appropriate access checks are performed on the DS.

Arguments:

    LdapHandle   - User credentially created LDAP connection
    pMachineInfo - Information to be used to populate the new MAO

Return Value:

    Win32 error code or ERROR_SUCCESS.

--*/
{
    WCHAR BootFilePath[MAX_PATH];
    ULONG LdapError = LDAP_SUCCESS; // not returned
    DWORD Error = ERROR_SUCCESS;    // this is the returned ERROR_BINL code
    ULONG iModCount, i,q;
    ULONG LdapMessageId;
    ULONG LdapMessageType;
    PLDAPMessage LdapMessage = NULL;
    BOOLEAN Impersonating = FALSE;

    LDAP_BERVAL guid_attr_value;
    PLDAP_BERVAL guid_attr_values[2];
    LDAP_BERVAL password_attr_value;
    PLDAP_BERVAL password_attr_values[2];

    DWORD dwRequiredFlags = MI_SAMNAME
                          | MI_BOOTFILENAME
                          | MI_HOSTNAME
                          | MI_SETUPPATH
                          | MI_PASSWORD;

    PWCHAR attr_values[6][2];            

    PLDAPMod ldap_mods[6];
    LDAPMod SamAccountName;
    LDAPMod ObjectTypeComputer;
    LDAPMod FilePath;
    LDAPMod SetupPathMod;
    LDAPMod UserAccountControl;
    LDAPMod UnicodePwd;
    LDAPMod NicGuid;

    BOOLEAN invalidateCache = FALSE;
    BOOLEAN updateCache = FALSE;

    TraceFunc( "UpdateAccount( )\n" );

    //
    // First impersonate the client.
    //

    Error = OscImpersonate(ClientState);
    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg((DEBUG_ERRORS,
                   "UpdateAccount: OscImpersonate failed %lx\n", Error));
        goto Cleanup;
    }

tryagain:
    Impersonating = TRUE;

    //
    // now initialize all of the properties we want to set on the MAO.
    //

    // Make sure we have all the information we need.
    if ( ! (pMachineInfo->dwFlags & MI_MACHINEDN) ||  pMachineInfo->MachineDN == NULL ) {
        BinlAssertMsg( 0, "Missing the Machine's DN" );
        OscAddVariableA( ClientState, "SUBERROR", "MACHINEDN" );
        Error = ERROR_BINL_MISSING_VARIABLE;
        goto Cleanup;
    }
    BinlAssert( !fCreate || (( pMachineInfo->dwFlags & dwRequiredFlags ) == dwRequiredFlags ) );
#if DBG
    // We must have both of these or none of these.
    // meant to have the !!.  casts the value twice, so it will be a 0 or a 1
    BinlAssert( !(pMachineInfo->dwFlags & MI_HOSTNAME) == !(pMachineInfo->dwFlags & MI_BOOTFILENAME) );
#endif

    iModCount = 0;
     
    if ( AssignNewClientsToServer &&
         (pMachineInfo->dwFlags & (MI_HOSTNAME | MI_BOOTFILENAME)) )
    {
        if ( _snwprintf( BootFilePath,
                         sizeof(BootFilePath) / sizeof(BootFilePath[0]),
                         L"%ws\\%ws",
                         pMachineInfo->HostName,
                         pMachineInfo->BootFileName
                         ) < 0 ) {
            Error = ERROR_BAD_PATHNAME;
            goto Cleanup;
        }
        BootFilePath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe
        attr_values[2][0] = BootFilePath;
        attr_values[2][1] = NULL;
        FilePath.mod_op = 0;
        FilePath.mod_type = L"netbootMachineFilePath";
        FilePath.mod_values = attr_values[2];
        ldap_mods[iModCount++] = &FilePath;

    }

    if ( pMachineInfo->dwFlags & MI_SETUPPATH ) {
        attr_values[3][0] = pMachineInfo->SetupPath;
        attr_values[3][1] = NULL;
        SetupPathMod.mod_op = 0;
        SetupPathMod.mod_type = L"netbootInitialization";
        SetupPathMod.mod_values = attr_values[3];
        ldap_mods[iModCount++] = &SetupPathMod;

    }

    if ( pMachineInfo->dwFlags & MI_GUID ) {
        guid_attr_values[0] = &guid_attr_value;
        guid_attr_values[1] = NULL;
        guid_attr_value.bv_val = pMachineInfo->Guid;
        guid_attr_value.bv_len = BINL_GUID_LENGTH;
        NicGuid.mod_op =    LDAP_MOD_BVALUES;
        NicGuid.mod_type =  L"netbootGUID";
        NicGuid.mod_bvalues = guid_attr_values;
        ldap_mods[iModCount++] = &NicGuid;
        
    }

    if ( fCreate && ( pMachineInfo->dwFlags & MI_SAMNAME ) ) {
        attr_values[0][0] = pMachineInfo->SamName;
        attr_values[0][1] = NULL;
        SamAccountName.mod_op = 0;
        SamAccountName.mod_type = L"sAMAccountName";
        SamAccountName.mod_values = attr_values[0];
        ldap_mods[iModCount++] = &SamAccountName;
    }

    attr_values[4][0] = L"4096";  // 0x1000 -- workstation trust account, enabled
    attr_values[4][1] = NULL;
    UserAccountControl.mod_op = 0;
    UserAccountControl.mod_type = L"userAccountControl";
    UserAccountControl.mod_values = attr_values[4];
    ldap_mods[iModCount++] = &UserAccountControl;

    //
    // if we're creating the MAO, then we need to specify the object type
    // as a computer object
    //
    if ( fCreate ) {
        attr_values[1][0] = L"Computer";
        attr_values[1][1] = NULL;
        ObjectTypeComputer.mod_op = 0;
        ObjectTypeComputer.mod_type = L"objectClass";
        ObjectTypeComputer.mod_values = attr_values[1];
        ldap_mods[iModCount++] = &ObjectTypeComputer;
    }

    //
    // Set the operation type depending on the create or modify flag
    //
    for ( i = 0 ; i < iModCount; i++ )
    {
        if ( fCreate ) {
            ldap_mods[i]->mod_op |= LDAP_MOD_ADD;
        } else {
            ldap_mods[i]->mod_op |= LDAP_MOD_REPLACE;
        }
    }

    ldap_mods[iModCount] = NULL; // terminate list

    //
    // The properties are initialized, so now either create or modify the MAO.
    //
    if ( fCreate || iModCount ) {

        if ( fCreate ) {

            BinlPrintDbg((DEBUG_OSC, "UpdateAccount() Creating a new MAO\n" ));
#if DBG
            for (q = 0;q < iModCount; q++) {
                BinlPrintDbg(( DEBUG_OSC, "LDAP Prop %x: Type: %S  Value: %S",
                               q, 
                               ldap_mods[q]->mod_type,
                               *ldap_mods[q]->mod_vals.modv_strvals ));
            }

#endif


            //
            // synchronously Create the object.
            //     

            LdapMessageId = ldap_add( ClientState->AuthenticatedDCLdapHandle, pMachineInfo->MachineDN, ldap_mods );

            if (LdapMessageId == -1) {
    
                Error = ERROR_BINL_FAILED_TO_CREATE_CLIENT;
                LdapError = LdapGetLastError();
                LogLdapError(   EVENT_WARNING_LDAP_ADD_ERROR,
                                LdapError,
                                ClientState->AuthenticatedDCLdapHandle
                                );
                BinlPrintDbg(( DEBUG_ERRORS,
                    "CreateAccount ldap_add failed %x\n", LdapError));
                goto Cleanup;
            }
    
            LdapMessageType = ldap_result(
                                  ClientState->AuthenticatedDCLdapHandle,
                                  LdapMessageId,
                                  LDAP_MSG_ALL,
                                  &BinlLdapSearchTimeout,
                                  &LdapMessage);
    
            if (LdapMessageType != LDAP_RES_ADD) {
    
                BinlPrintDbg(( DEBUG_ERRORS,
                    "CreateAccount ldap_result returned type %lx\n", LdapMessageType));
                OscAddVariableA( ClientState, "SUBERROR", "Unexpected LDAP error" );
                Error = ERROR_BINL_FAILED_TO_CREATE_CLIENT;
                goto Cleanup;
            }
    
            LdapError = ldap_result2error(
                            ClientState->AuthenticatedDCLdapHandle,
                            LdapMessage,
                            0);
    
            if (LdapError != LDAP_SUCCESS) {

                if ((LdapError != LDAP_ALREADY_EXISTS) && (LdapError != LDAP_INSUFFICIENT_RIGHTS)) {
                    Error = ERROR_BINL_FAILED_TO_CREATE_CLIENT;
                    LogLdapError(   EVENT_WARNING_LDAP_ADD_ERROR,
                                    LdapError,
                                    ClientState->AuthenticatedDCLdapHandle
                                    );
                    BinlPrintDbg(( DEBUG_ERRORS, "!!LdapError 0x%08x - UpdateAccount ldap_add_s( ) failed\n", LdapError));
                    goto Cleanup;
                } else {
                    BinlPrintDbg((DEBUG_OSC, "UpdateAccount() tried to create an existing account.  Try again, but modify existing MAO.\n" ));
                    fCreate = FALSE;
                    goto tryagain;
                }
            }

            updateCache = TRUE;

        } else {
        
            //
            // We don't strictly need to reset the properties below, as the
            // content under the MAO should be static. But it won't really
            // hurt things to try to reset in case something does change.
            //
            // Note that the reset of these properties may not succeed because
            // the user may not have permissions to modify the MAO, depending 
            // on how the admin locks things down. (The admin can use GPO to
            // allow the user to create MAOs but not modify the objects.)
            //
            
            //
            // asynchronously reset the properties
            //

            BinlPrintDbg((DEBUG_OSC, "UpdateAccount() updating existing MAO\n" ));
    
            LdapMessageId = ldap_modify( ClientState->AuthenticatedDCLdapHandle, pMachineInfo->MachineDN, ldap_mods );
    
            if (LdapMessageId == -1) {
    
                Error = ERROR_BINL_FAILED_TO_CREATE_CLIENT;
                LdapError = LdapGetLastError();
                LogLdapError(   EVENT_WARNING_LDAP_MODIFY_ERROR,
                                LdapError,
                                ClientState->AuthenticatedDCLdapHandle
                                );
                BinlPrintDbg(( DEBUG_ERRORS,
                    "UpdateAccount ldap_modify(userAccountControl) failed %x\n", LdapError));
                goto Cleanup;
            }
    
            LdapMessageType = ldap_result(
                                  ClientState->AuthenticatedDCLdapHandle,
                                  LdapMessageId,
                                  LDAP_MSG_ALL,
                                  &BinlLdapSearchTimeout,
                                  &LdapMessage);
    
            if (LdapMessageType != LDAP_RES_MODIFY) {
    
                BinlPrintDbg(( DEBUG_ERRORS,
                    "CreateAccount ldap_result returned type %lx\n", LdapMessageType));
                OscAddVariableA( ClientState, "SUBERROR", "Unexpected LDAP error" );
                Error = ERROR_BINL_FAILED_TO_CREATE_CLIENT;
                goto Cleanup;
            }
    
            LdapError = ldap_result2error(
                            ClientState->AuthenticatedDCLdapHandle,
                            LdapMessage,
                            0);
    
            if (LdapError != LDAP_SUCCESS) {
                LogLdapError(   EVENT_WARNING_LDAP_MODIFY_ERROR,
                                LdapError,
                                ClientState->AuthenticatedDCLdapHandle
                                );
                BinlPrintDbg(( DEBUG_ERRORS, "CreateAccount ldap_result2error failed %x\n", LdapError));
    
                // if the user doesn't have the rights to change
                // the properties then we'll just silently ignore the error
                //  (though we did just log an error for it).                  
                if ( LdapError != LDAP_INSUFFICIENT_RIGHTS) {
                    Error = ERROR_BINL_FAILED_TO_CREATE_CLIENT;
                    goto Cleanup;
                }
                LdapError = LDAP_SUCCESS;
            }
    
            updateCache = TRUE;
        }
    }

    //
    // if we've made it this far, we've got a MAO that's setup properly.  
    // Now we need to reset the account password so the domain join is
    // somewhat secure.
    //
    if ( pMachineInfo->dwFlags & MI_PASSWORD ) {    
#ifdef SET_PASSWORD_WITH_LDAP
        iModCount = 0;
        password_attr_values[0] = &password_attr_value;
        password_attr_values[1] = NULL;
        password_attr_value.bv_val = (PUCHAR) pMachineInfo->Password;
        password_attr_value.bv_len = pMachineInfo->PasswordLength;
        UnicodePwd.mod_op = LDAP_MOD_ADD | LDAP_MOD_BVALUES;    // you always "Add" the "unicodePwd"
        UnicodePwd.mod_type = L"unicodePwd";
        UnicodePwd.mod_bvalues = password_attr_values;
    
        ldap_mods[iModCount++] = &UnicodePwd;
        ldap_mods[iModCount] = NULL;    // terminate list

        LdapError = ldap_modify_s( ClientState->AuthenticatedDCLdapHandle, pMachineInfo->MachineDN, ldap_mods );
    
        if (LdapError != LDAP_SUCCESS) {
            LogLdapError(   EVENT_WARNING_LDAP_MODIFY_ERROR,
                            LdapError,
                            ClientState->AuthenticatedDCLdapHandle
                            );
            BinlPrintDbg(( DEBUG_ERRORS, "!!LdapError 0x%08x - UpdateAccount ldap_modify_s( ) failed\n", LdapError));
            goto Cleanup;
        }    
#else
        //
        // At this point we depend on LdapMessage being valid, which will
        // *not* be the case if we are only setting the password. This
        // breaks machine replacement for the moment.
        //
        BinlAssert( LdapMessage != NULL );
    
        Error = OscUpdatePassword(
                    ClientState,
                    pMachineInfo->SamName,
                    pMachineInfo->Password,
                    ClientState->AuthenticatedDCLdapHandle,
                    LdapMessage);
    
        if (Error != ERROR_SUCCESS) {
            goto Cleanup;
        }
#endif

    }

Cleanup:

    //
    // if the machine name was generated, 
    // then attempt to remove it from the queue
    //
    if (ClientState->fAutomaticMachineName) {
        
        BinlPrintDbg((DEBUG_OSC, "UpdateAccount: removing generated name from Queued DS Names list\n" ));

        Error = RemoveQueuedDSName(pMachineInfo->Name);

        if (Error != ERROR_SUCCESS) {
            
            BinlPrintDbg(( DEBUG_ERRORS, "RemoveQueuedDSName failed: 0x%x\n", Error));
            
            if (Error == ERROR_NOT_FOUND) {
                //
                // TODO: RIS currently has no way to deal with this error
                //       so make it succeed
                //
                Error = ERROR_SUCCESS;
            }
        }
    }

    //
    // Convert the LdapError to a ERROR_BINL and put the LdapError
    // into SUBERROR.
    //
    if ( LdapError != LDAP_SUCCESS )
    {
        OscCreateLDAPSubError( ClientState, LdapError );
        switch ( LdapError )
        {
        case LDAP_ALREADY_EXISTS:
            Error = ERROR_BINL_DUPLICATE_MACHINE_NAME_FOUND;
            break;

        case LDAP_INVALID_DN_SYNTAX:
            Error = ERROR_BINL_INVALID_OR_MISSING_OU;
            break;

        default:
            Error = ERROR_BINL_FAILED_TO_CREATE_CLIENT;
            break;
        }
    }

    if ( updateCache && ( pMachineInfo->dwFlags & MI_GUID ) ) {

        //
        //  update the cached DS information so that it is current.  We do
        //  this because if the account is created in a child domain, we still
        //  have the info cached (even if it hasn't replicated to the GC yet).
        //

        PMACHINE_INFO pCacheEntry = NULL;

        BinlCreateOrFindCacheEntry( pMachineInfo->Guid, TRUE, &pCacheEntry );

        invalidateCache = FALSE;

        // we don't care about the error coming back, only if a record was found.

        if (pCacheEntry != NULL) {

            pCacheEntry->TimeCreated = GetTickCount();
            pCacheEntry->MyClient = TRUE;
            pCacheEntry->EntryExists = TRUE;

            if (pCacheEntry != pMachineInfo) {

                memcpy( &pCacheEntry->HostAddress,
                        &pMachineInfo->HostAddress,
                        sizeof(pMachineInfo->HostAddress));

                if ( pMachineInfo->Name ) {
                    pCacheEntry->Name = BinlStrDup( pMachineInfo->Name );
                    if (!pCacheEntry->Name) {
                        goto noMemory;
                    }
                    pCacheEntry->dwFlags |= MI_NAME_ALLOC | MI_NAME;
                }

                if ( pMachineInfo->MachineDN ) {
                    pCacheEntry->MachineDN = BinlStrDup( pMachineInfo->MachineDN );
                    if (!pCacheEntry->MachineDN) {
                        goto noMemory;
                    }
                    pCacheEntry->dwFlags |= MI_MACHINEDN_ALLOC | MI_MACHINEDN;
                }

                if ( pMachineInfo->SetupPath ) {
                    pCacheEntry->SetupPath = BinlStrDup( pMachineInfo->SetupPath );
                    if (!pCacheEntry->SetupPath) {
                        goto noMemory;
                    }
                    pCacheEntry->dwFlags |= MI_SETUPPATH_ALLOC | MI_SETUPPATH;
                }

                if ( pMachineInfo->HostName ) {
                    pCacheEntry->HostName = BinlStrDup( pMachineInfo->HostName );
                    if (!pCacheEntry->HostName) {
                        goto noMemory;
                    }
                    pCacheEntry->dwFlags |= MI_HOSTNAME_ALLOC | MI_HOSTNAME;
                }

                if ( pMachineInfo->SamName ) {
                    pCacheEntry->SamName = BinlStrDup( pMachineInfo->SamName );
                    if (!pCacheEntry->SamName) {
                        goto noMemory;
                    }
                    pCacheEntry->dwFlags |= MI_SAMNAME_ALLOC | MI_SAMNAME;
                }

                if ( pMachineInfo->Domain ) {
                    pCacheEntry->Domain = BinlStrDup( pMachineInfo->Domain );
                    if (!pCacheEntry->Domain) {
noMemory:
                        invalidateCache = TRUE;
                        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;

                    } else {
                        pCacheEntry->dwFlags |= MI_DOMAIN_ALLOC | MI_DOMAIN;
                    }
                }
            }
            BinlDoneWithCacheEntry( pCacheEntry, invalidateCache );
        }
    }

    if ( invalidateCache && ( pMachineInfo->dwFlags & MI_GUID ) ) {

        //
        //  invalidate the cached DS information if we failed because it's stale.
        //

        PMACHINE_INFO pCacheEntry = NULL;

        BinlCreateOrFindCacheEntry( pMachineInfo->Guid, FALSE, &pCacheEntry );

        // we don't care about the error coming back, only if a record was found.

        if ((pCacheEntry != NULL) &&
            (pCacheEntry != pMachineInfo)) {

            BinlDoneWithCacheEntry( pCacheEntry, TRUE );
        }
    }

    if (LdapMessage != NULL) {
        ldap_msgfree(LdapMessage);
    }

    if (Impersonating) {
        OscRevert(ClientState);
    }

    return Error;
}

DWORD
BinlGenerateNewEntry(
    DWORD                  dwRequestedInfo,
    USHORT                 SystemArchitecture,
    PMACHINE_INFO *        ppMachineInfo )
/*++

Routine Description:

    fills in ppMachineInfo for a new entry if we are currently 
    allowing new clients.

Arguments:

    dwRequestedInfo - a bitmask telling us what parameters we're looking for
    
    SystemArchitecture - architecture of the client

    ppMachineInfo - gets filled in with information requested information

Return Value:

    ERROR_SUCCESS when we succeed.
    otherwise ERROR_BINL_INVALID_BINL_CLIENT if we are not allowing new clients
    or        ERROR_NO_MEMORY if a memory allocation failed
    or        ERROR_BINL_FAILED_TO_INITIALIZE_CLIENT if we did not fill in 
                all the information requested.

--*/
{
    DWORD Error = ERROR_BINL_INVALID_BINL_CLIENT;

    TraceFunc( "BinlGenerateNewEntry( ... )\n" );

    if ( AllowNewClients ) {

        BinlPrint(( DEBUG_OPTIONS, "Server allows new clients" ));

        if ( ( LimitClients == FALSE ) ||
             ( CurrentClientCount < BinlMaxClients ) ) {

            BinlPrint(( DEBUG_OPTIONS, " and the Server is generating the OS Chooser path response.\n" ));

            if ( dwRequestedInfo & MI_HOSTNAME ) {

                if ( (*ppMachineInfo)->dwFlags & MI_HOSTNAME_ALLOC ) {
                    BinlFreeMemory( (*ppMachineInfo)->HostName );
                    (*ppMachineInfo)->HostName = NULL;
                    (*ppMachineInfo)->dwFlags &= ~MI_HOSTNAME_ALLOC;
                }

                EnterCriticalSection( &gcsParameters );
                (*ppMachineInfo)->HostName = BinlStrDup( BinlGlobalOurDnsName );
                LeaveCriticalSection( &gcsParameters );

                if (!(*ppMachineInfo)->HostName) {
                    return (ERROR_OUTOFMEMORY);
                }

                (*ppMachineInfo)->dwFlags |= MI_HOSTNAME_ALLOC;

                (*ppMachineInfo)->dwFlags |= MI_HOSTNAME;
            }

            if ( dwRequestedInfo & MI_BOOTFILENAME ) {
                ULONG ulSize;
                PCWSTR OsChooserName = NULL;
                
                switch ( SystemArchitecture ) {
                    case DHCP_OPTION_CLIENT_ARCHITECTURE_X86:
                        OsChooserName = IntelOSChooser;
                        ulSize = (wcslen(OsChooserName)+1)*sizeof(WCHAR);
                        break;
                    case DHCP_OPTION_CLIENT_ARCHITECTURE_IA64:
                        OsChooserName = IA64OSChooser;
                        ulSize = (wcslen(OsChooserName)+1)*sizeof(WCHAR);
                        break;
                    default:
                        BinlAssertMsg( FALSE, "UnsupportedArchitecture" );
                }

                if (OsChooserName) {
                
                    if ( (*ppMachineInfo)->dwFlags & MI_BOOTFILENAME_ALLOC ) {
                        BinlFreeMemory( (*ppMachineInfo)->BootFileName );
                        (*ppMachineInfo)->dwFlags &= ~MI_BOOTFILENAME_ALLOC;
                    }
    
                    (*ppMachineInfo)->BootFileName = BinlAllocateMemory( ulSize );
                    if ( !(*ppMachineInfo)->BootFileName ) {
                        return (ERROR_OUTOFMEMORY);
                    }
                    RtlZeroMemory((*ppMachineInfo)->BootFileName, ulSize);
                    wcscpy((*ppMachineInfo)->BootFileName, OsChooserName);
                    (*ppMachineInfo)->dwFlags |= MI_BOOTFILENAME | MI_BOOTFILENAME_ALLOC;

                }
            }

            Error = ( ((*ppMachineInfo)->dwFlags & dwRequestedInfo ) == dwRequestedInfo ?
                      ERROR_SUCCESS :
                      ERROR_BINL_FAILED_TO_INITIALIZE_CLIENT );

        } else {

            BinlPrint(( DEBUG_OPTIONS, "... BUT the server has reached MaxClients (%u)\n", BinlMaxClients ));

        }
    } else {

        BinlPrint((DEBUG_OPTIONS, "Server does not allow new clients (AllowNewClients == FALSE )\n" ));
    }

    return Error;
}

DWORD
GetBootParameters(
    PUCHAR          pGuid,
    PMACHINE_INFO * ppMachineInfo,
    DWORD           dwRequestedInfo,
    USHORT          SystemArchitecture,
    BOOL            AllowOSChooser
    )
/*++

Routine Description:

    Use the Directory Service to lookup an entry for this machine using Guid as
    the value to lookup.

    If there is no entry for this machine then return oschooser, but only
    if the AllowOSChooser flag is set.

    If a cache entry is returned, then the cache entry has been marked
    InProgress so we have to call BinlDoneWithCacheEntry when the caller
    is done with it.

Arguments:

    pGuid -  Supplies the machine GUID

    ppMachineInfo - gets filled in with what we discovered
    
    dwRequestedInfo - a bitmask telling us what parameters we're looking for
    
    SystemArchitecture - architecture of the client
    
    AllowOSChooser - signifies that we're allowed to respond to the client with
                     the oschooser

Return Value:

    ERROR_SUCCESS or ERROR_BINL_INVALID_BINL_CLIENT or other error.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    BOOLEAN myClient = TRUE;
    BOOLEAN entryExists = FALSE;

    TraceFunc( "GetBootParameters( )\n" );

    BinlAssert( ppMachineInfo );

    {
        LPGUID GuidPtr = (LPGUID) pGuid;
        BinlPrint((DEBUG_MISC, "Client Guid: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n",
            GuidPtr->Data1, GuidPtr->Data2, GuidPtr->Data3,
            GuidPtr->Data4[0], GuidPtr->Data4[1], GuidPtr->Data4[2], GuidPtr->Data4[3],
            GuidPtr->Data4[4], GuidPtr->Data4[5], GuidPtr->Data4[6], GuidPtr->Data4[7] ));
    }

    if ( ppMachineInfo == NULL ) {
        return E_OUTOFMEMORY;
    }

    if (*ppMachineInfo == NULL) {
        //
        // See if we have any entries in the cache.
        // This also mark any entry found as being used.
        //
        Error = BinlCreateOrFindCacheEntry( pGuid, TRUE, ppMachineInfo );
        if ( Error != ERROR_SUCCESS ) {
            //
            //  if some bizarre error occurred OR if the client simply wasn't
            //  found and we're not sending down OS Chooser, then return the
            //  error here as there's no reason to query the DS.
            //

            if ( (Error != ERROR_BINL_INVALID_BINL_CLIENT ) ||
                 (AllowOSChooser == FALSE) ) {

                return Error;
            }
        }
    }

    // Do we have everything we need?
    if ( ( Error == ERROR_SUCCESS ) &&
         (((*ppMachineInfo)->dwFlags & dwRequestedInfo) == dwRequestedInfo )) {
        BinlPrint((DEBUG_MISC, "cache hit: returning success without querying ds DS\n"));
        return Error;   // Yes, no need to hit the DS.
    }

    //
    //  Initially search for the Computer object in the same domain as ourselves.
    //  This should be quick (because we are probably on a DC) and likely to work
    //  most of the time because the network topology will usually match the domain
    //  structure. If that fails then we fall back to looking at the global catalog.
    //

    if ( Error != ERROR_BINL_INVALID_BINL_CLIENT ) {
        Error = GetBootParametersExt( 
                            *ppMachineInfo, 
                            dwRequestedInfo, 
                            SystemArchitecture, 
                            FALSE);

        if ( Error == ERROR_BINL_INVALID_BINL_CLIENT ) {

            Error = GetBootParametersExt( 
                            *ppMachineInfo, 
                            dwRequestedInfo, 
                            SystemArchitecture, 
                            TRUE );
        }
    }

    if ( Error == ERROR_BINL_INVALID_BINL_CLIENT ) {

        //
        // Backdoor for testing/overiding the DS.
        //
        // If the registry has the GUID of the client, it
        // overrides all the DS settings and answers anyways.
        //
        // NOTE: AllowNewClients must be turned on for OSChooser to
        //       be sent down.
        //

        HKEY KeyHandle;

        if (AllowOSChooser == TRUE) {

            //
            //  if the client is not found in the DS and we're allowed to
            //  answer new clients, then send down OSCHOOSER to get the new
            //  client going.
            //
            BinlPrint((DEBUG_MISC, "generating a new entry because AllowOSChooser is TRUE...\n"));
            Error = BinlGenerateNewEntry( dwRequestedInfo, SystemArchitecture, ppMachineInfo );

            if ( Error != ERROR_SUCCESS ) {
                myClient = FALSE;
            }

        } else {

            //
            //  We're not answering because we didn't find the client
            //  record but the client's SecondsSinceBoot is less than
            //  BinlMinDelayResponseForNewClients.
            //

            myClient = FALSE;

            BinlPrint((DEBUG_OPTIONS, "... OS Chooser is not an option at this time... waiting...\n" ));
        }
    }

    //
    // Determine the host servers IP address iff it's not our own machine.
    //
    if ((Error == ERROR_SUCCESS) &&
        ( (*ppMachineInfo)->dwFlags & MI_HOSTNAME )
       && ( (*ppMachineInfo)->HostAddress == 0 )
       && ( (*ppMachineInfo)->HostName )) {

        EnterCriticalSection( &gcsParameters );

        if ( (BinlGlobalOurDnsName != NULL) &&
             (_wcsicmp( BinlGlobalOurDnsName, (*ppMachineInfo)->HostName ) != 0 )) {

            PCHAR machineName;
            PHOSTENT host;
            ULONG myMachineNameLength;
            PCHAR myMachineName;
            ULONG machineNameLength;

            myMachineNameLength = wcslen( BinlGlobalOurDnsName ) + 1;
            myMachineName = BinlAllocateMemory ( myMachineNameLength );
            if ( myMachineName != NULL ) {
                if (!BinlUnicodeToAnsi(BinlGlobalOurDnsName,myMachineName,(USHORT)myMachineNameLength)) {
                    BinlFreeMemory(myMachineName);
                    myMachineName = NULL;
                }
            }
            LeaveCriticalSection( &gcsParameters );

            machineNameLength = wcslen((*ppMachineInfo)->HostName) + 1;
            machineName = BinlAllocateMemory( machineNameLength );

            //
            //  Only fill in the IP address if the server is different from our
            //  own machine.  If we fail for any reason, we'll just end up using
            //  our own IP address.
            //

            if ((machineName != NULL) &&
                BinlUnicodeToAnsi((*ppMachineInfo)->HostName, machineName, (USHORT)machineNameLength)) {
                
                host = gethostbyname( machineName );
                if (host != NULL) {
                    (*ppMachineInfo)->HostAddress = *(PDHCP_IP_ADDRESS)host->h_addr;
                    // Adding stuff for multi-home NIC
                    if (myMachineName != NULL) {

                        PHOSTENT myhost;
                        int i;
                        myhost = gethostbyname( myMachineName );
                        if (myhost != NULL) {
                            i=0;
                            while (((myhost->h_addr_list)[i]) != NULL) {
                                if ((*((PDHCP_IP_ADDRESS)((myhost->h_addr_list)[i])))
                                    == (*ppMachineInfo)->HostAddress) {

                                    // 
                                    // this is us, leave it as 0
                                    //
                                    (*ppMachineInfo)->HostAddress = (DHCP_IP_ADDRESS)0;
                                    break;
                                }
                                i++;
                            }
                        }
                    }

                } else {
                    Error = ERROR_HOST_UNREACHABLE;
                    myClient = FALSE;
                    entryExists = TRUE;
                }
                BinlFreeMemory( machineName );
            } else {
                if (machineName) {
                    BinlFreeMemory( machineName );
                }
                Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
                myClient = FALSE;
                entryExists = TRUE;
            }
            if ( myMachineName != NULL ) {
                BinlFreeMemory( myMachineName );
            }

        } else {
            LeaveCriticalSection( &gcsParameters );
        }
    }

    if (Error != ERROR_SUCCESS) {

        //
        //  If we didn't find the record, then we mark it that we don't need
        //  to respond and it doesn't exist.  We then mark that we're done with
        //  the entry since we're not passing it back to the caller.
        //
        (*ppMachineInfo)->MyClient = myClient;
        (*ppMachineInfo)->EntryExists = entryExists;

        BinlDoneWithCacheEntry( *ppMachineInfo, FALSE );
        *ppMachineInfo = NULL;

    } else {

        //
        //  we've filled in the interesting fields, therefore mark that the
        //  entry has valid data.
        //

        (*ppMachineInfo)->MyClient = TRUE;
        (*ppMachineInfo)->EntryExists = TRUE;
    }

    return Error;
}

DWORD
GetBootParametersExt(
    PMACHINE_INFO pMachineInfo,
    DWORD         dwRequestedInfo,
    USHORT        SystemArchitecture,
    BOOL          fGlobalSearch)
/*++

Routine Description:

    Use the Directory Service to lookup an entry for this machine using Guid as
    the value to lookup.

    If there is no entry for this machine then return oschooser

Arguments:

    pMachineInfo - identifies the machine in the DS.

    dwRequestedInfo - mask telling what information we should query
    
    SystemArchitecture - architecture of the client

    GlobalSearch - TRUE if GC should be used

Return Value:

    ERROR_SUCCESS or ERROR_BINL_INVALID_BINL_CLIENT

--*/
{
    DWORD dwErr = ERROR_BINL_INVALID_BINL_CLIENT;
    PLDAP LdapHandle = NULL;
    PWCHAR * Base;
    DWORD LdapError;
    DWORD entryCount;
    DWORD ldapRetryLimit = 0;

    PLDAPMessage LdapMessage = NULL;

    PWCHAR * FilePath;
    PWCHAR * FilePath2;
    PLDAPMessage CurrentEntry;

    WCHAR Filter[128];
    WCHAR EscapedGuid[64];

    //  Paramters we want from the Computer Object
    PWCHAR ComputerAttrs[7];
    PDUP_GUID_DN dupDN;

    TraceFunc( "GetBootParametersExt( )\n" );

    pMachineInfo->dwFlags &= MI_ALL_ALLOC; // clear all but the ALLOC bits

    // we get all the info, regardless of what was requested.

    ComputerAttrs[0] = L"netbootMachineFilePath";
    ComputerAttrs[1] = L"netbootInitialization";
    ComputerAttrs[2] = L"sAMAccountName";
    ComputerAttrs[3] = L"dnsHostName";
    ComputerAttrs[4] = L"distinguishedName";
    ComputerAttrs[5] = L"netbootSIFFile";
    ComputerAttrs[6] = NULL;

    BinlAssertMsg( !(dwRequestedInfo & MI_PASSWORD), "Can't get the machine's password!" );

    //  Build the filter to find the Computer object with this GUID
    ldap_escape_filter_element(pMachineInfo->Guid, BINL_GUID_LENGTH, EscapedGuid, sizeof(EscapedGuid) );
    
    //
    // Dont' use ';binary' because win2k Active Directory isn't compatible with the
    // binary tag.
    //
    wsprintf( Filter, L"(&(objectClass=computer)(netbootGUID=%ws))", EscapedGuid );

#if 0 && DBG
    {
        LPGUID GuidPtr = (LPGUID) &pMachineInfo->Guid;
        BinlPrint((DEBUG_MISC, "Client Guid: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n",
            GuidPtr->Data1, GuidPtr->Data2, GuidPtr->Data3,
            GuidPtr->Data4[0], GuidPtr->Data4[1], GuidPtr->Data4[2], GuidPtr->Data4[3],
            GuidPtr->Data4[4], GuidPtr->Data4[5], GuidPtr->Data4[6], GuidPtr->Data4[7] ));
    }
#endif

RetryConnection:
    dwErr = InitializeConnection( fGlobalSearch, &LdapHandle, &Base );
    if ( dwErr != LDAP_SUCCESS ) {
        BinlPrint((DEBUG_ERRORS, 
                   "InitializeConnection failed, ec = %x\n",dwErr));  
        SetLastError( dwErr );
        dwErr = ERROR_BINL_INITIALIZE_LDAP_CONNECTION_FAILED;
        goto e0;
    }

    LdapError = ldap_search_ext_sW(LdapHandle,
                                   *Base,
                                   LDAP_SCOPE_SUBTREE,
                                   Filter,
                                   ComputerAttrs,
                                   FALSE,
                                   NULL,
                                   NULL,
                                   &BinlLdapSearchTimeout,
                                   0,
                                   &LdapMessage);

    if ( LdapError != LDAP_SUCCESS ) {
        HandleLdapFailure(  LdapError,
                            EVENT_WARNING_LDAP_SEARCH_ERROR,
                            fGlobalSearch,
                            &LdapHandle,
                            FALSE );    // don't have lock
        if (LdapHandle == NULL) {

            if (++ldapRetryLimit < LDAP_SERVER_DOWN_LIMIT) {
                goto RetryConnection;
            }
            dwErr = ERROR_BINL_INITIALIZE_LDAP_CONNECTION_FAILED;
            SetLastError( dwErr );
            goto e1;
        }

        BinlPrint((DEBUG_MISC, 
                   "ldap_search_ext_s %ws failed, ec = %x\n",
                   Filter,
                   LdapError));

        goto e1;

    }

    //  Did we get a Computer Object?
    entryCount = ldap_count_entries( LdapHandle, LdapMessage );
    if ( entryCount == 0 ) {
        BinlPrint((DEBUG_MISC, 
                   "ldap_count_entries %ws returned 0 entries\n",
                   Filter ));
        dwErr = ERROR_BINL_INVALID_BINL_CLIENT;
        goto e1; // nope
    }
    else if ( entryCount == -1 ) {
        //
        // catch any errors
        //
        dwErr = LdapGetLastError();
        
        HandleLdapFailure( dwErr, 
                           EVENT_WARNING_LDAP_COUNT_ENTRIES_ERROR,
                           fGlobalSearch,
                           &LdapHandle,
                           FALSE );     // don't have the lock

        if (LdapHandle == NULL) {
            if (++ldapRetryLimit < LDAP_SERVER_DOWN_LIMIT) {
                goto RetryConnection;
            }
            
            SetLastError( dwErr );
        }

        BinlPrint((DEBUG_MISC, "ldap_count_entries %ws failed with error 0x%x\n",
                   Filter, 
                   dwErr ));
        goto e1;
    }

    // if we get more than more entry back, we will use only the
    // first one.
    CurrentEntry = ldap_first_entry( LdapHandle, LdapMessage );

    if (entryCount > 1) {
        BinlLogDuplicateDsRecords( (LPGUID)&pMachineInfo->Guid, LdapHandle, LdapMessage, CurrentEntry );
    }

    FilePath = ldap_get_values( LdapHandle, CurrentEntry, L"distinguishedName");
    if ( FilePath ) {

        if ( pMachineInfo->dwFlags & MI_MACHINEDN_ALLOC ) {
            BinlFreeMemory( pMachineInfo->MachineDN );
            pMachineInfo->dwFlags &= ~MI_MACHINEDN_ALLOC;
        }

        pMachineInfo->MachineDN = BinlStrDup( *FilePath );
        if ( pMachineInfo->MachineDN ) {

            pMachineInfo->dwFlags |= MI_MACHINEDN | MI_MACHINEDN_ALLOC;
        }
        BinlPrint(( DEBUG_MISC, "MachineDN = %ws\n", pMachineInfo->MachineDN ));
        ldap_value_free( FilePath );
    } else {
        BinlPrint((DEBUG_MISC, 
                   "couldn't get distinguishedName for %ws\n",
                   Filter ));
    }

    FilePath = ldap_get_values( LdapHandle, CurrentEntry, L"netbootInitialization" );
    if ( FilePath ) {

        if ( pMachineInfo->dwFlags & MI_SETUPPATH_ALLOC ) {
            BinlFreeMemory( pMachineInfo->SetupPath );
            pMachineInfo->dwFlags &= ~MI_SETUPPATH_ALLOC;
        }

        pMachineInfo->SetupPath = BinlStrDup( *FilePath );
        if ( pMachineInfo->SetupPath ) {

            pMachineInfo->dwFlags |= MI_SETUPPATH | MI_SETUPPATH_ALLOC;
            BinlPrintDbg(( DEBUG_MISC, "SetupPath = %ws\n", pMachineInfo->SetupPath ));
        }
        ldap_value_free( FilePath );
    }

    FilePath = ldap_get_values( LdapHandle, CurrentEntry, L"netbootMachineFilePath" );
    
    if ( FilePath ) {
        PWCHAR psz = wcschr( *FilePath, L'\\' );
        if ( psz ) {
            *psz = L'\0';   // terminate
        }

        if (pMachineInfo->dwFlags & MI_HOSTNAME_ALLOC) {
            BinlFreeMemory( pMachineInfo->HostName );
            pMachineInfo->dwFlags &= ~MI_HOSTNAME_ALLOC;
        }
        pMachineInfo->HostName = BinlStrDup( *FilePath );
        if (pMachineInfo->HostName) {
            BinlPrint(( DEBUG_MISC, "HostName = %ws\n", pMachineInfo->HostName ));
            pMachineInfo->dwFlags |= MI_HOSTNAME | MI_HOSTNAME_ALLOC;
        }

        if ( psz ) {

            *psz = L'\\';       // let's put it back to what it started as.
            psz++;

            if (pMachineInfo->dwFlags & MI_BOOTFILENAME_ALLOC) {
                BinlFreeMemory( pMachineInfo->BootFileName );
                pMachineInfo->dwFlags &= ~MI_BOOTFILENAME_ALLOC;
            }
            pMachineInfo->BootFileName = BinlStrDup( psz );
            if ( pMachineInfo->BootFileName ) {
                pMachineInfo->dwFlags |= MI_BOOTFILENAME | MI_BOOTFILENAME_ALLOC;
                BinlPrintDbg(( DEBUG_MISC, "BootFileName = %ws\n", pMachineInfo->BootFileName ));
            }
        }
        ldap_value_free( FilePath );
    }

    FilePath = ldap_get_values( LdapHandle, CurrentEntry, L"netbootSIFFile" );
    
    if ( FilePath ) {
        PWSTR ForcedSifFilePath;
        DWORD ForcedSifFileLength;
        if (pMachineInfo->dwFlags & MI_SIFFILENAME_ALLOC) {
            BinlFreeMemory( pMachineInfo->ForcedSifFileName );
            pMachineInfo->dwFlags &= ~MI_SIFFILENAME_ALLOC;
        }

        ForcedSifFileLength = wcslen(*FilePath);
        // d:\remoteinstall + '\' + NULL terminator
        ForcedSifFileLength = ForcedSifFileLength + 1 + wcslen(IntelliMirrorPathW) + 1; 
        ForcedSifFileLength = ForcedSifFileLength * sizeof(WCHAR);
        pMachineInfo->ForcedSifFileName = BinlAllocateMemory(ForcedSifFileLength);
        if ( pMachineInfo->ForcedSifFileName ) {
            if (_snwprintf( pMachineInfo->ForcedSifFileName,
                        ForcedSifFileLength/sizeof(WCHAR),
                        L"%ws\\%ws",
                        IntelliMirrorPathW,
                        *FilePath) >= 0) {
                pMachineInfo->dwFlags |= MI_SIFFILENAME_ALLOC;
                BinlPrintDbg(( DEBUG_MISC, "ForcedSifFileName = %ws\n", pMachineInfo->ForcedSifFileName ));
            } else {
                BinlPrintDbg(( DEBUG_MISC, "ForcedSifFileName _snwprintf failed\n" ));
                BinlFreeMemory( pMachineInfo->ForcedSifFileName );
                pMachineInfo->ForcedSifFileName = NULL;
            }            
        }
        ldap_value_free( FilePath );
    }

    if ( !(pMachineInfo->dwFlags & MI_HOSTNAME )
        || ( !pMachineInfo->HostName )
        || ( pMachineInfo->HostName[0] == L'\0') ) {

        if ( pMachineInfo->dwFlags & MI_HOSTNAME_ALLOC ) {
            BinlFreeMemory( pMachineInfo->HostName );
            pMachineInfo->dwFlags &= ~MI_HOSTNAME_ALLOC;
            pMachineInfo->HostName = NULL;
        }
        dwErr = BinlGenerateNewEntry( MI_HOSTNAME, SystemArchitecture, &pMachineInfo );
        if ( dwErr != ERROR_SUCCESS ) {
            goto e1;
        }
    }

    if ( !(pMachineInfo->dwFlags & MI_BOOTFILENAME)
         || ( !pMachineInfo->BootFileName )
         || ( pMachineInfo->BootFileName[0] == L'\0') ) {

        if (pMachineInfo->dwFlags & MI_BOOTFILENAME_ALLOC) {
            BinlFreeMemory( pMachineInfo->BootFileName );
            pMachineInfo->BootFileName = NULL;
            pMachineInfo->dwFlags &= ~MI_BOOTFILENAME_ALLOC;
        }
        dwErr = BinlGenerateNewEntry( MI_BOOTFILENAME, SystemArchitecture, &pMachineInfo );
        if ( dwErr != ERROR_SUCCESS ) {
            goto e1;
        }
    }

    FilePath = ldap_get_values( LdapHandle, CurrentEntry, L"sAMAccountName" );

    if ( FilePath ) {

        if (pMachineInfo->dwFlags & MI_SAMNAME_ALLOC) {
            BinlFreeMemory( pMachineInfo->SamName );
            pMachineInfo->dwFlags &= ~MI_SAMNAME_ALLOC;
        }

        pMachineInfo->SamName = BinlStrDup( *FilePath );
        if ( pMachineInfo->SamName ) {

            pMachineInfo->dwFlags |= MI_SAMNAME | MI_SAMNAME_ALLOC;
            BinlPrint(( DEBUG_MISC, "SamName = %ws\n", pMachineInfo->SamName ));
        }

        //
        //  For now, the pMachineInfo Name and SamName are the same values,
        //  therefore we won't look them up twice in the ldap message.
        //
#if 0
        ldap_value_free( FilePath );
    }

    FilePath = ldap_get_values( LdapHandle, CurrentEntry, L"sAMAccountName" );

    if ( FilePath ) {
#endif
        if ( pMachineInfo->dwFlags & MI_NAME_ALLOC ) {
            BinlFreeMemory( pMachineInfo->Name );
            pMachineInfo->dwFlags &= ~MI_NAME_ALLOC;
        }

        pMachineInfo->Name = BinlStrDup( *FilePath );
        if ( pMachineInfo->Name ) {
            if( pMachineInfo->Name[ wcslen(pMachineInfo->Name) - 1 ] == L'$' ) {
                pMachineInfo->Name[ wcslen(pMachineInfo->Name) - 1 ] = L'\0'; // remove '$'
            }
            pMachineInfo->dwFlags |= MI_NAME | MI_NAME_ALLOC;
            BinlPrint(( DEBUG_MISC, "Name = %ws\n", pMachineInfo->Name ));
        }
        ldap_value_free( FilePath );
    }

    FilePath = ldap_get_values( LdapHandle, CurrentEntry, L"dnsHostName" );

    if ( FilePath ) {

        BOOL   fEndofString = FALSE;
        PWCHAR psz = *FilePath;

        // skip host name, we get that from the samName
        while ( *psz && *psz!=L'.' ) {
            psz++;
        }
        if ( !(*psz) ) {
            fEndofString = TRUE;
        }
        *psz = L'\0'; // terminate

        if ( fEndofString == FALSE ) {
            psz++;

            if (pMachineInfo->Domain) {
                BinlFreeMemory( pMachineInfo->Domain );
            }

            pMachineInfo->Domain = BinlStrDup( psz );
            if ( pMachineInfo->Domain )
            {
                pMachineInfo->dwFlags |= MI_DOMAIN;
                BinlPrint(( DEBUG_MISC, "Domain = %ws\n", pMachineInfo->Domain ));
            }
        }
        ldap_value_free(FilePath);
    }

    //
    // track duplicates that we get back
    //
    //  first we free all duplicates we have already allocated.
    //

    while (!IsListEmpty(&pMachineInfo->DNsWithSameGuid)) {

        PLIST_ENTRY p = RemoveHeadList(&pMachineInfo->DNsWithSameGuid);

        dupDN = CONTAINING_RECORD(p, DUP_GUID_DN, ListEntry);
        BinlFreeMemory( dupDN );
    }

    while (--entryCount > 0) {

        CurrentEntry = ldap_next_entry( LdapHandle, CurrentEntry );

        if (CurrentEntry == NULL) {
            break;
        }

        FilePath = ldap_get_values( LdapHandle, CurrentEntry, L"dnsHostName" );
        if (!FilePath) {
            FilePath = ldap_get_values( LdapHandle, CurrentEntry, L"sAMAccountName");
        }

        if ( FilePath ) {

            ULONG dupLength, dupLength2;

            BinlPrint(( DEBUG_OSC, "Found duplicate DN in %ws\n", *FilePath ));

            FilePath2 = ldap_get_values( LdapHandle, CurrentEntry, L"distinguishedName");

            dupLength = wcslen( *FilePath ) + 1;
            if (FilePath2) {
                dupLength2 = wcslen( *FilePath2 ) + 1;
            } else {
                dupLength2 = 1;
            }

            dupDN = BinlAllocateMemory( FIELD_OFFSET(DUP_GUID_DN, DuplicateName[0]) +
                        ( (dupLength + dupLength2) * sizeof(WCHAR) ) );
            if ( dupDN ) {

                dupDN->DuplicateDNOffset = dupLength;
                wcscpy( &dupDN->DuplicateName[0], *FilePath );
                if (FilePath2) {
                    wcscpy( &dupDN->DuplicateName[dupLength], *FilePath2 );
                } else {
                    dupDN->DuplicateName[dupLength] = L'\0';
                }

                //
                // if the last character is a $, then slam in a NULL to end it.
                //

                if (( dupLength > 1 ) &&
                    ( dupDN->DuplicateName[dupLength-2] == L'$' )) {

                    dupDN->DuplicateName[dupLength-2] = L'\0';
                }

                InsertTailList( &pMachineInfo->DNsWithSameGuid, &dupDN->ListEntry );
            }
            ldap_value_free( FilePath );
            if (FilePath2) {
                ldap_value_free( FilePath2 );
            }
        }
    }

e1:
    if (LdapMessage) {
        ldap_msgfree( LdapMessage );
    }
e0:
    return dwErr;
}

DWORD
InitializeConnection(
    BOOL Global,
    PLDAP * LdapHandle,
    PWCHAR ** Base )
/*++

Routine Description:

    Initialize the ldap connection for operating on either the domain or the
    global catalog.

Arguments:

    Global - TRUE if GC should be used

    LdapHandle - Returns the handle for further operations

    OperationalAttributeLdapMessage - Returns message containing Base so that it can be freed later

    Base - DN of where to start searches for computer objects.

Return Value:

    ldap error

--*/
{
    PLDAPMessage OperationalAttributeLdapMessage = NULL;
    PWCHAR Attrs[2];
    PLDAPMessage CurrentEntry;
    PWCHAR *LdapValue;
    DWORD LdapError = ERROR_SUCCESS;
    PLDAP *LdapHandleCurrent;
    PWCHAR ** LdapBaseCurrent;
    ULONG temp;

    TraceFunc( "InitializeConnection( )\n" );

    //  Use critical section to avoid two threads initialising the same parameters
    EnterCriticalSection(&gcsDHCPBINL);

    if ( !Global ) {

        LdapHandleCurrent = &DCLdapHandle;
        LdapBaseCurrent = &DCBase;

    } else {

        LdapHandleCurrent = &GCLdapHandle;
        LdapBaseCurrent = &GCBase;
    }

    if ( !(*LdapHandleCurrent) ) {
        if (Global) {

            *LdapHandleCurrent = ldap_initW( BinlGlobalDefaultGC, LDAP_GC_PORT);

            temp = DS_DIRECTORY_SERVICE_REQUIRED |
                    DS_IP_REQUIRED |
                    DS_GC_SERVER_REQUIRED;
        } else {

            *LdapHandleCurrent = ldap_initW( BinlGlobalDefaultDS, LDAP_PORT);

            temp = DS_DIRECTORY_SERVICE_REQUIRED |
                    DS_IP_REQUIRED;
        }

        if (!*LdapHandleCurrent) {
            BinlPrint(( DEBUG_ERRORS, "Failed to initialize LDAP connection.\n" ));
            LdapError = LDAP_CONNECT_ERROR;
            LogLdapError( (Global ? EVENT_WARNING_LDAP_INIT_ERROR_GC :
                                    EVENT_WARNING_LDAP_INIT_ERROR_DC),
                            GetLastError(),
                            NULL
                            );
            goto e0;
        }

        LdapError = ldap_set_option(*LdapHandleCurrent, LDAP_OPT_GETDSNAME_FLAGS, &temp );

        if ( LdapError != LDAP_SUCCESS ) {
            //
            // something went wrong setting the option.
            // do not continue, because we don't know
            // what will happen with other settings 
            //
            BinlPrint(( DEBUG_ERRORS, "Failed to set LDAP_OPT_GETDSNAME_FLAGS.\n"));
            LogLdapError( EVENT_WARNING_LDAP_INIT_OPTIONS_ERROR,
                          LdapError,
                          *LdapHandleCurrent
                          );
            goto e1;
        }

        if (Global == FALSE) {

            temp = BinlLdapOptReferrals;

        } else {
            //
            //  At some future time, the GC is going to return referrals to
            //  authoritative DCs when the GC doesn't contain all the
            //  attributes.  We'll enable referrals so that it "just works".
            //
            temp = (ULONG)((ULONG_PTR)LDAP_OPT_ON);
        }
        
        ldap_set_option(*LdapHandleCurrent, LDAP_OPT_REFERRALS, (void *) &temp );

        if ( LdapError != LDAP_SUCCESS ) {
            //
            // something went wrong setting the option.
            // do not continue, because we don't know
            // what will happen with other settings 
            //
            BinlPrint(( DEBUG_ERRORS, "Failed to set LDAP_OPT_REFERRALS.\n"));
            LogLdapError( EVENT_WARNING_LDAP_INIT_OPTIONS_ERROR,
                          LdapError,
                          *LdapHandleCurrent
                          );
            goto e1;
        }

        temp = LDAP_VERSION3;
        ldap_set_option(*LdapHandleCurrent, LDAP_OPT_VERSION, &temp );

        if ( LdapError != LDAP_SUCCESS ) {
            //
            // something went wrong setting the option.
            // do not continue, because we don't know
            // what will happen with other settings 
            //
            BinlPrint(( DEBUG_ERRORS, "Failed to set LDAP_OPT_VERSION.\n"));
            LogLdapError( EVENT_WARNING_LDAP_INIT_OPTIONS_ERROR,
                          LdapError,
                          *LdapHandleCurrent
                          );
            goto e1;
        }

        LdapError = ldap_connect(*LdapHandleCurrent,0);

        if (LdapError != LDAP_SUCCESS) {
            LogLdapError( (Global ? EVENT_WARNING_LDAP_INIT_ERROR_GC :
                                    EVENT_WARNING_LDAP_INIT_ERROR_DC),
                          LdapError,
                          *LdapHandleCurrent
                          );
            BinlPrint(( DEBUG_ERRORS, "ldap_connect failed: %lx\n", LdapError ));
            goto e1;
        }

        LdapError = ldap_bind_s(*LdapHandleCurrent, NULL, NULL, LDAP_AUTH_SSPI);

        if (LdapError != LDAP_SUCCESS) {
            BinlPrint(( DEBUG_ERRORS, "ldap_bind_s failed: %lx\n", LdapError ));
            LogLdapError(   EVENT_WARNING_LDAP_BIND_ERROR,
                            LdapError,
                            *LdapHandleCurrent
                            );
            goto e1;
        }
    }

    //
    //  Connected to Directory Service. Find out where in the DS we
    //  should start looking for the computer.
    //
    if ( !(*LdapBaseCurrent) )
    {
        DWORD count;
        Attrs[0] = DefaultNamingContext;
        Attrs[1] = NULL;

        LdapError = ldap_search_ext_sW(*LdapHandleCurrent,
                                       NULL, // base
                                       LDAP_SCOPE_BASE,
                                       L"objectClass=*",// filter
                                       Attrs,
                                       FALSE,
                                       NULL,
                                       NULL,
                                       &BinlLdapSearchTimeout,
                                       0,
                                       &OperationalAttributeLdapMessage);

        if ( LdapError != LDAP_SUCCESS ) {
            BinlPrint(( DEBUG_ERRORS, "ldap_search_ext_s failed: %x\n", LdapError ));

            HandleLdapFailure(  LdapError,
                                EVENT_WARNING_LDAP_SEARCH_ERROR,
                                Global,
                                LdapHandleCurrent,
                                TRUE );    // we have lock
            if (*LdapHandleCurrent == NULL) {
                goto e1;
            }

            goto e2;
        }
        count = ldap_count_entries( *LdapHandleCurrent, OperationalAttributeLdapMessage );
        if ( count == 0 ) {
            BinlPrint(( DEBUG_ERRORS, "Failed to find the defaultNamingContext.\n" ));
            LdapError = LDAP_NO_RESULTS_RETURNED;
            LogLdapError(   EVENT_WARNING_LDAP_SEARCH_ERROR,
                            LdapError,
                            *LdapHandleCurrent
                            );
            goto e2;
        }
        if ( count == -1 ) {
            // 
            // get the failing case as well
            //
            BinlPrint(( DEBUG_ERRORS, "ldap_count_entries failed.\n" ));
            LdapError = LdapGetLastError();

            HandleLdapFailure( LdapError,
                               EVENT_WARNING_LDAP_COUNT_ENTRIES_ERROR,
                               Global,
                               LdapHandleCurrent,
                               TRUE );   // we have lock

            if (*LdapHandleCurrent == NULL) {
                goto e1;
            }
            goto e2;
        }

        //
        //  the DS should always only return us a single root DSE record.
        //  It would be completely broken if it returned more than one.
        //

        BinlAssert( count == 1 );

        CurrentEntry = ldap_first_entry( *LdapHandleCurrent, OperationalAttributeLdapMessage );

        LdapValue = ldap_get_values( *LdapHandleCurrent, CurrentEntry, Attrs[0] );

        if (LdapValue == NULL) {
            BinlPrint(( DEBUG_ERRORS, "Failed to find the defaultNamingContext.\n" ));
            LdapError = LDAP_NO_RESULTS_RETURNED;
            goto e2;
        }

        *LdapBaseCurrent = LdapValue;
    }

e2:
    if (OperationalAttributeLdapMessage) {
        ldap_msgfree( OperationalAttributeLdapMessage );
    }

e0:
    if ( LdapHandle ) {
        *LdapHandle = *LdapHandleCurrent;
    }

    if ( Base ) {
        *Base = *LdapBaseCurrent;
    }

    LeaveCriticalSection(&gcsDHCPBINL);
    return LdapError;

e1:
    BinlPrint(( DEBUG_ERRORS, "Failed to connect to LDAP server.\n" ));
    if (*LdapHandleCurrent != NULL) {
        ldap_unbind(*LdapHandleCurrent);
        *LdapHandleCurrent = NULL;
    }
    goto e0;
}

VOID
HandleLdapFailure(
    DWORD LdapError,
    DWORD EventId,
    BOOL GlobalCatalog,
    PLDAP *LdapHandle,
    BOOL HaveLock
    )
/*++

Routine Description:

    This routine will recycle an ldap handle.  Call this routine when one
    of our global ldap handles becomes suspect because ldap calls start
    failing.

Arguments:

    LdapError - error code from ldap call that failed.
    EventId - eventlog error that we should log on failure.
    GlobalCatalog - set to TRUE if we were searching hte global catalog
                    and should therefore be cleaning up the GCLdapHandle.
    LdapHandle - ldap handle pointer.  it can be reset to null to indicate
                 that the handle was cleaned up and is no longer valid.
    HaveLock - flag indicating if we are holding gcsDHCPBINL (required to free
               a global structure like our handles).

Return Value:

    None.

--*/
{
    PLDAP *LdapHandleCurrent;
    PWCHAR ** LdapBaseCurrent;

    //
    // it used to be that we'd only recycle the handle on certain failures, but
    // it seems like we're likely to get any failure code on an invalid handle.
    // therefore we always recycle the handle regardless of the error code.
    //
    if (LdapError == LDAP_SUCCESS) {
        BinlAssert( FALSE );
    }

    if (!HaveLock) {
        EnterCriticalSection(&gcsDHCPBINL);
    }

    LdapHandleCurrent = GlobalCatalog ? &GCLdapHandle : &DCLdapHandle;
    LdapBaseCurrent = GlobalCatalog ? &GCBase : &DCBase;

    if (EventId) {
        LogLdapError(   EventId,
                        LdapError,
                        (LdapHandle != NULL ? *LdapHandle : *LdapHandleCurrent)
                        );
    }
    if (LdapHandle) {
        ASSERT( *LdapHandle == *LdapHandleCurrent );
        *LdapHandle = NULL;
    }

    FreeConnection( LdapHandleCurrent, LdapBaseCurrent );
    if (!HaveLock) {
        LeaveCriticalSection(&gcsDHCPBINL);
    }

    return;
}

VOID
FreeConnection(
    PLDAP * LdapHandle,
    PWCHAR ** Base)
/*++

Routine Description:

    Free the ldap connection for operating on either the domain or the
    global catalog.

Arguments:

    LdapHandle - The handle for further operations

    Base - DN of where to start searches for computer objects to be freed.

Return Value:

    None.

--*/
{
    TraceFunc( "FreeConnection( )\n" );

    if (*LdapHandle) {
        ldap_unbind( *LdapHandle );
        *LdapHandle = NULL;
    }

    if (*Base) {
        ldap_value_free(*Base);
        *Base = NULL;
    }
}


VOID
FreeConnections
(
    VOID
    )
/*++

Routine Description:

     Terminate any LDAP requests because we are stopping immediately.  We
     wait until all threads are stopped because the threads may have pointers
     to the values we're going to free.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  clear out the cache, wait until all are marked as not being
    //  processed.  We do this because the threads have pointers to DCBase,
    //  GCBase, etc and if we just blow them away, they may AV.
    //

    BinlCloseCache();

    TraceFunc( "FreeConnections( )\n" );

    FreeConnection( &DCLdapHandle, &DCBase);
    FreeConnection( &GCLdapHandle, &GCBase);
}


DWORD
FindSCPForBinlServer(
    PWCHAR * ResultPath,
    PWCHAR * MachinePath,
    BOOL GlobalSearch)
/*++

Routine Description:

    Use the Directory Service to lookup the settings for this service.

Arguments:

    GlobalSearch - TRUE if GC should be used

Return Value:

    ERROR_SUCCESS or BINL_CANT_FIND_SERVER_MAO or ERROR_OUTOFMEMORY

--*/
{
    DWORD Error = ERROR_SUCCESS;
    PLDAP LdapHandle;
    DWORD LdapError;
    DWORD count;
    ULONG ldapRetryLimit = 0;

    PWCHAR * DsPath;
    PLDAPMessage CurrentEntry;
    PLDAPMessage LdapMessage = NULL;

    PWCHAR ServerDN = NULL;
    BOOL retryDN = TRUE;

    //  Paramters we want from the Computer Object
    PWCHAR ComputerAttrs[2];
    ComputerAttrs[0] = &L"netbootSCPBL";
    ComputerAttrs[1] = NULL;

    TraceFunc( "FindSCPForBinlServer( )\n" );

RetryGetDN:

    //
    // get ServerDN
    //
    // It should be something like this:
    // ServerDN = "cn=server,cn=computers,dc=microsoft,dc=com"
    //
    EnterCriticalSection( &gcsParameters );
       
    if (!BinlGlobalOurFQDNName) {
        Error = ERROR_BINL_INITIALIZE_LDAP_CONNECTION_FAILED;
    }

    ServerDN = StrDupW( BinlGlobalOurFQDNName );

    LeaveCriticalSection( &gcsParameters );

    if (!ServerDN ) {
        if (Error == ERROR_SUCCESS) {
            Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        }
        goto e0;
    }

    Error = InitializeConnection(GlobalSearch, &LdapHandle, NULL);
    if ( Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_ERRORS, "!!Error 0x%08x - Ldap Connection Failed.\n", Error ));
        SetLastError( Error );
        Error = ERROR_BINL_INITIALIZE_LDAP_CONNECTION_FAILED;
        goto e0;
    }
RetrySearch:
    LdapError = ldap_search_ext_sW(LdapHandle,
                                   ServerDN,
                                   LDAP_SCOPE_BASE,
                                   L"objectClass=*",
                                   ComputerAttrs,
                                   FALSE,
                                   NULL,
                                   NULL,
                                   &BinlLdapSearchTimeout,
                                   0,
                                   &LdapMessage);

    //
    //  if the object isn't found, then something is amiss.. go grab the DN
    //  again.
    //

    if ((LdapError == LDAP_NO_SUCH_OBJECT) && retryDN) {

        retryDN = FALSE;

        // if we didn't find an entry or it was busy, retry
        GetOurServerInfo();

        BinlFreeMemory( ServerDN );
        ServerDN = NULL;
        goto RetryGetDN;
    }

    if (((LdapError == LDAP_BUSY) || (LdapError == LDAP_NO_SUCH_OBJECT)) &&
         (++ldapRetryLimit < LDAP_BUSY_LIMIT)) {
        Sleep( LDAP_BUSY_DELAY );
        goto RetrySearch;
    }

    if (LdapError != LDAP_SUCCESS) {
        //
        // something is screwed up with our handle, get rid of it.
        //
        HandleLdapFailure(
             LdapError,
             EVENT_WARNING_LDAP_SEARCH_ERROR,
             GlobalSearch,
             &LdapHandle,
             FALSE); // don't have lock

        goto e1;
    }
    
    
    count = ldap_count_entries( LdapHandle, LdapMessage );
    if (count == 0) {

        if (LdapError == LDAP_SUCCESS) {
            LdapError = LDAP_TIMELIMIT_EXCEEDED;
        }

        BinlPrintDbg(( DEBUG_ERRORS, "!!LdapError 0x%08x - LDAP search failed... will retry later.\n", LdapError ));

        BinlReportEventW( EVENT_ERROR_LOCATING_SCP,
                          EVENTLOG_ERROR_TYPE,
                          0,
                          sizeof(LdapError),
                          NULL,
                          &LdapError
                          );

        Error = ERROR_BINL_INITIALIZE_LDAP_CONNECTION_FAILED;
        goto e1;
    }
    BinlAssertMsg( count == 1, "Count should have been 1." );
    if ( count != 1 ) {
        BinlPrintDbg(( DEBUG_ERRORS, "!!Error - LDAP search returned more than one SCP record for us.\n" ));

        BinlReportEventW( BINL_DUPLICATE_MAO_RECORD,
                          EVENTLOG_ERROR_TYPE,
                          0,
                          sizeof(count),
                          NULL,
                          &count
                          );

        Error = ERROR_BINL_CANT_FIND_SERVER_MAO;
        goto e1;
    }

    //
    // Get the SCP
    //
    CurrentEntry = ldap_first_entry( LdapHandle, LdapMessage );

    DsPath = ldap_get_values( LdapHandle, CurrentEntry, L"netbootSCPBL" );
    if ( !DsPath ) {
        BinlPrintDbg(( DEBUG_ERRORS, "!!Error - Could not get 'netbootSCPBL' from the server's MAO\n" ))
        Error = ERROR_BINL_CANT_FIND_SERVER_MAO;
        goto e1;
    }

    *ResultPath = (PWCHAR) BinlAllocateMemory( (wcslen(*DsPath) + 1) * sizeof(WCHAR) );
    if ( *ResultPath == NULL ) {
        BinlPrintDbg(( DEBUG_ERRORS, "!!Error - Out of memory.\n" ));
        Error = ERROR_OUTOFMEMORY;
        goto e2;
    }

    wcscpy( *ResultPath, *DsPath );

    *MachinePath = ServerDN;
    ServerDN = NULL; // prevent freeing

    Error = ERROR_SUCCESS;

e2:
    ldap_value_free(DsPath);

e1:
    if (LdapMessage) {
        ldap_msgfree( LdapMessage );
    }

e0:
    if ( ServerDN )
        BinlFreeMemory( ServerDN );

    return Error;
}

DWORD
UpdateSettingsUsingResults(
    PLDAP        LdapHandle,
    PLDAPMessage LdapMessage,
    LPWSTR       ComputerAttrs[],
    PDWORD       NumberOfAttributesFound OPTIONAL
    )
{
    PLDAPMessage CurrentEntry;
    DWORD        LdapError = LDAP_SUCCESS;
    DWORD        count;
    DWORD        countFound = 0;

    TraceFunc( "UpdateSettingsUsingResults( ... )\n" );

    CurrentEntry = ldap_first_entry( LdapHandle, LdapMessage );

    for ( count = 0; ComputerAttrs[count] != NULL; count++ ) {

        PWCHAR * Attribute;

        Attribute = ldap_get_values( LdapHandle, CurrentEntry, ComputerAttrs[count] );

        if (Attribute == NULL) {
#if DBG
            CHAR Temp[MAX_PATH];
            if (BinlUnicodeToAnsi(ComputerAttrs[count],Temp,MAX_PATH)) {
                BinlPrintDbg(( DEBUG_OPTIONS, "Did not find attribute '%s'... skipping\n", Temp ));
            }
#endif

            if (count != 1) { // NewMachineOU

                continue; // skip and use default
            }

        } else {

            //
            // Increment the count of attributes found.
            //

            countFound++;
        }

        switch( count )
        {
        case 0: // NewMachineNamingPolicy
            {
                DWORD Length = wcslen( *Attribute ) + 1;
                PWCHAR psz = (PWCHAR) BinlAllocateMemory( Length * sizeof(WCHAR) );
                BinlAssert( _wcsicmp( ComputerAttrs[0], L"netbootNewMachineNamingPolicy" ) == 0 );
                if ( psz )
                {
                    wcscpy( psz, *Attribute );

                    EnterCriticalSection(&gcsParameters);

                    if ( NewMachineNamingPolicy != NULL )
                    {
                        BinlFreeMemory( NewMachineNamingPolicy );
                    }
                    NewMachineNamingPolicy = psz;

                    LeaveCriticalSection(&gcsParameters);
                }
                BinlPrint(( DEBUG_OPTIONS, "NewMachineNamingPolicy = '%ws'\n", NewMachineNamingPolicy ));
            }
            break;

        case 1: // NewMachineOU
            {
                LPWSTR psz;
                DWORD Length;
                BOOL getServerInfo;

                BinlAssert( _wcsicmp( ComputerAttrs[1], L"netbootNewMachineOU" ) == 0 );

                if (Attribute == NULL || *Attribute == NULL) {

                    Length = 1;

                } else {

                    Length = wcslen( *Attribute ) + 1;
                }

                psz = (LPWSTR) BinlAllocateMemory( Length * sizeof(WCHAR) );

                if (psz == NULL) {
                    LdapError = LDAP_NO_MEMORY;
                    break;
                }
                if (Length == 1) {

                    *psz = L'\0';

                } else {

                    wcscpy( psz, *Attribute );
                }

                EnterCriticalSection(&gcsParameters);

                getServerInfo = (BOOL)( (BinlGlobalDefaultContainer == NULL) ||
                                        (_wcsicmp(BinlGlobalDefaultContainer, psz) != 0) );

                if ( BinlGlobalDefaultContainer != NULL )
                {
                    BinlFreeMemory( BinlGlobalDefaultContainer );
                }
                BinlGlobalDefaultContainer = psz;

                LeaveCriticalSection(&gcsParameters);

                if ( getServerInfo ) {

                    ULONG Error = GetOurServerInfo();
                    if (Error != ERROR_SUCCESS) {

                        BinlPrintDbg(( DEBUG_ERRORS, "GetOurServerInfo returned 0x%x, we had a new default container.\n", Error ));
                    }
                }

                BinlPrint(( DEBUG_OPTIONS, "DefaultContainer = %ws\n", BinlGlobalDefaultContainer ));
            }
            break;

        case 2: // MaxClients
            {
                CHAR Temp[10];
                BinlAssert( _wcsicmp( ComputerAttrs[2], L"netbootMaxClients" ) == 0 );
                if (!BinlUnicodeToAnsi(*Attribute,Temp,sizeof(Temp))) {
                    BinlMaxClients = atoi( Temp );
                    BinlPrint(( DEBUG_OPTIONS, "BinlMaxClients = %u\n", BinlMaxClients ));
                }
            }
            break;

        case 3: // CurrentClientCount
            {
                CHAR Temp[10];
                BinlAssert( _wcsicmp( ComputerAttrs[3], L"netbootCurrentClientCount" ) == 0 );
                if (!BinlUnicodeToAnsi(*Attribute,Temp,sizeof(Temp))) {
                    CurrentClientCount = atoi( Temp );
                    BinlPrint(( DEBUG_OPTIONS, "(Last) CurrentClientCount = %u\n", CurrentClientCount ));
                }
            }
            break;

        case 4: // AnswerRequest
            BinlAssert( _wcsicmp ( ComputerAttrs[4], L"netbootAnswerRequests" ) == 0 );
            if ( wcscmp( *Attribute, L"TRUE" ) == 0 )
            {
                AnswerRequests = TRUE;
            }
            else
            {
                AnswerRequests = FALSE;
            }
            BinlPrint(( DEBUG_OPTIONS, "AnswerRequests = %s\n", BOOLTOSTRING( AnswerRequests ) ));
            break;

        case 5: // AnswerOnlyValidClients
            BinlAssert( _wcsicmp( ComputerAttrs[5], L"netbootAnswerOnlyValidClients" ) == 0 );
            if ( wcscmp( *Attribute, L"TRUE" ) == 0 ) {
                AnswerOnlyValidClients = TRUE;
            } else {
                AnswerOnlyValidClients = FALSE;
            }
            BinlPrint(( DEBUG_OPTIONS, "AnswerOnlyValidClients = %s\n", BOOLTOSTRING( AnswerOnlyValidClients ) ));
            break;

        case 6: // AllowNewClients
            BinlAssert( _wcsicmp( ComputerAttrs[6], L"netbootAllowNewClients" ) == 0 );
            if ( wcscmp( *Attribute, L"TRUE" ) == 0 )
            {
                AllowNewClients = TRUE;
            }
            else
            {
                AllowNewClients = FALSE;
            }
            BinlPrint(( DEBUG_OPTIONS, "AllowNewClients = %s\n", BOOLTOSTRING( AllowNewClients ) ));
            break;

        case 7: // LimitClients
            BinlAssert( _wcsicmp( ComputerAttrs[7], L"netbootLimitClients" ) == 0 );
            if ( wcscmp( *Attribute, L"TRUE" ) == 0 )
            {
                LimitClients = TRUE;
            }
            else
            {
                LimitClients = FALSE;
            }
            BinlPrint(( DEBUG_OPTIONS, "LimitClients = %s\n", BOOLTOSTRING( LimitClients ) ));
            break;

        case 8:  // IntellimirrorOSes
        case 9:  // Tools
        case 10: // LocalInstallOSes
            BinlAssert( _wcsicmp( ComputerAttrs[8],  L"netbootIntellimirrorOSes" ) == 0 );
            BinlAssert( _wcsicmp( ComputerAttrs[9],  L"netbootTools" ) == 0 );
            BinlAssert( _wcsicmp( ComputerAttrs[10], L"netbootLocalInstallOSes" ) == 0 );
            //
            // TODO: Tie these in with OS Chooser - this is still TBD.
            //
            break;

        default:
            // Somethings wrong
            BinlAssert( 0 );
        }

        if (Attribute != NULL) {
            ldap_value_free(Attribute);
        }
    }

    if ( ARGUMENT_PRESENT(NumberOfAttributesFound) ) {
        *NumberOfAttributesFound = countFound;
    }

    return LdapError;
}


DWORD
GetBinlServerParameters(
    BOOL GlobalSearch)
/*++

Routine Description:

    Use the Directory Service to lookup the settings for this service.

Arguments:

    GlobalSearch - TRUE if GC should be used

Return Value:

    ERROR_SUCCESS or BINL_CANT_FIND_SERVER_MAO

--*/
{
    DWORD Error;
    PLDAP LdapHandle;
    DWORD LdapError;
    DWORD count;
    ULONG ldapRetryLimit = 0;

    PLDAPMessage LdapMessage = NULL;

    //  Paramters we want from the IntelliMirror-SCP
    //  NOTE: These must be the same ordinals as those used in
    //  UpdateSettingsUsingResults( ).
    PWCHAR ComputerAttrs[12];
    ComputerAttrs[0]  = &L"netbootNewMachineNamingPolicy";
    ComputerAttrs[1]  = &L"netbootNewMachineOU";
    ComputerAttrs[2]  = &L"netbootMaxClients";
    ComputerAttrs[3]  = &L"netbootCurrentClientCount";
    ComputerAttrs[4]  = &L"netbootAnswerRequests";
    ComputerAttrs[5]  = &L"netbootAnswerOnlyValidClients";
    ComputerAttrs[6]  = &L"netbootAllowNewClients";
    ComputerAttrs[7]  = &L"netbootLimitClients";
    ComputerAttrs[8]  = &L"netbootIntellimirrorOSes";
    ComputerAttrs[9]  = &L"netbootTools";
    ComputerAttrs[10] = &L"netbootLocalInstallOSes";
    ComputerAttrs[11] = NULL;

    TraceFunc( "GetBinlServerParameters( )\n" );

    Error = FindSCPForBinlServer( &BinlGlobalSCPPath, &BinlGlobalServerDN, GlobalSearch );
    if ( Error != ERROR_SUCCESS ) {
        BinlPrint(( DEBUG_ERRORS, "!!Error 0x%08x - SCP not found. Default settings being used.\n", Error ));
        goto e0;
    }

    BinlPrint(( DEBUG_OPTIONS, "ServerDN = '%ws'\n", BinlGlobalServerDN ));
    BinlPrint(( DEBUG_OPTIONS, "SCPDN    = '%ws'\n", BinlGlobalSCPPath ));

RetryConnection:
    Error = InitializeConnection( GlobalSearch, &LdapHandle, NULL );
    if ( Error != ERROR_SUCCESS ) {
        SetLastError( Error );
        Error = ERROR_BINL_INITIALIZE_LDAP_CONNECTION_FAILED;
        goto e0;
    }

Retry:
    LdapError = ldap_search_ext_sW(LdapHandle,
                                   BinlGlobalSCPPath,
                                   LDAP_SCOPE_BASE,
                                   L"objectClass=*",
                                   ComputerAttrs,
                                   FALSE,
                                   NULL,
                                   NULL,
                                   NULL,
                                   0,
                                   &LdapMessage);

    if ((LdapError == LDAP_BUSY) && (++ldapRetryLimit < LDAP_BUSY_LIMIT)) {
        Sleep( LDAP_BUSY_DELAY );
        goto Retry;
    }

    if (LdapError != LDAP_SUCCESS) {
        HandleLdapFailure(  LdapError,
                            EVENT_WARNING_LDAP_SEARCH_ERROR,
                            GlobalSearch,
                            &LdapHandle,
                            FALSE );    // don't have lock
        if (LdapHandle == NULL) {
            if (++ldapRetryLimit < LDAP_SERVER_DOWN_LIMIT) {
                goto RetryConnection;
            }
            goto e0;
        }

        goto e1;
    }

    count = ldap_count_entries( LdapHandle, LdapMessage );
    if (count == 0) {

        if (LdapError == LDAP_SUCCESS) {
            LdapError = LDAP_TIMELIMIT_EXCEEDED;
        }
        BinlPrintDbg(( DEBUG_ERRORS, "!!LdapError 0x%08x - Failed to retrieve parameters... will retry later.\n", LdapError ));

        BinlReportEventW( EVENT_ERROR_LOCATING_SCP,
                          EVENTLOG_ERROR_TYPE,
                          0,
                          sizeof(LdapError),
                          NULL,
                          &LdapError
                          );

        Error = ERROR_BINL_INITIALIZE_LDAP_CONNECTION_FAILED;
        goto e1;
    }

    BinlAssertMsg( count == 1, "Count should have been one. Is the SCP missing?" );

    //  We did a base level search, we better only have gotten one record back.
    BinlAssert( count == 1 );

    // Retrieve the results into the settings
    LdapError = UpdateSettingsUsingResults( LdapHandle, LdapMessage, ComputerAttrs, &count );
    if ( LdapError == LDAP_SUCCESS )
    {
        BinlReportEventW( count != 0 ? EVENT_SCP_READ_SUCCESSFULLY :
                                       EVENT_SCP_READ_SUCCESSFULLY_EMPTY,
                          count != 0 ? EVENTLOG_INFORMATION_TYPE :
                                       EVENTLOG_WARNING_TYPE,
                          0,
                          0,
                          NULL,
                          NULL
                          );
    }

e1:
    if (LdapMessage) {
        ldap_msgfree( LdapMessage );
    }
e0:
    return Error;
}

VOID
BinlLogDuplicateDsRecords (
    LPGUID Guid,
    LDAP *LdapHandle,
    LDAPMessage *LdapMessage,
    LDAPMessage *CurrentEntry
    )
//
//  Log an error that we've received duplicate records for a client when
//  we looked them up by GUID.
//
//  We log the DNs so that the administrator can look them up.
//
{
    LPWSTR strings[4];
    LPWSTR dn1;
    LPWSTR dn2;
    ULONG strCount = 0;     // up to two strings to log
    PLDAPMessage nextEntry =  ldap_next_entry( LdapHandle, LdapMessage );
    LPWSTR  GuidString;

    if (SUCCEEDED(StringFromIID( (REFIID)Guid, &GuidString ))) {
        strCount += 1;
    }

    dn1 = ldap_get_dnW( LdapHandle, CurrentEntry );

    if (nextEntry != NULL) {

        dn2 = ldap_get_dnW( LdapHandle, nextEntry );

    } else {

        dn2 = NULL;
    }

    if (dn2 != NULL) {
        if (dn1 == NULL) {
            dn1 = dn2;
            dn2 = NULL;
        } else {
            strCount += 1;
        }
    }

    if (dn1 != NULL) {
        strCount += 1;
    }    
        

    BinlPrint(( DEBUG_ERRORS, "Warning - BINL received multiple records for a single GUID.\n" ));

    strings[0] = GuidString;
    strings[1] = dn1;
    strings[2] = dn2;
    strings[3] = NULL;
    
    BinlReportEventW( BINL_DUPLICATE_DS_RECORD,
                      EVENTLOG_WARNING_TYPE,
                      strCount,
                      0,
                      strings,
                      NULL
                      );

    ldap_memfree( dn1 );            // it's ok to call ldap_memfree with null
    ldap_memfree( dn2 );

    CoTaskMemFree( GuidString );
}

#ifndef DSCRACKNAMES_DNS
DWORD
BinlDNStoFQDN(
    PWCHAR   pMachineDNS,
    PWCHAR * ppMachineDN )
{
    DWORD Error;
    DWORD LdapError;
    WCHAR FilterTemplate[] = L"dnsHostName=%ws";
    PWCHAR Filter = NULL;
    PWCHAR ComputerAttrs[2];
    PLDAPMessage CurrentEntry;
    PLDAPMessage LdapMessage = NULL;
    LDAP *LdapHandle;
    PWCHAR * Base;
    PWCHAR * MachineDN;
    DWORD count;
    DWORD uSize;
    ULONG ldapRetryLimit = 0;

    TraceFunc( "BinlDNStoFQDN( )\n" );

    BinlAssert( ppMachineDN );
    BinlAssert( pMachineDNS );

    ComputerAttrs[0] = &L"distinguishedName";
    ComputerAttrs[1] = NULL;

    //  Build the filter to find the Computer object
    uSize = sizeof(FilterTemplate)  // include NULL terminater
          + (wcslen( pMachineDNS ) * sizeof(WCHAR));
    Filter = (LPWSTR) BinlAllocateMemory( uSize );
    if ( !Filter ) {
        Error = E_OUTOFMEMORY;
        goto e0;
    }
    wsprintf( Filter, FilterTemplate, pMachineDNS );
    BinlPrintDbg(( DEBUG_MISC, "Searching for %ws...\n", Filter ));

RetryConnection:
    Error = InitializeConnection( FALSE, &LdapHandle, &Base );
    if ( Error != ERROR_SUCCESS ) {
        SetLastError( Error );
        Error = ERROR_BINL_INITIALIZE_LDAP_CONNECTION_FAILED;
        goto e0;
    }

Retry:
    LdapError = ldap_search_ext_sW( LdapHandle,
                                    *Base,
                                    LDAP_SCOPE_SUBTREE,
                                    Filter,
                                    ComputerAttrs,
                                    FALSE,
                                    NULL,
                                    NULL,
                                    NULL,
                                    0,
                                    &LdapMessage);
    switch (LdapError)
    {
    case LDAP_SUCCESS:
        break;

    case LDAP_BUSY:
        if (++ldapRetryLimit < LDAP_BUSY_LIMIT) {
            Sleep( LDAP_BUSY_DELAY );
            goto Retry;
        }

        // lack of break is on purpose.

    default:
        BinlPrintDbg(( DEBUG_ERRORS, "!!LdapError 0x%08x - Search failed in DNStoFQDN.\n", LdapError ));

        HandleLdapFailure(  LdapError,
                            EVENT_WARNING_LDAP_SEARCH_ERROR,
                            FALSE,
                            &LdapHandle,
                            FALSE );    // don't have lock
        if (LdapHandle == NULL) {
            if (++ldapRetryLimit < LDAP_SERVER_DOWN_LIMIT) {
                goto RetryConnection;
            }
        }
        
        goto e1;
        
    }

    //  Did we get a Computer Object?
    count = ldap_count_entries( LdapHandle, LdapMessage );
    if ( count == 0 ) {
        Error = ERROR_BINL_UNABLE_TO_CONVERT;
        goto e1; // nope
    }

    // if we get more than more entry back, we will use only the
    // first one.
    CurrentEntry = ldap_first_entry( LdapHandle, LdapMessage );

    MachineDN = ldap_get_values( LdapHandle, CurrentEntry, ComputerAttrs[0] );
    if ( !MachineDN ) {
        Error = ERROR_BINL_UNABLE_TO_CONVERT;
        goto e1;
    }

    *ppMachineDN = BinlStrDup( *MachineDN );

    Error = ERROR_SUCCESS;

    ldap_value_free( MachineDN );
e1:
    if (LdapMessage) {
        ldap_msgfree( LdapMessage );
    }
e0:
    return Error;
}
#endif // DSCRACKNAMES_DNS

// message.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\netinf.c ===
/*
Module Name:

    netinfp.c

Abstract:

    This module implements our routines to parse net card INF files.

Author:

    Andy Herron Mar 12 1998

Revision History:

*/

#include "binl.h"
#pragma hdrstop

#include "netinfp.h"

//  for verbose output, define the following
//#define NET_INF_VERBOSE 1

ULONG
NetInfAllocateNetcardInfo (
    PWCHAR InfPath,
    ULONG Architecture,
    PNETCARD_INF_BLOCK *pNetCards
    )
/*++

Routine Description:

    This function is allocates the block that contains all the relavent info
    related to a given setup directory's INF files.


Arguments:

    InfPath - path to INF directory.  default is %systemroot%\inf if NULL.

    pNetCards - A pointer to a pointer that receives the allocated
        NETCARD_INF_BLOCK block allocated.  NULL if we return an error.

Return Value:

    Windows Error.

--*/
{
    ULONG i;
    PNETCARD_INF_BLOCK pBlock;

    *pNetCards = BinlAllocateMemory( sizeof( NETCARD_INF_BLOCK ) +
                                     (wcslen( InfPath )+1) * sizeof(WCHAR) );

    if (*pNetCards == NULL) {

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memset( (PCHAR) *pNetCards, '\0', sizeof( NETCARD_RESPONSE_DATABASE ) );

    pBlock = *pNetCards;

    pBlock->ReferenceCount = 2; // one for being alive.  one for referenced

    for (i = 0; i < NETCARD_HASH_TABLE_SIZE; i++) {
        InitializeListHead( &pBlock->NetCardEntries[i] );
    }
    InitializeCriticalSection( &pBlock->Lock );
    wcscpy( pBlock->InfDirectory, InfPath );
    pBlock->Architecture = Architecture;
    pBlock->FileListCallbackFunction = NULL;
    pBlock->InfBlockEntry.Flink = NULL;

    return ERROR_SUCCESS;
}

ULONG
GetNetCardList (
    PNETCARD_INF_BLOCK pNetCards
    )
/*++

Routine Description:

    We go through all the INF files on the server to pick out the net
    cards supported and the required reg fields to send to the client.

    This function uses the FindFirstFile and SetupOpenInfFile APIs to
    enumerate all the inf files and process all net card INFs.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

Return Value:

    Windows Error.

--*/
{
    ULONG err = ERROR_SUCCESS;
    HINF infHandle;
    WCHAR fileBuffer[ MAX_PATH ];
    HANDLE findHandle = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW findData;
    PWCHAR endOfPath;

    //
    //  We would call SetupGetInfFileList here rather than FindFirstFile,
    //  but then we'd have to open all the INFs three times rather than
    //  once.  Once to figure out how much space the file name buffer requires,
    //  once to fill in the file name buffer, and once to do our own
    //  processing.
    //  We'll skip the first two passes since they're just a waste of time
    //  by calling FindFirstFile.
    //

    if (0  >  _snwprintf( fileBuffer,
                          MAX_PATH,
                          L"%ws\\*.inf",
                          pNetCards->InfDirectory )) {
        err = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        BinlPrintDbg(( DEBUG_NETINF,"_snwprintf failed" ));
        goto exitGetCards;
    }
    fileBuffer[MAX_PATH-1] = L'\0';
    
    findHandle = FindFirstFileW( fileBuffer, &findData );

    if (findHandle == INVALID_HANDLE_VALUE) {

        //
        //  we're in trouble.  can't enumerate all the files.
        //

        err = GetLastError();
        BinlPrintDbg(( DEBUG_NETINF,"FindFirstFile returned 0x%x\n", err ));
        goto exitGetCards;
    }

    wsprintf( fileBuffer, L"%ws\\",pNetCards->InfDirectory);
    
    endOfPath = fileBuffer + wcslen( fileBuffer );

    do {

        //
        // Skip directories
        //

        if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            continue;
        }

        //
        // make sure we have enough room.
        //
        if ( ((endOfPath - fileBuffer)/sizeof(WCHAR)) + wcslen(findData.cFileName) + 1 > MAX_PATH) {
            err = ERROR_NOT_ENOUGH_SERVER_MEMORY;
            continue;
        }

        wcscpy( endOfPath, findData.cFileName );

        //
        //  try to be resiliant for ill formatted INF files.
        //

        try {

            infHandle = SetupOpenInfFileW( fileBuffer,
                                           L"NET",              // class of inf file
                                           INF_STYLE_WIN4 | INF_STYLE_CACHE_ENABLE,
                                           NULL );

            if (infHandle != INVALID_HANDLE_VALUE) {

                err = ProcessInfFile(   pNetCards,
                                        infHandle,
                                        findData.cFileName );

                SetupCloseInfFile( infHandle );

            } else {

                err = GetLastError();
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {

            //
            //  log an error here that we trapped out on a bad INF
            //

            PWCHAR strings[3];

            strings[0] = pNetCards->InfDirectory;
            strings[1] = findData.cFileName;
            strings[2] = NULL;

            BinlReportEventW(   ERROR_BINL_ERR_IN_INF,
                                EVENTLOG_WARNING_TYPE,
                                2,
                                0,
                                strings,
                                NULL
                                );

        }
        if (err == ERROR_NOT_ENOUGH_MEMORY) {
            break;
        }

#ifdef NET_INF_VERBOSE
        if (err != ERROR_SUCCESS && err != ERROR_CLASS_MISMATCH) {
            BinlPrintDbg(( DEBUG_NETINF,"ProcessInfFile returned 0x%x for %S\n", err, fileBuffer ));
        }
#endif

        err = ERROR_SUCCESS;
    } while (FindNextFileW(findHandle,&findData));

exitGetCards:

    if (findHandle != INVALID_HANDLE_VALUE) {

        FindClose( findHandle );
    }

    return err;
}


ULONG
ProcessInfFile (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName
    )
/*++

Routine Description:

    This function uses the SetupXxxx APIs to process a given INF file for
    all net card drivers.  Each INF file is first parsed for the MANUFACTURERS
    section.  This section contains all the section keys that contain all
    the devices.  We then enumerate all the devices in each manufacturer's
    section and call off to ParseCardDetails to add it to our list.

    As an example, the net557.inf file looks like this :

    [Manufacturer]
    %Intel%     = Intel
    %ATI%       = ATI
    %Compaq%    = Compaq
    %HPTX%      = HPTX
    %IBM%       = IBM
    %Microdyne% = Microdyne
    %Samsung%   = Samsung

    and the [ATI] section looks like this :

    [ATI]
    ; DisplayName            Section        DeviceID
    %AT2560B.DeviceDesc%   = AT2560B.ndi,   PCI\VEN_1259&DEV_2560&REV_01
    %AT2560C.DeviceDesc%   = AT2560C.ndi,   PCI\VEN_8086&DEV_1229&SUBSYS_25601259
    %AT2560CFX.DeviceDesc% = AT2560CFX.ndi, PCI\VEN_8086&DEV_1229&SUBSYS_25611259

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

    InfHandle - handle open to INF file, guarenteed to be net driver

    InfFileName - wide form of relative file name we have open.

Return Value:

    Windows Error.  We stop processing altogether at ERROR_NOT_ENOUGH_MEMORY

--*/
{
    ULONG err = ERROR_SUCCESS;
    INFCONTEXT manufacturerEnumContext;
    INFCONTEXT deviceEnumContext;
    PWCHAR manufacturer = NULL;
    ULONG sizeRequired;
    ULONG sizeAllocated = 0;
    PWCHAR strings[3];


    //
    //  We need to enumerate through the Manufacturer section first
    //

    if (SetupFindFirstLineW( InfHandle,
                             L"Manufacturer",
                             NULL,
                             &manufacturerEnumContext
                             ) == FALSE) {
        err = GetLastError();
        BinlPrintDbg(( DEBUG_NETINF, "SetupFindFirstLine failed with 0x%x in %S for Manufacturer\n",
                 err, InfFileName ));

        //
        //  log an error here that we couldn't parse INF
        //

        {
            strings[0] = InfFileName;
            strings[1] = L"Manufacturer";
            strings[2] = NULL;

            BinlReportEventW(   ERROR_BINL_ERR_IN_SECTION,
                                EVENTLOG_WARNING_TYPE,
                                2,
                                sizeof(ULONG),
                                strings,
                                &err
                                );
        }

        goto exitProcessInf;
    }

    while (1) {
    
        err = GetSetupWideTextField( &manufacturerEnumContext,
                                     1,
                                     &manufacturer,
                                     &sizeAllocated );
    
        if (err == ERROR_SUCCESS) {
    
            //
            //  we enumerate through each manufacturer section for drivers
            //
            //  since we need the display name in unicode, we use the wide
            //  APIs.
            //
    
            if (SetupFindFirstLineW( InfHandle,
                                     manufacturer,
                                     NULL,
                                     &deviceEnumContext ) == TRUE) {
                while (1) {
    
                    err = ParseCardDetails( pNetCards,
                                            InfHandle,
                                            InfFileName,
                                            &deviceEnumContext );
    
                    if (err == ERROR_NOT_ENOUGH_MEMORY) {
                        break;
                    }
    
                    if ( SetupFindNextLine( &deviceEnumContext,
                                            &deviceEnumContext ) == FALSE) {
                        break;
                    }
                }
    
                err = ERROR_SUCCESS;        // try the next card regardless
    
            } else {
                err = GetLastError();
                BinlPrintDbg(( DEBUG_NETINF, "SetupFindFirstLine failed with 0x%x in %S for Manufacturer\n",
                         err, InfFileName ));
            }
        } else {
            BinlPrintDbg(( DEBUG_NETINF, "GetSetupWideTextField failed with 0x%x in %S for Manufacturer\n",
                     err, InfFileName ));
        }
    
        if (err != ERROR_SUCCESS &&
            err != ERROR_NOT_SUPPORTED) {
    
            // log an error here? (and continue)

        }

        //
        //  if we ran out of memory on the inner loop, bail.
        //

        if (err == ERROR_NOT_ENOUGH_MEMORY) {
            break;
        }

        if ( SetupFindNextLine( &manufacturerEnumContext,
                                &manufacturerEnumContext ) == FALSE) {
            break;
        }
    }    

exitProcessInf:

#ifdef NET_INF_VERBOSE
    BinlPrintDbg(( DEBUG_NETINF, "BINL netinf returning 0x%x for %S\n", err, InfFileName ));
#endif

    if (manufacturer) {
        BinlFreeMemory(manufacturer);
    }
    return err;
}

ULONG
ParseCardDetails (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PINFCONTEXT DeviceEnumContext
    )
/*++

Routine Description:

    This function uses the SetupXxxx APIs to process an INF file for a given
    driver instance.  We check to see if it's already on the list (by hw
    description) and if it isn't, create a new one, get the rest of the info,
    and put it on the list.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

    InfHandle - handle open to INF file, guarenteed to be net driver

    InfFileName - wide form of relative file name we have open.

    DeviceEnumContext - current line that has device's hardware, name, section

Return Value:

    Windows Error.  We stop processing altogether at ERROR_NOT_ENOUGH_MEMORY

--*/
{
    ULONG err = ERROR_SUCCESS;
    PLIST_ENTRY listEntry, listHead;
    PNETCARD_RESPONSE_DATABASE pEntry = NULL;
    LONG hwLength;
    PWCHAR nextField;
    ULONG sizeRequired;
    UNICODE_STRING hwString;
    PWCHAR sectionToLog = NULL;

    PWCHAR deviceName = NULL;
    PWCHAR deviceSection = NULL;
    PWCHAR deviceHw = NULL;
    ULONG hashValue;

    err = GetSetupWideTextField( DeviceEnumContext,
                                 2,
                                 &deviceHw,
                                 NULL );
    if (err != ERROR_SUCCESS) {
        goto exitParseCardDetails;
    }

    BinlAssert(deviceHw != NULL);

    //  convert it to uppercase to speed our searches

    RtlInitUnicodeString( &hwString, deviceHw );
    RtlUpcaseUnicodeString( &hwString, &hwString, FALSE );

    err = CheckHwDescription( deviceHw );
    if (err != ERROR_SUCCESS) {

        // this should fail if it's not the format we expect.
        goto exitParseCardDetails;
    }

    //
    //  We sort the list by HwDescription so that we only have
    //  one entry for each one.  Ensure that this one is not
    //  already in the list.
    //

    COMPUTE_STRING_HASH( deviceHw, &hashValue );
    listHead = &pNetCards->NetCardEntries[HASH_TO_INF_INDEX(hashValue)];
    listEntry = listHead->Flink;

    hwLength = wcslen( deviceHw );
    pEntry = NULL;

    while ( listEntry != listHead ) {

        pEntry = (PNETCARD_RESPONSE_DATABASE) CONTAINING_RECORD(
                                                listEntry,
                                                NETCARD_RESPONSE_DATABASE,
                                                NetCardEntry );

        err = CompareStringW( LOCALE_SYSTEM_DEFAULT,
                              0,
                              deviceHw,
                              hwLength,
                              pEntry->HardwareId,
                              -1
                              );
        if (err == 2) {

            break;      // a match was found.
        }

        pEntry = NULL;

        if (err == 3) {

            break;      // it's greater, add it before listEntry
        }

        listEntry = listEntry->Flink;
    }

    if (pEntry != NULL) {

        //
        //  we've found a dup, don't process this one.
        //

        err = ERROR_SUCCESS;        // no problems here
        pEntry = NULL;
#ifdef NET_INF_VERBOSE
        BinlPrintDbg(( DEBUG_NETINF, "skipping dup of %S\n", deviceHw ));
#endif
        goto exitParseCardDetails;
    }

    //
    //  the inf name and section name are mandatory
    //

    err = GetSetupWideTextField( DeviceEnumContext,
                                 0,
                                 &deviceName,
                                 NULL );
    if (err != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_NETINF, "failed to get device name for %S\n", deviceHw ));
        goto exitParseCardDetails;
    }

    err = GetSetupWideTextField( DeviceEnumContext,
                                 1,
                                 &deviceSection,
                                 NULL );
    if (err != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_NETINF, "failed to get device section for %S\n", deviceHw ));
        goto exitParseCardDetails;
    }

    sectionToLog = deviceSection;

    if ((*deviceName == L'\0') ||
        (*deviceSection == L'\0')) {

        err = ERROR_NOT_SUPPORTED;
        BinlPrintDbg(( DEBUG_NETINF, "Empty Name or Section not supported for %S\n", deviceHw ));
        goto exitParseCardDetails;
    }

    //
    //  Allocate the buffer space required for the fields we need
    //

    sizeRequired = sizeof( NETCARD_RESPONSE_DATABASE ) +
        ( wcslen( InfFileName ) + 2 ) * sizeof(WCHAR);

    pEntry = (PNETCARD_RESPONSE_DATABASE) BinlAllocateMemory( sizeRequired );

    if (pEntry == NULL) {

        //
        //  Doh! we couldn't allocate a simple buffer.  we're done.
        //

        BinlPrintDbg(( DEBUG_NETINF, "failed to allocate new entry for %S\n", deviceHw ));
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto exitParseCardDetails;
    }

    memset( (PCHAR) pEntry, '\0', sizeRequired );

    nextField = (PWCHAR)(PCHAR)(((PCHAR) pEntry) + sizeof( NETCARD_RESPONSE_DATABASE ));

    //
    //  We hold the lock, so we don't need to reference all the
    //  entries.  Just start off the ref count at 1 for an entry
    //  that is alive but not in use.
    //

    pEntry->ReferenceCount = 1;

    pEntry->InfFileName = nextField;
    CopyMemory( nextField, InfFileName, wcslen( InfFileName ) * sizeof(WCHAR));

    pEntry->SectionName = deviceSection;
    deviceSection = NULL;

    pEntry->HardwareId = deviceHw;
    deviceHw = NULL;

    InitializeListHead( &pEntry->FileCopyList );

    pEntry->DriverDescription = deviceName;
    deviceName = NULL;

    InitializeListHead( &pEntry->Registry );

    //
    //  There's a few more fields we need to fill in before we're done with
    //  this entry.  We need to get :
    //          DriverName              "e100bnt.sys"
    //          SectionNameExt          "F1100C.ndi.ntx86"
    //          ServiceName             "E100B"
    //          Registry Additions      REG_MULTI_SZ
    //

    //
    //  determine SectionNameExt by first trying to tack on ".ntx86", if that
    //  doesn't work, try tacking on ".nt".  If that doesn't work, there aren't
    //  any extensions.
    //

    err = GetExtendedSectionName(   pNetCards,
                                    InfHandle,
                                    InfFileName,
                                    pEntry );

    if (err != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_NETINF, "failed to get extended section for %S\n", deviceHw ));
        goto exitParseCardDetails;
    }

    err = GetServiceAndDriver( pNetCards,
                               InfHandle,
                               InfFileName,
                               pEntry );

    if (err != ERROR_SUCCESS) {
        goto exitParseCardDetails;
    }

    //
    //  this gets both the CopyFiles and the misc registry settings.
    //

    err = GetRegistryParametersForDriver(   pNetCards,
                                            InfHandle,
                                            InfFileName,
                                            pEntry );

    if (err != ERROR_SUCCESS) {
        goto exitParseCardDetails;
    }

    //
    //  Either pInfEntry is NULL, in which case listEntry is equal
    //  to the head of the list, or it's not NULL, in which case
    //  listEntry is equal to that entries listEntry.  In either
    //  case, we can simply insert this new entry onto the tail
    //  of listEntry.
    //

    InsertTailList( listEntry, &pEntry->NetCardEntry );

exitParseCardDetails:

    if (err != ERROR_SUCCESS && err != ERROR_NOT_SUPPORTED) {

        PWCHAR strings[3];
        strings[0] = InfFileName;
        strings[1] = sectionToLog;
        strings[2] = NULL;

        BinlReportEventW(   ERROR_BINL_ERR_IN_SECTION,
                            EVENTLOG_WARNING_TYPE,
                            (sectionToLog == NULL) ? 1 : 2,
                            sizeof(ULONG),
                            strings,
                            &err
                            );
    }

    //
    //  free anything that didn't get used
    //

    if (deviceName) {
        BinlFreeMemory(deviceName);
    }
    if (deviceSection) {
        BinlFreeMemory(deviceSection);
    }
    if (deviceHw) {
        BinlFreeMemory(deviceHw);
    }

    if (pEntry != NULL && err != ERROR_SUCCESS) {

        NetInfDereferenceNetcardEntry( pEntry );
    }


    return err;
}


ULONG
GetExtendedSectionName (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry
    )
/*++

Routine Description:

    This function uses the SetupXxxx APIs to process an INF file for a given
    driver instance.  We parse the inf file for the extended section name
    for the specified platform (x86, alpha, ia64, etc).

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

    InfHandle - handle open to INF file, guarenteed to be net driver

    InfFileName - wide form of relative file name we have open.

    pEntry - entry for which to get section names, base section name present

Return Value:

    Windows Error.  We stop processing altogether at ERROR_NOT_ENOUGH_MEMORY

--*/
{
    ULONG err;
    PWCHAR extSectionName;
    ULONG sizeRequired;
    INFCONTEXT context;
    PWCHAR architecture;

    //  allocate space for the longest name we need, we'll shorten it later.

    switch(pNetCards->Architecture) {
#if 0
        // obsolete architectures.
        case PROCESSOR_ARCHITECTURE_ALPHA;
            architecture = L"alpha";
            break;
        case PROCESSOR_ARCHITECTURE_ALPHA64:
            architecture = L"axp64";
            break;
        case PROCESSOR_ARCHITECTURE_MIPS:
            architecture = L"mips";
            break;
        case PROCESSOR_ARCHITECTURE_PPC:
            architecture = L"ppc";
            break;
#endif
        case PROCESSOR_ARCHITECTURE_AMD64:
            architecture = L"amd64";
            break;
        case PROCESSOR_ARCHITECTURE_IA64:
            architecture = L"ia64";
            break;
        case PROCESSOR_ARCHITECTURE_INTEL:
        default:
            architecture = L"x86";
            break;
    }

    sizeRequired = wcslen( pEntry->SectionName ) +
                   wcslen( architecture ) +
                   sizeof( ".nt" ); // sizeof contains the '\0'

    extSectionName = (PWCHAR) BinlAllocateMemory( sizeRequired * sizeof(WCHAR) );

    if (extSectionName == NULL) {

        BinlPrintDbg(( DEBUG_NETINF, "failed to allocate ext section buffer for %S\n", pEntry->HardwareId ));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //  first try to find the .ntx86 form.
    //

    wsprintf( 
        extSectionName, 
        L"%ws.nt%ws",
        pEntry->SectionName,
        architecture);
    
    if (SetupFindFirstLineW(InfHandle,
                            extSectionName,
                            NULL,
                            &context) == TRUE) {

        pEntry->SectionNameExt = extSectionName;
        return ERROR_SUCCESS;
    }

    //
    //  next try to find the .nt form.
    //

    wsprintf( extSectionName, L"%ws.nt",pEntry->SectionName );
    
    if (SetupFindFirstLineW(InfHandle,
                            extSectionName,
                            NULL,
                            &context) == TRUE) {

        pEntry->SectionNameExt = extSectionName;
        return ERROR_SUCCESS;
    }

    BinlFreeMemory( extSectionName );

    pEntry->SectionNameExt = pEntry->SectionName;
    return ERROR_SUCCESS;
}


ULONG
GetServiceAndDriver (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry
    )
/*++

Routine Description:

    This function uses the SetupXxxx APIs to process an INF file for a given
    driver instance.  We parse the inf file for the service name and driver
    name for each platform we support (x86 and alpha).

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

    InfHandle - handle open to INF file, guarenteed to be net driver

    InfFileName - wide form of relative file name we have open.

    pEntry - entry for which to get section names, ext section name present

Return Value:

    Windows Error.  We stop processing altogether at ERROR_NOT_ENOUGH_MEMORY

--*/
{
    ULONG err = ERROR_SUCCESS;
    PWCHAR servSectionName = NULL;
    ULONG sizeRequired;
    INFCONTEXT context;
    LONG lineCount;
    PWCHAR serviceString = NULL;
    PWCHAR driverFullName = NULL;
    PWCHAR driverName;
    PWCHAR postSlash;

    //  allocate space for the longest name we need, we'll shorten it later.

    sizeRequired = wcslen( pEntry->SectionNameExt ) + (sizeof(L".Services")/sizeof(WCHAR)); //sizeof contains the '\0'

    servSectionName = (PWCHAR) BinlAllocateMemory( sizeRequired * sizeof(WCHAR) );

    if (servSectionName == NULL) {

        err = ERROR_NOT_ENOUGH_MEMORY;
        BinlPrintDbg(( DEBUG_NETINF, "failed to alloc service section for %S\n", pEntry->HardwareId ));
        goto exitGetService;
    }

    wsprintf( servSectionName, L"%ws.Services", pEntry->SectionNameExt);

    lineCount = SetupGetLineCountW( InfHandle, servSectionName);

    if ((lineCount == 0 || lineCount == -1) &&
        (pEntry->SectionNameExt != pEntry->SectionName)) {

        //
        //  hmm.. the service section wasn't there.  for grins, try the
        //  base service name.
        //
        BinlAssert( wcslen(pEntry->SectionName) <= wcslen(pEntry->SectionNameExt));

        wsprintf( servSectionName, L"%ws.Services", pEntry->SectionName);
        lineCount = SetupGetLineCountW( InfHandle, servSectionName);
    }

    if (lineCount == 0 || lineCount == -1) {

        err = GetLastError();
        if (err == ERROR_SUCCESS) {
            err = ERROR_NOT_SUPPORTED;
        }
        BinlPrintDbg(( DEBUG_NETINF, "failed to find service section for %S in %S\n",
                        pEntry->HardwareId, InfFileName ));
        goto exitGetService;
    }

    if (SetupFindFirstLineW( InfHandle,
                            servSectionName,
                            L"AddService",
                            &context ) == FALSE) {

        err = GetLastError();
        BinlPrintDbg(( DEBUG_NETINF, "failed to find AddService value for %S\n", pEntry->HardwareId ));
        goto exitGetService;
    }

    err = GetSetupWideTextField(&context,
                                1,
                                &pEntry->ServiceName,           // "E100B"
                                NULL );

    if (err != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_NETINF, "failed to find service name for %S\n", pEntry->HardwareId ));
        goto exitGetService;
    }

    err = GetSetupWideTextField(&context,
                                3,
                                &serviceString,     // "e100b.Service"
                                NULL );

    if (err != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_NETINF, "failed to find service install section for %S\n", pEntry->HardwareId ));
        goto exitGetService;
    }

    //
    //  go get the driver name from the service section
    //

    err = GetSetupLineWideText( NULL,
                                InfHandle,
                                serviceString,
                                L"ServiceBinary",
                                &driverFullName,
                                NULL );

    if (err != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_NETINF, "failed to find driver binary for %S\n", pEntry->HardwareId ));
        goto exitGetService;
    }

    //
    //  The driver comes down as a fully qualified path.  Let's strip off the
    //  path and just store off the filename.
    //

    driverName = postSlash = driverFullName;

    while (*driverName != L'\0') {

        if (*driverName == OBJ_NAME_PATH_SEPARATOR) {

            postSlash = driverName + 1;
        }
        driverName++;
    }

    //
    //  save off the root driver name into the entry
    //
    pEntry->DriverName = BinlStrDup( postSlash );
    if (pEntry->DriverName == NULL) {

        err = ERROR_NOT_ENOUGH_MEMORY;
        BinlPrintDbg(( DEBUG_NETINF, "failed to alloc memory for driver name for %S\n", pEntry->HardwareId ));
        goto exitGetService;
    }

exitGetService:

    if ( driverFullName ) {
        BinlFreeMemory( driverFullName );
    }
    if ( serviceString )  {
        BinlFreeMemory( serviceString );
    }
    if ( servSectionName ) {
        BinlFreeMemory( servSectionName );
    }
    return err;
}

ULONG
GetRegistryParametersForDriver (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry
    )
/*++

Routine Description:

    This function uses the SetupXxxx APIs to process an INF file for a given
    driver instance.  We parse the inf file for the registry parameters
    for each platform we support (x86 and alpha).

    We pass in values to update so that we can use the same code for both
    architectures.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

    InfHandle - handle open to INF file, guarenteed to be net driver

    InfFileName - wide form of relative file name we have open.

    pEntry - entry for which to get registry settings for

Return Value:

    Windows Error.  We stop processing altogether at ERROR_NOT_ENOUGH_MEMORY

--*/
{
    ULONG err = ERROR_SUCCESS;
    INFCONTEXT infContext;
    ULONG  bufferLength;
    PWCHAR keyBuffer = NULL;
    ULONG  keyBufferLength = 0;

    if (SetupFindFirstLineW( InfHandle,
                             pEntry->SectionNameExt,
                             NULL,
                             &infContext) == FALSE) {

        err = GetLastError();
        BinlPrintDbg(( DEBUG_NETINF, "failed to find section name of %S in %S\n",
                    pEntry->SectionNameExt, InfFileName ));
        goto exitGetRegistry;
    }
    //
    //  process each line in the section by either storing it off if it's one
    //  we don't recognize, ignoring it, or (for AddReg) process each value
    //  as yet another section to process.
    //

    while (1) {

        //
        //  process current line represented by infContext then go back for
        //  another
        //

        err = GetSetupWideTextField(&infContext,
                                    0,
                                    &keyBuffer,
                                    &keyBufferLength );

        if (err != ERROR_SUCCESS) {
            BinlPrintDbg(( DEBUG_NETINF, "failed to find service name for %S\n", pEntry->HardwareId ));
            goto exitGetRegistry;
        }

        if (CompareStringW( LOCALE_INVARIANT,
                            NORM_IGNORECASE,
                            keyBuffer,
                            -1,
                            L"CopyFiles",
                            -1 ) == 2) {

            // for each value, read off the CopyFiles section

            ULONG limit, i;

            limit = SetupGetFieldCount( &infContext );

            for (i = 1; i <= limit; i++ ) {

                err = GetSetupWideTextField(&infContext,
                                            i,
                                            &keyBuffer,
                                            &keyBufferLength );

                
                if (err != ERROR_SUCCESS) {
                    break;
                }

                if (*keyBuffer == L'\0') {
                    goto getNextCopySubsection;
                }
                err = ProcessCopyFilesSubsection(   pNetCards,
                                                    InfHandle,
                                                    InfFileName,
                                                    pEntry,
                                                    keyBuffer );
                if (err != ERROR_SUCCESS) {
#ifdef NET_INF_VERBOSE
                    BinlPrintDbg(( DEBUG_NETINF, "failed with 0x%x in section name of %S in %S\n",
                                err, keyBuffer, InfFileName ));
#endif
                    break;
                }
getNextCopySubsection:
                NOTHING;
            }

            //
            //  we'll ignore errors during processing subsections for now, as
            //  some sections are reported as not found.
            //

            if (err != ERROR_NOT_ENOUGH_MEMORY) {

                err = ERROR_SUCCESS;
            }

        } else if (CompareStringW( LOCALE_INVARIANT,
                                   NORM_IGNORECASE,
                                   keyBuffer,
                                   -1,
                                   L"AddReg",
                                   -1 ) == 2) {

            // for each value, read off the registry section

            ULONG limit, i;

            limit = SetupGetFieldCount( &infContext );

            for (i = 1; i <= limit; i++ ) {

                err = GetSetupWideTextField(&infContext,
                                            i,
                                            &keyBuffer,
                                            &keyBufferLength );

                if (err != ERROR_SUCCESS) {
                    break;
                }

                if (*keyBuffer == L'\0') {
                    goto getNextRegistrySubsection;
                }
                err = ProcessRegistrySubsection(    pNetCards,
                                                    InfHandle,
                                                    InfFileName,
                                                    pEntry,
                                                    keyBuffer );
                if (err != ERROR_SUCCESS) {
#ifdef NET_INF_VERBOSE
                    BinlPrintDbg(( DEBUG_NETINF, "failed with 0x%x in section name of %S in %S\n",
                                err, keyBuffer, InfFileName ));
#endif
                    break;
                }
getNextRegistrySubsection:
                NOTHING;
            }

            //
            //  we'll ignore errors during processing subsections for now, as
            //  some sections are reported as not found.
            //

            if (err != ERROR_NOT_ENOUGH_MEMORY) {

                err = ERROR_SUCCESS;
            }

        } else {

            PWCHAR textLine = NULL;

            //
            //  so far as we know, the only other ones are characteristics and
            //  BusType.  but there could certainly be others.
            //

            err = GetSetupLineWideText( &infContext,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &textLine,
                                        NULL );
            if (err == ERROR_SUCCESS) {

                PNETCARD_REGISTRY_PARAMETERS regParam;

                regParam = (PNETCARD_REGISTRY_PARAMETERS) BinlAllocateMemory(
                                sizeof(NETCARD_REGISTRY_PARAMETERS));

                if (regParam == NULL) {

                    BinlFreeMemory( textLine );
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                RtlInitUnicodeString( &regParam->Parameter, keyBuffer );
                keyBuffer = NULL;
                keyBufferLength = 0;

                RtlInitUnicodeString( &regParam->Value, textLine );

                //
                //  The only ones we know about are BusType, Characteristics,
                //  and
                //  BusType is an integer.  Characteristics (and anything else
                //  just to be safe) is a string.
                //

                if ((CompareStringW( LOCALE_INVARIANT,
                                    NORM_IGNORECASE,
                                    regParam->Parameter.Buffer,
                                    -1,
                                    L"Characteristics",
                                    -1) == 2) ||
                    (CompareStringW( LOCALE_INVARIANT,
                                    NORM_IGNORECASE,
                                    regParam->Parameter.Buffer,
                                    -1,
                                    L"BusType",
                                    -1) == 2))  {

                    ULONG tmpValue = 0;

                    regParam->Type = NETCARD_REGISTRY_TYPE_INT;

                    //
                    //  ensure the value is in decimal
                    //

                    err = RtlUnicodeStringToInteger( &regParam->Value, 0, &tmpValue );

                    if (err == STATUS_SUCCESS) {

                        PWCHAR valueBuffer;
                        UNICODE_STRING decimalString;

                        //
                        //  now that we have the value, convert it to decimal
                        //

                        valueBuffer = (PWCHAR) BinlAllocateMemory( 20 * sizeof(WCHAR) );

                        if (valueBuffer == NULL) {

                            BinlFreeMemory( textLine );
                            BinlFreeMemory( regParam->Parameter.Buffer );
                            BinlFreeMemory( regParam );
                            err = ERROR_NOT_ENOUGH_MEMORY;
                            goto exitGetRegistry;
                        }

                        decimalString.Buffer = valueBuffer;
                        decimalString.Length = 0;
                        decimalString.MaximumLength = 20 * sizeof(WCHAR);

                        err = RtlIntegerToUnicodeString( tmpValue, 10, &decimalString );

                        if ( err == STATUS_SUCCESS ) {

                            //
                            //  if it succeeded, reset the value to the new
                            //  buffer, otherwise leave the old one in place.
                            //

                            BinlFreeMemory( textLine );
                            RtlInitUnicodeString( &regParam->Value, valueBuffer );
                        }
                    }

                } else {

                    regParam->Type = NETCARD_REGISTRY_TYPE_STRING;
                }

                InsertTailList( &pEntry->Registry, &regParam->RegistryListEntry );
            }
        }

        if (SetupFindNextLine( &infContext, &infContext ) == FALSE ) {
            break;
        }
    }

    err = ERROR_SUCCESS;

exitGetRegistry:

    if ( keyBuffer ) {
        BinlFreeMemory( keyBuffer );
    }
    return err;
}

ULONG
ProcessRegistrySubsection (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry,
    PWCHAR SectionToParse
    )
/*++

Routine Description:

    This function uses the SetupXxxx APIs to process an INF file for a given
    driver instance.  We parse the inf file for the registry section given.
    Note that this is a different format than the extended install section.

    Here's an example of the lines we parse :

    HKR, Ndi\params\NumCoalesce,    type,       0, "int"
    HKR, ,                          MsPciScan,  0, "2"

    Note that we skip everything in the Ndi registry area.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

    InfHandle - handle open to INF file, guarenteed to be net driver

    InfFileName - wide form of relative file name we have open.

    pEntry - entry for which to get registry settings for

    SectionToParse - what section in the INF do we start with

Return Value:

    Windows Error.  We stop processing altogether at ERROR_NOT_ENOUGH_MEMORY

--*/
{
    ULONG err = ERROR_SUCCESS;
    INFCONTEXT infContext;
    ULONG  bufferLength;
    PWCHAR keyBuffer = NULL;
    ULONG  keyBufferLength = 0;
    PWCHAR parameterBuffer = NULL;
    PWCHAR valueBuffer;

    if (SetupFindFirstLineW( InfHandle,
                             SectionToParse,
                             NULL,
                             &infContext) == FALSE) {

        err = GetLastError();
        BinlPrintDbg(( DEBUG_NETINF, "failed to find section name of %S in %S\n",
                    SectionToParse, InfFileName ));
        goto exitGetRegistry;
    }
    //
    //  process each line in the section by either storing it off if it's one
    //  we don't recognize, ignoring it, or (for AddReg) process each value
    //  as yet another section to process.
    //

    while (1) {

        //
        //  process current line represented by infContext then go back for
        //  another
        //

        err = GetSetupWideTextField(&infContext,
                                    1,
                                    &keyBuffer,
                                    &keyBufferLength );

        if (err != ERROR_SUCCESS) {
            BinlPrintDbg(( DEBUG_NETINF, "failed to find registry value in %S in %S\n", SectionToParse, InfFileName ));
            goto OnToNextValue;
        }

        if (CompareStringW( LOCALE_INVARIANT,
                            NORM_IGNORECASE,
                            keyBuffer,
                            -1,
                            L"HKR",
                            -1 ) != 2) {


            BinlPrintDbg(( DEBUG_NETINF, "got something other than HKR, %S for %S\n", keyBuffer, InfFileName ));
            goto OnToNextValue;
        }

        err = GetSetupWideTextField(&infContext,
                                    2,
                                    &keyBuffer,
                                    &keyBufferLength );

        if (err != ERROR_SUCCESS) {

            BinlPrintDbg(( DEBUG_NETINF, "failed to get 2nd field in %S in %S\n", SectionToParse, InfFileName ));
            goto OnToNextValue;
        }

        if (IsSubString( L"Ndi", keyBuffer, TRUE )) {

            goto OnToNextValue;
        }

        //
        //  not part of the NDIS settings, we'll save this one off.
        //

        parameterBuffer = NULL;

        err = GetSetupWideTextField(&infContext,
                                    3,
                                    &parameterBuffer,
                                    NULL );

        if (err != ERROR_SUCCESS) {
            BinlPrintDbg(( DEBUG_NETINF, "failed to get 3rd field in %S in %S\n", SectionToParse, InfFileName ));
            goto OnToNextValue;
        }

        //
        //  check for empty parameter strings.  there are some infs that
        //  contain empty parameter names
        //

        valueBuffer = parameterBuffer;

        while (*valueBuffer == L' ') {
            valueBuffer++;
        }

        if (*valueBuffer != L'\0') {

            ULONG fieldFlags;
            ULONG regType;

            valueBuffer = NULL;

            if (SetupGetIntField( &infContext, 4, &fieldFlags) == FALSE) {

                err = GetLastError();
                BinlPrintDbg(( DEBUG_NETINF, "failed to get 4th field in %S in %S\n", parameterBuffer, InfFileName ));
                BinlFreeMemory( parameterBuffer );
                goto OnToNextValue;
            }

            if ((fieldFlags & FLG_ADDREG_TYPE_MASK) == FLG_ADDREG_TYPE_SZ) {

                //
                //  the value is a string.
                //

                err = GetSetupWideTextField(&infContext,
                                            5,
                                            &valueBuffer,
                                            NULL );

                if (err != ERROR_SUCCESS) {
                    BinlPrintDbg(( DEBUG_NETINF, "failed to get 5th field in %S in %S\n", parameterBuffer, InfFileName ));
                }

                if (*valueBuffer == L'\0') {

#ifdef NET_INF_VERBOSE
                    BinlPrintDbg(( DEBUG_NETINF, "found empty value for %S in %S\n", parameterBuffer, InfFileName  ));
#endif
                    BinlFreeMemory( valueBuffer );
                    BinlFreeMemory( parameterBuffer );
                    goto OnToNextValue;
                }
                regType = NETCARD_REGISTRY_TYPE_STRING;

            } else if ((fieldFlags & FLG_ADDREG_TYPE_MASK) == FLG_ADDREG_TYPE_DWORD) {

                ULONG intValue;

                regType = NETCARD_REGISTRY_TYPE_INT;

                //
                //  the value is a dword, let's grab it and store off it's
                //  string representation
                //

                if (SetupGetIntField( &infContext, 5, &intValue) == FALSE) {

                    err = GetLastError();
                    BinlPrintDbg(( DEBUG_NETINF, "failed to get value field in %S in %S\n", parameterBuffer, InfFileName ));

                } else {

                    UNICODE_STRING valueString;
                    WCHAR resultBuffer[16];

                    valueString.Buffer = resultBuffer;
                    valueString.Length = 0;
                    valueString.MaximumLength = 16 * sizeof(WCHAR);

                    err = RtlIntegerToUnicodeString( intValue, 10, &valueString );

                    if (err == ERROR_SUCCESS) {

                        valueBuffer = BinlAllocateMemory( valueString.Length + sizeof(WCHAR) );

                        if (valueBuffer == NULL) {

                            BinlFreeMemory( parameterBuffer );
                            err = ERROR_NOT_ENOUGH_MEMORY;
                            break;
                        }

                        CopyMemory( valueBuffer, resultBuffer, valueString.Length );
                    }
                }
            } else {

                BinlPrintDbg(( DEBUG_NETINF, "currently don't parse flags=0x%x in %S %S\n", fieldFlags, parameterBuffer, InfFileName ));
                err = ERROR_NOT_SUPPORTED;
            }

            if (err == ERROR_SUCCESS) {

                PNETCARD_REGISTRY_PARAMETERS regParam;

                //
                //  we have a parameter name and an associated value to store
                //  off.  let's allocate the list entry and store it on the list.
                //

                regParam = (PNETCARD_REGISTRY_PARAMETERS) BinlAllocateMemory(
                                sizeof(NETCARD_REGISTRY_PARAMETERS));

                if (regParam == NULL) {

                    BinlFreeMemory( valueBuffer );
                    BinlFreeMemory( parameterBuffer );
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                regParam->Type = regType;
                RtlInitUnicodeString( &regParam->Parameter, parameterBuffer );
                parameterBuffer = NULL;
                RtlInitUnicodeString( &regParam->Value, valueBuffer );
                valueBuffer = NULL;

                InsertTailList( &pEntry->Registry, &regParam->RegistryListEntry );
            }
        }

        if (parameterBuffer) {

            BinlFreeMemory( parameterBuffer );
        }

OnToNextValue:
        if (SetupFindNextLine( &infContext, &infContext ) == FALSE ) {
            break;
        }
    }

    err = ERROR_SUCCESS;

exitGetRegistry:

    if ( keyBuffer ) {
        BinlFreeMemory( keyBuffer );
    }
    return err;
}

ULONG
ProcessCopyFilesSubsection (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry,
    PWCHAR SectionToParse
    )
/*++

Routine Description:

    This function uses the SetupXxxx APIs to process an INF file for a given
    driver instance.  We parse the inf file for the registry section given.
    Note that this is a different format than the extended install section.

    Here's an example of the lines we parse :

    CopyFiles = @elnk90.sys
    CopyFiles = e100b.CopyFiles

    [e100b.CopyFiles]
    e100bnt.sys,,,2
    n100.sys,n100nt.sys,,2

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

    InfHandle - handle open to INF file, guarenteed to be net driver

    InfFileName - wide form of relative file name we have open.

    pEntry - entry for which to get registry settings for

    SectionToParse - what section in the INF do we start with

Return Value:

    Windows Error.  We stop processing altogether at ERROR_NOT_ENOUGH_MEMORY

--*/
{
    PNETCARD_FILECOPY_PARAMETERS fileCopy;
    ULONG err = ERROR_SUCCESS;
    INFCONTEXT infContext;
    PWCHAR sourceFileBuffer = NULL;
    ULONG  sourceFileBufferLength = 0;
    PWCHAR destFileBuffer = NULL;
    PWCHAR sourceFile;
    ULONG  destFileBufferLength = 0;
    PWCHAR tempPtr;

    if (*SectionToParse == L'@') {

        if (CompareStringW( LOCALE_SYSTEM_DEFAULT,
                            NORM_IGNORECASE,
                            SectionToParse+1,
                            -1,
                            pEntry->DriverName,
                            -1 ) == 2) {

            if (pNetCards->FileListCallbackFunction != NULL) {
                err = (*pNetCards->FileListCallbackFunction)( pNetCards->FileListCallbackContext,
                                                              InfFileName,
                                                              pEntry->DriverName );
            } else {
                err = STATUS_SUCCESS;
            }
            BinlPrintDbg(( DEBUG_NETINF, "Ignoring driver file %S as we already know that.\n", SectionToParse ));
            return err;
        }

        //
        //  the section name itself represents the file to copy
        //

        fileCopy = (PNETCARD_FILECOPY_PARAMETERS) BinlAllocateMemory(
                        sizeof(NETCARD_FILECOPY_PARAMETERS));

        if (fileCopy == NULL) {

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        RtlInitUnicodeString( &fileCopy->DestFile, NULL );
        fileCopy->SourceFile.Length = (USHORT)(wcslen( SectionToParse+1 ) * sizeof(WCHAR));
        fileCopy->SourceFile.MaximumLength = fileCopy->SourceFile.Length + sizeof(WCHAR);
        fileCopy->SourceFile.Buffer = (PWCHAR) BinlAllocateMemory( fileCopy->SourceFile.MaximumLength );

        if (fileCopy->SourceFile.Buffer == NULL) {

            BinlFreeMemory( fileCopy );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy( fileCopy->SourceFile.Buffer, SectionToParse+1 );   // skip @

        if (pNetCards->FileListCallbackFunction != NULL) {
            err = (*pNetCards->FileListCallbackFunction)( pNetCards->FileListCallbackContext,
                                                          InfFileName,
                                                          fileCopy->SourceFile.Buffer );
        } else {
            err = STATUS_SUCCESS;
        }

        InsertTailList( &pEntry->FileCopyList, &fileCopy->FileCopyListEntry );
        return err;
    }

    if (SetupFindFirstLineW( InfHandle,
                             SectionToParse,
                             NULL,
                             &infContext) == FALSE) {

        err = GetLastError();
        BinlPrintDbg(( DEBUG_NETINF, "failed to find section name of %S in %S\n",
                    SectionToParse, InfFileName ));
        goto exitGetRegistry;
    }
    //
    //  process each line in the section by storing it off
    //

    while (1) {

        //
        //  process current line represented by infContext then go back for
        //  another
        //

        err = GetSetupWideTextField(&infContext,
                                    1,
                                    &destFileBuffer,
                                    &destFileBufferLength );

        if (err != ERROR_SUCCESS) {
            BinlPrintDbg(( DEBUG_NETINF, "failed to find registry value in %S in %S\n", SectionToParse, InfFileName ));
            goto OnToNextValue;
        }

        if (CompareStringW( LOCALE_SYSTEM_DEFAULT,
                            NORM_IGNORECASE,
                            destFileBuffer,
                            -1,
                            pEntry->DriverName,
                            -1 ) == 2) {

            if (pNetCards->FileListCallbackFunction != NULL) {
                err = (*pNetCards->FileListCallbackFunction)( pNetCards->FileListCallbackContext,
                                                              InfFileName,
                                                              pEntry->DriverName );
                if (err != ERROR_SUCCESS) {
                    goto exitGetRegistry;
                }
            }
            BinlPrintDbg(( DEBUG_NETINF, "Ignoring driver file %S as we already know that.\n", sourceFileBuffer ));
            goto OnToNextValue;
        }

        //
        //  ensure that there's a value there.
        //

        tempPtr = destFileBuffer;

        while (*tempPtr == L' ') {
            tempPtr++;
        }

        if (*tempPtr == L'\0') {
            BinlPrintDbg(( DEBUG_NETINF, "Ignoring null file to copy in %S.\n", InfFileName ));
            goto OnToNextValue;
        }
        
        fileCopy = (PNETCARD_FILECOPY_PARAMETERS) BinlAllocateMemory(
                        sizeof(NETCARD_FILECOPY_PARAMETERS));

        if (fileCopy == NULL) {

            err = ERROR_NOT_ENOUGH_MEMORY;
            goto exitGetRegistry;
        }
                
        err = GetSetupWideTextField(&infContext,
                                    2,
                                    &sourceFileBuffer,
                                    &sourceFileBufferLength );

        if (err != ERROR_SUCCESS) {

            sourceFile = NULL;

        } else {

            tempPtr = sourceFileBuffer;

            while (*tempPtr == L' ') {
                tempPtr++;
            }

            if (*tempPtr == L'\0') {

                sourceFile = NULL;
            
            } else {

                sourceFile = sourceFileBuffer;
                sourceFileBuffer = NULL;
                sourceFileBufferLength = 0;
            }
        }

        err = ERROR_SUCCESS;

        if (sourceFile == NULL) {

            //
            //  if only the dest is given, only fill in the source since
            //  the client code is written that way already.
            //

            RtlInitUnicodeString( &fileCopy->DestFile, NULL );
            RtlInitUnicodeString( &fileCopy->SourceFile, destFileBuffer );

            if (pNetCards->FileListCallbackFunction != NULL) {
                err = (*pNetCards->FileListCallbackFunction)( pNetCards->FileListCallbackContext,
                                                              InfFileName,
                                                              destFileBuffer );
            }

        } else {

            RtlInitUnicodeString( &fileCopy->DestFile, destFileBuffer );
            RtlInitUnicodeString( &fileCopy->SourceFile, sourceFile );

            if (pNetCards->FileListCallbackFunction != NULL) {
                err = (*pNetCards->FileListCallbackFunction)( pNetCards->FileListCallbackContext,
                                                              InfFileName,
                                                              sourceFile );
            }
        }

        destFileBuffer = NULL;
        destFileBufferLength = 0;

        InsertTailList( &pEntry->FileCopyList, &fileCopy->FileCopyListEntry );

        if (err != ERROR_SUCCESS) {
            goto exitGetRegistry;
        }

OnToNextValue:
        if (SetupFindNextLine( &infContext, &infContext ) == FALSE ) {
            break;
        }
    }

    err = ERROR_SUCCESS;

exitGetRegistry:

    if ( sourceFileBuffer ) {
        BinlFreeMemory( sourceFileBuffer );
    }
    if ( destFileBuffer ) {
        BinlFreeMemory( destFileBuffer );
    }

    return err;
}


// netinf.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\netinf.h ===
/*++

Copyright (c) 1994-7  Microsoft Corporation

Module Name:

    netinf.h

Abstract:

    This file contains the structures and prototypes necessary for the
    netcard inf parser handler as required by the BINL remote boot server.

Author:

    Andy Herron (andyhe)  12-Mar-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NETINF_
#define _NETINF_

//
//  This is the structure we keep per registry value.  Off of each
//  NETCARD_RESPONSE_DATABASE is a list of these (stored in Registry).
//  It is a parameter that is required in the HKR path for the driver.
//

#define NETCARD_REGISTRY_TYPE_INT    '1'
#define NETCARD_REGISTRY_TYPE_STRING '2'

typedef struct _NETCARD_REGISTRY_PARAMETERS {

    LIST_ENTRY RegistryListEntry;
    UNICODE_STRING Parameter;
    ULONG   Type;
    UNICODE_STRING Value;

} NETCARD_REGISTRY_PARAMETERS, *PNETCARD_REGISTRY_PARAMETERS;

typedef struct _NETCARD_FILECOPY_PARAMETERS {

    LIST_ENTRY FileCopyListEntry;
    UNICODE_STRING SourceFile;

    // if DestFile is null, SourceFile is the file name for the target

    UNICODE_STRING DestFile;

} NETCARD_FILECOPY_PARAMETERS, *PNETCARD_FILECOPY_PARAMETERS;

//
//  this is the main structure that we return for any given net driver
//

typedef struct _NETCARD_RESPONSE_DATABASE {

    ULONG       ReferenceCount;
    LIST_ENTRY  NetCardEntry;
    PWCHAR HardwareId;   // hardware ID to return               ("PCI\\VEN_8086&DEV_1229")
    PWCHAR DriverName;   // driver name to return               ("e100bnt.sys")
    PWCHAR InfFileName; // inf file name to return              ("net557.inf")
    PWCHAR SectionName;  // section name within the inf         ("F1100C.ndi")
    PWCHAR SectionNameExt; // name with architecture extension  ("F1100C.ndi.ntx86")
    PWCHAR ServiceName;  // server name to add for this card    ("E100B")
    PWCHAR DriverDescription;   // description of the driver    ("Intel 82557B-based Ethernet PCI Adapter (10/100)")

    LIST_ENTRY FileCopyList;
    LIST_ENTRY Registry;

} NETCARD_RESPONSE_DATABASE, * PNETCARD_RESPONSE_DATABASE;

ULONG
NetInfStartHandler (
    VOID
    );

ULONG
NetInfCloseHandler (
    VOID
    );

//
//  This finds a specific driver for a given hardware description.
//  Be sure to call NetInfDereferenceNetcardEntry when you're done with the
//  entry.
//

ULONG
NetInfFindNetcardInfo (
    PWCHAR InfDirectory,
    ULONG Architecture,
    ULONG CardInfoVersion,
    NET_CARD_INFO UNALIGNED * CardIdentity,
    PWCHAR *FullDriverBuffer OPTIONAL,
    PNETCARD_RESPONSE_DATABASE *pInfEntry
    );

//
//  After calling NetInfFindNetcardInfo, call NetInfDereferenceNetcardEntry
//  when you're done with the entry so that it can be marked as not in use.
//  Otherwise it'll leak memory when you close call NetInfCloseNetcardInfo.
//

VOID
NetInfDereferenceNetcardEntry (
    PNETCARD_RESPONSE_DATABASE pInfEntry
    );

#endif _NETINF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\netinfp.h ===
/*++

Copyright (c) 1994-7  Microsoft Corporation

Module Name:

    netinfp.h

Abstract:

    This file contains the structures and prototypes necessary for the
    netcard inf parser handler.

Author:

    Andy Herron (andyhe)  12-Mar-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NETINFP_
#define _NETINFP_

#define NETINF_VENDOR_STRING    L"VEN_"
#define NETINF_REVISION_STRING  L"REV_"
#define NETINF_DEVICE_STRING    L"DEV_"
#define NETINF_IOSUBS_STRING    L"SUBSYS_"

#define NETINF_BUS_TYPE_PCI  2
#define NETINF_BUS_TYPE_ISAPNP 3

#define NETCARD_HASH_TABLE_SIZE    17

extern CRITICAL_SECTION NetInfLock;

#define RNDM_CONSTANT   314159269    /* default scrambling constant */
#define RNDM_PRIME     1000000007    /* prime number for scrambling  */

//
// Compute a string hash value that is invariant to case
//
#define COMPUTE_STRING_HASH( _pus, _phash ) {                \
    PWCHAR _p = _pus;                                        \
    ULONG _chHolder =0;                                      \
                                                             \
    while( *_p != L'\0' ) {                                  \
        _chHolder = 37 * _chHolder + (unsigned int) *(_p++); \
    }                                                        \
                                                             \
    *(_phash) = abs(RNDM_CONSTANT * _chHolder) % RNDM_PRIME; \
}

#define HASH_TO_INF_INDEX( _hash )    ((_hash) % NETCARD_HASH_TABLE_SIZE)

//
//  this is the block that we keep for every install directory that we
//  process INF files for.  We then keep the list of configurations as a list
//  off of the NetCardEntryList.
//

typedef struct _NETCARD_INF_BLOCK {

    ULONG               ReferenceCount;
    LIST_ENTRY          InfBlockEntry;      // list entry for global list

    // table of list of NETCARD_RESPONSE_DATABASE, hashed by DeviceHw string
    LIST_ENTRY          NetCardEntries[ NETCARD_HASH_TABLE_SIZE ];

    ULONG               Architecture;
    ULONG               StatusFromScan;
    PNETINF_CALLBACK    FileListCallbackFunction;
    LPVOID              FileListCallbackContext;
    CRITICAL_SECTION    Lock;
    WCHAR               InfDirectory[ANYSIZE_ARRAY];    // inf directory to search

} NETCARD_INF_BLOCK, *PNETCARD_INF_BLOCK;

//
//  NetInfGetAllNetcardInfo parses all the INF files in the given directory
//  and sets up a structure containing all the data.  Be sure to call
//  NetInfCloseNetcardInfo when you're all done with the structure.
//

ULONG
NetInfAllocateNetcardInfo (
    PWCHAR InfPath,
    ULONG Architecture,
    PNETCARD_INF_BLOCK *pNetCards
    );

//
//  This frees all resources associated with the parsing of the INF files.
//  Any entries that are in use will not be deleted until they're explicitely
//  dereferenced using NetInfDereferenceNetcardEntry.
//

ULONG
NetInfCloseNetcardInfo (
    PNETCARD_INF_BLOCK pNetCards
    );


//
//  This finds a specific driver for a given hardware description.
//  Be sure to call NetInfDereferenceNetcardEntry when you're done with the
//  entry.
//

ULONG
FindNetcardInfo (
    PNETCARD_INF_BLOCK pNetCards,
    ULONG CardInfoVersion,
    NET_CARD_INFO UNALIGNED * CardIdentity,
    PNETCARD_RESPONSE_DATABASE *pInfEntry
    );


ULONG
GetSetupLineWideText (
    PINFCONTEXT InfContext,
    HINF InfHandle,
    PWCHAR Section,
    PWCHAR Key,
    PWCHAR *String,
    PULONG SizeOfAllocation OPTIONAL
    );

ULONG
GetSetupWideTextField (
    PINFCONTEXT InfContext,
    DWORD  FieldIndex,
    PWCHAR *String,
    PULONG SizeOfAllocation OPTIONAL
    );

ULONG
GetHexValueFromHw (
    PWCHAR *String,      // this is updated.
    PULONG longValue,
    PUSHORT shortValue
    );

BOOLEAN
IsSubString (
    PWCHAR subString,
    PWCHAR target,
    BOOLEAN ignoreCase
    );

ULONG
CheckHwDescription (
    PWCHAR HardwareID
    );

ULONG
GetNetCardList (
    PNETCARD_INF_BLOCK pNetCards
    );

ULONG
ProcessInfFile (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName
    );

ULONG
ParseCardDetails (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PINFCONTEXT DeviceEnumContext
    );

ULONG
GetExtendedSectionName (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry
    );

ULONG
GetServiceAndDriver (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry
    );

ULONG
ProcessCopyFilesSubsection (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry,
    PWCHAR SectionToParse
    );

ULONG
GetRegistryParametersForDriver (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry
    );

ULONG
ProcessRegistrySubsection (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry,
    PWCHAR SectionToParse
    );

VOID
DereferenceNetcardInfo (
    PNETCARD_INF_BLOCK pNetCards
    );

ULONG
CreateListOfCardIdentifiers (
    NET_CARD_INFO UNALIGNED * CardIdentity,
    PWCHAR *CardIdentifiers
    );

VOID
ConvertHexToBuffer (
    PWCHAR Buff,
    USHORT Value
    );

#endif _NETINFP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\network.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    network.c

Abstract:

    This module contains the network interface for the BINL server.

Author:

    Colin Watson (colinw)  2-May-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include "binl.h"
#pragma hdrstop

DWORD
BinlWaitForMessage(
    BINL_REQUEST_CONTEXT *pRequestContext
    )
/*++

Routine Description:

    This function waits for a request on the BINL port on any of the
    configured interfaces.

Arguments:

    RequestContext - A pointer to a request context block for
        this request.

Return Value:

    The status of the operation.

--*/
{
    DWORD       length;
    DWORD       error;
    fd_set      readSocketSet;
    DWORD       i;
    int         readySockets;
    struct timeval timeout = { 0x7FFFFFFF, 0 }; // forever.

    LPOPTION    Option;
    LPBYTE      EndOfScan;
    LPBYTE      MagicCookie;
    BOOLEAN     FoundDesirablePacket;

    #define CLIENTOPTIONSTRING "PXEClient"
    #define CLIENTOPTIONSIZE (sizeof(CLIENTOPTIONSTRING) - 1)

    //
    //  Loop until we get an extended DHCP request or an error
    //

    while (1) {

        //
        // Setup the file descriptor set for select.
        //

        FD_ZERO( &readSocketSet );
        for ( i = 0; i < BinlGlobalNumberOfNets ; i++ ) {
            if (BinlGlobalEndpointList[i].Socket) {
                FD_SET(
                    BinlGlobalEndpointList[i].Socket,
                    &readSocketSet
                    );
            }
        }

        readySockets = select( 0, &readSocketSet, NULL, NULL, &timeout );

        //
        // return to caller when the service is shutting down or select()
        // times out.
        //

        if( (readySockets == 0)  ||
            (WaitForSingleObject( BinlGlobalProcessTerminationEvent, 0 ) == 0) ) {

            return( ERROR_SEM_TIMEOUT );
        }

        if( readySockets == SOCKET_ERROR) {
            continue;   //  Closed the DHCP socket?
        }

        //
        // Time to play 20 question with winsock.  Which socket is ready?
        //

        pRequestContext->ActiveEndpoint = NULL;

        for ( i = 0; i < BinlGlobalNumberOfNets ; i++ ) {
            if ( FD_ISSET( BinlGlobalEndpointList[i].Socket, &readSocketSet ) ) {
                pRequestContext->ActiveEndpoint = &BinlGlobalEndpointList[i];
                break;
            }
        }


        //BinlAssert(pRequestContext->ActiveEndpoint != NULL );
        if ( pRequestContext->ActiveEndpoint == NULL ) {
            return ERROR_SEM_TIMEOUT;
        }


        //
        // Read data from the net.  If multiple sockets have data, just
        // process the first available socket.
        //

        pRequestContext->SourceNameLength = sizeof( struct sockaddr );

        //
        // clean the receive buffer before receiving data in it. We clear
        // out one more byte than we actually hand to recvfrom, so we can
        // be sure the message has a NULL after it (in case we do a
        // wcslen etc. into the received packet).
        //

        RtlZeroMemory( pRequestContext->ReceiveBuffer, BINL_MESSAGE_SIZE + 1 );
        pRequestContext->ReceiveMessageSize = BINL_MESSAGE_SIZE;

        length = recvfrom(
                     pRequestContext->ActiveEndpoint->Socket,
                     (char *)pRequestContext->ReceiveBuffer,
                     pRequestContext->ReceiveMessageSize,
                     0,
                     &pRequestContext->SourceName,
                     (int *)&pRequestContext->SourceNameLength
                     );

        if ( length == SOCKET_ERROR ) {
            error = WSAGetLastError();
            BinlPrintDbg(( DEBUG_ERRORS, "Recv failed, error = %ld\n", error ));
        } 
        else if (length == 0) {
            //
            // the connection closed under us.
            // lets hope the connection opens again.
            //
            continue;
        }
        //
        // we received a message!!
        // we are expecting to receive a message whose first byte tells us
        // the purpose of the message.  Since we have received a message (it
        // must be of positive length), we can look at the first byte (Operation)
        // to tell us what to do with the message. but we still need to be 
        // careful, as the rest of the data may be bad.
        //
        else {

            //
            // Ignore all messages that do not look like DHCP or doesn't have the
            // option "PXEClient", OR that is not an oschooser message (they
            // all start with 0x81).
            //

            if ( ((LPDHCP_MESSAGE)pRequestContext->ReceiveBuffer)->Operation == OSC_REQUEST) {

                //
                // All OSC request packets have a 4-byte signature (first byte
                // is OSC_REQUEST) followed by a DWORD length (that does not
                // include the signature/length). Make sure the length matches
                // what we got from recvfrom (we allow padding at the end). We
                // use SIGNED_PACKET but any of the XXX_PACKET structures in
                // oscpkt.h would work.
                //

                if (length < FIELD_OFFSET(SIGNED_PACKET, SequenceNumber)) {
                    BinlPrintDbg(( DEBUG_OSC_ERROR, "Discarding runt packet %d bytes\n", length ));
                    continue;
                }

                if ((length - FIELD_OFFSET(SIGNED_PACKET, SequenceNumber)) <
                        ((SIGNED_PACKET UNALIGNED *)pRequestContext->ReceiveBuffer)->Length) {
                    BinlPrintDbg(( DEBUG_OSC_ERROR, "Discarding invalid length message %d bytes (header said %d)\n",
                        length, ((SIGNED_PACKET UNALIGNED *)pRequestContext->ReceiveBuffer)->Length));
                    continue;
                }

                BinlPrintDbg(( DEBUG_MESSAGE, "Received OSC message\n", 0 ));
                error = ERROR_SUCCESS;

            } else {

                //
                // check to see if this is a BOOTP message.
                // do so by checking to make sure it is at least the minimum
                // size for a DHCP message.  if so, check to see if it has
                // the appriopriate magic cookie '99' '130' '83' '99'.  
                //
                // once we verified that this is a BOOTP message, 
                // we will be looking for two options.  either an option
                // indicating this is a inform packet or
                // an option indicating this Vendor Class as "PXEClient"
                //
                // ignore all others.
                // 
                                                                
                if ( length < DHCP_MESSAGE_FIXED_PART_SIZE + 4 ) {
                    //
                    // Message isn't long enough to include the 
                    // DHCP message header and the BOOTP magic cookie, 
                    // ignore it.
                    //
                    continue;
                }

                if ( ((LPDHCP_MESSAGE)pRequestContext->ReceiveBuffer)->Operation != BOOT_REQUEST) {
                    //
                    // Doesn't look like an interesting DHCP frame
                    //
                    continue; 
                }

                //
                // check the BOOTP magic cookie.
                //
                MagicCookie = (LPBYTE)&((LPDHCP_MESSAGE)pRequestContext->ReceiveBuffer)->Option;

                if( (*MagicCookie != (BYTE)DHCP_MAGIC_COOKIE_BYTE1) ||
                    (*(MagicCookie+1) != (BYTE)DHCP_MAGIC_COOKIE_BYTE2) ||
                    (*(MagicCookie+2) != (BYTE)DHCP_MAGIC_COOKIE_BYTE3) ||
                    (*(MagicCookie+3) != (BYTE)DHCP_MAGIC_COOKIE_BYTE4))
                {
                    //
                    // this is a vendor specific magic cookie.
                    // ignore the message
                    //
                    continue; 
                }

                //
                // At this point, we have something that looks like a DHCP/BOOTP
                // packet.  we will now carefully look for two particular option 
                // types that are interest to us.  
                //    1. An inform packet which is indicated by the option type
                //       OPTION_MESSAGE_TYPE(53) with the message type of 
                //       DHCP_INFORM_MESSAGE(8)
                //    2. A vendor class indentifier "PXEClient" indicated by 
                //       the option type OPTION_CLIENT_CLASS_INFO(60) with the 
                //       value CLIENTOPTIONSTRING("PXEClient")
                // Stop scanning after we have found either one of these options
                // or we run off the packet.  if we do not find either option,
                // continue in the while loop looking for a packet with either
                // of these options
                //
                // EndOfScan indicates the last byte we received in the packet
                //
                EndOfScan = pRequestContext->ReceiveBuffer + length - 1;
                
                Option = (LPOPTION) (MagicCookie + 4);
                
                FoundDesirablePacket = FALSE;

                while ( ((LPBYTE)Option <= EndOfScan) && 
                        (Option->OptionType != OPTION_END) &&
                        (FoundDesirablePacket == FALSE) ) {

                    if ( Option->OptionType == OPTION_PAD ) {
                        //
                        // found an OPTION_PAD.  this is a 1 byte option ('0').
                        // just walk past this.
                        //
                        Option = (LPOPTION)((LPBYTE)(Option) + 1);
                    }
                    else {
                        //
                        // OPTION_PAD and OPTION_END are the only two options 
                        // that do not have a length field and a Value field.
                        // we know we do not have either, so we have to make 
                        // sure we do not step past the EndOfScan by 
                        // looking at the option length or the option value
                        //
                        // Note.  Option type and Option length take up two bytes
                        // but we only add one when seeing if the length brings us
                        // past EndOfScan, because when we step past the last 
                        // option, it will bring us 1 byte past EndOfScan.  
                        // we want to see if this is an invalid option
                        // that will somehow overstep the standard case
                        //
                        if ( (((LPBYTE)(Option) + 1) > EndOfScan) || 
                             (((LPBYTE)(Option) + Option->OptionLength + 1) > EndOfScan) ) {
                            //
                            // invalid option
                            //
                            break;
                        }

                        //
                        // look for the two option types of interest.
                        // OPTION_CLIENT_CLASS_INFO and OPTION_MESSAGE_TYPE
                        //
                        switch ( Option->OptionType ) {
                        case OPTION_MESSAGE_TYPE:
                            //
                            // check to see if we got an inform packet
                            //
                            if ( (Option->OptionLength == 1) && 
                                 (Option->OptionValue[0] == DHCP_INFORM_MESSAGE) ) {
                                FoundDesirablePacket = TRUE;
                            }
                            break;
                        case OPTION_CLIENT_CLASS_INFO:
                            //
                            // check to see if the Client class identifier is "PXEClient"
                            //
                            if (memcmp(Option->OptionValue, 
                                       CLIENTOPTIONSTRING, 
                                       CLIENTOPTIONSIZE) == 0) {
                                FoundDesirablePacket = TRUE;
                            }
                            break;
                        default:
                            break;
                        }

                        //
                        // walk past this option to check the next one
                        //
                        Option = (LPOPTION)((LPBYTE)(Option) + Option->OptionLength + 2);
                    }
                }

                if ( FoundDesirablePacket == FALSE ) {
                    // 
                    // Message was not an extended DHCP packet
                    // with the desired option ("PXEClient")
                    // or an inform packet.
                    // ignore the message
                    //
                    continue;   
                }

                BinlPrintDbg(( DEBUG_MESSAGE, "Received message\n", 0 ));
                error = ERROR_SUCCESS;

            }
        }

        pRequestContext->ReceiveMessageSize = length;
        return( error );
    }
}

DWORD
BinlSendMessage(
    LPBINL_REQUEST_CONTEXT RequestContext
    )
/*++

Routine Description:

    This function send a response to a BINL client.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

Return Value:

    The status of the operation.

--*/
{
    DWORD error;
    struct sockaddr_in *source;
    LPDHCP_MESSAGE binlMessage;
    LPDHCP_MESSAGE binlReceivedMessage;
    DWORD MessageLength;
    BOOL  ArpCacheUpdated = FALSE;

    binlMessage = (LPDHCP_MESSAGE) RequestContext->SendBuffer;
    binlReceivedMessage = (LPDHCP_MESSAGE) RequestContext->ReceiveBuffer;

    //
    // if the request arrived from a relay agent, then send the reply
    // on server port otherwise leave it as the client's source port.
    //

    source = (struct sockaddr_in *)&RequestContext->SourceName;
    if ( binlReceivedMessage->RelayAgentIpAddress != 0 ) {
        source->sin_port = htons( DHCP_SERVR_PORT );
    }

    //
    // if this request arrived from relay agent then send the
    // response to the address the relay agent says.
    //

    if ( binlReceivedMessage->RelayAgentIpAddress != 0 ) {
        source->sin_addr.s_addr = binlReceivedMessage->RelayAgentIpAddress;
    }
    else {

        //
        // if the client didnt specify broadcast bit and if
        // we know the ipaddress of the client then send unicast.
        //

        //
        // But if IgnoreBroadcastFlag is set in the registry and
        // if the client requested to broadcast or the server is
        // nacking or If the client doesn't have an address yet,
        // respond via broadcast.
        // Note that IgnoreBroadcastFlag is off by default. But it
        // can be set as a workaround for the clients that are not
        // capable of receiving unicast
        // and they also dont set the broadcast bit.
        //

        if ( (RequestContext->MessageType == DHCP_INFORM_MESSAGE) &&
             (ntohs(binlMessage->Reserved) & DHCP_BROADCAST) ) {

            source->sin_addr.s_addr = (DWORD)-1;

        } else if ( BinlGlobalIgnoreBroadcastFlag ) {

            if ((ntohs(binlReceivedMessage->Reserved) & DHCP_BROADCAST) ||
                    (binlReceivedMessage->ClientIpAddress == 0) ||
                    (source->sin_addr.s_addr == 0) ) {

                source->sin_addr.s_addr = (DWORD)-1;

                binlMessage->Reserved = 0;
                    // this flag should be zero in the local response.
            }

        } else {

            if( (ntohs(binlReceivedMessage->Reserved) & DHCP_BROADCAST) ||
                (!source->sin_addr.s_addr ) ){

                source->sin_addr.s_addr = (DWORD)-1;

                binlMessage->Reserved = 0;
                    // this flag should be zero in the local response.
            } else {

                //
                //  Send back to the same IP address that the request came in on (
                //  i.e. source->sin_addr.s_addr)
                //
            }

        }
    }

    BinlPrint(( DEBUG_STOC, "Sending response to = %s, XID = %lx.\n",
        inet_ntoa(source->sin_addr), binlMessage->TransactionID));


    //
    // send minimum DHCP_MIN_SEND_RECV_PK_SIZE (300) bytes, otherwise
    // bootp relay agents don't like the packet.
    //

    MessageLength = (RequestContext->SendMessageSize >
                    DHCP_MIN_SEND_RECV_PK_SIZE) ?
                        RequestContext->SendMessageSize :
                            DHCP_MIN_SEND_RECV_PK_SIZE;
    error = sendto(
                 RequestContext->ActiveEndpoint->Socket,
                (char *)RequestContext->SendBuffer,
                MessageLength,
                0,
                &RequestContext->SourceName,
                RequestContext->SourceNameLength
                );

    if ( error == SOCKET_ERROR ) {
        error = WSAGetLastError();
        BinlPrintDbg(( DEBUG_ERRORS, "Send failed, error = %ld\n", error ));
    } else {
        error = ERROR_SUCCESS;
    }

    return( error );
}

NTSTATUS
GetIpAddressInfo (
    ULONG Delay
    )
{
    ULONG count;
    DWORD Size;
    PIP_ADAPTER_INFO pAddressInfo = NULL;

    //
    //  We can get out ahead of the dns cached info here... let's delay a bit
    //  if the pnp logic told us there was a change.
    //

    if (Delay) {
        Sleep( Delay );
    }

    Size = 0;    
    if ( (GetAdaptersInfo(pAddressInfo,&Size) == ERROR_BUFFER_OVERFLOW) &&
         (pAddressInfo = BinlAllocateMemory(Size)) &&
         (GetAdaptersInfo(pAddressInfo,&Size) == ERROR_SUCCESS)) {
        PIP_ADAPTER_INFO pNext = pAddressInfo;
        count = 0;
        while (pNext) {
            count += 1;
            pNext = pNext->Next;
        }
    } else {
        count = 0;
    }

    if (count == 0) {

        //
        //  we don't know what went wrong, we'll fall back to old APIs.
        //

        DHCP_IP_ADDRESS ipaddr = 0;
        PHOSTENT Host = gethostbyname( NULL );

        if (Host) {

            ipaddr = *(PDHCP_IP_ADDRESS)Host->h_addr;

            if ((Host->h_addr_list[0] != NULL) &&
                (Host->h_addr_list[1] != NULL)) {

                BinlIsMultihomed = TRUE;

            } else {

                BinlIsMultihomed = FALSE;
            }

            BinlGlobalMyIpAddress = ipaddr;

        } else {

            //
            //  what's with the ip stack?  we can't get any type of address
            //  info out of it... for now, we won't answer any if we don't
            //  already have the info we need.
            //

            if (BinlIpAddressInfo == NULL) {
                BinlIsMultihomed = TRUE;
            }
        }
        return STATUS_SUCCESS;
    }

    EnterCriticalSection(&gcsParameters);

    if (BinlIpAddressInfo) {
        BinlFreeMemory( BinlIpAddressInfo );
    }

    BinlIpAddressInfo = pAddressInfo;
    BinlIpAddressInfoCount = count;

    BinlIsMultihomed = (count != 1);

    if (!BinlIsMultihomed) {
        BinlGlobalMyIpAddress = inet_addr(pAddressInfo->IpAddressList.IpAddress.String);
    }

    LeaveCriticalSection(&gcsParameters);

    return STATUS_SUCCESS;
}

DHCP_IP_ADDRESS
BinlGetMyNetworkAddress (
    LPBINL_REQUEST_CONTEXT RequestContext
    )
/*++

Routine Description:

    This function returns our (the server's) IP address.
    if multihomed, the function will walk through 
    each of the server's ip addresses looking for an 
    address with the same subnet mask as the sender.

Arguments:

    RequestContext - The RequestContext from the packet
           sent to us by the client.
            
Return Value:

    The Ip Address of the server.  in the multihome 
    situation, the ip address on the same subnet
    as the client.  In case of failure to find an 
    IP address on the same subnet or if we were 
    somehow unable to get the client's address, 0 is 
    returned

--*/
{
    ULONG RemoteIp;
    DHCP_IP_ADDRESS ipaddr;
    ULONG i;
    ULONG subnetMask;
    ULONG localAddr;
    PIP_ADAPTER_INFO pNext;

    BinlAssert( RequestContext != NULL);

    //
    //  If we're not multihomed, then we know the address since there's just one.
    // 

    if (!BinlIsMultihomed) {
        return BinlGlobalMyIpAddress;
    }

    RemoteIp = ((struct sockaddr_in *)&RequestContext->SourceName)->sin_addr.s_addr;

    // 
    // in attempt to be consistent with the previous case where we only
    // have 1 ip address, we should at least return an IP address.
    // Return the first ip address in the list.
    //
    ipaddr = (BinlIpAddressInfo) ? inet_addr(BinlIpAddressInfo->IpAddressList.IpAddress.String) : 0;

    if (RemoteIp == 0) {
        
        return ipaddr;
    }

    EnterCriticalSection(&gcsParameters);

    if (BinlIpAddressInfo == NULL) {
        LeaveCriticalSection(&gcsParameters);
        return (BinlIsMultihomed ? 0 : BinlGlobalMyIpAddress);
    }

    pNext = BinlIpAddressInfo;
    while (pNext) {
        localAddr = inet_addr(pNext->IpAddressList.IpAddress.String);
        subnetMask = inet_addr(pNext->IpAddressList.IpMask.String);
        pNext = pNext->Next;

        //
        //  check that the remote ip address may have come from this subnet.
        //  note that the address could be the address of a dhcp relay agent,
        //  which is fine since we're just looking for the address of the
        //  local subnet to broadcast the response on.
        //
        
        //
        // guard against bad ip address
        //
        if (!localAddr || !subnetMask) {
            continue;
        }

        if ((RemoteIp & subnetMask) == (localAddr & subnetMask)) {

            ipaddr = localAddr;
            break;
        }        
    }

    LeaveCriticalSection(&gcsParameters);

    return ipaddr;
}


VOID
FreeIpAddressInfo (
    VOID
    )
{
    EnterCriticalSection(&gcsParameters);

    if (BinlIpAddressInfo != NULL) {
        BinlFreeMemory( BinlIpAddressInfo );
    }
    BinlIpAddressInfo = NULL;
    BinlIpAddressInfoCount = 0;
 
    LeaveCriticalSection(&gcsParameters);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\osc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    osc.h

Abstract:

    This file containes definitions for the OS chooser server part.

Author:

    Adam Barr (adamba)  08-Jul-1997

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

#ifndef _OSCSERVER_
#define _OSCSERVER_

//
// list and lock for keeping track of queued DS names
//
extern LIST_ENTRY          QueuedDSNamesList;
extern CRITICAL_SECTION    QueuedDSNamesCriticalSection;

//
// Functions in osc.c.
//

DWORD
OscInitialize(
    VOID
    );

VOID
OscUninitialize(
    VOID
    );

DWORD
OscProcessMessage(
    LPBINL_REQUEST_CONTEXT RequestContext
    );

DWORD
OscVerifyLastResponseSize(
    PCLIENT_STATE clientState
    );

DWORD
OscProcessNegotiate(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    );

DWORD
OscProcessAuthenticate(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    );

DWORD
OscProcessScreenArguments(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PUCHAR *NameLoc
    );

DWORD
OscProcessRequestUnsigned(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    );

OscInstallClient(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PCREATE_DATA createData
    );

DWORD
OscGetCreateData(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PCREATE_DATA CreateData
    );

DWORD
OscProcessRequestSigned(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    );

DWORD
OscProcessSetupRequest(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    );

DWORD
OscProcessLogoff(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    );

DWORD
OscProcessNetcardRequest(
    LPBINL_REQUEST_CONTEXT RequestContext
    );

DWORD
OscProcessHalRequest(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    );

DWORD
OscProcessSifFile(
    PCLIENT_STATE clientState,
    LPWSTR TemplateFile,
    LPWSTR WinntSifPath
    );

DWORD
OscSetupClient(
    PCLIENT_STATE clientState,
    BOOLEAN ErrorDuplicateName
    );

VOID
OscUndoSetupClient(
    PCLIENT_STATE clientState
    );

USHORT 
OscPlatformToArchitecture(
    PCLIENT_STATE clientState
    );

//
// client.c
//

DWORD
OscUpdatePassword(
    IN PCLIENT_STATE ClientState,
    IN PWCHAR SamAccountName,
    IN PWCHAR Password,
    IN LDAP * LdapHandle,
    IN PLDAPMessage LdapMessage
    );

VOID
FreeClient(
    PCLIENT_STATE client
    );

VOID
OscFreeClientVariables(
    PCLIENT_STATE clientState
    );

BOOLEAN
OscInitializeClientVariables(
    PCLIENT_STATE clientState
    );

DWORD
OscFindClient(
    ULONG RemoteIp,
    BOOL Remove,
    PCLIENT_STATE * pClientState
    );

VOID
OscFreeClients(
    VOID
    );

VOID
SearchAndReplace(
    LPSAR psarList,
    LPSTR *pszString,
    DWORD ArraySize,
    DWORD dwSize,
    DWORD dwExtraSize
    );

VOID
ProcessUniqueUdb(
    LPSTR *pszString,
    DWORD dwSize,
    LPWSTR UniqueUdbPath,
    LPWSTR UniqueUdbId
    );

LPSTR
OscFindVariableA(
    PCLIENT_STATE clientState,
    LPSTR variableName
    );

LPWSTR
OscFindVariableW(
    PCLIENT_STATE clientState,
    LPSTR variableName
    );

BOOLEAN
OscCheckVariableLength(
    PCLIENT_STATE clientState,
    LPSTR        variableName,
    ULONG        variableLength
    );

DWORD
OscAddVariableA(
    PCLIENT_STATE clientState,
    LPSTR        variableName,
    LPSTR        variableValue
    );

DWORD
OscAddVariableW(
    PCLIENT_STATE clientState,
    LPSTR        variableName,
    LPWSTR       variableValue
    );

VOID
OscResetVariable(
    PCLIENT_STATE clientState,
    LPSTR        variableName
    );

//
// ds.c
//

DWORD
OscGetUserDetails (
    PCLIENT_STATE clientState
    );

DWORD
OscCreateAccount(
    PCLIENT_STATE clientState,
    PCREATE_DATA CreateData
    );

DWORD
CheckForDuplicateMachineName(
    PCLIENT_STATE clientState,
    LPWSTR pszMachineName
    );

DWORD
GenerateMachineName(
    PCLIENT_STATE clientState
    );

DWORD
OscCheckMachineDN(
    PCLIENT_STATE clientState
    );

DWORD
OscGetDefaultContainerForDomain (
    PCLIENT_STATE clientState,
    PWCHAR DomainDN
    );

//
// menu.c
//

DWORD
OscAppendTemplatesMenus(
    PCHAR *GeneratedScreen,
    PDWORD dwGeneratedSize,
    PCHAR DirToEnum,
    PCLIENT_STATE clientState,
    BOOLEAN RecoveryOptionsOnly
    );

DWORD
SearchAndGenerateOSMenu(
    PCHAR *GeneratedScreen,
    PDWORD dwGeneratedSize,
    PCHAR DirToEnum,
    PCLIENT_STATE clientState
    );

DWORD
FilterFormOptions(
    PCHAR  OutMessage,
    PCHAR  FilterStart,
    PULONG OutMessageLength,
    PCHAR SectionName,
    PCLIENT_STATE ClientState
    );

//
// utils.c
//

void
OscCreateWin32SubError(
    PCLIENT_STATE clientState,
    DWORD Error
    );

void
OscCreateLDAPSubError(
    PCLIENT_STATE clientState,
    DWORD Error
    );

VOID
OscGenerateSeed(
    UCHAR Seed[1]
    );

DWORD
OscRunEncode(
    IN PCLIENT_STATE ClientState,
    IN LPSTR Data,
    OUT LPSTR * EncodedData
    );

DWORD
OscRunDecode(
    IN PCLIENT_STATE ClientState,
    IN LPSTR EncodedData,
    OUT LPSTR * Data
    );

BOOLEAN
OscGenerateRandomBits(
    PUCHAR Buffer,
    ULONG  BufferLen
    );

VOID
OscGeneratePassword(
    OUT PWCHAR Password,
    OUT PULONG PasswordLength
    );

DWORD
GenerateErrorScreen(
    PCHAR  *OutMessage,
    PULONG OutMessageLength,
    DWORD  Error,
    PCLIENT_STATE clientState
    );

PCHAR
FindNext(
    PCHAR Start,
    CHAR ch,
    PCHAR End
    );

PCHAR
FindScreenName(
    PCHAR Screen
    );

DWORD
OscImpersonate(
    PCLIENT_STATE ClientState
    );

DWORD
OscRevert(
    PCLIENT_STATE ClientState
    );

DWORD
OscGuidToBytes(
    LPSTR  pszGuid,
    LPBYTE Guid
    );

BOOLEAN
OscSifIsSysPrep(
    PWCHAR pSysPrepSifPath
    );

BOOLEAN
OscSifIsCmdConsA(
    PCHAR pSysPrepSifPath
    );

BOOLEAN
OscSifIsASR(
    PCHAR pSysPrepSifPath
    );

BOOLEAN
OscSifIsWinPE(
    PCHAR pSysPrepSifPath
    );

BOOLEAN
OscGetClosestNt(
    IN LPWSTR PathToKernel,
    IN DWORD  SkuType,
    IN PCLIENT_STATE ClientState,
    OUT LPWSTR SetupPath,
    IN DWORD SetupPathSize,
    OUT PBOOLEAN ExactMatch
    );

BOOLEAN
OscGetNtVersionInfo(
    PULONGLONG Version,
    PWCHAR SearchDir,
    PCLIENT_STATE ClientState
    );

DWORD
SendUdpMessage(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    BOOL bFragment,
    BOOL bResend
    );

DWORD
OscVerifySignature(
    PCLIENT_STATE clientState,
    SIGNED_PACKET UNALIGNED * signedMessage
    );

DWORD
OscSendSignedMessage(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PCHAR Message,
    ULONG MessageLength
    );

DWORD
OscSendUnsignedMessage(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PCHAR Message,
    ULONG MessageLength
    );

DWORD
OscSendSetupMessage(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    ULONG RequestType,
    PCHAR Message,
    ULONG MessageLength
    );

DWORD
OscConstructSecret(
    PCLIENT_STATE clientState,
    PWCHAR UnicodePassword,
    ULONG  UnicodePasswordLength,
    PCREATE_DATA CreateData
    );

#if defined(SET_ACLS_ON_CLIENT_DIRS)
DWORD
OscSetClientDirectoryPermissions(
    PCLIENT_STATE clientState
    );
#endif

DWORD
OscSetupMachinePassword(
    PCLIENT_STATE clientState,
    PCWSTR        SifFile
    );

DWORD 
MyGetDcHandle(
    PCLIENT_STATE clientState,
    PCSTR DomainName,
    PHANDLE Handle
    );

DWORD
GetDomainNetBIOSName(
    IN PCWSTR DomainNameInAnyFormat,
    OUT PWSTR *NetBIOSName
    );

//
//
//
DWORD
AddQueuedDSName(
    PWCHAR  Name
    );

DWORD
RemoveQueuedDSName(
    PWCHAR  Name
    );

BOOL
IsQueuedDSName(
    PWCHAR  Name
    );

VOID
FreeQueuedDSNameList(
    VOID
    );

//
// OSC packet definitions.
//

#define OSC_REQUEST     0x81

//
// Miscellaneous definitions.
//

#define DESCRIPTION_SIZE        70              // 70 cols
#define HELPLINES_SIZE          4 * 70          // 4 lines of text
#define OSCHOOSER_SIF_SECTIONA    "OSChooser"
#define OSCHOOSER_SIF_SECTIONW    L"OSChooser"

#define COMPUTER_DEFAULT_CONTAINER_IN_B32_FORM L"B:32:AA312825768811D1ADED00C04FD8D5CD:"

//
// Default "default screen" (the first one sent down) if none is specified
// in the registry. Note that this is the actual filename, not the NAME
// value within it.
//

#define DEFAULT_SCREEN_NAME     L"welcome.osc"

//
// This defines the size by which the generated screen buffers will grow.
//

#define GENERATED_SCREEN_GROW_SIZE 512

//
// Make English default
//

#define DEFAULT_LANGUAGE     L"English"

//
// Default value for %ORGNAME%
//

#define DEFAULT_ORGNAME      L""

//
// Default value for %TIMEZONE% (GMT)
//

#define DEFAULT_TIMEZONE     L"085"

//
// Name of the tmp directory we create below the REMINST share.
//

#define TEMP_DIRECTORY L"tmp"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\osc.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    osc.c

Abstract:

    This module contains the code to process OS Chooser message
    for the BINL server.

Author:

    Adam Barr (adamba)  9-Jul-1997
    Geoff Pease (gpease) 10-Nov-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include "binl.h"
#pragma hdrstop

#include <dns.h>
#include <aclapi.h>

#ifdef TEST_FAILURE
BOOL FailFirstChallenge = TRUE;
BOOL FailFirstResult = TRUE;
BOOL FailFirstResponse = TRUE;
BOOL FailFirstFragment = TRUE;
#endif

//
// Flag indicating whether OscInitialize has been called.
//

BOOLEAN OscInitialized = FALSE;

//
// The list of clients.
//

LIST_ENTRY ClientsQueue;

//
// The list of queued ds names
//
LIST_ENTRY          QueuedDSNamesList;

//
// This guards access to DSName list.
//
CRITICAL_SECTION    QueuedDSNamesCriticalSection;

//
// This guards access to ClientsQueue.
//

CRITICAL_SECTION ClientsCriticalSection;

//
// This is a temporary hack to serialize all calls to the
// NetUserSetInfo/NetUserModalsGet pair. See discussion in
// bug 319962.
//

CRITICAL_SECTION HackWorkaroundCriticalSection;

//
// CurrentClientCount-er access guard
//

CRITICAL_SECTION g_CurrentClientCountCritSect;

//
// Guards creation of the \remoteinstall\tmp directory.
//
CRITICAL_SECTION g_TmpDirectoryCriticalSection;

//
// Credential handle from SSPI
//

CredHandle CredentialHandle;

//
// Info on the NTLMSSP security package.
//

PSecPkgInfo PackageInfo = NULL;

#if DBG
CHAR OscWatchVariable[32] = "";
#endif

DWORD
OscCheckTmpDirectory(
    VOID
    )
/*++

Routine Description:

    This function verifies that the \remoteinstall\tmp directory
    is there, if not it creates it.

Arguments:

    None.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    WCHAR TmpPath[ MAX_PATH ];
    DWORD FileAttributes;
    BOOL InCriticalSection = FALSE;
    PSID pEveryoneSID = NULL;
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    BOOL b;

    if ( _snwprintf( TmpPath,
                     sizeof(TmpPath) / sizeof(TmpPath[0]),
                     L"%ws\\%ws",
                     IntelliMirrorPathW,
                     TEMP_DIRECTORY
                     ) < 0 ) {
        Error = ERROR_BAD_PATHNAME;
        goto Cleanup;
    }
    TmpPath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe

    FileAttributes = GetFileAttributes(TmpPath);

    if (FileAttributes == 0xFFFFFFFF) {

        EXPLICIT_ACCESS ea;
        SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
        SECURITY_ATTRIBUTES sa;

        //
        // Get the critical section if we are going to try to create it.
        //

        InCriticalSection = TRUE;
        EnterCriticalSection(&g_TmpDirectoryCriticalSection);

        //
        // Make sure it still needs to be created.
        //

        FileAttributes = GetFileAttributes(TmpPath);

        if (FileAttributes == 0xFFFFFFFF) {


            // Create a well-known SID for the Everyone group.

            if(! AllocateAndInitializeSid( &SIDAuthWorld, 1,
                             SECURITY_WORLD_RID,
                             0, 0, 0, 0, 0, 0, 0,
                             &pEveryoneSID) ) {
                Error = GetLastError();
                BinlPrintDbg(( DEBUG_INIT, "AllocateAndInitializeSid failed: %lx\n", Error ));
                goto Cleanup;
            }

            // Initialize an EXPLICIT_ACCESS structure for an ACE.
            // The ACE will allow Everyone all access to the directory.

            ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
            ea.grfAccessPermissions = FILE_GENERIC_READ | FILE_GENERIC_WRITE;
            ea.grfAccessMode = SET_ACCESS;
            ea.grfInheritance= OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;
            ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ea.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
            ea.Trustee.ptstrName  = (LPTSTR) pEveryoneSID;

            // Create a new ACL that contains the new ACE.

            Error = SetEntriesInAcl(1, &ea, NULL, &pACL);
            if (Error != ERROR_SUCCESS) {
                BinlPrintDbg(( DEBUG_INIT, "SetEntriesInAcl failed lx\n", Error ));
                goto Cleanup;
            }

            // Initialize a security descriptor.

            pSD = (PSECURITY_DESCRIPTOR) BinlAllocateMemory(SECURITY_DESCRIPTOR_MIN_LENGTH);
            if (pSD == NULL) {
                Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
                BinlPrintDbg(( DEBUG_INIT, "Allocate SECURITY_DESCRIPTOR failed\n"));
                goto Cleanup;
            }

            if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) {
                Error = GetLastError();
                BinlPrintDbg(( DEBUG_INIT, "InitializeSecurityDescriptor failed: %lx\n", Error ));
                goto Cleanup;
            }

            // Add the ACL to the security descriptor.

            if (!SetSecurityDescriptorDacl(pSD,
                    TRUE,     // fDaclPresent flag
                    pACL,
                    FALSE))   // not a default DACL
            {
                Error = GetLastError();
                BinlPrintDbg(( DEBUG_INIT, "SetSecurityDescriptorDacl failed: %lx\n", Error ));
                goto Cleanup;
            }

            // Initialize a security attributes structure.

            sa.nLength = sizeof (SECURITY_ATTRIBUTES);
            sa.lpSecurityDescriptor = pSD;
            sa.bInheritHandle = FALSE;

            b = CreateDirectory(TmpPath, &sa);
            if (!b) {
                Error = GetLastError();
                BinlPrintDbg(( DEBUG_INIT, "CreateDirectory failed: %lx\n", Error ));
                goto Cleanup;
            }

        }

    } else if ((FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {

        Error = ERROR_FILE_EXISTS;
        goto Cleanup;
    }

Cleanup:

    if (InCriticalSection) {
        LeaveCriticalSection(&g_TmpDirectoryCriticalSection);
    }

    if (pEveryoneSID) {
        FreeSid(pEveryoneSID);
    }
    if (pACL) {
        BinlFreeMemory(pACL);
    }
    if (pSD) {
        BinlFreeMemory(pSD);
    }

    return Error;

}

DWORD
OscInitialize(
    VOID
    )
/*++

Routine Description:

    This function initializes the OSChooser server.

Arguments:

    None.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    SECURITY_STATUS SecStatus;
    ULONG PackageCount;
    TimeStamp Lifetime;
    LPSHARE_INFO_2 psi;
    NET_API_STATUS netStatus;

    TraceFunc("OscInitialize( )\n");

    if ( !OscInitialized ) {

        InitializeListHead(&QueuedDSNamesList);
        InitializeCriticalSection(&QueuedDSNamesCriticalSection);
        
        InitializeListHead(&ClientsQueue);
        InitializeCriticalSection(&ClientsCriticalSection);
        InitializeCriticalSection(&HackWorkaroundCriticalSection);
        InitializeCriticalSection(&g_CurrentClientCountCritSect);
        InitializeCriticalSection(&g_TmpDirectoryCriticalSection);

        CredentialHandle.dwLower = 0;
        CredentialHandle.dwUpper = 0;

        OscInitialized = TRUE;
    }

    //
    // Retrieve the path to the remote install directory
    //
    netStatus = NetShareGetInfo(NULL, L"REMINST", 2, (LPBYTE *)&psi);
    if ( netStatus == ERROR_SUCCESS &&
         wcslen(psi->shi2_path) + 1 <= sizeof(IntelliMirrorPathW)/sizeof(WCHAR) )
    {
        wcsncpy( IntelliMirrorPathW, psi->shi2_path, sizeof(IntelliMirrorPathW)/sizeof(IntelliMirrorPathW[0]) );
        NetApiBufferFree(psi);
    }
    else
    {
        BinlPrintDbg(( DEBUG_MISC, "NetShareGetInfo( ) returned 0x%08x\n", netStatus));
        BinlServerEventLog(
            EVENT_SERVER_OSC_NO_DEFAULT_SHARE_FOUND,
            EVENTLOG_ERROR_TYPE,
            netStatus );
        Error = ERROR_BINL_SHARE_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Translate this to ANSI once, use many...
    //
    if (!BinlUnicodeToAnsi(IntelliMirrorPathW,IntelliMirrorPathA,sizeof(IntelliMirrorPathA))) {
        Error = ERROR_BINL_SHARE_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Make sure there is a tmp directory below it.
    //

    Error = OscCheckTmpDirectory();
    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_INIT, "OscCheckTempDirectory failed lx\n", Error ));
        goto Cleanup;
    }

    //
    // Get info about the security packages.
    //

    SecStatus = EnumerateSecurityPackages( &PackageCount, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        BinlPrintDbg(( DEBUG_INIT, "EnumerateSecurityPackages failed: %lx\n", SecStatus ));
        Error = ERROR_NO_SUCH_PACKAGE;
        goto Cleanup;
    }

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( NEGOSSP_NAME, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        BinlPrintDbg(( DEBUG_INIT, "QuerySecurityPackageInfo failed: %lx\n", SecStatus ));
        Error = ERROR_NO_SUCH_PACKAGE;
        goto Cleanup;
    }

    //
    // Acquire a credential handle for the server side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    NEGOSSP_NAME,    // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CredentialHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        BinlPrintDbg(( DEBUG_INIT, "AcquireCredentialsHandle failed: %lx\n", SecStatus ));
        Error = SecStatus;
    }

Cleanup:

    return Error;
}

VOID
OscUninitialize(
    VOID
    )
/*++

Routine Description:

    This function uninitializes the OSChooser server.

Arguments:

    None.

Return Value:

    None.

--*/
{
    SECURITY_STATUS SecStatus;

    TraceFunc("OscUninitialize( )\n");

    if ( OscInitialized ) {

        OscFreeClients();
        
        FreeQueuedDSNameList();
        DeleteCriticalSection(&QueuedDSNamesCriticalSection);
        
        DeleteCriticalSection(&ClientsCriticalSection);
        DeleteCriticalSection(&HackWorkaroundCriticalSection);
        DeleteCriticalSection(&g_CurrentClientCountCritSect);
        DeleteCriticalSection(&g_TmpDirectoryCriticalSection);

        SecStatus = FreeCredentialsHandle( &CredentialHandle );

        if ( SecStatus != STATUS_SUCCESS ) {
            BinlPrintDbg(( DEBUG_OSC_ERROR, "FreeCredentialsHandle failed: %lx\n", SecStatus ));
        }

        if ( BinlOscClientDSHandle != NULL ) {
            DsUnBind( &BinlOscClientDSHandle );
            BinlOscClientDSHandle = NULL;
        }

        OscInitialized = FALSE;

    }
}

DWORD
OscProcessMessage(
    LPBINL_REQUEST_CONTEXT RequestContext
    )
/*++

Routine Description:

    This function dispatches the processing of a received OS chooser message.
    The handler functions will send response messages if necessary.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

Return Value:

    Windows Error.

--*/
{
    SIGNED_PACKET UNALIGNED * loginMessage = (SIGNED_PACKET UNALIGNED *)RequestContext->ReceiveBuffer;
    DWORD Error;
    PCLIENT_STATE clientState = NULL;
    ULONG RemoteIp;
    BOOL FreeClientState;
    BOOL IsLogoffMessage;
    BOOL IsNetcardRequestMessage;
    BOOL IsHalRequestMessage;
    BOOL IsNegotiateMessage;
    BOOL IsAuthenicateMessage;

    TraceFunc("OscProcessMessage( )\n");

    BinlPrintDbg(( DEBUG_OSC, "Received message, length %d, data %.3s\n",
            RequestContext->ReceiveMessageSize,
            ((PUCHAR)loginMessage)+1));

    //
    // Extract the IP address of the client.
    //
    RemoteIp = ((struct sockaddr_in *)&RequestContext->SourceName)->sin_addr.s_addr;

    //
    // IsLogoffMessage will be TRUE if the signature is equal to LogoffSignature.
    //
    IsLogoffMessage = (BOOL)(memcmp(loginMessage->Signature, LogoffSignature, 4) == 0);

    //
    // IsNetcardRequestMessage will be TRUE if the signature is equal to NetcardRequestSignature.
    //
    IsNetcardRequestMessage = (BOOL)(memcmp(loginMessage->Signature, NetcardRequestSignature, 4) == 0);

    //
    // IsHalRequestMessage will be TRUE if the signature is equal to HalRequestSignature.
    //
    IsHalRequestMessage = (BOOL)(memcmp(loginMessage->Signature, HalRequestSignature, 4) == 0);

    //
    // IsNegotiateMessage will be TRUE if the signature is equal to a NegotiateSignature.
    //
    IsNegotiateMessage = (BOOL)(memcmp(loginMessage->Signature, NegotiateSignature, 4) == 0);

    //
    // IsAuthenicateMessage will be TRUE if the signature is equal to an AuthenticateSignature
    // or AuthenticateFlippedSignature.
    //
    IsAuthenicateMessage = (BOOL)((memcmp(loginMessage->Signature, AuthenticateSignature, 4) == 0) ||
                                  (memcmp(loginMessage->Signature, AuthenticateFlippedSignature, 4) == 0));


    //
    // All messages except netcard queries need to use a CLIENT_STATE.
    //
    if (!IsNetcardRequestMessage)
    {
        //
        // If IsLogoffMessage is FALSE, this finds an old CLIENT_STATE or creates
        // a new one. If IsLogoffMessage is TRUE, this removes CLIENT_STATE from
        // the database if it finds it.
        // In both cases, if successful, it adds one to the PositiveRefCount.
        //

        Error = OscFindClient(RemoteIp, IsLogoffMessage, &clientState);

        if (Error == ERROR_NOT_ENOUGH_SERVER_MEMORY)
        {
            CLIENT_STATE TempClientState;
            SIGNED_PACKET TempLoginPacket;

            BinlPrint(( DEBUG_OSC_ERROR, "Could not get client state for %s\n", inet_ntoa(*(struct in_addr *)&RemoteIp) ));

            //
            // Send a NAK back to the client. We use a local CLIENT_STATE
            // since this did not allocate one.
            //
            TempClientState.LastResponse = (PUCHAR)&TempLoginPacket;
            TempClientState.LastResponseLength = SIGNED_PACKET_DATA_OFFSET;

            memcpy(TempLoginPacket.Signature, NegativeAckSignature, 4);
            TempLoginPacket.Length = 0;

            Error = SendUdpMessage(RequestContext, &TempClientState, FALSE, FALSE);

            if (Error != ERROR_SUCCESS)
            {
                BinlPrint(( DEBUG_OSC_ERROR, "Could not send NAK message %d\n", Error));
            }

            return ERROR_NOT_ENOUGH_SERVER_MEMORY;
        }
        else if (Error == ERROR_BUSY) {

            //
            // If it is likely that another thread is processing a request
            // for this client, then just exit quietly.
            //

            BinlPrintDbg((DEBUG_OSC, "clientState = 0x%08x busy, exiting\n", clientState ));
            return ERROR_SUCCESS;

        } 
    
        if ( clientState == NULL ) {

            BinlPrintDbg((DEBUG_OSC, "clientState not found, exiting\n" ));
            return ERROR_SUCCESS;
        }

        EnterCriticalSection(&clientState->CriticalSection);
        clientState->CriticalSectionHeld = TRUE;
        BinlPrintDbg((DEBUG_OSC, "Entering CS for clientState = 0x%08x\n", clientState ));
    }

    if (IsNegotiateMessage)
    {
        //
        // This is an initial negotiate request.
        //
        Error = OscProcessNegotiate( RequestContext, clientState );

    }
    else if (IsAuthenicateMessage)
    {
        //
        // This has the authenticate message.
        //

        Error = OscProcessAuthenticate( RequestContext, clientState );

    }
    else if (memcmp(loginMessage->Signature, RequestUnsignedSignature, 4) == 0)
    {
        //
        // This is an unsigned request.
        //
        // Format is:
        //
        // "RQU"
        // length (not including "RQU" and this)
        // sequence number
        // fragment count/total
        // sign length
        // sign
        // data
        //
        Error = OscProcessRequestUnsigned( RequestContext, clientState );

    }
    else if (memcmp(loginMessage->Signature, RequestSignedSignature, 4) == 0)
    {
        //
        // This is a signed request.
        //
        // Format is:
        //
        // "REQ"
        // length (not including "REQ" and this)
        // sequence number
        // fragment count/total
        // sign length
        // sign
        // data
        //
        Error = OscProcessRequestSigned( RequestContext, clientState );

    }
    else if (memcmp(loginMessage->Signature, SetupRequestSignature, 4) == 0)
    {
        //
        // This is a request by a textmode setup.
        //
        // Format is defined in SPUDP_PACKET in oskpkt.h
        //
        Error = OscProcessSetupRequest( RequestContext, clientState );

    }
    else if (IsLogoffMessage)
    {
        //
        // This is a logoff request. clientState has
        // already been removed from the database.
        //
        Error = OscProcessLogoff( RequestContext, clientState );

    }
    else if (IsNetcardRequestMessage)
    {
        //
        // This is a netcard request, which needs no client state.
        //
        Error = OscProcessNetcardRequest( RequestContext );

    }
    else if (IsHalRequestMessage)
    {
        //
        // This is a hal request
        //
        Error = OscProcessHalRequest( RequestContext, clientState );

    }
    else
    {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "Received unknown message!\n" ));
        Error = ERROR_INVALID_FUNCTION;
    }

    if ( clientState ) {

        clientState->LastUpdate = GetTickCount();

        if (!IsNetcardRequestMessage) {

            //
            // We processed a packet, so if we get a first request for this
            // client state (meaning the client has rebooted), we need to
            // reinitialize it.
            //

            clientState->InitializeOnFirstRequest = TRUE;

            ++clientState->NegativeRefCount;

            //
            // FreeClientState will be TRUE if the two refcounts are equal.
            //
            FreeClientState = (BOOL)(clientState->PositiveRefCount == clientState->NegativeRefCount);

            clientState->CriticalSectionHeld = FALSE;
            LeaveCriticalSection(&clientState->CriticalSection);
            BinlPrintDbg((DEBUG_OSC, "Leaving CS for clientState = 0x%08x\n", clientState ));

            if (FreeClientState)
            {
                FreeClient(clientState);
            }
        }
    }

    return Error;
}

DWORD
OscVerifyLastResponseSize(
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function checks that the LastResponse buffer is big enough,
    if not it reallocates it. The algorithm used is to keep increasing
    the size of the buffer, but not to try to shrink it.

Arguments:

    clientState - The client state for the remote. clientState->
        LastResponseLength should be set to the needed size.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = ERROR_SUCCESS;

    TraceFunc("OscVerifyLastResponseSize( )\n");

    if (clientState->LastResponseAllocated < clientState->LastResponseLength) {
        if (clientState->LastResponse) {
            BinlFreeMemory(clientState->LastResponse);
        }
        clientState->LastResponse = BinlAllocateMemory(clientState->LastResponseLength);
        if (clientState->LastResponse == NULL) {
            clientState->LastResponseAllocated = 0;
            BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not grow LastResponse to %ld bytes\n", clientState->LastResponseLength ));
            Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        } else {
            clientState->LastResponseAllocated = clientState->LastResponseLength;
        }
    }
    return Error;
}

DWORD
OscProcessNegotiate(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function processes a negotiate message.
    IT IS CALLED WITH clientState->CriticalSection HELD.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

    clientState - The client state for the remote.

Return Value:

    Windows Error.

--*/
{
    DWORD Error;
    SECURITY_STATUS SecStatus;
    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;
    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;
    TimeStamp Lifetime;
    LOGIN_PACKET UNALIGNED * loginMessage = (LOGIN_PACKET UNALIGNED *)RequestContext->ReceiveBuffer;
    PUCHAR TempChallengeBuffer;
    LOGIN_PACKET UNALIGNED * SendLoginMessage;


    TraceFunc("OscProcessNegotiate( )\n");

    //
    // First free anything we have allocated for this client. We
    // assume that each negotiate is a new request since the client
    // may have rebooted, so we don't resend the last response.
    //

    if (clientState->AuthenticatedDCLdapHandle) {
        //  Reconnecting again. Use new credentials.
        ldap_unbind(clientState->AuthenticatedDCLdapHandle);
        clientState->AuthenticatedDCLdapHandle = NULL;
    }
    if (clientState->UserToken) {
        CloseHandle(clientState->UserToken);
        clientState->UserToken = NULL;
    }

    if (clientState->NegotiateProcessed) {

        BinlPrintDbg(( DEBUG_OSC, "Got negotiate from client, reinitializing negotiate\n" ));

        SecStatus = DeleteSecurityContext( &clientState->ServerContextHandle );

        if ( SecStatus != STATUS_SUCCESS ) {
            BinlPrintDbg(( DEBUG_OSC_ERROR, "DeleteSecurityContext failed: %lx\n", SecStatus ));
            // This seems to fail if a previous logon failed, so ignore errors
            // return SecStatus;
        }

        clientState->NegotiateProcessed = FALSE;
    }

    if (clientState->AuthenticateProcessed) {

        BinlPrintDbg(( DEBUG_OSC, "Got negotiate from client, reinitializing authenticate\n"));

        clientState->AuthenticateProcessed = FALSE;
    }

    //
    // Once the client has logged in we need to worry about resending screens
    // if the client issues the request again. 0 is an invalid sequence
    // number, so set this to 0 to ensure that any stale LastResponse is
    // not resent.
    //

    clientState->LastSequenceNumber = 0;

    //
    // Get the ChallengeMessage (ServerSide)
    //

    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    TempChallengeBuffer = (PUCHAR)BinlAllocateMemory(PackageInfo->cbMaxToken);
    if (TempChallengeBuffer == NULL) {
        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        BinlPrintDbg(( DEBUG_OSC, "Allocate TempChallengeBuffer failed\n"));
        return Error;
    }

    ChallengeBuffer.pvBuffer = TempChallengeBuffer;
    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = loginMessage->Length;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN | SECBUFFER_READONLY;
    NegotiateBuffer.pvBuffer = loginMessage->Data;

    SecStatus = AcceptSecurityContext(
                    &CredentialHandle,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ISC_REQ_SEQUENCE_DETECT | ASC_REQ_ALLOW_NON_USER_LOGONS,
                    SECURITY_NATIVE_DREP,
                    &clientState->ServerContextHandle,
                    &ChallengeDesc,
                    &clientState->ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        if ( !NT_SUCCESS(SecStatus) ) {
            BinlPrintDbg(( DEBUG_OSC_ERROR, "AcceptSecurityContext (Challenge): %lx", SecStatus ));
            BinlFreeMemory(TempChallengeBuffer);
            return SecStatus;
        }
    }

    //
    // Send the challenge message back to the client.
    //

    clientState->LastResponseLength = ChallengeBuffer.cbBuffer + LOGIN_PACKET_DATA_OFFSET;
    Error = OscVerifyLastResponseSize(clientState);
    if (Error != ERROR_SUCCESS) {
        BinlFreeMemory(TempChallengeBuffer);
        return Error;
    }

    SendLoginMessage = (LOGIN_PACKET UNALIGNED *)(clientState->LastResponse);

    memcpy(SendLoginMessage->Signature, ChallengeSignature, 4);
    SendLoginMessage->Length = ChallengeBuffer.cbBuffer;
    memcpy(SendLoginMessage->Data, ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer);

    BinlFreeMemory(TempChallengeBuffer);

#ifdef TEST_FAILURE
    if (FailFirstChallenge) {
        BinlPrintDbg(( DEBUG_OSC, "NOT Sending CHL, %d bytes\n", clientState->LastResponseLength));
        FailFirstChallenge = FALSE;
        Error = ERROR_SUCCESS;
    } else
#endif
    Error = SendUdpMessage(RequestContext, clientState, FALSE, FALSE);

    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not send CHAL message %d\n", Error));
    }

    clientState->NegotiateProcessed = TRUE;

    return Error;

}


DWORD
OscProcessAuthenticate(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function processes an authenticate message.
    IT IS CALLED WITH clientState->CriticalSection HELD.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

    clientState - The client state for the remote.

Return Value:

    Windows Error.

--*/
{
    DWORD Error;
    SECURITY_STATUS SecStatus;
    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;
    TimeStamp Lifetime;
    LOGIN_PACKET UNALIGNED * loginMessage = (LOGIN_PACKET UNALIGNED *)RequestContext->ReceiveBuffer;
    LOGIN_PACKET UNALIGNED * SendLoginMessage;
    
    TraceFunc("OscProcessAuthenticate( )\n");

    //
    // Make sure we have gotten a negotiate.
    //

    if (!clientState->NegotiateProcessed) {

        BinlPrintDbg(( DEBUG_OSC_ERROR, "Received AUTH without NEG?\n"));
        return ERROR_INVALID_DATA;

    }

    //
    // If we have already responsed to this, just resend with the
    // same status.
    //

    if (clientState->AuthenticateProcessed) {

        SecStatus = clientState->AuthenticateStatus;

        BinlPrintDbg(( DEBUG_OSC, "Got authenticate from client, resending\n"));

    } else {

        //
        // Finally authenticate the user (ServerSide)
        //

        AuthenticateDesc.ulVersion = 0;
        AuthenticateDesc.cBuffers = 1;
        AuthenticateDesc.pBuffers = &AuthenticateBuffer;

        AuthenticateBuffer.cbBuffer = loginMessage->Length;
        AuthenticateBuffer.BufferType = SECBUFFER_TOKEN | SECBUFFER_READONLY;
        AuthenticateBuffer.pvBuffer = loginMessage->Data;

        SecStatus = AcceptSecurityContext(
                        NULL,
                        &clientState->ServerContextHandle,
                        &AuthenticateDesc,
                        ASC_REQ_ALLOW_NON_USER_LOGONS,
                        SECURITY_NATIVE_DREP,
                        &clientState->ServerContextHandle,
                        NULL,
                        &clientState->ContextAttributes,
                        &Lifetime );
       
        if ( SecStatus != STATUS_SUCCESS ) {

            BinlPrintDbg(( DEBUG_OSC_ERROR, "AcceptSecurityContext (Challenge): %lx\n", SecStatus ));

        }         
        
        //
        // Send the result back to the client.
        //

        clientState->LastResponseLength = LOGIN_PACKET_DATA_OFFSET + sizeof(ULONG);
        Error = OscVerifyLastResponseSize(clientState);
        if (Error != ERROR_SUCCESS) {
            return Error;
        }

        SendLoginMessage = (LOGIN_PACKET UNALIGNED *)(clientState->LastResponse);

        memcpy(SendLoginMessage->Signature, ResultSignature, 4);
        SendLoginMessage->Length = 4;
        SendLoginMessage->Status = SecStatus;                

        clientState->AuthenticateProcessed = TRUE;
        clientState->AuthenticateStatus = SecStatus;
    }

#ifdef TEST_FAILURE
    if (FailFirstResult) {
        BinlPrintDbg(( DEBUG_OSC, "NOT Sending OK, %d bytes\n", clientState->LastResponseLength));
        FailFirstResult = FALSE;
        Error = ERROR_SUCCESS;
    } else
#endif
    Error = SendUdpMessage(RequestContext, clientState, FALSE, FALSE);

    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not send OK message %d\n", Error));
    }

    return Error;

}


//
//
//
DWORD
OscProcessScreenArguments(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PUCHAR *NameLoc
    )
{
    SIGNED_PACKET UNALIGNED * signedMessage = (SIGNED_PACKET UNALIGNED *)RequestContext->ReceiveBuffer;
    PCHAR packetEnd = signedMessage->Data + signedMessage->Length - SIGNED_PACKET_EMPTY_LENGTH;
    DWORD Error = ERROR_SUCCESS;
    PCHAR Args;
    BOOLEAN GuidSent = FALSE;
    PDS_NAME_RESULTA pResults = NULL;

    TraceFunc("OscProcessScreenArguments( )\n");

    //
    // Find out the screen name and how long it is
    //
    *NameLoc = signedMessage->Data;
    Args = FindNext( *NameLoc, '\n', packetEnd );
    if ( Args == NULL )
    {
        BinlPrintDbg((DEBUG_OSC, "Could not determine the screen name."));
        *NameLoc = NULL;
        Error = ERROR_INVALID_DATA;
    }
    else
    {
        *Args = '\0';   // terminate

        //
        // The name can't have a ".." part in it.
        //

        if ((memcmp(*NameLoc, "..\\", 3) == 0) ||
            (strstr(*NameLoc, "\\..\\") != NULL)) {

            BinlPrintDbg((DEBUG_OSC, "Name <%s> has .. in it.", *NameLoc));
            *NameLoc = NULL;
            Error = ERROR_INVALID_DATA;

        } else {

            Args++;         // skip the NULL char

            //
            // Munge any variables that might have been passed back with it.
            // They come in like this:
            //    NextScreenName\nvariable=response\n....\nvariable=response\n\0
            //
            // If no arguments, it comes like:
            //    NextScreenName\n\0
            //
            while ( *Args )
            {
                PCHAR NextArg;
                PCHAR Response;
                PCHAR EncodedResponse;

                //
                // Find the variable name
                //
                Response = FindNext( Args, '=', packetEnd );
                if ( Response == NULL )
                {
                    BinlPrintDbg((DEBUG_OSC, "Could not find <variable>.\n" ));
                    Error = ERROR_INVALID_DATA;
                    break;
                }

                //
                // Find the variable response value
                //
                NextArg = FindNext( Response, '\n', packetEnd );
                if ( NextArg == NULL )
                {
                    BinlPrintDbg((DEBUG_OSC, "Could not find <response>.\n" ));
                    Error = ERROR_INVALID_DATA;
                    break;
                }

                //
                // Terminate strings
                //
                *NextArg = '\0';
                *Response = '\0';

                //
                // Point to response
                //
                Response++;
                NextArg++;

                //
                //
                // Add them to the Variable table.
                // If the variable starts with a '*', encode it first.
                //
                if (Args[0] == '*') {
                    Error = OscRunEncode(clientState, Response, &EncodedResponse);
                    if (Error == ERROR_SUCCESS) {
                        Error = OscAddVariableA( clientState, Args, EncodedResponse );
                        BinlFreeMemory(EncodedResponse);
                    }
                } else {

                    //
                    // Check whether this is the GUID variable. If it is, we'll
                    // need to do some special processing later. See below.
                    //

                    if ( Response[0] != '\0'
                      && _stricmp( Args, "GUID" ) == 0 )
                    {
                        GuidSent = TRUE;
                    }

                    // HACKHACK: Special case "MACHINEOU" for translation from canonical form
                    //           to 1779 so we can use it later.
                    if ( Response[0] != '\0'
                      && _stricmp( Args, "MACHINEOU" ) == 0 )
                    {
                        BOOL FirstTime = TRUE;
invalid_ds_handle:
                        // Make sure the handle is initialized
                        if ( BinlOscClientDSHandle == NULL )
                        {
                            HANDLE hTemp;
                            Error = DsBind(NULL, NULL, &hTemp);
                            InterlockedCompareExchangePointer( (void**)&BinlOscClientDSHandle, hTemp, NULL );
                            if ( BinlOscClientDSHandle != hTemp )
                            {
                                DsUnBind( &hTemp );
                            }
                        }

                        if ( Error == ERROR_SUCCESS )
                        {
                            Error = DsCrackNamesA( BinlOscClientDSHandle,
                                                   DS_NAME_NO_FLAGS,
                                                   DS_UNKNOWN_NAME,
                                                   DS_FQDN_1779_NAME,
                                                   1,
                                                   &Response,
                                                   &pResults );
                            BinlAssertMsg( Error == ERROR_SUCCESS, "Error in DsCrackNames\n" );

                            if ( Error == ERROR_SUCCESS ) {
                                if ( pResults->cItems == 1
                                  && pResults->rItems[0].status == DS_NAME_NO_ERROR
                                  && pResults->rItems[0].pName ) {    // paranoid
                                    Response = pResults->rItems[0].pName;
                                } else {
                                    //
                                    // check if we have an "external trust"
                                    // problem.  if that's the case, then we
                                    // need to bind to a DC in the domain we
                                    // care about and retrieve the information
                                    // from there.
                                    //
                                    if (pResults->cItems == 1 && pResults->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY) {
                                        HANDLE hDC;

                                        Error = MyGetDcHandle(clientState, pResults->rItems[0].pDomain,&hDC);
                                        if (Error == ERROR_SUCCESS) {
                                            DsFreeNameResultA( pResults );
                                            pResults = NULL;
                                            Error = DsCrackNamesA(
                                                       hDC,
                                                       DS_NAME_NO_FLAGS,
                                                       DS_UNKNOWN_NAME,
                                                       DS_FQDN_1779_NAME,
                                                       1,
                                                       &Response,
                                                       &pResults );

                                            DsUnBindA(&hDC);

                                            if (Error != ERROR_SUCCESS) {
                                                BinlPrintDbg((
                                                    DEBUG_OSC_ERROR,
                                                    "DsCrackNames failed, ec = %d.\n",
                                                    Error ));
                                            }
                                            else if (Error == ERROR_SUCCESS ) {
                                                if ( pResults->cItems == 1
                                                  && pResults->rItems[0].status == DS_NAME_NO_ERROR
                                                  && pResults->rItems[0].pName ) {    // paranoid
                                                    Response = pResults->rItems[0].pName;
                                                } else {
                                                    BinlPrintDbg((
                                                        DEBUG_OSC,
                                                        "pResults->rItems[0].status = %u\n",
                                                        pResults->rItems[0].status ));
                                                    Error = pResults->rItems[0].status;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        //
                        // DsCrackNamesA can return any number of error messages
                        // to us which can indicate the server is unavailable.
                        // If we get any error code, then the handle is stale
                        // stale and needs to be refreshed before we try again.
                        // note that we'll only try again one time.
                        if (Error != ERROR_SUCCESS) {
                            HANDLE hTemp;
                            BinlPrintDbg((
                                DEBUG_ERRORS,
                                "DsCrackNames returned a semi-expected error code.  Need to refresh handle.\n"
                                 ));
                            hTemp = InterlockedExchangePointer( (void**)&BinlOscClientDSHandle, NULL);
                            DsUnBind( &hTemp );
                            if (FirstTime) {
                                FirstTime = FALSE;
                                goto invalid_ds_handle;
                            }
                        }
                    }

                    Error = OscAddVariableA( clientState, Args, Response );

                }

                if ( Error != ERROR_SUCCESS ) {
                    BinlPrintDbg(( DEBUG_OSC_ERROR,
                                "!!Error 0x%08x - Could not add argument '%s' = '%s'\n",
                                Error, Args, Response));
                    break;
                }

                BinlPrintDbg(( DEBUG_OSC, "Got argument '%s' = '%s'\n", Args, Response));

                if (pResults) {
                    DsFreeNameResultA( pResults );
                    pResults = NULL;
                }

                Args = NextArg;
            }
        }
    }

    //
    // If the GUID was sent in this message, check to see if it's all zeroes
    // or all FFs. If it is, substitute a MAC address-based GUID. This is the
    // same thing that we do when we receive DHCP packets with bogus GUIDs.
    // We need to do this here, otherwise we end up adding the client to the
    // DS with a bogus GUID. It seems that PXE 2.0 clients always send the
    // GUID option even when they have no real machine GUID.
    //
    // Note that we can't do this substitution in the loop above because we
    // might not have process the MAC address variable yet. (Currently
    // OSChooser always puts the MAC address ahead of the GUID in the packet,
    // but we don't want to depend on that.)
    //

    if ( GuidSent ) {

        //
        // A GUID was sent. Retrieve it. It should be there, but if it
        // isn't, just bail.
        //

        LPSTR guid = OscFindVariableA( clientState, "GUID" );
        DWORD length;

        if ( (guid != NULL) && ((length = strlen(guid)) != 0) ) {

            //
            // Check the GUID for all zeroes or all FFs.
            //

            if ( (strspn( guid, "0" ) == length) ||
                 (strspn( guid, "F" ) == length) ) {

                //
                // The GUID is bogus. Substitute a MAC address GUID.
                // We should have the MAC address at this point, but
                // if we don't, just bail.
                //

                LPSTR mac = OscFindVariableA( clientState, "MAC" );

                if ( mac != NULL ) {

                    //
                    // The generated GUID is zeroes followed by the
                    // MAC address. (In other words, the MAC address
                    // is right-justified in a 32-character string.)
                    //

                    UCHAR guidString[(BINL_GUID_LENGTH * 2) + 1];

                    length = strlen(mac);

                    if ( length > BINL_GUID_LENGTH * 2 ) {

                        //
                        // We have an unusually long MAC address.
                        // Use the last 32 characters.
                        //

                        mac = mac + length - (BINL_GUID_LENGTH * 2);
                        length = BINL_GUID_LENGTH * 2;
                    }
                    else if ( length < BINL_GUID_LENGTH * 2 ) {

                        //
                        // Write zeroes in front of the MAC address.
                        //

                        memset( guidString, '0', (BINL_GUID_LENGTH * 2) - length );
                    }

                    //
                    // Copy the MAC address into the GUID (including the
                    // null terminator).
                    //

                    strcpy( guidString + (BINL_GUID_LENGTH * 2) - length, mac );

                    //
                    // Set the new GUID.
                    //

                    OscAddVariableA( clientState, "GUID", guidString );
                }
            }
        }

    }

    return Error;
}

//
//
//
DWORD
OscProcessRequestUnsigned(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function processes a request message.
    IT IS CALLED WITH clientState->CriticalSection HELD.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

    clientState - The client state for the remote.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    SIGNED_PACKET UNALIGNED * signedMessage = (SIGNED_PACKET UNALIGNED *)RequestContext->ReceiveBuffer;

    PCHAR RspMessage = NULL;
    ULONG RspMessageLength = 0;
    ULONG k;

    WCHAR FilePath[ MAX_PATH ];
    HANDLE hfile;
    PCHAR NameLoc;

    TraceFunc("OscProcessRequestUnsigned( )\n");

    //
    // All clients start with at least one unsigned request. When we get an
    // unsigned request, the client may have rebooted and be asking for a
    // different screen with the same sequence number. To avoid having
    // to check for this, we don't bother resending unsigned screens. We
    // do save the incoming sequence number since we use that for sending
    // the response.
    //

    clientState->LastSequenceNumber = signedMessage->SequenceNumber;

    //
    // We have a valid request for a screen, process incoming arguments.
    //

    Error = OscProcessScreenArguments( RequestContext, clientState, &NameLoc );

    if ( Error != ERROR_SUCCESS ) {

        goto SendScreen;

    } else {
        //
        // If NULL message, then send down the welcome screen.
        //
        if ( NameLoc == NULL || *NameLoc == '\0' )
        {
            if ( _snwprintf( FilePath,
                             sizeof(FilePath) / sizeof(FilePath[0]),
                             L"%ws\\OSChooser\\%ws",
                             IntelliMirrorPathW,
                             DEFAULT_SCREEN_NAME
                             ) < 0 ) {
                Error = ERROR_BAD_PATHNAME;
                goto SendScreen;
            }

            FilePath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe

            BinlPrint(( DEBUG_OSC, "NULL screen name so we are retrieving the Welcome Screen.\n"));

            //
            // This is the first request a client makes, which is a good
            // time to clean up the client state, unless we don't need to
            // (because the client state is new).
            //

            if (clientState->InitializeOnFirstRequest) {
                if (!OscInitializeClientVariables(clientState)) {
                    Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
                    goto SendScreen;
                }
            }
        }
        else
        {
            WCHAR NameLocW[ MAX_PATH ];
            ULONG NameLocLength;

            //
            // Create path to possible OSC file. Should look something like:
            //  "D:\RemoteInstall\OSChooser\English\NameLoc.OSC"
            BinlAssert( NameLoc );

            NameLocLength = strlen(NameLoc) + 1;
            if (NameLocLength > MAX_PATH) {
                NameLocLength = MAX_PATH-1;
                NameLocW[ MAX_PATH-1 ] = L'\0';
            }

            if (!BinlAnsiToUnicode(NameLoc, NameLocW, (USHORT)MAX_PATH*sizeof(WCHAR) )) {
                Error = ERROR_BAD_PATHNAME;
                goto SendScreen;
            }

            if ( _snwprintf( FilePath,
                             sizeof(FilePath) / sizeof(FilePath[0]),
                             L"%ws\\OSChooser\\%ws\\%ws.OSC",
                             IntelliMirrorPathW,
                             OscFindVariableW( clientState, "LANGUAGE" ),
                             NameLocW
                             ) < 0 ) {
                Error = ERROR_BAD_PATHNAME;
                goto SendScreen;
            }

            FilePath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe

        }

        BinlPrint(( DEBUG_OSC, "Retrieving screen file: '%ws'\n", FilePath));

    }

    //
    // If we find the file, load it into memory.
    //
    hfile = CreateFile( FilePath, GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    if ( hfile != INVALID_HANDLE_VALUE )
    {
        DWORD FileSize;
        //
        // Find out how big this screen is, if bigger than 0xFFFFFFFF we won't
        // display it.
        //
        FileSize = GetFileSize( hfile, NULL );
        if ( FileSize != 0xFFFFffff )
        {
            DWORD dwRead = 0;

            RspMessage = BinlAllocateMemory( FileSize + 3 );
            if ( RspMessage == NULL )
            {
                Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
            }
            else
            {
                RspMessageLength = 0;
                RspMessage[0] = '\0';

                while ( dwRead != FileSize )
                {
                    BOOL b;
                    DWORD dw;
                    b = ReadFile( hfile, &RspMessage[dwRead], FileSize - dwRead, &dw, NULL );
                    if (!b)
                    {
                        BinlPrintDbg(( DEBUG_OSC_ERROR, "Error reading screen file: Seek=%u, Size=%u, File=%ws\n",
                                    dwRead, FileSize - dwRead, FilePath ));
                        Error = GetLastError( );
                        break;
                    }
                    dwRead += dw;
                }

                RspMessageLength = dwRead;
            }
        }
        else
        {
            BinlPrintDbg((DEBUG_OSC, "!!Error - Could not determine file size.\n"));
            Error = GetLastError();
        }

        CloseHandle( hfile );
    }
    else
    {
        BinlPrintDbg((DEBUG_OSC, "!!Error - Did not find screen file: '%ws'\n", FilePath));
        Error = GetLastError();
        OscAddVariableW( clientState, "SUBERROR", FilePath );
    }

SendScreen:
    //
    // If there were any errors, switch to the error screen.
    //
    if ( Error != ERROR_SUCCESS )
    {
        //
        // Send down message about the failure.
        //
        if ( RspMessage )
        {
            BinlFreeMemory( RspMessage );
            RspMessage = NULL; // paranoid
        }

        BinlPrintDbg((DEBUG_OSC, "!!Error - Sending error screen back to client. Server error=0x%08x\n", Error));

        // 
        // do we want to be returning this
        // error status, or the one that got us here?
        //
        Error = GenerateErrorScreen( &RspMessage,
                                     &RspMessageLength,
                                     Error,
                                     clientState );
        BinlAssert( Error == ERROR_SUCCESS );
        if ( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // Require them to re-login.
        //
        // clientState->AuthenticateProcessed = FALSE;
    }

    if (RspMessage) {

        // Do replacements for dynamic screens or error screens
        SearchAndReplace( clientState->Variables,
                          &RspMessage,
                          clientState->nVariables,
                          RspMessageLength,
                          0);
        RspMessageLength = strlen( RspMessage ) + 1;
        RspMessage[RspMessageLength-1] = '\0';  // paranoid
    }

    //
    // Send out a signed response
    //
    BinlAssert( RspMessage );
    // BinlPrint((DEBUG_OSC, "Sending Unsigned:\n%s\n", RspMessage));

    OscSendUnsignedMessage( RequestContext, clientState, RspMessage, RspMessageLength );

Cleanup:
    //
    // Free any memory the we allocated for the screen.
    //
    if ( RspMessage ) {
        BinlFreeMemory( RspMessage );
    }

    return Error;
}

//
//
//
OscInstallClient(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PCREATE_DATA createData )
{
    DWORD Error;

    //
    // Client wants to create a machine account and run setup.
    //
    Error = OscSetupClient( clientState, TRUE );

    if ( Error == ERROR_SUCCESS  )
    {
        //
        // Only create the account if the setup went OK.
        //
RetryCreateAccount:
        Error = OscCreateAccount( clientState, createData );
        switch ( Error )
        {
        case ERROR_BINL_DUPLICATE_MACHINE_NAME_FOUND:
            if ( clientState->fAutomaticMachineName ) {

                // Try generating another name
                Error = GenerateMachineName( clientState );
                if ( Error == ERROR_SUCCESS ) {
                    goto RetryCreateAccount;
                }
                BinlPrint(( DEBUG_OSC_ERROR, "!!Error 0x%08x - Failed to generate machine name\n" ));
            }
            break;

        default:
            break;
        }        
    }

#ifdef SET_ACLS_ON_CLIENT_DIRS
    if ( Error == ERROR_SUCCESS )
    {
        //
        // Change the ACL permission of the client machine's root directory
        //
        Error = OscSetClientDirectoryPermissions( clientState );
    }
#endif // SET_ACLS_ON_CLIENT_DIRS

    if ( Error != ERROR_SUCCESS )
    {
        OscUndoSetupClient( clientState );

        BinlPrint((DEBUG_OSC,
                   "!!Error 0x%08x - Error setting up the client for Setup.\n",
                   Error ));
    }

    return Error;
}

//
// OscGetCreateData( )
//
// Queries the DS to get the information required to create
// the CreateData secret and then builds one.
//
DWORD
OscGetCreateData(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PCREATE_DATA CreateData)
{
    DWORD Error = ERROR_BINL_INVALID_BINL_CLIENT;
    PCHAR pGuid;
    PWCHAR pGuidW;
    UCHAR Guid[ BINL_GUID_LENGTH ];
    WCHAR  BootFilePath[MAX_PATH];
    PMACHINE_INFO pMachineInfo = NULL;
    WCHAR  MachinePassword[LM20_PWLEN + 1];
    WCHAR  SifPath[MAX_PATH];
    WCHAR  SifFile[(BINL_GUID_LENGTH*2)+(sizeof(TEMP_DIRECTORY)/sizeof(WCHAR))+6];
    DWORD  FileAttributes;
    ULONG  MachinePasswordLength;
    DWORD  dwRequestedInfo = MI_NAME | MI_BOOTFILENAME | MI_MACHINEDN | MI_SAMNAME;
    PWCHAR pszOU;
    USHORT SystemArchitecture;
    DWORD  OldFlags;
    ULONG  lenIntelliMirror = wcslen(IntelliMirrorPathW) + 1;

    pGuid = OscFindVariableA( clientState, "GUID" );
    if ( pGuid[0] == '\0' ) {
        BinlPrintDbg((DEBUG_OSC_ERROR, "OscGetCreateData: could not find GUID" ));
        OscAddVariableA( clientState, "SUBERROR", "GUID" );
        Error = ERROR_BINL_MISSING_VARIABLE;
        goto e0;
    }

    pGuidW = OscFindVariableW( clientState, "GUID" );
    if ( pGuidW[0] == L'\0' ) {
        BinlPrintDbg((DEBUG_OSC_ERROR, "OscGetCreateData: could not find GUID (unicode)" ));
        OscAddVariableA( clientState, "SUBERROR", "GUID" );
        Error = ERROR_BINL_MISSING_VARIABLE;
        goto e0;
    }

    Error = OscGuidToBytes( pGuid, Guid );
    if ( Error != ERROR_SUCCESS ) {
        BinlPrintDbg((DEBUG_OSC_ERROR, "OscGetCreateData: OscGuidToBytes failed" ));
        goto e0;
    }

    SystemArchitecture = OscPlatformToArchitecture(clientState);

    Error = GetBootParameters( Guid,
                               &pMachineInfo,
                               dwRequestedInfo,
                               SystemArchitecture,
                               FALSE );
    if ( Error != ERROR_SUCCESS ) {
        BinlPrintDbg((DEBUG_OSC_ERROR, "OscGetCreateData: GetBootParameters failed %lx", Error ));
        goto e0;
    }

    BinlAssertMsg(( pMachineInfo->dwFlags & dwRequestedInfo )== dwRequestedInfo, "Missing info." );

    //
    // The SIF file is named GUID.sif, and it must exist (the SIF
    // files go in a tmp directory so an admin may have cleaned it
    // out).
    //

    if (0 > _snwprintf(SifFile,
                   sizeof(SifFile)/sizeof(WCHAR),
                   L"%ws\\%ws.sif",
                   TEMP_DIRECTORY,
                   pGuidW)) {
        Error = ERROR_BAD_PATHNAME;
        goto e0;
    }
    SifFile[sizeof(SifFile)/sizeof(WCHAR) - 1] = L'\0';     // terminate

    if (0 > _snwprintf( SifPath,
                     sizeof(SifPath) / sizeof(SifPath[0]),
                     L"%ws\\%ws",
                     IntelliMirrorPathW,
                     SifFile
                     )) {
        Error = ERROR_BAD_PATHNAME;
        goto e0;
    }
    SifPath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe

    FileAttributes = GetFileAttributes(SifPath);
    if (FileAttributes == 0xFFFFFFFF) {
        BinlPrintDbg((DEBUG_OSC_ERROR, "OscGetCreateData: SifFile not found" ));
        OscAddVariableW( clientState, "SUBERROR", SifPath );
        Error = ERROR_BINL_SIFFILE_NOT_FOUND;
        goto e0;
    }

    //
    // The bootfile stored in pMachineInfo->BootFileName will point to
    // oschooser, so we parse the SIF to find the setupldr boot file.
    //

    BootFilePath[0] = L'\0';
    GetPrivateProfileString( OSCHOOSER_SIF_SECTIONW,
                             L"LaunchFile",
                             BootFilePath, // default
                             BootFilePath,
                             MAX_PATH,
                             SifPath );

    //
    // This might fail to add if it is too long due to bogus data in the .sif.
    //
    Error = OscAddVariableW( clientState, "BOOTFILE",  BootFilePath );
    if ( Error != ERROR_SUCCESS ) {
        goto e0;
    }

    //
    // This might fail to add if it is too long due to bogus data in the DS.
    //

    if (pMachineInfo->dwFlags & MI_SIFFILENAME_ALLOC) {

        Error = OscAddVariableW( clientState, "FORCESIFFILE",  pMachineInfo->ForcedSifFileName );
        if ( Error != ERROR_SUCCESS ) {
            goto e0;
        }

    }
    //
    // These next two shouldn't fail unless someone has modified the DS by
    // hand, since they are checked when the accounts are generated, but
    // best to be safe.
    //
    Error = OscAddVariableW( clientState, "NETBIOSNAME",   pMachineInfo->SamName );
    if ( Error != ERROR_SUCCESS) {
        goto e0;
    }
    Error = OscAddVariableW( clientState, "MACHINENAME",   pMachineInfo->Name );
    if ( Error != ERROR_SUCCESS) {
        goto e0;
    }

    //
    // Shouldn't fail unless the IntelliMirrorPathW is too long.
    //
    Error = OscAddVariableW( clientState, "SIFFILE",       &SifPath[lenIntelliMirror]  );
    if ( Error != ERROR_SUCCESS) {
        goto e0;
    }

    pszOU = wcschr( pMachineInfo->MachineDN, L',' );
    if (pszOU)
    {
        pszOU++;
        Error = OscAddVariableW( clientState, "MACHINEOU", pszOU );
        if ( Error != ERROR_SUCCESS ) {
            goto e0;
        }
    }


    Error = OscSetupMachinePassword( clientState, SifPath );
    if (Error != ERROR_SUCCESS) {
        goto e0;
    }

    //
    // save off the old flags so we can update the machine account information
    //
    OldFlags = pMachineInfo->dwFlags;

    pMachineInfo->dwFlags        = MI_PASSWORD | MI_MACHINEDN;
    pMachineInfo->Password       = clientState->MachineAccountPassword;
    pMachineInfo->PasswordLength = clientState->MachineAccountPasswordLength;

    Error = UpdateAccount( clientState, pMachineInfo, FALSE );
    if ( Error != LDAP_SUCCESS ) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "!! LdapError 0x%08x - UpdateAccount( ) failed.\n", Error ));
        goto e0;
    }

    pMachineInfo->dwFlags |= OldFlags;  // add them back

    Error = OscConstructSecret(
                    clientState,
                    clientState->MachineAccountPassword,
                    clientState->MachineAccountPasswordLength,
                    CreateData );
    if ( Error != ERROR_SUCCESS ) {
        BinlPrintDbg((DEBUG_OSC_ERROR, "OscGetCreateData: OscConstructSecret failed %lx", Error ));
        goto e0;
    }

e0:
    if (pMachineInfo) {

        BinlDoneWithCacheEntry( pMachineInfo, FALSE );
    }

    return Error;
}

//
//
//
DWORD
OscProcessRequestSigned(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function processes a request message.
    IT IS CALLED WITH clientState->CriticalSection HELD.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

    clientState - The client state for the remote.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    SIGNED_PACKET UNALIGNED * signedMessage = (SIGNED_PACKET UNALIGNED *)RequestContext->ReceiveBuffer;

    PCHAR RspMessage = NULL;
    ULONG RspMessageLength = 0;
    PCHAR RspBinaryData = NULL;
    ULONG RspBinaryDataLength = 0;
    ULONG k;
    DWORD dwErr;

    WCHAR FilePath[ MAX_PATH ];
    CHAR TmpName[ 16 ];
    HANDLE hfile;
    PCHAR NameLoc;

    LPSTR psz;

    TraceFunc("OscProcessRequestSigned( )\n");

    if ( clientState->AuthenticateProcessed == FALSE )
    {
        SIGNED_PACKET UNALIGNED * SendSignedMessage;

        //
        // This may happen if we reboot the server -- send an ERRS
        // and the client should reconnect OK.
        //

        BinlPrintDbg(( DEBUG_OSC_ERROR, "Got REQ but not authenticated, sending UNR\n" ));

        clientState->LastResponseLength = SIGNED_PACKET_ERROR_LENGTH;
        Error = OscVerifyLastResponseSize(clientState);
        if (Error != ERROR_SUCCESS) {
            return Error;
        }

        SendSignedMessage =
            (SIGNED_PACKET UNALIGNED *)(clientState->LastResponse);
        memcpy(SendSignedMessage->Signature, UnrecognizedClientSignature, 4);
        SendSignedMessage->Length = 4;
        SendSignedMessage->SequenceNumber = signedMessage->SequenceNumber;

        Error = SendUdpMessage( RequestContext, clientState, FALSE, FALSE );
        return Error;
    }

    if ( signedMessage->SequenceNumber == clientState->LastSequenceNumber )
    {
        //
        // Is the signature the same as the last one we sent out? If so,
        // then just resend (we'll do that after we leave this if
        // statement).
        //

        if ( clientState->LastResponse )
        {
            BinlPrintDbg(( DEBUG_OSC, "Resending last message\n" ));
        }
        else
        {
            //
            // We were unable to save the last response -- we are hosed!
            //
            BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not resend last message\n" ));
            return ERROR_NOT_ENOUGH_SERVER_MEMORY;
        }

        //
        // Resend last response
        //
        return SendUdpMessage( RequestContext,
                                  clientState,
                                  TRUE,
                                  TRUE );

    }
    else if ( signedMessage->SequenceNumber != ((clientState->LastSequenceNumber % 0x2000) + 1))
    {
        //
        // It's not the next message - ignore it.
        //

        BinlPrintDbg(( DEBUG_OSC, "got bogus sequence number: Got %u. Expected: %u\n",
            signedMessage->SequenceNumber , ((clientState->LastSequenceNumber % 0x2000) + 1)));
        return ERROR_INVALID_DATA;
    }

    //
    // Advance the clientState sequence counter
    //
    clientState->LastSequenceNumber = signedMessage->SequenceNumber;

    //
    // Verify packet signature
    //
    Error = OscVerifySignature( clientState, signedMessage );
    if ( Error != STATUS_SUCCESS ) {
        return Error;
    }

    //
    // We have a valid request for a screen.
    //
    if (signedMessage->Length == (SIGNED_PACKET_EMPTY_LENGTH))
    {
        //
        // An empty packet indicates to us to send down the Welcome screen.
        //
        if ( _snwprintf( FilePath,
                         sizeof(FilePath) / sizeof(FilePath[0]),
                         L"%ws\\OSChooser\\%ws",
                         IntelliMirrorPathW,
                         DEFAULT_SCREEN_NAME
                         ) < 0 ) {
            Error = ERROR_BAD_PATHNAME;

        } else {
            FilePath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe
            BinlPrintDbg(( DEBUG_OSC, "Retrieving Welcome Screen: %ws\n", FilePath));
        }
    }
    else
    {
        //
        // Process incoming arguments and get the next screen's name
        //
        Error = OscProcessScreenArguments( RequestContext, clientState, &NameLoc );

GrabAnotherScreen:
        //
        // Process special responses.
        //
        // INSTALL:     Indicates that user wants to create a new machine.
        // RESTART:     Indicates the client wants to restart setup.
        //
        if ( Error == ERROR_SUCCESS )
        {
            PWCHAR pCheckDomain = OscFindVariableW( clientState, "CHECKDOMAIN" );
            if (pCheckDomain[0] == L'1')
            {
                //
                // After the first login, the client will set this to
                // tell us to verify that the domain name used in this
                // context matches what the user requested. This will
                // prevent an invalid domain from being let through
                // due to SSPI using the default domain in that case.
                //

                BOOLEAN failedCheck = FALSE;
                DWORD impersonateError;
                PWCHAR pUserDomain = OscFindVariableW( clientState, "USERDOMAIN" );

                if ( pUserDomain[0] != L'\0' )
                {
                    SecPkgCredentials_Names names;
                    SECURITY_STATUS secStatus;
                    PWCHAR backslash;
                    PWSTR netbiosUserDomain = NULL;
                    DWORD Flags;

                    secStatus = QueryContextAttributes(
                                    &clientState->ServerContextHandle,
                                    SECPKG_CRED_ATTR_NAMES,
                                    &names);

                    if (secStatus == STATUS_SUCCESS) {

                        //
                        // The part up to the '\\' is the domain.
                        //

                        backslash = wcschr(names.sUserName, L'\\');
                        if (backslash != NULL) {
                            *backslash = L'\0';
                        }

                        if (ERROR_SUCCESS != GetDomainNetBIOSName(pUserDomain,&netbiosUserDomain)) {
                            Error = ERROR_BINL_USER_LOGIN_FAILED;
                            failedCheck = TRUE;
                        } else {


                            //
                            // If the domain names don't match, then the login
                            // succeeded due to the security package trying the
                            // server's domain name. We don't want to let those
                            // through since the LogonUser call will eventually
                            // fail. So fail right here.
                            //

                            if (_wcsicmp(netbiosUserDomain, names.sUserName) != 0) {

                                Error = ERROR_BINL_USER_LOGIN_FAILED;
                                failedCheck = TRUE;

                            }

                        }

                        if (netbiosUserDomain) {
                            BinlFreeMemory( netbiosUserDomain );
                        }

                        FreeContextBuffer(names.sUserName);

                    }
                }

                //
                // If we haven't already failed, try to impersonate and
                // revert. This verifies that the user has batch logon
                // permission.
                //

                if (!failedCheck) {

                    impersonateError = OscImpersonate(clientState);
                    if (impersonateError != ERROR_SUCCESS) {

                        if ( impersonateError == ERROR_LOGON_TYPE_NOT_GRANTED )
                        {
                            BinlPrint(( DEBUG_OSC_ERROR,
                                        "!!Error 0x%08x - CheckDomain: Batch Logon type not granted\n",
                                        impersonateError ));
                            Error = ERROR_BINL_LOGON_TYPE_NOT_GRANTED;
                        }
                        else
                        {
                            BinlPrint(( DEBUG_OSC_ERROR, "!!Error 0x%08x - CheckDomain: login failed\n", impersonateError ));
                            Error = ERROR_BINL_USER_LOGIN_FAILED;
                        }

                    } else {

                        OscRevert(clientState);
                    }

                }

                //
                // Once we've done this once, don't need to do it again.
                //

                if ( OscAddVariableW( clientState, "CHECKDOMAIN", L"0" ) != ERROR_SUCCESS )
                {
                    // don't overwrite the "Error" value unless we need to
                    Error = OscAddVariableW( clientState, "CHECKDOMAIN", L"0" );
                }
            }

            if ( _stricmp( NameLoc, "INSTALL" ) == 0 )
            {
                RspBinaryData = BinlAllocateMemory( sizeof(CREATE_DATA) );
                if (RspBinaryData == NULL) {
                    Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
                    goto SendResponse;    // skip the rest and just send it.
                }
                RspBinaryDataLength = sizeof(CREATE_DATA);

                //
                // This will fill in RspBinaryData with the CREATE_DATA
                // information.
                //

                Error = OscInstallClient( RequestContext, clientState, (PCREATE_DATA)RspBinaryData );

            }
            else if ( _stricmp( NameLoc, "LAUNCH" ) == 0 )
            {
                //
                // Launch the "LaunchFile" indicated in a SIF. Mainly used to
                // launch tools and other real-mode utilities.  In the case of
                // the command console, we need to copy this sif and fix it up
                // so that it looks like a textmode setup.
                //
                PCHAR pTemplatePath = OscFindVariableA( clientState, "SIF" );
                PCREATE_DATA pCreate;
                LONG nSize;

                if ( pTemplatePath[0] == '\0' ) {
                    BinlPrint(( DEBUG_OSC_ERROR, "Missing SIF variable\n" ));
                    OscAddVariableA( clientState, "SUBERROR", "SIF" );
                    Error = ERROR_BINL_MISSING_VARIABLE;
                    goto SendResponse;    // skip the rest and just send it.
                }

                if (RspMessage != NULL) {
                    BinlFreeMemory(RspMessage);
                }

                RspMessageLength = sizeof("LAUNCH") + sizeof(CREATE_DATA);
                RspMessage = BinlAllocateMemory( RspMessageLength );
                if ( RspMessage == NULL ) {
                    Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
                    goto SendResponse;    // skip the rest and just send it.
                }

                strcpy(RspMessage, "LAUNCH");

                RspBinaryData = BinlAllocateMemory( sizeof(CREATE_DATA) );
                if (RspBinaryData == NULL) {
                    Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
                    goto SendResponse;    // skip the rest and just send it.
                }

                ZeroMemory( RspBinaryData, sizeof(CREATE_DATA) );

                pCreate = (PCREATE_DATA)RspBinaryData;
                pCreate->VersionNumber = OSC_CREATE_DATA_VERSION;

                if (OscSifIsCmdConsA(pTemplatePath)) {
                    //
                    // Setup the client for an install
                    //
                    PSTR pSifFile;
                    Error = OscSetupClient( clientState, FALSE );

                    if (Error != ERROR_SUCCESS) {
                        goto SendResponse;
                    }

                    pTemplatePath = (PCHAR)FilePath;
                    pSifFile = OscFindVariableA( clientState, "SIFFILE");
                    if (!pSifFile ||
                        (_snprintf(pTemplatePath,
                                   sizeof(FilePath),
                                   "%s\\%s",
                                   IntelliMirrorPathA,
                                   pSifFile) < 0 )) {
                        Error = ERROR_BAD_PATHNAME;
                        goto SendResponse;
                    }
                    pTemplatePath[sizeof(FilePath)-1] = '\0'; // terminate
                    
                    pCreate->RebootParameter = OSC_REBOOT_COMMAND_CONSOLE_ONLY;
                }

                if (OscSifIsWinPE(pTemplatePath)) {
                    //
                    // Setup the client for an install
                    //
                    PSTR pSifFile;
                    Error = OscSetupClient( clientState, FALSE );

                    if (Error != ERROR_SUCCESS) {
                        goto SendResponse;
                    }

                    pTemplatePath = (PCHAR)FilePath;

                    pSifFile = OscFindVariableA( clientState, "SIFFILE");
                    if (!pSifFile ||
                        (_snprintf(pTemplatePath, 
                                   sizeof(FilePath),
                                   "%s\\%s",
                                   IntelliMirrorPathA,
                                   pSifFile) < 0)) {
                        Error = ERROR_BAD_PATHNAME;
                        goto SendResponse;
                    }
                    pTemplatePath[sizeof(FilePath)-1] = '\0'; // terminate
                    
                    //
                    // Currently it isn't necessary to have a WINPE OSC flag
                    // that's because you cannot share a winpe image with a
                    // regular image -- winpe is started via the presence of
                    // a MiniNT flag in the txtsetup.sif.  If this ever changes
                    // it may be necessary to pass this flag to oschoice.
                    //
                    //pCreate->RebootParameter = OSC_REBOOT_WINPE;
                }

                if (OscSifIsASR(pTemplatePath)) {
                    PSTR pGuid,pPathToAsrFile;
                    PSTR pSifFile;

                    //
                    // Setup the client for an install
                    //
                    Error = OscSetupClient( clientState, FALSE );

                    if (Error != ERROR_SUCCESS) {
                        goto SendResponse;
                    }

                    pTemplatePath = (PCHAR)FilePath;

                    pSifFile = OscFindVariableA( clientState, "SIFFILE");
                    if (!pSifFile ||
                        (_snprintf(pTemplatePath, 
                                   sizeof(FilePath),
                                   "%s\\%s",
                                   IntelliMirrorPathA,
                                   pSifFile) < 0)) {
                        Error = ERROR_BAD_PATHNAME;
                        goto SendResponse;
                    }
                    pTemplatePath[sizeof(FilePath)-1] = '\0';
                    
                    pCreate->RebootParameter = OSC_REBOOT_ASR;

                }


                nSize = GetPrivateProfileStringA( OSCHOOSER_SIF_SECTIONA,
                                                  "LaunchFile",
                                                  "",
                                                  pCreate->NextBootfile,
                                                  sizeof(pCreate->NextBootfile),
                                                  pTemplatePath );
                if ((nSize <= 0) || (pCreate->NextBootfile[0] == '\0')) {
                    Error = ERROR_INVALID_DATA;
                    goto SendResponse;
                }
                strncpy(pCreate->SifFile, 
                        pTemplatePath + strlen(IntelliMirrorPathA) + 1, 
                        min(sizeof(pCreate->SifFile), sizeof(FilePath) - strlen(IntelliMirrorPathA) - 1)); // skip the next backslash
                pCreate->SifFile[sizeof(pCreate->SifFile)-1] = '\0';

                BinlPrint(( DEBUG_OSC_ERROR, "Client will use SIF file %s\n", pCreate->SifFile ));
                BinlPrint(( DEBUG_OSC_ERROR, "Client rebooting to %s\n", pCreate->NextBootfile ));

                RspBinaryDataLength = sizeof(CREATE_DATA);

                goto SendResponse;    // skip the rest and just send it.
            }
            else if ( _stricmp( NameLoc, "RESTART" ) == 0 )
            {
                //
                // NOTE: This is very similar to the GETCREATE processing
                // except for the error case. We send down a packet with
                // only the create data in it.
                //

                //
                // Make RspMessage be NULL.
                //
                if (RspMessage != NULL) {
                    BinlFreeMemory(RspMessage);
                    RspMessage = NULL;
                }
                RspMessageLength = 0;

                RspBinaryData = BinlAllocateMemory( sizeof(CREATE_DATA) );
                if (RspBinaryData == NULL) {
                    Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
                    goto SendResponse;    // skip the rest and just send it.
                }

                Error = OscGetCreateData( RequestContext, clientState, (PCREATE_DATA)RspBinaryData );

                if ( Error == ERROR_SUCCESS ) {
                    RspBinaryDataLength = sizeof(CREATE_DATA);
                    goto SendResponse;    // skip the rest and just send it.
                } else {
                    BinlAssert( sizeof(TmpName) >= sizeof("RSTRTERR") );

                    BinlFreeMemory(RspBinaryData);
                    RspBinaryData = NULL;

                    strcpy(TmpName, "RSTRTERR");
                    NameLoc = TmpName;
                    Error = ERROR_SUCCESS;
                }

            }
        }

        //
        // Try to retrieve the next screen
        //
        if ( Error == ERROR_SUCCESS )
        {
            //
            // If NULL message, then send down the welcome screen.
            //
            if ( NameLoc == NULL || *NameLoc == '\0' )
            {
                if ( _snwprintf( FilePath,
                                 sizeof(FilePath) / sizeof(FilePath[0]),
                                 L"%ws\\OSChooser\\%ws",
                                 IntelliMirrorPathW,
                                 DEFAULT_SCREEN_NAME
                                 ) < 0 ) {
                    Error = ERROR_BAD_PATHNAME;

                } else {
                    FilePath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe
                    BinlPrint(( DEBUG_OSC, "NULL screen name so we are retrieving the Welcome Screen.\n"));
                }
            }
            else
            {
                WCHAR NameLocW[ MAX_PATH ];
                ULONG NameLocLength;

                //
                // Create path to possible OSC file. Should look something like:
                //  "D:\RemoteInstall\OSChooser\English\NameLoc.OSC"
                BinlAssert( NameLoc );

                NameLocLength = strlen(NameLoc) + 1;
                if (NameLocLength > MAX_PATH) {
                    NameLocLength = MAX_PATH-1;
                    NameLocW[ MAX_PATH-1 ] = L'\0';
                }

                if (!BinlAnsiToUnicode(NameLoc, NameLocW, (USHORT)MAX_PATH*sizeof(WCHAR) )) {
                    Error = ERROR_BAD_PATHNAME;
                }

#if DBG
                if (OscWatchVariable[0] != '\0') {
                    DbgPrint("Looking for screen <%ws>\n", NameLocW);
                }
#endif

                //
                // if it's ok to do so, try to set the filepath, but
                // be prepared for it to fail.
                //
                if ( Error == ERROR_SUCCESS &&
                     0 > _snwprintf( FilePath,
                                 sizeof(FilePath) / sizeof(FilePath[0]),
                                 L"%ws\\OSChooser\\%ws\\%ws.OSC",
                                 IntelliMirrorPathW,
                                 OscFindVariableW( clientState, "LANGUAGE" ),
                                 NameLocW
                                 )) {
                    Error = ERROR_BAD_PATHNAME;
                }
                FilePath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe
            }
        }
    }

    if ( Error == ERROR_SUCCESS )
    {
        //
        // If we find the file, load it into memory.
        //
        BinlPrint(( DEBUG_OSC, "Retrieving screen file: '%ws'\n", FilePath));

        hfile = CreateFile( FilePath, GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if ( hfile != INVALID_HANDLE_VALUE )
        {
            DWORD FileSize;
            //
            // Find out how big this screen is, if bigger than 0xFFFFFFFF we won't
            // display it.
            //
            FileSize = GetFileSize( hfile, NULL );
            if ( FileSize != 0xFFFFffff )
            {
                DWORD dwRead = 0;

                //
                // This might be non-NULL if we looped back to GrabAnotherScreen.
                //
                if (RspMessage != NULL) {
                    BinlFreeMemory(RspMessage);
                }
                RspMessage = BinlAllocateMemory( FileSize + RspBinaryDataLength + 3 );
                if ( RspMessage == NULL )
                {
                    Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
                }
                else
                {
                    RspMessageLength = 0;
                    RspMessage[0] = '\0';

                    while ( dwRead != FileSize )
                    {
                        BOOL b;
                        DWORD dw;
                        b = ReadFile( hfile, &RspMessage[dwRead], FileSize - dwRead, &dw, NULL );
                        if (!b)
                        {
                            BinlPrint(( DEBUG_OSC_ERROR, "Error reading screen file: Seek=%u, Size=%u, File=%ws\n",
                                        dwRead, FileSize - dwRead, FilePath ));
                            Error = GetLastError( );
                            break;
                        }
                        dwRead += dw;
                    }

                    RspMessageLength = FileSize + 1;
                    RspMessage[RspMessageLength - 1] = '\0';
                }
            }
            else
            {
                BinlPrintDbg((DEBUG_OSC, "!!Error - Could not determine file size.\n"));
                Error = GetLastError();
            }

            CloseHandle( hfile );
        }
        else
        {
            BinlPrint((DEBUG_OSC, "!!Error - Did not find screen file: '%ws'\n", FilePath));
            Error = GetLastError();
            OscAddVariableW( clientState, "SUBERROR", FilePath );
        }
    }

    //
    // Check the outgoing screen for special NAMEs
    //
    if ( Error == ERROR_SUCCESS )
    {
        //
        // Read the screen name from the "NAME" section of the file. This allows
        // the admin to have different screens with the same "NAME" section but
        // that have a different layout and/or text associated with them.
        //
        PCHAR ServerMeta = RspMessage;
        while ( ServerMeta && !!*ServerMeta )
        {
            CHAR tmpCh = '>';   // save (default)
            LPSTR EndofLine;
            ServerMeta = StrStrIA( ServerMeta, "<META " );
            if ( !ServerMeta ) {
                break;
            }
            // Find the end of the meta line
            EndofLine = strchr( ServerMeta, '>' );
            if ( !EndofLine ) {
                break;
            }
            *EndofLine = '\0';  // terminate

            // Is it a server side meta?
            ServerMeta = StrStrIA( ServerMeta, "SERVER" );
            if ( !ServerMeta ) {
                goto SkipLine;  // nope, skip it
            }
            // Find the action
            ServerMeta = StrStrIA( ServerMeta, "ACTION=" );
            if ( !ServerMeta ) {
                goto SkipLine;  // nothing to do, skip it
            }
            ServerMeta += sizeof("ACTION=") - sizeof("");

            // If the ACTION encapsulated in a pair of quotes, the only use
            // the part that is within the quotes.
            if ( *ServerMeta == '\"' ) {
                *EndofLine = '>';   // restore
                ServerMeta++;
                EndofLine = strchr( ServerMeta, '\"' );
                if ( EndofLine ) {
                    tmpCh = '\"';   // save
                } else {
                    EndofLine = strchr( ServerMeta, '>' );
                    if (!EndofLine) {
                        Error = ERROR_INVALID_PARAMETER;
                        goto SendResponse;
                    }
                }
                *EndofLine = '\0';  // terminate
            }

            BinlPrintDbg(( DEBUG_OSC, "Processing SERVER side ACTION: %s\n", ServerMeta ));

            if ( StrCmpNIA( ServerMeta, "ENUM ", sizeof("ENUM ")-sizeof("") ) == 0 )
            {
                PCHAR pOptionBuffer;
                ULONG OptionBufferLength;
                PCHAR pOptionBufferTemp;
                ULONG OptionBufferLengthTemp;
                PCHAR pCurOptionBuffer;
                PCHAR pDirToEnum;
                CHAR SaveChar;

                //
                // They are asking for the screen that has the listing
                // of the different types of network booted installations.
                //
                ServerMeta += sizeof("ENUM ") - sizeof("");

                OscResetVariable( clientState, "OPTIONS" );

                while (*ServerMeta != '\0') {

                    //
                    // Skip leading blanks
                    //
                    while (*ServerMeta == ' ') {
                        ServerMeta++;
                    }

                    if (*ServerMeta == '\0') {
                        break;
                    }

                    //
                    // Save beginning of the dir
                    //
                    pDirToEnum = ServerMeta;

                    //
                    // Skip to the end of the word
                    //
                    while ((*ServerMeta != ' ') &&
                           (*ServerMeta != '\"') &&
                           (*ServerMeta != '>') &&
                           (*ServerMeta != '\0')){
                        ServerMeta++;
                    }

                    //
                    // Temporarily terminate the word, we will restore it in this loop.
                    //
                    SaveChar = *ServerMeta;
                    *ServerMeta = '\0';

                    BinlPrintDbg(( DEBUG_OSC, "Processing SERVER side ACTION: ENUM, directory %s\n", pDirToEnum));

                    //
                    // Start a buffer for this directory
                    //
                    OptionBufferLengthTemp = 512;
                    pOptionBufferTemp = BinlAllocateMemory( OptionBufferLengthTemp );

                    if ( pOptionBufferTemp == NULL )
                    {
                        OscResetVariable( clientState, "OPTIONS" );
                        *ServerMeta = SaveChar;
                        if (SaveChar != '\0') {
                            ServerMeta++;
                        }
                        break;
                    }

                    BinlAssert(RspBinaryData == NULL);
                    *pOptionBufferTemp = '\0';

                    SearchAndGenerateOSMenu( &pOptionBufferTemp,
                                             &OptionBufferLengthTemp,
                                             pDirToEnum,
                                             clientState
                                           );

                    if (*pOptionBufferTemp == '\0') {
                        BinlFreeMemory( pOptionBufferTemp );
                        *ServerMeta = SaveChar;
                        if (SaveChar != '\0') {
                            ServerMeta++;
                        }
                        continue;
                    }

                    pCurOptionBuffer = OscFindVariableA( clientState, "OPTIONS" );
                    BinlAssert( pCurOptionBuffer != NULL );

                    OptionBufferLength = strlen(pCurOptionBuffer) + sizeof("");

                    pOptionBuffer = BinlAllocateMemory( OptionBufferLength + OptionBufferLengthTemp );

                    if (pOptionBuffer == NULL) {
                        BinlFreeMemory( pOptionBufferTemp );
                        OscResetVariable( clientState, "OPTIONS" );
                        *ServerMeta = SaveChar;
                        if (SaveChar != '\0') {
                            ServerMeta++;
                        }
                        break;
                    }

                    strcpy( pOptionBuffer, pCurOptionBuffer );
                    strcat( pOptionBuffer, pOptionBufferTemp);

                    OscAddVariableA( clientState, "OPTIONS", pOptionBuffer );

                    BinlFreeMemory( pOptionBuffer );
                    BinlFreeMemory( pOptionBufferTemp );

                    *ServerMeta = SaveChar;
                    if (SaveChar != '\0') {
                        ServerMeta++;
                    }

                }


                //
                // If this generated no options, send down the
                // NOOSES screen.
                //
                pOptionBuffer = OscFindVariableA( clientState, "OPTIONS" );
                if (*pOptionBuffer == '\0') {
                    BinlAssert( sizeof(TmpName) >= sizeof("NOOSES") );
                    strcpy(TmpName, "NOOSES");
                    NameLoc = TmpName;
                    goto GrabAnotherScreen;
                }

            }
            else if ( StrCmpNIA( ServerMeta, "WARNING", sizeof("WARNING")-sizeof("") ) == 0 )
            {
                LPSTR pszSIF = OscFindVariableA( clientState, "SIF" );
                if ( pszSIF )
                {
                    //
                    // lets check if we're repartitioning or not.  if we aren't,
                    // then there's no need to show the warning screen.
                    //
                    CHAR szRepartition[ 64 ];
                    BOOL DoRepartitionWarning = TRUE;

                    GetPrivateProfileStringA( "RemoteInstall",
                                              "Repartition",
                                              "Yes",
                                              szRepartition,
                                              sizeof(szRepartition)/sizeof(szRepartition[0]),
                                              pszSIF );

                    if ( _stricmp( szRepartition, "no") != 0) {
                        LPSTR pszPart;

                        //
                        // check if 'repartition' points to an OSC variable
                        //
                        if (szRepartition[0] = '%' && szRepartition[strlen(szRepartition)-1] == '%') {
                            szRepartition[strlen(szRepartition)-1] = '\0';

                            pszPart= OscFindVariableA( clientState, &szRepartition[1] );
                            if (_stricmp( pszPart, "no") == 0) {
                                DoRepartitionWarning = FALSE;
                            }
                        }
                    } else {
                        DoRepartitionWarning = FALSE;
                    }

                    if ( DoRepartitionWarning == FALSE ) {
                        // skip the warning screen
                        BinlPrintDbg(( DEBUG_OSC, "Repartition == NO. Skipping WARNING screen.\n" ));

                        *EndofLine = '>';   // restore
                        ServerMeta = StrStrIA( RspMessage, "ENTER" );
                        if ( ServerMeta )
                        {
                            ServerMeta = StrStrIA( ServerMeta, "HREF=" );
                            ServerMeta += sizeof("HREF=") - sizeof("");
                            // If the HREF encapsulated in a pair of quotes, the only use
                            // the part that is within the quotes.
                            if ( *ServerMeta == '\"' ) {
                                ServerMeta ++;
                                EndofLine = strchr( ServerMeta, '\"' );
                                if ( !EndofLine) {
                                    EndofLine = strchr( ServerMeta, '>' );
                                }
                                if ( EndofLine ) {
                                    *EndofLine = '\0';  // terminate
                                }
                            }
                            NameLoc = ServerMeta;
                            goto GrabAnotherScreen;
                        }
                    }
                }
            }
            else if ( StrCmpNIA( ServerMeta, "FILTER ", sizeof("FILTER ")-sizeof("") ) == 0 )
            {
                ULONG OptionCount;

                //
                // The options on the form on this screen are supposed
                // to be filtered by looking at the GPO list for this
                // client. This call may modify RspMessageLength, but
                // it will only shorten it.
                //
                // NOTE: We assume that the data we want to modify is after
                // the META SERVER ACTION tag. This assumption shows up in
                // two ways:
                // a) The second parameter to FilterFormOptions is the place
                // to start filtering -- we pass it EndOfLine+1 (that is,
                // the point right after the FILTER name) because
                // we have put a NULL character at EndOfLine. But this means
                // it won't process any of the screen before the META tag.
                // b) FilterFormOptions may remove parts of the message at
                // any place after the "start filtering" location -- so in
                // order for the code below after SkipLine: to still work,
                // we have to assume that the place in the message that
                // EndOfLine points to has not changed.
                //
                OptionCount = FilterFormOptions(
                                 RspMessage,   // start of message
                                 EndofLine+1,  // where we start filtering -- after the FILTER name,
                                               // since that is NULL-terminated.
                                 &RspMessageLength,
                                 ServerMeta + sizeof("FILTER ") - sizeof(""),
                                 clientState);

                //
                // If the result of the filtering is no options, then
                // send down the NOCHOICE screen.
                //

                if (OptionCount == 0) {
                    BinlAssert( sizeof(TmpName) >= sizeof("NOCHOICE") );
                    strcpy(TmpName, "NOCHOICE");
                    NameLoc = TmpName;
                    goto GrabAnotherScreen;
                }
            }
            else if ( StrCmpNIA( ServerMeta, "CHECKGUID ", sizeof("CHECKGUID ")-sizeof("") ) == 0 )
            {
                //
                //  Search the DS for accounts that have this same GUID and
                //  fill in the form with all the dups.  If it's fatal, tell
                //  them so here, otherwise allow them to continue warned.
                //

                PCHAR successScreen;
                PCHAR failureScreen;

                Error = OscCheckMachineDN( clientState );

                //
                // If there are DN warnings, then the text is saved off in
                // %SUBERROR% string.
                //

                ServerMeta += sizeof("CHECKGUID ") - sizeof("");
                successScreen = ServerMeta;
                while (*successScreen == ' ') {
                    successScreen++;
                }

                failureScreen = successScreen;
                while (*failureScreen != ' ' &&
                       *failureScreen != '>' &&
                       *failureScreen != '\0' ) {

                    failureScreen++;
                }
                if (*failureScreen == ' ') {

                    // terminate the success screen name

                    *failureScreen = '\0';
                    failureScreen++;

                    //
                    //  if they neglected to put a second parameter, then they
                    //  must not care about the warning case.
                    //

                    while (*failureScreen == ' ') {
                        failureScreen++;
                    }
                }

                if ((*failureScreen == '>') || (*failureScreen == '\0')) {
                    failureScreen = successScreen;
                }

                if (Error == ERROR_BINL_DUPLICATE_MACHINE_NAME_FOUND) {

                    //
                    //  in the case of failure, we grab the second parameter
                    //  to CHECKGUID as the warning screen.
                    //

                    NameLoc = failureScreen;

                } else if (Error != ERROR_SUCCESS) {

                    goto SendResponse;

                } else {

                    NameLoc = successScreen;
                }

                //
                //  in the case of success, we grab the first parameter
                //  to CHECKGUID as the success screen.
                //

                Error = ERROR_SUCCESS;
                goto GrabAnotherScreen;
            }
            else if ( StrCmpNIA( ServerMeta, "DNRESET", sizeof("DNRESET")-sizeof("") ) == 0 )
            {
                PWCHAR  pMachineName;              // Pointer to Machine Name variable value
                DWORD   rmError;
                
                //
                //  the client went back to select between auto and custom,
                //  therefore we need to reset machineou, machinename,
                //  machinedn, and machinedomain
                //

                //
                // before we reset the machinename in the client state,
                // we need to remove the name from the pending ds name list
                //

                pMachineName = OscFindVariableW( clientState, "MACHINENAME" );

                rmError = RemoveQueuedDSName(pMachineName);

                if (rmError != ERROR_SUCCESS) {

                    BinlPrintDbg(( DEBUG_ERRORS, "DNRESET: RemoveQueuedDSName returned with status: 0x%x\n", rmError));

                    if (rmError == ERROR_NOT_FOUND) {

                        BinlPrintDbg(( DEBUG_ERRORS, "DNRESET: QueuedDSName already removed\n", rmError));

                        rmError = ERROR_SUCCESS;

                    }

                }
                
                clientState->fHaveSetupMachineDN = FALSE;
                OscResetVariable( clientState, "MACHINEOU" );
                OscResetVariable( clientState, "MACHINENAME" );
                OscResetVariable( clientState, "MACHINEDN" );
                OscResetVariable( clientState, "MACHINEDOMAIN" );
                OscResetVariable( clientState, "NETBIOSNAME" );
                OscResetVariable( clientState, "DEFAULTDOMAINOU" );
            
            }
SkipLine:
            *EndofLine = tmpCh;  // restore
            EndofLine++;
            ServerMeta = EndofLine;
        }
    }

SendResponse:
    //
    // If there were any errors, switch to the error screen.
    //
    if ( Error != ERROR_SUCCESS )
    {
        //
        // Send down message about account creation failure.
        //
        if ( RspMessage )
        {
            BinlFreeMemory( RspMessage );
            RspMessage = NULL;  // paranoid
        }
        if ( RspBinaryData )
        {
            BinlFreeMemory( RspBinaryData );
            RspBinaryData = NULL;  // paranoid
        }
        Error = GenerateErrorScreen( &RspMessage,
                                     &RspMessageLength,
                                     Error,
                                     clientState );
        BinlAssert( Error == ERROR_SUCCESS );
        if ( Error != ERROR_SUCCESS )
            goto Cleanup;

        // Don't send this
        RspBinaryDataLength = 0;
    }

    //
    // Make some adjustments to the outgoing screen
    //
    if ( Error == ERROR_SUCCESS )
    {
        if (RspMessage) {

            //
            // Do replacements for dynamic screens
            //
            SearchAndReplace(   clientState->Variables,
                                &RspMessage,
                                clientState->nVariables,
                                RspMessageLength,
                                RspBinaryDataLength);
            RspMessageLength = strlen( RspMessage ) + 1;

            //
            // NULL terminate RspMessage, and copy binary data if any exists.
            //
            RspMessage[RspMessageLength-1] = '\0';

            if (RspBinaryDataLength) {
                memcpy(RspMessage + RspMessageLength, RspBinaryData, RspBinaryDataLength);
                RspMessageLength += RspBinaryDataLength;
            }
        } else {

            //
            // No RspMessage, RspBinaryData must be the entire thing.
            //
            BinlAssert( RspBinaryData );

            RspMessage = RspBinaryData;
            RspBinaryData = NULL;
            RspMessageLength = RspBinaryDataLength;
            RspBinaryDataLength = 0;
        }
    }

    //
    // Send out a signed response
    //
    BinlAssert( RspMessage );
    // BinlPrint((DEBUG_OSC, "Sending Signed:\n%s\n", RspMessage));

#if DBG
    if (OscWatchVariable[0] != '\0') {
        DbgPrint("VALUE OF <%s> IS <%ws>\n", OscWatchVariable, OscFindVariableW(clientState, OscWatchVariable));
    }
#endif

    Error = OscSendSignedMessage( RequestContext, clientState, RspMessage, RspMessageLength );

Cleanup:
    //
    // Free any memory the we allocated for the screen.
    //
    if ( RspMessage ) {
        BinlFreeMemory( RspMessage );
    }
    if ( RspBinaryData ) {
        BinlFreeMemory( RspBinaryData );
    }

    //  Clear the unencrypted buffer to ensure private data is erased.
    ZeroMemory(&signedMessage->SequenceNumber, signedMessage->Length);

    return Error;
}

//
//
//
DWORD
OscProcessSetupRequest(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function processes a request message sent by textmode setup on a client.
    IT IS CALLED WITH clientState->CriticalSection HELD.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

    clientState - The client state for the remote.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    SPUDP_PACKET UNALIGNED * Message = (SPUDP_PACKET UNALIGNED *)RequestContext->ReceiveBuffer;

    PCHAR RspMessage = NULL;

    PSPUDP_PACKET SuccessPacket;
    SPUDP_PACKET ErrorResponsePacket;
    CLIENT_STATE TempClientState;   // used to call UdpSendMessage
    ULONG SuccessPacketLength;

    PNETCARD_RESPONSE_DATABASE pInfEntry = NULL;

    PSP_NETCARD_INFO_REQ pReqData;
    PSP_NETCARD_INFO_RSP pRspData;

    PLIST_ENTRY CopyHead;
    PLIST_ENTRY CopyListEntry;
    PNETCARD_FILECOPY_PARAMETERS cpyParam;
    PWCHAR pTmp;

    TraceFunc("OscProcessSetupRequest( )\n");

    //
    // All clients start with at least one unsigned request. When we get an
    // unsigned request, the client may have rebooted and be asking for a
    // different request with the same sequence number. To avoid having
    // to check for this, we don't bother resending unsigned messages. We
    // do save the incoming sequence number since we use that for sending
    // the response.
    //

    clientState->LastSequenceNumber = Message->SequenceNumber;

    //
    // Get info from the INF file.
    //
    pReqData = (PSP_NETCARD_INFO_REQ)(&(Message->Data[0]));
    Error = NetInfFindNetcardInfo(pReqData->SetupPath,
                                  pReqData->Architecture,
                                  pReqData->Version,
                                  &pReqData->CardInfo,
                                  NULL,
                                  &pInfEntry
                                 );


    if (Error != ERROR_SUCCESS) {

        BinlPrint(( DEBUG_OSC_ERROR, "OscProcessSetupRequest( Card not found ) \n"));

SendErrorResponse:
        BinlPrintDbg(( DEBUG_OSC_ERROR, "OscProcessSetupRequest( ) sending Error response \n"));

        memcpy(ErrorResponsePacket.Signature, NetcardErrorSignature, 4);
        ErrorResponsePacket.Length = sizeof(ULONG) * 2;
        ErrorResponsePacket.RequestType = Message->RequestType;
        ErrorResponsePacket.Status = STATUS_INVALID_PARAMETER;

        TempClientState.LastResponse = (PUCHAR)&ErrorResponsePacket;
        TempClientState.LastResponseLength = 12;

        Error = SendUdpMessage(RequestContext, &TempClientState, FALSE, FALSE);

        goto CleanUp;

    }

    //
    //  We found a match, so construct a response.  We first need to
    //  calculate how big the buffer needs to be.
    //
    CopyHead = &pInfEntry->FileCopyList;

    SuccessPacketLength = sizeof(SP_NETCARD_INFO_RSP) - sizeof(WCHAR); // everything except the data

    SuccessPacketLength += sizeof(WCHAR) * (wcslen(pInfEntry->DriverName) +
                                            wcslen(pInfEntry->InfFileName) + 4);

    CopyListEntry = CopyHead->Flink;
    while (CopyListEntry != CopyHead) {

        cpyParam = (PNETCARD_FILECOPY_PARAMETERS) CONTAINING_RECORD(CopyListEntry,
                                                                    NETCARD_FILECOPY_PARAMETERS,
                                                                    FileCopyListEntry
                                                                   );
        SuccessPacketLength += cpyParam->SourceFile.Length;

        if (cpyParam->SourceFile.Buffer[cpyParam->SourceFile.Length / sizeof(WCHAR)] != UNICODE_NULL) {
            SuccessPacketLength += sizeof(WCHAR);
        }

        if (cpyParam->DestFile.Buffer == NULL) {
            SuccessPacketLength += sizeof(UNICODE_NULL);
        } else {
            SuccessPacketLength += cpyParam->DestFile.Length;
            if (cpyParam->DestFile.Buffer[cpyParam->DestFile.Length / sizeof(WCHAR)] != UNICODE_NULL) {
                SuccessPacketLength += sizeof(WCHAR);
            }

        }

        CopyListEntry = CopyListEntry->Flink;
    }


    //
    // Build response message
    //
    RspMessage = BinlAllocateMemory(SuccessPacketLength);

    if (RspMessage == NULL) {
        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto SendErrorResponse;
    }

    pRspData = (PSP_NETCARD_INFO_RSP)RspMessage;
    pRspData->cFiles = 0;
    pTmp = &(pRspData->MultiSzFiles[0]);

    CopyListEntry = CopyHead->Flink;
    while (CopyListEntry != CopyHead) {

        pRspData->cFiles++;

        cpyParam = (PNETCARD_FILECOPY_PARAMETERS) CONTAINING_RECORD(CopyListEntry,
                                                                    NETCARD_FILECOPY_PARAMETERS,
                                                                    FileCopyListEntry
                                                                   );

        RtlCopyMemory(pTmp, cpyParam->SourceFile.Buffer, cpyParam->SourceFile.Length);
        pTmp = &(pTmp[cpyParam->SourceFile.Length / sizeof(WCHAR)]);

        if (*pTmp != UNICODE_NULL) {

            pTmp++;
            *pTmp = UNICODE_NULL;

        }

        pTmp++;

        if (cpyParam->DestFile.Buffer == NULL) {

            *pTmp = UNICODE_NULL;
            pTmp++;

        } else {

            RtlCopyMemory(pTmp, cpyParam->DestFile.Buffer, cpyParam->DestFile.Length);
            pTmp = &(pTmp[cpyParam->DestFile.Length / sizeof(WCHAR)]);

            if (*pTmp != UNICODE_NULL) {

                pTmp++;
                *pTmp = UNICODE_NULL;

            }

            pTmp++;

        }

        CopyListEntry = CopyListEntry->Flink;
    }

    //
    // Add the driver name and INF file to the list
    //
    wcscpy(pTmp, pInfEntry->DriverName);
    pTmp = pTmp + (wcslen(pTmp) + 1);
    *pTmp = UNICODE_NULL;
    pTmp++;

    wcscpy(pTmp, pInfEntry->InfFileName);
    pTmp = pTmp + (wcslen(pTmp) + 1);
    *pTmp = UNICODE_NULL;
    pTmp++;

    pRspData->cFiles += 2;


    //
    // Send out a response
    //
    BinlAssert(RspMessage);

    Error = OscSendSetupMessage(RequestContext,
                                clientState,
                                Message->RequestType,
                                RspMessage,
                                SuccessPacketLength
                               );

CleanUp:
    //
    // Free any memory the we allocated for the screen.
    //
    if (pInfEntry) {
        NetInfDereferenceNetcardEntry(pInfEntry);
    }
    if (RspMessage) {
        BinlFreeMemory(RspMessage);
    }

    return Error;
}


DWORD
OscProcessLogoff(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function processes a logoff message.
    IT IS CALLED WITH clientState->CriticalSection HELD.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

    clientState - The client state for the remote.

Return Value:

    Windows Error.

--*/
{
    //
    // clientState will already have been removed from the
    // client database. All we need to do is add one to the
    // NegativeRefCount and the client will then be deleted
    // once everyone else is done using it.
    //

    TraceFunc("OscProcessLogoff( )\n");

    ++clientState->NegativeRefCount;

    if (clientState->PositiveRefCount != (clientState->NegativeRefCount+1)) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "Refcount not equal at logoff for %s\n", inet_ntoa(*(struct in_addr *)&(clientState->RemoteIp)) ));
    }

    return ERROR_SUCCESS;

}


DWORD
OscProcessNetcardRequest(
    LPBINL_REQUEST_CONTEXT RequestContext
    )
/*++

Routine Description:

    This function processes requests from clients for information
    about network cards.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

Return Value:

    Windows Error.

--*/
{
    NETCARD_REQUEST_PACKET UNALIGNED * netcardRequestMessage = (NETCARD_REQUEST_PACKET UNALIGNED *)RequestContext->ReceiveBuffer;
    NETCARD_RESPONSE_PACKET ErrorResponsePacket;
    PNETCARD_RESPONSE_PACKET SuccessResponsePacket;
    ULONG SuccessResponsePacketLength;
    CLIENT_STATE TempClientState;   // used to call UdpSendMessage
    PWCHAR driverPath = NULL;
    PWCHAR setupPath = NULL;
    PCHAR ansiSetupPath = NULL;
    ULONG ansiSetupLength;

    DWORD Error;
    ULONG i;
    PNETCARD_RESPONSE_DATABASE pInfEntry = NULL;

    TraceFunc("OscProcessNetcardRequest( )\n");

    if (netcardRequestMessage->Version != OSCPKT_NETCARD_REQUEST_VERSION) {

        Error = STATUS_INVALID_PARAMETER;
        TraceFunc("OscProcessNetcardRequest( Version not correct ) \n");
        goto sendErrorResponse;
    }

    if (RequestContext->ReceiveMessageSize < sizeof(NETCARD_REQUEST_PACKET)) {

        Error = STATUS_INVALID_PARAMETER;
        TraceFunc("OscProcessNetcardRequest( Message too short ) \n");
        goto sendErrorResponse;
    }

    if ((netcardRequestMessage->SetupDirectoryLength >
         RequestContext->ReceiveMessageSize -
            sizeof(NETCARD_REQUEST_PACKET))
            ) {

        Error = STATUS_INVALID_PARAMETER;
        TraceFunc("OscProcessNetcardRequest( setup path length invalid ) \n");
        goto sendErrorResponse;
    }
    ansiSetupLength = netcardRequestMessage->SetupDirectoryLength;

    ansiSetupPath = BinlAllocateMemory( ansiSetupLength + 1 );
    if (ansiSetupPath == NULL) {
        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        TraceFunc("OscProcessNetcardRequest( couldn't allocate temp buffer ) \n");
        goto sendErrorResponse;
    }

    //
    //  convert the setup path to unicode safely
    //

    memcpy( ansiSetupPath,
            &netcardRequestMessage->SetupDirectoryPath[0],
            ansiSetupLength );

    *(ansiSetupPath + ansiSetupLength) = '\0';

    setupPath = (PWCHAR) BinlAllocateMemory( (ansiSetupLength + 1) * sizeof(WCHAR) );
    if (setupPath == NULL) {

        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        TraceFunc("OscProcessNetcardRequest( couldn't allocate setup path buffer ) \n");
        goto sendErrorResponse;
    }

    if (!BinlAnsiToUnicode(ansiSetupPath,setupPath,(USHORT)((ansiSetupLength+1)*sizeof(WCHAR)))) {
        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        TraceFunc("OscProcessNetcardRequest( couldn't convert setup path buffer ) \n");
        BinlFreeMemory( ansiSetupPath );
        goto sendErrorResponse;
    }

    BinlFreeMemory( ansiSetupPath );

    //
    // Make sure this is a PCI card and the client request structure
    // is version 0.
    //
    BinlPrintDbg(( DEBUG_OSC, "Searching %ws for NIC INF...\n", setupPath ));

    Error = NetInfFindNetcardInfo( setupPath,
                                   netcardRequestMessage->Architecture,
                                   netcardRequestMessage->Version,
                                   &netcardRequestMessage->CardInfo,
                                   NULL,
                                   &pInfEntry );

    BinlAssert (pInfEntry != NULL || Error != ERROR_SUCCESS);

    if (Error != ERROR_SUCCESS) {


        BinlPrint(( DEBUG_OSC_ERROR, "OscProcessNetcardRequest( Card not found ) \n"));

sendErrorResponse:
        BinlPrintDbg(( DEBUG_OSC_ERROR, "OscProcessNetcardRequest( ) sending Error response \n"));
        memcpy(ErrorResponsePacket.Signature, NetcardErrorSignature, 4);
        ErrorResponsePacket.Length = sizeof(ULONG);
        ErrorResponsePacket.Status = STATUS_INVALID_PARAMETER;

        TempClientState.LastResponse = (PUCHAR)&ErrorResponsePacket;
        TempClientState.LastResponseLength = 12;

        Error = SendUdpMessage(RequestContext, &TempClientState, FALSE, FALSE);

    } else {

        //
        //  We found a match, so construct a response.  We first need to
        //  calculate how bit the buffer needs to be.
        //

        PLIST_ENTRY registryHead;
        PLIST_ENTRY registryListEntry;
        PNETCARD_REGISTRY_PARAMETERS regParam;
        ULONG registryLength = 0;

        registryHead = &pInfEntry->Registry;

        SuccessResponsePacketLength = sizeof(NETCARD_RESPONSE_PACKET) +
                + (( wcslen( pInfEntry->HardwareId ) + 1 ) * sizeof(WCHAR)) +
                + (( wcslen( pInfEntry->DriverName ) + 1 ) * sizeof(WCHAR)) +
                + (( wcslen( pInfEntry->ServiceName ) + 1 ) * sizeof(WCHAR)) +
                sizeof(WCHAR);      // termination for registry field

        registryListEntry = registryHead->Flink;
        while (registryListEntry != registryHead) {

            //
            //  each entry is a field name, field type (2 = string, 1 = int)
            //  and field value.  All of these are unicode strings terminated
            //  with a unicode null.
            //

            regParam = (PNETCARD_REGISTRY_PARAMETERS) CONTAINING_RECORD(
                                                        registryListEntry,
                                                        NETCARD_REGISTRY_PARAMETERS,
                                                        RegistryListEntry );

            registryLength += regParam->Parameter.Length + 1;
            registryLength += 2; // field type
            registryLength += regParam->Value.Length + 1;

            registryListEntry = registryListEntry->Flink;
        }

        registryLength += sizeof("Description");
        registryLength += 2;    // field type
        registryLength += wcslen( pInfEntry->DriverDescription ) + 1;

        SuccessResponsePacket = (PNETCARD_RESPONSE_PACKET)
                                BinlAllocateMemory(
                                        SuccessResponsePacketLength +
                                        registryLength );

        if (SuccessResponsePacket == NULL) {
            BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not allocate SuccessResponsePacket of %ld bytes\n",
                        SuccessResponsePacketLength + registryLength));
            Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
            goto sendErrorResponse;

        } else {

            PWCHAR nextWideField;
            PCHAR nextField;
            PCHAR startOfRegistry;
            ANSI_STRING aString;
            UNICODE_STRING descriptionString;

            RtlZeroMemory(SuccessResponsePacket,
                            SuccessResponsePacketLength + registryLength);

            memcpy(SuccessResponsePacket->Signature, NetcardResponseSignature, 4);
            SuccessResponsePacket->Status = STATUS_SUCCESS;
            SuccessResponsePacket->Version = OSCPKT_NETCARD_REQUEST_VERSION;

            nextWideField = (PWCHAR)(PCHAR)((PCHAR) &SuccessResponsePacket->RegistryOffset
                                                + sizeof(ULONG));

            wcscpy( nextWideField, pInfEntry->HardwareId );
            SuccessResponsePacket->HardwareIdOffset = (ULONG)((PCHAR) nextWideField - (PCHAR) SuccessResponsePacket);
            nextWideField += wcslen( pInfEntry->HardwareId ) + 1;

            wcscpy( nextWideField, pInfEntry->DriverName );
            SuccessResponsePacket->DriverNameOffset = (ULONG)((PCHAR) nextWideField - (PCHAR) SuccessResponsePacket);
            nextWideField += wcslen( pInfEntry->DriverName ) + 1;

            wcscpy( nextWideField, pInfEntry->ServiceName );
            SuccessResponsePacket->ServiceNameOffset = (ULONG)((PCHAR) nextWideField - (PCHAR) SuccessResponsePacket);
            nextWideField += wcslen( pInfEntry->ServiceName ) + 1;

            SuccessResponsePacket->RegistryOffset = (ULONG)((PCHAR) nextWideField - (PCHAR) SuccessResponsePacket);

            startOfRegistry = nextField = (PCHAR) nextWideField;

            //
            //  the first registry value should be description, otherwise
            //  bad things happen in NDIS on the client.
            //

            strcpy( nextField, "Description" );
            nextField += sizeof("Description");

            //
            //  then copy in the type of the field, int or string
            //

            *(nextField++) = NETCARD_REGISTRY_TYPE_STRING;
            *(nextField++) = '\0';

            //
            //  then copy in the registry value
            //

            RtlInitUnicodeString( &descriptionString, pInfEntry->DriverDescription );

            aString.Buffer = nextField;
            aString.Length = 0;
            aString.MaximumLength = ( descriptionString.Length + 1 ) * sizeof(WCHAR);

            RtlUnicodeStringToAnsiString( &aString,
                                          &descriptionString,
                                          FALSE );
            nextField += aString.Length + 1;

            registryListEntry = registryHead->Flink;
            while (registryListEntry != registryHead) {


                //
                //  each entry is a field name, field type (2 = string, 1 = int)
                //  and field value.  All of these are unicode strings terminated
                //  with a unicode null.
                //

                regParam = (PNETCARD_REGISTRY_PARAMETERS) CONTAINING_RECORD(
                                                            registryListEntry,
                                                            NETCARD_REGISTRY_PARAMETERS,
                                                            RegistryListEntry );

                if (regParam->Parameter.Length > 0) {

                    //
                    //  first copy in the registry value name
                    //

                    aString.Buffer = nextField;
                    aString.Length = 0;
                    aString.MaximumLength = ( regParam->Parameter.Length + 1 ) * sizeof(WCHAR);

                    RtlUnicodeStringToAnsiString( &aString,
                                                  &regParam->Parameter,
                                                  FALSE );

                    nextField += aString.Length + 1;

                    //
                    //  then copy in the type of the field, int or string
                    //

                    *(nextField++) = (UCHAR) regParam->Type;
                    *(nextField++) = '\0';

                    //
                    //  then copy in the registry value
                    //

                    aString.Buffer = nextField;
                    aString.Length = 0;
                    aString.MaximumLength = ( regParam->Value.Length + 1 ) * sizeof(WCHAR);

                    RtlUnicodeStringToAnsiString( &aString,
                                                  &regParam->Value,
                                                  FALSE );
                    nextField += aString.Length + 1;
                }

                registryListEntry = registryListEntry->Flink;
            }

            //
            //  put in extra null terminator for end of registry section
            //

            *nextField = '\0';
            nextField++;

            SuccessResponsePacket->RegistryLength = (ULONG) (nextField - startOfRegistry);
            SuccessResponsePacketLength += SuccessResponsePacket->RegistryLength;

            //
            //  The length field in the packet is set to the length of the
            //  packet starting at the Status field.  If we put in a field
            //  between LENGTH and STATUS, we need to update this code.
            //

            SuccessResponsePacket->Length = (ULONG)((PCHAR) nextField -
                                (PCHAR) &SuccessResponsePacket->Status);

            TempClientState.LastResponse = (PUCHAR)SuccessResponsePacket;
            TempClientState.LastResponseLength = SuccessResponsePacketLength;

            Error = SendUdpMessage(RequestContext, &TempClientState, FALSE, FALSE);

            BinlFreeMemory(SuccessResponsePacket);
        }
    }

    if (pInfEntry) {
        NetInfDereferenceNetcardEntry( pInfEntry );
    }

    if (driverPath) {

        BinlFreeMemory( driverPath );
    }

    if (setupPath) {

        BinlFreeMemory( setupPath );
    }

    return Error;
}



DWORD
OscProcessHalRequest(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function processes requests from clients for taking a
    detected HAL name string and mapping it to a <hal>.dll name
    and then copying that hal to the machine directory.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.
    clientState - contains client state for the remote machine

Return Value:

    Windows Error.

--*/
{
    HAL_REQUEST_PACKET UNALIGNED * halRequestMessage = (HAL_REQUEST_PACKET UNALIGNED *)RequestContext->ReceiveBuffer;
    HAL_RESPONSE_PACKET responsePacket;
    CLIENT_STATE TempClientState;   // used to call UdpSendMessage
    DWORD Error;
    WCHAR MachinePath[MAX_PATH];
    WCHAR SrcPath[MAX_PATH];
    WCHAR DestPath[MAX_PATH];
    WCHAR HalName[MAX_HAL_NAME_LENGTH+1];
    WCHAR HalInfo[MAX_PATH];
    ULONG HalNameLength;
    ULONG len, index;
    BOOL b;
    PMACHINE_INFO pMachineInfo = NULL;
    USHORT SystemArchitecture;
    TraceFunc("OscProcessHalRequest( )\n");

    //
    // Find the length of the HAL name. To avoid overflowing past the
    // end of the received message, check it ourselves.
    //

    HalNameLength = 0;
    while (halRequestMessage->HalName[HalNameLength] != '\0') {
        ++HalNameLength;
        if (HalNameLength >= sizeof(HalName)/sizeof(WCHAR)) {
            Error = ERROR_INVALID_DATA;
            TraceFunc("OscProcessHalRequest( Exit 0 ) \n");
            goto SendResponse;
        }
    }
    ++HalNameLength;  // convert the '\0' also
    if (!BinlAnsiToUnicode(halRequestMessage->HalName,HalName,sizeof(HalName))) {
        Error = ERROR_INVALID_DATA;
        TraceFunc("OscProcessHalRequest( Exit 0 ) \n");
        goto SendResponse;
    }
                          
    SystemArchitecture = OscPlatformToArchitecture( clientState );

    //
    // Retrieve information from the DS
    //
    Error = GetBootParameters( halRequestMessage->Guid,
                               &pMachineInfo,
                               MI_NAME | MI_SETUPPATH | MI_HOSTNAME,
                               SystemArchitecture,
                               FALSE );
    if (Error != ERROR_SUCCESS) {
        TraceFunc("OscProcessHalRequest( Exit 1 ) \n");
        goto SendResponse;
    }

    //
    // Find the HAL
    //
    //
    // Resulting string should be something like:
    //      "\\ADAMBA4\REMINST\Setup\English\Images\NTWKS5.0\i386\txtsetup.sif"
    if ( _snwprintf( SrcPath,
                     sizeof(SrcPath) / sizeof(SrcPath[0]),
                     L"%ws\\txtsetup.sif",
                     pMachineInfo->SetupPath
                     ) < 0 ) {
        Error = ERROR_BAD_PATHNAME;
        goto SendResponse;
    }
    SrcPath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe

    len = GetPrivateProfileString(L"hal",
                                  HalName,
                                  L"",
                                  HalInfo,
                                  sizeof(HalInfo)/sizeof(HalInfo[0]),
                                  SrcPath
                                  );
    if (len == 0) {
        TraceFunc("OscProcessHalRequest( Exit 3 ) \n");
        goto SendResponse;
    }

    //
    // Parse the response which should be in the form:
    // "newhal.dll,2,hal.dll"
    //
    index = 0;
    while ( HalInfo[index] )
    {
        if (HalInfo[index] == L' ' || HalInfo[index] == L',' )
            break;

        index++;
    }

    HalInfo[index] = L'\0';
    if (HalInfo[0] == L'\0' ) {
        Error = ERROR_BINL_HAL_NOT_FOUND;
        goto SendResponse;
    }

    //
    // Copy the HAL to the machine directory
    //

    if ( _snwprintf( SrcPath,
                     sizeof(SrcPath) / sizeof(SrcPath[0]),
                     L"%ws\\%ws",
                     pMachineInfo->SetupPath,
                     HalInfo
                     ) < 0 ) {
        Error = ERROR_BAD_PATHNAME;
        goto SendResponse;
    }
    SrcPath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe

    if ( _snwprintf( DestPath,
                     sizeof(DestPath) / sizeof(DestPath[0]),
                     L"%ws\\winnt\\system32\\hal.dll",
                     MachinePath
                     ) < 0 ) {
        Error = ERROR_BAD_PATHNAME;
        goto SendResponse;
    }
    DestPath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe

    BinlPrintDbg((DEBUG_OSC, "Copying %ws to %ws...\n", SrcPath, DestPath));

    b = CopyFile( SrcPath, DestPath, FALSE );

    if (!b) {
        Error = ERROR_BINL_HAL_NOT_FOUND;
        TraceFunc("OscProcessHalRequest( Exit 4 ) \n");
        goto SendResponse;
    }

    //
    // Find which kernel to copy
    //

    index = wcslen(HalName);
    while (index > 0) {
        index--;
        if (HalName[index] == L'_') {
            index++;
            break;
        }
    }

    if ((index == 0) || (index == wcslen(HalName))) {
        Error = ERROR_SERVER_KERNEL_NOT_FOUND;
        goto SendResponse;
    }

    //
    // Copy that too
    //
    if ((HalName[index] == L'u') ||
        (HalName[index] == L'U')) {
        if ( _snwprintf( SrcPath,
                         sizeof(SrcPath) / sizeof(SrcPath[0]),
                         L"%ws\\ntoskrnl.exe",
                         pMachineInfo->SetupPath
                         ) < 0 ) {
            Error = ERROR_BAD_PATHNAME;
            goto SendResponse;
        }
        SrcPath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe
    } else {
        if ( _snwprintf( SrcPath,
                         sizeof(SrcPath) / sizeof(SrcPath[0]),
                         L"%ws\\ntkrnlmp.exe",
                         pMachineInfo->SetupPath
                         ) < 0 ) {
            Error = ERROR_BAD_PATHNAME;
            goto SendResponse;
        }
        SrcPath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe
    }

    if ( _snwprintf( DestPath,
                     sizeof(DestPath) / sizeof(DestPath[0]),
                     L"%ws\\winnt\\system32\\ntoskrnl.exe",
                     MachinePath
                     ) < 0 ) {
        Error = ERROR_BAD_PATHNAME;
        goto SendResponse;
    }
    DestPath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe

    BinlPrintDbg((DEBUG_OSC, "Copying %ws to %ws...\n", SrcPath, DestPath));

    b = CopyFile( SrcPath, DestPath, FALSE );

    if (!b) {
        Error = ERROR_SERVER_KERNEL_NOT_FOUND;
        TraceFunc("OscProcessHalRequest( Exit 5 ) \n");
        goto SendResponse;
    }

    Error = ERROR_SUCCESS;
    TraceFunc("OscProcessHalRequest( SUCCESS ) \n");

SendResponse:
    if ( pMachineInfo ) {
        BinlDoneWithCacheEntry( pMachineInfo, FALSE );
    }

    memcpy(responsePacket.Signature, HalResponseSignature, 4);
    responsePacket.Length = sizeof(ULONG);
    responsePacket.Status = (Error == ERROR_SUCCESS) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
    TempClientState.LastResponse = (PUCHAR)&responsePacket;
    TempClientState.LastResponseLength = sizeof(responsePacket);

    Error = SendUdpMessage(RequestContext, &TempClientState, FALSE, FALSE);
    return Error;
}


//
// Process WINNT.SIF file for the client setup
//
DWORD
OscProcessSifFile(
    PCLIENT_STATE clientState,
    LPWSTR TemplateFile,
    LPWSTR WinntSifPath )
{
    DWORD  dwErr = ERROR_SUCCESS;
    DWORD  len;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    SECURITY_ATTRIBUTES SecurityAttributes;
    EXPLICIT_ACCESS ExplicitAccessList[2];
    PACL pAcl;
    PSID pSid;
    PWCHAR pszUserName;
    PWCHAR pszDomainName;
    WCHAR UniqueUdbPath[ MAX_PATH ];  // ie "D:\RemoteInstall\Setup\English\Images\NT50.WKS\i386\Templates\unique.udb"
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
    PSECURITY_DESCRIPTOR pSd;

    TraceFunc("OscProcessSifFile( )\n");

    //
    // Impersonate while opening the file, in case the administrator messed
    // up and didn't give local system permission.
    //

    dwErr = OscImpersonate(clientState);
    if (dwErr == ERROR_SUCCESS) {

        LPWSTR uniqueUdbId = OscFindVariableW( clientState, "UNIQUEUDBID" );

        if (uniqueUdbId[0] != L'\0') {

            //
            // See if a unique.udb file name was specified in the template file.
            // The default name is "unique.udb".
            //
            len = GetPrivateProfileStringW(OSCHOOSER_SIF_SECTIONW,
                                           L"UniqueUdbFile",
                                           L"unique.udb",  // default
                                           UniqueUdbPath,
                                           sizeof(UniqueUdbPath)/sizeof(UniqueUdbPath[0]),
                                           TemplateFile
                                          );

            if (len == 0) {
                UniqueUdbPath[0] = L'\0';  // means not to process it
            } else {
                //
                // Prepend the path to our template file to UniqueUdbPath.
                //
                PWCHAR EndOfTemplatePath = wcsrchr(TemplateFile, L'\\');
                if (EndOfTemplatePath != NULL) {
                    DWORD PathLength = (DWORD)(EndOfTemplatePath - TemplateFile + 1);
                    DWORD FileNameLength = wcslen(UniqueUdbPath) + 1;
                    if (PathLength + FileNameLength <= MAX_PATH) {
                        memmove(UniqueUdbPath + PathLength, UniqueUdbPath, FileNameLength * sizeof(WCHAR));
                        memmove(UniqueUdbPath, TemplateFile, PathLength * sizeof(WCHAR));
                    }
                }
            }
        }

        //
        // Open the template file
        //
        hFile = CreateFile( TemplateFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,                   // security attribs
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,  // maybe FILE_ATTRIBUTE_HIDDEN(?)
                            NULL );                 // template

        OscRevert(clientState);

        if ( hFile != INVALID_HANDLE_VALUE )
        {
            DWORD dwFileSize = GetFileSize( hFile, NULL );
            if ( dwFileSize != -1 )
            {
                DWORD dw;
                LPSTR pBuffer = BinlAllocateMemory( dwFileSize + 1);   // SIF file buffer
                //
                // Read the file in
                //
                if ( pBuffer && 
                     ReadFile( hFile, pBuffer, dwFileSize, &dw, NULL ) ) {
                    
                    CloseHandle( hFile );

                    pBuffer[ dwFileSize ] = '\0'; // terminate

                    //
                    // Process the unique.udb overlay. We change the
                    // in-memory version of the file in pBuffer. NOTE
                    // we do this before calling SearchAndReplace in
                    // case unique.udb has any variables in it, or
                    // has a hard-coded value for something that it
                    // normally a variable in the file.
                    //
                    if ((uniqueUdbId[0] != L'\0') &&
                        (UniqueUdbPath[0] != L'\0')) {
                        ProcessUniqueUdb( &pBuffer,
                                          dwFileSize + 1,
                                          UniqueUdbPath,
                                          uniqueUdbId );
                        dwFileSize = strlen( pBuffer );
                    }

                    //
                    // search and replace defined macros
                    //
                    SearchAndReplace(   clientState->Variables,
                                        &pBuffer,
                                        clientState->nVariables,
                                        dwFileSize + 1,
                                        0 );

                    dwFileSize = strlen( pBuffer );

                    //
                    // HACK:
                    // If there is a line 'FullName = " "' in the SIF, get rid
                    // of the space in the quotes. This deals with the case
                    // where the template SIF had something like:
                    //    FullName = "%USERFIRSTNAME% %USERLASTNAME%"
                    // and OscGetUserDetails() was unable to get the necessary
                    // user information from the DS. If we leave the space in
                    // there, setup won't prompt for the user name.
                    //

#define BLANK_FULL_NAME "FullName = \" \"\r\n"
                    {
                        LPSTR p = pBuffer;
                        while ( *p != 0 ) {
                            if ( StrCmpNIA( p, BLANK_FULL_NAME, strlen(BLANK_FULL_NAME) ) == 0 ) {
                                p = p + strlen(BLANK_FULL_NAME) - 4;
                                memmove( p, p+1, dwFileSize - (p - pBuffer) ); // move terminator too
                                dwFileSize--;
                                break;
                            }
                            while ( (*p != 0) && (*p != '\r') && (*p != '\n') ) {
                                p++;
                            }
                            while ( (*p != 0) && ((*p == '\r') || (*p == '\n')) ) {
                                p++;
                            }
                        }
                    }

                    //
                    // Setup the ACL for this file, first is to grant admins all rights.
                    //
                    if (!AllocateAndInitializeSid(&SidAuthority,
                                                  2,
                                                  SECURITY_BUILTIN_DOMAIN_RID,
                                                  DOMAIN_ALIAS_RID_ADMINS,
                                                  0, 0, 0, 0, 0, 0,
                                                  &pSid
                                                 )) {

                        OscCreateWin32SubError( clientState, GetLastError( ) );
                        dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
                        BinlFreeMemory(pBuffer);
                        return dwErr;

                    }

                    ExplicitAccessList[0].grfAccessMode = SET_ACCESS;
                    ExplicitAccessList[0].grfAccessPermissions = GENERIC_READ | GENERIC_WRITE | DELETE;
                    ExplicitAccessList[0].grfInheritance = NO_INHERITANCE;
                    ExplicitAccessList[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
                    ExplicitAccessList[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
                    ExplicitAccessList[0].Trustee.ptstrName = pSid;

                    //
                    // Now grant the user all rights.
                    //
                    pszUserName = OscFindVariableW(clientState, "USERNAME");
                    pszDomainName = OscFindVariableW(clientState, "USERDOMAIN");

                    if (pszUserName[0] == L'\0') {
                        dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
                        FreeSid(pSid);
                        BinlFreeMemory(pBuffer);
                        return dwErr;
                    }

                    if (pszDomainName[0] != L'\0') {
                        swprintf(UniqueUdbPath, L"%s\\", pszDomainName);
                    } else {
                        UniqueUdbPath[0] = L'\0';
                    }
                    wcscat(UniqueUdbPath, pszUserName);

                    ExplicitAccessList[1].grfAccessMode = SET_ACCESS;
                    ExplicitAccessList[1].grfAccessPermissions = GENERIC_READ | GENERIC_WRITE | DELETE;
                    ExplicitAccessList[1].grfInheritance = NO_INHERITANCE;
                    ExplicitAccessList[1].Trustee.TrusteeType = TRUSTEE_IS_USER;
                    ExplicitAccessList[1].Trustee.TrusteeForm = TRUSTEE_IS_NAME;
                    ExplicitAccessList[1].Trustee.ptstrName = UniqueUdbPath;

                    //
                    // Create an ACL with these two.
                    //
                    dwErr = SetEntriesInAcl(2, ExplicitAccessList, NULL, &pAcl);

                    if (dwErr != ERROR_SUCCESS) {
                        OscCreateWin32SubError( clientState, GetLastError( ) );
                        dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
                        FreeSid(pSid);
                        BinlFreeMemory(pBuffer);
                        return dwErr;
                    }

                    //
                    // Create an SD for this ACL
                    //
                    pSd = BinlAllocateMemory(SECURITY_DESCRIPTOR_MIN_LENGTH);

                    if (pSd == NULL) {
                        dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
                        FreeSid(pSid);
                        BinlFreeMemory(pBuffer);
                        return dwErr;
                    }

                    if (!InitializeSecurityDescriptor(pSd, SECURITY_DESCRIPTOR_REVISION) ||
                        !SetSecurityDescriptorDacl(pSd, TRUE, pAcl, FALSE)) {

                        OscCreateWin32SubError( clientState, GetLastError( ) );
                        dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
                        BinlFreeMemory(pSd);
                        FreeSid(pSid);
                        BinlFreeMemory(pBuffer);
                        return dwErr;

                    }

                    SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
                    SecurityAttributes.lpSecurityDescriptor = pSd;
                    SecurityAttributes.bInheritHandle = FALSE;

                    //
                    // Create the destination file
                    //
                    hFile = CreateFile( WinntSifPath,
                                        GENERIC_WRITE | GENERIC_READ | DELETE,
                                        FILE_SHARE_READ,
                                        &SecurityAttributes,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL );                 // template

                    BinlFreeMemory(pSd);
                    FreeSid(pSid);
                    LocalFree(pAcl);

                    if ( hFile != INVALID_HANDLE_VALUE )
                    {
                        //
                        // Write it all at once
                        //
                        if (!WriteFile( hFile, pBuffer, dwFileSize, &dw, NULL )) {
                            OscCreateWin32SubError( clientState, GetLastError( ) );
                            dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
                        }

                        CloseHandle( hFile );
                    }
                    else
                    {
                        OscCreateWin32SubError( clientState, GetLastError( ) );
                        dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
                    }

                    BinlFreeMemory(pBuffer);

                } else {
                    CloseHandle( hFile );
                    OscCreateWin32SubError( clientState, GetLastError( ) );
                    dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
                }

            } else {
                CloseHandle( hFile );
                OscCreateWin32SubError( clientState, ERROR_INVALID_DATA );
                dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
            }
        } else {
            OscCreateWin32SubError( clientState, GetLastError() );
            dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
        }
    }
    else {
        OscCreateWin32SubError( clientState, dwErr );
        dwErr = ERROR_BINL_FAILED_TO_CREATE_TEMP_SIF;
    }

    return dwErr;
}

//
// Creates the client image directory, copy the files needed to run
// launch text mode setup, munges Winnt.Sif, more...
//
DWORD
OscSetupClient(
    PCLIENT_STATE clientState,
    BOOLEAN ErrorDuplicateName
    )
{
    DWORD    dwErr = ERROR_SUCCESS;
    WCHAR    SetupPath[ MAX_PATH ];     // ie "D:\RemoteInstall\Setup\English\Images\NT50.WKS\i386"
    PWCHAR   pTemplatePath;             // ie "D:\RemoteInstall\Setup\English\Images\NT50.WKS\i386\Templates\RemBoot.SIF"
    WCHAR    WinntSifPath[ MAX_PATH ];  // ie "D:\RemoteInstall\Clients\NP00805F7F4C85$\winnt.sif"
    PWCHAR   pwc;                       // parsing pointer
    WCHAR    wch;                       // temp wide char
    PWCHAR   pMachineName;              // Pointer to Machine Name variable value
    PWCHAR   pMachineOU;                // Pointer to where the MAO will be created
    PWCHAR   pDomain;                   // Pointer to Domain variable name
    PWCHAR   pGuid;                     // Pointer to Guid variable name
    WCHAR    Path[MAX_PATH];            // general purpose path buffer
    WCHAR    TmpPath[MAX_PATH];         // general purpose path buffer
    ULONG    lenIntelliMirror;          // Lenght of IntelliMirrorPath (eg "D:\RemoteInstall")
    HANDLE   hDir;                      // Directory handle
    ULONG    i;                         // general counter
    BOOL     b;                         // general purpose BOOLean.
    BOOLEAN  ExactMatch;
    UINT     uSize;
    LARGE_INTEGER KernelVersion;
    WCHAR    VersionString[20];
    PCHAR    pszGuid;
    UCHAR    Guid[ BINL_GUID_LENGTH ];
    USHORT   SystemArchitecture;
    PMACHINE_INFO pMachineInfo = NULL;

    TraceFunc("OscSetupClient( )\n");

    lenIntelliMirror = wcslen(IntelliMirrorPathW) + 1;

    dwErr = OscCheckMachineDN( clientState );

    if ((dwErr == ERROR_BINL_DUPLICATE_MACHINE_NAME_FOUND) && !ErrorDuplicateName) {
        dwErr = ERROR_SUCCESS;
    }

    if (dwErr != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "OscCheckMachineDN returned 0x%x\n", dwErr ));
        goto e0;
    }

    //
    // Get the machine GUID and get any overriding parameters.
    //
    pszGuid = OscFindVariableA( clientState, "GUID" );
    if ( pszGuid[0] == '\0' ) {
        BinlPrintDbg((DEBUG_OSC_ERROR, "OscSetupClient: could not find GUID" ));
        OscAddVariableA( clientState, "SUBERROR", "GUID" );
        dwErr = ERROR_BINL_MISSING_VARIABLE;
        goto e0;
    }

    pGuid = OscFindVariableW( clientState, "GUID" );
    if ( pGuid[0] == L'\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "GUID" );
        dwErr = ERROR_BINL_MISSING_VARIABLE;
        goto e0;
    }

    dwErr = OscGuidToBytes( pszGuid, Guid );
    if ( dwErr != ERROR_SUCCESS ) {
        BinlPrintDbg((DEBUG_OSC_ERROR, "OscSetupClient: OscGuidToBytes failed\n" ));
        goto e0;
    }

    SystemArchitecture = OscPlatformToArchitecture(clientState);

    dwErr = GetBootParameters( Guid,
                               &pMachineInfo,
                               MI_SIFFILENAME_ALLOC,
                               SystemArchitecture,
                               FALSE );

    if ( dwErr == ERROR_SUCCESS ) {
        //
        // Set default values
        //
        if (pMachineInfo->dwFlags & MI_SIFFILENAME_ALLOC) {

            dwErr = OscAddVariableW( clientState, "FORCESIFFILE",  pMachineInfo->ForcedSifFileName );
            if ( dwErr != ERROR_SUCCESS ) {
                goto e0;
            }

        }
    }

    //
    // Get SIF File name.
    //
    pTemplatePath = OscFindVariableW( clientState, "SIF" );

    if ( pTemplatePath[0] == L'\0' ) {
        BinlPrint(( DEBUG_OSC_ERROR, "Missing SIF variable\n" ));
        OscAddVariableA( clientState, "SUBERROR", "SIF" );
        dwErr = ERROR_BINL_MISSING_VARIABLE;
        goto e0;
    }

    //
    // validate the machine name.  Note the extra check for a
    // period that DnsValidateDnsName_W won't catch for us.
    //
    pMachineName  = OscFindVariableW( clientState, "MACHINENAME" );
    if ( pMachineName[0] == L'\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "MACHINENAME" );
        dwErr = ERROR_BINL_MISSING_VARIABLE;
        goto e0;
    } else if ( DnsValidateDnsName_W( pMachineName ) != ERROR_SUCCESS ) {
        dwErr = ERROR_BINL_INVALID_MACHINE_NAME;
        OscAddVariableA( clientState, "SUBERROR", " " );
        goto e0;
    } else if ( StrStrI( pMachineName,L".")) {
        dwErr = ERROR_BINL_INVALID_MACHINE_NAME;
        OscAddVariableA( clientState, "SUBERROR", " " );
        goto e0;
    }

    pMachineOU = OscFindVariableW( clientState, "MACHINEOU" );
    if ( pMachineOU[0] == L'\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "MACHINEOU" );
        dwErr = ERROR_BINL_MISSING_VARIABLE;
        goto e0;
    }

    // Do we have a domain yet?
    pDomain = OscFindVariableW( clientState, "MACHINEDOMAIN" );
    if ( pDomain[0] == L'\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "MACHINEDOMAIN" );
        dwErr = ERROR_BINL_MISSING_VARIABLE;
        goto e0;
    }

    if (OscSifIsSysPrep(pTemplatePath)) {
        DWORD SysPrepSku;

        //
        // Get the system path from the SIF file
        //
        dwErr = GetPrivateProfileStringW(OSCHOOSER_SIF_SECTIONW,
                                         L"SysPrepSystemRoot",
                                         L"",
                                         TmpPath,
                                         sizeof(TmpPath)/sizeof(TmpPath[0]),
                                         pTemplatePath
                                        );

        if (dwErr == 0) {
            dwErr  = ERROR_BINL_CD_IMAGE_NOT_FOUND;
            goto e0;
        }

        SysPrepSku = GetPrivateProfileInt(
                              OSCHOOSER_SIF_SECTIONW,
                              L"ProductType",
                              0,
                              pTemplatePath );

        //
        // Get the root of the mirror directory from the template path.
        //
        // pTemplatePath looks like
        // "D:\RemoteInstall\Setup\English\Images\NT50.Prep\i386\templates\riprep.sif",
        // truncate it temporarily to
        // "D:\RemoteInstall\Setup\English\Images\NT50.Prep\i386"
        // by NULLing out the second-to-last '\'.
        //
        pwc = pTemplatePath + wcslen( pTemplatePath );
        for ( i = 0; i < 2; i++ )
        {
            while ( pwc > pTemplatePath && *pwc != L'\\' )
                pwc--;
            pwc--;
        }
        pwc++;
        wch = *pwc;                         // remember
        *pwc = L'\0';                       // terminate

        //
        // Now make Path be something like
        // "D:\RemoteInstall\Setup\English\Images\NT50.Prep\i386\Mirror1\UserData\WINNT\system32"
        // which is where the ntoskrnl.exe whose version we want is located.
        //
        // Make sure there is room for pTemplatePath + "\" (1 byte) +
        // TmpPath + "\system32" (9 bytes) + '\0' (1 byte).
        //

        if (wcslen(pTemplatePath) + wcslen(TmpPath) + 11 > sizeof(Path)/sizeof(Path[0])) {
            dwErr = ERROR_BAD_PATHNAME;
            goto e0;
        }

        wcscpy(Path, pTemplatePath);
        wcscat(Path, L"\\");
        wcscat(Path, TmpPath);
        wcscat(Path, L"\\system32");

        //
        //  For NT 5.0, we'll bomb out if it's not an exact match.
        //

        if (!OscGetClosestNt(
                        Path,
                        SysPrepSku,
                        clientState,
                        SetupPath,
                        sizeof(SetupPath)/sizeof(WCHAR),
                        &ExactMatch) ||
            ( ExactMatch == FALSE ))  {
            dwErr  = ERROR_BINL_CD_IMAGE_NOT_FOUND;
            goto e0;
        }

        //
        // SetupPath comes back as a path like
        // "D:\RemoteInstall\Setup\English\Images\nt5.0\i386",
        // If there was an exact match, we want SYSPREPDRIVERS to just be
        // "Setup\English\Images\nt5.0\i386"
        // otherwise we want it to be blank.
        //

        if (ExactMatch) {
            OscAddVariableW(clientState, "SYSPREPDRIVERS", &(SetupPath[lenIntelliMirror]));
        } else {
            OscAddVariableW(clientState, "SYSPREPDRIVERS", L"");
        }

        //
        // SYSPREPPATH will be the truncated pTemplatePath, without the
        // local path at the front, something like
        // "Setup\English\Images\NT50.Prep\i386".
        //

        OscAddVariableW(clientState, "SYSPREPPATH", &pTemplatePath[lenIntelliMirror]);

        //
        // Now restore pTemplatePath to what it was originally.
        //

        *pwc = wch;

        dwErr = ERROR_SUCCESS;

    } else {

        //
        // create the setup path to the workstation installation by stripping off
        // the SIF filename. We'll search backwards for the first 2nd "\".
        //
        // "D:\RemoteInstall\Setup\English\NetBootOs\NT50.WKS\i386"
        pwc = pTemplatePath + wcslen( pTemplatePath );
        for ( i = 0; i < 2; i++ )
        {
            while ( pwc > pTemplatePath && *pwc != L'\\' )
                pwc--;
            pwc--;
        }
        pwc++;
        wch = *pwc;                         // remember
        *pwc = L'\0';                       // terminate
        wcscpy( SetupPath, pTemplatePath ); // copy
        *pwc = wch;                         // restore

    }

    //
    // Figure out the INSTALLPATH. This is the SetupPath minus the
    // "D:\RemoteInstall" and should be:
    // "Setup\English\Images\NT50.WKS"
    wcscpy( Path, &SetupPath[lenIntelliMirror] );
    Path[ wcslen(Path) - 1
              - strlen( OscFindVariableA( clientState, "MACHINETYPE" ) ) ] = '\0';
    dwErr = OscAddVariableW( clientState, "INSTALLPATH", Path );
    if ( dwErr != ERROR_SUCCESS ) {
        goto e0;
    }

    //
    // record the build and version of the OS we're installing.
    // if it fails, just fall back to NT 5.0.
    //
    if(!OscGetNtVersionInfo((PULONGLONG)&KernelVersion, SetupPath, clientState )) {
        KernelVersion.LowPart = MAKELONG(2195,0);
        KernelVersion.HighPart = MAKELONG(5,0);
    }

    wsprintf(VersionString,L"%d.%d", HIWORD(KernelVersion.HighPart), LOWORD(KernelVersion.HighPart));

    OscAddVariableW( clientState, "IMAGEVERSION", VersionString );

    wsprintf(VersionString,L"%d", HIWORD(KernelVersion.LowPart));

    OscAddVariableW( clientState, "IMAGEBUILD", VersionString );

    //
    // Create the default path to the image
    //
    if ( _snwprintf( Path,
                     sizeof(Path) / sizeof(Path[0]),
                     L"%ws\\%ws\\templates",
                     OscFindVariableW( clientState, "INSTALLPATH" ),
                     OscFindVariableW( clientState, "MACHINETYPE" )
                     ) < 0 ) {
        dwErr = ERROR_BAD_PATHNAME;
        goto e0;
    }
    Path[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe

    //
    // Create destination SIF file path.
    //
    if ( _snwprintf( WinntSifPath,
                     sizeof(WinntSifPath) / sizeof(WinntSifPath[0]),
                     L"%ws\\%ws\\%ws.sif",
                     IntelliMirrorPathW,
                     TEMP_DIRECTORY,
                     pGuid
                     ) < 0 ) {
        dwErr = ERROR_BAD_PATHNAME;
        goto e0;
    }
    WinntSifPath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe

    //
    // Make sure there is a tmp directory below \remoteinstall.
    //

    dwErr = OscCheckTmpDirectory();
    if (dwErr != ERROR_SUCCESS) {
        goto e0;
    }

    //
    // generate a machine password that we'll use in the SIF file and when
    // setting up the MAO
    //
    wcscpy(TmpPath, Path );

    dwErr = OscSetupMachinePassword( clientState, pTemplatePath );
    if (dwErr != ERROR_SUCCESS) {
        goto e0;
    }

    //
    // Copy and process the selected SIF file
    //
    dwErr = OscProcessSifFile( clientState, pTemplatePath, WinntSifPath );
    if ( dwErr != ERROR_SUCCESS ) {
        goto e0;
    }

    //
    // Get the boot file name
    //
    // Make sure there is room for Path + "\startrom.com" + NULL (so
    // use sizeof to include the NULL).
    //
    if (wcslen(Path) + (sizeof(L"\\startrom.com")/sizeof(WCHAR)) > sizeof(Path)/sizeof(Path[0])) {
        dwErr = ERROR_BAD_PATHNAME;
        goto e0;
    }

    //
    // construct default path in case the LaunchFile entry isn't
    // found in the SIF file.
    //
    switch ( SystemArchitecture ) {
        case DHCP_OPTION_CLIENT_ARCHITECTURE_IA64:
            wcscat( Path, L"\\setupldr.efi" );
            break;
        default:
            wcscat( Path, L"\\startrom.com" );      // construct default path
    }

    GetPrivateProfileString( OSCHOOSER_SIF_SECTIONW,
                             L"LaunchFile",
                             Path, // default
                             Path,
                             MAX_PATH,
                             WinntSifPath );
    dwErr = OscAddVariableW( clientState, "BOOTFILE", Path );
    if ( dwErr != ERROR_SUCCESS ) {
        goto e0;
    }

    //
    // Get the SIF file name
    //

    dwErr = OscAddVariableW( clientState, "SIFFILE", &WinntSifPath[lenIntelliMirror] );
    if ( dwErr != ERROR_SUCCESS ) {
        goto e0;
    }

e0:
    if (pMachineInfo != NULL) {
        BinlDoneWithCacheEntry( pMachineInfo, FALSE );
    }

    return dwErr;
}

//
// Undoes whatever permanent things OscSetupClient does.
//
VOID
OscUndoSetupClient(
    PCLIENT_STATE clientState
    )
{
    WCHAR  WinntSifPath[ MAX_PATH ];  // ie "D:\RemoteInstall\tmp\NP00805F7F4C85$.sif"
    PWCHAR pSifFile;
    DWORD  dwErr;

    TraceFunc("OscUndoSetupClient( )\n");

    pSifFile = OscFindVariableW( clientState, "SIFFILE" );
    if ( pSifFile[0] == L'\0' ) {
        return;
    }

    //
    // Create destination SIF file path.
    //
    if ( _snwprintf( WinntSifPath,
                     sizeof(WinntSifPath) / sizeof(WinntSifPath[0]),
                     L"%ws\\%ws",
                     IntelliMirrorPathW,
                     pSifFile
                     ) < 0 ) {
        return;
    }
    WinntSifPath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe

    //
    // Impersonate so that we can get correct permissions to delete the file.
    //
    dwErr = OscImpersonate(clientState);

    if (dwErr == ERROR_SUCCESS) {

        //
        // Delete the template file
        //
        DeleteFile( WinntSifPath );

        OscRevert(clientState);
    }

}


USHORT
OscPlatformToArchitecture(
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    Translates the client architecture string value to a
    DHCP_OPTION_CLIENT_ARCHITECTURE_*** flag.

Arguments:

    ClientState - The client state.  It's assumed that the MACHINETYPE
    OSC variable has been set when you call this function.  This occurs
    after OSCHOICE logs on the user.

Return Value:

    DHCP_OPTION_CLIENT_ARCHITECTURE_*** flag.

--*/
{
    PCWSTR pArch;

    pArch = OscFindVariableW( clientState, "MACHINETYPE");
    if (!pArch) {
        //
        // if we have no architecture, just assume x86
        //
        return DHCP_OPTION_CLIENT_ARCHITECTURE_X86;
    }

    if (_wcsicmp(pArch, L"ia64") == 0) {
        return DHCP_OPTION_CLIENT_ARCHITECTURE_IA64;
    } else if (_wcsicmp(pArch, L"i386") == 0) {
        return DHCP_OPTION_CLIENT_ARCHITECTURE_X86;
    }

    return DHCP_OPTION_CLIENT_ARCHITECTURE_X86;
}

DWORD
OscSetupMachinePassword(
    IN PCLIENT_STATE clientState,
    IN PCWSTR SifFile
    )
/*++

Routine Description:

    Generates and stores the machine password for later use.

Arguments:

    ClientState - The client state.
    SifFile - path to unattend SIF file.

Return Value:

    DWORD Win32Error code indicating status of the operation.

--*/
{
    WCHAR MachinePassword[LM20_PWLEN+1];
    DWORD MachinePasswordLength;
    PWCHAR pMachineName;
    BOOL SecuredJoin;
    PWCHAR pVersion;
    WCHAR Answer[20];

    //
    // Figure out if we should be doing a secure domain join.
    // In Win2K, there is no such thing, so we do the old
    // style domain join with a weaker password.  In all other
    // cases, we use the secure domain join method.
    //
    pVersion = OscFindVariableW( clientState, "IMAGEVERSION" );
    if (pVersion && (wcscmp(pVersion,L"5.0") == 0)) {
        SecuredJoin = FALSE;
    } else {
        if (!GetPrivateProfileString( L"Identification",
                                 L"DoOldStyleDomainJoin",
                                 L"", // default
                                 Answer,
                                 20,
                                 SifFile ) ||
            0 == _wcsicmp(Answer, L"Yes" )) {
            SecuredJoin = FALSE;
        } else {
            SecuredJoin = TRUE;
        }
    }


    //
    // Set up the password. For diskless clients it is the machine name
    // in lowercase, for disked clients we generate a random one, making
    // sure it has no NULLs in it.
    //
    //
    // We have to change the password for DISKED machines, since
    // they will have a random password that we can't query.
    //

    //
    // Windows 2000 machines have to have the "well-known-password"
    // Machine passwords are just the "MachineName" (without the "$")
    //

    if (!SecuredJoin) {

        UINT i;

        pMachineName = OscFindVariableW( clientState, "MACHINENAME" );
        if (!pMachineName) {
            return ERROR_INVALID_DATA;
        }

        memset( MachinePassword, 0, sizeof(MachinePassword) );

        MachinePasswordLength = wcslen( pMachineName ) * sizeof(WCHAR);
        if ( MachinePasswordLength >= (LM20_PWLEN * sizeof(WCHAR)) ) {
            // 
            // make sure the entire password (plus terminator)
            // fit into buffer
            //
            MachinePasswordLength = LM20_PWLEN * sizeof(WCHAR);
        }

        //
        // Lower-case the NT password.
        //
        for (i = 0; i < MachinePasswordLength / sizeof(WCHAR); i++) {
            MachinePassword[i] = towlower(pMachineName[i]);
        }
        MachinePassword[i] = L'\0';

        BinlPrintDbg(( DEBUG_OSC, "Using WKP\n" ));
    } else {

        PUCHAR psz = (PUCHAR) &MachinePassword[0];
        UINT i;

        OscGeneratePassword(MachinePassword, &MachinePasswordLength );

#if 0 && DBG
        BinlPrintDbg(( DEBUG_OSC, "Generated password: " ));
        for ( i = 0; i < MachinePasswordLength / sizeof(WCHAR); i++ ) {
            BinlPrintDbg(( DEBUG_OSC, "x%02x ", psz[i] ));
        }
        BinlPrintDbg(( DEBUG_OSC, "\n" ));
#endif

    }

    RtlCopyMemory(clientState->MachineAccountPassword,MachinePassword, MachinePasswordLength);
    clientState->MachineAccountPasswordLength = MachinePasswordLength;

    //
    // the password always consists of printable characters since it must be
    // substituted into a text file.
    //
    OscAddVariableW( clientState, "MACHINEPASSWORD", clientState->MachineAccountPassword );


    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\client\dhcpcli.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    dhcpcli.h

Abstract:

    Private header file for the client end of the DHCP server service.

Author:

    Madan Appiah (madana) 10-Sep-1993
    Manny Weiser (mannyw) 11-Aug-1992

Revision History:

--*/

//
//  NT public header files
//

#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <rpc.h>

//
//  DHCP public header files
//

#include "dhcp.h"


//
//  Local RPC built files
//

#include "dhcp_cli.h"
#include "dhcp2_cli.h"

ULONG DhcpGlobalTryDownlevel;

#define USE_TCP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\proto.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    proto.h

Abstract:

    This file contain function prototypes for the BINL service.

Author:

    Colin Watson  (colinw)  11-Aug-1997

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

//
// network.c
//

DWORD
BinlWaitForMessage(
    BINL_REQUEST_CONTEXT *pRequestContext
    );

DWORD
BinlSendMessage(
    LPBINL_REQUEST_CONTEXT BinlRequestContext
    );

DHCP_IP_ADDRESS
BinlGetMyNetworkAddress (
    LPBINL_REQUEST_CONTEXT RequestContext
    );

NTSTATUS
GetIpAddressInfo (
    ULONG Delay
    );

VOID
FreeIpAddressInfo (
    VOID
    );

//
// main.c
//

DWORD
ReadDWord(
    HKEY KeyHandle,
    LPTSTR lpValueName,
    DWORD DefaultValue
    );

DWORD
BinlRegGetValue(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    LPBYTE * BufferPtr
    );

DWORD
GetBinlServerParameters(
    BOOL GlobalSearch);

DWORD
BinlInitializeEndpoint(
    PENDPOINT pEndpoint,
    PDHCP_IP_ADDRESS pIpAddress,
    DWORD Port
    );

VOID
SendWakeup(
           PENDPOINT pEndpoint
           );

DWORD
MaybeInitializeEndpoint(
    PENDPOINT pEndpoint,
    PDHCP_IP_ADDRESS pIpAddress,
    DWORD Port
    );

VOID
MaybeCloseEndpoint(
    PENDPOINT pEndpoint
    );

VOID
BinlMessageLoop(
    LPVOID Parameter
    );

DWORD
BinlStartWorkerThread(
    BINL_REQUEST_CONTEXT **ppContext
    );

VOID
BinlProcessingLoop(
    VOID
    );

BOOL
BinlIsProcessMessageExecuting(
    VOID
    );

BOOL
BinlIsProcessMessageBusy(
    VOID
    );

DWORD
Scavenger(
    VOID
    );

VOID
ServiceEntry(
    DWORD NumArgs,
    LPWSTR *ArgsArray,
    IN PTCPSVCS_GLOBAL_DATA pGlobalData
    );

NTSTATUS
BinlSetupPnpWait (
    VOID
    );

// message.c

DWORD
ProcessMessage(
    LPBINL_REQUEST_CONTEXT RequestContext
    );

DWORD
ProcessBinlDiscover(
    LPBINL_REQUEST_CONTEXT RequestContext,
    LPDHCP_SERVER_OPTIONS dhcpOptions
    );

DWORD
ProcessBinlRequest(
    LPBINL_REQUEST_CONTEXT RequestContext,
    LPDHCP_SERVER_OPTIONS dhcpOptions
    );

DWORD
ProcessBinlInform(
    LPBINL_REQUEST_CONTEXT RequestContext,
    LPDHCP_SERVER_OPTIONS  DhcpOptions
);

DWORD
UpdateAccount(
    PCLIENT_STATE ClientState,
    PMACHINE_INFO pMachineInfo,
    BOOL          fCreateAccount
    );

DWORD
GetBootParameters(
    PUCHAR          pGuid,
    PMACHINE_INFO * pMachineInfo,
    DWORD           dwRequestedInfo,
    USHORT          SystemArchitecture,
    BOOL            AllowOSChooser
    );

DWORD
VerifyExistingClient(
    PUCHAR Guid
    );

DWORD
InitializeConnection(
    BOOL Global,
    PLDAP * LdapHandle,
    PWCHAR ** Base);

VOID
HandleLdapFailure(
    DWORD LdapError,
    DWORD EventId,
    BOOL GlobalCatalog,
    PLDAP *LdapHandle,
    BOOL HaveLock
    );

VOID
FreeConnections(
    VOID
    );

DWORD
BinlReportEventW(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPWSTR *Strings,
    LPVOID Data
    );

DWORD
BinlReportEventA(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    );

VOID
BinlLogDuplicateDsRecords (
    LPGUID Guid,
    LDAP *LdapHandle,
    LDAPMessage *LdapMessage,
    LDAPMessage *CurrentEntry
    );

//
// osc.c
//

DWORD
OscUpdatePassword(
    IN PCLIENT_STATE ClientState,
    IN PWCHAR SamAccountName,
    IN PWCHAR Password,
    IN LDAP * LdapHandle,
    IN PLDAPMessage LdapMessage
    );

//
//  Routines for caching the DS responses and to ensure that we don't work on
//  a request that we're already working on.
//

DWORD
BinlCreateOrFindCacheEntry (
    PCHAR Guid,
    BOOLEAN CreateIfNotExist,
    PMACHINE_INFO *CacheEntry
    );

VOID
BinlDoneWithCacheEntry (
    PMACHINE_INFO pMachineInfo,
    BOOLEAN FreeIt
    );

VOID
BinlCloseCache (
    VOID
    );

void
OscCreateLDAPSubError(
    PCLIENT_STATE clientState,
    DWORD Error );


#ifndef DSCRACKNAMES_DNS
DWORD
BinlDNStoFQDN(
    PWCHAR   pMachineName,
    PWCHAR * ppMachineDN );
#endif

DWORD
GetOurServerInfo (
    VOID
    );

//
//  rogue.c
//

NTSTATUS
MaybeStartRogueThread (
    VOID
    );

VOID
StopRogueThread (
    VOID
    );

VOID
HandleRogueAuthorized (
    VOID
    );

VOID
HandleRogueUnauthorized (
    VOID
    );

VOID
LogCurrentRogueState (
    BOOL ResponseToMessage
    );

VOID
LogLdapError (
    ULONG LdapEvent,
    ULONG LdapError,
    PLDAP LdapHandle OPTIONAL
    );

BOOL
BinlAnsiToUnicode(
    IN PSTR AnsiString,
    OUT PWSTR UnicodeBuffer,
    IN USHORT UnicodeBufferSize
    );

BOOL
BinlUnicodeToAnsi(
    IN PWSTR UnicodeString,
    OUT PSTR AnsiBuffer,
    IN USHORT AnsiBufferSize
    );

//
// Create a copy of a string by allocating heap memory.
//
LPSTR
BinlStrDupA( LPCSTR pStr );

LPWSTR
BinlStrDupW( LPCWSTR pStr );

// We should always be UNICODE
#define BinlStrDup BinlStrDupW

#if DBG==1
#define BinlAllocateMemory(x) DebugAlloc( __FILE__, __LINE__, "BINL", LMEM_FIXED | LMEM_ZEROINIT, x, #x)
#define BinlFreeMemory(x)     DebugFree(x)
#else // DBG==0
#define BinlAllocateMemory(x) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, x)
#define BinlFreeMemory(x)     LocalFree(x)
#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\client\makefile.inc ===
obj\$(TARGET_DIRECTORY)\dhcpcmd.res: dhcpcmd.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\rogue.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    rogue.c

Abstract:

    This module contains the rogue detection interface to DHCP for BINL server.

Author:

    Andy Herron (andyhe)  19-Aug-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include "binl.h"
#pragma hdrstop

VOID
BinlRogueLoop(
    LPVOID Parameter
    );

NTSTATUS
MaybeStartRogueThread (
    VOID
    )
//
//  Initiate rogue thread.  The gcsDHCPBINL should not be held by caller.
//
{
    DWORD Error = ERROR_SUCCESS;
    DWORD threadId;

    EnterCriticalSection(&gcsDHCPBINL);

    //
    //  if we're stopping anyway or if we're already running the rogue stuff
    //  or if the DHCP server is up, then we don't bother starting rogue
    //  detection.
    //

    if ((BinlCurrentState == BINL_STOPPED) ||
        (BinlGlobalHaveCalledRogueInit) ||
        (DHCPState != DHCP_STOPPED)) {

        LeaveCriticalSection(&gcsDHCPBINL);
        return ERROR_SUCCESS;
    }

    //
    //  Let's do rogue detection..  first create the events we need
    //

    if (BinlRogueTerminateEventHandle == NULL) {

        BinlRogueTerminateEventHandle = CreateEvent( NULL, FALSE, FALSE, NULL );
    }
    if (RogueUnauthorizedHandle == NULL) {

        RogueUnauthorizedHandle = CreateEvent( NULL, TRUE, FALSE, NULL );
    }
    if ( BinlRogueTerminateEventHandle == NULL || RogueUnauthorizedHandle == NULL) {

        Error = GetLastError();

        BinlPrintDbg( (DEBUG_ROGUE,
                    "Initialize(...) CreateEvent returned error %x for rogue\n",
                    Error )
                );

        LeaveCriticalSection(&gcsDHCPBINL);
        return Error;
    }

    Error = DhcpRogueInit( &DhcpRogueInfo,
                            BinlRogueTerminateEventHandle,
                            RogueUnauthorizedHandle );

    if (Error != ERROR_SUCCESS) {

        LeaveCriticalSection(&gcsDHCPBINL);
        return Error;
    }

    //
    //  create the thread that handles the rogue detection logic in DHCP code.
    //

    BinlRogueThread = CreateThread( NULL,
                                    0,
                                    (LPTHREAD_START_ROUTINE)BinlRogueLoop,
                                    NULL,
                                    0,
                                    &threadId );

    if ( BinlRogueThread == NULL ) {
        Error =  GetLastError();
        BinlPrint((DEBUG_ROGUE, "Can't create rogue Thread, %ld.\n", Error));
        LeaveCriticalSection(&gcsDHCPBINL);
        return Error;
    }

    BinlGlobalHaveCalledRogueInit = TRUE;
    LeaveCriticalSection(&gcsDHCPBINL);

    return ERROR_SUCCESS;
}

VOID
StopRogueThread (
    VOID
    )
//
//  Cleanup all rogue thread resources.
//  The gcsDHCPBINL should not be held by caller.
//
{
    HANDLE tempThreadHandle;

    tempThreadHandle = InterlockedExchangePointer( &BinlRogueThread, NULL );

    if ( tempThreadHandle != NULL ) {

        BinlAssert( BinlRogueTerminateEventHandle != NULL );
        SetEvent( BinlRogueTerminateEventHandle );

        WaitForSingleObject(
            tempThreadHandle,
            THREAD_TERMINATION_TIMEOUT );
        CloseHandle( tempThreadHandle );
    }

    EnterCriticalSection(&gcsDHCPBINL);

    if (BinlGlobalHaveCalledRogueInit) {

        DhcpRogueCleanup( &DhcpRogueInfo );
        BinlGlobalHaveCalledRogueInit = FALSE;
    }

    if ( BinlRogueTerminateEventHandle ) {

        CloseHandle( BinlRogueTerminateEventHandle );
        BinlRogueTerminateEventHandle = NULL;
    }
    if ( RogueUnauthorizedHandle ) {

        CloseHandle( RogueUnauthorizedHandle );
        RogueUnauthorizedHandle = NULL;
    }

    LeaveCriticalSection(&gcsDHCPBINL);

    return;
}

VOID
HandleRogueAuthorized (
    VOID
    )
{
    BOOL oldState = BinlGlobalAuthorized;

    BinlGlobalAuthorized = TRUE;

    if ((BinlGlobalAuthorized != oldState) &&
        (BinlCurrentState != BINL_STOPPED)) {

        LogCurrentRogueState( FALSE );
    }
    return;
}

VOID
HandleRogueUnauthorized (
    VOID
    )
{
    BOOL oldState = BinlGlobalAuthorized;

    BinlGlobalAuthorized = FALSE;

    if ((BinlGlobalAuthorized != oldState) &&
        (BinlCurrentState != BINL_STOPPED)) {

        LogCurrentRogueState( FALSE );
    }
    return;
}

VOID
LogCurrentRogueState (
    BOOL ResponseToMessage
    )
{
    //
    //  If we're responding to a message and we haven't yet logged that
    //  we're unauthorized

    if ((ResponseToMessage == FALSE) ||
        ((BinlGlobalAuthorized == FALSE) &&
         (BinlRogueLoggedState == FALSE)) ) {

        BinlRogueLoggedState = TRUE;

        BinlReportEventW(   BinlGlobalAuthorized ?
                                EVENT_ERROR_DHCP_AUTHORIZED :
                                EVENT_ERROR_DHCP_NOT_AUTHORIZED,
                            EVENTLOG_INFORMATION_TYPE,
                            0,
                            0,
                            NULL,
                            NULL
                            );
    }
    return;
}

VOID
BinlRogueLoop(
    LPVOID Parameter
    )
{
    HANDLE  Handles[3];
    ULONG SecondsToSleep, SleepTime, Error;
    ULONG Flag;

    BinlPrintDbg((DEBUG_ROGUE, "BinlRogue thread has been started.\n" ));

    Handles[0] = BinlRogueTerminateEventHandle;
    Handles[1] = RogueUnauthorizedHandle;
    Handles[2] = BinlGlobalProcessTerminationEvent;

    do {
        SecondsToSleep = RogueDetectStateMachine(&DhcpRogueInfo);

        if( INFINITE == SecondsToSleep ) {
            SleepTime = INFINITE;
        } else {
            SleepTime = SecondsToSleep * 1000;
        }

        BinlPrintDbg( (DEBUG_ROGUE, "BinlRogue waiting %u milliseconds.\n", SleepTime ));

        Error = WaitForMultipleObjects(3, Handles, FALSE, SleepTime );

        //
        //   if we got anything but WAIT_TIMEOUT or RogueUnauthorized, we
        //   break out.  This is per RameshV's sample code.
        //

        if (Error == WAIT_OBJECT_0+2) {

            //
            // binl is terminating.
            //

            BinlPrintDbg((DEBUG_ROGUE, "BinlRogue thread is exiting because BINL shutting down.\n" ));
            return;
        }

        if (BinlRogueThread == NULL) {

            //
            //  we've been terminated because DHCP has started and is doing
            //  it's own rogue detection.
            //

            BinlPrintDbg((DEBUG_ROGUE, "BinlRogue thread is exiting because rogue thread is null.\n" ));
            return;
        }


        // if we ever have to do anything besides just continue when the
        // state machine tells us to exit, do so here.

#if 0
        if ((Error == WAIT_OBJECT_0+1) || (Error == WAIT_TIMEOUT)) {
            continue;
        }
#endif
        //
        //  supposedly the state machine resets so we should just continue.
        //

        BinlPrintDbg((DEBUG_ROGUE, "BinlRogue has error of 0x%x. sleeping a bit\n", Error ));
        Sleep( 1000 );  //  we'll sleep to give the dhcp rogue state
                            //  machine time to reset

    } while ( TRUE );
}

// rogue.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\binl\utils.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains the code to process OS Chooser message
    for the BINL server.

Author:

    Adam Barr (adamba)  9-Jul-1997
    Geoff Pease (gpease) 10-Nov-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include "binl.h"
#pragma hdrstop

//
// When all else fails "Error screen".
//
CHAR ErrorScreenHeaders[] =
"<OSCML>"\
"<META KEY=F3 ACTION=\"REBOOT\">"
"<META KEY=ENTER ACTION=\"REBOOT\">"
"<TITLE>  Client Installation Wizard                                    Error "; // there is a %08x after this
CHAR ErrorScreenBody[] =
" </TITLE>"
"<FOOTER> Press F3 to reboot</FOOTER>"
"<BODY LEFT=3 RIGHT=76><BR><BR>"; // the error message is inserted here
CHAR ErrorScreenTrailer[] =
"An error occurred on the server. Please notify your administrator.<BR>"
"%SUBERROR%<BR>"
"</BODY>"
"</OSCML>";

#define RANDOM_SEED (98725757)
static PCWSTR gUsableChars = L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

void
OscCreateWin32SubError(
    PCLIENT_STATE clientState,
    DWORD Error )
/*++
Routine Description:

    Create a OSC Variable SUBERROR with the actual Win32 error code that
    caused the BINL error.

Arguments:

      clientState - client state to add the variable too.

      Error - the Win32 error that occurred.
--*/
{
    DWORD dwLen;
    PWCHAR ErrorResponse = NULL;
    PWCHAR ErrorMsg = NULL;
    BOOL UsedFallback = FALSE;
    PWCHAR pch;
    DWORD ErrorLength;

    const WCHAR UnknownErrorMsg[] = L"Unknown Error.";
    const WCHAR ErrorString[] = L"Error: 0x%08x - %s";

    TraceFunc( "OscCreateWin32SubError( )\n" );

    // Retrieve the error message from system resources.
    dwLen = FormatMessageW( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_IGNORE_INSERTS |
                            FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            Error,
                            0,
                            (LPWSTR) &ErrorMsg,
                            0,
                            NULL );
    if ( dwLen == 0 )
        goto Cleanup;

#if DBG
    if ( ErrorMsg )
        DebugMemoryAdd( ErrorMsg, __FILE__, __LINE__, "BINL", LPTR, wcslen(ErrorMsg), "ErrorMsg" );
#endif

    // If all else fails, just print an error code out.
    if ( ErrorMsg == NULL ) {
        UsedFallback = TRUE;
        ErrorMsg = (PWCHAR) UnknownErrorMsg;
        dwLen = wcslen(ErrorMsg);
    }

    // The + 4 is the extra characters of the "%08x" of the generated error message.
    ErrorLength = dwLen + (sizeof( ErrorString )/sizeof(ErrorString[0])) + 4;
    ErrorResponse = (PWCHAR) BinlAllocateMemory( ErrorLength * sizeof(WCHAR) );
    if ( ErrorResponse == NULL ) {
        goto Cleanup;
    }

    wsprintf( ErrorResponse, ErrorString, Error, ErrorMsg );

    // We need to go through the string and elminate any CRs or LFs that
    // FormatMessageA() might have introduced.
    pch = ErrorResponse;
    while ( *pch )
    {
        if ( *pch == '\r' || * pch == '\n' )
            *pch = 32;  // change to space

        pch++;
    }

    OscAddVariableW( clientState, "SUBERROR", ErrorResponse );

Cleanup:
    if ( ErrorResponse ) {
        BinlFreeMemory( ErrorResponse );
    }
    if ( ErrorMsg && !UsedFallback ) {
        BinlFreeMemory( ErrorMsg );
    }
}

void
OscCreateLDAPSubError(
    PCLIENT_STATE clientState,
    DWORD Error )
/*++
Routine Description:

    Create a OSC Variable SUBERROR with the actual LDAP error code that
    caused the BINL error.

Arguments:

      clientState - client state to add the variable too.

      Error - the LDAP error that occurred.
--*/
{
    DWORD dwLen;
    PWCHAR ErrorResponse = NULL;
    DWORD ErrorLength;

    const WCHAR LdapErrorMsg[] = L"LDAP Error: 0x%08x";

    TraceFunc( "OscCreateLDAPSubError( )\n" );

    // The + 13 is the "0x12345678 - " of the generated error message.
    ErrorLength = wcslen(LdapErrorMsg) + 1 + 13;
    ErrorResponse = (PWCHAR) BinlAllocateMemory( ErrorLength * sizeof(WCHAR) );
    if ( ErrorResponse == NULL ) {
        goto Cleanup;
    }

    wsprintf( ErrorResponse, LdapErrorMsg, Error );

    OscAddVariableW( clientState, "SUBERROR", ErrorResponse );

Cleanup:
    if ( ErrorResponse ) {
        BinlFreeMemory( ErrorResponse );
    }
}

//
// This routine was stolen from private\ntos\rtl\sertl.c\RtlRunEncodeUnicodeString().
//

VOID
OscGenerateSeed(
    UCHAR Seed[1]
    )
/*++

Routine Description:

    Generates a one-byte seed for use in run encoding/decoding client
    state variables such as passwords.

Arguments:

    Seed - points to a single byte that holds the generated seed.

Return Value:

    None.

--*/

{
    LARGE_INTEGER Time;
    PUCHAR        LocalSeed;
    NTSTATUS      Status;
    ULONG         i;

    //
    // Use the 2nd byte of current time as the seed.
    // This byte seems to be sufficiently random (by observation).
    //

    Status = NtQuerySystemTime ( &Time );
    BinlAssert(NT_SUCCESS(Status));

    LocalSeed = (PUCHAR)((PVOID)&Time);

    i = 1;

    (*Seed) = LocalSeed[ i ];

    //
    // Occasionally, this byte could be zero.  That would cause the
    // string to become un-decodable, since 0 is the magic value that
    // causes us to re-gen the seed.  This loop makes sure that we
    // never end up with a zero byte (unless time is zero, as well).
    //

    while ( ((*Seed) == 0) && ( i < sizeof( Time ) ) )
    {
        (*Seed) |= LocalSeed[ i++ ] ;
    }

    if ( (*Seed) == 0 )
    {
        (*Seed) = 1;
    }
}

DWORD
OscRunEncode(
    IN PCLIENT_STATE ClientState,
    IN LPSTR Data,
    OUT LPSTR * EncodedData
    )
/*++

Routine Description:

    Calls RtlRunEncodeUnicodeString for the Data, using the client
    state's random seed. Then convert each byte into a 2-byte
    value so that there are no NULLs in the result.

    Each byte is encoded into a 2-byte values as follows:
    The first byte has the low 4 bits of the byte in its low 4 bits,
    with 0xf in the high 4 bits
    The second byte has the high 4 bits of the byte in its high 4 bits,
    with 0xf in the low 4 bits

Arguments:

    ClientState - the client state.

    Data - The data which is to be encoded.

    EncodedData - An allocated buffer which holds the encoded result.

Return Value:

    The result of the operation.

--*/
{
    STRING String;
    ULONG i;
    LPSTR p;

    RtlInitAnsiString(&String, Data);

    *EncodedData = BinlAllocateMemory((String.Length * 2) + 1);
    if (*EncodedData == NULL) {
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;
    }

    RtlRunEncodeUnicodeString(&ClientState->Seed, (PUNICODE_STRING)&String);

    for (i = 0, p = *EncodedData; i < String.Length; i++) {
        *(p++) = Data[i] | 0xf0;
        *(p++) = Data[i] | 0x0f;
    }
    *p = '\0';

    return ERROR_SUCCESS;

}

DWORD
OscRunDecode(
    IN PCLIENT_STATE ClientState,
    IN LPSTR EncodedData,
    OUT LPSTR * Data
    )
/*++

Routine Description:

    Convert the encoded data (see OscRunEncode) into the real bytes,
    then calls RtlRunDecodeUnicodeString on that, using the client
    state's random seed.

Arguments:

    ClientState - the client state.

    EncodedData - the encoded data from OscRunEncode.

    Data - An allocated buffer which holds the decoded result.

Return Value:

    The result of the operation.

--*/
{
    STRING String;
    ULONG Count = strlen(EncodedData) / 2;
    ULONG i, j;
    LPSTR p;

    *Data = BinlAllocateMemory(Count + 1);
    if (*Data == NULL) {
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;
    }

    for (i = 0, j = 0, p = *Data; i < Count; i++, j+=2)  {
        *(p++) = (EncodedData[j] & 0x0f) | (EncodedData[j+1] & 0xf0);
    }
    *p = '\0';

    //
    // Set up the string ourselves since there may be NULLs in
    // the decoded data.
    //

    String.Buffer = *Data;
    String.Length = (USHORT)Count;
    String.MaximumLength = (USHORT)(Count+1);

    RtlRunDecodeUnicodeString(ClientState->Seed, (PUNICODE_STRING)&String);

    return ERROR_SUCCESS;
}

//
// This routine was stolen from net\svcdlls\logonsrv\server\ssiauth.c.
//

BOOLEAN
OscGenerateRandomBits(
    PUCHAR Buffer,
    ULONG  BufferLen
    )
/*++

Routine Description:

    Generates random bits

Arguments:

    pBuffer - Buffer to fill

    cbBuffer - Number of bytes in buffer

Return Value:

    Status of the operation.

--*/

{
    BOOL Status = TRUE;
    HCRYPTPROV CryptProvider = 0;

    Status = CryptAcquireContext( &CryptProvider, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT );

    if ( Status ) {

        Status = CryptGenRandom( CryptProvider, BufferLen, ( LPBYTE )Buffer );

        CryptReleaseContext( CryptProvider, 0 );

    } else {

        BinlPrintDbg((DEBUG_ERRORS, "CryptAcquireContext failed with %lu\n", GetLastError() ));

    }

    return ( Status != 0);
}

VOID
OscGeneratePassword(
    OUT PWCHAR Password,
    OUT PULONG PasswordLength
    )
{
    ULONG   i;
    DWORD   UsableCount = 0;
    DWORD   Seed = 0;
    WCHAR   GeneratedCharacter;
    BOOLEAN Proceed = FALSE;

    
    //
    // Set return password length and initialize
    // the generated password.
    //
    *PasswordLength = LM20_PWLEN * sizeof(WCHAR);
    memset( Password, 0, *PasswordLength );


    //
    // Initialize for random password generation.
    //
    UsableCount = lstrlen(gUsableChars);
    Seed = RANDOM_SEED ^ GetCurrentTime();
    srand( Seed );


    //
    // Ensure we have at least one period in the password.
    //
    Password[rand() % LM20_PWLEN] = L'.';


    //
    // Ensure there's at least one digit in the password.
    //
    do {
        i = rand() % LM20_PWLEN;
    } while ( Password[i] != 0 );
    Password[i] = (rand() % 10) + 0x30;


    //
    // Now fill in the rest of the password.
    //
    for (i = 0; i < LM20_PWLEN; i++) {
        
        if ( Password[i] == 0 ) {
            Password[i] = gUsableChars[rand() % UsableCount];
        }
    }
}

//
// GenerateErrorScreen( )
//
DWORD
GenerateErrorScreen(
    PCHAR  *OutMessage,
    PULONG OutMessageLength,
    DWORD  Error,
    PCLIENT_STATE clientState
    )
{
    DWORD Err;
    DWORD dwLen;
    PCHAR ErrorMsg;
    DWORD ErrorScreenLength = strlen(ErrorScreenHeaders) + strlen(ErrorScreenBody) + strlen(ErrorScreenTrailer);
    PCHAR pch;
    PCHAR RspMessage = NULL;
    ULONG RspMessageLength = 0;

    const CHAR UnknownErrorMsg[] = "Unknown Error.";

    WCHAR ErrorMsgFilename[ MAX_PATH ];
    HANDLE hfile;

    LPSTR Messages[5];

    Messages[0] = OscFindVariableA( clientState, "USERNAME" );
    Messages[1] = OscFindVariableA( clientState, "USERDOMAIN" );
    Messages[2] = OscFindVariableA( clientState, "MACHINENAME" );
    Messages[3] = OscFindVariableA( clientState, "SUBERROR" );
    Messages[4] = NULL; // paranoid

    if ( _snwprintf( ErrorMsgFilename,
                     sizeof(ErrorMsgFilename) / sizeof(ErrorMsgFilename[0]),
                     L"%ws\\OSChooser\\%ws\\%08x.OSC",
                     IntelliMirrorPathW,
                     OscFindVariableW( clientState, "LANGUAGE" ),
                     Error ) > 0 ) {

        ErrorMsgFilename[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe
        //
        // If we find the file, load it into memory.
        //
        hfile = CreateFile( ErrorMsgFilename, GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if ( hfile != INVALID_HANDLE_VALUE ) {
            DWORD FileSize;
            //
            // Find out how big this screen is, if bigger than 0xFFFFFFFF we won't
            // display it.
            //
            FileSize = GetFileSize( hfile, NULL );
            if ( FileSize != 0xFFFFffff )
            {
                DWORD dwRead = 0;

                RspMessage = BinlAllocateMemory( FileSize + 3 );
                if ( RspMessage == NULL )
                {
                    //
                    // Ignore error and fall thru to generate an error screen
                    //
                }
                else
                {
                    RspMessageLength = 0;
                    RspMessage[0] = '\0';

                    while ( dwRead != FileSize )
                    {
                        BOOL b;
                        DWORD dw;
                        b = ReadFile( hfile, &RspMessage[dwRead], FileSize - dwRead, &dw, NULL );
                        if (!b)
                        {
                            PWCHAR strings[2];
                            strings[0] = ErrorMsgFilename;
                            strings[1] = NULL;
                            Err = GetLastError( );

                            BinlPrint(( DEBUG_OSC_ERROR, "Error reading screen file: Seek=%u, Size=%u, File=%ws\n",
                                        dwRead, FileSize - dwRead, ErrorMsgFilename ));

                            BinlReportEventW( EVENT_ERROR_READING_OSC_SCREEN,
                                              EVENTLOG_ERROR_TYPE,
                                              1,
                                              sizeof(Err),
                                              strings,
                                              &Err
                                              );
                            break;
                        }
                        dwRead += dw;
                    }

                    RspMessageLength = dwRead;
                    RspMessage[dwRead] = '\0'; // paranoid

                    CloseHandle( hfile );

                    Err = ERROR_SUCCESS;
                    goto Cleanup;
                }
            }
            else
            {
                BinlPrintDbg((DEBUG_OSC_ERROR, "!!Error 0x%08x - Could not determine file size.\n", GetLastError( )));
                //
                // Ignore error and fall thru to generate an error screen
                //
            }

            CloseHandle( hfile );
        }

    }

    BinlPrintDbg((DEBUG_OSC_ERROR, "no friendly OSC error screen available.\n" ));
    //
    // See if this is a BINL error or a system error and
    // get the text from the error tables.
    //
    dwLen = FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            GetModuleHandle(L"BINLSVC.DLL"),
                            Error,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                            (LPSTR) &ErrorMsg,
                            0,
                            (va_list*) Messages );
    if ( dwLen == 0 )
    {
        BinlAssert( ErrorMsg == NULL );
        Err = GetLastError( );
        BinlPrintDbg((DEBUG_OSC_ERROR, "!! Error 0x%08x - no BINLSVC specific message available.\n", Err ));

        dwLen = FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_IGNORE_INSERTS |
                                FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                Error,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                                (LPSTR) &ErrorMsg,
                                0,
                                NULL );
        if ( dwLen == 0 )
        {
            BinlAssert( ErrorMsg == NULL );
            Err = GetLastError( );
            BinlPrintDbg((DEBUG_OSC_ERROR, "!! Error 0x%08x - no SYSTEM specific message available.\n", Err ));
        }
    }

#if DBG
    if ( ErrorMsg )
        DebugMemoryAdd( ErrorMsg, __FILE__, __LINE__, "BINL", LPTR, strlen(ErrorMsg), "ErrorMsg" );
#endif

    //
    // If all else fails, just print an error code.
    //
    if ( ErrorMsg == NULL ) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "sending using generic error message.\n" ));
        ErrorMsg = (PCHAR) UnknownErrorMsg;
        dwLen = strlen(ErrorMsg);
    }

#define ERRORITEM "%s%08x%s<BR><BOLD>%s</BOLD><BR><BR>%s"

    //
    // The + 13 is the "0x12345678 - " of the generated error message.
    //
    RspMessageLength = ErrorScreenLength + strlen(ERRORITEM) + dwLen + 1 + 13;
    RspMessage = (PCHAR) BinlAllocateMemory( RspMessageLength );
    if ( RspMessage == NULL )
    {
        Err = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto Cleanup;
    }

    wsprintfA( RspMessage, ERRORITEM, ErrorScreenHeaders, Error, ErrorScreenBody, ErrorMsg, ErrorScreenTrailer );

    Err = ERROR_SUCCESS;

Cleanup:
    if ( Err == ERROR_SUCCESS )
    {
        // BinlPrint(( DEBUG_OSC, "Generated Error Response:\n%s\n", RspMessage ));
        *OutMessage = RspMessage;
        *OutMessageLength = RspMessageLength;

        BinlReportEventA( EVENT_ERROR_SERVER_SIDE_ERROR,
                          EVENTLOG_ERROR_TYPE,
                          4,
                          sizeof(Error),
                          Messages,
                          &Error
                          );
    }
    else
    {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "!! Error 0x%08x - Couldn't generate error screen.\n", Err ));

        BinlReportEventA( EVENT_ERROR_GENERATING_SERVER_SIDE_ERROR,
                          EVENTLOG_ERROR_TYPE,
                          4,
                          sizeof(Err),
                          Messages,
                          &Err
                          );

        *OutMessage = NULL;
        *OutMessageLength = 0;

        if ( RspMessage )
        {
            BinlFreeMemory( RspMessage );
        }
    }

    return Err;
}

//
// Returns a pointer point to the next 'ch' or NULL character.
//
PCHAR
FindNext(
    PCHAR Start,
    CHAR ch,
    PCHAR End
    )
{
    TraceFunc("FindNext( )\n");

    while( Start != End && *Start && *Start !=ch ) {
        Start++;
    }

    if ( Start != End && *Start ) {
        return Start;
    } else {
        return NULL;
    }
}

//
// Finds the screen name.
//
PCHAR
FindScreenName(
    PCHAR Screen
    )
{
    PCHAR Name;
    TraceFunc("FindScreenName( )\n");

    Name = strstr( Screen, "NAME" );

    if ( Name == NULL ) {
        return NULL;
    }

    Name += 5;  // "Name" plus space

    return Name;
}

DWORD
OscImpersonate(
    IN PCLIENT_STATE ClientState
    )
/*++

Routine Description:

    Makes the current thread impersonate the client. It is assumed
    that the client has already sent up a login screen. If this call
    succeeds, ClientState->AuthenticatedDCLdapHandle is valid.

Arguments:

    ClientState - The client state.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    LPSTR pUserName;
    LPSTR pUserDomain;
    LPSTR pUserPassword;
    LPSTR pDecodedPassword = NULL;
    LPSTR tempptr;
    ULONG temp;
    ULONG LdapError = 0;
    SEC_WINNT_AUTH_IDENTITY_A authIdentity;
    BOOL bResult;
    BOOL Impersonating = FALSE;
    LPWSTR pCrossDsDc;

    TraceFunc( "OscImpersonate( ... )\n" );

    pCrossDsDc = OscFindVariableW( ClientState, "DCNAME" );
    if (*pCrossDsDc == L'\0') {
    
        //
        // Clean up any old client state.
        //
    
        if (ClientState->AuthenticatedDCLdapHandle &&
            ClientState->UserToken) {
    
            bResult = ImpersonateLoggedOnUser(ClientState->UserToken);
            if (bResult) {
    
                return STATUS_SUCCESS;
            }
        }

    }

    if (ClientState->AuthenticatedDCLdapHandle) {
        //  Reconnecting again. Use new credentials.
        ldap_unbind(ClientState->AuthenticatedDCLdapHandle);
        ClientState->AuthenticatedDCLdapHandle = NULL;
    }
    if (ClientState->UserToken) {
        CloseHandle(ClientState->UserToken);
        ClientState->UserToken = NULL;
    }

    //
    // Get the login variables from the client state.
    //

    pUserName = OscFindVariableA( ClientState, "USERNAME" );
    pUserDomain = OscFindVariableA( ClientState, "USERDOMAIN" );
    pUserPassword = OscFindVariableA( ClientState, "*PASSWORD" );

    if (pUserName[0] == '\0') {
        OscAddVariableA( ClientState, "SUBERROR", "USERNAME" );
        Error = ERROR_BINL_MISSING_VARIABLE;
        goto ImpersonateFailed;
    }

    //
    // Decode the password.
    //

    Error = OscRunDecode(ClientState, pUserPassword, &pDecodedPassword);
    if (Error != ERROR_SUCCESS) {
        goto ImpersonateFailed;
    }


    //
    //  if the user didn't enter a domain name, use the server's
    //

    if (pUserDomain == NULL || pUserDomain[0] == '\0') {

        OscAddVariableW( ClientState, "USERDOMAIN", BinlGlobalOurDomainName );
            
        pUserDomain = OscFindVariableA( ClientState, "USERDOMAIN" );
        
    }

    //
    // Do a LogonUser with the credentials, since we
    // need that to change the machine password (even the
    // authenticated LDAP handle won't do that if we don't
    // have 128-bit SSL setup on this machine).
    //

    bResult = LogonUserA(
                  pUserName,
                  pUserDomain,
                  pDecodedPassword,
                  LOGON32_LOGON_NETWORK_CLEARTEXT,
                  LOGON32_PROVIDER_DEFAULT,
                  &ClientState->UserToken);

    if (!bResult) {
        Error = GetLastError();
        BinlPrintDbg(( DEBUG_ERRORS, "LogonUser failed %lx\n", Error));
        ClientState->UserToken = NULL;   // this may be set even on failure
        goto ImpersonateFailed;
    }

    //
    //  if the user didn't enter a domain name, grab it out of the user token.
    //

    if (pUserDomain == NULL || pUserDomain[0] == '\0') {

        PTOKEN_USER userToken;
        DWORD tokenSize = 4096;

        userToken = (PTOKEN_USER) BinlAllocateMemory( tokenSize );

        if (userToken != NULL) {

            DWORD returnLength;
            BOOL bRC;

            bRC = GetTokenInformation( ClientState->UserToken,
                                       TokenUser,
                                       (LPVOID) userToken,
                                       tokenSize,
                                       &returnLength
                                       );

            if (bRC) {

                WCHAR uUser[128];
                DWORD cUser   = 128;
                WCHAR uDomain[128];
                DWORD cDomain = 128;
                SID_NAME_USE peType;

                uDomain[0] = L'\0';
                uUser[0] = L'\0';

                bRC = LookupAccountSidW(   NULL,      // system name
                                           userToken->User.Sid,
                                           uUser,         // user name
                                           &cUser,        // user name count
                                           uDomain,       // domain name
                                           &cDomain,      // domain name count
                                           &peType
                                           );

                if (bRC && uDomain[0] != L'\0') {

                    OscAddVariableW( ClientState, "USERDOMAIN", &uDomain[0] );
                }
            }

            BinlFreeMemory( userToken );
        }
    }

    //
    // Now impersonate the user.
    //

    bResult = ImpersonateLoggedOnUser(ClientState->UserToken);
    if (!bResult) {
        BinlPrintDbg(( DEBUG_ERRORS,
            "ImpersonateLoggedOnUser failed %x\n", GetLastError()));
        Error = GetLastError();
        goto ImpersonateFailed;
    }

    Impersonating = TRUE;

    //
    // Create authenticated DC connection for use in machine object creation
    //  or modification.
    //
    BinlPrintDbg(( DEBUG_OSC,
        "ldap_init %S or %S\n", pCrossDsDc, BinlGlobalDefaultDS ));

    ClientState->AuthenticatedDCLdapHandle = ldap_init( 
                                                (*pCrossDsDc != L'\0')
                                                  ? pCrossDsDc
                                                  : BinlGlobalDefaultDS, 
                                                LDAP_PORT);

    BinlPrintDbg(( DEBUG_OSC,
    "ldap_init handle %x\n", ClientState->AuthenticatedDCLdapHandle ));


    temp = DS_DIRECTORY_SERVICE_REQUIRED | DS_IP_REQUIRED;
    Error = ldap_set_option(ClientState->AuthenticatedDCLdapHandle, LDAP_OPT_GETDSNAME_FLAGS, &temp );
    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_ERRORS, "OscImpersonate: Error %x when setting ldap options\n" ));
        goto ImpersonateFailed;
    }

    temp = LDAP_VERSION3;
    Error = ldap_set_option(ClientState->AuthenticatedDCLdapHandle, LDAP_OPT_VERSION, &temp );
    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_ERRORS, "OscImpersonate: Error %x when setting ldap options\n" ));
        goto ImpersonateFailed;
    }

    //
    // Tell LDAP to keep connections referenced after searches.
    //

    temp = (ULONG)((ULONG_PTR)LDAP_OPT_ON);
    Error = ldap_set_option(ClientState->AuthenticatedDCLdapHandle, LDAP_OPT_REF_DEREF_CONN_PER_MSG, &temp);
    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_ERRORS, "OscImpersonate: Error %x when setting ldap options\n" ));
        goto ImpersonateFailed;
    }

    LdapError = ldap_connect(ClientState->AuthenticatedDCLdapHandle,0);

    if (LdapError != LDAP_SUCCESS) {
        BinlPrintDbg(( DEBUG_ERRORS,
            "this ldap_connect() failed %x\n", LdapError));
        goto ImpersonateFailed;
    }

    //
    // LDAP_AUTH_NEGOTIATE tells it to use the credentials of the user
    // we are impersonating.
    //

    LdapError = ldap_bind_sA(ClientState->AuthenticatedDCLdapHandle,
                             NULL,
                             NULL,
                             LDAP_AUTH_NEGOTIATE);

    if (LdapError != LDAP_SUCCESS) {
        BinlPrintDbg(( DEBUG_ERRORS,
            "ldap_bind_s() failed %x\n", LdapError));
        goto ImpersonateFailed;
    }

ImpersonateFailed:

    //
    // If we decoded the password, then erase and free it.
    //

    if (pDecodedPassword != NULL) {
        RtlSecureZeroMemory(pDecodedPassword, strlen(pDecodedPassword));
        BinlFreeMemory(pDecodedPassword);
    }

    if (LdapError != LDAP_SUCCESS) {
        Error = LdapMapErrorToWin32(LdapError);
    }

    if (Error) {
        PWCHAR strings[3];
        strings[0] = OscFindVariableW( ClientState, "USERNAME" );
        strings[1] = OscFindVariableW( ClientState, "USERDOMAIN" );
        strings[2] = NULL;

        BinlReportEventW( ERROR_BINL_ERR_USER_LOGIN_FAILED,
                          EVENTLOG_WARNING_TYPE,
                          2,
                          sizeof(ULONG),
                          strings,
                          &Error
                          );

        if (ClientState->AuthenticatedDCLdapHandle) {
            ldap_unbind(ClientState->AuthenticatedDCLdapHandle);
            ClientState->AuthenticatedDCLdapHandle = NULL;
        }
        if (ClientState->UserToken) {
            CloseHandle(ClientState->UserToken);
            ClientState->UserToken = NULL;
        }
        if (Impersonating) {
            RevertToSelf();
        }
    }

    return Error;
}

DWORD
OscRevert(
    IN PCLIENT_STATE ClientState
    )
/*++

Routine Description:

    Stops the current thread impersonating.

Arguments:

    ClientState - The client state.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    BOOL bResult;

    TraceFunc( "OscRevert( ... )\n" );

    //
    // We are done impersonating for the moment.
    //

    bResult = RevertToSelf();
    if (!bResult) {
        BinlPrintDbg(( DEBUG_ERRORS,
            "RevertToSelf failed %x\n", GetLastError()));
        Error = GetLastError();
    }

    //  keep the ldap handle around in case we need it again.

//  if (ClientState->AuthenticatedDCLdapHandle) {
//      ldap_unbind(ClientState->AuthenticatedDCLdapHandle);
//      ClientState->AuthenticatedDCLdapHandle = NULL;
//  }
//  if (ClientState->UserToken) {
//      CloseHandle(ClientState->UserToken);
//      ClientState->UserToken = NULL;
//  }

    return Error;

}

//
// OscGuidToBytes( )
//
// Change CHAR Guid to bytes
//
DWORD
OscGuidToBytes(
    LPSTR  pszGuid,
    LPBYTE Guid )
{
    PCHAR psz;
    ULONG len;
    ULONG i;

    TraceFunc( "OscGuidToBytes( ... )\n" );

    len = strlen(pszGuid);
    BinlAssert( len == 32 );
    if ( len != 32 ) {
        return ERROR_BINL_INVALID_GUID;
    }

    psz = pszGuid;
    i = 0;
    while ( i * 2 < 32 )
    {
        //
        // Upper 4-bits
        //
        CHAR c = *psz;
        psz++;
        Guid[i] = ( c > 59 ? (toupper(c) - 55) << 4 : (c - 48) << 4);

        //
        // Lower 4-bits
        //
        c = *psz;
        psz++;
        Guid[i] += ( c > 59 ? (toupper(c) - 55) : (c - 48) );

        //
        // Next byte
        //
        i++;
    }

    return ERROR_SUCCESS;
}


BOOLEAN
OscSifIsSysPrep(
    LPWSTR pSysPrepSifPath
    )
{
    DWORD dwErr;
    WCHAR Buffer[256];
    UNICODE_STRING UnicodeString;

    TraceFunc("OscSifIsSysPrep( )\n");

    Buffer[0] = UNICODE_NULL;
    GetPrivateProfileString(OSCHOOSER_SIF_SECTIONW,
                            L"ImageType",
                            Buffer, // default
                            Buffer,
                            256,
                            pSysPrepSifPath
                           );

    RtlInitUnicodeString(&UnicodeString, Buffer);
    RtlUpcaseUnicodeString(&UnicodeString, &UnicodeString, FALSE);

    if (_wcsicmp(L"SYSPREP", Buffer)) {
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
OscSifIsCmdConsA(
    PCHAR pSifPath
    )
{
    DWORD dwErr;
    CHAR Buffer[256];

    TraceFunc("OscSifIsCmdCons( )\n");

    Buffer[0] = '\0';
    GetPrivateProfileStringA(OSCHOOSER_SIF_SECTIONA,
                             "ImageType",
                             Buffer, // default
                             Buffer,
                             256,
                             pSifPath
                            );

    if (_stricmp("CMDCONS", Buffer)) {
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
OscSifIsASR(
    PCHAR pSifPath
    )
{
    DWORD dwErr;
    CHAR Buffer[256];

    TraceFunc("OscSifIsASR( )\n");

    Buffer[0] = '\0';
    GetPrivateProfileStringA(OSCHOOSER_SIF_SECTIONA,
                             "ImageType",
                             Buffer, // default
                             Buffer,
                             256,
                             pSifPath
                            );

    if (_stricmp("ASR", Buffer)) {
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
OscSifIsWinPE(
    PCHAR pSifPath
    )
{
    DWORD dwErr;
    CHAR Buffer[256];

    TraceFunc("OscSifIsWinPE( )\n");

    Buffer[0] = '\0';
    GetPrivateProfileStringA(OSCHOOSER_SIF_SECTIONA,
                             "ImageType",
                             Buffer, // default
                             Buffer,
                             256,
                             pSifPath
                            );

    if (_stricmp("WinPE", Buffer)) {
        return FALSE;
    }

    return TRUE;
}



BOOLEAN
OscSifIsWinPEW(
    PWCHAR pSifPath
    )
{
    DWORD dwErr;
    WCHAR Buffer[256];

    TraceFunc("OscSifIsWinPE( )\n");

    Buffer[0] = UNICODE_NULL;
    GetPrivateProfileString(OSCHOOSER_SIF_SECTIONW,
                             L"ImageType",
                             Buffer, // default
                             Buffer,
                             256,
                             pSifPath
                            );

    if (_wcsicmp(L"WinPE", Buffer)) {
        return FALSE;
    }

    return TRUE;
}



DWORD
OscGetSkuType(
    PWSTR PathToTxtSetupSif
    )
{
    PWSTR SifFile;
    DWORD SkuType = 0;

    SifFile = BinlAllocateMemory( 
                    (wcslen(PathToTxtSetupSif) + 
                     sizeof(L"\\txtsetup.sif")/sizeof(WCHAR) ) * sizeof(WCHAR));

    if (!SifFile) {
        return 0; //default to professional on failure
    }

    wcscpy(SifFile, PathToTxtSetupSif);
    if (SifFile[wcslen(SifFile)-1] == L'\\') {
        wcscat( SifFile, L"txtsetup.sif" );
    } else {
        wcscat( SifFile, L"\\txtsetup.sif" );
    }

    SkuType = GetPrivateProfileInt( 
                        L"SetupData", 
                        L"ProductType", 
                        0, 
                        SifFile );

    BinlFreeMemory( SifFile );

    return (SkuType);

}


BOOLEAN
OscGetClosestNt(
    IN LPWSTR PathToKernel,
    IN DWORD  SkuType,
    IN PCLIENT_STATE ClientState,
    OUT LPWSTR SetupPath,
    IN DWORD SetupPathSize,
    OUT PBOOLEAN ExactMatch
    )
{
    DWORD Error = ERROR_SUCCESS;
    WIN32_FIND_DATA FindData,TemplateData;
    HANDLE hFind = INVALID_HANDLE_VALUE,hTemplate = INVALID_HANDLE_VALUE;
    BOOLEAN Impersonated = FALSE;
    WCHAR Path[MAX_PATH],TemplatesPath[MAX_PATH];
    PWSTR p;
    ULONGLONG BestVersion = (ULONGLONG)0;
    ULONGLONG ThisVersion;
    ULONGLONG KernelVersion;
    DWORD dwPathLen;
    BOOLEAN ReturnValue = FALSE;
    BOOLEAN FoundWinPE;

    TraceFunc("OscGetClosestNt( )\n");

    Error = ImpersonateSecurityContext(&ClientState->ServerContextHandle);
    if (Error != STATUS_SUCCESS) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "ImpersonateSecurityContext: 0x%08x\n", Error ));
        goto Cleanup;
    }

    Impersonated = TRUE;

    //
    // Get the version info of the kernel passed in
    //
    if (!OscGetNtVersionInfo(&KernelVersion, PathToKernel, ClientState)) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "OscGetNtVersionInfo failed\n" ));
        goto Cleanup;
    }

    //
    // Resulting string should be something like:
    //      "D:\RemoteInstall\Setup\English\Images\*"
    if ( _snwprintf( Path,
                     sizeof(Path) / sizeof(Path[0]),
                     L"%ws\\Setup\\%ws\\%ws\\*",
                     IntelliMirrorPathW,
                     OscFindVariableW(ClientState, "LANGUAGE"),
                     REMOTE_INSTALL_IMAGE_DIR_W
                     ) < 0 ) {
        goto Cleanup;
    }

    Path[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe
    hFind = FindFirstFile(Path, (LPVOID) &FindData);
    if (hFind == INVALID_HANDLE_VALUE) {
        goto Cleanup;
    }

    dwPathLen = wcslen(Path);

    //
    // Loop enumerating each subdirectory
    //
    do {
        //
        // Ignore directories "." and ".."
        //
        if (wcscmp(FindData.cFileName, L".") &&
            wcscmp(FindData.cFileName, L"..") &&
            (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            DWORD ThisSkuType;
            DWORD dwFileNameLen;
            DWORD dwTemplatesPathLen;
            
            //
            // Add the sub-directory to the path
            //
            dwFileNameLen = wcslen(FindData.cFileName);
            if (dwPathLen + dwFileNameLen + MAX_ARCHITECTURE_LENGTH + 1 > sizeof(Path)/sizeof(Path[0])) {
                continue;  // path too long, skip it
            }
            wcscpy(&Path[dwPathLen - 1], FindData.cFileName );

            BinlPrintDbg(( DEBUG_OSC, "Found OS Directory: %ws\n", Path ));

            // Resulting string should be something like:
            //      "D:\RemoteInstall\Setup\English\Images\nt50.wks\i386"
            p = OscFindVariableW(ClientState, "MACHINETYPE");
            if (!p) {
                continue;
            }

            if (wcslen(Path) + (sizeof(L"\\")/sizeof(WCHAR)) + wcslen(p) > sizeof(Path)/sizeof(Path[0])) {
                continue;
            }
            
            wcscat(Path, L"\\");
            wcscat(Path, p);

            //
            // get a path to the templates folder and make sure we dont' have
            // a winpe image.  if we do then we're in trouble because we can't
            // treat that as a normal image.
            //
            FoundWinPE = FALSE;
            if (0 > _snwprintf(
                            TemplatesPath,
                            MAX_PATH,
                            L"%ws\\templates\\*.sif",
                            Path)) {
                continue;
            }
            TemplatesPath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe

            dwTemplatesPathLen = wcslen(TemplatesPath);
            p = wcsrchr(TemplatesPath,L'*');
            BinlAssert( p != NULL );
            
            dwTemplatesPathLen = (p - TemplatesPath)/sizeof(WCHAR);
            

            hTemplate = FindFirstFile(TemplatesPath, (LPVOID) &TemplateData);
            if (hTemplate != INVALID_HANDLE_VALUE) {
                do {
                    if (wcscmp(TemplateData.cFileName, L".") &&
                        wcscmp(TemplateData.cFileName, L"..") &&
                        (TemplateData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
                        // make sure there is enough room.
                        if (dwTemplatesPathLen + wcslen(TemplateData.cFileName) + 1 > sizeof(TemplatesPath)/sizeof(WCHAR)) {
                            continue; 
                        }
                        
                        wcscpy(&TemplatesPath[dwTemplatesPathLen],TemplateData.cFileName);                        

                        if (OscSifIsWinPEW(TemplatesPath)) {             
                            BinlPrintDbg(( DEBUG_OSC, "OS Directory %ws is really a WinPE image, skipping it.\n", Path ));
                            FoundWinPE = TRUE;
                            break;
                        }
                    }
                } while (FindNextFile(hTemplate, (LPVOID) &TemplateData));

                FindClose(hTemplate);
                hTemplate = INVALID_HANDLE_VALUE;
            }

            if (FoundWinPE) {                
                continue;
            }


            ThisSkuType = OscGetSkuType( Path );

            if (OscGetNtVersionInfo(&ThisVersion, Path, ClientState)) {
                //
                // if the sku we're looking for is ads and we've found srv,
                // then lie and say it's really
                // ads.  This gets around a problem where txtsetup.sif didn't
                // specify the SKU type correctly in 2195.
                //
                if (ThisSkuType == 1 && SkuType == 2) {
                    ThisSkuType = 2;
                }

                if ((ThisVersion >= KernelVersion) &&
                    (ThisSkuType == SkuType) &&
                    ((BestVersion == (ULONGLONG)0) || (ThisVersion < BestVersion))) {
                    if (SetupPathSize >= wcslen(Path)) {
                        wcscpy(SetupPath, Path);
                        BestVersion = ThisVersion;
                    }
                }
            }            
        }

    } while (FindNextFile(hFind, (LPVOID) &FindData));

    if (BestVersion != 0) {
        ReturnValue = TRUE;
        *ExactMatch = (BOOLEAN)(BestVersion == KernelVersion);
    } else {
        ReturnValue = FALSE;
    }

Cleanup:

    if (hFind != INVALID_HANDLE_VALUE) {
        FindClose(hFind);
    }

    if (Impersonated) {
        Error = RevertSecurityContext(&ClientState->ServerContextHandle);
        if (Error != STATUS_SUCCESS) {
            BinlPrintDbg(( DEBUG_OSC_ERROR, "RevertSecurityContext: 0x%08x\n", Error ));
            return FALSE;
        }
    }

    return ReturnValue;
}

BOOLEAN
OscGetNtVersionInfo(
    PULONGLONG Version,
    PWCHAR SearchDir,
    PCLIENT_STATE ClientState
    )
{
    DWORD Error = ERROR_SUCCESS;
    DWORD FileVersionInfoSize;
    DWORD VersionHandle;
    ULARGE_INTEGER TmpVersion;
    PVOID VersionInfo;
    VS_FIXEDFILEINFO * FixedFileInfo;
    UINT FixedFileInfoLength;
    WCHAR Path[MAX_PATH];
    BOOLEAN fResult = FALSE;

    TraceFunc("OscGetNtVersionInfo( )\n");

    if (!SearchDir) {
        goto e0;
    }

    //
    // Resulting string should be something like:
    //      "D:\RemoteInstall\Setup\English\Images\nt50.wks\i386\ntoskrnl.exe"
    //
    if (0 > _snwprintf(
                    Path,
                    MAX_PATH,
                    L"%ws\\ntoskrnl.exe",
                    SearchDir)) {
        goto e0; // path too long, skip it
    }
    Path[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe

    BinlPrintDbg((DEBUG_OSC, "Checking version: %ws\n", Path));

    FileVersionInfoSize = GetFileVersionInfoSize(Path, &VersionHandle);
    if (FileVersionInfoSize == 0) {
        goto e0;
    }

    VersionInfo = BinlAllocateMemory(FileVersionInfoSize);
    if (VersionInfo == NULL) {
        goto e0;
    }

    if (!GetFileVersionInfo(
             Path,
             VersionHandle,
             FileVersionInfoSize,
             VersionInfo)) {
        goto e1;
    }

    if (!VerQueryValue(
             VersionInfo,
             L"\\",
             &FixedFileInfo,
             &FixedFileInfoLength)) {
        goto e1;
    }

    TmpVersion.HighPart = FixedFileInfo->dwFileVersionMS;
    TmpVersion.LowPart = FixedFileInfo->dwFileVersionLS;

    //
    // We need to whack the low 16 bits of the .LowPart so that
    // we ignore the service pack value.  For example, WindowsXP has a
    // version number of 5.1.2600.0.  XP-ServicePack1 has a version
    // number of 5.1.2600.1038.  We'd like those to match, so just whack
    // the servicepack number portion.
    //
    TmpVersion.LowPart &= 0xFFFF0000;


    *Version = TmpVersion.QuadPart;

    fResult = TRUE;

e1:
    BinlFreeMemory(VersionInfo);
e0:
    return fResult;
}

//
// Send a message on our socket. If the message is too long, then it
// splits it into fragments of MAXIMUM_FRAGMENT_LENGTH bytes.
//

#define MAXIMUM_FRAGMENT_LENGTH 1400

DWORD
SendUdpMessage(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    BOOL bFragment,
    BOOL bResend
    )
{
    DWORD error;
    FRAGMENT_PACKET FragmentHeader;
    USHORT FragmentNumber;
    USHORT FragmentTotal;
    ULONG MessageLengthWithoutHeader;
    ULONG BytesSent;
    ULONG BytesThisSend;
    UCHAR TempMessage[1500];
    FRAGMENT_PACKET UNALIGNED * SendFragmentPacket =
                        (FRAGMENT_PACKET UNALIGNED *)TempMessage;

    TraceFunc("SendUdpMessage( )\n");

    //
    // The message starts with a signature, a length, a sequence number (all
    // four bytes), then two ushorts for fragment count and total. If
    // we have to split it we preserve this header in each packet, with
    // fragment count modified for each one.
    //

    MessageLengthWithoutHeader =
            clientState->LastResponseLength - FRAGMENT_PACKET_DATA_OFFSET;

    if (!bFragment ||
        ((FragmentTotal = (USHORT)((MessageLengthWithoutHeader + MAXIMUM_FRAGMENT_LENGTH - 1) / MAXIMUM_FRAGMENT_LENGTH)) <= 1))
    {
#ifdef _TRACE_FUNC_
        SendFragmentPacket = (FRAGMENT_PACKET UNALIGNED *)clientState->LastResponse;
        TraceFunc("Sending packet with ");
        BinlPrintDbg(( DEBUG_OSC, " SequenceNumber = %u )\n", SendFragmentPacket->SequenceNumber ));
#endif

        error = sendto(
                    RequestContext->ActiveEndpoint->Socket,
                    clientState->LastResponse,
                    clientState->LastResponseLength,
                    0,
                    &RequestContext->SourceName,
                    RequestContext->SourceNameLength
                    );

    } else {

        FragmentHeader = *((FRAGMENT_PACKET UNALIGNED *)clientState->LastResponse);  // struct copy -- save the header
        BytesSent = 0;

        for (FragmentNumber = 0; FragmentNumber < FragmentTotal; FragmentNumber++) {

            if (FragmentNumber == (FragmentTotal - 1)) {
                BytesThisSend = MessageLengthWithoutHeader - BytesSent;
            } else {
                BytesThisSend = MAXIMUM_FRAGMENT_LENGTH;
            }

            memcpy(
                TempMessage + FRAGMENT_PACKET_DATA_OFFSET,
                clientState->LastResponse + FRAGMENT_PACKET_DATA_OFFSET + (FragmentNumber * MAXIMUM_FRAGMENT_LENGTH),
                BytesThisSend);

            memcpy(SendFragmentPacket, &FragmentHeader, FRAGMENT_PACKET_DATA_OFFSET);
            SendFragmentPacket->Length = BytesThisSend + FRAGMENT_PACKET_EMPTY_LENGTH;
            SendFragmentPacket->FragmentNumber = FragmentNumber + 1;
            SendFragmentPacket->FragmentTotal = FragmentTotal;

#ifdef TEST_FAILURE
            if (FailFirstFragment) {
                FailFirstFragment = FALSE;
                BinlPrintDbg((DEBUG_OSC, "NOT sending first fragment, %ld bytes\n", BytesThisSend + FRAGMENT_PACKET_DATA_OFFSET));
                error = ERROR_SUCCESS;
            } else
#endif

            //
            // On resends, wait between fragments in case the resend is
            // because the card can't handle quick bursts of packets.
            //
            if (bResend && (FragmentNumber != 0)) {
                Sleep(10);  // wait 10 milliseconds
            }

            error = sendto(
                        RequestContext->ActiveEndpoint->Socket,
                        TempMessage,
                        BytesThisSend + FRAGMENT_PACKET_DATA_OFFSET,
                        0,
                        &RequestContext->SourceName,
                        RequestContext->SourceNameLength
                        );

            if (error == SOCKET_ERROR) {
                break;
            }

            BytesSent += BytesThisSend;

        }

    }

    if ( error == SOCKET_ERROR ) {
        error = WSAGetLastError();
        BinlPrintDbg(( DEBUG_OSC_ERROR, "Sendto() failed, error = %ld\n", error ));
    } else {
        error = ERROR_SUCCESS;
    }

    return( error );
}

//
// Verifies the packets signature is authentic
//
DWORD
OscVerifySignature(
    PCLIENT_STATE clientState,
    SIGNED_PACKET UNALIGNED * signedMessage
    )
{
    SECURITY_STATUS SecStatus;
    SecBuffer SigBuffers[2];
    ULONG MessageLength, SignLength;
    SecBufferDesc SignMessage;

    TraceFunc("OscVerifySignature( )\n");

    MessageLength = signedMessage->Length;
    SignLength = signedMessage->SignLength;

    //
    // Verify the signature
    //
    SigBuffers[0].pvBuffer = signedMessage->Data;
    SigBuffers[0].cbBuffer = MessageLength - SIGNED_PACKET_EMPTY_LENGTH;
    SigBuffers[0].BufferType = SECBUFFER_DATA;

    SigBuffers[1].pvBuffer = signedMessage->Sign;
    SigBuffers[1].cbBuffer = SignLength;
    SigBuffers[1].BufferType = SECBUFFER_TOKEN;

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

#ifndef ONLY_SIGN_MESSAGES
    SecStatus = UnsealMessage(
    &clientState->ServerContextHandle,
    &SignMessage,
    0,
    0 );
#else
    SecStatus = VerifySignature(
    &clientState->ServerContextHandle,
    &SignMessage,
    0,
    0 );
#endif

    if (SecStatus != STATUS_SUCCESS)
    {
        DWORD Error;
        SIGNED_PACKET UNALIGNED * SendSignedMessage;

        BinlPrintDbg(( DEBUG_OSC_ERROR, "Sending ERR packet from Verify/Unseal!!\n"));

        clientState->LastResponseLength = SIGNED_PACKET_ERROR_LENGTH;
        Error = OscVerifyLastResponseSize(clientState);
        if (Error != ERROR_SUCCESS) {
            return SecStatus;   // we can't send anything back
        }

        SendSignedMessage = (SIGNED_PACKET UNALIGNED *)(clientState->LastResponse);

        memcpy(SendSignedMessage->Signature, ErrorSignedSignature, 4);
        SendSignedMessage->Length = 4;
        SendSignedMessage->SequenceNumber = clientState->LastSequenceNumber;
    }

    return SecStatus;
}

//
//
//
DWORD
OscSendSignedMessage(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PCHAR Message,
    ULONG MessageLength
    )
{
    DWORD Error = ERROR_SUCCESS;
    SIGNED_PACKET UNALIGNED * SendSignedMessage;
    SecBuffer SigBuffers[2];
    SecBufferDesc SignMessage;
    SECURITY_STATUS SecStatus;

#ifdef _TRACE_FUNC_
    TraceFunc("OscSendSignedMessage( ");
    BinlPrintDbg(( DEBUG_OSC, "SequenceNumber = %u )\n", clientState->LastSequenceNumber ));
#endif

    //
    // Make sure we have space for the message
    //
    clientState->LastResponseLength = MessageLength + SIGNED_PACKET_DATA_OFFSET;
    Error = OscVerifyLastResponseSize(clientState);
    if (Error != ERROR_SUCCESS)
        return Error;

    //
    // copy the message
    //
    SendSignedMessage = (SIGNED_PACKET UNALIGNED *) clientState->LastResponse;
    memcpy(SendSignedMessage->Data, Message, MessageLength);

    //
    // sign the message
    //
    memcpy(SendSignedMessage->Signature, ResponseSignedSignature, 4);
    SendSignedMessage->Length = MessageLength + SIGNED_PACKET_EMPTY_LENGTH;
    SendSignedMessage->SequenceNumber = clientState->LastSequenceNumber;
    SendSignedMessage->FragmentNumber = 1;  // fragment count
    SendSignedMessage->FragmentTotal = 1;  // fragment total

    SendSignedMessage->SignLength = NTLMSSP_MESSAGE_SIGNATURE_SIZE;

#if 0
    //
    // Send out an unsealed copy to a different port.
    //

    {
        USHORT TmpPort;
        PCHAR TmpSignature[4];

        TmpPort = ((struct sockaddr_in *)&RequestContext->SourceName)->sin_port;
        memcpy(TmpSignature, SendSignedMessage->Signature, 4);

        ((struct sockaddr_in *)&RequestContext->SourceName)->sin_port = 0xabcd;
        memcpy(SendSignedMessage->Signature, "FAKE", 4);

        Error = SendUdpMessage(RequestContext, clientState, TRUE, FALSE);

        ((struct sockaddr_in *)&RequestContext->SourceName)->sin_port = TmpPort;
        memcpy(SendSignedMessage->Signature, TmpSignature, 4);
    }
#endif

    SigBuffers[0].pvBuffer = SendSignedMessage->Data;
    SigBuffers[0].cbBuffer = MessageLength;
    SigBuffers[0].BufferType = SECBUFFER_DATA;

    SigBuffers[1].pvBuffer = SendSignedMessage->Sign;
    SigBuffers[1].cbBuffer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
    SigBuffers[1].BufferType = SECBUFFER_TOKEN;

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

#ifndef ONLY_SIGN_MESSAGES
    SecStatus = SealMessage(
                        &clientState->ServerContextHandle,
                        0,
                        &SignMessage,
                        0 );
#else
    SecStatus = MakeSignature(
                        &clientState->ServerContextHandle,
                        0,
                        &SignMessage,
                        0 );
#endif

    //
    // Make sure the signature worked. If not, send error packet.
    //
    if (SecStatus != STATUS_SUCCESS)
    {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "Sending ERR packet from Make/Seal!!\n"));

        clientState->LastResponseLength = SIGNED_PACKET_ERROR_LENGTH;
        Error = OscVerifyLastResponseSize(clientState);
        if (Error != ERROR_SUCCESS)
            return Error;

        memcpy(SendSignedMessage->Signature, ErrorSignedSignature, 4);
        SendSignedMessage->Length = 4;
    }
    else
    {
        BinlPrintDbg(( DEBUG_OSC, "Sending RSPS, %d bytes\n", clientState->LastResponseLength));
    }

#ifdef TEST_FAILURE
    if (FailFirstResponse)
    {
        BinlPrintDbg(( DEBUG_OSC, "NOT Sending RSP, %d bytes\n", clientState->LastResponseLength));
        FailFirstResponse = FALSE;
        Error = ERROR_SUCCESS;
    } else
#endif

    Error = SendUdpMessage(RequestContext, clientState, TRUE, FALSE);

    if (Error != ERROR_SUCCESS)
    {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not send RSP message %d\n", Error ));
    }

    return Error;
}

//
//
//
DWORD
OscSendUnsignedMessage(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PCHAR Message,
    ULONG MessageLength
    )
{
    DWORD Error = ERROR_SUCCESS;
    SIGNED_PACKET UNALIGNED * SendSignedMessage;
    SecBuffer SigBuffers[2];
    SecBufferDesc SignMessage;
    SECURITY_STATUS SecStatus;

#ifdef _TRACE_FUNC_
    TraceFunc("OscSendUnsignedMessage( ");
    BinlPrintDbg(( DEBUG_OSC, "SequenceNumber = %u )\n", clientState->LastSequenceNumber ));
#endif

    //
    // Make sure we have space for the message
    //
    clientState->LastResponseLength = MessageLength + SIGNED_PACKET_DATA_OFFSET;
    Error = OscVerifyLastResponseSize(clientState);
    if (Error != ERROR_SUCCESS) {
        return Error;
    }

    //
    // copy the message
    //
    SendSignedMessage = (SIGNED_PACKET UNALIGNED *) clientState->LastResponse;
    memcpy(SendSignedMessage->Data, Message, MessageLength);

    //
    // sign the message
    //
    memcpy(SendSignedMessage->Signature, ResponseUnsignedSignature, 4);
    SendSignedMessage->Length = MessageLength + SIGNED_PACKET_EMPTY_LENGTH;
    SendSignedMessage->SequenceNumber = clientState->LastSequenceNumber;
    SendSignedMessage->FragmentNumber = 1;  // fragment count
    SendSignedMessage->FragmentTotal = 1;  // fragment total
    SendSignedMessage->SignLength = 0;

    Error = SendUdpMessage(RequestContext, clientState, TRUE, FALSE);

    if (Error != ERROR_SUCCESS)
    {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not send RSU message %d\n", Error ));
    }

    return Error;
}

DWORD
OscSendSetupMessage(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    ULONG RequestType,
    PCHAR Message,
    ULONG MessageLength
    )
{
    DWORD Error = ERROR_SUCCESS;
    SPUDP_PACKET UNALIGNED * SendMessage;

#ifdef _TRACE_FUNC_
    TraceFunc("OscSendSetupMessage( ");
    BinlPrintDbg(( DEBUG_OSC, "SequenceNumber = %u )\n", clientState->LastSequenceNumber ));
#endif

    //
    // Make sure we have space for the message
    //
    clientState->LastResponseLength = MessageLength + SPUDP_PACKET_DATA_OFFSET;
    Error = OscVerifyLastResponseSize(clientState);
    if (Error != ERROR_SUCCESS) {
        return Error;
    }

    //
    // copy the message
    //
    SendMessage = (SPUDP_PACKET UNALIGNED *) clientState->LastResponse;
    memcpy(SendMessage->Data, Message, MessageLength);

    //
    // fill in the message stuff
    //
    memcpy(SendMessage->Signature, SetupResponseSignature, 4);
    SendMessage->Length = MessageLength + SPUDP_PACKET_EMPTY_LENGTH;
    SendMessage->Status = STATUS_SUCCESS;
    SendMessage->SequenceNumber = clientState->LastSequenceNumber;
    SendMessage->RequestType = RequestType;
    SendMessage->FragmentNumber = 1;  // fragment count
    SendMessage->FragmentTotal = 1;  // fragment total

    Error = SendUdpMessage(RequestContext, clientState, TRUE, FALSE);

    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not send SPR message %d\n", Error ));
    }

    return Error;
}

#ifdef SET_ACLS_ON_CLIENT_DIRS
//
//
//
DWORD
OscSetClientDirectoryPermissions(
    PCLIENT_STATE clientState )
{
    DWORD Err = ERROR_SUCCESS;
    WCHAR DirPath[ MAX_PATH ];
    WCHAR Domain[ 80 ];
    DWORD dwDomainSize = 80;
    PSECURITY_DESCRIPTOR pSD;
    PACL pDACL;
    PSID pSID;
    BOOL bOwnerDefault;
    DWORD dwLengthRequired;
    SID_NAME_USE snu;
    PWCHAR pMachineName = OscFindVariableW( clientState, "MACHINENAME" );

    if ( !pMachineName || _snwprintf ( 
                                DirPath,
                                sizeof(DirPath) / sizeof(DirPath[0]),
                                L"%ws\\REMINST\\Clients\\%ws",
                                OscFindVariableW( clientState, "SERVERNAME" ),
                                pMachineName ) < 0 ) {
        Err = ERROR_BAD_PATHNAME;
        goto Cleanup;
    }
    DirPath[MAX_PATH-1] = L'\0'; // throw in terminating null just to be safe

    //
    // Figure out how big the machine account's SID is
    //
    LookupAccountName( NULL,
                       pMachineName,
                       pSID,
                       &dwLengthRequired,
                       Domain,
                       &dwDomainSize,
                       &snu );

    //
    // make space
    //
    pSID = (PSID) BinlAllocateMemory( dwLengthRequired );
    if ( pSID == NULL ) {
        goto OutOfMemory;
    }

    //
    // get the machine account's SID
    //
    if (!LookupAccountName( NULL, pMachineName, pSID, &dwLengthRequired, Domain, &dwDomainSize, &snu ) ) {
        goto Error;
    }

    dwLengthRequired += sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid ( pSID );
    pDACL = (PACL) BinlAllocateMemory( dwLengthRequired );
    if ( pDACL == NULL ) {
        goto OutOfMemory;
    }

    pSD = ( PSECURITY_DESCRIPTOR) BinlAllocateMemory( SECURITY_DESCRIPTOR_MIN_LENGTH + dwLengthRequired );
    if ( pSD == NULL ) {
        goto OutOfMemory;
    }

    if ( !InitializeSecurityDescriptor ( pSD, SECURITY_DESCRIPTOR_REVISION) ) {
        goto Error;
    }

    if ( !InitializeAcl( pDACL, dwLengthRequired, ACL_REVISION ) ) {
        goto Error;
    }

    if ( !AddAccessAllowedAce( pDACL, ACL_REVISION, FILE_ALL_ACCESS, pSID ) ) {
        goto Error;
    }

    if ( !IsValidAcl( pDACL ) ) {
        goto Error;
    }

    if ( !SetSecurityDescriptorDacl( pSD, TRUE, pDACL, FALSE ) ) {
        goto Error;
    }

    if ( !SetSecurityDescriptorOwner( pSD, pSID, FALSE ) ) {
        goto Error;
    }

    if ( ! IsValidSecurityDescriptor ( pSD ) ) {
        goto Error;
    }

    if ( !SetFileSecurity( DirPath,
                          OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                          pSD ) ) {
        goto Error;
    }

    goto Cleanup;

OutOfMemory:
    Err = ERROR_NOT_ENOUGH_SERVER_MEMORY;
    goto Cleanup;

Error:
    Err = GetLastError( );

Cleanup:
    if ( pSID )
        BinlFreeMemory( pSID );

    if ( pSD )
        BinlFreeMemory( pSD );

    return Err;
}
#endif // SET_ACLS_ON_CLIENT_DIRS


DWORD
OscConstructSecret(
    PCLIENT_STATE clientState,
    PWCHAR UnicodePassword,
    ULONG  UnicodePasswordLength,
    PCREATE_DATA CreateData
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    UINT i;
    WCHAR DomainBuffer[64];
    DWORD SidLength, DomainLength;
    SID_NAME_USE NameUse;
    BOOL  b;
    PCHAR pBootFile;
    PCHAR pSifFile;

    TraceFunc( "OscConstructSecret( )\n" );

    RtlZeroMemory(CreateData, sizeof(CREATE_DATA));

    //
    // Copy the machine data into the response packet
    //
    // The following fields aren't necessary unless we're supporting remote boot.
    //      UCHAR Sid[28];
    //      UCHAR Domain[32];
    //      UCHAR Name[32];
    //      UCHAR Password[32];
    //      ULONG UnicodePasswordLength;  // in bytes
    //      WCHAR UnicodePassword[32];
    //      UCHAR Installation[32];
    //      UCHAR MachineType[6];  // 'i386\0' or 'Alpha\0'
    //

    pBootFile = OscFindVariableA( clientState, "BOOTFILE" );
    if ( pBootFile[0] == L'\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "BOOTFILE" );
        return ERROR_BINL_MISSING_VARIABLE;
    }

    pSifFile = OscFindVariableA( clientState, "SIFFILE" );
    if ( pSifFile[0] == L'\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "SIFFILE" );
        return ERROR_BINL_MISSING_VARIABLE;
    }

    memcpy( CreateData->Id, "ACCT", 4);
    CreateData->VersionNumber = OSC_CREATE_DATA_VERSION;
    strncpy( CreateData->NextBootfile, pBootFile, 128 );
    CreateData->NextBootfile[128-1]='\0';
    strncpy( CreateData->SifFile, pSifFile, 128 );
    CreateData->SifFile[128-1]='\0';

    BinlAssertMsg( CreateData->NextBootfile[0],       "No boot file" );
    return dwErr;
}

DWORD
GetOurServerInfo (
    VOID
    )
//
//  This routine gets several global names that we need to handle client
//  requests.  We store them in globals because they change very infrequently
//  and they're relatively expense to retrieve.
//
{
    PWCHAR fqdn = NULL;
    DWORD uSize;
    DWORD dnsError = ERROR_SUCCESS;
    DWORD fqdnError = ERROR_SUCCESS;
    DWORD netbiosServerError = ERROR_SUCCESS;
    DWORD netbiosDomainError = ERROR_SUCCESS;
    PWCHAR ourDNSName = NULL;
    PWCHAR tmp;
    PWCHAR pDomain;
    WCHAR  ServerName[32] = { 0 };
    DWORD  ServerSize = sizeof(ServerName) / sizeof(WCHAR);
    ULONG Error;

    // first grab the netbios name of our server

    if ( !GetComputerNameEx( ComputerNameNetBIOS, ServerName, &ServerSize ) ) {
        netbiosServerError = GetLastError();
        BinlPrintDbg(( DEBUG_OSC_ERROR, "!! Error 0x%08x - GetComputerNameEx failed.\n", netbiosServerError ));
    } else {

        tmp = BinlStrDup( ServerName );

        if (tmp == NULL) {
            netbiosServerError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        } else {
            EnterCriticalSection( &gcsParameters );

            if (BinlGlobalOurServerName) {
                BinlFreeMemory( BinlGlobalOurServerName );
            }

            BinlGlobalOurServerName = tmp;

            LeaveCriticalSection( &gcsParameters );
        }
    }

    // Next grab the fully qualified domain name of our server
    uSize = 0;
    if ( !GetComputerObjectName( NameFullyQualifiedDN, NULL, &uSize ) ) {
        fqdnError = GetLastError( );
        if ( fqdnError != ERROR_MORE_DATA ) {

            BinlPrint((DEBUG_OSC_ERROR, "!! Error 0x%08x - GetComputerObjectName failed.\n", fqdnError ));
            goto GetDNS;
        }
        fqdnError = ERROR_SUCCESS;
    }
    fqdn = BinlAllocateMemory( uSize * sizeof(WCHAR) );
    if ( fqdn ) {
        if ( !GetComputerObjectName( NameFullyQualifiedDN, fqdn, &uSize ) ) {

            fqdnError = GetLastError( );
            BinlPrint((DEBUG_OSC_ERROR, "!! Error 0x%08x - GetComputerObjectName failed.\n", fqdnError ));

        } else {

            EnterCriticalSection( &gcsParameters );

            tmp = BinlGlobalOurFQDNName;
            BinlGlobalOurFQDNName = fqdn;

            fqdn = tmp;     // we'll free it below

            // next setup the netbios domain name

            pDomain = StrStrIW( BinlGlobalOurFQDNName, L"DC=" );
            if ( pDomain ) {

                PDS_NAME_RESULTW pResults;

                BinlPrintDbg(( DEBUG_OSC, "Converting %ws to a NetBIOS domain name...\n", pDomain ));

                netbiosDomainError = DsCrackNames( INVALID_HANDLE_VALUE,
                                      DS_NAME_FLAG_SYNTACTICAL_ONLY,
                                      DS_FQDN_1779_NAME,
                                      DS_CANONICAL_NAME,
                                      1,
                                      &pDomain,
                                      &pResults );
                if (netbiosDomainError != ERROR_SUCCESS) {

                    BinlPrint(( DEBUG_ERRORS, "GetOurServerInfo error in DsCrackNames %u\n", netbiosDomainError ));
                }

                if ( netbiosDomainError == ERROR_SUCCESS ) {
                    if ( pResults->cItems == 1
                      && pResults->rItems[0].status == DS_NAME_NO_ERROR
                      && pResults->rItems[0].pName ) {    // paranoid

                        pResults->rItems[0].pName[wcslen(pResults->rItems[0].pName)-1] = L'\0';

                        tmp = BinlStrDup( pResults->rItems[0].pName );
                        
                        if (tmp == NULL) {

                            netbiosDomainError = ERROR_NOT_ENOUGH_SERVER_MEMORY;

                        } else {

                            if (BinlGlobalOurDomainName) {
                                BinlFreeMemory( BinlGlobalOurDomainName );
                            }
                            BinlGlobalOurDomainName = tmp;
                        }
                    }
                    DsFreeNameResult( pResults );
                }
            }
            LeaveCriticalSection( &gcsParameters );
        }
    } else {

        fqdnError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
    }

GetDNS:
    // Retrieve the FQDNS name of the server
    uSize = 0;
    if ( !GetComputerNameEx( ComputerNameDnsFullyQualified, NULL, &uSize ) ) {
        dnsError = GetLastError( );
        if ( dnsError != ERROR_MORE_DATA ) {
            BinlPrint((DEBUG_OSC_ERROR, "!! Error 0x%08x - GetComputerNameEx failed.\n", dnsError ));
            goto returnError;
        }
        dnsError = ERROR_SUCCESS;
    }
    ourDNSName = (PWCHAR) BinlAllocateMemory( uSize * sizeof(WCHAR) );
    if ( ourDNSName ) {
        if ( !GetComputerNameEx( ComputerNameDnsFullyQualified, ourDNSName, &uSize ) ) {

            dnsError = GetLastError( );
            BinlPrint((DEBUG_OSC_ERROR, "!! Error 0x%08x - GetComputerNameEx failed.\n", dnsError ));

        } else {

            EnterCriticalSection( &gcsParameters );

            tmp = BinlGlobalOurDnsName;
            BinlGlobalOurDnsName = ourDNSName;

            LeaveCriticalSection( &gcsParameters );

            ourDNSName = tmp;   // we'll free it below
        }
    } else {
        dnsError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
    }

returnError:

    if (ourDNSName) {
        BinlFreeMemory( ourDNSName );
    }
    if (fqdn) {
        BinlFreeMemory( fqdn );
    }
    if (fqdnError != ERROR_SUCCESS) {
        Error = fqdnError;
    } else if (dnsError != ERROR_SUCCESS) {
        Error = dnsError;
    } else if (netbiosServerError != ERROR_SUCCESS) {
        Error = netbiosServerError;
    } else {
        Error = netbiosDomainError;
    }
    return Error;
}

DWORD
GetDomainNetBIOSName(
    IN PCWSTR DomainNameInAnyFormat,
    OUT PWSTR *NetBIOSName
    )
/*++

Routine Description:

    Retrieves the netbios name for a domain given an input name.  The input
    name may be in DNS form or netbios form, it doesn't really matter.

Arguments:

    DomainNameInAnyFormat - string representing the name of the domain to query

    NetBIOSName - receives string that represents the domain netbios name.  
                  The string must be freed via BinlFreeMemory.

Return Value:

    win32 error code indicating outcome.

--*/
{
    PDOMAIN_CONTROLLER_INFO DomainControllerInfo = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC DomainInfo = NULL;
    DWORD Error;

    Error = DsGetDcName( 
                    NULL, 
                    DomainNameInAnyFormat, 
                    NULL, 
                    NULL, 
                    DS_RETURN_DNS_NAME, 
                    &DomainControllerInfo );

    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg((
            DEBUG_ERRORS,
            "DsGetDcName (%ws) failed, ec = %d.\r\n",
            DomainNameInAnyFormat,
            Error ));
        goto exit;
    }

    Error = DsRoleGetPrimaryDomainInformation(
                                        DomainControllerInfo->DomainControllerName,
                                        DsRolePrimaryDomainInfoBasic,
                                        (PBYTE *) &DomainInfo);

    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg((
            DEBUG_ERRORS,
            "DsRoleGetPrimaryDomainInformation (%ws) failed, ec = %d.\r\n",
            DomainControllerInfo->DomainControllerName,
            Error ));
        goto exit;
    }

    *NetBIOSName = BinlStrDup( DomainInfo->DomainNameFlat );

    if (!*NetBIOSName) {
        BinlPrintDbg((
            DEBUG_ERRORS,
            "GetDomainNetBIOSName: failed to allocate memory (%d bytes) .\r\n",
            (wcslen(DomainInfo->DomainNameFlat)+1) * sizeof(WCHAR) ));
        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
    }

exit:
    if (DomainInfo) {
        DsRoleFreeMemory( DomainInfo );
    }

    if (DomainControllerInfo) {
        NetApiBufferFree( DomainControllerInfo );
    }

    return(Error);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\client\dhcpcmd.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpcmd.c

Abstract:

    This file contains program to test all DHCP APIs.

Author:

    Madan Appiah (madana) 5-Oct-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock.h>
#include <dhcp.h>
#include <dhcpapi.h>
#include <dhcplib.h>
#include <stdio.h>
#include <ctype.h>
#include <wchar.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <jet.h>        // for JET_cbColumnMost
#ifdef NT5
#include <mdhcsapi.h>
#endif NT5
#include <heapx.h>
#include <ipexport.h>
#include <icmpif.h>
#include <icmpapi.h>
#include <winnls.h>

#ifdef DBG
#ifdef __DHCP_USE_DEBUG_HEAP__


#pragma message ( "*** DHCPCMD will use debug heap ***" )

#define DhcpAllocateMemory(x) calloc(1,x)
#define DhcpFreeMemory(x) free(x)

#endif
#endif


typedef enum _COMMAND_CODE {
    AddIpRange,
    RemoveIpRange,
    EnumIpRanges,
    AddReservedIp,
    EnumClients,
    EnumClientsV5,
    DeleteBadClients,
    DeleteClient,
    MibCounts,
    ServerConfig,
    GetDhcpVersion,
    SetSuperScope,
    DeleteSuperScope,
    GetSuperScopeTable,
    RemoveSubscope,
    CheckDB,
    CreateSubnet,
    AddExcludeRange,
    RemoveReservedIp,
    RemoveExcludeRange,
    SetSubnetState,
    DeleteSubnet,
    CreateOption,
    DeleteOption,
    EnumOptions,
    SetGlobalOptionValue,
    SetGlobalOptionValues,
    RemoveGlobalOptionValue,
    SetSubnetOptionValue,
    RemoveSubnetOptionValue,
    SetReservedOptionValue,
    RemoveReservedOptionValue,
    GetAllOptions,
    GetAllOptionValues,
    CreateMScope,
    DeleteMScope,
    AddMScopeRange,
    EnumMScopeClients,
    ReconcileMScope,
    EnumMScopes,
    MCastMibCounts,
    CreateClass,
    DeleteClass,
    EnumClasses,
    AddServer,
    DelServer,
    EnumServers,
    GetServerStatus,
    RetryAuthorization,
    GetBindings,
    SetBinding,
    UnknownCommand
} COMMAND_CODE, *LPCOMMAND_CODE;

typedef struct _COMMAND_INFO {
    LPSTR CommandName;
    COMMAND_CODE CommandCode;
} COMMAND_INFO, *LPCOMMAND_INFO;

LPWSTR GlobalServerIpAddressUnicodeString = NULL;
LPSTR GlobalServerIpAddressAnsiString = NULL;
LPWSTR GlobalClassName = NULL;
LPWSTR GlobalVendorName = NULL;
BOOL   GlobalIsVendor = FALSE;
BOOL   GlobalNoRPC = FALSE;
BOOL   GlobalNoDS = TRUE;

DWORD GlobalClientCount;
DWORD g_dwMajor = (DWORD) -1 ,
      g_dwMinor = (DWORD) -1; // version control

#define CLASS_ID_VERSION  0x5

COMMAND_INFO GlobalCommandInfo[] = {
    // global server stuff.
    {"MibCounts",             MibCounts },
    {"GetVersion",            GetDhcpVersion },
    {"ServerConfig",          ServerConfig },

    // subnet stuff
    {"CreateSubnet",          CreateSubnet },
    {"DeleteSubnet",          DeleteSubnet },
    {"SetSubnetState",        SetSubnetState },

    // ranges
    {"AddIpRange",            AddIpRange },
    {"RemoveIpRange",         RemoveIpRange },
#ifdef NT5
    {"EnumIpRanges",          EnumIpRanges },
#endif NT5
    {"AddExcludeRange",       AddExcludeRange },
    {"RemoveExcludeRange",    RemoveExcludeRange },

    // active leases
    {"EnumClients",           EnumClients },
    {"DeleteBadClients",      DeleteBadClients },
    {"DeleteClient",          DeleteClient },
#ifdef NT5
    {"EnumClientsV5",         EnumClientsV5 },
#endif NT5

    // reservations
    {"AddReservedIp",         AddReservedIp },
    {"RemoveReservedIp",      RemoveReservedIp },

    // super-scoping
    {"SetSuperScope",         SetSuperScope },
    {"DeleteSuperScope",      DeleteSuperScope },
    {"GetSuperScopeTable",    GetSuperScopeTable },
    {"RemoveSubscope",        RemoveSubscope },

    // reconcile
    {"CheckDB",               CheckDB },

    // options
    {"CreateOption",          CreateOption },
    {"DeleteOption",          DeleteOption },
    {"SetGlobalOptionValue",  SetGlobalOptionValue },
    {"SetGlobalOptionValues", SetGlobalOptionValues },
    {"RemoveGlobalOptionValue", RemoveGlobalOptionValue },
    {"SetSubnetOptionValue",  SetSubnetOptionValue },
    {"RemoveSubnetOptionValue", RemoveSubnetOptionValue },
    {"SetReservedOptionValue",SetReservedOptionValue },
    {"RemoveReservedOptionValue", RemoveReservedOptionValue },
    {"EnumOptions",           EnumOptions},

#ifdef NT5
    {"GetAllOptions",         GetAllOptions },
    {"GetAllOptionValues",    GetAllOptionValues },

    // multicast stuff
    {"CreateMScope",          CreateMScope},
    {"DeleteMScope",          DeleteMScope},
    {"AddMScopeIpRange",      AddMScopeRange},
    {"EnumMScopeClients",     EnumMScopeClients},
    {"ReconcileMScope",       ReconcileMScope},
    {"EnumMScopes",           EnumMScopes},
    {"MCastMibCounts",           MCastMibCounts},

    // classes
    {"CreateClass",           CreateClass},
    {"DeleteClass",           DeleteClass},
    {"EnumClasses",           EnumClasses},

    // servers
    {"AddServer",             AddServer},
    {"DeleteServer",          DelServer},
    {"EnumServers",           EnumServers},

    {"GetServerStatus",       GetServerStatus},
    {"RetryAuthorization",    RetryAuthorization},

    {"GetBindings",           GetBindings},
    {"SetBinding",            SetBinding}
#endif NT5
};

typedef enum _CONFIG_COMMAND_CODE {
    ConfigAPIProtocolSupport,
    ConfigDatabaseName,
    ConfigDatabasePath,
    ConfigBackupPath,
    ConfigBackupInterval,
    ConfigDatabaseLoggingFlag,
    ConfigRestoreFlag,
    ConfigDatabaseCleanupInterval,
    ConfigDebugFlag,
    ConfigActivityLog,
    ConfigPingRetries,
    ConfigBootFileTable,
    UnknownConfigCommand
} CONFIG_COMMAND_CODE, *LPCONFIG_COMMAND_CODE;

typedef struct _CONFIG_COMMAND_INFO {
    LPSTR CommandName;
    CONFIG_COMMAND_CODE CommandCode;
} CONFIG_COMMAND_INFO, *LPCONFIG_COMMAND_INFO;

CONFIG_COMMAND_INFO GlobalConfigCommandInfo[] =
{
    {"APIProtocolSupport",           ConfigAPIProtocolSupport },
    {"DatabaseName",                 ConfigDatabaseName },
    {"DatabasePath",                 ConfigDatabasePath },
    {"BackupPath",                   ConfigBackupPath },
    {"BackupInterval",               ConfigBackupInterval },
    {"DatabaseLoggingFlag",          ConfigDatabaseLoggingFlag },
    {"RestoreFlag",                  ConfigRestoreFlag },
    {"DatabaseCleanupInterval",      ConfigDatabaseCleanupInterval },
    {"DebugFlag",                    ConfigDebugFlag },
    {"ActivityLog",                  ConfigActivityLog },
    {"PingRetries",                  ConfigPingRetries },
    {"BootFileTable",                ConfigBootFileTable }
};




#define DHCPCMD_VERSION_MAJOR   4
#define DHCPCMD_VERSION_MINOR   1


#if DBG

VOID
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{

#define WSTRSIZE( wsz ) ( ( wcslen( wsz ) + 1 ) * sizeof( WCHAR ) )

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length = 0;

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    va_end(arglist);

     DhcpAssert(length <= MAX_PRINTF_LEN);

    //
    // Output to the debug terminal,
    //

    DbgPrint( "%s", OutputBuffer);
}

#endif // DBG
DWORD
SetOptionDataType(
    LPSTR OptionTypeString,
    LPSTR OptionValueString,
    LPDHCP_OPTION_DATA_ELEMENT OptionData,
    LPWSTR *UnicodeOptionValueString
    )
{
    DHCP_OPTION_DATA_TYPE OptionType;
    DHCP_OPTION_ID OptionValue;

    if( _stricmp( OptionTypeString, "BYTE") == 0 ) {
        OptionType = DhcpByteOption;
    } else if( _stricmp( OptionTypeString, "WORD") == 0 ) {
        OptionType = DhcpWordOption;
    } else if( _stricmp( OptionTypeString, "DWORD") == 0 ) {
        OptionType = DhcpDWordOption;
    } else if( _stricmp( OptionTypeString, "STRING") == 0 ) {
        OptionType = DhcpStringDataOption;
    } else if( _stricmp( OptionTypeString, "IPADDRESS") == 0 ) {
        OptionType = DhcpIpAddressOption;
    } else {
        printf("OptionType either Unknown or not supported, %s.\n",
                OptionTypeString );
        return( ERROR_INVALID_PARAMETER );
    }

    OptionData->OptionType = OptionType;

    switch( OptionType ) {
    case DhcpByteOption:
        OptionValue = strtoul( OptionValueString, NULL, 0 );

        if( OptionValue & ~((BYTE)-1) ) {
            printf("DefValue is too large (%ld).\n", OptionValue );
            return( ERROR_INVALID_PARAMETER );
        }

        OptionData->Element.ByteOption = (BYTE)OptionValue;
        break;

    case DhcpWordOption:
        OptionValue = strtoul( OptionValueString, NULL, 0 );

        if( OptionValue & ~((WORD)-1) ) {
            printf("DefValue is too large (%ld).\n", OptionValue );
            return( ERROR_INVALID_PARAMETER );
        }

        OptionData->Element.WordOption = (WORD)OptionValue;
        break;

    case DhcpDWordOption:
        OptionValue = strtoul( OptionValueString, NULL, 0 );
        OptionData->Element.DWordOption = (DWORD)OptionValue;
        break;


    case DhcpIpAddressOption:
        OptionData->Element.IpAddressOption =
            DhcpDottedStringToIpAddress(OptionValueString);
        break;

    case DhcpStringDataOption:
        *UnicodeOptionValueString =
            DhcpOemToUnicode( OptionValueString, NULL );
        if( UnicodeOptionValueString == NULL ) {
            return( ERROR_NOT_ENOUGH_MEMORY );
        }
        OptionData->Element.StringDataOption = *UnicodeOptionValueString;
        break;

    default:
        DhcpAssert(FALSE);
        printf("CreateOptionValue: Unknown OptionType \n");
        return( ERROR_INVALID_PARAMETER );
        break;
    }

    return( ERROR_SUCCESS );
}

COMMAND_CODE
DecodeCommand(
    LPSTR CommandName
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalCommandInfo) / sizeof(COMMAND_INFO);
    DhcpAssert( NumCommands <= UnknownCommand );
    for( i = 0; i < NumCommands; i++) {
        if( _stricmp( CommandName, GlobalCommandInfo[i].CommandName ) == 0 ) {
            return( GlobalCommandInfo[i].CommandCode );
        }
    }
    return( UnknownCommand );
}

VOID
PrintCommands(
    VOID
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalCommandInfo) / sizeof(COMMAND_INFO);
    DhcpAssert( NumCommands <= UnknownCommand );
    for( i = 0; i < NumCommands; i++) {
        printf( "    %s\n", GlobalCommandInfo[i].CommandName );
    }
}


DWORD
ProcessCreateSubnet(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_SUBNET_INFO SubnetInfo;
    LPWSTR UnicodeSubnetName = NULL;

    //
    // Expected Parameters are : <SubnetAddress SubnetMask SubnetName>
    //


    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress CreateSubnet [Command Parameters].\n"
            "<Command Parameters> - <SubnetAddress SubnetMask SubnetName>.\n" );
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    SubnetInfo.SubnetAddress =
        DhcpDottedStringToIpAddress(CommandArgv[0]);
    SubnetInfo.SubnetMask =
        DhcpDottedStringToIpAddress(CommandArgv[1]);

    UnicodeSubnetName = DhcpOemToUnicode( CommandArgv[2], NULL );
    DhcpAssert( UnicodeSubnetName != NULL );

    SubnetInfo.SubnetName = UnicodeSubnetName;
    SubnetInfo.SubnetComment = NULL;
    SubnetInfo.PrimaryHost.IpAddress =
        DhcpDottedStringToIpAddress(GlobalServerIpAddressAnsiString);

    SubnetInfo.PrimaryHost.NetBiosName = NULL;
    SubnetInfo.PrimaryHost.HostName = NULL;
    SubnetInfo.SubnetState = DhcpSubnetEnabled;

    Error = DhcpCreateSubnet(
                GlobalServerIpAddressUnicodeString,
                SubnetInfo.SubnetAddress,
                &SubnetInfo );

Cleanup:

    if( UnicodeSubnetName != NULL ) {
        DhcpFreeMemory( UnicodeSubnetName );
    }

    return( Error );
}

BOOL
IsValidServerVersion(
    DWORD dwMajor,
    DWORD dwMinor
    )
{
    DWORD dwServerVersion = MAKEWORD( dwMinor, dwMajor );
    return ( dwServerVersion >=
         MAKEWORD( DHCPCMD_VERSION_MINOR,
                   DHCPCMD_VERSION_MAJOR ));
}

DWORD
ProcessAddIpRange(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    ULONG MajorVersion, MinorVersion;
    ULONG Resume;
    DHCP_IP_RANGE IpRange;
    DHCP_SUBNET_ELEMENT_DATA Element;
    DHCP_SUBNET_ELEMENT_TYPE ElementType;

    //
    // Expected Parameters are : <SubnetAddress IpRangeStart IpRangeEnd>
    //

    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress AddIpRange  [Command Parameters].\n"
            "<Command Parameters> - <SubnetAddress IpRangeStart IpRangeEnd>.\n" );
        return( ERROR_SUCCESS );
    }

    IpRange.StartAddress = DhcpDottedStringToIpAddress(CommandArgv[1]);
    IpRange.EndAddress = DhcpDottedStringToIpAddress(CommandArgv[2]);

    Element.ElementType = DhcpIpRanges;
    Element.Element.IpRange = &IpRange;

#ifdef NT5
    if( CommandArgc >= 4 ) {
        DHCP_BOOTP_IP_RANGE ThisRange = {IpRange.StartAddress, IpRange.EndAddress, 0, ~0};

        Element.Element.IpRange = (PVOID)&ThisRange;
        if( GlobalNoRPC ) {
            MajorVersion = CLASS_ID_VERSION;
        } else {
            Error = DhcpGetVersion(GlobalServerIpAddressUnicodeString, &MajorVersion, &MinorVersion);
            if( ERROR_SUCCESS != Error ) {
                printf("Could not determine server version\n");
                return Error;
            }
        }

        if( MajorVersion >= CLASS_ID_VERSION ) {
            if( CommandArgc >= 5 ) {
                ThisRange.MaxBootpAllowed = strtoul( CommandArgv[4], NULL, 0 ) ;
            }

            if( 0 == _stricmp(CommandArgv[3], "DHCP") ) {
                Element.ElementType = DhcpIpRangesDhcpOnly;
            } else if( 0 == _stricmp(CommandArgv[3], "BOOTP") ) {
                Element.ElementType = DhcpIpRangesBootpOnly;
            } else if( 0 == _stricmp(CommandArgv[3], "DHCPBOOTP" ) ) {
                Element.ElementType = DhcpIpRangesDhcpBootp;
            } else {
                printf("usage:DhcpCmd SrvIpAddress AddIpRange [Command Parameters].\n"
                       "<CommandParameters> - <SubnetAddress IpRangeStart"
                       " IpRangeEnd (DHCP | BOOTP | DHCPBOOTP)>\n");
                return ERROR_SUCCESS;
            }

            return DhcpAddSubnetElementV5(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                (PVOID)&Element
                );
        }
    }
#endif

    Error = DhcpAddSubnetElement(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                &Element );

    return( Error );
}

DWORD
ProcessRemoveIpRange(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    ULONG MajorVersion, MinorVersion;
    DHCP_IP_RANGE IpRange;
    DHCP_SUBNET_ELEMENT_DATA Element;
    DHCP_SUBNET_ELEMENT_TYPE ElementType;

    //
    // Expected Parameters are : <SubnetAddress IpRangeStart IpRangeEnd>
    //

    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress RemoveIpRange  [Command Parameters].\n"
            "<Command Parameters> - <SubnetAddress IpRangeStart IpRangeEnd>.\n" );
        return( ERROR_SUCCESS );
    }

    IpRange.StartAddress = DhcpDottedStringToIpAddress(CommandArgv[1]);
    IpRange.EndAddress = DhcpDottedStringToIpAddress(CommandArgv[2]);

    Element.ElementType = DhcpIpRanges;
    Element.Element.IpRange = &IpRange;

#ifdef NT5
    if( CommandArgc >= 4 ) {
        if( GlobalNoRPC ) {
            MajorVersion = CLASS_ID_VERSION;
        } else {
            Error = DhcpGetVersion(GlobalServerIpAddressUnicodeString, &MajorVersion, &MinorVersion);
            if( ERROR_SUCCESS != Error ) {
                printf("Could not determine server version\n");
                return Error;
            }
        }

        if( MajorVersion >= CLASS_ID_VERSION ) {
            if( 0 == _stricmp(CommandArgv[3], "DHCP") ) {
                Element.ElementType = DhcpIpRangesDhcpOnly;
            } else if( 0 == _stricmp(CommandArgv[3], "BOOTP") ) {
                Element.ElementType = DhcpIpRangesBootpOnly;
            } else if( 0 == _stricmp(CommandArgv[3], "DHCPBOOTP" ) ) {
                Element.ElementType = DhcpIpRangesDhcpBootp;
            } else {
                printf("usage:DhcpCmd SrvIpAddress AddIpRange [Command Parameters].\n"
                       "<CommandParameters> - <SubnetAddress IpRangeStart"
                       " IpRangeEnd (DHCP | BOOTP | DHCPBOOTP)>\n");
                return ERROR_SUCCESS;
            }

            return DhcpRemoveSubnetElementV5(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                (PVOID)&Element,
                FALSE
                );
        }
    }
#endif

    Error = DhcpRemoveSubnetElement(
        GlobalServerIpAddressUnicodeString,
        DhcpDottedStringToIpAddress(CommandArgv[0]),
        &Element,
        FALSE
        );

    return( Error );
}

#ifdef NT5
VOID
PrintRange(
    DHCP_SUBNET_ELEMENT_TYPE Type,
    DHCP_IP_ADDRESS Start,
    DHCP_IP_ADDRESS End,
    ULONG BootpAllocated,
    ULONG MaxBootpAllowed
)
{
    printf("Range: %s -", DhcpIpAddressToDottedString( Start ) );
    printf("%s ", DhcpIpAddressToDottedString( End ) );

    switch(Type ) {
    case DhcpIpRanges : printf("\n"); break;
    case DhcpIpRangesDhcpOnly : printf("DHCP\n"); break;
    case DhcpIpRangesDhcpBootp:
        printf("DHCPBOOTP Bootp Clients leased = %d; Max Allowed BootpClients = %ld\n",
               BootpAllocated, MaxBootpAllowed
            );
        break;
    case DhcpIpRangesBootpOnly:
        printf("BOOTP     Bootp Clients leased = %d; Max Allowed BootpClients = %ld\n",
               BootpAllocated, MaxBootpAllowed
            );
        break;
    default: printf("Unknown range type: %ld\n", Type);
    }
}

DWORD
ProcessEnumIpRanges(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    ULONG Error;
    ULONG MajorVersion, MinorVersion;
    ULONG nRead, nTotal, i;
    ULONG Resume;
    BOOL fIsV5Call;
    DHCP_SUBNET_ELEMENT_TYPE ElementType;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Elements4;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 Elements5;

    if( CommandArgc < 1 ) {
        printf("usage:DhcpCmd SrvIpAddress EnumIpRanges <SubnetAddress>\n");
        return ERROR_SUCCESS;
    }

    Error = DhcpGetVersion(GlobalServerIpAddressUnicodeString, &MajorVersion, &MinorVersion);
    if( MajorVersion >= CLASS_ID_VERSION ) {
        fIsV5Call = TRUE;
    } else {
        fIsV5Call = FALSE;
    }

    Resume = 0;
    while( TRUE ) {
        Elements5 = NULL;
        Elements4 = NULL;
        nRead = nTotal = 0;

        if( fIsV5Call ) {
            Error = DhcpEnumSubnetElementsV5(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                DhcpIpRangesDhcpBootp,
                &Resume,
                ~0,
                &Elements5,
                &nRead,
                &nTotal
                );
        } else {
            Error = DhcpEnumSubnetElementsV4(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                DhcpIpRangesDhcpBootp,
                &Resume,
                ~0,
                &Elements4,
                &nRead,
                &nTotal
                );
        }

        if( ERROR_SUCCESS == Error || ERROR_MORE_DATA == Error ) {
            for( i = 0; i < nRead ; i ++ ) {
                if( fIsV5Call ) {
                    PrintRange(
                        Elements5->Elements[i].ElementType,
                        Elements5->Elements[i].Element.IpRange->StartAddress,
                        Elements5->Elements[i].Element.IpRange->EndAddress,
                        Elements5->Elements[i].Element.IpRange->BootpAllocated,
                        Elements5->Elements[i].Element.IpRange->MaxBootpAllowed
                        );
                } else {
                    PrintRange(
                        Elements4->Elements[i].ElementType,
                        Elements4->Elements[i].Element.IpRange->StartAddress,
                        Elements4->Elements[i].Element.IpRange->EndAddress,
                        0,
                        0
                        );
                }
            }
        }

        if( Elements4 ) DhcpRpcFreeMemory( Elements4 );
        if( Elements5 ) DhcpRpcFreeMemory( Elements5 );
        if( ERROR_SUCCESS == Error || ERROR_NO_MORE_ITEMS == Error ) break;
        if( ERROR_MORE_DATA != Error ) return Error;
    }

    return ERROR_SUCCESS;
}

#endif NT5

#define COMMAND_ARG_TYPE        5

DWORD
ProcessBootpParameters(
    DWORD                    cArgs,
    LPSTR                   *ppszArgs,
    DHCP_IP_RESERVATION_V4   *pReservation
)
{
    DWORD dwResult = ERROR_SUCCESS;


    if ( cArgs > COMMAND_ARG_TYPE )
    {
        // user specified the allowed client type

        if ( !_stricmp( ppszArgs[ COMMAND_ARG_TYPE ], "bootp" ) )
        {
            pReservation->bAllowedClientTypes = CLIENT_TYPE_BOOTP;
        }
        else if ( !_stricmp ( ppszArgs[ COMMAND_ARG_TYPE ], "dhcp" ) )
        {
            pReservation->bAllowedClientTypes = CLIENT_TYPE_DHCP;
        }
        else if ( !_stricmp ( ppszArgs[ COMMAND_ARG_TYPE ], "both" ) )
        {
            pReservation->bAllowedClientTypes = CLIENT_TYPE_BOTH;
        }
        else
        {
            printf( "Specify BOOTP, DHCP, or BOTH for reservation type.\n" );
            return ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        // allow dhcp clients by default.
        pReservation->bAllowedClientTypes = CLIENT_TYPE_DHCP;
        return ERROR_SUCCESS;
    }

    return dwResult;
}



DWORD
ProcessAddReservedIp(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
#define MAX_ADDRESS_LENGTH  64  // 64 bytes
#define COMMAND_ARG_CLIENT_COMMENT  4

    DWORD Error;
    DHCP_SUBNET_ELEMENT_DATA_V4 Element;
    DHCP_IP_RESERVATION_V4 ReserveElement;
    DHCP_CLIENT_UID ClientUID;
    BYTE  Address[MAX_ADDRESS_LENGTH];
    DWORD i;
    DHCP_IP_ADDRESS ReservedIpAddress;

    //
    // Expected Parameters are : <SubnetAddress ReservedIp HWAddressString>
    //

    //
    // if the server version is 4.1 or greater, <AllowedClientTypes> and <BootFileString> can
    // also be supplied
    //


    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress AddReservedIp "
            "[Command Parameters].\n"
            "<Command Parameters> - "
            "<SubnetAddress ReservedIp HWAddressString [ClientName] [ClientComment]"
            " [DHCP | BOOTP | BOTH]>\n" );

        return( ERROR_SUCCESS );
    }

    //
    // make HardwareAddress.
    //

    ClientUID.DataLength = strlen(CommandArgv[2]);
    if( ClientUID.DataLength % 2 != 0 ) {
        //
        // address must be even length.
        //

        printf("ProcessAddReservedIp: address must be even length.\n");
        return( ERROR_INVALID_PARAMETER );
    }

    ClientUID.DataLength /= 2;
    DhcpAssert( ClientUID.DataLength < MAX_ADDRESS_LENGTH );

    i = DhcpStringToHwAddress( (LPSTR)Address, CommandArgv[2] );
    DhcpAssert( i == ClientUID.DataLength );
    ClientUID.Data = Address;

    //
    // make reserve element.
    //

    ReservedIpAddress = DhcpDottedStringToIpAddress(CommandArgv[1]);
    ReserveElement.ReservedIpAddress = ReservedIpAddress;
    ReserveElement.ReservedForClient = &ClientUID;

    Element.ElementType = DhcpReservedIps;
    Element.Element.ReservedIp = &ReserveElement;

    Error = ProcessBootpParameters( CommandArgc, CommandArgv, &ReserveElement );
    if ( ERROR_SUCCESS != Error )
    {
        return Error;
    }

    Error = DhcpAddSubnetElementV4(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                &Element );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    // if we are asked to set the client name, do so.
    //

    if( CommandArgc > 3 ) {

        DHCP_SEARCH_INFO ClientSearchInfo;
        LPDHCP_CLIENT_INFO_V4 ClientInfo = NULL;
        LPWSTR UnicodeClientName = NULL;
        LPWSTR UnicodeClientComment = NULL;

        //
        // set client name.
        //

        ClientSearchInfo.SearchType = DhcpClientIpAddress;
        ClientSearchInfo.SearchInfo.ClientIpAddress = ReservedIpAddress;

        do {

            Error = DhcpGetClientInfoV4(
                        GlobalServerIpAddressUnicodeString,
                        &ClientSearchInfo,
                        &ClientInfo );

            if( Error != ERROR_SUCCESS ) {
                break;
            }

            UnicodeClientName =  DhcpOemToUnicode( CommandArgv[3], NULL );

            if( UnicodeClientName == NULL ) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            if ( ( wcslen( UnicodeClientName ) + 1 ) * sizeof(WCHAR) > JET_cbColumnMost ) {
                printf("ProcessAddReservedIp: Client Name too long\n");
                Error = ERROR_INVALID_PARAMETER;
                break;
            }

            //
            // if client comment is also given in the argument, store that
            // as well.
            //
            if ( CommandArgc > COMMAND_ARG_CLIENT_COMMENT ) {

                UnicodeClientComment    =   DhcpOemToUnicode( CommandArgv[COMMAND_ARG_CLIENT_COMMENT], NULL );

                if (!UnicodeClientComment ) {
                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                //
                // check the size here.
                //
                if ( ( wcslen( UnicodeClientComment ) + 1 ) * sizeof(WCHAR) > JET_cbColumnMost ) {
                    printf("ProcessAddReservedIp: Client Comment too long\n");
                    Error = ERROR_INVALID_PARAMETER;
                    break;
                }

                ClientInfo->ClientComment = UnicodeClientComment;



            }

            ClientInfo->ClientName = UnicodeClientName;

        } while ( FALSE );

        if ( Error == ERROR_SUCCESS ) {

            Error = DhcpSetClientInfoV4(
                        GlobalServerIpAddressUnicodeString,
                        ClientInfo );

        } else {
            //
            // Cleanup.
            //
            if ( ClientInfo ) {
                DhcpRpcFreeMemory( ClientInfo );
            }
            if ( UnicodeClientName ) {
                DhcpFreeMemory( UnicodeClientName );
            }
            if ( UnicodeClientComment ) {
                DhcpFreeMemory( UnicodeClientComment );
            }
        }

    } // if( CommandArgc > 3 )


    return( Error );
}

DWORD
ProcessAddExcludeRange(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_IP_RANGE IpRange;
    DHCP_SUBNET_ELEMENT_DATA Element;

    //
    // Expected Parameters are : <SubnetAddress IpRangeStart IpRangeEnd>
    //


    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress AddExcludeRange  [Command Parameters].\n"
            "<Command Parameters> - <SubnetAddress IpRangeStart IpRangeEnd>.\n" );
        return( ERROR_SUCCESS );
    }

    IpRange.StartAddress = DhcpDottedStringToIpAddress(CommandArgv[1]);
    IpRange.EndAddress = DhcpDottedStringToIpAddress(CommandArgv[2]);

    Element.ElementType = DhcpExcludedIpRanges;
    Element.Element.IpRange = &IpRange;

    Error = DhcpAddSubnetElement(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                &Element );

    return( Error );
}

DWORD
ProcessRemoveExcludeRange(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_SUBNET_ELEMENT_DATA Element;
    DHCP_IP_RANGE IpRange;

    //
    // Expected Parameters are : <SubnetAddress IpRangeStart IpRangeEnd>
    //


    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress RemoveExcludeRange  [Command Parameters].\n"
            "<Command Parameters> - <SubnetAddress IpRangeStart IpRangeEnd>.\n" );
        return( ERROR_SUCCESS );
    }

    IpRange.StartAddress = DhcpDottedStringToIpAddress(CommandArgv[1]);
    IpRange.EndAddress = DhcpDottedStringToIpAddress(CommandArgv[2]);

    Element.ElementType = DhcpExcludedIpRanges;
    Element.Element.ExcludeIpRange = &IpRange;

    Error = DhcpRemoveSubnetElement(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                &Element,
                DhcpFullForce );

    return( Error );
}

DWORD
ProcessRemoveReservedIp(
    DWORD CommandArgc,
    LPSTR *CommandArgv
    )
{
    DWORD Error;
    DHCP_SUBNET_ELEMENT_DATA_V4 Element;
    DHCP_IP_RESERVATION_V4 ReserveElement;
    DHCP_CLIENT_UID ClientUID;
    BYTE  Address[MAX_ADDRESS_LENGTH];
    DWORD i;

    //
    // Expected Parameters are : <SubnetAddress ReservedIp HWAddressString>
    //


    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress RemoveReservedIp "
                    "[Command Parameters].\n"
                    "<Command Parameters> - "
                    "<SubnetAddress ReservedIp HWAddressString>.\n" );

        return( ERROR_SUCCESS );
    }

    //
    // make HardwareAddress.
    //

    ClientUID.DataLength = strlen(CommandArgv[2]);
    if( ClientUID.DataLength % 2 != 0 ) {
        //
        // address must be even length.
        //

        printf("ProcessAddReservedIp: address must be even length.\n");
        return( ERROR_INVALID_PARAMETER );
    }

    ClientUID.DataLength /= 2;
    DhcpAssert( ClientUID.DataLength < MAX_ADDRESS_LENGTH );

    i = DhcpStringToHwAddress( (LPSTR)Address, CommandArgv[2] );
    DhcpAssert( i == ClientUID.DataLength );
    ClientUID.Data = Address;

    //
    // make reserve element.
    //

    ReserveElement.ReservedIpAddress = DhcpDottedStringToIpAddress(CommandArgv[1]);
    ReserveElement.ReservedForClient = &ClientUID;

    Element.ElementType = DhcpReservedIps;
    Element.Element.ReservedIp = &ReserveElement;

    Error = DhcpRemoveSubnetElementV4(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                &Element,
                DhcpFullForce );

    return( Error );
}

DWORD
ProcessSetSubnetState(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    LPDHCP_SUBNET_INFO SubnetInfo;
    LPWSTR UnicodeSubnetName = NULL;
    DWORD State;

    //
    // Expected Parameters are : <SubnetAddress SubnetMask SubnetName>
    //


    if( CommandArgc < 2 ) {
        printf("usage:DhcpCmd SrvIpAddress SetSubnetState [Command Parameters].\n"
            "<Command Parameters> - <SubnetAddress State>.\n" );
        Error = ERROR_SUCCESS;
        return( Error );
    }

    Error = DhcpGetSubnetInfo(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                &SubnetInfo );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    State = strtoul( CommandArgv[1], NULL, 0 );

    if( State == 0 ) {
        if( SubnetInfo->SubnetState == DhcpSubnetEnabled ) {
            Error = ERROR_SUCCESS;
            goto Cleanup;
        }
        SubnetInfo->SubnetState = DhcpSubnetEnabled;
    }
    else {
        if( SubnetInfo->SubnetState == DhcpSubnetDisabled ) {
            Error = ERROR_SUCCESS;
            goto Cleanup;
        }
        SubnetInfo->SubnetState = DhcpSubnetDisabled;
    }

    Error = DhcpSetSubnetInfo(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                SubnetInfo );
Cleanup:

    if( SubnetInfo != NULL ) {
        DhcpFreeMemory( SubnetInfo );
    }

    return( Error );

}

DWORD
ProcessDeleteSubnet(
    IN      DWORD                  CommandArgc,
    IN      LPSTR                  CommandArgv[]
)
{
    DWORD                          Error;
    DHCP_IP_ADDRESS                SubnetAddress;
    DHCP_FORCE_FLAG                ForceFlag;

    //
    // Expected Parameters are :
    //  <SubnetAddress ForceFlag>
    // <ForceFlag> : "DhcpFullForce" "DhcpNoForce"

    if( CommandArgc != 2 ) {
        printf("usage: DhcpCmd SrvIpAddress DeleteSubnet [Command Parameters].\n"
               "<CommandParameters> - <SubnetAddress ForceFlag>.\n");
        printf("<ForceFlag> : <DhcpFullForce | DhcpNoForce>.\n");
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    SubnetAddress = DhcpDottedStringToIpAddress( CommandArgv[0] );
    if( 0 == _stricmp(CommandArgv[1], "DhcpFullForce" ) ) {
        ForceFlag = DhcpFullForce;
    } else if( 0 == _stricmp(CommandArgv[1], "DhcpNoForce" ) ) {
        ForceFlag = DhcpNoForce;
    } else {
        printf("Unknown force flag value: %s (expecting DhcpFullForce or DhcpNoForce)\n",
               CommandArgv[1]);
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    Error = DhcpDeleteSubnet(
        GlobalServerIpAddressUnicodeString,
        SubnetAddress,
        ForceFlag
    );

  Cleanup:

    return Error;
}

DWORD
_CreateOption(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      DHCP_OPTION           *OptionInfo
)
{
    DWORD                          MajorVersion, MinorVersion;
    DWORD                          Error;

#ifdef NT5
    if( GlobalNoRPC ) {
        MajorVersion = CLASS_ID_VERSION ;
    } else {
        Error = DhcpGetVersion(ServerAddress, &MajorVersion, &MinorVersion);
        if( ERROR_SUCCESS != Error ) {
            printf("Could not determine server version.\n");
            return Error;
        }
    }

    if( MajorVersion >= CLASS_ID_VERSION ) {
        return DhcpCreateOptionV5(
            ServerAddress,
            GlobalIsVendor ? Flags | DHCP_FLAGS_OPTION_IS_VENDOR : Flags,
            OptionId,
            ClassName,
            VendorName,
            OptionInfo
        );
    }

    // incorrect version, just do like before..
#endif

    return DhcpCreateOption(
        ServerAddress,
        OptionId,
        OptionInfo
    );
}

ProcessCreateOption(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_OPTION OptionInfo;
    DHCP_OPTION_ID OptionID;
    LPWSTR UnicodeOptionName = NULL;
    LPWSTR UnicodeOptionValueString = NULL;
    DHCP_OPTION_DATA_ELEMENT OptionData;

    //
    // Expected Parameters are :
    //  <OptionID OptionName DefValueType DefValue>
    //


    if( CommandArgc < 2 ) {
        printf("usage:DhcpCmd SrvIpAddress CreateOption [Command Parameters].\n"
            "<Command Parameters> - <OptionID OptionName <DefValueType DefValue>>.\n");
        printf("<DefValueType> : <BYTE | WORD | DWORD | STRING | IPADDRESS>.\n");
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    OptionID = strtoul( CommandArgv[0], NULL, 0 );

    OptionInfo.OptionID = OptionID;

    UnicodeOptionName = DhcpOemToUnicode( CommandArgv[1], NULL );
    if( UnicodeOptionName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    OptionInfo.OptionName = UnicodeOptionName;
    OptionInfo.OptionComment = NULL;

    if( CommandArgc >= 4 ) {
        Error = SetOptionDataType(
            CommandArgv[2],
            CommandArgv[3],
            &OptionData,
            &UnicodeOptionValueString
        );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        OptionInfo.DefaultValue.NumElements = 1;
        OptionInfo.DefaultValue.Elements = &OptionData;
    }
    else {
        OptionInfo.DefaultValue.NumElements = 0;
        OptionInfo.DefaultValue.Elements = NULL;
    }

    OptionInfo.OptionType = DhcpUnaryElementTypeOption;

    Error = _CreateOption(
        GlobalServerIpAddressUnicodeString,
        0,
        OptionID,
        GlobalClassName,
        GlobalVendorName,
        &OptionInfo
    );

Cleanup:
    if( UnicodeOptionName != NULL ) {
        DhcpFreeMemory( UnicodeOptionName );
    }

    if( UnicodeOptionValueString != NULL ) {
        DhcpFreeMemory( UnicodeOptionValueString );
    }

    return( Error );

}

DWORD
RemoveOption(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
)
{
    DWORD                          MajorVersion, MinorVersion;
    DWORD                          Error;

#ifdef NT5
    if( GlobalNoRPC ) {
        MajorVersion = CLASS_ID_VERSION ;
    } else {
        Error = DhcpGetVersion(ServerAddress, &MajorVersion, &MinorVersion);
        if( ERROR_SUCCESS != Error ) {
            printf("Could not determine server version.\n");
            return Error;
        }
    }

    if( MajorVersion >= CLASS_ID_VERSION ) {
        return DhcpRemoveOptionV5(
            ServerAddress,
            GlobalIsVendor ? Flags | DHCP_FLAGS_OPTION_IS_VENDOR : Flags,
            OptionId,
            ClassName,
            VendorName
        );
    }

    // incorrect version, just do like before..
#endif

    return DhcpRemoveOption(
        ServerAddress,
        OptionId
    );
}

ProcessDeleteOption(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_OPTION_ID OptionID;

    //
    // Expected Parameters are :
    //  <OptionID>
    //


    if( CommandArgc != 1 ) {
        printf("usage:DhcpCmd SrvIpAddress DeleteOption [Command Parameters].\n"
            "<Command Parameters> - <OptionID>.\n");
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    OptionID = strtoul( CommandArgv[0], NULL, 0 );

    Error = RemoveOption(
        GlobalServerIpAddressUnicodeString,
        0,
        OptionID,
        GlobalClassName,
        GlobalVendorName
    );

Cleanup:

    return Error ;
}

DWORD
SetOptionValue(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
)
{
    DWORD                          MajorVersion, MinorVersion;
    DWORD                          Error;

#ifdef NT5
    if( GlobalNoRPC ) {
        MajorVersion = CLASS_ID_VERSION ;
    } else {
        Error = DhcpGetVersion(ServerAddress, &MajorVersion, &MinorVersion);
        if( ERROR_SUCCESS != Error ) {
            printf("Could not determine server version.\n");
            return Error;
        }
    }

    if( MajorVersion >= CLASS_ID_VERSION ) {
        return DhcpSetOptionValueV5(
            ServerAddress,
            GlobalIsVendor ? Flags | DHCP_FLAGS_OPTION_IS_VENDOR : Flags,
            OptionId,
            ClassName,
            VendorName,
            ScopeInfo,
            OptionValue
        );
    }

    // incorrect version, just do like before..
#endif

    return DhcpSetOptionValue(
        ServerAddress,
        OptionId,
        ScopeInfo,
        OptionValue
    );
}


ProcessSetGlobalOptionValue(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;
    DHCP_OPTION_DATA OptionValue;
    DHCP_OPTION_DATA_ELEMENT OptionData;
    LPWSTR UnicodeOptionValueString = NULL;

    //
    // Expected Parameters are :
    //  <OptionID OptionType OptionValue>
    //

    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress SetGlobalOptionValue [Command Parameters].\n"
            "<Command Parameters> - <OptionID OptionType OptionValue>.\n");
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    OptionID = strtoul( CommandArgv[0], NULL, 0 );

    Error = SetOptionDataType(
        CommandArgv[1],
        CommandArgv[2],
        &OptionData,
        &UnicodeOptionValueString
    );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    OptionValue.NumElements = 1;
    OptionValue.Elements = &OptionData;

    ScopeInfo.ScopeType = DhcpGlobalOptions;
    ScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;

    Error = SetOptionValue(
        GlobalServerIpAddressUnicodeString,
        0,
        (DHCP_OPTION_ID)OptionID,
        GlobalClassName,
        GlobalVendorName,
        &ScopeInfo,
        &OptionValue
    );
Cleanup:

    if( UnicodeOptionValueString != NULL ) {
        DhcpFreeMemory( UnicodeOptionValueString );
    }

    return( Error );
}

DWORD
SetOptionValues(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
)
{
    DWORD                          MajorVersion, MinorVersion;
    DWORD                          Error;

#ifdef NT5
    if( GlobalNoRPC ) {
        MajorVersion = CLASS_ID_VERSION ;
    } else {
        Error = DhcpGetVersion(ServerAddress, &MajorVersion, &MinorVersion);
        if( ERROR_SUCCESS != Error ) {
            printf("Could not determine server version.\n");
            return Error;
        }
    }

    if( MajorVersion >= CLASS_ID_VERSION ) {
        return DhcpSetOptionValuesV5(
            ServerAddress,
            GlobalIsVendor ? Flags | DHCP_FLAGS_OPTION_IS_VENDOR : Flags,
            ClassName,
            VendorName,
            ScopeInfo,
            OptionValues
        );
    }

    // incorrect version, just do like before..
#endif

    return DhcpSetOptionValues(
        ServerAddress,
        ScopeInfo,
        OptionValues
    );
}

ProcessSetGlobalOptionValues(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{

#define NUM_VALUES      5

    DWORD Error;
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;
    DHCP_OPTION_DATA OptionValue;
    DHCP_OPTION_DATA_ELEMENT OptionData[NUM_VALUES];
    LPWSTR UnicodeOptionValueString[NUM_VALUES];

    DHCP_OPTION_VALUE_ARRAY ValuesArray;
    DHCP_OPTION_VALUE Values[NUM_VALUES];
    DWORD NumValue;

    RtlZeroMemory( UnicodeOptionValueString, NUM_VALUES * sizeof(LPWSTR) );

    //
    // Expected Parameters are :
    //  <OptionID OptionType OptionValue>
    //

    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress SetGlobalOptionValues [Command Parameters].\n"
            "<Command Parameters> - <OptionID OptionType OptionValue> <..>.\n"); Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    for (NumValue = 0;
            (CommandArgc >= 3) && (NumValue < NUM_VALUES);
                NumValue++, CommandArgc -= 3, CommandArgv += 3 ) {

       OptionID = strtoul( CommandArgv[0], NULL, 0 );

       Error = SetOptionDataType(
           CommandArgv[1],
           CommandArgv[2],
           &OptionData[NumValue],
           &UnicodeOptionValueString[NumValue]
       );

       if( Error != ERROR_SUCCESS ) {
           goto Cleanup;
       }

       Values[NumValue].OptionID = OptionID;
       Values[NumValue].Value.NumElements = 1;
       Values[NumValue].Value.Elements = &OptionData[NumValue];
    }

    ValuesArray.NumElements = NumValue;
    ValuesArray.Values = Values;

    ScopeInfo.ScopeType = DhcpGlobalOptions;
    ScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;

    Error = SetOptionValues(
        GlobalServerIpAddressUnicodeString,
        0,
        GlobalClassName,
        GlobalVendorName,
        &ScopeInfo,
        &ValuesArray
    );

Cleanup:

    for (NumValue = 0; NumValue < NUM_VALUES; NumValue++) {

       if( UnicodeOptionValueString[NumValue] != NULL ) {
           DhcpFreeMemory( UnicodeOptionValueString );
       }
    }

    return( Error );
}

DWORD
RemoveOptionValue(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
)
{
    DWORD                          MajorVersion, MinorVersion;
    DWORD                          Error;

#ifdef NT5
    if( GlobalNoRPC ) {
        MajorVersion = CLASS_ID_VERSION ;
    } else {
        Error = DhcpGetVersion(ServerAddress, &MajorVersion, &MinorVersion);
        if( ERROR_SUCCESS != Error ) {
            printf("Could not determine server version.\n");
            return Error;
        }
    }

    if( MajorVersion >= CLASS_ID_VERSION ) {
        return DhcpRemoveOptionValueV5(
            ServerAddress,
            GlobalIsVendor ? Flags | DHCP_FLAGS_OPTION_IS_VENDOR : Flags,
            OptionID,
            ClassName,
            VendorName,
            ScopeInfo
        );
    }

    // incorrect version, just do like before..
#endif

    return DhcpRemoveOptionValue(
        ServerAddress,
        OptionID,
        ScopeInfo
    );
}

DWORD
ProcessRemoveGlobalOptionValue(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;

    //
    // Expected Parameters are :
    //  <OptionID OptionType OptionValue>
    //

    if( CommandArgc != 1 ) {
        printf("usage:DhcpCmd SrvIpAddress RemoveGlobalOptionValue [Command Parameters].\n"
            "<Command Parameters> - <OptionID>.\n");
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    OptionID = strtoul( CommandArgv[0], NULL, 0 );

    ScopeInfo.ScopeType = DhcpGlobalOptions;
    ScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;

    Error = RemoveOptionValue(
        GlobalServerIpAddressUnicodeString,
        0,
        (DHCP_OPTION_ID)OptionID,
        GlobalClassName,
        GlobalVendorName,
        &ScopeInfo
    );

Cleanup:

    return Error ;
}

ProcessSetSubnetOptionValue(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;
    DHCP_OPTION_DATA OptionValue;
    DHCP_OPTION_DATA_ELEMENT OptionData;
    LPWSTR UnicodeOptionValueString = NULL;

    //
    // Expected Parameters are :
    // subnet-address <OptionID OptionType OptionValue>
    //

    if( CommandArgc < 4 ) {
        printf("usage:DhcpCmd SrvIpAddress SetSubnetOptionValue "
            "[Command Parameters].\n"
            "<Command Parameters> - "
            "<SubnetAddress OptionID OptionType OptionValue>.\n");
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    ScopeInfo.ScopeType = DhcpSubnetOptions;
    ScopeInfo.ScopeInfo.SubnetScopeInfo =  DhcpDottedStringToIpAddress( CommandArgv[0] );

    OptionID = strtoul( CommandArgv[1], NULL, 0 );

    Error = SetOptionDataType(
                CommandArgv[2],
                CommandArgv[3],
                &OptionData,
                &UnicodeOptionValueString );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    OptionValue.NumElements = 1;
    OptionValue.Elements = &OptionData;

    Error = SetOptionValue(
        GlobalServerIpAddressUnicodeString,
        0,
        (DHCP_OPTION_ID)OptionID,
        GlobalClassName,
        GlobalVendorName,
        &ScopeInfo,
        &OptionValue
    );

Cleanup:

    if( UnicodeOptionValueString != NULL ) {
        DhcpFreeMemory( UnicodeOptionValueString );
    }

    return( Error );
}

ProcessRemoveSubnetOptionValue(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;

    //
    // Expected Parameters are :
    // subnet-address <OptionID>
    //

    if( CommandArgc != 2 ) {
        printf("usage:DhcpCmd SrvIpAddress RemoveSubnetOptionValue "
            "[Command Parameters].\n"
            "<Command Parameters> - "
            "<SubnetAddress OptionID>.\n");
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    ScopeInfo.ScopeType = DhcpSubnetOptions;
    ScopeInfo.ScopeInfo.SubnetScopeInfo =  DhcpDottedStringToIpAddress( CommandArgv[0] );

    OptionID = strtoul( CommandArgv[1], NULL, 0 );

    Error = RemoveOptionValue(
        GlobalServerIpAddressUnicodeString,
        0,
        (DHCP_OPTION_ID)OptionID,
        GlobalClassName,
        GlobalVendorName,
        &ScopeInfo
    );

Cleanup:

    return Error ;
}

ProcessSetReservedOptionValue(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;
    DHCP_OPTION_DATA OptionValue;
    DHCP_OPTION_DATA_ELEMENT OptionData;
    LPWSTR UnicodeOptionValueString = NULL;

    //
    // Expected Parameters are :
    // subnet-address reservation-address <OptionID OptionType OptionValue>
    //

    if( CommandArgc < 5 ) {
        printf("usage:DhcpCmd SrvIpAddress SetReservedOptionValue "
            "[Command Parameters].\n"
            "<Command Parameters> - "
            "<SubnetAddress Reservation-Address OptionID OptionType OptionValue>.\n");
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    ScopeInfo.ScopeType = DhcpReservedOptions;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
    	DhcpDottedStringToIpAddress(CommandArgv[0]);
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
    	DhcpDottedStringToIpAddress( CommandArgv[1] );

    OptionID = strtoul( CommandArgv[2], NULL, 0 );

    Error = SetOptionDataType(
        CommandArgv[3],
        CommandArgv[4],
        &OptionData,
        &UnicodeOptionValueString
    );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    OptionValue.NumElements = 1;
    OptionValue.Elements = &OptionData;

    Error = SetOptionValue(
        GlobalServerIpAddressUnicodeString,
        0,
        (DHCP_OPTION_ID)OptionID,
        GlobalClassName,
        GlobalVendorName,
        &ScopeInfo,
        &OptionValue
    );

Cleanup:

    if( UnicodeOptionValueString != NULL ) {
        DhcpFreeMemory( UnicodeOptionValueString );
    }

    return( Error );
}

ProcessRemoveReservedOptionValue(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_SCOPE_INFO ScopeInfo;

    //
    // Expected Parameters are :
    // subnet-address reservation-address <OptionID>
    //

    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress RemoveReservedOptionValue "
            "[Command Parameters].\n"
            "<Command Parameters> - "
            "<SubnetAddress Reservation-Address OptionID>.\n");
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    ScopeInfo.ScopeType = DhcpReservedOptions;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
    	DhcpDottedStringToIpAddress(CommandArgv[0]);
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
    	DhcpDottedStringToIpAddress( CommandArgv[1] );

    OptionID = strtoul( CommandArgv[2], NULL, 0 );

    Error = RemoveOptionValue(
        GlobalServerIpAddressUnicodeString,
        0,
        (DHCP_OPTION_ID)OptionID,
        GlobalClassName,
        GlobalVendorName,
        &ScopeInfo
    );

Cleanup:

    return Error ;
}


VOID
PrintClientInfo(
    LPDHCP_CLIENT_INFO_V4 ClientInfo
    )
{
    DWORD i;
    DWORD DataLength;
    LPBYTE Data;
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;
    char *szClientType;

    printf("ClientInfo :\n");
    printf("\tIP Address = %s.\n",
        DhcpIpAddressToDottedString(ClientInfo->ClientIpAddress));
    printf("\tSubnetMask = %s.\n",
        DhcpIpAddressToDottedString(ClientInfo->SubnetMask));

    DataLength = ClientInfo->ClientHardwareAddress.DataLength;
    Data = ClientInfo->ClientHardwareAddress.Data;
    printf("\tClient Hardware Address = ");
    for( i = 0; i < DataLength; i++ ) {
        if( (i+1) < DataLength ) {
            printf("%.2lx-", (DWORD)Data[i]);
        }
        else {
            printf("%.2lx", (DWORD)Data[i]);
        }
    }
    printf(".\n");

    printf("\tName = %ws.\n", ClientInfo->ClientName);
    printf("\tComment = %ws.\n", ClientInfo->ClientComment);
    printf("\tType = " );

    switch( ClientInfo->bClientType )
    {
        case CLIENT_TYPE_NONE:
            szClientType= "None";
            break;

        case CLIENT_TYPE_DHCP:
            szClientType = "DHCP";
            break;

        case CLIENT_TYPE_BOOTP:
            szClientType = "BOOTP";
            break;

        case CLIENT_TYPE_UNSPECIFIED:
            szClientType = "Unspecified";
            break;

        default:
            DhcpAssert( FALSE );
    }
    printf( "%s\n", szClientType );

    printf("\tExpires = ");

    if ( ClientInfo->ClientLeaseExpires.dwLowDateTime ==
            DHCP_DATE_TIME_INFINIT_LOW &&
         ClientInfo->ClientLeaseExpires.dwHighDateTime ==
            DHCP_DATE_TIME_INFINIT_HIGH )
    {
        printf( "Never (lease duration is infinite.)\n" );
    }
    else if( FileTimeToLocalFileTime(
            (FILETIME *)(&ClientInfo->ClientLeaseExpires),
            &LocalTime) ) {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) {

            printf( "%02u/%02u/%02u %02u:%02u:%02u.\n",
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wYear,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );
        }
        else {
            printf( "Can't convert time, %ld.\n", GetLastError() );
        }
    }
    else {
        printf( "Can't convert time, %ld.\n", GetLastError() );
    }

    printf("\tOwner Host IP Address = %s.\n",
        DhcpIpAddressToDottedString(ClientInfo->OwnerHost.IpAddress));
    printf("\tOwner Host NetBios Name = %ws.\n",
            ClientInfo->OwnerHost.NetBiosName );
    printf("\tOwner Host Name = %ws.\n",
            ClientInfo->OwnerHost.HostName );

}

#ifdef NT5
VOID
PrintClientInfoV5(
    LPDHCP_CLIENT_INFO_V5 ClientInfo
    )
{
    DWORD i;
    DWORD DataLength;
    LPBYTE Data;
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;
    char *szClientType;

    printf("ClientInfo :\n");
    printf("\tIP Address = %s.\n",
        DhcpIpAddressToDottedString(ClientInfo->ClientIpAddress));
    printf("\tSubnetMask = %s.\n",
        DhcpIpAddressToDottedString(ClientInfo->SubnetMask));

    DataLength = ClientInfo->ClientHardwareAddress.DataLength;
    Data = ClientInfo->ClientHardwareAddress.Data;
    printf("\tClient Hardware Address = ");
    for( i = 0; i < DataLength; i++ ) {
        if( (i+1) < DataLength ) {
            printf("%.2lx-", (DWORD)Data[i]);
        }
        else {
            printf("%.2lx", (DWORD)Data[i]);
        }
    }
    printf(".\n");

    printf("\tName = %ws.\n", ClientInfo->ClientName);
    printf("\tComment = %ws.\n", ClientInfo->ClientComment);
    printf("\tType = " );

    switch( ClientInfo->bClientType )
    {
        case CLIENT_TYPE_NONE:
            szClientType= "None";
            break;

        case CLIENT_TYPE_DHCP:
            szClientType = "DHCP";
            break;

        case CLIENT_TYPE_BOOTP:
            szClientType = "BOOTP";
            break;

        case CLIENT_TYPE_UNSPECIFIED:
            szClientType = "Unspecified";
            break;

        default:
            DhcpAssert( FALSE );
    }
    printf( "%s\n", szClientType );

    printf("\tExpires = ");

    if ( ClientInfo->ClientLeaseExpires.dwLowDateTime ==
            DHCP_DATE_TIME_INFINIT_LOW &&
         ClientInfo->ClientLeaseExpires.dwHighDateTime ==
            DHCP_DATE_TIME_INFINIT_HIGH )
    {
        printf( "Never (lease duration is infinite.)\n" );
    }
    else if( FileTimeToLocalFileTime(
            (FILETIME *)(&ClientInfo->ClientLeaseExpires),
            &LocalTime) ) {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) {

            printf( "%02u/%02u/%02u %02u:%02u:%02u.\n",
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wYear,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );
        }
        else {
            printf( "Can't convert time, %ld.\n", GetLastError() );
        }
    }
    else {
        printf( "Can't convert time, %ld.\n", GetLastError() );
    }

    printf("\tOwner Host IP Address = %s.\n",
        DhcpIpAddressToDottedString(ClientInfo->OwnerHost.IpAddress));
    printf("\tOwner Host NetBios Name = %ws.\n",
            ClientInfo->OwnerHost.NetBiosName );
    printf("\tOwner Host Name = %ws.\n",
            ClientInfo->OwnerHost.HostName );

    printf("\tState = %0x\n", ClientInfo->AddressState );
}
#endif NT5

VOID
PrintClientInfoShort(
    LPDHCP_CLIENT_INFO_V4 ClientInfo
    )
{
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    printf("%ld\t %- 16.16s %- 16.16ws ",
                GlobalClientCount++,
                DhcpIpAddressToDottedString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );
    if ( ClientInfo->ClientLeaseExpires.dwLowDateTime ==
        DHCP_DATE_TIME_INFINIT_LOW &&
     ClientInfo->ClientLeaseExpires.dwHighDateTime ==
        DHCP_DATE_TIME_INFINIT_HIGH )
    {
        printf( "Never (lease duration is infinite.)\n" );
    }
    else if( FileTimeToLocalFileTime(
            (FILETIME *)(&ClientInfo->ClientLeaseExpires),
            &LocalTime) ) {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) {

            printf( "%02u/%02u/%02u %02u:%02u:%02u",
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wYear,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );
        }
        else {
            printf( "% 18.18s", "******************" );
        }
    }
    else {
        printf( "%.18s", "******************" );
    }

    printf( "\n" );
}

#ifdef NT5
VOID
PrintClientInfoShortV5(
    LPDHCP_CLIENT_INFO_V5 ClientInfo
    )
{
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    printf("%ld\t %- 16.16s %- 16.16ws ",
                GlobalClientCount++,
                DhcpIpAddressToDottedString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );
    if ( ClientInfo->ClientLeaseExpires.dwLowDateTime ==
        DHCP_DATE_TIME_INFINIT_LOW &&
     ClientInfo->ClientLeaseExpires.dwHighDateTime ==
        DHCP_DATE_TIME_INFINIT_HIGH )
    {
        printf( "Never (lease duration is infinite.)\n" );
    }
    else if( FileTimeToLocalFileTime(
            (FILETIME *)(&ClientInfo->ClientLeaseExpires),
            &LocalTime) ) {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) {

            printf( "%02u/%02u/%02u %02u:%02u:%02u",
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wYear,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );
        }
        else {
            printf( "% 18.18s", "******************" );
        }
    }
    else {
        printf( "%.18s", "******************" );
    }
    printf( "State=%02x", ClientInfo->AddressState);
    printf( "\n" );
}
#endif NT5

VOID
PrintClientInfoShort1(
    LPDHCP_CLIENT_INFO_V4 ClientInfo
    )
{
    DWORD i;
    DWORD DataLength;
    LPBYTE Data;

    printf("%ld\t %- 16.16s %- 16.16ws ",
                GlobalClientCount++,
                DhcpIpAddressToDottedString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );

    DataLength = ClientInfo->ClientHardwareAddress.DataLength;
    Data = ClientInfo->ClientHardwareAddress.Data;
    for( i = 0; i < DataLength; i++ ) {
        printf("%.2lx", (DWORD)Data[i]);
    }

    printf( "\n" );
}

DWORD
DetectIpAddressConflict(
    DHCP_IP_ADDRESS IpAddress,
    DWORD dwRetries,
    LPBOOL AddressExists
    )
/*++

Routine Description:

    This function pings the specific IP address and checks if it exists

    The number of "ping" retries is controled by the parameter
DetectConflictRetries in the registry. When it is set to 0, this
function always sets result to FALSE.

Arguments:

    IpAddress - The IP address to check

    AddressExists - pointer to the variable where the result is to be stored

Return Value:

    Windows Error

--*/

{
    HANDLE IcmpHandle;
    char ReplyBuffer [1000];
    DWORD NumReplies = 0;
    DWORD i,
          dwResult;

    DhcpAssert( dwRetries );

    *AddressExists = FALSE;



    IcmpHandle = IcmpCreateFile();
    if (IcmpHandle == INVALID_HANDLE_VALUE)
        return GetLastError();


    for (i = 0; i < dwRetries; i++) {

        NumReplies = IcmpSendEcho(
            IcmpHandle,
            (IPAddr) ntohl(IpAddress),
            (LPVOID) "DHCP Server Bad Address",
            (WORD)strlen("DHCP Server Bad Address"),
            NULL,
            ReplyBuffer,
            sizeof(ReplyBuffer),
            1000
            );

        if (NumReplies != 0) {
            break;
        }
    }

    dwResult = GetLastError();

    // IcmpSendEcho will also return 0 to indicate an error condition.
    // IP_REQ_TIMED_OUT indicates no response

    if ( IP_REQ_TIMED_OUT == dwResult )
        dwResult = 0;

    IcmpCloseHandle (IcmpHandle);

    *AddressExists = (NumReplies != 0);


    return dwResult;
}

BOOL
AddressCanBeDeleted(
    IN DHCP_IP_ADDRESS Address
    )
{
    BOOL RetVal;

    RetVal = TRUE;
    DetectIpAddressConflict(
        Address,
        3,
        &RetVal
        );
    if( RetVal ) {
        printf("This address exists, so it wont be deleted\n");
    } else {
        printf("This address does not exist, so it will be deleted.\n");
    }

    return !RetVal;
}

DWORD
ProcessDeleteClient(
    DWORD CommandArgc,
    LPSTR *CommandArgv
    )
{
    DHCP_SEARCH_INFO SrchInfo;
    DWORD Error;

    if( CommandArgc != 1 ) {
        printf("Usage: DhcpCmd SrvIpAddress DeleteClient ClientIp\n");
        return ERROR_INVALID_PARAMETER;
    }

    SrchInfo.SearchType = DhcpClientIpAddress;
    SrchInfo.SearchInfo.ClientIpAddress = htonl(
        inet_addr( CommandArgv[0]) );

    Error = DhcpDeleteClientInfo(
        GlobalServerIpAddressUnicodeString, &SrchInfo );

    if( NO_ERROR != Error ) {
        printf("DhcpDeleteClientInfo failed %ld\n", Error);
    }

    return Error;
}

DWORD
ProcessDeleteBadClients(
    DWORD CommandArgc,
    LPSTR *CommandArgv
    )
{
    BOOL NoPing = FALSE;
    DWORD Error;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    LPDHCP_CLIENT_INFO_ARRAY_V4 ClientEnumInfo = NULL;
    DWORD ClientsRead = 0;
    DWORD ClientsTotal = 0;
    DWORD i;


    if( CommandArgc > 1 || (
        CommandArgc == 1 && _stricmp(CommandArgv[0], "NOPING") ) ) {
        printf("usage:DhcpCmd SrvIpAddress DeleteBadClients [NOPING]\n");
        return ERROR_SUCCESS;
    }

    NoPing = (CommandArgc == 1 );

    GlobalClientCount = 1;

    for(;;) {

        ClientEnumInfo = NULL;
        Error = DhcpEnumSubnetClientsV4(
            GlobalServerIpAddressUnicodeString,
            0,
            &ResumeHandle,
            (DWORD)(-1),
            &ClientEnumInfo,
            &ClientsRead,
            &ClientsTotal
            );

        if( (Error != ERROR_SUCCESS) && (Error != ERROR_MORE_DATA) ) {
            printf("DhcpEnumSubnetClients failed, %ld.\n", Error );
            return( Error );
        }

        DhcpAssert( ClientEnumInfo != NULL );
        DhcpAssert( ClientEnumInfo->NumElements == ClientsRead );


        for( i = 0; i < ClientsRead; i++ ) {
            if( NULL == ClientEnumInfo->Clients[i]->ClientName ) {
                //
                // No name? Can that be a bad client? no.
                //
                continue;
            }

            if( wcscmp(ClientEnumInfo->Clients[i]->ClientName, L"BAD_ADDRESS" ) ) {
                //
                // Not a bad client! ignore it.
                //
                continue;
            }

            PrintClientInfoShort1( ClientEnumInfo->Clients[i] );
            if( NoPing || AddressCanBeDeleted(ClientEnumInfo->Clients[i]->ClientIpAddress) ) {
                DHCP_SEARCH_INFO SrchInfo2 = {
                    DhcpClientIpAddress,
                    ClientEnumInfo->Clients[i]->ClientIpAddress
                };

                Error = DhcpDeleteClientInfo(
                    GlobalServerIpAddressUnicodeString,
                    &SrchInfo2
                    );
                if( ERROR_SUCCESS != Error ) {
                    printf("DhcpDeleteClientInfo failed %ld, continuing. \n", Error);
                }
            }
        }

        DhcpRpcFreeMemory( ClientEnumInfo );

        if( Error != ERROR_MORE_DATA ) {
            break;
        }
    }

    return(Error);
    return 0;
}


#ifdef NT5
VOID
PrintClientInfoShort1V5(
    LPDHCP_CLIENT_INFO_V5 ClientInfo
    )
{
    DWORD i;
    DWORD DataLength;
    LPBYTE Data;

    printf("%ld\t %- 16.16s %- 16.16ws ",
                GlobalClientCount++,
                DhcpIpAddressToDottedString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );

    DataLength = ClientInfo->ClientHardwareAddress.DataLength;
    Data = ClientInfo->ClientHardwareAddress.Data;
    for( i = 0; i < DataLength; i++ ) {
        printf("%.2lx", (DWORD)Data[i]);
    }

    printf(" State=%02x\n", ClientInfo->AddressState);
    printf( "\n" );
}


DWORD
ProcessEnumClientsV5(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    LPDHCP_CLIENT_INFO_ARRAY_V5 ClientEnumInfo = NULL;
    DWORD ClientsRead = 0;
    DWORD ClientsTotal = 0;
    DWORD i;

    //
    // Expected Parameters are : <SubnetAddress>
    //


    if( CommandArgc < 1 ) {
        printf("usage:DhcpCmd SrvIpAddress EnumClients [Command Parameters].\n"
            "<Command Parameters> - <SubnetAddress [-v | -h] >.\n" );
        return( ERROR_SUCCESS );
    }

    GlobalClientCount = 1;

    for(;;) {

        ClientEnumInfo = NULL;
        Error = DhcpEnumSubnetClientsV5(
                    GlobalServerIpAddressUnicodeString,
                    DhcpDottedStringToIpAddress(CommandArgv[0]),
                    &ResumeHandle,
                    (DWORD)(-1),
                    &ClientEnumInfo,
                    &ClientsRead,
                    &ClientsTotal );

        if( (Error != ERROR_SUCCESS) && (Error != ERROR_MORE_DATA) ) {
            printf("DhcpEnumSubnetClients failed, %ld.\n", Error );
            return( Error );
        }

        DhcpAssert( ClientEnumInfo != NULL );
        DhcpAssert( ClientEnumInfo->NumElements == ClientsRead );

        if( (CommandArgc > 1) && CommandArgv[1][0] == '-') {

            switch (CommandArgv[1][1]) {
            case 'h':
            case 'H':
                for( i = 0; i < ClientsRead; i++ ) {
                    PrintClientInfoShort1V5( ClientEnumInfo->Clients[i] );
                }
                break;

            case 'V':
            case 'v':
                printf("Num Client info read = %ld.\n", ClientsRead );
                printf("Total Client count = %ld.\n", ClientsTotal );

                for( i = 0; i < ClientsRead; i++ ) {
                    PrintClientInfoV5( ClientEnumInfo->Clients[i] );
                }
                break;

            default:

                for( i = 0; i < ClientsRead; i++ ) {
                    PrintClientInfoShortV5( ClientEnumInfo->Clients[i] );
                }
                break;
            }
        }
        else {

            for( i = 0; i < ClientsRead; i++ ) {
                PrintClientInfoShortV5( ClientEnumInfo->Clients[i] );
            }
        }

        DhcpRpcFreeMemory( ClientEnumInfo );

        if( Error != ERROR_MORE_DATA ) {
            break;
        }
    }

    return(Error);
}
#endif NT5

DWORD
ProcessEnumClients(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    LPDHCP_CLIENT_INFO_ARRAY_V4 ClientEnumInfo = NULL;
    DWORD ClientsRead = 0;
    DWORD ClientsTotal = 0;
    DWORD i;

    //
    // Expected Parameters are : <SubnetAddress>
    //


    if( CommandArgc < 1 ) {
        printf("usage:DhcpCmd SrvIpAddress EnumClients [Command Parameters].\n"
            "<Command Parameters> - <SubnetAddress [-v | -h] >.\n" );
        return( ERROR_SUCCESS );
    }

    GlobalClientCount = 1;

    for(;;) {

        ClientEnumInfo = NULL;
        Error = DhcpEnumSubnetClientsV4(
                    GlobalServerIpAddressUnicodeString,
                    DhcpDottedStringToIpAddress(CommandArgv[0]),
                    &ResumeHandle,
                    (DWORD)(-1),
                    &ClientEnumInfo,
                    &ClientsRead,
                    &ClientsTotal );

        if( (Error != ERROR_SUCCESS) && (Error != ERROR_MORE_DATA) ) {
            printf("DhcpEnumSubnetClients failed, %ld.\n", Error );
            return( Error );
        }

        DhcpAssert( ClientEnumInfo != NULL );
        DhcpAssert( ClientEnumInfo->NumElements == ClientsRead );

        if( (CommandArgc > 1) && CommandArgv[1][0] == '-') {

            switch (CommandArgv[1][1]) {
            case 'h':
            case 'H':
                for( i = 0; i < ClientsRead; i++ ) {
                    PrintClientInfoShort1( ClientEnumInfo->Clients[i] );
                }
                break;

            case 'V':
            case 'v':
                printf("Num Client info read = %ld.\n", ClientsRead );
                printf("Total Client count = %ld.\n", ClientsTotal );

                for( i = 0; i < ClientsRead; i++ ) {
                    PrintClientInfo( ClientEnumInfo->Clients[i] );
                }
                break;

            default:

                for( i = 0; i < ClientsRead; i++ ) {
                    PrintClientInfoShort( ClientEnumInfo->Clients[i] );
                }
                break;
            }
        }
        else {

            for( i = 0; i < ClientsRead; i++ ) {
                PrintClientInfoShort( ClientEnumInfo->Clients[i] );
            }
        }

        DhcpRpcFreeMemory( ClientEnumInfo );

        if( Error != ERROR_MORE_DATA ) {
            break;
        }
    }

    return(Error);
}


DWORD
ProcessMibCounts(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    LPDHCP_MIB_INFO MibInfo = NULL;
    DWORD i;
    LPSCOPE_MIB_INFO ScopeInfo;
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    Error = DhcpGetMibInfo(
                GlobalServerIpAddressUnicodeString,
                &MibInfo );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    DhcpAssert( MibInfo != NULL );

    printf("Discovers = %d.\n", MibInfo->Discovers);
    printf("Offers = %d.\n", MibInfo->Offers);
    printf("Requests = %d.\n", MibInfo->Requests);
    printf("Acks = %d.\n", MibInfo->Acks);
    printf("Naks = %d.\n", MibInfo->Naks);
    printf("Declines = %d.\n", MibInfo->Declines);
    printf("Releases = %d.\n", MibInfo->Releases);
    printf("ServerStartTime = ");

    if( FileTimeToLocalFileTime(
            (FILETIME *)(&MibInfo->ServerStartTime),
            &LocalTime) ) {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) {

            printf( "%02u/%02u/%02u %02u:%02u:%02u.\n",
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wYear,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );
        }
        else {
            printf( "Can't convert time, %ld.\n", GetLastError() );
        }
    }
    else {
        printf( "Can't convert time, %ld.\n", GetLastError() );
    }

    printf("Scopes = %d.\n", MibInfo->Scopes);

    ScopeInfo = MibInfo->ScopeInfo;

    for ( i = 0; i < MibInfo->Scopes; i++ ) {
        printf("Subnet = %s.\n",
                    DhcpIpAddressToDottedString(ScopeInfo[i].Subnet));
        printf("\tNumAddressesInuse = %d.\n",
                    ScopeInfo[i].NumAddressesInuse );
        printf("\tNumAddressesFree = %d.\n",
                    ScopeInfo[i].NumAddressesFree );
        printf("\tNumPendingOffers = %d.\n",
                    ScopeInfo[i].NumPendingOffers );
    }

    DhcpRpcFreeMemory( MibInfo );

    return( ERROR_SUCCESS );
}

VOID
PrintConfigCommands(
    VOID
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalConfigCommandInfo) /
                        sizeof(CONFIG_COMMAND_INFO);

    DhcpAssert( NumCommands <= UnknownConfigCommand );
    for( i = 0; i < NumCommands; i++) {
        printf( "\t%ld. %s\n",
            i, GlobalConfigCommandInfo[i].CommandName );
    }
}

CONFIG_COMMAND_CODE
DecodeConfigCommand(
    LPSTR CommandName
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalConfigCommandInfo) /
                    sizeof(CONFIG_COMMAND_INFO);

    DhcpAssert( NumCommands <= UnknownConfigCommand );
    for( i = 0; i < NumCommands; i++) {
        if( _stricmp( CommandName,
                GlobalConfigCommandInfo[i].CommandName ) == 0 ) {
            return( GlobalConfigCommandInfo[i].CommandCode );
        }
    }
    return( UnknownConfigCommand );
}

//
// this function assumes input of the following format:
//
// [generic name1],[server name1],<boot file1>;[generic name2],...
//
//


WCHAR *
ParseBootFileTable(
    char     *szBootFileTable,
    DWORD    *pcb
    )
{
    WCHAR *pwszOutput;
    DWORD  cb;

    *pcb = 0;
    cb = strlen( szBootFileTable ) + 2; // double null terminator

    pwszOutput = DhcpAllocateMemory( cb * sizeof( WCHAR ) );
    if ( pwszOutput )
    {
        WCHAR *pwszTemp = DhcpOemToUnicode( szBootFileTable, pwszOutput );

        if ( !pwszTemp )
        {
            // conversion failed
            DhcpFreeMemory( pwszOutput );
            pwszOutput = NULL;
        }
        else
        {
            // replace ';' with '\0'
            while ( *pwszTemp )
            {
                if ( L';' == *pwszTemp )
                {
                    *pwszTemp = L'\0';
                }

                ++pwszTemp;
            }

            *pcb = cb * sizeof( WCHAR );

            // add 2cnd null terminator
            pwszOutput[ cb - 1 ] = L'\0';
        }

    }

    return pwszOutput;
}




void PrintBootFileString(
    WCHAR *wszBootFileString
    )
{
    WCHAR *pwszBootFile = wszBootFileString;

    while( *pwszBootFile != BOOT_FILE_STRING_DELIMITER_W )
        pwszBootFile++;

    *pwszBootFile = L'\0';

    printf( "Bootfile Server = %S\n", wszBootFileString );
    printf( "Bootfile = %S\n\n", ++pwszBootFile );
}

void PrintBootTableString(
    WCHAR *wszBootFileTable
    )
{
    while( *wszBootFileTable )
    {
        WCHAR *pwszDelimiter = wszBootFileTable;
        DWORD cb = wcslen( wszBootFileTable ) + 1;

        while( *pwszDelimiter != BOOT_FILE_STRING_DELIMITER_W )
            pwszDelimiter++;

        *pwszDelimiter = L'\0';
        printf( "Generic Bootfile request = %S\n", wszBootFileTable );
        PrintBootFileString( ++pwszDelimiter );

        wszBootFileTable += cb;
    }
}

DWORD ProcessRemoveSubscope(
    DWORD CommandArgc,
    LPSTR *CommandArgv
    )
{
    DHCP_IP_ADDRESS SubnetAddress;
    DWORD           dwResult;

    if( CommandArgc < 1 )
    {
        printf("usage:DhcpCmd SrvIpAddress RemoveSubscope <scope ID>.\n" );
        return( ERROR_SUCCESS );
    }

    SubnetAddress = htonl( inet_addr( CommandArgv[0] ) );

    dwResult = DhcpSetSuperScopeV4(
        GlobalServerIpAddressUnicodeString,
        SubnetAddress,
        NULL,
        TRUE
    );

    return dwResult;
}

DWORD ProcessSetSuperScope(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DHCP_IP_ADDRESS SubnetAddress;
    WCHAR           *pwszSuperScopeName;
    BOOL            fChangeExisting;
    DWORD           dwResult;

    if( CommandArgc < 3 )
    {
        printf("usage:DhcpCmd SrvIpAddress SetSuperScope <SuperScope name> <scope ID> <1|0>\n" );
        return( ERROR_SUCCESS );
    }

    pwszSuperScopeName = DhcpOemToUnicode( CommandArgv[0], NULL );
    SubnetAddress = htonl( inet_addr( CommandArgv[1] ) );
    fChangeExisting = (BOOL) ( *(CommandArgv[2]) - '0' );

    dwResult = DhcpSetSuperScopeV4( GlobalServerIpAddressUnicodeString,
                                    SubnetAddress,
                                    pwszSuperScopeName,
                                    fChangeExisting );

    return dwResult;
}

DWORD ProcessDeleteSuperScope(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    WCHAR *pwszSuperScope;
    DWORD  dwResult;

    if( CommandArgc < 1 ) {
        printf("usage:DhcpCmd SrvIpAddress DeleteSuperScope <scope name>.\n" );
        return( ERROR_SUCCESS );
    }

    printf( "Deleting SuperScope %s\n", CommandArgv[0] );

    pwszSuperScope = DhcpOemToUnicode( CommandArgv[0], NULL );
    dwResult = DhcpDeleteSuperScopeV4( GlobalServerIpAddressUnicodeString,
                                       pwszSuperScope );

    DhcpFreeMemory( pwszSuperScope );

    return dwResult;
}

DWORD ProcessGetSuperScopeTable(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DHCP_SUPER_SCOPE_TABLE *pTable = NULL;
    DWORD dwResult;

    dwResult = DhcpGetSuperScopeInfoV4(
                        GlobalServerIpAddressUnicodeString,
                        &pTable );
    if ( ERROR_SUCCESS == dwResult )
    {
        DWORD n;

        for ( n = 0; n < pTable->cEntries; n++ )
        {
            IN_ADDR InAddr;

            InAddr.s_addr = htonl( pTable->pEntries[n].SubnetAddress );

            printf( "Superscope name = %S\n", pTable->pEntries[n].SuperScopeName );
            printf( "Subnet address = %s\n", inet_ntoa( InAddr ) );
            printf( "Superscope goup number = %d\n", pTable->pEntries[n].SuperScopeNumber );
        }


        DhcpRpcFreeMemory( pTable );
    }


    return ERROR_SUCCESS;
}

DWORD
ProcessServerConfig(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo = NULL;
    DWORD FieldsToSet = 0;
    CONFIG_COMMAND_CODE CommandCode;
    DWORD Value;
    LPWSTR ValueString;

    if( CommandArgc < 1 ) {

        Error = DhcpServerGetConfigV4(
                    GlobalServerIpAddressUnicodeString,
                    &ConfigInfo );

        if( Error != ERROR_SUCCESS ) {
            return( Error );
        }

        DhcpAssert( ConfigInfo != NULL );

        printf("APIProtocolSupport = %lx\n", ConfigInfo->APIProtocolSupport );
        printf("DatabaseName = %ws\n", ConfigInfo->DatabaseName );
        printf("DatabasePath = %ws\n", ConfigInfo->DatabasePath );
        printf("BackupPath = %ws\n", ConfigInfo->BackupPath );
        printf("BackupInterval = %ld mins.\n",
                ConfigInfo->BackupInterval );
        printf("DatabaseLoggingFlag = %ld\n", ConfigInfo->DatabaseLoggingFlag );
        printf("RestoreFlag = %ld\n", ConfigInfo->RestoreFlag );
        printf("DatabaseCleanupInterval = %ld mins.\n",
                ConfigInfo->DatabaseCleanupInterval );
        printf("DebugFlag = %lx\n", ConfigInfo->DebugFlag );
        printf("PingRetries = %d\n", ConfigInfo->dwPingRetries );
        printf("ActivityLog = %d\n", (DWORD) ConfigInfo->fAuditLog );

        if ( ConfigInfo->cbBootTableString )
        {
            printf( "BOOTP request table:\n" );
            PrintBootTableString( ConfigInfo->wszBootTableString );
        }

        DhcpRpcFreeMemory( ConfigInfo );

        return( Error );
    }


    if ( CommandArgc == 1)
    {
        ++CommandArgc;
        return ERROR_INVALID_PARAMETER;
    }
    else
    {
        ConfigInfo = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

        if( ConfigInfo == NULL ) {
            printf("Insufficient memory\n");
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        RtlZeroMemory( ConfigInfo, sizeof( *ConfigInfo ) );
    }
    while( CommandArgc >= 2 ) {


        CommandCode = DecodeConfigCommand( CommandArgv[0] );

        Value = 0;
        ValueString = NULL;

        switch( CommandCode )
        {
            case ConfigDatabaseName:
            case ConfigDatabasePath:
            case ConfigBackupPath:
            case ConfigAPIProtocolSupport:
            case ConfigBackupInterval:
            case ConfigDatabaseLoggingFlag:
            case ConfigRestoreFlag:
            case ConfigDatabaseCleanupInterval:
            case ConfigDebugFlag:
            case ConfigActivityLog:
            case ConfigPingRetries:
                Value = atoi( CommandArgv[1] );
                break;

            case ConfigBootFileTable:
                ValueString = ParseBootFileTable( CommandArgv[1],
                                                  &Value );
                break;
        }


        switch( CommandCode ) {
        case ConfigAPIProtocolSupport:
            FieldsToSet |= Set_APIProtocolSupport;
            ConfigInfo->APIProtocolSupport = Value;
            break;

        case ConfigDatabaseName:
            FieldsToSet |= Set_DatabaseName;
            ConfigInfo->DatabaseName = ValueString;
            break;

        case ConfigDatabasePath:
            FieldsToSet |= Set_DatabasePath;
            ConfigInfo->DatabasePath = ValueString;
            break;

        case ConfigBackupPath:
            FieldsToSet |= Set_BackupPath;
            ConfigInfo->BackupPath = ValueString;
            break;

        case ConfigBackupInterval:
            FieldsToSet |= Set_BackupInterval;
            ConfigInfo->BackupInterval = Value;
            break;

        case ConfigDatabaseLoggingFlag:
            FieldsToSet |= Set_DatabaseLoggingFlag;
            ConfigInfo->DatabaseLoggingFlag = Value;
            break;

        case ConfigRestoreFlag:
            FieldsToSet |= Set_RestoreFlag;
            ConfigInfo->RestoreFlag = Value;
            break;

        case ConfigDatabaseCleanupInterval:
            FieldsToSet |= Set_DatabaseCleanupInterval;
            ConfigInfo->DatabaseCleanupInterval = Value;
            break;

        case ConfigDebugFlag:
            FieldsToSet |= Set_DebugFlag;
            ConfigInfo->DebugFlag = Value;
            break;


        case ConfigPingRetries:
            FieldsToSet |= Set_PingRetries;
            ConfigInfo->dwPingRetries = Value;
            break;

        case ConfigActivityLog:
            FieldsToSet |= Set_AuditLogState;
            ConfigInfo->fAuditLog = (BOOL) Value;
            break;

        case ConfigBootFileTable:

            FieldsToSet |= Set_BootFileTable;
            ConfigInfo->wszBootTableString  = ValueString;
            ConfigInfo->cbBootTableString = Value;

            break;

        case UnknownConfigCommand:
        default:
            printf("usage:DhcpCmd SrvIpAddress ServerConfig "
                    "[ConfigCommand ConfigValue]"
                    "[ConfigCommand ConfigValue]"
                    "... \n");

            printf("ConfigCommands : \n");
            PrintConfigCommands();

            Error = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        CommandArgc -= 2;
        CommandArgv += 2;
    }

    Error = DhcpServerSetConfigV4(
                GlobalServerIpAddressUnicodeString,
                FieldsToSet,
                ConfigInfo );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = ProcessServerConfig( 0, NULL );

Cleanup:

    if( ConfigInfo != NULL ) {

        if( ConfigInfo->DatabaseName != NULL ) {
            DhcpFreeMemory( ConfigInfo->DatabaseName );
        }

        if( ConfigInfo->DatabasePath != NULL ) {
            DhcpFreeMemory( ConfigInfo->DatabasePath );
        }

        if( ConfigInfo->BackupPath != NULL ) {
            DhcpFreeMemory( ConfigInfo->BackupPath );
        }

        DhcpFreeMemory( ConfigInfo );
    }

    return( Error );
}

DWORD
ProcessCheckDB(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    LPDHCP_SCAN_LIST ScanList = NULL;
    BOOL FixFlag = FALSE;

    if( CommandArgc < 1 ) {
        printf("usage:DhcpCmd SrvIpAddress CheckDB [Command Parameters].\n"
            "<Command Parameters> - <SubnetAddress> <[Fix]>.\n" );
        return( ERROR_SUCCESS );
    }

    if( CommandArgc >= 2 ) {

        //
        // parse fix parameter.
        //

        if( _stricmp(CommandArgv[0], "fix") ) {
            FixFlag = TRUE;
        }
    }

    //
    // scan dhcp database and registry, check consistency and get bad
    // entries if any.
    //

    Error = DhcpScanDatabase(
                GlobalServerIpAddressUnicodeString,
                DhcpDottedStringToIpAddress(CommandArgv[0]),
                FixFlag,
                &ScanList
                );

    if( Error != ERROR_SUCCESS ) {
        printf("DhcpScanDatabase failed, %ld.\n", Error );
        return( Error );
    }

    //
    // display bad entries.
    //

    if( (ScanList != NULL) &&
        (ScanList->NumScanItems != 0) &&
        (ScanList->ScanItems != NULL) ) {

        LPDHCP_SCAN_ITEM ScanItem;
        LPDHCP_SCAN_ITEM ScanItemEnd;
        DWORD i = 1;

        ScanItemEnd =
            ScanList->ScanItems +
            ScanList->NumScanItems;

        for( ScanItem = ScanList->ScanItems;
                ScanItem < ScanItemEnd; ScanItem++ ) {

            printf("%ld %- 16.16s ",
                i++,
                DhcpIpAddressToDottedString(ScanItem->IpAddress) );

            if( ScanItem->ScanFlag == DhcpRegistryFix ) {
                printf("Fix Registry\n");
            }
            else if( ScanItem->ScanFlag == DhcpDatabaseFix ) {
                printf("Fix Database\n");
            }
            else {
                printf("Fix Unknown\n");
            }
        }
    }

    return( ERROR_SUCCESS );
}

VOID
PrintOptionValue(
    LPDHCP_OPTION_DATA OptionValue
    )
{
    DWORD NumElements;
    DHCP_OPTION_DATA_TYPE OptionType;
    DWORD i;

    printf("Option Value : \n");
    NumElements = OptionValue->NumElements;

    printf("\tNumber of Option Elements = %ld\n", NumElements );

    if( NumElements == 0 ) {
        return;
    }

    OptionType = OptionValue->Elements[0].OptionType;
    printf("\tOption Elements Type = " );

    switch( OptionType ) {
    case DhcpByteOption:
        printf("DhcpByteOption\n");
        break;

    case DhcpWordOption:
        printf("DhcpWordOption\n");
        break;

    case DhcpDWordOption:
        printf("DhcpDWordOption\n");
        break;

    case DhcpDWordDWordOption:
        printf("DhcpDWordDWordOption\n");
        break;

    case DhcpIpAddressOption:
        printf("DhcpIpAddressOption\n");
        break;

    case DhcpStringDataOption:
        printf("DhcpStringDataOption\n");
        break;

    case DhcpBinaryDataOption:
        printf("DhcpBinaryDataOption\n");
        break;

    case DhcpEncapsulatedDataOption:
        printf("DhcpEncapsulatedDataOption\n");
        break;
    default:
        printf("Unknown\n");
        return;
    }

    for( i = 0; i < OptionValue->NumElements; i++ ) {
        DhcpAssert( OptionType == OptionValue->Elements[i].OptionType );
        printf("Option Element %ld value = ", i );

        switch( OptionType ) {
        case DhcpByteOption:
            printf("%lx.\n", (DWORD)
                OptionValue->Elements[i].Element.ByteOption );
            break;

        case DhcpWordOption:
            printf("%lx.\n", (DWORD)
                OptionValue->Elements[i].Element.WordOption );
            break;

        case DhcpDWordOption:
            printf("%lx.\n",
                OptionValue->Elements[i].Element.DWordOption );
            break;

        case DhcpDWordDWordOption:
            printf("%lx, %lx.\n",
                OptionValue->Elements[i].Element.DWordDWordOption.DWord1,
                OptionValue->Elements[i].Element.DWordDWordOption.DWord2 );

            break;

        case DhcpIpAddressOption:
            printf("%lx.\n",
                OptionValue->Elements[i].Element.IpAddressOption );
            break;

        case DhcpStringDataOption:
            printf("%ws.\n",
                OptionValue->Elements[i].Element.StringDataOption );
            break;

        case DhcpBinaryDataOption:
        case DhcpEncapsulatedDataOption: {
            DWORD j;
            DWORD Length;

            Length = OptionValue->Elements[i].Element.BinaryDataOption.DataLength;
            for( j = 0; j < Length; j++ ) {
                printf("%2lx ",
                    OptionValue->Elements[i].Element.BinaryDataOption.Data[j] );
            }
            printf(".\n");
            break;
        }
        default:
            printf("PrintOptionValue: Unknown OptionType.\n");
            break;
        }
    }
}


VOID
PrintOptionInfo(
    LPDHCP_OPTION OptionInfo
    )
{
    printf( "Option Info : \n");
    printf( "\tOptionId : %ld \n", (DWORD)OptionInfo->OptionID );
    printf( "\tOptionName : %ws \n", OptionInfo->OptionName );
    printf( "\tOptionComment : %ws \n", OptionInfo->OptionComment );
    PrintOptionValue( &OptionInfo->DefaultValue );
    printf( "\tOptionType : %ld \n", (DWORD)OptionInfo->OptionType );
}

DWORD
_EnumOptions(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_ARRAY   *Options,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
)
{
    DWORD                          MajorVersion, MinorVersion;
    DWORD                          Error;

#ifdef NT5
    if( GlobalNoRPC ) {
        MajorVersion = CLASS_ID_VERSION ;
    } else {
        Error = DhcpGetVersion(ServerAddress, &MajorVersion, &MinorVersion);
        if( ERROR_SUCCESS != Error ) {
            printf("Could not determine server version.\n");
            return Error;
        }
    }

    if( MajorVersion >= CLASS_ID_VERSION ) {
        return DhcpEnumOptionsV5(
            ServerAddress,
            GlobalIsVendor ? Flags | DHCP_FLAGS_OPTION_IS_VENDOR : Flags,
            ClassName,
            VendorName,
            ResumeHandle,
            PreferredMaximum,
            Options,
            OptionsRead,
            OptionsTotal
        );
    }

    // incorrect version, just do like before..
#endif

    return DhcpEnumOptions(
        ServerAddress,
        ResumeHandle,
        PreferredMaximum,
        Options,
        OptionsRead,
        OptionsTotal
    );
}

DWORD
ProcessEnumOptions(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    LPDHCP_OPTION_ARRAY OptionsArray = NULL;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    DWORD OptionsRead;
    DWORD OptionsTotal;


    Error = _EnumOptions(
        GlobalServerIpAddressUnicodeString,
        0,
        GlobalClassName,
        GlobalVendorName,
        &ResumeHandle,
        0xFFFFFFFF,  // get all.
        &OptionsArray,
        &OptionsRead,
        &OptionsTotal
    );

    if( Error != ERROR_SUCCESS ) {
        printf("DhcpEnumOptions failed %ld\n", Error );
    } else {

        DWORD i;
        LPDHCP_OPTION Options;
        DWORD NumOptions;

        printf("OptionsRead = %ld.\n", OptionsRead);
        printf("OptionsTotal = %ld.\n", OptionsTotal);

        Options = OptionsArray->Options;
        NumOptions = OptionsArray->NumElements;

        for( i = 0; i < NumOptions; i++, Options++ ) {
            PrintOptionInfo( Options );
        }
        DhcpRpcFreeMemory( OptionsArray );
        OptionsArray = NULL;
    }

    return( Error );
}

DWORD
ProcessGetVersion(
    DWORD *pdwMajor,
    DWORD *pdwMinor
)
{
    DWORD Error = ERROR_SUCCESS;
    DWORD MajorVersion;
    DWORD MinorVersion;

    if ( g_dwMajor == (DWORD) -1 && g_dwMinor == (DWORD) -1 ) {
        Error = DhcpGetVersion(
            GlobalServerIpAddressUnicodeString,
            &g_dwMajor,
            &g_dwMinor
        );

        if ( ERROR_SUCCESS == Error ) {
            printf( "DHCP Server version %d.%d\n", g_dwMajor, g_dwMinor );
        }
    }

    return Error;
}

VOID
PrintOptionArray(
    IN      LPDHCP_OPTION_ARRAY    OptArray
)
{
    DWORD                          i;

    for( i = 0; i < OptArray->NumElements ; i ++ ) {
        PrintOptionInfo( &OptArray->Options[i] );
    }
}

VOID
PrintOptionValue1(
    IN      LPDHCP_OPTION_VALUE    OptVal
)
{
    printf("Option: %ld\n", OptVal->OptionID);

    PrintOptionValue(&OptVal->Value);
}

VOID
PrintOptionValuesArray(
    IN      LPDHCP_OPTION_VALUE_ARRAY OptValArray
)
{
    DWORD                          i;

    if( NULL == OptValArray ) return;
    for( i = 0; i < OptValArray->NumElements ; i ++ ) {
        PrintOptionValue1( &OptValArray->Values[i] );
    }
}

#ifdef NT5
#define CHKNULL(Str) ((Str)?(Str):L"<None>")

VOID
PrintAllOptions(
    IN      LPDHCP_ALL_OPTIONS     Options
)
{
    DWORD                          i;

    printf("Options [Non Vendor specific]:\n"
           "==============================\n");
    PrintOptionArray(Options->NonVendorOptions);

    for( i = 0; i < Options->NumVendorOptions; i ++ ) {
        printf("\nOptions [Vendor:%ws]\n==============================\n",
            CHKNULL( Options->VendorOptions[i].VendorName));
        PrintOptionInfo(&(Options->VendorOptions[i].Option));
    }

    printf("\n\n");
}

DWORD
ProcessGetAllOptions(
    IN      DWORD                  CommandArgc,
    IN      LPSTR                  CommandArgv[]
)
{
    DWORD                          Error, Major, Minor;
    LPDHCP_ALL_OPTIONS             Options;

    if( TRUE == GlobalNoRPC ) {
        Major = CLASS_ID_VERSION;
    } else {
        Error = DhcpGetVersion(
            GlobalServerIpAddressUnicodeString,
            &Major,
            &Minor
        );
        if( ERROR_SUCCESS != Error ) {
            printf("Could not get DHCP server version!\n");
            return Error;
        }
    }

    if( CLASS_ID_VERSION > Major ) {
        printf("DHCP Server (major version %ld) does not support this function call.\n", Major);
        return ERROR_SUCCESS;
    }

    Options = NULL;
    Error = DhcpGetAllOptions(
        GlobalServerIpAddressUnicodeString,
        0,
        &Options
    );

    if( ERROR_SUCCESS != Error ) return Error;

    if( NULL == Options ) {
        printf("Server returned no options!\n");
        DhcpAssert(FALSE);
    } else {
        PrintAllOptions(Options);
        DhcpRpcFreeMemory(Options);
    }

    return ERROR_SUCCESS;
}

VOID
PrintAllOptionValues(
    IN      LPDHCP_ALL_OPTION_VALUES OptValues
)
{
    DWORD                          i;

    printf("Flags = 0x%lx, NumValues = %ld\n", OptValues->Flags, OptValues->NumElements);
    for( i = 0; i < OptValues->NumElements ; i ++ ) {
        printf("Options");
        if( OptValues->Options[i].IsVendor ) {
            printf(" for vendor <%ws>", CHKNULL(OptValues->Options[i].VendorName));
        }
        if( OptValues->Options[i].ClassName ) {
            printf(" for user class <%ws>", OptValues->Options[i].ClassName);
        }
        printf(":\n");
        PrintOptionValuesArray(OptValues->Options[i].OptionsArray);
    }
}

DWORD
ProcessGetAllOptionValues(
    IN      DWORD                  CommandArgc,
    IN      LPSTR                  CommandArgv[]
)
{
    DWORD                          Error, Major, Minor;
    LPDHCP_ALL_OPTION_VALUES       OptionValues;
    DHCP_OPTION_SCOPE_INFO         ScopeInfo;

    // usage: getalloptionvalues [command parameters]
    // [CommandParameters] = Global/Default/SubnetAddress/SubnetAddress ReservedAddress

    if( CommandArgc != 1 && CommandArgc != 2 ) {
        printf("Usage: Dhcpcmd SrvIpAddress GetAllOptionValues [CommandParameters]\n");
        printf("<Command parameters> - < GLOBAL | DEFAULT | Subnet-Adddress | Subnet-Address Reserved Address>.\n");
        return ERROR_SUCCESS;
    }

    if( 1 == CommandArgc ) {
        if( 0 == _stricmp(CommandArgv[0], "GLOBAL") ) {
            ScopeInfo.ScopeType = DhcpGlobalOptions;
        } else if ( 0 == _stricmp(CommandArgv[0], "DEFAULT" )) {
            ScopeInfo.ScopeType = DhcpDefaultOptions;
        } else {
            ScopeInfo.ScopeType = DhcpSubnetOptions;
            ScopeInfo.ScopeInfo.SubnetScopeInfo = DhcpDottedStringToIpAddress(CommandArgv[0]);
        }
    } else {
        ScopeInfo.ScopeType = DhcpReservedOptions;
        ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
    		DhcpDottedStringToIpAddress(CommandArgv[0]);
        ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
    		DhcpDottedStringToIpAddress( CommandArgv[1] );
    }

    if( TRUE == GlobalNoRPC ) {
        Major = CLASS_ID_VERSION;
    } else {
        Error = DhcpGetVersion(
            GlobalServerIpAddressUnicodeString,
            &Major,
            &Minor
        );
        if( ERROR_SUCCESS != Error ) {
            printf("Could not get DHCP server version!\n");
            return Error;
        }
    }

    if( CLASS_ID_VERSION > Major ) {
        printf("DHCP Server (major version %ld) does not support this function call.\n", Major);
        return ERROR_SUCCESS;
    }

    OptionValues = NULL;
    Error = DhcpGetAllOptionValues(
        GlobalServerIpAddressUnicodeString,
        0,
        &ScopeInfo,
        &OptionValues
    );

    if( ERROR_SUCCESS != Error ) return Error;

    if( NULL == OptionValues ) {
        printf("Server returned no option values!\n");
        DhcpAssert(FALSE);
    } else {
        PrintAllOptionValues(OptionValues);
        DhcpRpcFreeMemory(OptionValues);
    }

    return ERROR_SUCCESS;
}

PBYTE
GetLangTag(
    )
{
    char b1[8], b2[8];
    static char buff[80];

    GetLocaleInfoA(LOCALE_SYSTEM_DEFAULT, LOCALE_SISO639LANGNAME, b1, sizeof(b1));

    GetLocaleInfoA(LOCALE_SYSTEM_DEFAULT, LOCALE_SISO3166CTRYNAME, b2, sizeof(b2));

    if (_stricmp(b1, b2))
        sprintf(buff, "%s-%s", b1, b2);
    else
        strcpy(buff, b1);

    return buff;
}

DWORD
ProcessCreateMScope(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_MSCOPE_INFO MScopeInfo;
    LPWSTR UnicodeMScopeName = NULL;
    LPWSTR UnicodeMScopeDesc = NULL;
    DWORD MScopeId;
    LPWSTR  UnicodeLangTag = NULL;
    PBYTE   LangTag;
    DWORD   ExpiryTimeInHours = 0;


    //
    // Expected Parameters are : <MScopeId MScopeName MScopeDescription ExpiryTime>
    //


    if( CommandArgc < 4 ) {
        printf("usage:DhcpCmd SrvIpAddress CreateMScope [Command Parameters].\n"
            "<Command Parameters> - <MScopeId MScopeName MScopeDescription ExpiryTimeInHours>.\n"
             );
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    MScopeId = atoi( CommandArgv[0] );
    if (!MScopeId) {
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    UnicodeMScopeName = DhcpOemToUnicode( CommandArgv[1], NULL );
    DhcpAssert( UnicodeMScopeName != NULL );

    UnicodeMScopeDesc = DhcpOemToUnicode( CommandArgv[2], NULL );
    DhcpAssert( UnicodeMScopeName != NULL );

    ExpiryTimeInHours = atoi(CommandArgv[3]);
    LangTag = GetLangTag();
    UnicodeLangTag = DhcpOemToUnicode(LangTag, NULL);
    DhcpAssert(UnicodeLangTag);

    MScopeInfo.MScopeName = UnicodeMScopeName;
    MScopeInfo.MScopeId = MScopeId;
    MScopeInfo.MScopeComment = UnicodeMScopeDesc;
    MScopeInfo.PrimaryHost.IpAddress =
        DhcpDottedStringToIpAddress(GlobalServerIpAddressAnsiString);

    MScopeInfo.PrimaryHost.NetBiosName = NULL;
    MScopeInfo.PrimaryHost.HostName = NULL;
    MScopeInfo.MScopeState = DhcpSubnetEnabled;
    MScopeInfo.MScopeFlags = 0;
    MScopeInfo.MScopeAddressPolicy = 0;
    MScopeInfo.TTL = 255;
    MScopeInfo.LangTag = UnicodeLangTag;
    MScopeInfo.ExpiryTime = DhcpCalculateTime(ExpiryTimeInHours*60*60);

    Error = DhcpSetMScopeInfo(
                GlobalServerIpAddressUnicodeString,
                UnicodeMScopeName,
                &MScopeInfo,
                TRUE); // new scope

Cleanup:

    if( UnicodeMScopeName != NULL ) {
        DhcpFreeMemory( UnicodeMScopeName );
    }
    if( UnicodeMScopeDesc != NULL ) {
        DhcpFreeMemory( UnicodeMScopeDesc );
    }

    return( Error );
}

DWORD
ProcessDeleteMScope(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_MSCOPE_INFO MScopeInfo;
    LPWSTR UnicodeMScopeName = NULL;

    //
    // Expected Parameters are : <MScopeName>
    //


    if( CommandArgc < 1 ) {
        printf("usage:DhcpCmd SrvIpAddress DeleteMScope [Command Parameters].\n"
            "<Command Parameters> - <MScopeName>.\n" );
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    UnicodeMScopeName = DhcpOemToUnicode( CommandArgv[0], NULL );
    DhcpAssert( UnicodeMScopeName != NULL );

    Error = DhcpDeleteMScope(
                GlobalServerIpAddressUnicodeString,
                UnicodeMScopeName,
                TRUE); // force flag

Cleanup:

    if( UnicodeMScopeName != NULL ) {
        DhcpFreeMemory( UnicodeMScopeName );
    }

    return( Error );
}

DWORD
ProcessAddMScopeIpRange(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_IP_RANGE IpRange;
    DHCP_SUBNET_ELEMENT_DATA_V4 Element;
    LPWSTR UnicodeMScopeName = NULL;
    //
    // Expected Parameters are : <MScopeName IpRangeStart IpRangeEnd>
    //


    if( CommandArgc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress AddMScopeIpRange  [Command Parameters].\n"
            "<Command Parameters> - <MScopeName IpRangeStart IpRangeEnd>.\n" );
        return( ERROR_SUCCESS );
    }

    UnicodeMScopeName = DhcpOemToUnicode( CommandArgv[0], NULL );
    DhcpAssert( UnicodeMScopeName != NULL );

    IpRange.StartAddress = DhcpDottedStringToIpAddress(CommandArgv[1]);
    IpRange.EndAddress = DhcpDottedStringToIpAddress(CommandArgv[2]);

    Element.ElementType = DhcpIpRanges;
    Element.Element.IpRange = &IpRange;

    Error = DhcpAddMScopeElement(
                GlobalServerIpAddressUnicodeString,
                UnicodeMScopeName,
                &Element );

    if( UnicodeMScopeName != NULL ) DhcpFreeMemory( UnicodeMScopeName );

    return( Error );
}

DWORD
ProcessReconcileMScope(
   DWORD CommandArgc,
   LPSTR *CommandArgv
)
{
   DWORD Error;
   LPWSTR UnicodeMScopeName = NULL;
   LPDHCP_SCAN_LIST ScanList    = NULL;
   //
   // Expected Parameters are : <MScopeName>
   //


   if( CommandArgc < 1 ) {
       printf("usage:DhcpCmd SrvIpAddress ReconcileMScope  [Command Parameters].\n"
           "<Command Parameters> - <MScopeName>.\n" );
       return( ERROR_SUCCESS );
   }

   UnicodeMScopeName = DhcpOemToUnicode( CommandArgv[0], NULL );
   DhcpAssert( UnicodeMScopeName != NULL );


   Error = DhcpScanMDatabase(
               GlobalServerIpAddressUnicodeString,
               UnicodeMScopeName,
               TRUE,        // fix bad entries.
               &ScanList );

   if( UnicodeMScopeName != NULL ) DhcpFreeMemory( UnicodeMScopeName );
   if (ScanList) DhcpRpcFreeMemory( ScanList );

   return( Error );
}


VOID
PrintMClientInfo(
    LPDHCP_MCLIENT_INFO ClientInfo
    )
{
    DWORD i;
    DWORD DataLength;
    LPBYTE Data;
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;
    char *szClientType;

    printf("ClientInfo :\n");
    printf("\tIP Address = %s.\n",
        DhcpIpAddressToDottedString(ClientInfo->ClientIpAddress));
    printf("\tMScopeId = %lx.\n",
        ClientInfo->MScopeId);

    DataLength = ClientInfo->ClientId.DataLength;
    Data = ClientInfo->ClientId.Data;
    printf("\tClient Hardware Address = ");
    for( i = 0; i < DataLength; i++ ) {
        if( (i+1) < DataLength ) {
            printf("%.2lx-", (DWORD)Data[i]);
        }
        else {
            printf("%.2lx", (DWORD)Data[i]);
        }
    }
    printf(".\n");

    printf("\tName = %ws.\n", ClientInfo->ClientName);
    printf("\tStarts = ");

    if ( ClientInfo->ClientLeaseStarts.dwLowDateTime ==
            DHCP_DATE_TIME_INFINIT_LOW &&
         ClientInfo->ClientLeaseStarts.dwHighDateTime ==
            DHCP_DATE_TIME_INFINIT_HIGH )
    {
        printf( "Never (lease duration is infinite.)\n" );
    }
    else if( FileTimeToLocalFileTime(
            (FILETIME *)(&ClientInfo->ClientLeaseStarts),
            &LocalTime) ) {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) {

            printf( "%02u/%02u/%02u %02u:%02u:%02u.\n",
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wYear,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );
        }
        else {
            printf( "Can't convert time, %ld.\n", GetLastError() );
        }
    }
    else {
        printf( "Can't convert time, %ld.\n", GetLastError() );
    }

    printf("\tExpires = ");

    if ( ClientInfo->ClientLeaseEnds.dwLowDateTime ==
            DHCP_DATE_TIME_INFINIT_LOW &&
         ClientInfo->ClientLeaseEnds.dwHighDateTime ==
            DHCP_DATE_TIME_INFINIT_HIGH )
    {
        printf( "Never (lease duration is infinite.)\n" );
    }
    else if( FileTimeToLocalFileTime(
            (FILETIME *)(&ClientInfo->ClientLeaseEnds),
            &LocalTime) ) {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) {

            printf( "%02u/%02u/%02u %02u:%02u:%02u.\n",
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wYear,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );
        }
        else {
            printf( "Can't convert time, %ld.\n", GetLastError() );
        }
    }
    else {
        printf( "Can't convert time, %ld.\n", GetLastError() );
    }

    printf("\tOwner Host IP Address = %s.\n",
        DhcpIpAddressToDottedString(ClientInfo->OwnerHost.IpAddress));
    printf("\tOwner Host NetBios Name = %ws.\n",
            ClientInfo->OwnerHost.NetBiosName );
    printf("\tOwner Host Name = %ws.\n",
            ClientInfo->OwnerHost.HostName );

    printf("\tState = %0x\n", ClientInfo->AddressState );
}

VOID
PrintMClientInfoShort(
    LPDHCP_MCLIENT_INFO ClientInfo
    )
{
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    printf("%ld\t %- 16.16s %- 16.16ws ",
                GlobalClientCount++,
                DhcpIpAddressToDottedString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );
    if ( ClientInfo->ClientLeaseEnds.dwLowDateTime ==
        DHCP_DATE_TIME_INFINIT_LOW &&
     ClientInfo->ClientLeaseEnds.dwHighDateTime ==
        DHCP_DATE_TIME_INFINIT_HIGH )
    {
        printf( "Never (lease duration is infinite.)\n" );
    }
    else if( FileTimeToLocalFileTime(
            (FILETIME *)(&ClientInfo->ClientLeaseEnds),
            &LocalTime) ) {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) {

            printf( "%02u/%02u/%02u %02u:%02u:%02u",
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wYear,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );
        }
        else {
            printf( "% 18.18s", "******************" );
        }
    }
    else {
        printf( "%.18s", "******************" );
    }

    printf( "\n" );
}

DWORD
ProcessEnumMScopeClients(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    LPDHCP_MCLIENT_INFO_ARRAY ClientEnumInfo = NULL;
    DWORD ClientsRead = 0;
    DWORD ClientsTotal = 0;
    DWORD i;
    LPWSTR UnicodeMScopeName = NULL;

    //
    // Expected Parameters are : <MScopeNames>
    //


    if( CommandArgc < 1 ) {
        printf("usage:DhcpCmd SrvIpAddress EnumClients [Command Parameters].\n"
            "<Command Parameters> - <MScopeNames [-v | -h] >.\n" );
        return( ERROR_SUCCESS );
    }

    UnicodeMScopeName = DhcpOemToUnicode( CommandArgv[0], NULL );
    DhcpAssert( UnicodeMScopeName != NULL );

    GlobalClientCount = 1;

    for(;;) {

        ClientEnumInfo = NULL;
        Error = DhcpEnumMScopeClients(
                    GlobalServerIpAddressUnicodeString,
                    UnicodeMScopeName,
                    &ResumeHandle,
                    (DWORD)(-1),
                    &ClientEnumInfo,
                    &ClientsRead,
                    &ClientsTotal );

        if( (Error != ERROR_SUCCESS) && (Error != ERROR_MORE_DATA) ) {
            printf("DhcpEnumSubnetClients failed, %ld.\n", Error );
            return( Error );
        }

        DhcpAssert( ClientEnumInfo != NULL );
        DhcpAssert( ClientEnumInfo->NumElements == ClientsRead );

        if( (CommandArgc > 1) && CommandArgv[1][0] == '-') {

            switch (CommandArgv[1][1]) {
            case 'h':
            case 'H':
                for( i = 0; i < ClientsRead; i++ ) {
                    PrintMClientInfoShort( ClientEnumInfo->Clients[i] );
                }
                break;

            case 'V':
            case 'v':
                printf("Num Client info read = %ld.\n", ClientsRead );
                printf("Total Client count = %ld.\n", ClientsTotal );

                for( i = 0; i < ClientsRead; i++ ) {
                    PrintMClientInfo( ClientEnumInfo->Clients[i] );
                }
                break;

            default:

                for( i = 0; i < ClientsRead; i++ ) {
                    PrintMClientInfoShort( ClientEnumInfo->Clients[i] );
                }
                break;
            }
        }
        else {

            for( i = 0; i < ClientsRead; i++ ) {
                PrintMClientInfoShort( ClientEnumInfo->Clients[i] );
            }
        }

        DhcpRpcFreeMemory( ClientEnumInfo );

        if( Error != ERROR_MORE_DATA ) {
            break;
        }
    }

    return(Error);
}

DWORD
ProcessEnumMScopes(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    DHCP_RESUME_HANDLE ResumeHandle = 0;
    LPDHCP_MSCOPE_TABLE MScopeTable = NULL;
    DWORD ClientsRead = 0;
    DWORD ClientsTotal = 0;
    DWORD i;
    LPWSTR UnicodeMScopeName = NULL;

    for(;;) {

        MScopeTable = NULL;
        Error = DhcpEnumMScopes(
                    GlobalServerIpAddressUnicodeString,
                    &ResumeHandle,
                    (DWORD)(-1),
                    &MScopeTable,
                    &ClientsRead,
                    &ClientsTotal );

        if( (Error != ERROR_SUCCESS) && (Error != ERROR_MORE_DATA) ) {
            printf("DhcpEnumSubnetClients failed, %ld.\n", Error );
            return( Error );
        }

        DhcpAssert( MScopeTable != NULL );
        DhcpAssert( MScopeTable->NumElements == ClientsRead );
        printf("Total Client count = %ld.\n", ClientsTotal );

        for( i = 0; i < ClientsRead; i++ ) {
            printf("MScope %ws\n", MScopeTable->pMScopeNames[i] );
        }
        break;


        DhcpRpcFreeMemory( MScopeTable );

        if( Error != ERROR_MORE_DATA ) {
            break;
        }
    }

    return(Error);
}

DWORD
ProcessMCastMibCounts(
    DWORD CommandArgc,
    LPSTR *CommandArgv
)
{
    DWORD Error;
    LPDHCP_MCAST_MIB_INFO MibInfo = NULL;
    DWORD i;
    LPMSCOPE_MIB_INFO ScopeInfo;
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    Error = DhcpGetMCastMibInfo(
                GlobalServerIpAddressUnicodeString,
                &MibInfo );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    DhcpAssert( MibInfo != NULL );

    printf("Discovers = %d.\n", MibInfo->Discovers);
    printf("Offers = %d.\n", MibInfo->Offers);
    printf("Requests = %d.\n", MibInfo->Requests);
    printf("Acks = %d.\n", MibInfo->Acks);
    printf("Naks = %d.\n", MibInfo->Naks);
    printf("Renews = %d.\n", MibInfo->Renews);
    printf("Releases = %d.\n", MibInfo->Releases);
    printf("ServerStartTime = ");

    if( FileTimeToLocalFileTime(
            (FILETIME *)(&MibInfo->ServerStartTime),
            &LocalTime) ) {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) {

            printf( "%02u/%02u/%02u %02u:%02u:%02u.\n",
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wYear,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );
        }
        else {
            printf( "Can't convert time, %ld.\n", GetLastError() );
        }
    }
    else {
        printf( "Can't convert time, %ld.\n", GetLastError() );
    }

    printf("Scopes = %d.\n", MibInfo->Scopes);

    ScopeInfo = MibInfo->ScopeInfo;

    for ( i = 0; i < MibInfo->Scopes; i++ ) {
        printf("Scope Name = %ws.\n",
                    (ScopeInfo[i].MScopeName));
        printf("\tNumAddressesInuse = %d.\n",
                    ScopeInfo[i].NumAddressesInuse );
        printf("\tNumAddressesFree = %d.\n",
                    ScopeInfo[i].NumAddressesFree );
        printf("\tNumPendingOffers = %d.\n",
                    ScopeInfo[i].NumPendingOffers );
    }

    DhcpRpcFreeMemory( MibInfo );

    return( ERROR_SUCCESS );
}

DWORD
ProcessAddServer(                                 // add a server to DS
    IN      DWORD                  CommandArgc,
    IN      LPSTR                 *CommandArgv
)
{
    DWORD                          Err;
    DWORD                          Address;
    LPWSTR                         ServerName;
    DHCP_SERVER_INFO               Server;

    // usage: AddServer <ServerName> <ServerIpAddress>
    if( CommandArgc != 2 ) {                      // wrong usage
        printf("usage:DhcpCmd SrvIpAddress AddServer <server-dns-name> <server-ip-address>\n");
        return ERROR_SUCCESS;
    }

    if( GlobalNoDS ) {
        Err = DhcpDsInit();
        if( ERROR_SUCCESS != Err ) return Err;
    }

    ServerName = DhcpOemToUnicode( CommandArgv[0], NULL);
    Address = (inet_addr(CommandArgv[1]));
    printf("Adding server %ws,%s\n", ServerName, inet_ntoa(*(struct in_addr*)&Address));

    Server.Version = 0;
    Server.ServerName = ServerName;
    Server.ServerAddress = htonl(Address);
    Server.Flags = 0;
    Server.State = 0;
    Server.DsLocation = NULL;
    Server.DsLocType = 0;

    Err = DhcpAddServer(0, NULL, &Server, NULL, NULL);
    DhcpFreeMemory(ServerName);

    if( ERROR_SUCCESS != Err ) {                  // could not add the server
        printf("DhcpAddServer failed %ld (0x%lx)\n", Err, Err);
    }

    if( GlobalNoDS ) DhcpDsCleanup();

    return Err;
}

DWORD
ProcessDelServer(                                 // delete a server from DS
    IN      DWORD                  CommandArgc,
    IN      LPSTR                 *CommandArgv
)
{
    DWORD                          Err;
    DWORD                          Address;
    LPWSTR                         ServerName;
    DHCP_SERVER_INFO               Server;

    // usage: DelServer <ServerName> <ServerIpAddress>
    if( CommandArgc != 2 ) {                      // wrong usage
        printf("usage:DhcpCmd SrvIpAddress DelServer <server-dns-name> <server-ip-address>\n");
        return ERROR_SUCCESS;
    }

    if( GlobalNoDS ) {
        Err = DhcpDsInit();
        if( ERROR_SUCCESS != Err ) return Err;
    }

    ServerName = DhcpOemToUnicode( CommandArgv[0], NULL);
    Address = (inet_addr(CommandArgv[1]));
    printf("Deleting server %ws,%s\n", ServerName, inet_ntoa(*(struct in_addr*)&Address));

    Server.Version = 0;
    Server.ServerName = ServerName;
    Server.ServerAddress = htonl(Address);
    Server.Flags = 0;
    Server.State = 0;
    Server.DsLocation = NULL;
    Server.DsLocType = 0;

    Err = DhcpDeleteServer(0, NULL, &Server, NULL, NULL);
    DhcpFreeMemory(ServerName);

    if( ERROR_SUCCESS != Err ) {                  // could not add the server
        printf("DhcpDeleteServer failed %ld (0x%lx)\n", Err, Err);
    }
    if( GlobalNoDS ) DhcpDsCleanup();
    return Err;
}


VOID
PrintServerInfo(                                  // print server information
    IN      LPDHCP_SERVER_INFO       Server
)
{
    DHCP_IP_ADDRESS                  ServerAddress = htonl(Server->ServerAddress);
    printf("Server [%ws] Address [%s] Ds location: %ws\n",
           Server->ServerName,
           inet_ntoa(*(struct in_addr *)&ServerAddress),
           Server->DsLocation? Server->DsLocation : L"<no-ds-location-available>"
    );
}

VOID
PrintServerInfoArray(                             // print list of servers
    IN      LPDHCP_SERVER_INFO_ARRAY Servers
)
{
    DWORD                          i;

    printf("%ld Servers were found in the DS:\n", Servers->NumElements);
    for( i = 0; i < Servers->NumElements; i ++ ) {
        printf("\t");
        PrintServerInfo(&Servers->Servers[i]);
    }
    printf("\n");
}

DWORD
ProcessEnumServers(                               // enumerate servers in DS.
    IN      DWORD                  CommandArgc,   // ignored..
    IN      LPSTR                 *CommandArgv    // ignored
)
{
    DWORD                          Err;
    LPDHCP_SERVER_INFO_ARRAY       Servers;

    if( GlobalNoDS ) {
        Err = DhcpDsInit();
        if( ERROR_SUCCESS != Err ) return Err;
    }

    Servers = NULL;
    Err = DhcpEnumServers(0, NULL, &Servers, NULL, NULL);
    if( ERROR_SUCCESS != Err ) {
        printf("DhcpEnumServers failed %ld (0x%lx)\n", Err, Err);
        if( GlobalNoDS ) DhcpDsCleanup();
        return Err;
    }

    PrintServerInfoArray(Servers);
    LocalFree(Servers);
    if( GlobalNoDS ) DhcpDsCleanup();
    return ERROR_SUCCESS;
}


DWORD
ProcessCreateClass(                               // create a new class
    IN      DWORD                  CommandArgc,
    IN      LPSTR                 *CommandArgv
)
{
    DWORD                          Err;
    DHCP_CLASS_INFO                ClassInfo;

    // usage: [/IsVendor] CreateClass ClassName ClassComment Ascii-Data-For-Class

    if( CommandArgc != 3 ) {                      // wrong usage
        printf("usage:DhcpCmd SrvIpAddress CreateClass [Command Parameters]\n");
        printf("[Command Parameters] - ClassName ClassComment Ascii-Date-For-Class\n");
        printf("/IsVendor option would cause this to be created as a vendor class.\n");
        return ERROR_SUCCESS;
    }

    ClassInfo.ClassName = DhcpOemToUnicode(CommandArgv[0], NULL);
    ClassInfo.ClassComment = DhcpOemToUnicode(CommandArgv[1], NULL);
    ClassInfo.ClassDataLength = strlen(CommandArgv[2]);
    ClassInfo.ClassData = (LPBYTE)CommandArgv[2];
    ClassInfo.IsVendor = GlobalIsVendor;
    ClassInfo.Flags = 0;

    Err = DhcpCreateClass(
        GlobalServerIpAddressUnicodeString,
        0,
        &ClassInfo
    );

    DhcpFreeMemory(ClassInfo.ClassName);
    DhcpFreeMemory(ClassInfo.ClassComment);

    return Err;
}


DWORD
ProcessDeleteClass(                               // delete an existing class
    IN      DWORD                  CommandArgc,
    IN      LPSTR                 *CommandArgv
)
{
    DWORD                          Err;
    LPWSTR                         ClassName;

    // usage: DeleteClass ClassName

    if( CommandArgc != 1 ) {
        printf("usage: DhcpCmd SrvIpAddress DeleteClass ClassName\n");
        return ERROR_SUCCESS;
    }

    ClassName = DhcpOemToUnicode(CommandArgv[0], NULL);
    Err = DhcpDeleteClass(
        GlobalServerIpAddressUnicodeString,
        0,
        ClassName
    );

    DhcpFreeMemory(ClassName);

    return Err;
}

VOID
PrintClassInfo(                                   // print info on a single class
    IN      LPDHCP_CLASS_INFO      Class
)
{
    DWORD                          i;

    printf("Class [%ws]:\n\tComment: %ws\n\tFlags: 0x%lx\n\tIsVendor: %s\n",
           Class->ClassName, Class->ClassComment, Class->Flags, Class->IsVendor?"TRUE":"FALSE");
    printf("\tClassData: ");
    for( i = 0; i < Class->ClassDataLength; i ++ )
        printf("%02x ", Class->ClassData[i]);
    printf("\n");
}

VOID
PrintClassInfoArray(                              // print array of classes
    IN      LPDHCP_CLASS_INFO_ARRAY Classes
)
{
    DWORD                          i;

    printf("NumClasses = %ld (0x%lx)\n", Classes->NumElements, Classes->NumElements);
    for( i = 0; i < Classes->NumElements; i ++ )
        PrintClassInfo(&Classes->Classes[i]);
}


DWORD
ProcessEnumClasses(                               // enumerate list of classes defined
    IN      DWORD                  CommandArgc,
    IN      LPSTR                 *CommandArgv
)
{
    DWORD                          Err, nRead, nTotal;
    DHCP_RESUME_HANDLE             ResumeHandle;
    LPDHCP_CLASS_INFO_ARRAY        ClassInfoArray;

    // usage: EnumClasses

    ClassInfoArray = NULL;
    ResumeHandle = 0;

    Err = DhcpEnumClasses(
        GlobalServerIpAddressUnicodeString,
        0,
        &ResumeHandle,
        0xFFFFFFFF,
        &ClassInfoArray,
        &nRead,
        &nTotal
    );

    if( ERROR_MORE_DATA == Err || ERROR_NO_MORE_ITEMS == Err ) {
        Err = ERROR_SUCCESS;
    }

    if( ERROR_SUCCESS == Err ) {
        PrintClassInfoArray(ClassInfoArray);
        DhcpRpcFreeMemory(ClassInfoArray);
    }

    return Err;
}

LPSTR
AttribString(
    IN ULONG AttribId
)
{
    switch(AttribId) {
    case DHCP_ATTRIB_BOOL_IS_ROGUE:
        return "IsRogue";
    case DHCP_ATTRIB_BOOL_IS_DYNBOOTP:
        return "DynamicBootpEnabled" ;
    case DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC:
        return "ServerPartOfDsEnabledDC" ;
    default:
        ;
    }

    return "UnknownAttribute";
}

VOID
PrintDhcpAttrib(                                  // print a server attrib
    IN      LPDHCP_ATTRIB          ServerAttrib
)
{
    if( NULL == ServerAttrib ) return;

    printf("Server Attrib %s [%ld]: ",
           AttribString(ServerAttrib->DhcpAttribId),
           ServerAttrib->DhcpAttribId );
    switch( ServerAttrib->DhcpAttribType ) {
    case DHCP_ATTRIB_TYPE_BOOL :
        printf("%s\n", ServerAttrib->DhcpAttribBool? "TRUE" : "FALSE");
        break;
    case DHCP_ATTRIB_TYPE_ULONG:
        printf("0x%lx\n", ServerAttrib->DhcpAttribUlong);
        break;
    default:
        printf("unknown attrib type\n");
        break;
    }
}

DWORD
ProcessGetServerStatus(                           // what is the server status?
    IN      DWORD                  CommandArgc,
    IN      LPSTR                 *CommandArgv
)
{
    DWORD                          Err, i;
    LPDHCP_ATTRIB_ARRAY            pDhcpAttribArr;
    DHCP_ATTRIB_ID                 Attribs[] = {
        DHCP_ATTRIB_BOOL_IS_ROGUE,
        DHCP_ATTRIB_BOOL_IS_DYNBOOTP,
        DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC
    };

    pDhcpAttribArr = NULL;
    Err = DhcpServerQueryAttributes(
        GlobalServerIpAddressUnicodeString,
        0,
        sizeof(Attribs)/sizeof(Attribs[0]),
        Attribs,
        &pDhcpAttribArr
    );

    if( ERROR_NOT_SUPPORTED == Err ) {
        Err = ERROR_SUCCESS;
    }

    if( ERROR_SUCCESS != Err ) {
        return Err;
    }

    printf("Supported Server Attributes:\n");
    if( pDhcpAttribArr ) {
        for( i = 0; i < pDhcpAttribArr->NumElements ; i ++ ) {
            PrintDhcpAttrib(&pDhcpAttribArr->DhcpAttribs[i]);
        }
        DhcpRpcFreeMemory(pDhcpAttribArr);
    }

    return ERROR_SUCCESS;
}

DWORD
ProcessRetryAuthorization(                        // what is the server status?
    IN      DWORD                  CommandArgc,
    IN      LPSTR                 *CommandArgv
)
{
    return DhcpServerRedoAuthorization(
        GlobalServerIpAddressUnicodeString,
        0
    );
}


DWORD
ProcessGetBindings(
    IN DWORD CommandArgc,
    IN LPSTR *CommandArgv
)
{
    ULONG Error, i ;
    LPDHCP_BIND_ELEMENT_ARRAY BindInfo = NULL;

    Error = DhcpGetServerBindingInfo(
        GlobalServerIpAddressUnicodeString,
        0,
        &BindInfo
        );
    if( ERROR_SUCCESS != Error ) {
        printf("Error: %ld (0x%lx)\n", Error, Error);
        return Error;
    }

    for( i = 0; i < BindInfo->NumElements ; i ++ ) {
        printf("%s \"%ws\"\n",
               BindInfo->Elements[i].fBoundToDHCPServer ? "[BOUND]  " : "[UNBOUND]" ,
               BindInfo->Elements[i].IfDescription
               );
    }

    DhcpRpcFreeMemory(BindInfo);
    return ERROR_SUCCESS;
}

DWORD
ProcessSetBinding(
    IN DWORD CommandArgc,
    IN LPSTR *CommandArgv
)
{
    ULONG Error, i ;
    BOOL Bind;
    LPDHCP_BIND_ELEMENT_ARRAY BindInfo = NULL;
    LPWSTR AdapterName;

    if( CommandArgc != 2 ) {
        printf("usage: DhcpCmd SrvIpAddress SetBinding [BIND/UNBIND] AdapterName");
        return ERROR_SUCCESS;
    }

    if( 0 == _stricmp(CommandArgv[0], "BIND") ) {
        Bind = TRUE;
    } else {
        Bind = FALSE;
    }

    AdapterName = DhcpOemToUnicode(CommandArgv[1], NULL);

    Error = DhcpGetServerBindingInfo(
        GlobalServerIpAddressUnicodeString,
        0,
        &BindInfo
        );
    if( ERROR_SUCCESS != Error ) {
        printf("Error: %ld (0x%lx)\n", Error, Error);
        return Error;
    }

    for( i = 0; i < BindInfo->NumElements ; i ++ ) {
        if( 0 == _wcsicmp(BindInfo->Elements[i].IfDescription, AdapterName)) {
            BindInfo->Elements[i].fBoundToDHCPServer = Bind;
            break;
        }
    }

    if( i == BindInfo->NumElements ) {
        printf("Requested Adapter Name not present. \n"
               "Use DhcpCmd SrvIpAddress GetBindings to view bindings.\n");
        return ERROR_SUCCESS;
    }

    Error = DhcpSetServerBindingInfo(
        GlobalServerIpAddressUnicodeString,
        0,
        BindInfo
        );
    if( ERROR_SUCCESS != Error ) {
        printf("Error: %ld (0x%lx)\n", Error, Error);
    }

    DhcpRpcFreeMemory(BindInfo);
    return ERROR_SUCCESS;
}

#define CMD_OPT_INVALID            0
#define CMD_OPT_LPWSTR             1
#define CMD_OPT_BOOL               2

struct /* anonymous */ {
    LPSTR                          CommandOptName;
    DWORD                          CommandOptType;
    LPVOID                         CommandOptStorage;
} CommandOpts[] = {
    {  "ClassName",  CMD_OPT_LPWSTR, (LPVOID)&GlobalClassName  },
    {  "VendorName", CMD_OPT_LPWSTR, (LPVOID)&GlobalVendorName },
    {  "IsVendor",   CMD_OPT_BOOL,   (LPVOID)&GlobalIsVendor   },
    {  "NoRPC",      CMD_OPT_BOOL,   (LPVOID)&GlobalNoRPC      },
    {  "NoDS",       CMD_OPT_BOOL,   (LPVOID)&GlobalNoDS       },
    {  NULL,         CMD_OPT_INVALID, NULL                     },
};

DWORD
ProcessOption(                                    // process a given option
    IN       DWORD                 Index,         // index into CommandOpts table
    IN       LPSTR                 Value          // value passed for option
)
{
    BOOL                           Val_BOOL;
    LPWSTR                         Val_LPWSTR;

    switch(CommandOpts[Index].CommandOptType ) {  // see what type we need to convert to..
    case CMD_OPT_BOOL:
        if( NULL == Value || '\0' == *Value ) {
            Val_BOOL = TRUE;                      // implicitly set value to TRUE
        } else {
            if( 0 == _stricmp(Value, "TRUE") ) {  // explicitly setting TRUE
                Val_BOOL = TRUE;
            } else if( 0 == _stricmp(Value, "FALSE" ) ) {
                Val_BOOL = FALSE;                 // explicitly setting it to FALSE
            } else {
                return ERROR_INVALID_PARAMETER;   // unknown response..
            }
        }

        *((LPBOOL)(CommandOpts[Index].CommandOptStorage)) = Val_BOOL;
        break;

    case CMD_OPT_LPWSTR:
        if( NULL == Value ) {
            Val_LPWSTR = NULL;
        } else if( '\0' == *Value ) {
            Val_LPWSTR = L"";
        } else {                                  // now convert this..
            Val_LPWSTR = DhcpOemToUnicode(Value, NULL);
        }

        *((LPWSTR *)(CommandOpts[Index].CommandOptStorage)) = Val_LPWSTR;
        break;

    default:
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    return ERROR_SUCCESS;
}

DWORD
ProcessOptions(                                  // process all options..
    IN OUT   int                  *argc,
    IN OUT   LPSTR                 argv[]
)
{
    DWORD                          Error;
    int                            i, j, k, n;
    LPSTR                          Arg, Val;

    for( i = 1; i < *argc ; i ++ ) {              // process each option
        if( argv[i][0] != '/' && argv[i][0] != '-' ) {
            continue;                             // not an option
        }

        Arg = argv[i];                            // an option to process
        Arg ++;                                   // skip leading '/' or '-'
        Val = strchr(Arg, ':');                   // see if it is of form /Option:Value
        if( Val ) {                               // yup!
            *Val = '\0';                          // terminate Arg..
            Val++;                                // now Val points to value in /Option:Value
        }

        for( j = 0; CommandOpts[j].CommandOptName ; j ++ ) {
            if( 0 == _stricmp(Arg, CommandOpts[j].CommandOptName) ) {
                break;                            // found a match!
            }
        }

        if( NULL ==  CommandOpts[j].CommandOptName ) {
            if( Val ) Val[-1] = ':';              // give back the colon we stole..
            continue;
        }

        for( k = i + 1; k < *argc ; k ++ ) {      // remove this arg and slide the rest
            argv[k-1] = argv[k];
        }
        i -- ; (*argc) --;

        Error = ProcessOption( j, Val );          // now process it
        if( ERROR_SUCCESS != Error ) {            // ouch?
            DhcpPrint((0xFFFF, "Could not process option: /%s:%s\n", Arg, Val));
            return Error;
        }
    }

    return ERROR_SUCCESS;
}

VOID
CleanupOptions(
    VOID
)
{
    DWORD                          i;
    LPWSTR                         String;

    for( i = 0; CommandOpts[i].CommandOptName ; i ++ ) {
        switch(CommandOpts[i].CommandOptType ) {
        case CMD_OPT_BOOL:
            // nothing to free
            break;
        case CMD_OPT_LPWSTR:
            // need to free string space used..
            String = *((LPWSTR *)CommandOpts[i].CommandOptStorage);
            if( NULL != String ) DhcpFreeMemory(String);
            break;
        }
    }

    // done!
}
#endif NT5

#ifdef NT5
#define OPTIONS_STRING "[Options]"
#else
#define OPTIONS_STRING
#endif

DWORD __cdecl
main(
    int argc,
    char **argv
    )
{
    DWORD Error, ThreadOptions;
    COMMAND_CODE CommandCode;
    DWORD CommandArgc;
    LPSTR *CommandArgv;

    INIT_DEBUG_HEAP( HEAPX_VERIFY );

    Error = ERROR_SUCCESS;
#ifdef NT5
    Error = ProcessOptions(&argc, argv);
#endif NT5

    if( ERROR_SUCCESS != Error || argc < 3 ) {
        printf("usage:DhcpCmd SrvIpAddress" OPTIONS_STRING  "Command [Command Parameters].\n");
        printf("Commands : \n");
        PrintCommands();
#ifdef NT5
        printf("Options: \n");
        printf("\t/ClassName:<string>  -- [default NULL] specify class name wherever applicable.\n");
        printf("\t/VendorName:<string> -- [default NULL] specify vendor name wherever applicable.\n");
        printf("\t/IsVendor:TRUE/FALSE -- [default FALSE] specify that option being referred as vendor.\n");
        printf("\t/NoRPC:TRUE/FALSE    -- [default FALSE] specify that no RPC calls should be made.\n");
        printf("\t/NoDS:TRUE/FALSE     -- [default TRUE]  specify that no DS calls should be made.\n");
        printf("\n\n");
#endif NT5
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    GlobalServerIpAddressAnsiString = argv[1];
    GlobalServerIpAddressUnicodeString =
        DhcpOemToUnicode( GlobalServerIpAddressAnsiString, NULL );

    if( GlobalServerIpAddressUnicodeString == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        printf("Insufficient memory\n");
        goto Cleanup;
    }

    GlobalServerIpAddressAnsiString = argv[1];

    CommandCode = DecodeCommand( argv[2] );
    if( CommandCode == UnknownCommand ) {
        Error = ERROR_INVALID_PARAMETER;
        printf("Unknown Command Specified.\n");
        goto Cleanup;
    }

    if( FALSE == GlobalNoRPC ) {
        Error = ProcessGetVersion( &g_dwMajor, &g_dwMinor );
        if ( ERROR_SUCCESS != Error ) {
            printf("Unable to determine server version.\n" );
            goto Cleanup;
        }
    } else {
        Error = ERROR_SUCCESS;
    }

    if ( FALSE == GlobalNoRPC && !IsValidServerVersion( g_dwMajor, g_dwMinor ) ) {
        printf( "This version of %s works with Microsoft DHCP server"
                " running on Windows NT Server version %d.%d or later.\n",
                argv[0],
                DHCPCMD_VERSION_MAJOR,
                DHCPCMD_VERSION_MINOR
        );
        Error = ERROR_OLD_WIN_VERSION;
        goto Cleanup;
    }

    CommandArgc = (DWORD)(argc - 3);
    CommandArgv = &argv[3];

#ifdef NT5
    Error = ERROR_SUCCESS;
    if( FALSE == GlobalNoDS ) Error = DhcpDsInit();
    if( ERROR_SUCCESS != Error && FALSE == GlobalNoDS ) {
        printf("DhcpDsInit() failed %ld (0x%lx), but continuing ..\n", Error, Error);
        printf("This indicates that either your machine is part of a work group\n");
        printf("or that your DS is unreachable\n");
    }

    Error = ERROR_SUCCESS;

    ThreadOptions = 0;
    if( GlobalNoRPC ) ThreadOptions |= DHCP_FLAGS_DONT_DO_RPC;
    if( GlobalNoDS ) ThreadOptions |= DHCP_FLAGS_DONT_ACCESS_DS;
    DhcpSetThreadOptions(ThreadOptions, 0);

#endif NT5

    switch( CommandCode ) {
    case AddIpRange:
        Error = ProcessAddIpRange( CommandArgc, CommandArgv );
        break;

    case RemoveIpRange:
        Error = ProcessRemoveIpRange( CommandArgc, CommandArgv );
        break;

#ifdef NT5
    case EnumIpRanges:
        Error = ProcessEnumIpRanges( CommandArgc, CommandArgv );
        break;
#endif NT5

    case AddReservedIp:
        Error = ProcessAddReservedIp( CommandArgc, CommandArgv );
        break;

    case EnumClients:
        Error = ProcessEnumClients( CommandArgc, CommandArgv );
        break;

#ifdef NT5
    case EnumClientsV5:
        Error = ProcessEnumClientsV5( CommandArgc, CommandArgv );
        break;
#endif NT5

    case MibCounts:
        Error = ProcessMibCounts( CommandArgc, CommandArgv );
        break;

    case ServerConfig:
        Error = ProcessServerConfig( CommandArgc, CommandArgv );
        break;

    case GetDhcpVersion:
        Error = ProcessGetVersion( &g_dwMajor, &g_dwMinor );
        break;

    case SetSuperScope:
        Error = ProcessSetSuperScope( CommandArgc, CommandArgv );
        break;

    case RemoveSubscope:
        Error = ProcessRemoveSubscope( CommandArgc, CommandArgv );
        break;

    case DeleteSuperScope:
        Error = ProcessDeleteSuperScope( CommandArgc, CommandArgv );
        break;

    case GetSuperScopeTable:
        Error = ProcessGetSuperScopeTable( CommandArgc, CommandArgv );
        break;

    case CheckDB:
        Error = ProcessCheckDB( CommandArgc, CommandArgv );
        break;

    case CreateSubnet:
        Error = ProcessCreateSubnet( CommandArgc, CommandArgv );
        break;

    case DeleteSubnet:
        Error = ProcessDeleteSubnet( CommandArgc, CommandArgv );
        break;

    case AddExcludeRange:
        Error = ProcessAddExcludeRange( CommandArgc, CommandArgv );
        break;

    case RemoveReservedIp:
        Error = ProcessRemoveReservedIp( CommandArgc, CommandArgv );
        break;

    case RemoveExcludeRange:
        Error = ProcessRemoveExcludeRange( CommandArgc, CommandArgv );
        break;

    case SetSubnetState:
        Error = ProcessSetSubnetState( CommandArgc, CommandArgv );
        break;

    case CreateOption:
        Error = ProcessCreateOption( CommandArgc, CommandArgv );
        break;

    case DeleteOption:
        Error = ProcessDeleteOption( CommandArgc, CommandArgv );
        break;

    case SetGlobalOptionValue:
        Error = ProcessSetGlobalOptionValue( CommandArgc, CommandArgv );
        break;

    case SetGlobalOptionValues:
        Error = ProcessSetGlobalOptionValues( CommandArgc, CommandArgv );
        break;

    case RemoveGlobalOptionValue:
        Error = ProcessRemoveGlobalOptionValue( CommandArgc, CommandArgv );
        break;

    case SetSubnetOptionValue:
        Error = ProcessSetSubnetOptionValue( CommandArgc, CommandArgv );
        break;

    case RemoveSubnetOptionValue:
        Error = ProcessRemoveSubnetOptionValue( CommandArgc, CommandArgv );
        break;

    case SetReservedOptionValue:
        Error = ProcessSetReservedOptionValue( CommandArgc, CommandArgv );
        break;

    case RemoveReservedOptionValue:
        Error = ProcessRemoveReservedOptionValue( CommandArgc, CommandArgv );
        break;

    case EnumOptions:
        Error = ProcessEnumOptions( CommandArgc, CommandArgv );
        break;

#ifdef NT5
    case GetAllOptions:
        Error = ProcessGetAllOptions( CommandArgc, CommandArgv );
        break;

    case GetAllOptionValues:
        Error = ProcessGetAllOptionValues( CommandArgc, CommandArgv );
        break;

    case CreateMScope:
        Error = ProcessCreateMScope( CommandArgc, CommandArgv );
        break;

    case DeleteMScope:
        Error = ProcessDeleteMScope( CommandArgc, CommandArgv );
        break;

    case AddMScopeRange:
        Error = ProcessAddMScopeIpRange( CommandArgc, CommandArgv );
        break;

    case EnumMScopeClients:
        Error = ProcessEnumMScopeClients( CommandArgc, CommandArgv );
        break;

    case ReconcileMScope:
        Error = ProcessReconcileMScope( CommandArgc, CommandArgv );
        break;

    case EnumMScopes:
        Error = ProcessEnumMScopes( CommandArgc, CommandArgv );
        break;

    case MCastMibCounts:
        Error = ProcessMCastMibCounts( CommandArgc, CommandArgv );
        break;

    case EnumServers:
        Error = ProcessEnumServers( CommandArgc, CommandArgv );
        break;

    case AddServer:
        Error = ProcessAddServer( CommandArgc, CommandArgv );
        break;

    case DelServer:
        Error = ProcessDelServer( CommandArgc, CommandArgv );
        break;

    case CreateClass:
        Error = ProcessCreateClass( CommandArgc, CommandArgv );
        break;

    case DeleteClass:
        Error = ProcessDeleteClass( CommandArgc, CommandArgv );
        break;

    case EnumClasses:
        Error = ProcessEnumClasses( CommandArgc, CommandArgv );
        break;

    case GetServerStatus:
        Error = ProcessGetServerStatus( CommandArgc, CommandArgv );
        break;

    case RetryAuthorization:
        Error = ProcessRetryAuthorization(CommandArgc, CommandArgv);
        break;

    case DeleteBadClients:
        Error = ProcessDeleteBadClients(CommandArgc, CommandArgv);
        break;

    case DeleteClient:
        Error = ProcessDeleteClient(CommandArgc, CommandArgv);
        break;

    case GetBindings:
        Error = ProcessGetBindings(CommandArgc, CommandArgv);
        break;

    case SetBinding:
        Error = ProcessSetBinding(CommandArgc, CommandArgv);
        break;

#endif NT5

    case UnknownCommand:
    default:
        DhcpAssert( FALSE );
        Error = ERROR_INVALID_PARAMETER;
        printf("Unknown Command Specified.\n");
        goto Cleanup;
    }

Cleanup:

#ifdef NT5
    DhcpDsCleanup();
#endif NT5

    if( GlobalServerIpAddressUnicodeString != NULL ) {
        DhcpFreeMemory( GlobalServerIpAddressUnicodeString );
    }

#ifdef NT5
    CleanupOptions();
#endif NT5

    if( Error != ERROR_SUCCESS ) {
        printf("Command failed, %ld.\n", Error );
        return(1);
    }

    UNINIT_DEBUG_HEAP();
    printf("Command successfully completed.\n");

    return(0);
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\client\dhcp_clt.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC client stubs */


 /* File created by MIDL compiler version 6.00.0323 */
/* Compiler settings for dhcp_cli.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust dhcp_bug_compatibility
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#include <string.h>
#if defined( _ALPHA_ )
#include <stdarg.h>
#endif

#include "dhcp_cli.h"

#define TYPE_FORMAT_STRING_SIZE   1547                              
#define PROC_FORMAT_STRING_SIZE   2359                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

#define GENERIC_BINDING_TABLE_SIZE   1            


/* Standard interface: dhcpsrv, ver. 1.0,
   GUID={0x6BFFD098,0xA112,0x3610,{0x98,0x33,0x46,0xC3,0xF8,0x74,0x53,0x2D}} */

handle_t dhcpsrv_bhandle;


static const RPC_CLIENT_INTERFACE dhcpsrv___RpcClientInterface =
    {
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x6BFFD098,0xA112,0x3610,{0x98,0x33,0x46,0xC3,0xF8,0x74,0x53,0x2D}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    0,
    0,
    0,
    0,
    0,
    0x00000000
    };
RPC_IF_HANDLE dhcpsrv_ClientIfHandle = (RPC_IF_HANDLE)& dhcpsrv___RpcClientInterface;

extern const MIDL_STUB_DESC dhcpsrv_StubDesc;

static RPC_BINDING_HANDLE dhcpsrv__MIDL_AutoBindHandle;


DWORD R_DhcpCreateSubnet( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_INFO SubnetInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SubnetInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetSubnetInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_INFO SubnetInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SubnetInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[54],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[54],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetSubnetInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [out] */ LPDHCP_SUBNET_INFO __RPC_FAR *SubnetInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SubnetInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[108],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[108],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnets( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_IP_ARRAY __RPC_FAR *EnumInfo,
    /* [out] */ DWORD __RPC_FAR *ElementsRead,
    /* [out] */ DWORD __RPC_FAR *ElementsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ElementsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[162],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[162],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpAddSubnetElement( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_ELEMENT_DATA AddElementInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,AddElementInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[234],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[234],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnetElements( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [in] */ DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_SUBNET_ELEMENT_INFO_ARRAY __RPC_FAR *EnumElementInfo,
    /* [out] */ DWORD __RPC_FAR *ElementsRead,
    /* [out] */ DWORD __RPC_FAR *ElementsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ElementsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[288],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[288],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpRemoveSubnetElement( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_ELEMENT_DATA RemoveElementInfo,
    /* [in] */ DHCP_FORCE_FLAG ForceFlag)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ForceFlag);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[372],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[372],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpDeleteSubnet( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [in] */ DHCP_FORCE_FLAG ForceFlag)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ForceFlag);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[432],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[432],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpCreateOption( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION OptionInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[486],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[486],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetOptionInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION OptionInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[540],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[540],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetOptionInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [out] */ LPDHCP_OPTION __RPC_FAR *OptionInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[594],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[594],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpRemoveOption( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionID);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[648],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[648],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetOptionValue( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    /* [ref][in] */ LPDHCP_OPTION_DATA OptionValue)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionValue);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[696],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[696],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetOptionValue( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    /* [out] */ LPDHCP_OPTION_VALUE __RPC_FAR *OptionValue)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionValue);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[756],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[756],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumOptionValues( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_OPTION_VALUE_ARRAY __RPC_FAR *OptionValues,
    /* [out] */ DWORD __RPC_FAR *OptionsRead,
    /* [out] */ DWORD __RPC_FAR *OptionsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[816],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[816],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpRemoveOptionValue( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_OPTION_ID OptionID,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ScopeInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[894],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[894],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpCreateClientInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_CLIENT_INFO ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[948],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[948],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetClientInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_CLIENT_INFO ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[996],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[996],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetClientInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_SEARCH_INFO SearchInfo,
    /* [out] */ LPDHCP_CLIENT_INFO __RPC_FAR *ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1044],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1044],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpDeleteClientInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_SEARCH_INFO ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1098],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1098],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnetClients( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_CLIENT_INFO_ARRAY __RPC_FAR *ClientInfo,
    /* [out] */ DWORD __RPC_FAR *ClientsRead,
    /* [out] */ DWORD __RPC_FAR *ClientsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1146],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1146],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetClientOptions( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS ClientIpAddress,
    /* [in] */ DHCP_IP_MASK ClientSubnetMask,
    /* [out] */ LPDHCP_OPTION_LIST __RPC_FAR *ClientOptions)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientOptions);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1224],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1224],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetMibInfo( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDHCP_MIB_INFO __RPC_FAR *MibInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,MibInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1284],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1284],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumOptions( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_OPTION_ARRAY __RPC_FAR *Options,
    /* [out] */ DWORD __RPC_FAR *OptionsRead,
    /* [out] */ DWORD __RPC_FAR *OptionsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1332],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1332],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetOptionValues( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    /* [ref][in] */ LPDHCP_OPTION_VALUE_ARRAY OptionValues)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,OptionValues);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1404],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1404],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpServerSetConfig( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DWORD FieldsToSet,
    /* [ref][in] */ LPDHCP_SERVER_CONFIG_INFO ConfigInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ConfigInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1458],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1458],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpServerGetConfig( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDHCP_SERVER_CONFIG_INFO __RPC_FAR *ConfigInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ConfigInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1512],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1512],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpScanDatabase( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [in] */ DWORD FixFlag,
    /* [out] */ LPDHCP_SCAN_LIST __RPC_FAR *ScanList)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ScanList);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1560],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1560],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetVersion( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDWORD MajorVersion,
    /* [out] */ LPDWORD MinorVersion)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,MinorVersion);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1620],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1620],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpAddSubnetElementV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_ELEMENT_DATA_V4 AddElementInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,AddElementInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1674],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1674],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnetElementsV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [in] */ DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 __RPC_FAR *EnumElementInfo,
    /* [out] */ DWORD __RPC_FAR *ElementsRead,
    /* [out] */ DWORD __RPC_FAR *ElementsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ElementsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1728],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1728],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpRemoveSubnetElementV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [ref][in] */ LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    /* [in] */ DHCP_FORCE_FLAG ForceFlag)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ForceFlag);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1812],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1812],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpCreateClientInfoV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_CLIENT_INFO_V4 ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1872],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1872],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetClientInfoV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_CLIENT_INFO_V4 ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1920],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1920],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetClientInfoV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [ref][in] */ LPDHCP_SEARCH_INFO SearchInfo,
    /* [out] */ LPDHCP_CLIENT_INFO_V4 __RPC_FAR *ClientInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1968],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1968],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpEnumSubnetClientsV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [out][in] */ DHCP_RESUME_HANDLE __RPC_FAR *ResumeHandle,
    /* [in] */ DWORD PreferredMaximum,
    /* [out] */ LPDHCP_CLIENT_INFO_ARRAY_V4 __RPC_FAR *ClientInfo,
    /* [out] */ DWORD __RPC_FAR *ClientsRead,
    /* [out] */ DWORD __RPC_FAR *ClientsTotal)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ClientsTotal);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2022],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2022],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpSetSuperScopeV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DHCP_IP_ADDRESS SubnetAddress,
    /* [string][unique][in] */ WCHAR __RPC_FAR *SuperScopeName,
    /* [in] */ BOOL ChangeExisting)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ChangeExisting);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2100],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2100],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpGetSuperScopeInfoV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDHCP_SUPER_SCOPE_TABLE __RPC_FAR *SuperScopeTable)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SuperScopeTable);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2160],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2160],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpDeleteSuperScopeV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [string][ref][in] */ WCHAR __RPC_FAR *SuperScopeName)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,SuperScopeName);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2208],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2208],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpServerSetConfigV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [in] */ DWORD FieldsToSet,
    /* [ref][in] */ LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ConfigInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2256],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2256],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}


DWORD R_DhcpServerGetConfigV4( 
    /* [string][unique][in] */ DHCP_SRV_HANDLE ServerIpAddress,
    /* [out] */ LPDHCP_SERVER_CONFIG_INFO_V4 __RPC_FAR *ConfigInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    
#if defined( _ALPHA_ )
    va_list vlist;
#endif
    
#if defined( _ALPHA_ )
    va_start(vlist,ConfigInfo);
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2310],
                  vlist.a0);
#else
    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&dhcpsrv_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2310],
                  ( unsigned char __RPC_FAR * )&ServerIpAddress);
#endif
    return ( DWORD  )_RetVal.Simple;
    
}

extern const GENERIC_BINDING_ROUTINE_PAIR BindingRoutines[ GENERIC_BINDING_TABLE_SIZE ];
extern const EXPR_EVAL ExprEvalRoutines[];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 Professional or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure R_DhcpCreateSubnet */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
#ifndef _ALPHA_
/*  8 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 10 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 12 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 14 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 22 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 30 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 32 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 34 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 36 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 38 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 42 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 44 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 46 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 48 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 50 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 52 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetSubnetInfo */

/* 54 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 56 */	NdrFcLong( 0x0 ),	/* 0 */
/* 60 */	NdrFcShort( 0x1 ),	/* 1 */
#ifndef _ALPHA_
/* 62 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 64 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 66 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 68 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 70 */	NdrFcShort( 0x8 ),	/* 8 */
/* 72 */	NdrFcShort( 0x8 ),	/* 8 */
/* 74 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 76 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 78 */	NdrFcShort( 0x0 ),	/* 0 */
/* 80 */	NdrFcShort( 0x0 ),	/* 0 */
/* 82 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 84 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 86 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 88 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 90 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 92 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 94 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 96 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 98 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 100 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 102 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 104 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 106 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetSubnetInfo */

/* 108 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 110 */	NdrFcLong( 0x0 ),	/* 0 */
/* 114 */	NdrFcShort( 0x2 ),	/* 2 */
#ifndef _ALPHA_
/* 116 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 118 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 120 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 122 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 124 */	NdrFcShort( 0x8 ),	/* 8 */
/* 126 */	NdrFcShort( 0x8 ),	/* 8 */
/* 128 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 130 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x0 ),	/* 0 */
/* 136 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 138 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 140 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 142 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 144 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 146 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 148 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 150 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 152 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 154 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */

	/* Return value */

/* 156 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 158 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 160 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnets */

/* 162 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 164 */	NdrFcLong( 0x0 ),	/* 0 */
/* 168 */	NdrFcShort( 0x3 ),	/* 3 */
#ifndef _ALPHA_
/* 170 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/*